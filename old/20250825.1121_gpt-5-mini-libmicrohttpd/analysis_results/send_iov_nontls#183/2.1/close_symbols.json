{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SENDMSG",
    "HAVE_WRITEV",
    "MHD_WINSOCK_SOCKETS",
    "_MHD_IOV_MAX",
    "MHD_USE_MSG_MORE",
    "_WIN64",
    "EPOLL_SUPPORT",
    "MHD_USE_TLS",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "struct MHD_Connection (fields: socket_fd, state, daemon, epoll_state)",
    "connection->daemon->options",
    "struct MHD_iovec_track_ (fields: cnt, sent, iov)",
    "type of r_iov->iov elements (struct iovec on POSIX or WSABUF on Win32): fields iov_base, iov_len and typedef MHD_iov_size_",
    "sendmsg() / writev() / WSASend() return conventions and semantics",
    "MSG_NOSIGNAL_OR_ZERO",
    "MSG_MORE",
    "MHD_socket_get_error_",
    "socket-error macros and constants: MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_, MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_ERR_IS_LOW_RESOURCES_, MHD_SCKT_EBADF_",
    "UINT32_MAX (and DWORD semantics on Win32)",
    "pre_send_setopt",
    "post_send_setopt",
    "mhd_assert"
  ],
  "explanation": "To judge whether any lines in send_iov_nontls are unreachable you must know which compile-time branches are present and which runtime conditions can occur. The listed symbols are required for that reasoning:\n\n- HAVE_SENDMSG, HAVE_WRITEV, MHD_WINSOCK_SOCKETS: these #ifdefs select mutually exclusive large blocks (sendmsg / writev / WSASend). Whether any of those blocks exist (and thus whether later code inside them can be reached) depends on these macros.\n- _MHD_IOV_MAX: controls the items_to_send truncation block; its presence and numeric value determine whether the truncation branch (and the push_data=false path) can be taken (or is compile-time omitted), affecting reachability.\n- MHD_USE_MSG_MORE and MSG_MORE / MSG_NOSIGNAL_OR_ZERO: affect which flags are passed to sendmsg and thus are needed to reason about code guarded by MHD_USE_MSG_MORE and the semantics of the send call (not strictly reachability by itself but tied to the sendmsg call inclusion).\n- _WIN64, UINT32_MAX, DWORD semantics: determine whether the Win32-specific cnt_w truncation path is compiled and whether the branch that casts and reduces items_to_send can be entered.\n- EPOLL_SUPPORT: controls presence of code that clears EPOLL_STATE_WRITE_READY; if EPOLL_SUPPORT is not defined those statements are not present (affects reachability of those statements).\n- MHD_USE_TLS and mhd_assert: the assertion inspects connection->daemon->options & MHD_USE_TLS \u2014 while assert does not alter control flow in production builds, you must know MHD_USE_TLS and daemon->options to reason whether the assert documents an always-true/false condition (helpful when checking for dead code assumptions).\n- MHD_INVALID_SOCKET and MHD_CONNECTION_CLOSED and struct MHD_Connection (socket_fd, state, daemon, epoll_state): the initial early-return depends on these values; to determine whether the body is ever reachable you need their definitions and the connection fields used.\n- struct MHD_iovec_track_ (cnt, sent, iov) and the iov element type (iov_base, iov_len) plus MHD_iov_size_: the loop that advances r_iov->sent and updates iov_base/iov_len is the core of the function; to know if that loop or its branches can execute you must know the possible relationships between cnt, sent, and iov[].iov_len (types and sizes matter for comparisons and pointer arithmetic).\n- sendmsg(), writev(), WSASend() return conventions and semantics: reachability of the error-handling block (res < 0) versus the 'some data has been sent' block depends on the documented return values of the invoked system call used on the target platform.\n- MHD_socket_get_error_ and the socket-error macros/constants (MHD_SCKT_ERR_IS_*, MHD_SCKT_EPIPE_, etc.): the many mutually exclusive error branches in the res < 0 block are only reachable if MHD_socket_get_error_ can yield error values that make the corresponding predicates true. You need those predicates and the range of possible error codes to see whether any error-case branches are impossible.\n- pre_send_setopt and post_send_setopt: they are called in several places; their presence or side effects do not directly mark code unreachable, but you must know whether they can longjmp/abort or otherwise alter control flow (or be empty) to assess reachability of subsequent code.\n\nCollectively, these compile-time macros, types, system-call semantics, and error-predicate helpers are required to decide whether any conditional/alternate block in send_iov_nontls can never be compiled in or can never be executed at runtime \u2014 which is the essential information to determine violations of the \"no unreachable code\" MISRA rule."
}