{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ssize_t",
    "size_t",
    "uint64_t",
    "int64_t",
    "uintptr_t",
    "off_t",
    "SSIZE_MAX",
    "INT32_MAX",
    "SEEK_SET",
    "struct MHD_Response (fields: fd, fd_off)",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "pread64",
    "pread",
    "lseek64",
    "lseek",
    "read",
    "HAVE_PREAD64",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "_WIN32",
    "__CYGWIN__",
    "_get_osfhandle",
    "HANDLE",
    "INVALID_HANDLE_VALUE",
    "OVERLAPPED",
    "ULARGE_INTEGER",
    "DWORD",
    "ReadFile"
  ],
  "explanation": "For each listed symbol indicate whether it is part of standard ISO C, a C standard-library (C99) feature, a POSIX API, or a platform/compiler/library extension. The target function mixes POSIX APIs, C99 types, and Win32 APIs behind conditional compilation; to decide if the code uses language/compiler extensions you must know the provenance of each referenced symbol:\n\n- ssize_t: POSIX type (not ISO C); needed to decide if its use is an extension.\n- size_t: standard C type; included to confirm this is not an extension.\n- uint64_t, int64_t, uintptr_t: C99 (stdint.h) types \u2014 confirm whether C99 is allowed or treated as an extension by the toolchain/MISRA interpretation.\n- off_t: POSIX file-offset type; may be implementation-defined/extension \u2014 needed to assess casts and use with pread/lseek.\n- SSIZE_MAX, INT32_MAX, SEEK_SET: macros from limits/headers (POSIX/stdint); needed to check if they are standard or extensions when used for clamps/limits.\n- struct MHD_Response (fd and fd_off fields): the MHD library's response structure \u2014 required to know the types of response->fd and response->fd_off (e.g. int vs 64-bit) to judge casts and platform-specific code paths.\n- MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM: MHD-return constants \u2014 needed to see whether they are macros/enum values and whether their definitions rely on non-standard constructs.\n- pread64, pread, lseek64, lseek, read: POSIX/GNU file I/O functions. pread64 and lseek64 are often non-standard extensions (GNU); required to determine if the code conditionally uses extensions.\n- HAVE_PREAD64, HAVE_PREAD, HAVE_LSEEK64: build-time feature macros that select use of extensions \u2014 required to understand when extension APIs are compiled in.\n- _WIN32, __CYGWIN__: platform feature macros controlling compilation of Win32 vs POSIX paths \u2014 needed to determine which API set (and possible extensions) is used.\n- _get_osfhandle: Microsoft CRT function to obtain an OS HANDLE from a file descriptor \u2014 a platform-specific/CRT extension; required to identify Windows-only extension usage.\n- HANDLE, INVALID_HANDLE_VALUE, OVERLAPPED, ULARGE_INTEGER, DWORD, ReadFile: Win32 types/constants/APIs used in the Windows code path \u2014 all are platform-specific (non-ISO-C) and must be considered extensions for MISRA analysis.\n\nIn short: to decide whether the function violates the 'no language extensions' rule you must inspect each of the above symbols' definitions or provenance to determine whether they are ISO C, optional C99, POSIX, or platform/compiler/library extensions. The MHD-specific symbols are needed to check how the library defines/uses types or macros that could introduce non-standard constructs."
}