{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of check_param__poll:\n```c\nstatic int\ncheck_param__poll (void)\n{\n  if (! tool_params.poll)\n    return ! 0;\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_POLL))\n  {\n    fprintf (stderr, \"poll() was requested, but this MHD build does not \"\n             \"support polling by poll().\\n\");\n    return 0;\n  }\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function check_param__poll:\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the provided target function check_param__poll and the related MHD_is_feature_supported definitions. None of the code fragments contain any calls to memcmp, nor do they perform string comparisons using memcmp. All comparisons are against enum values (e.g. MHD_NO, MHD_YES, MHD_FEATURE_POLL) or use literals and conditional compilation; there are no operations that compare null-terminated strings with memcmp (neither directly nor via macros or wrapper functions in the supplied snippets). Therefore there are no fragments that need investigation for violation of MISRA C 2023 Rule 21.14 in the provided code."
}