{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password3 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password3.\n```c\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression params->token68.str is passed as the (read\u2011only) base64 input. Because params is declared as const struct MHD_RqBAuth *params, the member access yields a pointer of type like \"char * const\" (i.e. the pointer itself is const but it points to non\u2011const char). The code treats the buffer as immutable input to MHD_base64_to_bin_n and does not modify the characters; per MISRA C 2023 Rule 8.13 the pointer should therefore point to a const\u2011qualified type (e.g. const char *). If the token68.str member is declared as char * (or char *const when accessed through a const struct), that is a violation \u2014 token68.str should be declared as const char * to comply. (If token68.str is already declared as const char * in the struct, then no violation occurs.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_basic_auth_get_username_password3:\nstruct MHD_BasicAuthInfo\n{\n  /**\n   * The username, cannot be NULL.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username, not including zero-termination\n   */\n  size_t username_len;\n\n  /**\n   * The password, may be NULL if password is not encoded by the client.\n   * The buffer pointed by the @a password becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *password;\n\n  /**\n   * The length of the @a password, not including zero-termination;\n   * when the @a password is NULL, the length is always zero.\n   */\n  size_t password_len;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation is technically correct in principle but cannot be confirmed from the code shown. MISRA C:2023 Rule 8.13 recommends that pointers should point to const-qualified types when the pointed-to object is not modified. In this function params is a const struct MHD_RqBAuth *, so the struct\u2019s members are not modifiable through params, but that does not automatically make pointer members point to const data \u2014 if token68.str is declared as char * in the definition of MHD_RqBAuth then the expression params->token68.str has type char * const (a const pointer to non-const char). The function treats the buffer as read-only (passes it to a decoder and never modifies the bytes), so per Rule 8.13 the member would be better declared as const char *; if token68.str is indeed declared as plain char * then Agent A\u2019s report of a Rule 8.13 violation is correct. However the definition of MHD_RqBAuth (and the declaration of token68.str) was not provided, so you cannot definitively conclude a violation from the code shown. If token68.str is already declared const char * then there is no violation."
}