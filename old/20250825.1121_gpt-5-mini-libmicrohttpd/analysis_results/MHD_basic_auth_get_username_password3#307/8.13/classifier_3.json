{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_basic_auth_get_username_password3:\n```c\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_basic_auth_get_username_password3:\nstruct MHD_BasicAuthInfo\n{\n  /**\n   * The username, cannot be NULL.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username, not including zero-termination\n   */\n  size_t username_len;\n\n  /**\n   * The password, may be NULL if password is not encoded by the client.\n   * The buffer pointed by the @a password becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *password;\n\n  /**\n   * The length of the @a password, not including zero-termination;\n   * when the @a password is NULL, the length is always zero.\n   */\n  size_t password_len;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ndecoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len, decoded, decoded_max_len);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The expression params->token68.str is passed as the (read\u2011only) base64 input. Because params is declared as const struct MHD_RqBAuth *params, the member access yields a pointer of type like \"char * const\" (i.e. the pointer itself is const but it points to non\u2011const char). The code treats the buffer as immutable input to MHD_base64_to_bin_n and does not modify the characters; per MISRA C 2023 Rule 8.13 the pointer should therefore point to a const\u2011qualified type (e.g. const char *). If the token68.str member is declared as char * (or char *const when accessed through a const struct), that is a violation \u2014 token68.str should be declared as const char * to comply. (If token68.str is already declared as const char * in the struct, then no violation occurs.)"
}