{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_basic_auth_get_username_password3': {'callees': ['MHD_get_rq_bauth_params_', 'MHD_base64_to_bin_n', 'MHD_DLOG'], 'callers': ['MHD_basic_auth_get_username_password', 'ahc_echo', 'answer_to_connection']}, 'MHD_get_rq_bauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_bauth_params'], 'callers': ['MHD_basic_auth_get_username_password3']}, 'MHD_base64_to_bin_n': {'callees': [], 'callers': ['MHD_basic_auth_get_username_password3']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_basic_auth_get_username_password': {'callees': ['MHD_basic_auth_get_username_password3', 'MHD_DLOG'], 'callers': []}, 'ahc_echo': {'callees': ['MHD_queue_response', 'MHD_create_response_from_callback', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_create_response_empty', 'MHD_lookup_connection_value', 'MHD_create_response_from_buffer_with_free_callback', 'MHD_create_response_from_fd64', 'MHD_create_response_from_buffer', 'MHD_create_response_from_buffer_copy', 'MHD_suspend_connection', 'MHD_digest_auth_check3', 'MHD_queue_auth_required_response3', 'MHD_basic_auth_get_username_password3', 'MHD_queue_basic_auth_required_response3', 'MHD_free', 'MHD_create_response_for_upgrade', 'can_compress', 'body_compress'], 'callers': []}, 'answer_to_connection': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_queue_response', 'MHD_destroy_response', 'MHD_get_connection_values', 'MHD_create_response_from_fd_at_offset64', 'MHD_basic_auth_get_username_password3', 'MHD_queue_basic_auth_required_response3', 'MHD_free', 'MHD_create_post_processor', 'send_page', 'MHD_post_process'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "struct MHD_BasicAuthInfo",
    "struct MHD_RqBAuth",
    "token68 (member type inside MHD_RqBAuth)",
    "MHD_get_rq_bauth_params_",
    "MHD_base64_max_dec_size_",
    "MHD_base64_to_bin_n",
    "mhd_assert",
    "MHD_DLOG",
    "_ (translation macro)",
    "HAVE_MESSAGES"
  ],
  "explanation": "For checking use of compiler/language extensions you must inspect any macros, type definitions or function declarations that can hide compiler-specific extensions (for example __attribute__, __declspec, zero-length arrays, statement-expressions, typeof, nested functions, asm, etc.). Each listed symbol may expand to or be defined using such extensions, so their definitions are required:\n\n- _MHD_EXTERN: This is a macro used on the function declaration. It often expands to linkage/visibility attributes (e.g. __attribute__((visibility(...))) or __declspec), which are explicit compiler extensions. Inspecting its definition is necessary to detect such extensions.\n\n- struct MHD_BasicAuthInfo: The code allocates sizeof(struct MHD_BasicAuthInfo) + decoded_max_len + 1 and then uses (ret + 1) to access storage following the struct. The struct definition may use flexible-array members (C99 feature) or a zero-length array (a common GCC extension), or may have attribute-annotated fields. You must see the struct to determine if a nonstandard zero-length array or other extension is used.\n\n- struct MHD_RqBAuth: The function reads params->token68.str and params->token68.len. The RqBAuth type (and any nested types) might be defined using extensions (bitfields with nonstandard widths, attributes, packed structs, anonymous structs/unions, etc.). Its definition is needed to detect such constructs.\n\n- token68 (member type inside MHD_RqBAuth): The token68 member's type (e.g. a struct or union) might itself use extensions (anonymous union, zero-length array, or attributes). Explicitly inspect that member type.\n\n- MHD_get_rq_bauth_params_: Declaration/definition may be a macro or inline function using compiler extensions (e.g. inline semantics, __attribute__, statement expressions). The analysis should inspect its definition to ensure no extensions are pulled into the call site.\n\n- MHD_base64_max_dec_size_: Could be a macro or inline function. Macros can contain GCC extensions (statement-expressions, typeof), so its definition must be checked.\n\n- MHD_base64_to_bin_n: Its prototype/definition should be checked for any attributes (e.g. nonstandard calling conventions, __attribute__((...))) or use of inline/extensions.\n\n- mhd_assert: Likely a macro. Assertion macros often expand to compiler-specific constructs (do { } while(0) is fine, but they might use __builtin_expect, __attribute__, or statement-expressions). Inspect to detect extension usage.\n\n- MHD_DLOG: Logging macro used under HAVE_MESSAGES. It is commonly a variadic macro or may expand to functions with format-attribute annotations or compiler-specific constructs; its macro expansion may use extensions (variadic macros are a C99 feature but some implementations use GNU extensions). Check its definition.\n\n- _ (translation macro): The underscore macro used for gettext may be a macro wrapping gettext or other constructs and could be defined using extensions (attributes or special wrappers). Inspect its definition.\n\n- HAVE_MESSAGES: This conditional macro controls conditional compilation blocks in the function. Its presence/absence affects whether MHD_DLOG and _ are used; you must know how it is defined (and any related configuration macros) to determine whether extension-using code is compiled in.\n\nNote: Standard library symbols used in the function (malloc, free, memchr, size_t) are part of the C standard and need not be inspected for compiler extensions unless they have been redefined in the project; if such redefinitions exist, they would appear as project symbols and should be treated similarly."
}