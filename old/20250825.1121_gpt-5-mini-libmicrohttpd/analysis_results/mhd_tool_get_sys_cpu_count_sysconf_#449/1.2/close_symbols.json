{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_sysconf_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SYSCONF) && \\\n  (defined(HAS_DECL__SC_NPROCESSORS_ONLN) || defined(HAS_DECL__SC_NPROC_ONLN))\n  long value = -1;\n#ifdef HAS_DECL__SC_NPROCESSORS_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROCESSORS_ONLN);\n#endif /* HAS_DECL__SC_NPROCESSORS_ONLN */\n#ifdef HAS_DECL__SC_NPROC_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROC_ONLN);\n#endif /* HAS_DECL__SC_NPROC_ONLN */\n  if (0 >= value)\n    return -1;\n  ret = (int) value;\n  if ((long) ret != value)\n    return -1; /* Overflow */\n#endif /* HAVE_SYSCONF &&\n          (HAS_DECL__SC_NPROCESSORS_ONLN || HAS_DECL__SC_NPROC_ONLN) */\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_sys_cpu_count_sysconf_': {'callees': [], 'callers': ['mhd_tool_get_system_cpu_count']}, 'mhd_tool_get_system_cpu_count': {'callees': ['mhd_tool_get_sys_cpu_count_special_api_', 'mhd_tool_get_sys_cpu_count_sysctl_', 'mhd_tool_get_sys_cpu_count_sysconf_', 'mhd_tool_get_proc_cpu_count', 'mhd_tool_get_sys_cpu_count_sysctl_fallback_', 'mhd_tool_get_sys_cpu_count_sysconf_fallback_'], 'callers': ['detect_cpu_core_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SYSCONF",
    "HAS_DECL__SC_NPROCESSORS_ONLN",
    "HAS_DECL__SC_NPROC_ONLN",
    "sysconf",
    "_SC_NPROCESSORS_ONLN",
    "_SC_NPROC_ONLN",
    "<unistd.h> / declaration of sysconf",
    "config.h (generated configure macros)",
    "compiler identification macros (__GNUC__, _MSC_VER, etc.)"
  ],
  "explanation": "For checking MISRA C rule about language extensions we must determine whether any tokens or constructs in the function are compiler- or platform-specific extensions. Each listed symbol is needed for that determination:\n\n- HAVE_SYSCONF: This build-time macro gates the entire sysconf-based code path. You must know whether it can be defined by the build system or the compiler environment (or is synthetically injected). If it is not set, the function reduces to trivial code with no sysconf usage.\n\n- HAS_DECL__SC_NPROCESSORS_ONLN and HAS_DECL__SC_NPROC_ONLN: These configure-style macros control use of particular system constants. They are not language features themselves but their presence selects use of _SC_* macros. You need their definitions to know whether references to the _SC_* names are actually compiled.\n\n- sysconf: The function calls sysconf. To decide if this is a language/compiler extension you must know the declaration and provenance of sysconf (standard POSIX function declared in <unistd.h> vs. some compiler-specific extension). The exact prototype (return type long) is required to understand casts and whether any nonstandard signature is in play.\n\n- _SC_NPROCESSORS_ONLN and _SC_NPROC_ONLN: These identifiers are system/implementation macros (often in <unistd.h>). They have leading underscores and platform-specific semantics; you must inspect their origin to decide whether using them constitutes a compiler/standard extension (or merely POSIX/system-specific macros). Knowing whether they are standard on the target platform is necessary.\n\n- <unistd.h> / declaration of sysconf: The header that provides sysconf and the _SC_* macros tells you whether the code is relying on standard POSIX declarations or on nonstandard extensions provided by the C library or platform headers.\n\n- config.h (generated configure macros): The project-generated configuration header (or equivalent) typically defines HAVE_SYSCONF and the HAS_DECL_* macros. Inspecting it shows whether these macros are set by feature tests (autoconf) and whether any nonportable/extension macros are injected.\n\n- compiler identification macros (__GNUC__, _MSC_VER, etc.): Whether a token/construct is a language extension depends on the compiler. You need to know which compiler (or its predefined feature macros) is targeted so you can consult that compiler's documentation to determine if any used language element (for example, use of reserved identifiers, leading-underscore macros, or nonstandard functions) is an explicitly-documented compiler extension.\n\nTogether these symbols let the analyst determine (a) which parts of the function are actually compiled, (b) whether sysconf and the _SC_* macros are standard POSIX or compiler/library extensions, and (c) whether any of the used identifiers or constructs rely on compiler-specific language extensions. Without them you cannot reliably decide if the code uses a compiler-declared language extension for the MISRA rule."
}