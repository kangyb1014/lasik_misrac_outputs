{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_str_has_token_caseless_:\n```c\nbool\nMHD_str_has_token_caseless_ (const char *str,\n                             const char *const token,\n                             size_t token_len)\n{\n  if (0 == token_len)\n    return false;\n\n  while (0 != *str)\n  {\n    size_t i;\n    /* Skip all whitespaces and empty tokens. */\n    while (' ' == *str || '\\t' == *str || ',' == *str)\n      str++;\n\n    /* Check for token match. */\n    i = 0;\n    while (1)\n    {\n      const char sc = *(str++);\n      const char tc = token[i++];\n\n      if (0 == sc)\n        return false;\n      if (! charsequalcaseless (sc, tc))\n        break;\n      if (i >= token_len)\n      {\n        /* Check whether substring match token fully or\n         * has additional unmatched chars at tail. */\n        while (' ' == *str || '\\t' == *str)\n          str++;\n        /* End of (sub)string? */\n        if ((0 == *str) || (',' == *str) )\n          return true;\n        /* Unmatched chars at end of substring. */\n        break;\n      }\n    }\n    /* Find next substring. */\n    while (0 != *str && ',' != *str)\n      str++;\n  }\n  return false;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_str_has_token_caseless_:\n_MHD_static_inline bool\ncharsequalcaseless (const char c1, const char c2)\n{\n  return ( (c1 == c2) ||\n           (isasciiupper (c1) ?\n            ((c1 - 'A' + 'a') == c2) :\n            ((c1 == (c2 - 'A' + 'a')) && isasciiupper (c2))) );\n}\n...\n_MHD_static_inline bool\nisasciiupper (char c)\n{\n  return (c >= 'A') && (c <= 'Z');\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no code fragments that are provably unreachable. Reasoning by control-flow and possible inputs:\n\n- The initial guard (if (0 == token_len) return false;) is reachable when the caller passes token_len == 0.\n- The outer loop (while (0 != *str)) is entered for non-empty input strings; the inner whitespace/comma-skip (while (' ' == *str || '\\t' == *str || ',' == *str) str++;) is reachable when leading separators are present.\n- The inner infinite loop (while (1)) has three distinct exit behaviours that are all reachable depending on inputs:\n  - if (0 == sc) return false; \u2014 reachable when the input string terminates while attempting to read the next character (string shorter than expected token match).\n  - if (! charsequalcaseless (sc, tc)) break; \u2014 reachable when a character mismatch occurs.\n  - if (i >= token_len) { ... if ((0 == *str) || (',' == *str) ) return true; ... } \u2014 reachable when token_len characters have matched; the subsequent check for end-of-string or comma (and the preceding skip of spaces/tabs) is reachable depending on the following byte(s).\n- The post-match/failed-match substring skip (while (0 != *str && ',' != *str) str++;) is reachable after break from the inner loop to move to the next comma-separated substring.\n- The final return false at the function end is reachable if the outer loop completes without returning true.\n\nRelated helper functions (charsequalcaseless and isasciiupper) contain conditional branches that are reachable depending on the character values (uppercase vs non-uppercase). No branch or statement in the provided code is statically impossible to reach across all possible inputs, so there are no code fragments that need investigation for unreachable-code violations of MISRA C 2023 Rule 2.1."
}