{
  "user_message": "An agent A claimed that the following MHD_create_response_from_buffer_with_free_callback code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_response_from_buffer_with_free_callback.\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    MHD_ContentReaderFreeCallback\n                                                    crfc)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 crfc,\n                                                                 buffer);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement '(void) version;' is an expression statement that has no effect at runtime\u2014its execution (evaluating and discarding the parameter) does not change program behaviour. Removing that statement would not affect program behaviour, so it constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_response_from_buffer_with_free_callback:\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback_cls (size_t size,\n                                                        const void *buffer,\n                                                        MHD_ContentReaderFreeCallback\n                                                        crfc,\n                                                        void *crfc_cls)\n{\n  struct MHD_Response *r;\n\n  if ((NULL == buffer) && (size > 0))\n    return NULL;\n#if SIZEOF_SIZE_T >= SIZEOF_UINT64_T\n  if (MHD_SIZE_UNKNOWN == size)\n    return NULL;\n#endif /* SIZEOF_SIZE_T >= SIZEOF_UINT64_T */\n  r = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == r)\n    return NULL;\n#if defined(MHD_USE_THREADS)\n  if (! MHD_mutex_init_ (&r->mutex))\n  {\n    free (r);\n    return NULL;\n  }\n#endif\n  r->fd = -1;\n  r->reference_count = 1;\n  r->total_size = size;\n  r->data = buffer;\n  r->data_size = size;\n  r->crfc = crfc;\n  r->crc_cls = crfc_cls;\n  return r;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer (size_t size,\n                                 void *buffer,\n                                 enum MHD_ResponseMemoryMode mode)\n{\n  if (MHD_RESPMEM_MUST_FREE == mode)\n    return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                   buffer,\n                                                                   &free,\n                                                                   buffer);\n  if (MHD_RESPMEM_MUST_COPY == mode)\n    return MHD_create_response_from_buffer_copy (size,\n                                                 buffer);\n\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_copy (size_t size,\n                                      const void *buffer)\n{\n  struct MHD_Response *r;\n  void *mhd_copy;\n\n  if (0 == size)\n    return MHD_create_response_from_buffer_with_free_callback_cls (0,\n                                                                   NULL,\n                                                                   NULL,\n                                                                   NULL);\n  if (NULL == buffer)\n    return NULL;\n\n  mhd_copy = malloc (size);\n  if (NULL == mhd_copy)\n    return NULL;\n  memcpy (mhd_copy, buffer, size);\n\n  r = MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                              mhd_copy,\n                                                              &free,\n                                                              mhd_copy);\n  if (NULL == r)\n    free (mhd_copy);\n  else\n  {\n    /* TODO: remove the next assignment, the buffer should not be modifiable */\n    r->data_buffer_size = size;\n  }\n\n  return r;\n}\n...\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n  (void) req_cls;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  return MHD_queue_response (connection, MHD_HTTP_OK, response);\n}\n...\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  size_t slen;\n  char *reply;\n  struct MHD_Response *response;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (MAIN_PAGE) + strlen (session->value_1);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            MAIN_PAGE,\n            session->value_1);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n...\ntypedef void\n(*MHD_ContentReaderFreeCallback) (void *cls)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Agent A's claimed violation focusses on the idiom \u201c(void) version;\u201d (an explicit cast-to-void of an unused parameter) and asserts it is dead code under MISRA C 2023 Rule 2.2. There are two separate problems with that claim: 1) The target function shown (MHD_create_response_from_buffer_with_free_callback) is a tiny public wrapper that forwards to MHD_create_response_from_buffer_with_free_callback_cls; it is not the location of the \u2018\u2018(void) version;\u2019\u2019 statement, and the wrapper is not dead code \u2014 it is part of the public API (removing it could change program linkage/behaviour). 2) The \u2018\u2018(void) parameter;\u2019\u2019 statements in the rest of the listing (for example in ahc_echo and other callbacks) are an explicit, conventional way to mark parameters as intentionally unused to suppress compiler warnings. While such a statement is a no-op at runtime, it is intentionally used to document and silence warnings about unused parameters. MISRA guidance recognises the need to mark unused parameters (and the common idiom is to cast to void); in practice this is an accepted technique to avoid spurious warnings and to document intent. Therefore the presence of those (void) casts should not be treated as an inadvertent dead-code violation of Rule 2.2 in this context. If you prefer to avoid the appearance of \u2018\u2018no-op statements\u2019\u2019, you may instead use a dedicated UNUSED(x) macro or compiler-specific annotations, but the code as shown does not constitute a MISRA 2.2 violation in practice."
}