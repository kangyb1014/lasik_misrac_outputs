{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of can_compress:\n```c\nstatic enum MHD_Result\ncan_compress (struct MHD_Connection *con)\n{\n  const char *ae;\n  const char *de;\n\n  ae = MHD_lookup_connection_value (con,\n                                    MHD_HEADER_KIND,\n                                    MHD_HTTP_HEADER_ACCEPT_ENCODING);\n  if (NULL == ae)\n    return MHD_NO;\n  if (0 == strcmp (ae,\n                   \"*\"))\n    return MHD_YES;\n  de = strstr (ae,\n               \"deflate\");\n  if (NULL == de)\n    return MHD_NO;\n  if (((de == ae) ||\n       (de[-1] == ',') ||\n       (de[-1] == ' ')) &&\n      ((de[strlen (\"deflate\")] == '\\0') ||\n       (de[strlen (\"deflate\")] == ',') ||\n       (de[strlen (\"deflate\")] == ';')))\n    return MHD_YES;\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function can_compress:\n_MHD_EXTERN const char *\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)\n{\n  const char *value;\n\n  value = NULL;\n  (void) MHD_lookup_connection_value_n (connection,\n                                        kind,\n                                        key,\n                                        (NULL == key) ? 0 : strlen (key),\n                                        &value,\n                                        NULL);\n  return value;\n}\n...\nstruct MHD_Connection\n...\n#define MHD_HTTP_HEADER_ACCEPT_ENCODING \"Accept-Encoding\"\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nae = MHD_lookup_connection_value (con,\n                                    MHD_HEADER_KIND,\n                                    MHD_HTTP_HEADER_ACCEPT_ENCODING);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: MHD_lookup_connection_value calls strlen(key) only when key != NULL. Here the call passes the string literal MHD_HTTP_HEADER_ACCEPT_ENCODING (\"Accept-Encoding\"), which is a valid NUL-terminated array, so strlen will not read past its bounds. A potential violation scenario would be if the function were called with a non-NULL pointer that does not point to a NUL-terminated buffer (or otherwise invalid memory) \u2014 then the internal strlen(key) could access beyond the object bounds."
}