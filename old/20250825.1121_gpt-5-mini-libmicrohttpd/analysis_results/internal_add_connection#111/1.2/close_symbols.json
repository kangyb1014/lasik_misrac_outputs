{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'internal_add_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'new_connection_prepare_', 'new_connection_process_'], 'callers': ['MHD_add_connection', 'MHD_accept_connection']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'new_connection_process_': {'callees': ['MHD_pool_create', 'MHD_DLOG', '__builtin_unreachable', 'MHD_connection_set_initial_state_', 'MHD_create_named_thread_', 'MHD_pool_destroy', 'MHD_ip_limit_del'], 'callers': ['internal_add_connection', 'new_connections_list_process_']}, 'MHD_add_connection': {'callees': ['MHD_cleanup_connections', 'MHD_DLOG', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection', '__builtin_unreachable'], 'callers': []}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_D_IS_USING_SELECT_",
    "MHD_D_DOES_SCKT_FIT_FDSET_",
    "MHD_D_GET_FD_SETSIZE_",
    "MHD_socket_close_chk_",
    "MHD_D_IS_USING_EPOLL_",
    "MHD_DLOG",
    "new_connection_prepare_",
    "new_connection_process_",
    "MHD_D_IS_THREAD_SAFE_",
    "MHD_mutex_lock_chk_",
    "DLL_insert",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_activate_",
    "struct MHD_Daemon",
    "MHD_socket",
    "enum MHD_Result",
    "enum MHD_tristate",
    "MHD_YES",
    "MHD_NO",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "HAVE_MESSAGES",
    "ENFILE",
    "EINVAL",
    "__builtin_unreachable"
  ],
  "explanation": "For checking whether the function uses compiler language extensions we must inspect the definitions/expansions of all macros, functions and types referenced in the target function (and any compile-time conditionals that alter the emitted code). Each listed symbol is required for the reasons below:\n\n- MHD_D_IS_USING_SELECT_: macro; may expand to compile-time expressions or compiler-specific constructs. Inspect for extensions.\n- MHD_D_DOES_SCKT_FIT_FDSET_: macro; its expansion determines whether FD_SET/FD_SETSIZE checks use non-standard constructs.\n- MHD_D_GET_FD_SETSIZE_: macro; check its definition for extension usage (e.g. typeof, __extension__, attributes).\n- MHD_socket_close_chk_: macro/function called to close socket; its implementation could use builtins or attributes (e.g. __builtin_close, __attribute__).\n- MHD_D_IS_USING_EPOLL_: macro; may expand conditionally or use compiler extensions.\n- MHD_DLOG: logging macro/function used in conditional blocks; logging macros commonly hide gcc builtins or statement-expressions \u2014 must inspect for extensions (format attribute, statement-expression GNU extension, variadic macro extensions).\n- new_connection_prepare_: function called and visible in call graph to call builtin extensions (the call graph shows it calls __builtin_unreachable). Inspect its definition for use of compiler intrinsics/attributes.\n- new_connection_process_: function called at end; call graph indicates it may call __builtin_unreachable and other intrinsics \u2014 inspect implementation.\n- MHD_D_IS_THREAD_SAFE_: macro; may use thread-checking constructs or compiler-specific thread attributes.\n- MHD_mutex_lock_chk_: macro/function; could expand to try/cleanup blocks, __attribute__ or compiler-specific synchronization intrinsics.\n- DLL_insert: macro/function manipulating lists; check for GNU statement expressions or typeof usage.\n- MHD_ITC_IS_VALID_: macro; inspect for extension usage in validation logic.\n- MHD_itc_activate_: function; implementation may use compiler builtins or non-standard features when signaling.\n- struct MHD_Daemon: type definition may contain compiler-specific attributes, bitfields, or nonportable extensions \u2014 need to inspect the struct declaration.\n- MHD_socket: typedef for the socket type \u2014 its definition may be platform-specific or use extension types.\n- enum MHD_Result: return type of function \u2014 check enum definition (and any enumerator macros) for non-standard constructs.\n- enum MHD_tristate: parameter type \u2014 inspect its definition for extensions.\n- MHD_YES / MHD_NO: macros or enum values used as return values; inspect how they are defined (macros could hide extensions).\n- MHD_USE_POSIX_THREADS / MHD_USE_W32_THREADS: build-time macros controlling conditional compilation; they change which code is compiled and may expose extension usage in other branches.\n- HAVE_MESSAGES: conditional compilation macro that enables MHD_DLOG blocks; need to examine code included under this flag for extensions.\n- ENFILE / EINVAL: errno macros referenced under conditionals; while standard, their conditional use could enable code paths using extensions (inspect surrounding conditional code and how these macros are referenced).\n- __builtin_unreachable: compiler builtin (GCC/Clang extension) appears in call graph \u2014 explicitly inspect where and whether it is emitted/used by macros or functions reachable from internal_add_connection.\n\nIn short: to decide if the target function (as compiled in the project configuration) uses language extensions you must examine the definitions/expansions of all macros and functions called or referenced here (and the relevant type definitions and compile-time flags). The listed symbols point exactly to those definitions/conditional macros that can inject compiler-specific extensions into the compiled code for internal_add_connection."
}