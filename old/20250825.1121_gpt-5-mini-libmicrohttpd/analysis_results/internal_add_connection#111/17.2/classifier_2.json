{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of internal_add_connection:\n```c\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function internal_add_connection:\nstatic struct MHD_Connection *\nnew_connection_prepare_ (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n  int eno = 0;\n\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d.\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n  {\n    /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Server reached connection limit. \" \\\n                 \"Closing inbound connection.\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return NULL;\n  }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n                               (const struct sockaddr *) addr,\n                               addrlen)) )\n  {\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n#if defined(EACCESS) && (EACCESS + 0 != 0)\n    errno = EACCESS;\n#endif\n    return NULL;\n  }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n  {\n    eno = errno;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    errno = eno;\n    return NULL;\n  }\n\n  if (! external_add)\n  {\n    connection->sk_corked = _MHD_OFF;\n    connection->sk_nodelay = _MHD_OFF;\n  }\n  else\n  {\n    connection->sk_corked = _MHD_UNKNOWN;\n    connection->sk_nodelay = _MHD_UNKNOWN;\n  }\n\n  if (0 < addrlen)\n  {\n    if (NULL == (connection->addr = malloc ((size_t) addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n      errno = eno;\n      return NULL;\n    }\n    memcpy (connection->addr,\n            addr,\n            (size_t) addrlen);\n  }\n  else\n    connection->addr = NULL;\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->is_nonip = sk_is_nonip;\n  connection->sk_spipe_suppress = sk_spipe_supprs;\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&connection->tid);\n#endif /* MHD_USE_THREADS */\n  connection->daemon = daemon;\n  connection->connection_timeout_ms = daemon->connection_timeout_ms;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n  if (0 != connection->connection_timeout_ms)\n    connection->last_activity = MHD_monotonic_msec_counter ();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n  {\n    /* set default connection handlers  */\n    MHD_set_http_callbacks_ (connection);\n  }\n  else\n  {\n#ifdef HTTPS_SUPPORT\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030500)\n    gnutls_init_flags_t\n#else\n    unsigned int\n#endif\n    flags;\n\n    flags = GNUTLS_SERVER;\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030402)\n    flags |= GNUTLS_NO_SIGNAL;\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n    flags |= GNUTLS_NONBLOCK;\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030603)\n    if (0 != (daemon->options & MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT))\n      flags |= GNUTLS_POST_HANDSHAKE_AUTH;\n#endif\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030605)\n    if (0 != (daemon->options & MHD_USE_INSECURE_TLS_EARLY_DATA))\n      flags |= GNUTLS_ENABLE_EARLY_DATA;\n#endif\n    connection->tls_state = MHD_TLS_CONN_INIT;\n    MHD_set_https_callbacks (connection);\n    if ((GNUTLS_E_SUCCESS != gnutls_init (&connection->tls_session, flags)) ||\n        (GNUTLS_E_SUCCESS != gnutls_priority_set (connection->tls_session,\n                                                  daemon->priority_cache)))\n    {\n      if (NULL != connection->tls_session)\n        gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise TLS session.\\n\"));\n#endif\n#if defined(EPROTO) && (EPROTO + 0 != 0)\n      errno = EPROTO;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030200)\n    if (! daemon->disable_alpn)\n    {\n      static const char prt1[] = \"http/1.1\"; /* Registered code for HTTP/1.1 */\n      static const char prt2[] = \"http/1.0\"; /* Registered code for HTTP/1.0 */\n      static const gnutls_datum_t prts[2] =\n      { {_MHD_DROP_CONST (prt1), MHD_STATICSTR_LEN_ (prt1)},\n        {_MHD_DROP_CONST (prt2), MHD_STATICSTR_LEN_ (prt2)} };\n\n      if (GNUTLS_E_SUCCESS !=\n          gnutls_alpn_set_protocols (connection->tls_session,\n                                     prts,\n                                     sizeof(prts) / sizeof(prts[0]),\n                                     0 /* | GNUTLS_ALPN_SERVER_PRECEDENCE */))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to set ALPN protocols.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n        (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n      }\n    }\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030200 */\n    gnutls_session_set_ptr (connection->tls_session,\n                            connection);\n    switch (daemon->cred_type)\n    {\n    /* set needed credentials for certificate authentication. */\n    case GNUTLS_CRD_CERTIFICATE:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_CERTIFICATE,\n                              daemon->x509_cred);\n      break;\n    case GNUTLS_CRD_PSK:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_PSK,\n                              daemon->psk_cred);\n      gnutls_psk_set_server_credentials_function (daemon->psk_cred,\n                                                  &psk_gnutls_adapter);\n      break;\n    case GNUTLS_CRD_ANON:\n    case GNUTLS_CRD_SRP:\n    case GNUTLS_CRD_IA:\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to setup TLS credentials: \" \\\n                   \"unknown credential type %d.\\n\"),\n                daemon->cred_type);\n#endif\n      gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n      MHD_PANIC (_ (\"Unknown credential type.\\n\"));\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n      errno = EINVAL;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030109) && ! defined(_WIN64)\n    gnutls_transport_set_int (connection->tls_session,\n                              (int) (client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n    gnutls_transport_set_ptr (connection->tls_session,\n                              (gnutls_transport_ptr_t) \\\n                              (intptr_t) client_socket);\n#endif /* GnuTLS before 3.1.9 or Win x64 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n    gnutls_transport_set_push_function (connection->tls_session,\n                                        MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n    if (daemon->https_mem_trust)\n      gnutls_certificate_server_set_request (connection->tls_session,\n                                             GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    free (connection->addr);\n    free (connection);\n    MHD_PANIC (_ (\"TLS connection on non-TLS daemon.\\n\"));\n#if 0\n    /* Unreachable code */\n    eno = EINVAL;\n    return NULL;\n#endif\n#endif /* ! HTTPS_SUPPORT */\n  }\n\n  return connection;\n}\n...\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n...\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n...\n#define MHD_itc_activate_(itc, str) ((write((itc).fd,(constvoid*)&_MHD_itc_wr_data,sizeof(_MHD_itc_wr_data))>0)||(EAGAIN==errno))\n...\n#define DLL_insert(head, tail, element) do{mhd_assert(NULL==(element)->next);mhd_assert(NULL==(element)->prev);(element)->next=(head);(element)->prev=NULL;if((tail)==NULL){(tail)=element;}else{(head)->prev=element;}(head)=(element);}while(0)\n...\n#define MHD_mutex_lock_chk_(pmutex) do{if(!MHD_mutex_lock_(pmutex))MHD_PANIC(_(\"Failed to lock mutex.\\n\"));\\\n}while(0)\n...\n#define MHD_mutex_unlock_chk_(pmutex) do{if(!MHD_mutex_unlock_(pmutex))MHD_PANIC(_(\"Failed to unlock mutex.\\n\"));\\\n}while(0)\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n...\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n...\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n...\nvoid\nMHD_set_http_callbacks_ (struct MHD_Connection *connection)\n{\n  connection->recv_cls = &recv_param_adapter;\n}\n...\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n...\nvoid\nMHD_connection_set_initial_state_ (struct MHD_Connection *c)\n{\n  size_t read_buf_size;\n\n#ifdef HTTPS_SUPPORT\n  mhd_assert ( (0 == (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_INIT == c->tls_state) );\n  mhd_assert ( (0 != (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_NO_TLS == c->tls_state) );\n#endif /* HTTPS_SUPPORT */\n  mhd_assert (MHD_CONNECTION_INIT == c->state);\n\n  c->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n  c->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n\n  memset (&c->rq, 0, sizeof(c->rq));\n  memset (&c->rp, 0, sizeof(c->rp));\n\n  c->write_buffer = NULL;\n  c->write_buffer_size = 0;\n  c->write_buffer_send_offset = 0;\n  c->write_buffer_append_offset = 0;\n\n  c->continue_message_write_offset = 0;\n\n  c->read_buffer_offset = 0;\n  read_buf_size = c->daemon->pool_size / 2;\n  c->read_buffer\n    = MHD_pool_allocate (c->pool,\n                         read_buf_size,\n                         false);\n  c->read_buffer_size = read_buf_size;\n}\n...\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n...\nvoid\nMHD_pool_destroy (struct MemoryPool *pool)\n{\n  if (NULL == pool)\n    return;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  _MHD_UNPOISON_MEMORY (pool->memory, pool->size);\n  if (! pool->is_mmap)\n    free (pool->memory);\n  else\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    munmap (pool->memory,\n            pool->size);\n#elif defined(_WIN32)\n    VirtualFree (pool->memory,\n                 0,\n                 MEM_RELEASE);\n#else\n    abort ();\n#endif\n  free (pool);\n}\n...\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nint\nMHD_socket_nonblocking_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFL);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | O_NONBLOCK) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFL,\n                    flags | O_NONBLOCK)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        (int) FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n...\nint\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE) sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment is a call from MHD_add_connection to internal_add_connection. internal_add_connection does not call MHD_add_connection nor call itself (directly or indirectly); its callees (new_connection_prepare_, new_connection_process_, etc.) do not invoke internal_add_connection. Therefore no recursion occurs."
}