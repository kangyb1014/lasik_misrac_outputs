{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_unquoted_param:\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_unquoted_param:\nstruct MHD_RqDAuthParam\n{\n  /**\n   * The string with length, NOT zero-terminated\n   */\n  struct _MHD_str_w_len value;\n  /**\n   * True if string must be \"unquoted\" before processing.\n   * This member is false if the string is used in DQUOTE marks, but no\n   * backslash-escape is used in the string.\n   */\n  bool quoted;\n}\n...\nstruct _MHD_str_w_len\n{\n  const char *str;\n  size_t len;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstr = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the local variable 'str' must be a mutable char * because it is used as the destination buffer for MHD_str_unquote (i.e. it is written to). The source buffer param->value.str is declared const char * and is passed as const to the unquote routine. Assigning the (modifiable) char * returned by get_buffer_for_size to the struct member unquoted->str (which has type const char *) is legal (non-const -> const). Thus the pointer const-qualification is appropriate and Rule 8.13 is not violated. (If get_buffer_for_size were to return a const char *, that would need review, but the current usage requires a non-const buffer.)"
}