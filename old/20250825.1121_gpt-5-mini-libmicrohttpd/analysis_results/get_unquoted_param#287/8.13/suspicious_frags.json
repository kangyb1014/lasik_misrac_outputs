{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_unquoted_param:\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function get_unquoted_param:\nstruct MHD_RqDAuthParam\n{\n  /**\n   * The string with length, NOT zero-terminated\n   */\n  struct _MHD_str_w_len value;\n  /**\n   * True if string must be \"unquoted\" before processing.\n   * This member is false if the string is used in DQUOTE marks, but no\n   * backslash-escape is used in the string.\n   */\n  bool quoted;\n}\n...\nstruct _MHD_str_w_len\n{\n  const char *str;\n  size_t len;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "struct _MHD_str_w_len *unquoted)",
    "size_t *ptmp2_size,",
    "char *str;",
    "unquoted->str = str;",
    "str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);",
    "char **ptmp2,",
    "char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],"
  ],
  "explanation": "I did not list as suspicious: the parameter declaration 'const struct MHD_RqDAuthParam *param' (it is already const-qualified), uses of param->value.str and param->value.len (the struct member 'str' is already 'const char *'), the early-return branch that assigns unquoted->str = param->value.str and unquoted->len = param->value.len (these are assignments from const data to the struct member which is declared with a const char *), and the call to MHD_str_unquote(param->value.str, ..., str) (this treats the source as const and the destination as mutable, so a non-const destination is required). Also the assert lines and the final len/return handling do not introduce pointer-type qualifiers issues. The fragments reported above are those in this function where pointer declarations or assignments might be eligible for additional const-qualification (or need verification that they must remain non-const), and therefore should be investigated for compliance with MISRA C 2023 Rule 8.13."
}