{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of internal_get_fdset2:\n```c\nstatic enum MHD_Result\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     int fd_setsize)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  enum MHD_Result result = MHD_YES;\n  MHD_socket ls;\n  bool itc_added;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (daemon->shutdown)\n    return MHD_YES;\n\n  /* The order of FDs added is important for W32 sockets as W32 fd_set has\n     limits for number of added FDs instead of the limit for the higher\n     FD value. */\n\n  /* Add ITC FD first. The daemon must be able to respond on application\n     commands issued in other threads. */\n  itc_added = false;\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize);\n    if (! itc_added)\n      result = MHD_NO;\n  }\n\n  ls = daemon->was_quiesced ? MHD_INVALID_SOCKET : daemon->listen_fd;\n  if (! itc_added &&\n      (MHD_INVALID_SOCKET != ls))\n  {\n    /* Add listen FD if ITC was not added. Listen FD could be used to signal\n       the daemon shutdown. */\n    if (MHD_add_to_fd_set_ (ls,\n                            read_fd_set,\n                            max_fd,\n                            fd_setsize))\n      ls = MHD_INVALID_SOCKET;   /* Already added */\n    else\n      result = MHD_NO;\n  }\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n  {\n    posn = pos->prev;\n\n    switch (pos->event_loop_info)\n    {\n    case MHD_EVENT_LOOP_INFO_READ:\n    case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_WRITE:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                write_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_PROCESS:\n      if ( (NULL == except_fd_set) ||\n           ! MHD_add_to_fd_set_ (pos->socket_fd,\n                                 except_fd_set,\n                                 max_fd,\n                                 fd_setsize))\n        result = MHD_NO;\n      break;\n    case MHD_EVENT_LOOP_INFO_CLEANUP:\n      /* this should never happen */\n      break;\n    }\n  }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  if (NULL != except_fd_set)\n  {\n    for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n  }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (1)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      if (MHD_NO ==\n          urh_to_fdset (urh,\n                        read_fd_set,\n                        write_fd_set,\n                        except_fd_set,\n                        max_fd,\n                        fd_setsize))\n        result = MHD_NO;\n    }\n  }\n#endif\n\n  if (MHD_INVALID_SOCKET != ls)\n  {\n    /* The listen socket is present and hasn't been added */\n    if ((daemon->connections < daemon->connection_limit) &&\n        ! daemon->at_limit)\n    {\n      if (! MHD_add_to_fd_set_ (ls,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n    }\n  }\n\n#if _MHD_DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _ (\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "struct MHD_Connection *posn;",
    "struct MHD_Connection *pos;",
    "struct MHD_Daemon *daemon,",
    "struct MHD_UpgradeResponseHandle *urh;"
  ],
  "explanation": "I did not mark other pointer occurrences as suspicious because they are clearly used for modification and therefore should remain non-const: - fd_set *read_fd_set, *write_fd_set and *except_fd_set are passed to MHD_add_to_fd_set_ (they are modified/updated). - MHD_socket *max_fd is updated by MHD_add_to_fd_set_ and later read for debug output, so it must be non-const. - Pointers returned/used by macros/functions (e.g. MHD_itc_r_fd_(daemon->itc)) are not pointer-to-object parameters in this function. The four fragments listed are the pointer declarations in this function that are only read/traversed here (daemon, the connection traversal pointers pos/posn, and urh in the upgrade loop) and thus should be investigated to determine whether they could be const-qualified under Rule 8.13."
}