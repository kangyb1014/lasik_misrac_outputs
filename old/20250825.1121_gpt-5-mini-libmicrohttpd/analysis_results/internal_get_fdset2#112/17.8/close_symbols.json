{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     int fd_setsize)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  enum MHD_Result result = MHD_YES;\n  MHD_socket ls;\n  bool itc_added;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (daemon->shutdown)\n    return MHD_YES;\n\n  /* The order of FDs added is important for W32 sockets as W32 fd_set has\n     limits for number of added FDs instead of the limit for the higher\n     FD value. */\n\n  /* Add ITC FD first. The daemon must be able to respond on application\n     commands issued in other threads. */\n  itc_added = false;\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize);\n    if (! itc_added)\n      result = MHD_NO;\n  }\n\n  ls = daemon->was_quiesced ? MHD_INVALID_SOCKET : daemon->listen_fd;\n  if (! itc_added &&\n      (MHD_INVALID_SOCKET != ls))\n  {\n    /* Add listen FD if ITC was not added. Listen FD could be used to signal\n       the daemon shutdown. */\n    if (MHD_add_to_fd_set_ (ls,\n                            read_fd_set,\n                            max_fd,\n                            fd_setsize))\n      ls = MHD_INVALID_SOCKET;   /* Already added */\n    else\n      result = MHD_NO;\n  }\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n  {\n    posn = pos->prev;\n\n    switch (pos->event_loop_info)\n    {\n    case MHD_EVENT_LOOP_INFO_READ:\n    case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_WRITE:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                write_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_PROCESS:\n      if ( (NULL == except_fd_set) ||\n           ! MHD_add_to_fd_set_ (pos->socket_fd,\n                                 except_fd_set,\n                                 max_fd,\n                                 fd_setsize))\n        result = MHD_NO;\n      break;\n    case MHD_EVENT_LOOP_INFO_CLEANUP:\n      /* this should never happen */\n      break;\n    }\n  }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  if (NULL != except_fd_set)\n  {\n    for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n  }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (1)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      if (MHD_NO ==\n          urh_to_fdset (urh,\n                        read_fd_set,\n                        write_fd_set,\n                        except_fd_set,\n                        max_fd,\n                        fd_setsize))\n        result = MHD_NO;\n    }\n  }\n#endif\n\n  if (MHD_INVALID_SOCKET != ls)\n  {\n    /* The listen socket is present and hasn't been added */\n    if ((daemon->connections < daemon->connection_limit) &&\n        ! daemon->at_limit)\n    {\n      if (! MHD_add_to_fd_set_ (ls,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n    }\n  }\n\n#if _MHD_DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _ (\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "FD_SETSIZE",
    "MHD_add_to_fd_set_",
    "urh_to_fdset",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "HTTPS_SUPPORT",
    "UPGRADE_SUPPORT"
  ],
  "explanation": "Explain why each symbol is required for checking the MISRA rule (a function parameter shall not be modified):\n\n- HAS_FD_SETSIZE_OVERRIDABLE\n  - The assignment \"fd_setsize = (int) FD_SETSIZE;\" is inside #ifndef HAS_FD_SETSIZE_OVERRIDABLE. Whether this assignment is present in the compiled function depends solely on this preprocessor symbol. You must know its definition to decide if the parameter fd_setsize is modified.\n\n- FD_SETSIZE\n  - Used as the right-hand value in the assignment to fd_setsize. Knowing this macro is not required to determine that fd_setsize is assigned to, but is necessary to fully understand the guarded assignment and its intent/value when the assignment is present.\n\n- MHD_add_to_fd_set_\n  - This identifier is invoked repeatedly and may be implemented either as a function or a macro. If it is a macro, its expansion could reassign the identifiers passed as arguments (for example max_fd or fd_setsize) in the caller context. To prove the function does or does not modify any parameter variable you must inspect the definition of MHD_add_to_fd_set_ to ensure it does not perform assignments to the caller\u2019s parameter identifiers.\n\n- urh_to_fdset\n  - Called inside a conditional compilation block controlled by HTTPS_SUPPORT && UPGRADE_SUPPORT. Like MHD_add_to_fd_set_, urh_to_fdset could be a macro or function that (via macro expansion) assigns to expressions passed as arguments; if present it must be inspected to ensure it does not reassign any of internal_get_fdset2's parameter variables.\n\n- MHD_ITC_IS_VALID_\n  - This macro/function guards the MHD_itc_r_fd_ call and is a macro candidate. A macro expansion could include side-effects that alter local variables (including reassigning a parameter identifier). Its definition is needed to be sure it does not modify parameters.\n\n- MHD_itc_r_fd_\n  - Used as an argument to MHD_add_to_fd_set_. If MHD_itc_r_fd_ is a macro that expands into code containing assignments to the token used as argument, it could (via expansion) reassign a parameter identifier; check its definition to rule that out.\n\n- MHD_POSIX_SOCKETS and MHD_WINSOCK_SOCKETS\n  - These preprocessor symbols control inclusion of code paths that call MHD_add_to_fd_set_ (for except_fd_set) and an extra loop that repeatedly invokes MHD_add_to_fd_set_. They influence which calls (possibly macro expansions) appear in the compiled function; include them to know whether those code regions (and their potential macro effects) are compiled.\n\n- HTTPS_SUPPORT and UPGRADE_SUPPORT\n  - These control inclusion of the urh_to_fdset loop. If defined, urh_to_fdset is invoked and its definition must be inspected (see above). If not defined, that potential source of parameter modification is absent.\n\nNotes on scope: The MISRA rule forbids assigning to the function parameters themselves (e.g., fd_setsize = ... or read_fd_set = ...). It does not forbid modifying the objects pointed to by pointer parameters. The single explicit assignment in the source is to fd_setsize; whether that exists depends on HAS_FD_SETSIZE_OVERRIDABLE. In addition, any macro used in this function (notably MHD_add_to_fd_set_ and urh_to_fdset, and less likely the small ITC macros) must be inspected to ensure they do not expand to assignments that reassign any of the parameter identifiers (read_fd_set, write_fd_set, except_fd_set, max_fd, fd_setsize, daemon). Inspecting the definitions of the listed symbols is therefore necessary and sufficient to determine compliance."
}