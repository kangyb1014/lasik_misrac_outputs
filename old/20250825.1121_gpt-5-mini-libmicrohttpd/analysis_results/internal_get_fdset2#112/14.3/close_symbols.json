{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     int fd_setsize)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  enum MHD_Result result = MHD_YES;\n  MHD_socket ls;\n  bool itc_added;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (daemon->shutdown)\n    return MHD_YES;\n\n  /* The order of FDs added is important for W32 sockets as W32 fd_set has\n     limits for number of added FDs instead of the limit for the higher\n     FD value. */\n\n  /* Add ITC FD first. The daemon must be able to respond on application\n     commands issued in other threads. */\n  itc_added = false;\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize);\n    if (! itc_added)\n      result = MHD_NO;\n  }\n\n  ls = daemon->was_quiesced ? MHD_INVALID_SOCKET : daemon->listen_fd;\n  if (! itc_added &&\n      (MHD_INVALID_SOCKET != ls))\n  {\n    /* Add listen FD if ITC was not added. Listen FD could be used to signal\n       the daemon shutdown. */\n    if (MHD_add_to_fd_set_ (ls,\n                            read_fd_set,\n                            max_fd,\n                            fd_setsize))\n      ls = MHD_INVALID_SOCKET;   /* Already added */\n    else\n      result = MHD_NO;\n  }\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n  {\n    posn = pos->prev;\n\n    switch (pos->event_loop_info)\n    {\n    case MHD_EVENT_LOOP_INFO_READ:\n    case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_WRITE:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                write_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_PROCESS:\n      if ( (NULL == except_fd_set) ||\n           ! MHD_add_to_fd_set_ (pos->socket_fd,\n                                 except_fd_set,\n                                 max_fd,\n                                 fd_setsize))\n        result = MHD_NO;\n      break;\n    case MHD_EVENT_LOOP_INFO_CLEANUP:\n      /* this should never happen */\n      break;\n    }\n  }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  if (NULL != except_fd_set)\n  {\n    for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n  }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (1)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      if (MHD_NO ==\n          urh_to_fdset (urh,\n                        read_fd_set,\n                        write_fd_set,\n                        except_fd_set,\n                        max_fd,\n                        fd_setsize))\n        result = MHD_NO;\n    }\n  }\n#endif\n\n  if (MHD_INVALID_SOCKET != ls)\n  {\n    /* The listen socket is present and hasn't been added */\n    if ((daemon->connections < daemon->connection_limit) &&\n        ! daemon->at_limit)\n    {\n      if (! MHD_add_to_fd_set_ (ls,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n    }\n  }\n\n#if _MHD_DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _ (\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon (fields: shutdown, itc, was_quiesced, listen_fd, connections_tail, urh_tail, connections, connection_limit, at_limit)",
    "struct MHD_Connection (fields: prev, event_loop_info, socket_fd)",
    "struct MHD_UpgradeResponseHandle (field: prev)",
    "enum/values for event_loop_info: MHD_EVENT_LOOP_INFO_READ, MHD_EVENT_LOOP_INFO_PROCESS_READ, MHD_EVENT_LOOP_INFO_WRITE, MHD_EVENT_LOOP_INFO_PROCESS, MHD_EVENT_LOOP_INFO_CLEANUP",
    "MHD_ITC_IS_VALID_ (macro/function)",
    "MHD_itc_r_fd_ (macro/function)",
    "urh_to_fdset (function)",
    "MHD_INVALID_SOCKET (constant)",
    "MHD_socket (typedef)",
    "FD_SETSIZE and HAS_FD_SETSIZE_OVERRIDABLE (macro/constant)",
    "MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS, HTTPS_SUPPORT, UPGRADE_SUPPORT (conditional-compilation macros)",
    "except_fd_set parameter (fd_set *except_fd_set)",
    "MHD_Result enum values / macros: MHD_YES, MHD_NO"
  ],
  "explanation": "Explain why each symbol is required to judge whether controlling expressions are invariant:\n\n- struct MHD_Daemon (shutdown, itc, was_quiesced, listen_fd, connections_tail, urh_tail, connections, connection_limit, at_limit): Many controlling expressions depend on daemon fields (e.g. if (daemon->shutdown), initialization of ls from was_quiesced/listen_fd, the for-loop start daemon->connections_tail, final if using connections/connection_limit/at_limit). You must know these fields' types/semantics and whether they can be non\u2011constant/modified to decide if the controlling expressions are truly invariant.\n\n- struct MHD_Connection (prev, event_loop_info, socket_fd): The for-loop iterates using pos->prev and the switch uses pos->event_loop_info as the controlling expression. Understanding these fields (types, possible values, mutability) is necessary to determine if the loop/switch conditions can ever vary.\n\n- struct MHD_UpgradeResponseHandle (prev): The URH loop uses daemon->urh_tail and urh->prev in a controlling expression; you need this struct to know whether that loop condition can change.\n\n- enum/values for event_loop_info: MHD_EVENT_LOOP_INFO_READ, _PROCESS_READ, _WRITE, _PROCESS, _CLEANUP: The switch controlling expression (pos->event_loop_info) is compared to these constants. Their definitions and range are needed to judge whether the switch control is invariant or can take multiple values.\n\n- MHD_ITC_IS_VALID_ (macro/function): The early if (MHD_ITC_IS_VALID_(daemon->itc)) controls addition of ITC and affects subsequent branches (itc_added). You need its definition/semantics to know whether that condition could be constant.\n\n- MHD_itc_r_fd_ (macro/function): Used to obtain an FD passed to MHD_add_to_fd_set_. While not a control expression itself, its behavior/return type can influence itc_added and thus later branch decisions; its definition may reveal invariance.\n\n- urh_to_fdset (function): Called inside a conditional loop when HTTPS_SUPPORT && UPGRADE_SUPPORT are defined; its return is tested (== MHD_NO) and therefore affects result and control flow in that compiled-in block. Its presence/behavior is required to decide whether that loop/body contributes any invariant condition.\n\n- MHD_INVALID_SOCKET (constant): Comparisons against this constant (MHD_INVALID_SOCKET != ls) control several branches. Knowing its value/type is necessary to determine if such comparisons are ever variable.\n\n- MHD_socket (typedef): The type of ls, max_fd and related comparisons can affect whether expressions are constant; e.g. signed/unsigned behaviour, sentinel values\u2014required to analyze invariance semantics.\n\n- FD_SETSIZE and HAS_FD_SETSIZE_OVERRIDABLE (macro/constant): The compile\u2011time branch that assigns fd_setsize depends on HAS_FD_SETSIZE_OVERRIDABLE and FD_SETSIZE; these macros can enable/disable code that changes behavior and thus affect whether some expressions (e.g. results of MHD_add_to_fd_set_) are invariant.\n\n- MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS, HTTPS_SUPPORT, UPGRADE_SUPPORT (conditional-compilation macros): These macros enable/disable blocks (except_fd_set additions, extra W32 loop, URH loop). Whether those blocks exist affects which conditional/loop controlling expressions are present \u2014 you must know their definitions to know which control expressions are actually compiled and whether they are invariant.\n\n- except_fd_set parameter (fd_set *except_fd_set): Several conditions check (NULL != except_fd_set) to decide branches; you need to know whether the caller can pass NULL (or if it's constant in the analyzed context) to decide invariance of those controlling expressions.\n\n- MHD_Result enum values / macros: MHD_YES, MHD_NO: The code tests/assigns these; although they do not directly control flow, they appear in equality tests of returned statuses (e.g. urh_to_fdset comparing to MHD_NO) and are needed to understand control decisions and whether those decisions are constant.\n\nIn short: to determine if any controlling expression in internal_get_fdset2 is an invariant constant, the analyzer must know the definitions and semantics of the daemon/connection/URH data structures and their fields, the conditional macros that enable/disable code, the sentinel constants and types used in comparisons, and the helper predicates/functions (MHD_ITC_IS_VALID_, MHD_itc_r_fd_, urh_to_fdset) that appear in controlling tests."
}