{
  "user_message": "Target function code is:\n```c\nstatic enum SHA1_RESULT\nSHA1Result (struct SHA1Context *context, unsigned char\n            Message_Digest[SHA1HashSize])\n{\n  int i;\n\n  if (! context || ! Message_Digest)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (! context->computed)\n  {\n    SHA1PadMessage (context);\n    for (i = 0; i < 64; ++i)\n    {\n      context->message_block[i] = 0;\n    }\n    context->length_low = 0;\n    context->length_high = 0;\n    context->computed = 1;\n  }\n  for (i = 0; i < SHA1HashSize; ++i)\n  {\n    Message_Digest[i]\n      = (unsigned char) (context->intermediate_hash[i >> 2]\n                         >> 8 * (3 - (i & 0x03)));\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'SHA1Result': {'callees': ['SHA1PadMessage'], 'callers': ['ws_get_accept_value']}, 'SHA1PadMessage': {'callees': ['SHA1ProcessMessageBlock'], 'callers': ['SHA1Result']}, 'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum SHA1_RESULT (definition, including SHA1_RESULT_NULL, SHA1_RESULT_STATE_ERROR, SHA1_RESULT_SUCCESS)",
    "SHA1HashSize (macro/constant that defines the size used in the Message_Digest parameter and loop)",
    "struct SHA1Context (full definition: types of members corrupted, computed, message_block[], length_low, length_high, intermediate_hash[] element type)",
    "SHA1PadMessage (prototype and definition of the callee)",
    "Prototype/definition of any typedefs or integer types used inside SHA1Context (e.g. type of intermediate_hash elements, length_low/high)"
  ],
  "explanation": "To decide whether the target function or its immediate interactions use compiler language extensions, the analyser must see the exact declarations and definitions of all types, macros and callees that the function relies on. Specifically:\n- enum SHA1_RESULT: needed to verify that the enum is a standard C enum and that its enumerators are not created using compiler-specific extensions (e.g. exotic enum attributes or nonstandard sized-enum extensions).\n- SHA1HashSize: the array parameter syntax and loops use this macro; its definition must be inspected to ensure it is a plain constant (not a compiler-specific construct or extension like a nonstandard attribute or expression involving extensions).\n- struct SHA1Context: the function reads/writes members (corrupted, computed, message_block, length_low/high, intermediate_hash). The structure definition is required to check for language extensions inside it (e.g. bit-field widths that rely on implementation extensions, anonymous/unnamed fields or nonstandard attributes, flexible-array members used in a nonstandard way, packed/attribute markers, or compiler-specific alignment pragmas).\n- SHA1PadMessage prototype/definition: the target calls this function; its declaration/definition must be checked for compiler-specific extensions (function attributes, inline assembly, GCC nested functions, nonstandard calling conventions, __attribute__ markers, etc.) that would cause the target to rely on language extensions.\n- typedefs/integer types used in SHA1Context (e.g. the type of intermediate_hash elements, length_low/high): required to check whether their definitions use nonstandard integer types or compiler extensions (extended-width integer types, custom attributes, or implementation-defined integer-size hacks) which could imply use of language extensions.\n\nProviding these symbols allows the analyser to determine whether any nonstandard/implementation-specific language constructs appear in the types, macros or function declarations that the target function depends on. Only these few (types, macros, structure and callee declarations) are necessary to detect language-extension usage affecting the target function."
}