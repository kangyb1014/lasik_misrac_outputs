{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nreply_with_method_not_supported (struct MHD_Connection *c)\n{\n  static const char page_content[] =\n    \"<html><head><title>Requested HTTP Method Is Not Supported</title></head>\" \\\n    \"<body>The requested HTTP method is not supported.</body></html>\";\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len, page_content)\n  ;\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE, \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_NOT_IMPLEMENTED, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'reply_with_method_not_supported': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': ['ahc_main']}, 'MHD_create_response_from_buffer_static': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['transmit_error_response_len', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'not_found_page', 'create_response', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'create_response_object', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'ahc_main': {'callees': ['reply_with_method_not_supported', 'reply_with_main_page', 'handle_sec_areas_req', 'reply_with_page_not_found'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_Result (definition)",
    "MHD_NO (enumerator/constant)",
    "MHD_HTTP_NOT_IMPLEMENTED (enumerator/constant)",
    "struct MHD_Connection (definition)",
    "struct MHD_Response (definition)",
    "MHD_create_response_from_buffer_static (declaration/definition)",
    "MHD_add_response_header (declaration/definition)",
    "MHD_queue_response (declaration/definition)",
    "MHD_destroy_response (declaration/definition)",
    "MHD_HTTP_HEADER_CONTENT_TYPE (macro/string)",
    "size_t (typedef)"
  ],
  "explanation": "For checking whether the target function uses any compiler language extensions, the analyzer must see the declarations/definitions of all types, macros and callees that appear in the function so it can detect non\u2011standard constructs (macros, GCC/Clang attributes, inline assembly, builtin intrinsics, variadic macro tricks, token\u2011pasting, etc.). Brief rationale per symbol:\n\n- enum MHD_Result (definition): the return type; the enum declaration may itself use compiler extensions or attributes (e.g. extension enums, explicit underlying types, or macros expanding to extensions).\n- MHD_NO (enumerator/constant): used as an early return value; must verify it is a plain enum/constant and not produced via an extension macro.\n- MHD_HTTP_NOT_IMPLEMENTED (enumerator/constant): used as HTTP status; verify it is a standard constant and not an extension or macro with special tokens/attributes.\n- struct MHD_Connection (definition): parameter type; its declaration could involve bit\u2011fields, packed attributes, or compiler extensions that affect linkage or calling convention.\n- struct MHD_Response (definition): local pointer type and argument to several callees; its definition or associated typedefs/macros might use extensions.\n- MHD_create_response_from_buffer_static (declaration/definition): callee used to create resp; it could be a macro or function with GCC/Clang attributes, inline asm, nonstandard calling conventions, or other extensions that affect how the call behaves.\n- MHD_add_response_header (declaration/definition): callee invoked (cast to void); needed to check if it is a macro or defined using extensions (variadic macros, attribute annotations, etc.).\n- MHD_queue_response (declaration/definition): callee returning enum MHD_Result; its prototype/definition could embed attributes or use language extensions that change semantics.\n- MHD_destroy_response (declaration/definition): callee; its declaration/definition must be inspected for extensions (inline asm, special attributes, or macro wrappers).\n- MHD_HTTP_HEADER_CONTENT_TYPE (macro/string): header name passed to MHD_add_response_header; may be a macro that uses token pasting or other preprocessor extensions.\n- size_t (typedef): used for page_content_len; verify it is the standard typedef and not redefined via nonstandard compiler-specific typedefs.\n\nCollecting these symbols (their declarations/definitions and macro expansions) lets the next analyzer determine if any of them \u2014 or how they are used in this function \u2014 rely on compiler language extensions (attributes, builtins, inline asm, nonstandard preprocessor constructs, etc.)."
}