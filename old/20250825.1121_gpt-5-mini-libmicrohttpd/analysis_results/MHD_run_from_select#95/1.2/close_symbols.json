{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select (struct MHD_Daemon *daemon,\n                     const fd_set *read_fd_set,\n                     const fd_set *write_fd_set,\n                     const fd_set *except_fd_set)\n{\n  return MHD_run_from_select2 (daemon,\n                               read_fd_set,\n                               write_fd_set,\n                               except_fd_set,\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n                               daemon->fdset_size_set_by_app ?\n                               ((unsigned int) daemon->fdset_size) :\n                               ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                               ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                               );\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_run_from_select': {'callees': ['MHD_run_from_select2'], 'callers': []}, 'MHD_run_from_select2': {'callees': ['MHD_DLOG', 'MHD_epoll', 'MHD_cleanup_connections', 'resume_suspended_connections', 'internal_run_from_select'], 'callers': ['MHD_run_from_select']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "MHD_run_from_select2",
    "struct MHD_Daemon",
    "daemon->fdset_size_set_by_app",
    "daemon->fdset_size",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "_MHD_SYS_DEFAULT_FD_SETSIZE",
    "enum MHD_Result",
    "fd_set"
  ],
  "explanation": "For checking the MISRA rule on language extensions, the following additional symbols are needed and why:\n\n- _MHD_EXTERN: This macro controls the function linkage/storage and commonly expands to platform/compiler-specific tokens (for example __attribute__((...)), __declspec(...), or other compiler extensions). You must inspect its definition to detect any non\u2011standard extension usage.\n\n- MHD_run_from_select2: The called function's prototype may carry compiler-specific attributes or non\u2011standard qualifiers (e.g. __attribute__, nonstandard calling conventions). Its declaration must be checked for extensions.\n\n- struct MHD_Daemon: The function reads daemon members; the struct definition may use bit\u2011fields, nonstandard types, or macros that expand to compiler extensions. Inspecting the struct is required to see if any member declarations use extensions.\n\n- daemon->fdset_size_set_by_app and daemon->fdset_size: These specific members are used in the conditional expression. Their types/definitions (e.g. bit\u2011field, typedefs, or macros) could hide extensions \u2014 list them explicitly so the next agent can inspect their declarations.\n\n- HAS_FD_SETSIZE_OVERRIDABLE: This conditional compilation macro controls alternate code paths. Its definition (or build-system definition) may indicate use of platform\u2011specific behavior or hide macros that expand to extensions; it must be checked.\n\n- _MHD_SYS_DEFAULT_FD_SETSIZE: This macro provides the fallback size value \u2014 its definition might expand to system macros or compiler\u2011specific constants (or use sizeof tricks or typeof, etc.). Inspect it for extensions.\n\n- enum MHD_Result: The return type must be examined to confirm it is a standard enum and that its declaration does not use compiler extensions (e.g. enum attributes, nonstandard underlying type annotations).\n\n- fd_set: The parameter type comes from system headers; fd_set (or related macros/types used to compute sizes) could be implemented via compiler extensions on some platforms. Verify the typedef/definition for any non\u2011standard constructs.\n\nThese symbols cover the places where compiler- or platform-specific extensions are likely to be hidden (macros, attributes, typedefs, struct member declarations and prototypes). Inspecting their definitions is necessary to determine whether the target function itself (as written) relies on any language/compiler extensions and thus violates the MISRA rule."
}