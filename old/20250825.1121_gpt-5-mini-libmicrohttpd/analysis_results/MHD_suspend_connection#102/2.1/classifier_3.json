{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_suspend_connection:\n```c\n_MHD_EXTERN void\nMHD_suspend_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_ (\"Cannot suspend connections without \" \\\n                  \"enabling MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#ifdef UPGRADE_SUPPORT\n  if (NULL != connection->urh)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error: connection scheduled for \\\"upgrade\\\" cannot \" \\\n                 \"be suspended.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return;\n  }\n#endif /* UPGRADE_SUPPORT */\n  internal_suspend_connection_ (connection);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_suspend_connection:\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define MHD_D_IS_USING_THREADS_(d) (0!=(d->options&(MHD_USE_INTERNAL_POLLING_THREAD)))\n...\n#define MHD_D_IS_USING_THREAD_PER_CONN_(d) (0!=((d)->options&MHD_USE_THREAD_PER_CONNECTION))\n...\n#define MHD_thread_handle_ID_is_current_thread_(hndl_id) MHD_thread_ID_is_current_thread_((hndl_id).ID)\n...\n#define MHD_TEST_ALLOW_SUSPEND_RESUME 8192\n...\nvoid\ninternal_suspend_connection_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  mhd_assert (NULL == daemon->worker_pool);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if (connection->resuming)\n  {\n    /* suspending again while we didn't even complete resuming yet */\n    connection->resuming = false;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    return;\n  }\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n      XDLL_remove (daemon->normal_timeout_head,\n                   daemon->normal_timeout_tail,\n                   connection);\n    else\n      XDLL_remove (daemon->manual_timeout_head,\n                   daemon->manual_timeout_tail,\n                   connection);\n  }\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              connection);\n  mhd_assert (! connection->suspended);\n  DLL_insert (daemon->suspended_connections_head,\n              daemon->suspended_connections_tail,\n              connection);\n  connection->suspended = true;\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n    {\n      EDLL_remove (daemon->eready_head,\n                   daemon->eready_tail,\n                   connection);\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n    }\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET))\n    {\n      if (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          connection->socket_fd,\n                          NULL))\n        MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EPOLL_SET);\n    }\n    connection->epoll_state |= MHD_EPOLL_STATE_SUSPENDED;\n  }\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\n#define UPGRADE_SUPPORT 1\n...\n#define MHD_USE_THREADS 1\n...\n#define HAVE_MESSAGES 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define mhd_assert(ignore) ((void)0)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation \u2014 defining mhd_assert(ignore) as ((void)0) simply makes assertion calls no-ops. For example, 'mhd_assert(cond); foo();' expands to '((void)0); foo();' so foo() remains reachable. The macro does not introduce unreachable code by itself (it only removes runtime checks)."
}