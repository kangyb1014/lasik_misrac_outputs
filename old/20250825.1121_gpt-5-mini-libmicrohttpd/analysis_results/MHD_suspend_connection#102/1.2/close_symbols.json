{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN void\nMHD_suspend_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_ (\"Cannot suspend connections without \" \\\n                  \"enabling MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#ifdef UPGRADE_SUPPORT\n  if (NULL != connection->urh)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error: connection scheduled for \\\"upgrade\\\" cannot \" \\\n                 \"be suspended.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return;\n  }\n#endif /* UPGRADE_SUPPORT */\n  internal_suspend_connection_ (connection);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_suspend_connection': {'callees': ['__builtin_unreachable', 'MHD_DLOG', 'internal_suspend_connection_'], 'callers': ['ahc_echo']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'internal_suspend_connection_': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_suspend_connection', 'MHD_response_execute_upgrade_']}, 'ahc_echo': {'callees': ['MHD_queue_response', 'MHD_create_response_from_callback', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_create_response_empty', 'MHD_lookup_connection_value', 'MHD_create_response_from_buffer_with_free_callback', 'MHD_create_response_from_fd64', 'MHD_create_response_from_buffer', 'MHD_create_response_from_buffer_copy', 'MHD_suspend_connection', 'MHD_digest_auth_check3', 'MHD_queue_auth_required_response3', 'MHD_basic_auth_get_username_password3', 'MHD_queue_basic_auth_required_response3', 'MHD_free', 'MHD_create_response_for_upgrade', 'can_compress', 'body_compress'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "MHD_USE_THREADS",
    "mhd_assert",
    "MHD_D_IS_USING_THREADS_",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "MHD_thread_handle_ID_is_current_thread_",
    "MHD_PANIC",
    "_",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "UPGRADE_SUPPORT",
    "HAVE_MESSAGES",
    "connection->urh",
    "MHD_DLOG",
    "internal_suspend_connection_",
    "struct MHD_Connection",
    "struct MHD_Daemon",
    "daemon->options",
    "daemon->tid",
    "__builtin_unreachable"
  ],
  "explanation": "For MISRA C language-extension analysis we must see the definitions/decls/macros that the function uses or expands to, because extensions may be hidden inside macros, types or called routines: \n\n- _MHD_EXTERN: may expand to compiler-specific storage-class specifiers or attributes (e.g. extern \"C\", __declspec, __attribute__), so we must inspect its definition. \n- MHD_USE_THREADS: preprocessor conditional; the macro controls code paths and may be set via compiler-specific flags or tie into extension use. \n- mhd_assert: could be a macro wrapping compiler builtins or extensions (e.g. __builtin_expect, __assert_func, inline assembly); need its expansion. \n- MHD_D_IS_USING_THREADS_: macro that may reference daemon internals or use extension constructs in its body. \n- MHD_D_IS_USING_THREAD_PER_CONN_: same reason as above. \n- MHD_thread_handle_ID_is_current_thread_: likely a function/macro checking thread id; implementations sometimes use compiler intrinsics or inline assembly\u2014must inspect. \n- MHD_PANIC: error/reporting macro \u2014 could use varargs, statement-expressions, non-standard attributes or call compiler builtins; inspect expansion. \n- _: translation macro (gettext) or localization macro \u2014 could be a macro/function that uses extensions; check its definition. \n- MHD_TEST_ALLOW_SUSPEND_RESUME: option flag macro; its type/definition affects evaluation and may be implemented via extension-dependent constructs. \n- UPGRADE_SUPPORT: conditional compile macro that changes control flow; variants may enable code using extensions. \n- HAVE_MESSAGES: conditional compile macro; its definition may bring in logging code that uses extensions. \n- connection->urh: the urh field's type or accessor might be an inline function/macro with extensions or be a union/anonymous struct (C99/C11 features) \u2014 need its declaration. \n- MHD_DLOG: logging macro/function that frequently uses varargs, attributes or compiler extensions; inspect implementation. \n- internal_suspend_connection_: the called function's definition may itself use compiler builtins or nonstandard pragmas/attributes that affect whether the target uses extensions indirectly (macro inlines, attributes). \n- struct MHD_Connection: full struct declaration to check for use of C extensions in its fields (anonymous unions/structs, flexible array members, attributes, bit-field widths with non-standard types). \n- struct MHD_Daemon: same as above; also used for daemon->options/daemon->tid field types. \n- daemon->options: type and any macros used to access flags may involve extensions (bitfield widths, enums with attributes). \n- daemon->tid: thread id type \u2014 may be a typedef to a compiler-specific handle or use thread-local storage, requiring inspection for extensions. \n- __builtin_unreachable: builtin noted in static graph; even if not directly in the source shown, macros or callees reachable from this function may expand to builtin intrinsics \u2014 include to detect GCC/Clang builtins (explicit language extensions).\n\nCollecting these symbols (and their definitions/expansions) allows checking whether the target function source or any macro/function it expands to uses compiler-specific language extensions that would violate the MISRA rule."
}