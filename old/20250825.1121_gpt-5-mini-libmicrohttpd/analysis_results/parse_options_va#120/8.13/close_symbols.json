{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  const char *pstr;\n#if GNUTLS_VERSION_MAJOR >= 3\n  gnutls_certificate_retrieve_function2 * pgcrf;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  gnutls_certificate_retrieve_function3 * pgcrf2;\n#endif\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    /* Increase counter at start, so resulting value is number of\n     * processed options, including any failed ones. */\n    params->num_opts++;\n    switch (opt)\n    {\n    case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n\n        if (0 != val)\n        {\n          daemon->pool_increment = val;\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_INCREMENT value is \" \\\n                         \"too large and rounded down to 1/4 of \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_increment = daemon->pool_size / 4;\n          }\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_LIMIT:\n      daemon->connection_limit = va_arg (ap,\n                                         unsigned int);\n      break;\n    case MHD_OPTION_CONNECTION_TIMEOUT:\n      uv = va_arg (ap,\n                   unsigned int);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n      if ((UINT64_MAX / 4000 - 1) < uv)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"The specified connection timeout (%u) is too large. \" \\\n                     \"Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                     \"instead.\\n\"),\n                  uv,\n                  (UINT64_MAX / 4000 - 1));\n#endif\n        uv = UINT64_MAX / 4000 - 1;\n      }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n      daemon->connection_timeout_ms = ((uint64_t) uv) * 1000;\n      break;\n    case MHD_OPTION_NOTIFY_COMPLETED:\n      daemon->notify_completed = va_arg (ap,\n                                         MHD_RequestCompletedCallback);\n      daemon->notify_completed_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_NOTIFY_CONNECTION:\n      daemon->notify_connection = va_arg (ap,\n                                          MHD_NotifyConnectionCallback);\n      daemon->notify_connection_cls = va_arg (ap,\n                                              void *);\n      break;\n    case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n      daemon->per_ip_connection_limit = va_arg (ap,\n                                                unsigned int);\n      break;\n    case MHD_OPTION_SOCK_ADDR_LEN:\n      params->server_addr_len = va_arg (ap,\n                                        socklen_t);\n      params->server_addr_len_set = true;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_SOCK_ADDR:\n      params->server_addr_len_set = false;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_URI_LOG_CALLBACK:\n      daemon->uri_log_callback = va_arg (ap,\n                                         LogCallback);\n      daemon->uri_log_callback_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_SERVER_INSANITY:\n      daemon->insanity_level = (enum MHD_DisableSanityCheck)\n                               va_arg (ap,\n                                       unsigned int);\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_POOL_SIZE:\n      daemon->worker_pool_size = va_arg (ap,\n                                         unsigned int);\n      if (0 == daemon->worker_pool_size)\n      {\n        (void) 0; /* MHD_OPTION_THREAD_POOL_SIZE ignored, do nothing */\n      }\n      else if (1 == daemon->worker_pool_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Warning: value \\\"1\\\", specified as the thread pool \" \\\n                     \"size, is ignored. Thread pool is not used.\\n\"));\n#endif\n        daemon->worker_pool_size = 0;\n      }\n#if SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2)\n      /* Next comparison could be always false on some platforms and whole branch will\n       * be optimized out on these platforms. On others it will be compiled into real\n       * check. */\n      else if (daemon->worker_pool_size >=\n               (SIZE_MAX / sizeof (struct MHD_Daemon)))            /* Compiler may warn on some platforms, ignore warning. */\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Specified thread pool size (%u) too big.\\n\"),\n                  daemon->worker_pool_size);\n#endif\n        return MHD_NO;\n      }\n#endif /* SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2) */\n      else\n      {\n        if (! MHD_D_IS_USING_THREADS_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n                       \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n                       \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n      }\n      break;\n#endif\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_key = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_key_password = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_CERT:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_cert = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_trust = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n      daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                              int);\n      break;\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        gnutls_datum_t dhpar;\n        size_t pstr_len;\n\n        if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Error initializing DH parameters.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n        pstr_len = strlen (pstr);\n        if (UINT_MAX < pstr_len)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Diffie-Hellman parameters string too long.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.size = (unsigned int) pstr_len;\n        if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                           &dhpar,\n                                           GNUTLS_X509_FMT_PEM) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Bad Diffie-Hellman parameters format.\\n\"));\n#endif\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          return MHD_NO;\n        }\n        daemon->have_dhparams = true;\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        if (NULL != daemon->priority_cache)\n          gnutls_priority_deinit (daemon->priority_cache);\n\n        if (MHD_OPTION_HTTPS_PRIORITIES == opt)\n        {\n          int init_res;\n          const char *err_pos;\n          init_res = gnutls_priority_init (&daemon->priority_cache,\n                                           pstr,\n                                           &err_pos);\n          if (GNUTLS_E_SUCCESS != init_res)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Setting priorities to '%s' failed: %s \" \\\n                         \"The problematic part starts at: %s\\n\"),\n                      pstr,\n                      gnutls_strerror (init_res),\n                      err_pos);\n#endif\n            daemon->priority_cache = NULL;\n            return MHD_NO;\n          }\n        }\n        else\n        {\n          /* The cache has been deinited */\n          daemon->priority_cache = NULL;\n          if (! daemon_tls_priorities_init_append (daemon, pstr))\n            return MHD_NO;\n        }\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building \" \\\n                   \"MHD with GnuTLS >= 3.0.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf = va_arg (ap,\n                      gnutls_certificate_retrieve_function2 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback = pgcrf;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /*  HAVE_MESSAGES */\n      break;\n#endif\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#if GNUTLS_VERSION_NUMBER < 0x030603\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK2 requires building \" \\\n                   \"MHD with GnuTLS >= 3.6.3.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf2 = va_arg (ap,\n                       gnutls_certificate_retrieve_function3 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback2 = pgcrf2;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /* HAVE_MESSAGES */\n      break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n      daemon->digest_auth_rand_size = va_arg (ap,\n                                              size_t);\n      daemon->digest_auth_random = va_arg (ap,\n                                           const char *);\n      if (MHD_OPTION_DIGEST_AUTH_RANDOM_COPY == opt)\n        /* Set to some non-NULL value just to indicate that copy is required. */\n        daemon->digest_auth_random_copy = daemon;\n      else\n        daemon->digest_auth_random_copy = NULL;\n      break;\n    case MHD_OPTION_NONCE_NC_SIZE:\n      daemon->nonce_nc_size = va_arg (ap,\n                                      unsigned int);\n      break;\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n      daemon->dauth_bind_type = va_arg (ap,\n                                        unsigned int);\n      if (0 != (daemon->dauth_bind_type & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n        daemon->dauth_bind_type |= MHD_DAUTH_BIND_NONCE_URI;\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n      if (1)\n      {\n        unsigned int val;\n        val = va_arg (ap,\n                      unsigned int);\n        if (0 != val)\n          daemon->dauth_def_nonce_timeout = val;\n      }\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n      if (1)\n      {\n        uint32_t val;\n        val = va_arg (ap,\n                      uint32_t);\n        if (0 != val)\n          daemon->dauth_def_max_nc = val;\n      }\n      break;\n#else  /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n    case MHD_OPTION_NONCE_NC_SIZE:\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Digest Auth is disabled for this build \" \\\n                   \"of GNU libmicrohttpd.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_LISTEN_SOCKET:\n      params->listen_fd = va_arg (ap,\n                                  MHD_socket);\n      params->listen_fd_set = true;\n      break;\n    case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n      daemon->custom_error_log = va_arg (ap,\n                                         VfprintfFunctionPointerType);\n      daemon->custom_error_log_cls = va_arg (ap,\n                                             void *);\n      if (1 != params->num_opts)\n        MHD_DLOG (daemon,\n                  _ (\"MHD_OPTION_EXTERNAL_LOGGER is not the first option \"\n                     \"specified for the daemon. Some messages may be \"\n                     \"printed by the standard MHD logger.\\n\"));\n\n#else\n      (void) va_arg (ap,\n                     VfprintfFunctionPointerType);\n      (void) va_arg (ap,\n                     void *);\n#endif\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_STACK_SIZE:\n      daemon->thread_stack_size = va_arg (ap,\n                                          size_t);\n      break;\n#endif\n    case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n#ifdef TCP_FASTOPEN\n      daemon->fastopen_queue_size = va_arg (ap,\n                                            unsigned int);\n      break;\n#else  /* ! TCP_FASTOPEN */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"TCP fastopen is not supported on this platform.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! TCP_FASTOPEN */\n    case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n      daemon->listening_address_reuse = va_arg (ap,\n                                                unsigned int) ? 1 : -1;\n      break;\n    case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n      daemon->listen_backlog_size = va_arg (ap,\n                                            unsigned int);\n      break;\n    case MHD_OPTION_STRICT_FOR_CLIENT:\n      daemon->client_discipline = va_arg (ap, int); /* Temporal assignment */\n      /* Map to correct value */\n      if (-1 >= daemon->client_discipline)\n        daemon->client_discipline = -3;\n      else if (1 <= daemon->client_discipline)\n        daemon->client_discipline = 1;\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_STRICT_CLIENT.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n      daemon->client_discipline = va_arg (ap, int);\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_CLIENT_DISCIPLINE_LVL.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_ARRAY:\n      params->num_opts--; /* Do not count MHD_OPTION_ARRAY */\n      oa = va_arg (ap, struct MHD_OptionItem *);\n      i = 0;\n      while (MHD_OPTION_END != (opt = oa[i].option))\n      {\n        switch (opt)\n        {\n        /* all options taking 'size_t' */\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'unsigned int' */\n        case MHD_OPTION_NONCE_NC_SIZE:\n        case MHD_OPTION_CONNECTION_LIMIT:\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n        case MHD_OPTION_THREAD_POOL_SIZE:\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n        case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n        case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n        case MHD_OPTION_SERVER_INSANITY:\n        case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (unsigned int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'enum' */\n        case MHD_OPTION_HTTPS_CRED_TYPE:\n#ifdef HTTPS_SUPPORT\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (gnutls_credentials_type_t) oa[i].value,\n                                       MHD_OPTION_END))\n#endif /* HTTPS_SUPPORT */\n          return MHD_NO;\n          break;\n        /* all options taking 'MHD_socket' */\n        case MHD_OPTION_LISTEN_SOCKET:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (MHD_socket) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'int' */\n        case MHD_OPTION_STRICT_FOR_CLIENT:\n        case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n        case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n        case MHD_OPTION_TLS_NO_ALPN:\n        case MHD_OPTION_APP_FD_SETSIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'uint32_t' */\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (uint32_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking one pointer */\n        case MHD_OPTION_SOCK_ADDR:\n        case MHD_OPTION_HTTPS_MEM_KEY:\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n        case MHD_OPTION_HTTPS_MEM_CERT:\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n        case MHD_OPTION_HTTPS_PRIORITIES:\n        case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n        case MHD_OPTION_ARRAY:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking two pointers */\n        case MHD_OPTION_NOTIFY_COMPLETED:\n        case MHD_OPTION_NOTIFY_CONNECTION:\n        case MHD_OPTION_URI_LOG_CALLBACK:\n        case MHD_OPTION_EXTERNAL_LOGGER:\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n        case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (void *) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking size_t-number followed by pointer */\n        case MHD_OPTION_DIGEST_AUTH_RANDOM:\n        case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking socklen_t-number followed by pointer */\n        case MHD_OPTION_SOCK_ADDR_LEN:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (socklen_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        case MHD_OPTION_END: /* Not possible */\n        default:\n          return MHD_NO;\n        }\n        i++;\n      }\n      break;\n    case MHD_OPTION_UNESCAPE_CALLBACK:\n      daemon->unescape_callback = va_arg (ap,\n                                          UnescapeCallback);\n      daemon->unescape_callback_cls = va_arg (ap,\n                                              void *);\n      break;\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n#if GNUTLS_VERSION_MAJOR >= 3\n      daemon->cred_callback = va_arg (ap,\n                                      MHD_PskServerCredentialsCallback);\n      daemon->cred_callback_cls = va_arg (ap,\n                                          void *);\n      break;\n#else\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD compiled \" \\\n                   \"without GNUtls >= 3.\\n\"),\n                opt);\n      return MHD_NO;\n#endif\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n      if (! MHD_D_IS_USING_THREADS_ (daemon))\n        daemon->sigpipe_blocked = ( (va_arg (ap,\n                                             int)) != 0);\n      else\n      {\n        (void) va_arg (ap,\n                       int);\n      }\n      break;\n    case MHD_OPTION_TLS_NO_ALPN:\n#ifdef HTTPS_SUPPORT\n      daemon->disable_alpn = (va_arg (ap,\n                                      int) != 0);\n#else  /* ! HTTPS_SUPPORT */\n      (void) va_arg (ap, int);\n#endif /* ! HTTPS_SUPPORT */\n#ifdef HAVE_MESSAGES\n      if (0 == (daemon->options & MHD_USE_TLS))\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD \" \\\n                     \"but MHD_USE_TLS not set.\\n\"),\n                  (int) opt);\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_APP_FD_SETSIZE:\n      params->fdset_size_set = true;\n      params->fdset_size = va_arg (ap,\n                                   int);\n      break;\n#ifndef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n    case MHD_OPTION_HTTPS_MEM_CERT:\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD \"\n                   \"compiled without HTTPS support.\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_END: /* Not possible */\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Invalid option %d! (Did you terminate \"\n                   \"the list with MHD_OPTION_END?).\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'parse_options_va': {'callees': ['MHD_DLOG', 'parse_options'], 'callers': ['parse_options', 'MHD_start_daemon_va']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'parse_options': {'callees': ['parse_options_va'], 'callers': ['parse_options_va']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "struct MHD_InterimParams_",
    "struct MHD_OptionItem",
    "parse_options",
    "_MHD_DROP_CONST",
    "MHD_socket",
    "VfprintfFunctionPointerType",
    "LogCallback",
    "UnescapeCallback",
    "MHD_RequestCompletedCallback",
    "MHD_NotifyConnectionCallback",
    "MHD_PskServerCredentialsCallback",
    "gnutls_certificate_retrieve_function2",
    "gnutls_certificate_retrieve_function3",
    "gnutls_credentials_type_t",
    "gnutls_datum_t",
    "gnutls_dh_params_init",
    "gnutls_dh_params_import_pkcs3",
    "gnutls_dh_params_deinit",
    "gnutls_priority_init",
    "gnutls_priority_deinit",
    "gnutls_strerror",
    "GNUTLS_E_SUCCESS",
    "GNUTLS_X509_FMT_PEM"
  ],
  "explanation": "To check whether parse_options_va violates the MISRA rule that pointers should be const-qualified where possible you must see the actual declarations/types where pointers are stored, assigned, or converted. The listed symbols are required for that analysis for the reasons below:\n\n- struct MHD_Daemon: contains the members assigned in this function (e.g. https_mem_key, https_mem_cert, https_mem_trust, https_key_password, https_mem_dhparams, priority_cache, cert_callback, cert_callback2, cred_callback, digest_auth_random, digest_auth_random_copy, notify_completed_cls, notify_connection_cls, uri_log_callback_cls, unescape_callback_cls, etc.). You must inspect each member's declaration to determine whether it is declared as a pointer to const (e.g. const char *) or a non-const pointer (char * / void *). Assignments from const-qualified sources to non-const members or vice versa are directly relevant to the MISRA rule.\n\n- struct MHD_InterimParams_: contains fields set in this function that are pointers (e.g. pserver_addr) and flags (pserver_addr_set, server_addr_len_set, fdset_size_set). The actual declaration of the pointer fields (const struct sockaddr * vs struct sockaddr *) is needed to check const-qualification correctness.\n\n- struct MHD_OptionItem: provides the types of oa[i].value and oa[i].ptr_value used in array handling. You need to know whether ptr_value is declared as const void * or void * (and similarly typed value/ptr_value combinations) because parse_options_va passes oa[i].ptr_value into parse_options and does pointer casts; that affects const correctness.\n\n- parse_options: prototype/signature. parse_options_va calls parse_options repeatedly with various argument types (including pointer arguments). You must know parse_options parameter types (whether it expects const pointers) to decide if passing non-const pointers or casting away const violates the rule.\n\n- _MHD_DROP_CONST: macro/function used to drop constness from pstr before assigning into a gnutls_datum_t .data (dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr)). The definition is required to determine whether the code intentionally strips const and whether that is acceptable under MISRA; presence and semantics of this macro are central to assessing const-qualification violations.\n\n- MHD_socket: typedef for listen_fd; if pointer-to-socket types appear, their declarations may affect constness checks (less likely but included for completeness).\n\n- VfprintfFunctionPointerType, LogCallback, UnescapeCallback, MHD_RequestCompletedCallback, MHD_NotifyConnectionCallback, MHD_PskServerCredentialsCallback: the function-pointer typedefs for callbacks and the external logger. The MISRA rule applies to pointer-to-data types and also to pointer-to-function parameters/contexts (e.g. callback cls pointers). You must see whether the callback context fields in struct MHD_Daemon and the typedefs themselves use const qualifications (e.g. void * vs const void *) and whether parse_options_va assigns const-qualified pointers into non-const fields or vice versa.\n\n- gnutls_certificate_retrieve_function2, gnutls_certificate_retrieve_function3: the GnuTLS callback function-pointer types assigned into daemon->cert_callback and cert_callback2. Their typedefs and whether the daemon fields are declared const-qualified are necessary to check pointer constness correctness for function-pointer assignments.\n\n- gnutls_credentials_type_t: type for cred_type assignment (not a pointer itself, but included for completeness to inspect related declarations).\n\n- gnutls_datum_t: structure used to import DH parameters (contains data pointer and size). You must inspect gnutls_datum_t.data declaration (unsigned char *) and how parse_options_va assigns a const char * (pstr) into dhpar.data after _MHD_DROP_CONST \u2014 this is a direct constness concern.\n\n- gnutls_dh_params_init, gnutls_dh_params_import_pkcs3, gnutls_dh_params_deinit: function signatures are needed to see whether they take pointers to mutable data or const data (e.g. whether import expects a const gnutls_datum_t * or a gnutls_datum_t *). That determines whether providing a non-const datum (created from a const source) is required or could be const.\n\n- gnutls_priority_init, gnutls_priority_deinit, gnutls_strerror, GNUTLS_E_SUCCESS, GNUTLS_X509_FMT_PEM: priority and error handling symbols are referenced; you need their prototypes/definitions to know whether priority strings passed (pstr) could and should be const-qualified when stored or passed to library APIs.\n\nIn short, to determine if parse_options_va violates the MISRA pointer-const rule you must inspect the declarations of all struct members and function prototypes that receive or store pointers (especially const char * sources like pstr and oa[i].ptr_value). The symbols above supply those declarations and macros that perform explicit const-dropping; without them you cannot conclude whether the code removes const unnecessarily or correctly uses const-qualified pointers."
}