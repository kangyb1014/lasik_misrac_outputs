{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of parse_options_va:\n```c\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  const char *pstr;\n#if GNUTLS_VERSION_MAJOR >= 3\n  gnutls_certificate_retrieve_function2 * pgcrf;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  gnutls_certificate_retrieve_function3 * pgcrf2;\n#endif\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    /* Increase counter at start, so resulting value is number of\n     * processed options, including any failed ones. */\n    params->num_opts++;\n    switch (opt)\n    {\n    case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n\n        if (0 != val)\n        {\n          daemon->pool_increment = val;\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_INCREMENT value is \" \\\n                         \"too large and rounded down to 1/4 of \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_increment = daemon->pool_size / 4;\n          }\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_LIMIT:\n      daemon->connection_limit = va_arg (ap,\n                                         unsigned int);\n      break;\n    case MHD_OPTION_CONNECTION_TIMEOUT:\n      uv = va_arg (ap,\n                   unsigned int);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n      if ((UINT64_MAX / 4000 - 1) < uv)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"The specified connection timeout (%u) is too large. \" \\\n                     \"Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                     \"instead.\\n\"),\n                  uv,\n                  (UINT64_MAX / 4000 - 1));\n#endif\n        uv = UINT64_MAX / 4000 - 1;\n      }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n      daemon->connection_timeout_ms = ((uint64_t) uv) * 1000;\n      break;\n    case MHD_OPTION_NOTIFY_COMPLETED:\n      daemon->notify_completed = va_arg (ap,\n                                         MHD_RequestCompletedCallback);\n      daemon->notify_completed_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_NOTIFY_CONNECTION:\n      daemon->notify_connection = va_arg (ap,\n                                          MHD_NotifyConnectionCallback);\n      daemon->notify_connection_cls = va_arg (ap,\n                                              void *);\n      break;\n    case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n      daemon->per_ip_connection_limit = va_arg (ap,\n                                                unsigned int);\n      break;\n    case MHD_OPTION_SOCK_ADDR_LEN:\n      params->server_addr_len = va_arg (ap,\n                                        socklen_t);\n      params->server_addr_len_set = true;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_SOCK_ADDR:\n      params->server_addr_len_set = false;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_URI_LOG_CALLBACK:\n      daemon->uri_log_callback = va_arg (ap,\n                                         LogCallback);\n      daemon->uri_log_callback_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_SERVER_INSANITY:\n      daemon->insanity_level = (enum MHD_DisableSanityCheck)\n                               va_arg (ap,\n                                       unsigned int);\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_POOL_SIZE:\n      daemon->worker_pool_size = va_arg (ap,\n                                         unsigned int);\n      if (0 == daemon->worker_pool_size)\n      {\n        (void) 0; /* MHD_OPTION_THREAD_POOL_SIZE ignored, do nothing */\n      }\n      else if (1 == daemon->worker_pool_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Warning: value \\\"1\\\", specified as the thread pool \" \\\n                     \"size, is ignored. Thread pool is not used.\\n\"));\n#endif\n        daemon->worker_pool_size = 0;\n      }\n#if SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2)\n      /* Next comparison could be always false on some platforms and whole branch will\n       * be optimized out on these platforms. On others it will be compiled into real\n       * check. */\n      else if (daemon->worker_pool_size >=\n               (SIZE_MAX / sizeof (struct MHD_Daemon)))            /* Compiler may warn on some platforms, ignore warning. */\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Specified thread pool size (%u) too big.\\n\"),\n                  daemon->worker_pool_size);\n#endif\n        return MHD_NO;\n      }\n#endif /* SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2) */\n      else\n      {\n        if (! MHD_D_IS_USING_THREADS_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n                       \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n                       \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n      }\n      break;\n#endif\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_key = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_key_password = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_CERT:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_cert = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_trust = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n      daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                              int);\n      break;\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        gnutls_datum_t dhpar;\n        size_t pstr_len;\n\n        if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Error initializing DH parameters.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n        pstr_len = strlen (pstr);\n        if (UINT_MAX < pstr_len)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Diffie-Hellman parameters string too long.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.size = (unsigned int) pstr_len;\n        if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                           &dhpar,\n                                           GNUTLS_X509_FMT_PEM) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Bad Diffie-Hellman parameters format.\\n\"));\n#endif\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          return MHD_NO;\n        }\n        daemon->have_dhparams = true;\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        if (NULL != daemon->priority_cache)\n          gnutls_priority_deinit (daemon->priority_cache);\n\n        if (MHD_OPTION_HTTPS_PRIORITIES == opt)\n        {\n          int init_res;\n          const char *err_pos;\n          init_res = gnutls_priority_init (&daemon->priority_cache,\n                                           pstr,\n                                           &err_pos);\n          if (GNUTLS_E_SUCCESS != init_res)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Setting priorities to '%s' failed: %s \" \\\n                         \"The problematic part starts at: %s\\n\"),\n                      pstr,\n                      gnutls_strerror (init_res),\n                      err_pos);\n#endif\n            daemon->priority_cache = NULL;\n            return MHD_NO;\n          }\n        }\n        else\n        {\n          /* The cache has been deinited */\n          daemon->priority_cache = NULL;\n          if (! daemon_tls_priorities_init_append (daemon, pstr))\n            return MHD_NO;\n        }\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building \" \\\n                   \"MHD with GnuTLS >= 3.0.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf = va_arg (ap,\n                      gnutls_certificate_retrieve_function2 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback = pgcrf;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /*  HAVE_MESSAGES */\n      break;\n#endif\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#if GNUTLS_VERSION_NUMBER < 0x030603\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK2 requires building \" \\\n                   \"MHD with GnuTLS >= 3.6.3.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf2 = va_arg (ap,\n                       gnutls_certificate_retrieve_function3 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback2 = pgcrf2;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /* HAVE_MESSAGES */\n      break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n      daemon->digest_auth_rand_size = va_arg (ap,\n                                              size_t);\n      daemon->digest_auth_random = va_arg (ap,\n                                           const char *);\n      if (MHD_OPTION_DIGEST_AUTH_RANDOM_COPY == opt)\n        /* Set to some non-NULL value just to indicate that copy is required. */\n        daemon->digest_auth_random_copy = daemon;\n      else\n        daemon->digest_auth_random_copy = NULL;\n      break;\n    case MHD_OPTION_NONCE_NC_SIZE:\n      daemon->nonce_nc_size = va_arg (ap,\n                                      unsigned int);\n      break;\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n      daemon->dauth_bind_type = va_arg (ap,\n                                        unsigned int);\n      if (0 != (daemon->dauth_bind_type & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n        daemon->dauth_bind_type |= MHD_DAUTH_BIND_NONCE_URI;\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n      if (1)\n      {\n        unsigned int val;\n        val = va_arg (ap,\n                      unsigned int);\n        if (0 != val)\n          daemon->dauth_def_nonce_timeout = val;\n      }\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n      if (1)\n      {\n        uint32_t val;\n        val = va_arg (ap,\n                      uint32_t);\n        if (0 != val)\n          daemon->dauth_def_max_nc = val;\n      }\n      break;\n#else  /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n    case MHD_OPTION_NONCE_NC_SIZE:\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Digest Auth is disabled for this build \" \\\n                   \"of GNU libmicrohttpd.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_LISTEN_SOCKET:\n      params->listen_fd = va_arg (ap,\n                                  MHD_socket);\n      params->listen_fd_set = true;\n      break;\n    case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n      daemon->custom_error_log = va_arg (ap,\n                                         VfprintfFunctionPointerType);\n      daemon->custom_error_log_cls = va_arg (ap,\n                                             void *);\n      if (1 != params->num_opts)\n        MHD_DLOG (daemon,\n                  _ (\"MHD_OPTION_EXTERNAL_LOGGER is not the first option \"\n                     \"specified for the daemon. Some messages may be \"\n                     \"printed by the standard MHD logger.\\n\"));\n\n#else\n      (void) va_arg (ap,\n                     VfprintfFunctionPointerType);\n      (void) va_arg (ap,\n                     void *);\n#endif\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_STACK_SIZE:\n      daemon->thread_stack_size = va_arg (ap,\n                                          size_t);\n      break;\n#endif\n    case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n#ifdef TCP_FASTOPEN\n      daemon->fastopen_queue_size = va_arg (ap,\n                                            unsigned int);\n      break;\n#else  /* ! TCP_FASTOPEN */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"TCP fastopen is not supported on this platform.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! TCP_FASTOPEN */\n    case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n      daemon->listening_address_reuse = va_arg (ap,\n                                                unsigned int) ? 1 : -1;\n      break;\n    case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n      daemon->listen_backlog_size = va_arg (ap,\n                                            unsigned int);\n      break;\n    case MHD_OPTION_STRICT_FOR_CLIENT:\n      daemon->client_discipline = va_arg (ap, int); /* Temporal assignment */\n      /* Map to correct value */\n      if (-1 >= daemon->client_discipline)\n        daemon->client_discipline = -3;\n      else if (1 <= daemon->client_discipline)\n        daemon->client_discipline = 1;\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_STRICT_CLIENT.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n      daemon->client_discipline = va_arg (ap, int);\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_CLIENT_DISCIPLINE_LVL.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_ARRAY:\n      params->num_opts--; /* Do not count MHD_OPTION_ARRAY */\n      oa = va_arg (ap, struct MHD_OptionItem *);\n      i = 0;\n      while (MHD_OPTION_END != (opt = oa[i].option))\n      {\n        switch (opt)\n        {\n        /* all options taking 'size_t' */\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'unsigned int' */\n        case MHD_OPTION_NONCE_NC_SIZE:\n        case MHD_OPTION_CONNECTION_LIMIT:\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n        case MHD_OPTION_THREAD_POOL_SIZE:\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n        case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n        case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n        case MHD_OPTION_SERVER_INSANITY:\n        case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (unsigned int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'enum' */\n        case MHD_OPTION_HTTPS_CRED_TYPE:\n#ifdef HTTPS_SUPPORT\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (gnutls_credentials_type_t) oa[i].value,\n                                       MHD_OPTION_END))\n#endif /* HTTPS_SUPPORT */\n          return MHD_NO;\n          break;\n        /* all options taking 'MHD_socket' */\n        case MHD_OPTION_LISTEN_SOCKET:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (MHD_socket) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'int' */\n        case MHD_OPTION_STRICT_FOR_CLIENT:\n        case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n        case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n        case MHD_OPTION_TLS_NO_ALPN:\n        case MHD_OPTION_APP_FD_SETSIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'uint32_t' */\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (uint32_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking one pointer */\n        case MHD_OPTION_SOCK_ADDR:\n        case MHD_OPTION_HTTPS_MEM_KEY:\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n        case MHD_OPTION_HTTPS_MEM_CERT:\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n        case MHD_OPTION_HTTPS_PRIORITIES:\n        case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n        case MHD_OPTION_ARRAY:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking two pointers */\n        case MHD_OPTION_NOTIFY_COMPLETED:\n        case MHD_OPTION_NOTIFY_CONNECTION:\n        case MHD_OPTION_URI_LOG_CALLBACK:\n        case MHD_OPTION_EXTERNAL_LOGGER:\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n        case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (void *) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking size_t-number followed by pointer */\n        case MHD_OPTION_DIGEST_AUTH_RANDOM:\n        case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking socklen_t-number followed by pointer */\n        case MHD_OPTION_SOCK_ADDR_LEN:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (socklen_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        case MHD_OPTION_END: /* Not possible */\n        default:\n          return MHD_NO;\n        }\n        i++;\n      }\n      break;\n    case MHD_OPTION_UNESCAPE_CALLBACK:\n      daemon->unescape_callback = va_arg (ap,\n                                          UnescapeCallback);\n      daemon->unescape_callback_cls = va_arg (ap,\n                                              void *);\n      break;\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n#if GNUTLS_VERSION_MAJOR >= 3\n      daemon->cred_callback = va_arg (ap,\n                                      MHD_PskServerCredentialsCallback);\n      daemon->cred_callback_cls = va_arg (ap,\n                                          void *);\n      break;\n#else\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD compiled \" \\\n                   \"without GNUtls >= 3.\\n\"),\n                opt);\n      return MHD_NO;\n#endif\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n      if (! MHD_D_IS_USING_THREADS_ (daemon))\n        daemon->sigpipe_blocked = ( (va_arg (ap,\n                                             int)) != 0);\n      else\n      {\n        (void) va_arg (ap,\n                       int);\n      }\n      break;\n    case MHD_OPTION_TLS_NO_ALPN:\n#ifdef HTTPS_SUPPORT\n      daemon->disable_alpn = (va_arg (ap,\n                                      int) != 0);\n#else  /* ! HTTPS_SUPPORT */\n      (void) va_arg (ap, int);\n#endif /* ! HTTPS_SUPPORT */\n#ifdef HAVE_MESSAGES\n      if (0 == (daemon->options & MHD_USE_TLS))\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD \" \\\n                     \"but MHD_USE_TLS not set.\\n\"),\n                  (int) opt);\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_APP_FD_SETSIZE:\n      params->fdset_size_set = true;\n      params->fdset_size = va_arg (ap,\n                                   int);\n      break;\n#ifndef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n    case MHD_OPTION_HTTPS_MEM_CERT:\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD \"\n                   \"compiled without HTTPS support.\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_END: /* Not possible */\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Invalid option %d! (Did you terminate \"\n                   \"the list with MHD_OPTION_END?).\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function parse_options_va:\nstruct MHD_OptionItem\n{\n  /**\n   * Which option is being given.  Use #MHD_OPTION_END\n   * to terminate the array.\n   */\n  enum MHD_OPTION option;\n\n  /**\n   * Option value (for integer arguments, and for options requiring\n   * two pointer arguments); should be 0 for options that take no\n   * arguments or only a single pointer argument.\n   */\n  intptr_t value;\n\n  /**\n   * Pointer option value (use NULL for options taking no arguments\n   * or only an integer option).\n   */\n  void *ptr_value;\n\n}\n...\nstruct MHD_Daemon\n{\n\n  /**\n   * Callback function for all requests.\n   */\n  MHD_AccessHandlerCallback default_handler;\n\n  /**\n   * Closure argument to default_handler.\n   */\n  void *default_handler_cls;\n\n  /**\n   * Daemon's flags (bitfield).\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  enum MHD_FLAG options;\n\n  /**\n   * Head of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_head;\n\n  /**\n   * Tail of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_tail;\n\n  /**\n   * Head of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_head;\n\n  /**\n   * Tail of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_tail;\n\n  /**\n   * _MHD_YES if the @e listen_fd socket is a UNIX domain socket.\n   */\n  enum MHD_tristate listen_is_unix;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Head of EDLL of connections ready for processing (in epoll mode).\n   */\n  struct MHD_Connection *eready_head;\n\n  /**\n   * Tail of EDLL of connections ready for processing (in epoll mode)\n   */\n  struct MHD_Connection *eready_tail;\n\n  /**\n   * File descriptor associated with our epoll loop.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  int epoll_fd;\n\n  /**\n   * true if the @e listen_fd socket is in the 'epoll' set,\n   * false if not.\n   */\n  bool listen_socket_in_epoll;\n\n#ifdef UPGRADE_SUPPORT\n#ifdef HTTPS_SUPPORT\n  /**\n   * File descriptor associated with the #run_epoll_for_upgrade() loop.\n   * Only available if #MHD_USE_HTTPS_EPOLL_UPGRADE is set.\n   */\n  int epoll_upgrade_fd;\n\n  /**\n   * true if @e epoll_upgrade_fd is in the 'epoll' set,\n   * false if not.\n   */\n  bool upgrade_fd_in_epoll;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Head of EDLL of upgraded connections ready for processing (in epoll mode).\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_head;\n\n  /**\n   * Tail of EDLL of upgraded connections ready for processing (in epoll mode)\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_tail;\n#endif /* UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * Head of the XDLL of ALL connections with a default ('normal')\n   * timeout, sorted by timeout (earliest at the tail, most recently\n   * used connection at the head).  MHD can just look at the tail of\n   * this list to determine the timeout for all of its elements;\n   * whenever there is an event of a connection, the connection is\n   * moved back to the tail of the list.\n   *\n   * All connections by default start in this list; if a custom\n   * timeout that does not match @e connection_timeout_ms is set, they\n   * are moved to the @e manual_timeout_head-XDLL.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode as each thread\n   * needs only one connection-specific timeout.\n   */\n  struct MHD_Connection *normal_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a default timeout,\n   * sorted by timeout (earliest timeout at the tail).\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *normal_timeout_tail;\n\n  /**\n   * Head of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.  MHD will do a O(n) scan over this list to\n   * determine the current timeout.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_tail;\n\n  /**\n   * Function to call to check if we should accept or reject an\n   * incoming request.  May be NULL.\n   */\n  MHD_AcceptPolicyCallback apc;\n\n  /**\n   * Closure argument to apc.\n   */\n  void *apc_cls;\n\n  /**\n   * Function to call when we are done processing\n   * a particular request.  May be NULL.\n   */\n  MHD_RequestCompletedCallback notify_completed;\n\n  /**\n   * Closure argument to @e notify_completed.\n   */\n  void *notify_completed_cls;\n\n  /**\n   * Function to call when we are starting/stopping\n   * a connection.  May be NULL.\n   */\n  MHD_NotifyConnectionCallback notify_connection;\n\n  /**\n   * Closure argument to @e notify_connection.\n   */\n  void *notify_connection_cls;\n\n  /**\n   * Function to call with the full URI at the\n   * beginning of request processing.  May be NULL.\n   * <p>\n   * Returns the initial pointer to internal state\n   * kept by the client for the request.\n   */\n  LogCallback uri_log_callback;\n\n  /**\n   * Closure argument to @e uri_log_callback.\n   */\n  void *uri_log_callback_cls;\n\n  /**\n   * Function to call when we unescape escape sequences.\n   */\n  UnescapeCallback unescape_callback;\n\n  /**\n   * Closure for @e unescape_callback.\n   */\n  void *unescape_callback_cls;\n\n  /**\n   * Listen port.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  uint16_t port;\n\n#ifdef HAVE_MESSAGES\n  /**\n   * Function for logging error messages (if we\n   * support error reporting).\n   */\n  MHD_LogCallback custom_error_log;\n\n  /**\n   * Closure argument to @e custom_error_log.\n   */\n  void *custom_error_log_cls;\n#endif\n\n  /**\n   * Pointer to master daemon (NULL if this is the master)\n   */\n  struct MHD_Daemon *master;\n\n  /**\n   * Listen socket.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  MHD_socket listen_fd;\n\n  /**\n   * Listen socket is non-blocking.\n   */\n  bool listen_nonblk;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Worker daemons (one per thread)\n   */\n  struct MHD_Daemon *worker_pool;\n#endif\n\n  /**\n   * Table storing number of connections per IP\n   */\n  void *per_ip_connection_count;\n\n  /**\n   * Number of active parallel connections.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  unsigned int connections;\n\n  /**\n   * Size of the per-connection memory pools.\n   */\n  size_t pool_size;\n\n  /**\n   * Increment for growth of the per-connection memory pools.\n   */\n  size_t pool_increment;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Size of threads created by MHD.\n   */\n  size_t thread_stack_size;\n\n  /**\n   * Number of worker daemons\n   */\n  unsigned int worker_pool_size;\n\n  /**\n   * The select thread handle (if we have internal select)\n   */\n  MHD_thread_handle_ID_ tid;\n\n  /**\n   * Mutex for per-IP connection counts.\n   */\n  MHD_mutex_ per_ip_connection_mutex;\n\n  /**\n   * Mutex for (modifying) access to the \"cleanup\", \"normal_timeout\" and\n   * \"manual_timeout\" DLLs.\n   */\n  MHD_mutex_ cleanup_connection_mutex;\n\n  /**\n   * Mutex for any access to the \"new connections\" DL-list.\n   */\n  MHD_mutex_ new_connections_mutex;\n#endif\n\n  /**\n   * Our #MHD_OPTION_SERVER_INSANITY level, bits indicating\n   * which sanity checks are off.\n   */\n  enum MHD_DisableSanityCheck insanity_level;\n\n  /**\n   * Whether to allow/disallow/ignore reuse of listening address.\n   * The semantics is the following:\n   * 0: ignore (user did not ask for neither allow/disallow, use SO_REUSEADDR\n   *    except W32)\n   * >0: allow (use SO_REUSEPORT on most platforms, SO_REUSEADDR on Windows)\n   * <0: disallow (mostly no action, SO_EXCLUSIVEADDRUSE on Windows or SO_EXCLBIND\n   *     on Solaris)\n   */\n  int listening_address_reuse;\n\n\n  /**\n   * Inter-thread communication channel (also used to unblock\n   * select() in non-threaded code).\n   */\n  struct MHD_itc_ itc;\n\n  /**\n   * Are we shutting down?\n   */\n  volatile bool shutdown;\n\n  /**\n   * Has this daemon been quiesced via #MHD_quiesce_daemon()?\n   * If so, we should no longer use the @e listen_fd (including\n   * removing it from the @e epoll_fd when possible).\n   */\n  volatile bool was_quiesced;\n\n  /**\n   * Did we hit some system or process-wide resource limit while\n   * trying to accept() the last time? If so, we don't accept new\n   * connections until we close an existing one.  This effectively\n   * temporarily lowers the \"connection_limit\" to the current\n   * number of connections.\n   */\n  bool at_limit;\n\n  /*\n   * Do we need to process resuming connections?\n   */\n  volatile bool resuming;\n\n  /**\n   * Indicate that new connections in @e new_connections_head list\n   * need to be processed.\n   */\n  volatile bool have_new;\n\n  /**\n   * 'True' if some data is already waiting to be processed.\n   * If set to 'true' - zero timeout for select()/poll*()\n   * is used.\n   * Should be reset each time before processing connections\n   * and raised by any connection which require additional\n   * immediately processing (application does not provide\n   * data for response, data waiting in TLS buffers etc.)\n   */\n  bool data_already_pending;\n\n  /**\n   * Limit on the number of parallel connections.\n   */\n  unsigned int connection_limit;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Maximum number of connections per IP, or 0 for\n   * unlimited.\n   */\n  unsigned int per_ip_connection_limit;\n\n  /**\n   * The strictness level for parsing of incoming data.\n   * @see #MHD_OPTION_CLIENT_DISCIPLINE_LVL\n   */\n  int client_discipline;\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  /**\n   * The value of FD_SETSIZE used by the daemon.\n   * For external sockets polling this is the value provided by the application\n   * via MHD_OPTION_APP_FD_SETSIZE or current FD_SETSIZE value.\n   * For internal threads modes this is always current FD_SETSIZE value.\n   */\n  int fdset_size;\n\n  /**\n   * Indicates whether @a fdset_size value was set by application.\n   * 'false' if default value is used.\n   */\n  bool fdset_size_set_by_app;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /**\n   * True if SIGPIPE is blocked\n   */\n  bool sigpipe_blocked;\n\n#ifdef HTTPS_SUPPORT\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Head of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_head;\n\n  /**\n   * Tail of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_tail;\n#endif /* UPGRADE_SUPPORT */\n\n  /**\n   * Desired cipher algorithms.\n   */\n  gnutls_priority_t priority_cache;\n\n  /**\n   * What kind of credentials are we offering\n   * for SSL/TLS?\n   */\n  gnutls_credentials_type_t cred_type;\n\n  /**\n   * Server x509 credentials\n   */\n  gnutls_certificate_credentials_t x509_cred;\n\n  /**\n   * Diffie-Hellman parameters\n   */\n  gnutls_dh_params_t dh_params;\n\n  /**\n   * Server PSK credentials\n   */\n  gnutls_psk_server_credentials_t psk_cred;\n\n#if GNUTLS_VERSION_MAJOR >= 3\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for SNI support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK.\n   */\n  gnutls_certificate_retrieve_function2 *cert_callback;\n\n  /**\n   * Function that can be used to obtain the shared key.\n   */\n  MHD_PskServerCredentialsCallback cred_callback;\n\n  /**\n   * Closure for @e cred_callback.\n   */\n  void *cred_callback_cls;\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for OCSP stapling support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK2.\n   */\n  gnutls_certificate_retrieve_function3 *cert_callback2;\n#endif\n\n  /**\n   * Pointer to our SSL/TLS key (in ASCII) in memory.\n   */\n  const char *https_mem_key;\n\n  /**\n   * Pointer to our SSL/TLS certificate (in ASCII) in memory.\n   */\n  const char *https_mem_cert;\n\n  /**\n   * Pointer to 0-terminated HTTPS passphrase in memory.\n   */\n  const char *https_key_password;\n\n  /**\n   * Pointer to our SSL/TLS certificate authority (in ASCII) in memory.\n   */\n  const char *https_mem_trust;\n\n  /**\n   * Our Diffie-Hellman parameters in memory.\n   */\n  gnutls_dh_params_t https_mem_dhparams;\n\n  /**\n   * true if we have initialized @e https_mem_dhparams.\n   */\n  bool have_dhparams;\n\n  /**\n   * true if ALPN is disabled.\n   */\n  bool disable_alpn;\n\n  #endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n\n  /**\n   * Character array of random values.\n   */\n  const char *digest_auth_random;\n\n  /**\n   * Size of @a digest_auth_random.\n   */\n  size_t digest_auth_rand_size;\n\n  /**\n   * The malloc'ed copy of the @a digest_auth_random.\n   */\n  void *digest_auth_random_copy;\n\n  /**\n   * An array that contains the map nonce-nc.\n   */\n  struct MHD_NonceNc *nnc;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * A rw-lock for synchronizing access to @e nnc.\n   */\n  MHD_mutex_ nnc_lock;\n#endif\n\n  /**\n   * Size of the nonce-nc array.\n   */\n  unsigned int nonce_nc_size;\n\n  /**\n   * Nonce bind type.\n   */\n  unsigned int dauth_bind_type;\n\n  /**\n   * Default nonce validity length.\n   */\n  unsigned int dauth_def_nonce_timeout;\n\n  /**\n   * Default maximum nc (nonce count) value.\n   */\n  uint32_t dauth_def_max_nc;\n#endif\n\n#ifdef TCP_FASTOPEN\n  /**\n   * The queue size for incoming SYN + DATA packets.\n   */\n  unsigned int fastopen_queue_size;\n#endif\n\n  /**\n   * The size of queue for listen socket.\n   */\n  unsigned int listen_backlog_size;\n\n  /* TODO: replace with a single member */\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_listen_fd;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_epoll_fd;\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_num_connections;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_flags;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_port;\n\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  /**\n   * If set to 'true', accept() function will be used instead of accept4() even\n   * if accept4() is available.\n   * This is a workaround for zzuf, which does not support sockets created\n   * by accept4() function.\n   * There is no API to change the value of this member, it can be flipped\n   * only by direct access to the struct member.\n   */\n  bool avoid_accept4;\n#endif /* _DEBUG */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ncase MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The 'if (1)' statement inside the MHD_OPTION_CONNECTION_MEMORY_LIMIT case uses an invariant controlling expression (constant 1). Rule 14.3 forbids invariant controlling expressions except for creating infinite loops or the permitted do-while constant-false case; neither exception applies here. This is a violation."
}