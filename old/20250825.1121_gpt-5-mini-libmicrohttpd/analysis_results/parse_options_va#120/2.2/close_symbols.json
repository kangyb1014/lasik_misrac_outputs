{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  const char *pstr;\n#if GNUTLS_VERSION_MAJOR >= 3\n  gnutls_certificate_retrieve_function2 * pgcrf;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  gnutls_certificate_retrieve_function3 * pgcrf2;\n#endif\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    /* Increase counter at start, so resulting value is number of\n     * processed options, including any failed ones. */\n    params->num_opts++;\n    switch (opt)\n    {\n    case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n\n        if (0 != val)\n        {\n          daemon->pool_increment = val;\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_INCREMENT value is \" \\\n                         \"too large and rounded down to 1/4 of \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_increment = daemon->pool_size / 4;\n          }\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_LIMIT:\n      daemon->connection_limit = va_arg (ap,\n                                         unsigned int);\n      break;\n    case MHD_OPTION_CONNECTION_TIMEOUT:\n      uv = va_arg (ap,\n                   unsigned int);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n      if ((UINT64_MAX / 4000 - 1) < uv)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"The specified connection timeout (%u) is too large. \" \\\n                     \"Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                     \"instead.\\n\"),\n                  uv,\n                  (UINT64_MAX / 4000 - 1));\n#endif\n        uv = UINT64_MAX / 4000 - 1;\n      }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n      daemon->connection_timeout_ms = ((uint64_t) uv) * 1000;\n      break;\n    case MHD_OPTION_NOTIFY_COMPLETED:\n      daemon->notify_completed = va_arg (ap,\n                                         MHD_RequestCompletedCallback);\n      daemon->notify_completed_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_NOTIFY_CONNECTION:\n      daemon->notify_connection = va_arg (ap,\n                                          MHD_NotifyConnectionCallback);\n      daemon->notify_connection_cls = va_arg (ap,\n                                              void *);\n      break;\n    case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n      daemon->per_ip_connection_limit = va_arg (ap,\n                                                unsigned int);\n      break;\n    case MHD_OPTION_SOCK_ADDR_LEN:\n      params->server_addr_len = va_arg (ap,\n                                        socklen_t);\n      params->server_addr_len_set = true;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_SOCK_ADDR:\n      params->server_addr_len_set = false;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_URI_LOG_CALLBACK:\n      daemon->uri_log_callback = va_arg (ap,\n                                         LogCallback);\n      daemon->uri_log_callback_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_SERVER_INSANITY:\n      daemon->insanity_level = (enum MHD_DisableSanityCheck)\n                               va_arg (ap,\n                                       unsigned int);\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_POOL_SIZE:\n      daemon->worker_pool_size = va_arg (ap,\n                                         unsigned int);\n      if (0 == daemon->worker_pool_size)\n      {\n        (void) 0; /* MHD_OPTION_THREAD_POOL_SIZE ignored, do nothing */\n      }\n      else if (1 == daemon->worker_pool_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Warning: value \\\"1\\\", specified as the thread pool \" \\\n                     \"size, is ignored. Thread pool is not used.\\n\"));\n#endif\n        daemon->worker_pool_size = 0;\n      }\n#if SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2)\n      /* Next comparison could be always false on some platforms and whole branch will\n       * be optimized out on these platforms. On others it will be compiled into real\n       * check. */\n      else if (daemon->worker_pool_size >=\n               (SIZE_MAX / sizeof (struct MHD_Daemon)))            /* Compiler may warn on some platforms, ignore warning. */\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Specified thread pool size (%u) too big.\\n\"),\n                  daemon->worker_pool_size);\n#endif\n        return MHD_NO;\n      }\n#endif /* SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2) */\n      else\n      {\n        if (! MHD_D_IS_USING_THREADS_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n                       \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n                       \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n      }\n      break;\n#endif\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_key = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_key_password = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_CERT:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_cert = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_trust = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n      daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                              int);\n      break;\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        gnutls_datum_t dhpar;\n        size_t pstr_len;\n\n        if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Error initializing DH parameters.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n        pstr_len = strlen (pstr);\n        if (UINT_MAX < pstr_len)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Diffie-Hellman parameters string too long.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.size = (unsigned int) pstr_len;\n        if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                           &dhpar,\n                                           GNUTLS_X509_FMT_PEM) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Bad Diffie-Hellman parameters format.\\n\"));\n#endif\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          return MHD_NO;\n        }\n        daemon->have_dhparams = true;\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        if (NULL != daemon->priority_cache)\n          gnutls_priority_deinit (daemon->priority_cache);\n\n        if (MHD_OPTION_HTTPS_PRIORITIES == opt)\n        {\n          int init_res;\n          const char *err_pos;\n          init_res = gnutls_priority_init (&daemon->priority_cache,\n                                           pstr,\n                                           &err_pos);\n          if (GNUTLS_E_SUCCESS != init_res)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Setting priorities to '%s' failed: %s \" \\\n                         \"The problematic part starts at: %s\\n\"),\n                      pstr,\n                      gnutls_strerror (init_res),\n                      err_pos);\n#endif\n            daemon->priority_cache = NULL;\n            return MHD_NO;\n          }\n        }\n        else\n        {\n          /* The cache has been deinited */\n          daemon->priority_cache = NULL;\n          if (! daemon_tls_priorities_init_append (daemon, pstr))\n            return MHD_NO;\n        }\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building \" \\\n                   \"MHD with GnuTLS >= 3.0.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf = va_arg (ap,\n                      gnutls_certificate_retrieve_function2 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback = pgcrf;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /*  HAVE_MESSAGES */\n      break;\n#endif\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#if GNUTLS_VERSION_NUMBER < 0x030603\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK2 requires building \" \\\n                   \"MHD with GnuTLS >= 3.6.3.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf2 = va_arg (ap,\n                       gnutls_certificate_retrieve_function3 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback2 = pgcrf2;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /* HAVE_MESSAGES */\n      break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n      daemon->digest_auth_rand_size = va_arg (ap,\n                                              size_t);\n      daemon->digest_auth_random = va_arg (ap,\n                                           const char *);\n      if (MHD_OPTION_DIGEST_AUTH_RANDOM_COPY == opt)\n        /* Set to some non-NULL value just to indicate that copy is required. */\n        daemon->digest_auth_random_copy = daemon;\n      else\n        daemon->digest_auth_random_copy = NULL;\n      break;\n    case MHD_OPTION_NONCE_NC_SIZE:\n      daemon->nonce_nc_size = va_arg (ap,\n                                      unsigned int);\n      break;\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n      daemon->dauth_bind_type = va_arg (ap,\n                                        unsigned int);\n      if (0 != (daemon->dauth_bind_type & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n        daemon->dauth_bind_type |= MHD_DAUTH_BIND_NONCE_URI;\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n      if (1)\n      {\n        unsigned int val;\n        val = va_arg (ap,\n                      unsigned int);\n        if (0 != val)\n          daemon->dauth_def_nonce_timeout = val;\n      }\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n      if (1)\n      {\n        uint32_t val;\n        val = va_arg (ap,\n                      uint32_t);\n        if (0 != val)\n          daemon->dauth_def_max_nc = val;\n      }\n      break;\n#else  /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n    case MHD_OPTION_NONCE_NC_SIZE:\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Digest Auth is disabled for this build \" \\\n                   \"of GNU libmicrohttpd.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_LISTEN_SOCKET:\n      params->listen_fd = va_arg (ap,\n                                  MHD_socket);\n      params->listen_fd_set = true;\n      break;\n    case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n      daemon->custom_error_log = va_arg (ap,\n                                         VfprintfFunctionPointerType);\n      daemon->custom_error_log_cls = va_arg (ap,\n                                             void *);\n      if (1 != params->num_opts)\n        MHD_DLOG (daemon,\n                  _ (\"MHD_OPTION_EXTERNAL_LOGGER is not the first option \"\n                     \"specified for the daemon. Some messages may be \"\n                     \"printed by the standard MHD logger.\\n\"));\n\n#else\n      (void) va_arg (ap,\n                     VfprintfFunctionPointerType);\n      (void) va_arg (ap,\n                     void *);\n#endif\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_STACK_SIZE:\n      daemon->thread_stack_size = va_arg (ap,\n                                          size_t);\n      break;\n#endif\n    case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n#ifdef TCP_FASTOPEN\n      daemon->fastopen_queue_size = va_arg (ap,\n                                            unsigned int);\n      break;\n#else  /* ! TCP_FASTOPEN */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"TCP fastopen is not supported on this platform.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! TCP_FASTOPEN */\n    case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n      daemon->listening_address_reuse = va_arg (ap,\n                                                unsigned int) ? 1 : -1;\n      break;\n    case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n      daemon->listen_backlog_size = va_arg (ap,\n                                            unsigned int);\n      break;\n    case MHD_OPTION_STRICT_FOR_CLIENT:\n      daemon->client_discipline = va_arg (ap, int); /* Temporal assignment */\n      /* Map to correct value */\n      if (-1 >= daemon->client_discipline)\n        daemon->client_discipline = -3;\n      else if (1 <= daemon->client_discipline)\n        daemon->client_discipline = 1;\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_STRICT_CLIENT.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n      daemon->client_discipline = va_arg (ap, int);\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_CLIENT_DISCIPLINE_LVL.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_ARRAY:\n      params->num_opts--; /* Do not count MHD_OPTION_ARRAY */\n      oa = va_arg (ap, struct MHD_OptionItem *);\n      i = 0;\n      while (MHD_OPTION_END != (opt = oa[i].option))\n      {\n        switch (opt)\n        {\n        /* all options taking 'size_t' */\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'unsigned int' */\n        case MHD_OPTION_NONCE_NC_SIZE:\n        case MHD_OPTION_CONNECTION_LIMIT:\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n        case MHD_OPTION_THREAD_POOL_SIZE:\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n        case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n        case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n        case MHD_OPTION_SERVER_INSANITY:\n        case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (unsigned int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'enum' */\n        case MHD_OPTION_HTTPS_CRED_TYPE:\n#ifdef HTTPS_SUPPORT\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (gnutls_credentials_type_t) oa[i].value,\n                                       MHD_OPTION_END))\n#endif /* HTTPS_SUPPORT */\n          return MHD_NO;\n          break;\n        /* all options taking 'MHD_socket' */\n        case MHD_OPTION_LISTEN_SOCKET:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (MHD_socket) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'int' */\n        case MHD_OPTION_STRICT_FOR_CLIENT:\n        case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n        case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n        case MHD_OPTION_TLS_NO_ALPN:\n        case MHD_OPTION_APP_FD_SETSIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'uint32_t' */\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (uint32_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking one pointer */\n        case MHD_OPTION_SOCK_ADDR:\n        case MHD_OPTION_HTTPS_MEM_KEY:\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n        case MHD_OPTION_HTTPS_MEM_CERT:\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n        case MHD_OPTION_HTTPS_PRIORITIES:\n        case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n        case MHD_OPTION_ARRAY:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking two pointers */\n        case MHD_OPTION_NOTIFY_COMPLETED:\n        case MHD_OPTION_NOTIFY_CONNECTION:\n        case MHD_OPTION_URI_LOG_CALLBACK:\n        case MHD_OPTION_EXTERNAL_LOGGER:\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n        case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (void *) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking size_t-number followed by pointer */\n        case MHD_OPTION_DIGEST_AUTH_RANDOM:\n        case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking socklen_t-number followed by pointer */\n        case MHD_OPTION_SOCK_ADDR_LEN:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (socklen_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        case MHD_OPTION_END: /* Not possible */\n        default:\n          return MHD_NO;\n        }\n        i++;\n      }\n      break;\n    case MHD_OPTION_UNESCAPE_CALLBACK:\n      daemon->unescape_callback = va_arg (ap,\n                                          UnescapeCallback);\n      daemon->unescape_callback_cls = va_arg (ap,\n                                              void *);\n      break;\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n#if GNUTLS_VERSION_MAJOR >= 3\n      daemon->cred_callback = va_arg (ap,\n                                      MHD_PskServerCredentialsCallback);\n      daemon->cred_callback_cls = va_arg (ap,\n                                          void *);\n      break;\n#else\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD compiled \" \\\n                   \"without GNUtls >= 3.\\n\"),\n                opt);\n      return MHD_NO;\n#endif\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n      if (! MHD_D_IS_USING_THREADS_ (daemon))\n        daemon->sigpipe_blocked = ( (va_arg (ap,\n                                             int)) != 0);\n      else\n      {\n        (void) va_arg (ap,\n                       int);\n      }\n      break;\n    case MHD_OPTION_TLS_NO_ALPN:\n#ifdef HTTPS_SUPPORT\n      daemon->disable_alpn = (va_arg (ap,\n                                      int) != 0);\n#else  /* ! HTTPS_SUPPORT */\n      (void) va_arg (ap, int);\n#endif /* ! HTTPS_SUPPORT */\n#ifdef HAVE_MESSAGES\n      if (0 == (daemon->options & MHD_USE_TLS))\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD \" \\\n                     \"but MHD_USE_TLS not set.\\n\"),\n                  (int) opt);\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_APP_FD_SETSIZE:\n      params->fdset_size_set = true;\n      params->fdset_size = va_arg (ap,\n                                   int);\n      break;\n#ifndef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n    case MHD_OPTION_HTTPS_MEM_CERT:\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD \"\n                   \"compiled without HTTPS support.\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_END: /* Not possible */\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Invalid option %d! (Did you terminate \"\n                   \"the list with MHD_OPTION_END?).\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'parse_options_va': {'callees': ['MHD_DLOG', 'parse_options'], 'callers': ['parse_options', 'MHD_start_daemon_va']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'parse_options': {'callees': ['parse_options_va'], 'callers': ['parse_options_va']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_OPTION (all option constants used by this function, e.g. MHD_OPTION_END, MHD_OPTION_CONNECTION_MEMORY_LIMIT, MHD_OPTION_CONNECTION_MEMORY_INCREMENT, MHD_OPTION_CONNECTION_LIMIT, MHD_OPTION_CONNECTION_TIMEOUT, MHD_OPTION_NOTIFY_COMPLETED, MHD_OPTION_NOTIFY_CONNECTION, MHD_OPTION_PER_IP_CONNECTION_LIMIT, MHD_OPTION_SOCK_ADDR_LEN, MHD_OPTION_SOCK_ADDR, MHD_OPTION_URI_LOG_CALLBACK, MHD_OPTION_SERVER_INSANITY, MHD_OPTION_THREAD_POOL_SIZE, MHD_OPTION_HTTPS_MEM_KEY, MHD_OPTION_HTTPS_KEY_PASSWORD, MHD_OPTION_HTTPS_MEM_CERT, MHD_OPTION_HTTPS_MEM_TRUST, MHD_OPTION_HTTPS_CRED_TYPE, MHD_OPTION_HTTPS_MEM_DHPARAMS, MHD_OPTION_HTTPS_PRIORITIES, MHD_OPTION_HTTPS_PRIORITIES_APPEND, MHD_OPTION_HTTPS_CERT_CALLBACK, MHD_OPTION_HTTPS_CERT_CALLBACK2, MHD_OPTION_DIGEST_AUTH_RANDOM, MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, MHD_OPTION_NONCE_NC_SIZE, MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE, MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT, MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC, MHD_OPTION_LISTEN_SOCKET, MHD_OPTION_EXTERNAL_LOGGER, MHD_OPTION_THREAD_STACK_SIZE, MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE, MHD_OPTION_LISTENING_ADDRESS_REUSE, MHD_OPTION_LISTEN_BACKLOG_SIZE, MHD_OPTION_STRICT_FOR_CLIENT, MHD_OPTION_CLIENT_DISCIPLINE_LVL, MHD_OPTION_ARRAY, MHD_OPTION_UNESCAPE_CALLBACK, MHD_OPTION_GNUTLS_PSK_CRED_HANDLER, MHD_OPTION_SIGPIPE_HANDLED_BY_APP, MHD_OPTION_TLS_NO_ALPN, MHD_OPTION_APP_FD_SETSIZE"
  ],
  "explanation": "To determine whether parse_options_va contains dead code (i.e. code that can be removed without changing program behaviour) the analyser must know which branches are actually reachable and which statements have side effects visible outside the function. The following symbols are required and why:\n\n1) enum MHD_OPTION and the concrete option constants (listed): the main control flow is a switch on option values. Knowing the full enum values and their meaning is required to decide which case labels are potentially taken at runtime and which are never selected (dead). Without these specific option constants you cannot tell whether particular case blocks are reachable.\n\n2) Compile-time feature macros: HTTPS_SUPPORT, DAUTH_SUPPORT, HAVE_MESSAGES, TCP_FASTOPEN, GNUTLS_VERSION_MAJOR, GNUTLS_VERSION_NUMBER. These macros determine whether whole blocks of code are compiled in or compiled out. Code that is #ifdef'd out is not dead code (it's absent), while code that remains but only executes when a macro/compile-time condition holds may or may not be removable. You must know their values for the build to decide reachability.\n\n3) Size/width configuration macros and constants: SIZEOF_UINT64_T, SIZEOF_UNSIGNED_INT, SIZEOF_SIZE_T, SIZE_MAX, UINT64_MAX, PRIu64. These control conditional arithmetic and comparisons (e.g. the connection-timeout saturation branch). Their values affect whether those branches execute and whether adjustments to values are effective (i.e. have visible effect), so they are needed to decide if that code is semantically required.\n\n4) Runtime flags and constants used on daemon: MHD_USE_TLS, MHD_USE_PEDANTIC_CHECKS, MHD_YES, MHD_NO. These determine execution of TLS-related branches and the function's return values. To judge whether a branch has observable effect you must know what these flags mean and whether they are set in typical runs.\n\n5) Thread-related macros/helpers: MHD_D_IS_USING_THREADS_, MHD_D_IS_USING_THREAD_PER_CONN_. These predicates gate thread-pool logic; they decide whether thread-pool related branches are meaningful or inert. Their definitions and how they inspect daemon->options are required to decide reachability and side effects.\n\n6) Data structures and fields modified/read by the function: struct MHD_Daemon (fields assigned/read: pool_size, pool_increment, connection_limit, connection_timeout_ms, notify_completed, notify_completed_cls, notify_connection, notify_connection_cls, per_ip_connection_limit, https_mem_key, https_key_password, https_mem_cert, https_mem_trust, cred_type, https_mem_dhparams, have_dhparams, priority_cache, cert_callback, cert_callback2, digest_auth_rand_size, digest_auth_random, digest_auth_random_copy, nonce_nc_size, dauth_bind_type, dauth_def_nonce_timeout, dauth_def_max_nc, listen_backlog_size, listening_address_reuse, client_discipline, worker_pool_size, thread_stack_size, fastopen_queue_size, unescape_callback, unescape_callback_cls, cred_callback, cred_callback_cls, sigpipe_blocked, disable_alpn, custom_error_log, custom_error_log_cls and options/insanity_level etc.). These field definitions are necessary to determine whether the assignments in each case produce externally observable state changes (i.e. not dead) or only touch ephemeral/local state.\n\n7) struct MHD_InterimParams_ and struct MHD_OptionItem (fields used: num_opts, server_addr_len, server_addr_len_set, pserver_addr, pserver_addr_set, listen_fd, listen_fd_set, fdset_size_set, fdset_size; and for MHD_OptionItem: option, value, ptr_value). The function increments and sets these fields; knowing their use elsewhere is necessary to decide whether those assignments are required for program behaviour.\n\n8) parse_options (the wrapper that calls parse_options_va): parse_options_va is called recursively via parse_options and MHD_OPTION_ARRAY handling; to know whether ARRAY handling is needed and whether the recursive calls are ever invoked you must see parse_options semantics and its callers.\n\n9) Logging and helper functions used inside branches: MHD_DLOG, daemon_tls_priorities_init_append, _MHD_DROP_CONST, strlen. MHD_DLOG calls may be compiled out (HAVE_MESSAGES) but when present they have side effects (logging). gnutls/priority/dh functions below are also side-effectful (see 10). Knowing whether logging occurs is required to decide if a branch is removable.\n\n10) GnuTLS-related functions/types used inside HTTPS branches: gnutls_dh_params_init, gnutls_dh_params_import_pkcs3, gnutls_dh_params_deinit, gnutls_priority_init, gnutls_priority_deinit, gnutls_strerror, gnutls_certificate_retrieve_function2/3 types, gnutls_credentials_type_t, gnutls_datum_t. These calls allocate/init or deinit library objects and return status; they have side effects external to the function and can fail, causing early returns. To establish whether the HTTPS branches are dead you must know whether these functions/types are present and what side effects their calls produce.\n\n11) Standard helpers/constants used in argument handling and type casts: strlen, UINT_MAX, UINT64_MAX. These affect bounds checks and error returns, thus influencing whether code paths are necessary.\n\n12) Callback type names used (only for completeness of side-effect analysis): MHD_RequestCompletedCallback, MHD_NotifyConnectionCallback, LogCallback, UnescapeCallback, MHD_PskServerCredentialsCallback and VfprintfFunctionPointerType. Assigning callback pointers changes behaviour of later processing; to decide removability you must know whether those pointers are observable elsewhere.\n\n13) Any platform socket types/macros used by cases: MHD_socket, socklen_t. These types affect how listen_fd and server_addr_len usage is interpreted by other code and whether those assignments are necessary.\n\nIn short: you need the enum option definitions, compile-time feature macros and platform-size macros, the MHD_Daemon and MHD_InterimParams_/MHD_OptionItem layout, parse_options declaration, logging and GnuTLS APIs and the runtime flag macros/predicates. With those symbols you can decide which branches are compiled in, which can be triggered at runtime, and which perform externally visible side effects (thus not dead)."
}