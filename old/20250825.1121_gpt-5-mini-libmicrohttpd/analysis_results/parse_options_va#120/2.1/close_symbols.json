{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  const char *pstr;\n#if GNUTLS_VERSION_MAJOR >= 3\n  gnutls_certificate_retrieve_function2 * pgcrf;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  gnutls_certificate_retrieve_function3 * pgcrf2;\n#endif\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    /* Increase counter at start, so resulting value is number of\n     * processed options, including any failed ones. */\n    params->num_opts++;\n    switch (opt)\n    {\n    case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n\n        if (0 != val)\n        {\n          daemon->pool_increment = val;\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_INCREMENT value is \" \\\n                         \"too large and rounded down to 1/4 of \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_increment = daemon->pool_size / 4;\n          }\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_LIMIT:\n      daemon->connection_limit = va_arg (ap,\n                                         unsigned int);\n      break;\n    case MHD_OPTION_CONNECTION_TIMEOUT:\n      uv = va_arg (ap,\n                   unsigned int);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n      if ((UINT64_MAX / 4000 - 1) < uv)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"The specified connection timeout (%u) is too large. \" \\\n                     \"Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                     \"instead.\\n\"),\n                  uv,\n                  (UINT64_MAX / 4000 - 1));\n#endif\n        uv = UINT64_MAX / 4000 - 1;\n      }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n      daemon->connection_timeout_ms = ((uint64_t) uv) * 1000;\n      break;\n    case MHD_OPTION_NOTIFY_COMPLETED:\n      daemon->notify_completed = va_arg (ap,\n                                         MHD_RequestCompletedCallback);\n      daemon->notify_completed_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_NOTIFY_CONNECTION:\n      daemon->notify_connection = va_arg (ap,\n                                          MHD_NotifyConnectionCallback);\n      daemon->notify_connection_cls = va_arg (ap,\n                                              void *);\n      break;\n    case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n      daemon->per_ip_connection_limit = va_arg (ap,\n                                                unsigned int);\n      break;\n    case MHD_OPTION_SOCK_ADDR_LEN:\n      params->server_addr_len = va_arg (ap,\n                                        socklen_t);\n      params->server_addr_len_set = true;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_SOCK_ADDR:\n      params->server_addr_len_set = false;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_URI_LOG_CALLBACK:\n      daemon->uri_log_callback = va_arg (ap,\n                                         LogCallback);\n      daemon->uri_log_callback_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_SERVER_INSANITY:\n      daemon->insanity_level = (enum MHD_DisableSanityCheck)\n                               va_arg (ap,\n                                       unsigned int);\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_POOL_SIZE:\n      daemon->worker_pool_size = va_arg (ap,\n                                         unsigned int);\n      if (0 == daemon->worker_pool_size)\n      {\n        (void) 0; /* MHD_OPTION_THREAD_POOL_SIZE ignored, do nothing */\n      }\n      else if (1 == daemon->worker_pool_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Warning: value \\\"1\\\", specified as the thread pool \" \\\n                     \"size, is ignored. Thread pool is not used.\\n\"));\n#endif\n        daemon->worker_pool_size = 0;\n      }\n#if SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2)\n      /* Next comparison could be always false on some platforms and whole branch will\n       * be optimized out on these platforms. On others it will be compiled into real\n       * check. */\n      else if (daemon->worker_pool_size >=\n               (SIZE_MAX / sizeof (struct MHD_Daemon)))            /* Compiler may warn on some platforms, ignore warning. */\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Specified thread pool size (%u) too big.\\n\"),\n                  daemon->worker_pool_size);\n#endif\n        return MHD_NO;\n      }\n#endif /* SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2) */\n      else\n      {\n        if (! MHD_D_IS_USING_THREADS_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n                       \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n                       \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n      }\n      break;\n#endif\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_key = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_key_password = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_CERT:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_cert = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_trust = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n      daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                              int);\n      break;\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        gnutls_datum_t dhpar;\n        size_t pstr_len;\n\n        if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Error initializing DH parameters.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n        pstr_len = strlen (pstr);\n        if (UINT_MAX < pstr_len)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Diffie-Hellman parameters string too long.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.size = (unsigned int) pstr_len;\n        if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                           &dhpar,\n                                           GNUTLS_X509_FMT_PEM) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Bad Diffie-Hellman parameters format.\\n\"));\n#endif\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          return MHD_NO;\n        }\n        daemon->have_dhparams = true;\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        if (NULL != daemon->priority_cache)\n          gnutls_priority_deinit (daemon->priority_cache);\n\n        if (MHD_OPTION_HTTPS_PRIORITIES == opt)\n        {\n          int init_res;\n          const char *err_pos;\n          init_res = gnutls_priority_init (&daemon->priority_cache,\n                                           pstr,\n                                           &err_pos);\n          if (GNUTLS_E_SUCCESS != init_res)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Setting priorities to '%s' failed: %s \" \\\n                         \"The problematic part starts at: %s\\n\"),\n                      pstr,\n                      gnutls_strerror (init_res),\n                      err_pos);\n#endif\n            daemon->priority_cache = NULL;\n            return MHD_NO;\n          }\n        }\n        else\n        {\n          /* The cache has been deinited */\n          daemon->priority_cache = NULL;\n          if (! daemon_tls_priorities_init_append (daemon, pstr))\n            return MHD_NO;\n        }\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building \" \\\n                   \"MHD with GnuTLS >= 3.0.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf = va_arg (ap,\n                      gnutls_certificate_retrieve_function2 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback = pgcrf;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /*  HAVE_MESSAGES */\n      break;\n#endif\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#if GNUTLS_VERSION_NUMBER < 0x030603\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK2 requires building \" \\\n                   \"MHD with GnuTLS >= 3.6.3.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf2 = va_arg (ap,\n                       gnutls_certificate_retrieve_function3 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback2 = pgcrf2;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /* HAVE_MESSAGES */\n      break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n      daemon->digest_auth_rand_size = va_arg (ap,\n                                              size_t);\n      daemon->digest_auth_random = va_arg (ap,\n                                           const char *);\n      if (MHD_OPTION_DIGEST_AUTH_RANDOM_COPY == opt)\n        /* Set to some non-NULL value just to indicate that copy is required. */\n        daemon->digest_auth_random_copy = daemon;\n      else\n        daemon->digest_auth_random_copy = NULL;\n      break;\n    case MHD_OPTION_NONCE_NC_SIZE:\n      daemon->nonce_nc_size = va_arg (ap,\n                                      unsigned int);\n      break;\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n      daemon->dauth_bind_type = va_arg (ap,\n                                        unsigned int);\n      if (0 != (daemon->dauth_bind_type & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n        daemon->dauth_bind_type |= MHD_DAUTH_BIND_NONCE_URI;\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n      if (1)\n      {\n        unsigned int val;\n        val = va_arg (ap,\n                      unsigned int);\n        if (0 != val)\n          daemon->dauth_def_nonce_timeout = val;\n      }\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n      if (1)\n      {\n        uint32_t val;\n        val = va_arg (ap,\n                      uint32_t);\n        if (0 != val)\n          daemon->dauth_def_max_nc = val;\n      }\n      break;\n#else  /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n    case MHD_OPTION_NONCE_NC_SIZE:\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Digest Auth is disabled for this build \" \\\n                   \"of GNU libmicrohttpd.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_LISTEN_SOCKET:\n      params->listen_fd = va_arg (ap,\n                                  MHD_socket);\n      params->listen_fd_set = true;\n      break;\n    case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n      daemon->custom_error_log = va_arg (ap,\n                                         VfprintfFunctionPointerType);\n      daemon->custom_error_log_cls = va_arg (ap,\n                                             void *);\n      if (1 != params->num_opts)\n        MHD_DLOG (daemon,\n                  _ (\"MHD_OPTION_EXTERNAL_LOGGER is not the first option \"\n                     \"specified for the daemon. Some messages may be \"\n                     \"printed by the standard MHD logger.\\n\"));\n\n#else\n      (void) va_arg (ap,\n                     VfprintfFunctionPointerType);\n      (void) va_arg (ap,\n                     void *);\n#endif\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_STACK_SIZE:\n      daemon->thread_stack_size = va_arg (ap,\n                                          size_t);\n      break;\n#endif\n    case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n#ifdef TCP_FASTOPEN\n      daemon->fastopen_queue_size = va_arg (ap,\n                                            unsigned int);\n      break;\n#else  /* ! TCP_FASTOPEN */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"TCP fastopen is not supported on this platform.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! TCP_FASTOPEN */\n    case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n      daemon->listening_address_reuse = va_arg (ap,\n                                                unsigned int) ? 1 : -1;\n      break;\n    case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n      daemon->listen_backlog_size = va_arg (ap,\n                                            unsigned int);\n      break;\n    case MHD_OPTION_STRICT_FOR_CLIENT:\n      daemon->client_discipline = va_arg (ap, int); /* Temporal assignment */\n      /* Map to correct value */\n      if (-1 >= daemon->client_discipline)\n        daemon->client_discipline = -3;\n      else if (1 <= daemon->client_discipline)\n        daemon->client_discipline = 1;\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_STRICT_CLIENT.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n      daemon->client_discipline = va_arg (ap, int);\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_CLIENT_DISCIPLINE_LVL.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_ARRAY:\n      params->num_opts--; /* Do not count MHD_OPTION_ARRAY */\n      oa = va_arg (ap, struct MHD_OptionItem *);\n      i = 0;\n      while (MHD_OPTION_END != (opt = oa[i].option))\n      {\n        switch (opt)\n        {\n        /* all options taking 'size_t' */\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'unsigned int' */\n        case MHD_OPTION_NONCE_NC_SIZE:\n        case MHD_OPTION_CONNECTION_LIMIT:\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n        case MHD_OPTION_THREAD_POOL_SIZE:\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n        case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n        case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n        case MHD_OPTION_SERVER_INSANITY:\n        case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (unsigned int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'enum' */\n        case MHD_OPTION_HTTPS_CRED_TYPE:\n#ifdef HTTPS_SUPPORT\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (gnutls_credentials_type_t) oa[i].value,\n                                       MHD_OPTION_END))\n#endif /* HTTPS_SUPPORT */\n          return MHD_NO;\n          break;\n        /* all options taking 'MHD_socket' */\n        case MHD_OPTION_LISTEN_SOCKET:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (MHD_socket) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'int' */\n        case MHD_OPTION_STRICT_FOR_CLIENT:\n        case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n        case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n        case MHD_OPTION_TLS_NO_ALPN:\n        case MHD_OPTION_APP_FD_SETSIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'uint32_t' */\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (uint32_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking one pointer */\n        case MHD_OPTION_SOCK_ADDR:\n        case MHD_OPTION_HTTPS_MEM_KEY:\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n        case MHD_OPTION_HTTPS_MEM_CERT:\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n        case MHD_OPTION_HTTPS_PRIORITIES:\n        case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n        case MHD_OPTION_ARRAY:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking two pointers */\n        case MHD_OPTION_NOTIFY_COMPLETED:\n        case MHD_OPTION_NOTIFY_CONNECTION:\n        case MHD_OPTION_URI_LOG_CALLBACK:\n        case MHD_OPTION_EXTERNAL_LOGGER:\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n        case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (void *) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking size_t-number followed by pointer */\n        case MHD_OPTION_DIGEST_AUTH_RANDOM:\n        case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking socklen_t-number followed by pointer */\n        case MHD_OPTION_SOCK_ADDR_LEN:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (socklen_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        case MHD_OPTION_END: /* Not possible */\n        default:\n          return MHD_NO;\n        }\n        i++;\n      }\n      break;\n    case MHD_OPTION_UNESCAPE_CALLBACK:\n      daemon->unescape_callback = va_arg (ap,\n                                          UnescapeCallback);\n      daemon->unescape_callback_cls = va_arg (ap,\n                                              void *);\n      break;\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n#if GNUTLS_VERSION_MAJOR >= 3\n      daemon->cred_callback = va_arg (ap,\n                                      MHD_PskServerCredentialsCallback);\n      daemon->cred_callback_cls = va_arg (ap,\n                                          void *);\n      break;\n#else\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD compiled \" \\\n                   \"without GNUtls >= 3.\\n\"),\n                opt);\n      return MHD_NO;\n#endif\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n      if (! MHD_D_IS_USING_THREADS_ (daemon))\n        daemon->sigpipe_blocked = ( (va_arg (ap,\n                                             int)) != 0);\n      else\n      {\n        (void) va_arg (ap,\n                       int);\n      }\n      break;\n    case MHD_OPTION_TLS_NO_ALPN:\n#ifdef HTTPS_SUPPORT\n      daemon->disable_alpn = (va_arg (ap,\n                                      int) != 0);\n#else  /* ! HTTPS_SUPPORT */\n      (void) va_arg (ap, int);\n#endif /* ! HTTPS_SUPPORT */\n#ifdef HAVE_MESSAGES\n      if (0 == (daemon->options & MHD_USE_TLS))\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD \" \\\n                     \"but MHD_USE_TLS not set.\\n\"),\n                  (int) opt);\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_APP_FD_SETSIZE:\n      params->fdset_size_set = true;\n      params->fdset_size = va_arg (ap,\n                                   int);\n      break;\n#ifndef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n    case MHD_OPTION_HTTPS_MEM_CERT:\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD \"\n                   \"compiled without HTTPS support.\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_END: /* Not possible */\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Invalid option %d! (Did you terminate \"\n                   \"the list with MHD_OPTION_END?).\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'parse_options_va': {'callees': ['MHD_DLOG', 'parse_options'], 'callers': ['parse_options', 'MHD_start_daemon_va']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'parse_options': {'callees': ['parse_options_va'], 'callers': ['parse_options_va']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_OPTION (enum) (esp. MHD_OPTION_END, MHD_OPTION_ARRAY and the option constants used in switch)",
    "HAVE_MESSAGES",
    "HTTPS_SUPPORT",
    "DAUTH_SUPPORT",
    "GNUTLS_VERSION_MAJOR",
    "GNUTLS_VERSION_NUMBER",
    "TCP_FASTOPEN",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "MHD_D_IS_USING_THREADS_ (macro)",
    "MHD_D_IS_USING_THREAD_PER_CONN_ (macro)",
    "MHD_USE_TLS (daemon->options bit)",
    "MHD_USE_PEDANTIC_CHECKS (daemon->options bit)",
    "parse_options (function)",
    "MHD_DLOG (function/macro)",
    "MHD_YES / MHD_NO (return/result constants)",
    "struct MHD_OptionItem (fields: option, value, ptr_value)",
    "UINT64_MAX",
    "SIZEOF_UINT64_T",
    "SIZEOF_UNSIGNED_INT",
    "SIZEOF_SIZE_T",
    "SIZE_MAX",
    "gnutls_dh_params_init",
    "gnutls_dh_params_import_pkcs3",
    "gnutls_dh_params_deinit",
    "gnutls_priority_init",
    "gnutls_priority_deinit",
    "gnutls_strerror",
    "daemon_tls_priorities_init_append",
    "MHD_socket (type)",
    "VfprintfFunctionPointerType (type)",
    "UnescapeCallback (type)",
    "MHD_PskServerCredentialsCallback (type)",
    "MHD_RequestCompletedCallback (type)",
    "MHD_NotifyConnectionCallback (type)",
    "LogCallback (type)"
  ],
  "explanation": "For MISRA C unreachable-code analysis we must know which parts of parse_options_va are compiled in and which branches can ever be taken at runtime. The following explains why each symbol is required:\n\n- MHD_OPTION (enum) (esp. MHD_OPTION_END, MHD_OPTION_ARRAY and the option constants used in switch): the entire control flow of the big switch depends on the option values provided; MHD_OPTION_END controls loop termination and reachability of the default/error cases; MHD_OPTION_ARRAY affects nested parsing paths.\n- HAVE_MESSAGES: controls compilation of many MHD_DLOG calls and some conditional logging-only branches; whether logging-only statements exist (or are compiled out) affects whether code lines are considered reachable.\n- HTTPS_SUPPORT: includes or excludes large HTTPS-specific blocks (many cases and returns). Knowing whether it is defined is needed to determine which code is actually present and potentially unreachable.\n- DAUTH_SUPPORT: similarly includes/excludes digest-auth related cases and return paths.\n- GNUTLS_VERSION_MAJOR / GNUTLS_VERSION_NUMBER: control inclusion of specific GnuTLS-dependent cases (cert callback variants); affect presence of code and compile-time path elimination.\n- TCP_FASTOPEN: controls the TCP fastopen case vs an immediate return; required to decide if that case is reachable or compiled to an unconditional return.\n- MHD_USE_POSIX_THREADS / MHD_USE_W32_THREADS: determine compilation of thread-pool related cases (thread-pool size/stack size) and thus which branches exist.\n- MHD_D_IS_USING_THREADS_ / MHD_D_IS_USING_THREAD_PER_CONN_ (macros): runtime predicates used to accept or reject options (they cause returns MHD_NO in some branches). Their definitions (what they test on daemon state) are required to know if the branches that lead to returns can ever be taken.\n- MHD_USE_TLS / MHD_USE_PEDANTIC_CHECKS (daemon->options bits): used to gate HTTPS-related assignments and logging; they affect whether certain branches are meaningful or only log a message (or are compiled-out behavior differences).\n- parse_options (function): parse_options_va calls parse_options recursively for MHD_OPTION_ARRAY items; parse_options may return MHD_NO which causes an immediate return from parse_options_va \u2014 its semantics and whether it can return MHD_NO are necessary to determine reachability of subsequent code.\n- MHD_DLOG (function/macro): many code paths only log via MHD_DLOG; while logging itself does not change control flow, whether logging statements exist (HAVE_MESSAGES vs not) affects whether lines are compiled and thus considered reachable/unreachable.\n- MHD_YES / MHD_NO (return/result constants): the function returns these; some branches return MHD_NO early \u2014 need their values/meanings to reason about control-flow exits.\n- struct MHD_OptionItem (fields: option, value, ptr_value): used by MHD_OPTION_ARRAY handling; knowledge of its layout and how nested arrays are terminated is needed to evaluate whether inner loops/returns are reachable.\n- UINT64_MAX, SIZEOF_UINT64_T, SIZEOF_UNSIGNED_INT, SIZEOF_SIZE_T, SIZE_MAX: these compile-time/constant values and sizeof macros are used in conditional compilation or run-time comparisons that can eliminate or enable branches (e.g., the connection timeout limiting logic and thread-pool-size overflow checks); their values affect whether the guarded branches are reachable.\n- gnutls_dh_params_init / gnutls_dh_params_import_pkcs3 / gnutls_dh_params_deinit / gnutls_priority_init / gnutls_priority_deinit / gnutls_strerror / daemon_tls_priorities_init_append: functions called inside HTTPS blocks can return errors that cause parse_options_va to return MHD_NO; their presence and failure modes are required to determine whether those error-return paths are reachable.\n- MHD_socket, VfprintfFunctionPointerType, UnescapeCallback, MHD_PskServerCredentialsCallback, MHD_RequestCompletedCallback, MHD_NotifyConnectionCallback, LogCallback (types): these pointer/type names identify option cases that consume arguments; their presence and expected va_arg types are necessary to reason about which cases may appear and whether their parsing code is compiled in.\n\nIn short: the list contains (a) preprocessor symbols that include/exclude code, (b) macros/constants that control conditional branches, (c) runtime predicates/macros that gate option acceptance, (d) the recursive parse_options call and GnuTLS helper functions that can cause early returns, and (e) the option/item types needed to understand the nested-array parsing. Any unreachable-code determination for parse_options_va requires these symbols to know which case-labels and branches are actually present and whether they can be executed at runtime."
}