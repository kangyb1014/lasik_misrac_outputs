{
  "user_message": "Target function code is:\n```c\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_thread_': {'callees': [], 'callers': ['MHD_create_named_thread_']}, 'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_thread_handle_ID_get_native_handle_ptr_",
    "MHD_thread_handle_ID_is_valid_handle_",
    "MHD_thread_handle_ID_set_invalid_",
    "MHD_thread_handle_ID_set_native_handle_",
    "MHD_thread_handle_ID_ (type)",
    "MHD_thread_handle_native_ (type)",
    "mhd_assert"
  ],
  "explanation": "- MHD_thread_handle_ID_get_native_handle_ptr_: This macro/function is used to obtain a pthread_t* when the code is compiled with that variant. Its definition is required to determine whether it modifies the parameter handle_id itself (e.g. by reassigning it) or merely returns a pointer into the object pointed to by handle_id. That distinction is critical for the MISRA rule (pointer parameter must not be modified).  \n- MHD_thread_handle_ID_is_valid_handle_: The code calls this to check the handle; the implementation could be a macro that accesses or modifies the parameter. We need its definition to be sure it does not assign to the handle_id parameter variable.  \n- MHD_thread_handle_ID_set_invalid_: This is called with handle_id and is expected to modify the object pointed to by handle_id. We need its definition to confirm it only modifies *handle_id (allowed) and does not reassign the handle_id parameter itself (disallowed).  \n- MHD_thread_handle_ID_set_native_handle_: Likewise, this is called with handle_id and a native handle; its definition must be inspected to ensure it updates the pointee and does not modify the pointer parameter variable.  \n- MHD_thread_handle_ID_ (type): The typedef/struct definition of the handle type is needed to know whether handle_id is a pointer-to-struct, pointer-to-pointer, or some other type \u2014 this affects whether operations on it could be reassignments of the parameter vs allowed modifications of the pointee.  \n- MHD_thread_handle_native_ (type): Needed to understand what set/get operations do and whether conversions or assignments could imply modification of the handle_id parameter.  \n- mhd_assert: This macro/function is used early in the function; its expansion could include side effects (including assignments) in some build configurations. We must inspect it to verify it doesn't modify the handle_id parameter.  \n\nProviding these symbols (their definitions/expansions and related type declarations) allows a precise determination whether any code path assigns to the handle_id parameter itself (a MISRA violation) versus only mutating the object it points to (allowed)."
}