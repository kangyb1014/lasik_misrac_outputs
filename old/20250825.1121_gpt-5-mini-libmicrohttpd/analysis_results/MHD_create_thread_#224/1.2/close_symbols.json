{
  "user_message": "Target function code is:\n```c\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_thread_': {'callees': [], 'callers': ['MHD_create_named_thread_']}, 'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_thread_handle_ID_get_native_handle_ptr_",
    "MHD_thread_handle_ID_is_valid_handle_",
    "MHD_thread_handle_ID_set_invalid_",
    "MHD_thread_handle_ID_set_native_handle_",
    "MHD_thread_handle_ID_",
    "MHD_thread_handle_native_",
    "MHD_THREAD_START_ROUTINE_",
    "mhd_assert",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "SIZEOF_SIZE_T",
    "SIZEOF_UNSIGNED_INT",
    "pthread_t",
    "pthread_attr_t",
    "pthread_attr_init",
    "pthread_attr_setstacksize",
    "pthread_attr_destroy",
    "pthread_create",
    "errno",
    "uintptr_t",
    "_beginthreadex",
    "UINT_MAX",
    "EINVAL"
  ],
  "explanation": "For the MISRA check for language extensions, the next analyst must examine the definitions (macros, typedefs and declarations) of any symbol that the target uses and whose implementation/definition could hide compiler-specific or non\u2011standard constructs. Each listed symbol is required because:\n\n- MHD_thread_handle_ID_get_native_handle_ptr_, MHD_thread_handle_ID_is_valid_handle_, MHD_thread_handle_ID_set_invalid_, MHD_thread_handle_ID_set_native_handle_: these are macros or inline helpers manipulating the thread-handle abstraction; their definitions may use compiler extensions (statement expressions, typeof, attributes, token-pasting, inline asm, non\u2011standard calling conventions, etc.). Inspecting them is necessary to detect any such extensions.\n\n- MHD_thread_handle_ID_, MHD_thread_handle_native_: the underlying typedefs/structs for the handle may be defined using compiler-specific keywords or attributes (packed, aligned, extension typedefs). Their definitions must be checked.\n\n- MHD_THREAD_START_ROUTINE_: the function-pointer type used for thread entry; its typedef or macro could use non-standard calling-convention attributes (stdcall,fastcall) or other extensions.\n\n- mhd_assert: typically a macro; may expand to compiler-specific constructs (like __builtin_expect, __extension__, inline assembly, or statement-expression GNU extensions). Verify its definition.\n\n- MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS: configuration macros that select platform-specific code paths. Their values/definitions determine which platform headers/implementations to inspect for extensions.\n\n- SIZEOF_SIZE_T, SIZEOF_UNSIGNED_INT: compile-time size macros; could be produced by build-system macros or use sizeof in macro expressions or compiler-specific constant expressions. Check for extension usage in how they are defined.\n\n- pthread_t, pthread_attr_t, pthread_attr_init, pthread_attr_setstacksize, pthread_attr_destroy, pthread_create: pthread API types and functions come from system headers. Their declarations could use vendor/extension attributes (e.g., visibility, calling conventions, __attribute__ annotations). If MHD maps or wraps these names, those wrappers might use extensions.\n\n- errno: often a macro that may expand to a function call or thread-local accessor (e.g., __errno_location(), __thread, or other extensions). Its definition must be inspected.\n\n- uintptr_t: standard in C99, but the typedef may be provided by the implementation and could use compiler-specific typedefs or attributes \u2014 inspect its definition to be safe.\n\n- _beginthreadex: Microsoft CRT function (non\u2011standard). Its declaration may include non\u2011standard calling conventions or attributes; its presence is itself a platform-specific extension and must be examined.\n\n- UINT_MAX, EINVAL: standard macros from limits/errno headers. Although standard, their header definitions or related macros might rely on implementation-specific constructs; verify only if needed (less likely to be extension-prone, but included for completeness).\n\nIn short: to decide whether the target function uses any compiler-documented language extensions you must inspect the definitions/declarations of the above macros, typedefs and functions because macros and platform-specific APIs are the usual places where such extensions are introduced."
}