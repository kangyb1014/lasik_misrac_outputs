{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\ndir_reader (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  DIR *dir = cls;\n  struct dirent *e;\n  int res;\n\n  if (max < 512)\n    return 0;\n  (void) pos; /* 'pos' is ignored as function return next one single entry per call. */\n  do\n  {\n    e = readdir (dir);\n    if (e == NULL)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n  } while (e->d_name[0] == '.');\n  res = snprintf (buf, max,\n                  \"<a href=\\\"/%s\\\">%s</a><br>\",\n                  e->d_name,\n                  e->d_name);\n  if (0 >= res)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  if (max < (size_t) res)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return (ssize_t) res;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ssize_t",
    "uint64_t",
    "size_t",
    "DIR",
    "struct dirent",
    "d_name",
    "readdir",
    "snprintf",
    "NULL",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "MHD_CONTENT_READER_END_WITH_ERROR"
  ],
  "explanation": "For determining whether the target function uses any compiler language extensions, the next analyser needs the definitions/declarations of all non\u2011built-in identifiers used by the function so it can tell whether they come from standard C, standard libraries, POSIX, or from vendor/third\u2011party headers that might use compiler extensions. Explanation for each symbol:\n\n- ssize_t: the function return type. ssize_t is not part of ISO C89; it is POSIX (or platform specific). The analyser must inspect its typedef/definition to see if it is a compiler/platform type or provided by a header that uses extensions.\n\n- uint64_t: fixed-width integer type. Provided by <stdint.h> in C99 but some toolchains provide it as an extension; check its definition to confirm it's a standard typedef and not a compiler extension.\n\n- size_t: standard C type for object sizes. Confirmed in <stddef.h>/<stdio.h>, but the analyser should verify the actual declaration in the target build environment to rule out extension usage.\n\n- DIR: opaque directory stream type (from <dirent.h> on POSIX). This is a platform/POSIX type; the analyser must check its definition to see if any compiler-specific extension is involved.\n\n- struct dirent: directory entry structure. The analyser needs its definition (especially d_name member type) to ensure use of e->d_name[0] and string formatting is standard and that the struct is not declared with compiler\u2011specific attributes/extensions.\n\n- d_name: member of struct dirent used in the code. Knowing its declared type (char array vs pointer, qualifiers) is required to check for nonstandard declarations or extensions.\n\n- readdir: POSIX function returning struct dirent*. readdir is not ISO C; its declaration and any attributes/macros around it must be checked to ensure no compiler extensions are used in its prototype.\n\n- snprintf: formatting function from C99 (<stdio.h>). Some older/libc implementations or compilers provide it as an extension or macro; the analyser should inspect its declaration/implementation for extension usage or nonstandard behavior.\n\n- NULL: the null pointer macro. Its definition may be standard or compiler specific; verify it is the standard macro and not a compiler extension.\n\n- MHD_CONTENT_READER_END_OF_STREAM and MHD_CONTENT_READER_END_WITH_ERROR: library macros/values (likely from libmicrohttpd). These are not standard C; the analyser must inspect their definitions to see if they rely on compiler extensions (e.g. nonstandard attributes, unusual types, GCC extensions) or otherwise change function semantics.\n\nCollecting the above symbols (their declarations/definitions and the headers that provide them) lets the next agent decide whether any of them or the way they are used constitute a compiler language extension as defined by the compiler documentation."
}