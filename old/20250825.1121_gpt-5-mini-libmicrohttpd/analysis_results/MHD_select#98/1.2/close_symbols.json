{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_Result",
    "struct MHD_Daemon",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_NO",
    "MHD_YES",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "resume_suspended_connections",
    "internal_get_fdset2",
    "FD_ZERO",
    "fd_set",
    "FD_SETSIZE",
    "MHD_add_to_fd_set_",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_DLOG",
    "MHD_get_timeout64",
    "SIZEOF_UINT64_T",
    "SIZEOF_STRUCT_TIMEVAL_TV_SEC",
    "TIMEVAL_TV_SEC_MAX",
    "_MHD_TIMEVAL_TV_SEC_TYPE",
    "MHD_SYS_select_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "internal_run_from_select"
  ],
  "explanation": "To determine whether MHD_select uses any compiler/language extensions (per the MISRA rule), the analyser must see the definitions/expansions and types of all macros, typedefs, constants and wrapper functions used in the function body \u2014 any of those might hide compiler-specific extensions (e.g. __extension__, __attribute__, __builtin_*, GCC/Clang pragmas, statement-expressions, GCC nested functions, non-standard variadic macro behaviour, or other documented extensions). Brief reasons for each symbol:\n\n- enum MHD_Result: needed to inspect its definition (enum syntax, any compiler-specific qualifiers or extension usage in enum declaration).\n- struct MHD_Daemon: required because fields accessed (shutdown, options, itc, listen_fd, was_quiesced, connections, connection_limit, at_limit) might be defined with non-standard extensions (bitfields, packed, attribute, anonymous structs/unions).\n- MHD_socket: the socket type may be a typedef to an implementation-specific type (could use compiler extensions).\n- MHD_INVALID_SOCKET: constant/macro that may be defined via extension or as an expression using compiler-specific constructs.\n- MHD_NO / MHD_YES: enum or macro values \u2014 need their definitions to detect extension usage.\n- MHD_TEST_ALLOW_SUSPEND_RESUME: options bitmask macro \u2014 expansion may use extensions.\n- MHD_D_IS_USING_THREAD_PER_CONN_: macro \u2014 its expansion could use compiler extensions (e.g. statement-expression, typeof, inline functions, GCC extensions).\n- resume_suspended_connections: function prototype/definition is required because the call-site behavior or prototype could use attributes or builtins (e.g. __attribute__((noreturn))) or inline/extension constructs; the callee may also expose uses of compiler builtins that affect how the call must be considered.\n- internal_get_fdset2: prototype/definition to check if it's a macro or inline wrapper that employs extensions.\n- FD_ZERO: macro from system headers; its definition must be checked (some platforms implement fd macros with extensions or use statement-exprs).\n- fd_set: type definition (structure) must be checked for any nonstandard fields or compiler attributes.\n- FD_SETSIZE: constant \u2014 may be defined by system headers in a way that uses extensions.\n- MHD_add_to_fd_set_: function or macro \u2014 inspect its definition for extensions (inline, __builtin_* usage, etc.).\n- MHD_ITC_IS_VALID_: macro \u2014 expansion could be nonstandard.\n- MHD_itc_r_fd_: accessor macro/function \u2014 its implementation may use extensions.\n- MHD_DLOG: logging macro is commonly implemented with variadic macros, __FILE__/__LINE__/__func__ usage or with compiler-specific wrappers; its definition must be inspected for language extensions (variadic macros are C99 but some implementations use GCC extensions, or they may use attributes like format).\n- MHD_get_timeout64: prototype/definition \u2014 may use nonstandard integer types, attributes or builtins.\n- SIZEOF_UINT64_T / SIZEOF_STRUCT_TIMEVAL_TV_SEC: compile-time constants used in #if/conditional compilation; their definitions or how they are set (via sizeof introspection macros or compiler-specific defines) may use extensions such as sizeof on types in preprocessor expressions using nonstandard features.\n- TIMEVAL_TV_SEC_MAX: constant that could be derived by macros or expressions that use extensions.\n- _MHD_TIMEVAL_TV_SEC_TYPE: typedef used to cast timeout.tv_sec \u2014 must inspect to see if it uses implementation-specific types or extension keywords.\n- MHD_SYS_select_: wrapper around select() \u2014 could be a macro that maps to pselect/select with attributes, or a macro using statement-expr or builtins. Need definition to check for extensions.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: socket error helpers may be macros or inline functions using builtins or attributes; their definitions must be inspected.\n- internal_run_from_select: prototype/definition may be macro/inline using extensions; also it controls post-select flow so its signature/definition must be known.\n\nIn short: any macro, typedef, constant or wrapper function used directly in MHD_select can hide language extensions; the listed symbols are the direct ones referenced in the function and must be inspected to decide compliance. The static callees already listed (resume_suspended_connections, internal_get_fdset2, MHD_DLOG, MHD_add_to_fd_set_, MHD_get_timeout64, internal_run_from_select) are included above because their implementations or macros may contain language extensions that would cause MHD_select to effectively use them."
}