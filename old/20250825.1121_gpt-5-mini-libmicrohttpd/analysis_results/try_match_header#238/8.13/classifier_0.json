{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of try_match_header:\n```c\nstatic int\ntry_match_header (const char *prefix,\n                  size_t prefix_len,\n                  char *line,\n                  char **suffix)\n{\n  if (NULL != *suffix)\n    return MHD_NO;\n  while (0 != *line)\n  {\n    if (MHD_str_equal_caseless_n_ (prefix,\n                                   line,\n                                   prefix_len))\n    {\n      *suffix = strdup (&line[prefix_len]);\n      return MHD_YES;\n    }\n    ++line;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (NULL != *suffix)\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The parameter is char **suffix and the function assigns to *suffix (\"*suffix = strdup(...)\") so the pointed-to type must be modifiable; declaring it const would be incorrect. A violation would occur if a pointer-to-char were only read and never modified but declared as char * instead of const char * (for example, declaring char *p that is only dereferenced for reading rather than const char *p), or if the code tried to assign to *suffix while suffix were declared to point to a const-qualified char (e.g. const char **suffix and then doing *suffix = strdup(...))."
}