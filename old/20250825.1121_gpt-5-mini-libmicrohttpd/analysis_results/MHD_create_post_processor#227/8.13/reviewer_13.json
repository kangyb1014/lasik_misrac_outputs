{
  "user_message": "An agent A claimed that the following MHD_create_post_processor code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_post_processor.\n```c\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe member 'addr' appears to hold the foreign address which is allocated and thereafter only inspected (e.g. returned/read via connection-info functions) and is not intended to be modified through the MHD_Connection interface. In that case the pointer should be declared as pointing to a const-qualified type (const struct sockaddr_storage *addr). Because it is declared as struct sockaddr_storage *addr (non-const) the code violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_post_processor:\nstruct MHD_PostProcessor\n{\n\n  /**\n   * The connection for which we are doing\n   * POST processing.\n   */\n  struct MHD_Connection *connection;\n\n  /**\n   * Function to call with POST data.\n   */\n  MHD_PostDataIterator ikvi;\n\n  /**\n   * Extra argument to ikvi.\n   */\n  void *cls;\n\n  /**\n   * Encoding as given by the headers of the connection.\n   */\n  const char *encoding;\n\n  /**\n   * Primary boundary (points into encoding string)\n   */\n  const char *boundary;\n\n  /**\n   * Nested boundary (if we have multipart/mixed encoding).\n   */\n  char *nested_boundary;\n\n  /**\n   * Pointer to the name given in disposition.\n   */\n  char *content_name;\n\n  /**\n   * Pointer to the (current) content type.\n   */\n  char *content_type;\n\n  /**\n   * Pointer to the (current) filename.\n   */\n  char *content_filename;\n\n  /**\n   * Pointer to the (current) encoding.\n   */\n  char *content_transfer_encoding;\n\n  /**\n   * Value data left over from previous iteration.\n   */\n  char xbuf[2];\n\n  /**\n   * Size of our buffer for the key.\n   */\n  size_t buffer_size;\n\n  /**\n   * Current position in the key buffer.\n   */\n  size_t buffer_pos;\n\n  /**\n   * Current position in @e xbuf.\n   */\n  size_t xbuf_pos;\n\n  /**\n   * Current offset in the value being processed.\n   */\n  uint64_t value_offset;\n\n  /**\n   * strlen(boundary) -- if boundary != NULL.\n   */\n  size_t blen;\n\n  /**\n   * strlen(nested_boundary) -- if nested_boundary != NULL.\n   */\n  size_t nlen;\n\n  /**\n   * Do we have to call the 'ikvi' callback when processing the\n   * multipart post body even if the size of the payload is zero?\n   * Set to #MHD_YES whenever we parse a new multiparty entry header,\n   * and to #MHD_NO the first time we call the 'ikvi' callback.\n   * Used to ensure that we do always call 'ikvi' even if the\n   * payload is empty (but not more than once).\n   */\n  bool must_ikvi;\n\n  /**\n   * Set if we still need to run the unescape logic\n   * on the key allocated at the end of this struct.\n   */\n  bool must_unescape_key;\n\n  /**\n   * State of the parser.\n   */\n  enum PP_State state;\n\n  /**\n   * Side-state-machine: skip CRLF (or just LF).\n   * Set to 0 if we are not in skip mode.  Set to 2\n   * if a CRLF is expected, set to 1 if a CR should\n   * be skipped if it is the next character.\n   */\n  enum RN_State skip_rn;\n\n  /**\n   * If we are in skip_rn with \"dash\" mode and\n   * do find 2 dashes, what state do we go into?\n   */\n  enum PP_State dash_state;\n\n  /**\n   * Which headers are global? (used to tell which\n   * headers were only valid for the nested multipart).\n   */\n  enum NE_State have;\n\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n...\nint\nMHD_str_equal_caseless_n_ (const char *const str1,\n                           const char *const str2,\n                           size_t maxlen)\n{\n  size_t i;\n\n  for (i = 0; i < maxlen; ++i)\n  {\n    const char c1 = str1[i];\n    const char c2 = str2[i];\n    if (0 == c2)\n      return 0 == c1;\n    if (charsequalcaseless (c1, c2))\n      continue;\n    else\n      return 0;\n  }\n  return ! 0;\n}\n...\ntypedef enum MHD_Result\n(*MHD_PostDataIterator)(void *cls,\n                        enum MHD_ValueKind kind,\n                        const char *key,\n                        const char *filename,\n                        const char *content_type,\n                        const char *transfer_encoding,\n                        const char *data,\n                        uint64_t off,\n                        size_t size)\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\n#define MHD_calloc_(n, s) calloc((n),(s))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. The reported violation is not supported by the provided code. Rule 8.13 recommends const-qualification when a pointer does not need to be used to modify the pointed-to object, but making a struct member const must be done only when it cannot be modified anywhere else. The MHD_Connection::addr member is documented as \u201cForeign address \u2026 MALLOCED (not in pool!)\u201d which implies ownership and dynamic allocation and strongly suggests that code elsewhere will allocate, assign, update or free that pointer (and possibly modify the pointed-to sockaddr_storage). MHD_create_post_processor itself does not touch connection->addr, so no local constness issue arises in that function; the rule applies to the declaration/usage site, not to this function alone. Without evidence that the address pointer and the pointed-to storage are never modified anywhere in the codebase, we cannot claim a MISRA 8.13 violation. In short: there is insufficient justification to change the field to const, and therefore Agent A\u2019s claim of a rule 8.13 violation is not correct."
}