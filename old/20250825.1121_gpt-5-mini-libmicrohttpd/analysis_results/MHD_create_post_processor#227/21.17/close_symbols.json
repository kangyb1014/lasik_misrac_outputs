{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_post_processor': {'callees': ['__builtin_unreachable', 'MHD_lookup_connection_value_n', 'MHD_str_equal_caseless_n_'], 'callers': ['create_response', 'generate_page', 'answer_to_connection']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_lookup_connection_value_n': {'callees': [], 'callers': ['MHD_lookup_connection_value', 'need_100_continue', 'get_no_space_err_status_code', 'parse_cookie_header', 'parse_connection_headers', 'MHD_create_post_processor', 'ahc_cb']}, 'MHD_str_equal_caseless_n_': {'callees': ['charsequalcaseless'], 'callers': ['MHD_create_post_processor', 'try_match_header', 'process_multipart_headers', 'post_process_multipart', 'MHD_post_process']}, 'create_response': {'callees': ['MHD_create_post_processor', 'get_session', 'MHD_post_process', 'MHD_destroy_post_processor', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': []}, 'generate_page': {'callees': ['MHD_queue_response', 'MHD_create_response_from_fd', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_post_processor', 'MHD_post_process', 'MHD_destroy_post_processor', 'update_directory', 'return_directory_response'], 'callers': []}, 'answer_to_connection': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_queue_response', 'MHD_destroy_response', 'MHD_get_connection_values', 'MHD_create_response_from_fd_at_offset64', 'MHD_basic_auth_get_username_password3', 'MHD_queue_basic_auth_required_response3', 'MHD_free', 'MHD_create_post_processor', 'send_page', 'MHD_post_process'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_lookup_connection_value_n",
    "MHD_NO",
    "MHD_HEADER_KIND",
    "MHD_HTTP_HEADER_CONTENT_TYPE",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_n_",
    "MHD_HTTP_POST_ENCODING_FORM_URLENCODED",
    "MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA",
    "strstr",
    "strlen",
    "MHD_calloc_",
    "struct MHD_Connection (definition / header storage and lifetime)"
  ],
  "explanation": "To determine whether the calls to string functions in MHD_create_post_processor (notably strstr and strlen) can read past object bounds you need the following symbols and why:\n\n- MHD_lookup_connection_value_n\n  - This is the function that provides the encoding pointer used later. You must inspect its contract/implementation to know whether it returns a NUL-terminated string, the buffer length, and the lifetime/ownership of that pointer (so strlen/strstr operate on a valid, bounded C string).\n\n- MHD_NO\n  - The return-code constant used when lookup fails; needed to understand the control flow that leads to using encoding (ensures encoding is set only on success).\n\n- MHD_HEADER_KIND and MHD_HTTP_HEADER_CONTENT_TYPE\n  - The lookup is filtered by these values. You need the exact header key used by the lookup to correlate how header values are stored and whether the value returned is the full content-type string (including possible appended data) and how it is terminated.\n\n- MHD_STATICSTR_LEN_\n  - Macro used to pass literal lengths for comparisons. Knowing its expansion ensures the comparisons involving MHD_str_equal_caseless_n_ use the intended lengths and do not cause overreads.\n\n- MHD_str_equal_caseless_n_\n  - This function is used to detect the specific encodings before treating the remainder of encoding as the boundary. You must check its implementation/contract to ensure it does not read beyond the supplied length or the encoding buffer (and that it safely handles non-NUL-terminated inputs if relevant).\n\n- MHD_HTTP_POST_ENCODING_FORM_URLENCODED and MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA\n  - The exact literal contents matter because boundary is derived as the suffix after the multipart literal. You must confirm where the boundary pointer is set and that the code correctly finds the start of the boundary within the returned encoding buffer.\n\n- strstr\n  - The standard library function used to find \"boundary=\" inside the suffix. strstr requires both inputs be NUL-terminated strings; you must verify the pointer passed as the haystack (the suffix of encoding) is NUL-terminated and entirely within the bounds of the object returned by lookup.\n\n- strlen\n  - Used to compute blen from the boundary pointer. strlen reads until a NUL; you must ensure that the boundary pointer definitely points to a NUL-terminated region inside the original buffer and that that region does not run past the allocated/valid memory for the header value.\n\n- MHD_calloc_\n  - Allocation used for the returned struct and its internal buffer_size accounting. The code adjusts buffer_size and adds +1 for zero-termination; you need to verify the size computation to ensure later string operations (if any) will not overflow that allocated buffer. Even if not directly used by strstr/strlen here, it affects whether the function's computed blen vs buffer_size checks are sufficient.\n\n- struct MHD_Connection (definition / header storage and lifetime)\n  - To judge safety you must know how header values are stored inside the connection (e.g., are they stored as contiguous NUL-terminated strings, pooled buffers, ephemeral buffers freed after lookup?). This determines whether encoding/boundary pointers remain valid and whether the memory region has a NUL within its bounds so that strstr/strlen will not read past the valid object.\n\nThese symbols provide the necessary contracts/implementations and literal values to decide whether the calls to strstr and strlen in this function can legally and safely access only memory within the bounds of the objects they reference (per the MISRA rule)."
}