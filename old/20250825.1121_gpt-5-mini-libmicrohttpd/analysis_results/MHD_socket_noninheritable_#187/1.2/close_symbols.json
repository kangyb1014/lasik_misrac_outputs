{
  "user_message": "Target function code is:\n```c\nint\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE) sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'MHD_add_connection': {'callees': ['MHD_cleanup_connections', 'MHD_DLOG', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection', '__builtin_unreachable'], 'callers': []}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "MHD_socket",
    "fcntl",
    "F_GETFD",
    "F_SETFD",
    "FD_CLOEXEC",
    "SetHandleInformation",
    "HANDLE",
    "HANDLE_FLAG_INHERIT",
    "WINAPI",
    "__stdcall"
  ],
  "explanation": "- MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS: These preprocessor macros determine which branch of the #if is compiled. To decide whether any platform-specific language extension is used you must know which branch is active.\n- MHD_socket: The typedef/underlying type of MHD_socket is required to determine whether the cast (HANDLE) sock (in the Win32 branch) is a pointer/integer reinterpretation or a normal conversion and whether that conversion relies on non\u2011standard behavior.\n- fcntl, F_GETFD, F_SETFD, FD_CLOEXEC: Declarations/macros for the POSIX API and flags are needed to confirm these are standard POSIX symbols (not compiler extensions) and that no extension attributes are involved.\n- SetHandleInformation, HANDLE, HANDLE_FLAG_INHERIT: The Win32 API declarations and related type/macros are required to see whether calling this API or using HANDLE/HANDLE_FLAG_INHERIT involves compiler-specific extensions (e.g. non\u2011standard typedefs or calling conventions).\n- WINAPI and __stdcall: The Windows API calling convention macro (WINAPI) typically expands to a compiler\u2011specific calling convention such as __stdcall. To determine a violation of the MISRA prohibition on language extensions you must inspect these macros/expansions (or equivalent compiler headers) to see if a language extension is introduced.\n\nCollecting these symbols (their typedefs/macros/prototypes from the relevant headers or build configuration) lets the next analyst determine exactly which branch is compiled and whether any compiler\u2011specific language extensions (calling conventions, attributes, or nonstandard casts) are being used."
}