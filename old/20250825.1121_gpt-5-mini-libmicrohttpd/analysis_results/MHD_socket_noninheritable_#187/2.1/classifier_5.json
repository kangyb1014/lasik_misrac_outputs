{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_socket_noninheritable_:\n```c\nint\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE) sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_socket_noninheritable_:\n#define MHD_POSIX_SOCKETS 1\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n...\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n...\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n...\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n                     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd = MHD_INVALID_SOCKET;\n  const struct sockaddr *pservaddr = NULL;\n  socklen_t addrlen;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n  struct MHD_InterimParams_ *interim_params;\n\n  MHD_check_global_init_ ();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n\n  if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n    *pflags |= MHD_USE_INTERNAL_POLLING_THREAD; /* Force enable, log warning later if needed */\n\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n  {\n#ifdef UPGRADE_SUPPORT\n    *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n    return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n#ifdef MHD_USE_THREADS\n  if ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD) ==\n      ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD)\n       & *pflags))\n    return NULL; /* Cannot be thread-unsafe with multiple threads */\n#else  /* ! MHD_USE_THREADS */\n  if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    return NULL;\n#endif /* ! MHD_USE_THREADS */\n\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_EPOLL)) &&\n      (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_POLL)) &&\n      (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD\n                        | MHD_USE_THREAD_PER_CONNECTION))))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_AUTO)) &&\n      (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))))\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n  {\n#if defined(EPOLL_SUPPORT) && defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_POLL;\n    else\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#elif defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n      *pflags |= MHD_USE_POLL; /* Including thread-per-connection */\n#elif defined(EPOLL_SUPPORT)\n    if (0 == (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#else\n    /* No choice: use select() for any mode - do not modify flags */\n#endif\n  }\n\n  if (0 != (*pflags & MHD_USE_NO_THREAD_SAFETY))\n    *pflags = (*pflags & ~((enum MHD_FLAG) MHD_USE_ITC)); /* useless in single-threaded environment */\n  else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n  {\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n    *pflags |= MHD_USE_ITC;       /* yes, must use ITC to signal thread */\n  }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n  interim_params = (struct MHD_InterimParams_ *) \\\n                   MHD_calloc_ (1, sizeof (struct MHD_InterimParams_));\n  if (NULL == interim_params)\n  {\n    int err_num = errno;\n    free (daemon);\n    errno = err_num;\n    return NULL;\n  }\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listen_is_unix = _MHD_NO;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->client_discipline = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ?\n                              1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout_ms = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&daemon->tid);\n#endif /* MHD_USE_THREADS */\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = &MHD_default_logger_;\n  daemon->custom_error_log_cls = stderr;\n#endif\n#ifndef MHD_WINSOCK_SOCKETS\n  daemon->sigpipe_blocked = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  /* There is no SIGPIPE on W32, nothing to block. */\n  daemon->sigpipe_blocked = true;\n#endif /* _WIN32 && ! __CYGWIN__ */\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  daemon->avoid_accept4 = false;\n#endif /* _DEBUG */\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  daemon->fdset_size = (int) FD_SETSIZE;\n  daemon->fdset_size_set_by_app = false;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n  daemon->dauth_def_nonce_timeout = MHD_DAUTH_DEF_TIMEOUT_;\n  daemon->dauth_def_max_nc = MHD_DAUTH_DEF_MAX_NC_;\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n  }\n#endif /* HTTPS_SUPPORT */\n\n  interim_params->num_opts = 0;\n  interim_params->fdset_size_set = false;\n  interim_params->fdset_size = 0;\n  interim_params->listen_fd_set = false;\n  interim_params->listen_fd = MHD_INVALID_SOCKET;\n  interim_params->pserver_addr_set = false;\n  interim_params->pserver_addr = NULL;\n  interim_params->server_addr_len_set = false;\n  interim_params->server_addr_len = 0;\n\n  if (MHD_NO == parse_options_va (daemon,\n                                  interim_params,\n                                  ap))\n  {\n#ifdef HTTPS_SUPPORT\n    if ( (0 != (*pflags & MHD_USE_TLS)) &&\n         (NULL != daemon->priority_cache) )\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  if (! process_interim_params (daemon,\n                                &pservaddr,\n                                &addrlen,\n                                interim_params))\n  {\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  free (interim_params);\n  interim_params = NULL;\n#ifdef HTTPS_SUPPORT\n  if ((0 != (*pflags & MHD_USE_TLS))\n      && (NULL == daemon->priority_cache)\n      && ! daemon_tls_priorities_init_default (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialise GnuTLS priorities.\\n\"));\n#endif /* HAVE_MESSAGES */\n    free (daemon);\n    return NULL;\n  }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (flags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used \" \\\n                 \"only with MHD_USE_INTERNAL_POLLING_THREAD. \" \\\n                 \"Flag MHD_USE_INTERNAL_POLLING_THREAD was added. \" \\\n                 \"Consider setting MHD_USE_INTERNAL_POLLING_THREAD \" \\\n                 \"explicitly.\\n\"));\n  }\n#endif\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)\n      && ((NULL != daemon->notify_completed)\n          || (NULL != daemon->notify_connection)) )\n    *pflags |= MHD_USE_ITC; /* requires ITC */\n\n#ifdef _DEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            _ (\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* _DEBUG */\n\n  if ( (0 != (*pflags & MHD_USE_ITC))\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n       && (0 == daemon->worker_pool_size)\n#endif\n       )\n  {\n    if (! MHD_itc_init_ (daemon->itc))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create inter-thread communication channel: %s\\n\"),\n                MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (daemon->itc), daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"file descriptor for inter-thread communication \" \\\n                   \"channel exceeds maximum value.\\n\"));\n#endif\n      MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#ifdef DAUTH_SUPPORT\n  if (NULL != daemon->digest_auth_random_copy)\n  {\n    mhd_assert (daemon == daemon->digest_auth_random_copy);\n    daemon->digest_auth_random_copy = malloc (daemon->digest_auth_rand_size);\n    if (NULL == daemon->digest_auth_random_copy)\n    {\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    memcpy (daemon->digest_auth_random_copy,\n            daemon->digest_auth_random,\n            daemon->digest_auth_rand_size);\n    daemon->digest_auth_random = daemon->digest_auth_random_copy;\n  }\n  if (daemon->nonce_nc_size > 0)\n  {\n    if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc)))\n         / sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Specified value for NC_SIZE too large.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n    daemon->nnc = MHD_calloc_ (daemon->nonce_nc_size,\n                               sizeof (struct MHD_NonceNc));\n    if (NULL == daemon->nnc)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize nonce-nc mutex.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n    if (0 != (*pflags & MHD_USE_TLS))\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n    free (daemon);\n    return NULL;\n  }\n#endif\n#endif\n\n  /* Thread polling currently works only with internal select thread mode */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! MHD_D_IS_USING_THREADS_ (daemon)) &&\n       (daemon->worker_pool_size > 0) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD thread polling only works with \" \\\n                 \"MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif\n    goto free_and_fail;\n  }\n#endif\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n  {\n    /* try to open listen socket */\n    struct sockaddr_in servaddr4;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 servaddr6;\n    const bool use_ipv6 = (0 != (*pflags & MHD_USE_IPv6));\n#else  /* ! HAVE_INET6 */\n    const bool use_ipv6 = false;\n#endif /* ! HAVE_INET6 */\n    int domain;\n\n    if (NULL != pservaddr)\n    {\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      const socklen_t sa_len = pservaddr->sa_len;\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#ifdef HAVE_INET6\n      if (use_ipv6 && (AF_INET6 != pservaddr->sa_family))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_USE_IPv6 is enabled, but 'struct sockaddr *' \" \\\n                     \"specified for MHD_OPTION_SOCK_ADDR_LEN or \" \\\n                     \"MHD_OPTION_SOCK_ADDR is not IPv6 address.\\n\"));\n#endif /* HAVE_MESSAGES */\n        goto free_and_fail;\n      }\n#endif /* HAVE_INET6 */\n      switch (pservaddr->sa_family)\n      {\n      case AF_INET:\n        if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;\n#ifdef HAVE_INET6\n      case AF_INET6:\n        if (1)\n        {\n          struct sockaddr_in6 sa6;\n          uint16_t sa6_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa6)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa6)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa6);\n          memcpy (&sa6, pservaddr, sizeof(sa6));  /* Required due to stronger alignment */\n          sa6_port = (uint16_t) ntohs (sa6.sin6_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa6_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa6_port;\n          domain = PF_INET6;\n          *pflags |= ((enum MHD_FLAG) MHD_USE_IPv6);\n        }\n        break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n#endif /* AF_UNIX */\n      default:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n        if (0 == addrlen)\n          addrlen = sa_len;\n        else if ((0 != sa_len) && (sa_len < addrlen))\n          addrlen = sa_len; /* Use smaller value for safety */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n        if (0 >= addrlen)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"The 'sa_family' of the 'struct sockaddr' provided \" \\\n                       \"via MHD_OPTION_SOCK_ADDR option is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n          goto free_and_fail;\n        }\n#ifdef AF_UNIX\n        if (AF_UNIX == pservaddr->sa_family)\n        {\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n#ifdef PF_UNIX\n          domain = PF_UNIX;\n#else /* ! PF_UNIX */\n          domain = AF_UNIX;\n#endif /* ! PF_UNIX */\n        }\n        else /* combined with the next 'if' */\n#endif /* AF_UNIX */\n        if (1)\n        {\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          /* Assumed the same values for AF_* and PF_* */\n          domain = pservaddr->sa_family;\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (! use_ipv6)\n      {\n        memset (&servaddr4,\n                0,\n                sizeof (struct sockaddr_in));\n        servaddr4.sin_family = AF_INET;\n        servaddr4.sin_port = htons (port);\n        if (0 != INADDR_ANY)\n          servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n        servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr4;\n        addrlen = (socklen_t) sizeof(servaddr4);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET;\n      }\n#ifdef HAVE_INET6\n      else\n      {\n#ifdef IN6ADDR_ANY_INIT\n        static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n        memset (&servaddr6,\n                0,\n                sizeof (struct sockaddr_in6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n        servaddr6.sin6_addr = static_in6any;\n#endif\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n        servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr6;\n        addrlen = (socklen_t) sizeof (servaddr6);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET6;\n      }\n#endif /* HAVE_INET6 */\n    }\n\n    listen_fd = MHD_socket_create_listen_ (domain);\n    if (MHD_INVALID_SOCKET == listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create socket for listening: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n\n    /* Apply the socket options according to listening_address_reuse. */\n    if (0 == daemon->listening_address_reuse)\n    {\n#ifndef MHD_WINSOCK_SOCKETS\n      /* No user requirement, use \"traditional\" default SO_REUSEADDR\n       * on non-W32 platforms, and do not fail if it doesn't work.\n       * Don't use it on W32, because on W32 it will allow multiple\n       * bind to the same address:port, like SO_REUSEPORT on others. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n    }\n    else if (daemon->listening_address_reuse > 0)\n    {\n      /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n      /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n       * it doesn't work. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n      /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n       * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n       */\n      /* SO_REUSEADDR on W32 has the same semantics\n         as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                          SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                          SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n      /* we're supposed to allow address:port re-use, but\n         on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot allow listening address reuse: \" \\\n                   \"SO_REUSEPORT not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n    }\n    else   /* if (daemon->listening_address_reuse < 0) */\n    {\n      /* User requested to disallow reusing listening address:port.\n       * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n       * is used and Solaris with SO_EXCLBIND.\n       * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n       * or setsockopt fails.\n       */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n      (defined(__sun) && defined(SO_EXCLBIND))\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                          SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                          SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot disallow listening address reuse: \" \\\n                   \"SO_EXCLUSIVEADDRUSE not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n\n    /* check for user supplied sockaddr */\n    daemon->listen_fd = listen_fd;\n\n    if (0 != (*pflags & MHD_USE_IPv6))\n    {\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n      /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n         (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n         and may also be missing on older POSIX systems; good luck if you have any of those,\n         your IPv6 socket may then also bind against IPv4 anyway... */\n      const MHD_SCKT_OPT_BOOL_ v6_only =\n        (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n      if (0 > setsockopt (listen_fd,\n                          IPPROTO_IPV6, IPV6_V6ONLY,\n                          (const void *) &v6_only,\n                          sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n    }\n    if (0 != bind (listen_fd, pservaddr, addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to bind to port %u: %s\\n\"),\n                (unsigned int) port,\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n#ifdef TCP_FASTOPEN\n    if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    {\n      if (0 == daemon->fastopen_queue_size)\n        daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n      if (0 != setsockopt (listen_fd,\n                           IPPROTO_TCP,\n                           TCP_FASTOPEN,\n                           (const void *) &daemon->fastopen_queue_size,\n                           sizeof (daemon->fastopen_queue_size)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n    }\n#endif\n    if (0 != listen (listen_fd,\n                     (int) daemon->listen_backlog_size))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to listen for connections: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n  }\n  else\n  {\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) daemon->listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      goto free_and_fail;\n    }\n    else\n    {\n#if defined(SOL_SOCKET) && (defined(SO_DOMAIN) || defined(SO_PROTOCOL_INFOW))\n      int af;\n      int opt_name;\n      void *poptval;\n      socklen_t optval_size;\n#ifdef SO_DOMAIN\n      opt_name = SO_DOMAIN;\n      poptval = &af;\n      optval_size = (socklen_t) sizeof (af);\n#else  /* SO_PROTOCOL_INFOW */\n      WSAPROTOCOL_INFOW prot_info;\n      opt_name = SO_PROTOCOL_INFOW;\n      poptval = &prot_info;\n      optval_size = (socklen_t) sizeof (prot_info);\n#endif /* SO_PROTOCOL_INFOW */\n\n      if (0 == getsockopt (daemon->listen_fd,\n                           SOL_SOCKET,\n                           opt_name,\n                           poptval,\n                           &optval_size))\n      {\n#ifndef SO_DOMAIN\n        af = prot_info.iAddressFamily;\n#endif /* SO_DOMAIN */\n        switch (af)\n        {\n        case AF_INET:\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#ifdef HAVE_INET6\n        case AF_INET6:\n          *pflags |= MHD_USE_IPv6;\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n        case AF_UNIX:\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n          break;\n#endif /* AF_UNIX */\n        default:\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          break;\n        }\n      }\n      else\n#endif /* SOL_SOCKET && (SO_DOMAIN || SO_PROTOCOL_INFOW)) */\n      daemon->listen_is_unix = _MHD_UNKNOWN;\n    }\n\n    listen_fd = daemon->listen_fd;\n#ifdef MHD_USE_GETSOCKNAME\n    daemon->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n  }\n\n#ifdef MHD_USE_GETSOCKNAME\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) &&\n       (_MHD_YES != daemon->listen_is_unix) )\n  {   /* Get port number. */\n    struct sockaddr_storage bindaddr;\n\n    memset (&bindaddr,\n            0,\n            sizeof (struct sockaddr_storage));\n    addrlen = sizeof (struct sockaddr_storage);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n    bindaddr.ss_len = (socklen_t) addrlen;\n#endif\n    if (0 != getsockname (listen_fd,\n                          (struct sockaddr *) &bindaddr,\n                          &addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef MHD_POSIX_SOCKETS\n    else if (sizeof (bindaddr) < addrlen)\n    {\n      /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number \" \\\n                   \"(`struct sockaddr_storage` too small!?).\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifndef __linux__\n    else if (0 == addrlen)\n    {\n      /* Many non-Linux-based platforms return zero addrlen\n       * for AF_UNIX sockets */\n      daemon->port = 0;     /* special value for UNIX domain sockets */\n      if (_MHD_UNKNOWN == daemon->listen_is_unix)\n        daemon->listen_is_unix = _MHD_YES;\n    }\n#endif /* __linux__ */\n#endif /* MHD_POSIX_SOCKETS */\n    else\n    {\n      switch (bindaddr.ss_family)\n      {\n      case AF_INET:\n        {\n          struct sockaddr_in *s4 = (struct sockaddr_in *) &bindaddr;\n\n          daemon->port = ntohs (s4->sin_port);\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n        }\n#ifdef HAVE_INET6\n      case AF_INET6:\n        {\n          struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &bindaddr;\n\n          daemon->port = ntohs (s6->sin6_port);\n          daemon->listen_is_unix = _MHD_NO;\n          mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n          break;\n        }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n        daemon->port = 0;     /* special value for UNIX domain sockets */\n        daemon->listen_is_unix = _MHD_YES;\n        break;\n#endif\n      default:\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Listen socket has unknown address family!\\n\"));\n#endif\n        daemon->port = 0;     /* ugh */\n        daemon->listen_is_unix = _MHD_UNKNOWN;\n        break;\n      }\n    }\n  }\n#endif /* MHD_USE_GETSOCKNAME */\n\n  if (MHD_INVALID_SOCKET != listen_fd)\n  {\n    mhd_assert (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    if (! MHD_socket_nonblocking_ (listen_fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          || (daemon->worker_pool_size > 0)\n#endif\n          )\n      {\n        /* Accept must be non-blocking. Multiple children may wake up\n         * to handle a new connection, but only one will win the race.\n         * The others must immediately return. */\n        MHD_socket_close_chk_ (listen_fd);\n        listen_fd = MHD_INVALID_SOCKET;\n        goto free_and_fail;\n      }\n      daemon->listen_nonblk = false;\n    }\n    else\n      daemon->listen_nonblk = true;\n  }\n  else\n  {\n    mhd_assert (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    daemon->listen_nonblk = false; /* Actually listen socket does not exist */\n  }\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      && (0 == daemon->worker_pool_size)\n#endif\n      )\n  {\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Combining MHD_USE_THREAD_PER_CONNECTION and \" \\\n                   \"MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_NO == setup_epoll_to_listen (daemon))\n      goto free_and_fail;\n  }\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize IP connection limit mutex.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    goto free_and_fail;\n  }\n#endif\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialize TLS support.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    goto free_and_fail;\n  }\n#endif /* HTTPS_SUPPORT */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Start threads if requested by parameters */\n  if (MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    /* Internal thread (or threads) is used.\n     * Make sure that MHD will be able to communicate with threads. */\n    /* If using a thread pool ITC will be initialised later\n     * for each individual worker thread. */\n#ifdef HAVE_LISTEN_SHUTDOWN\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)) || \\\n                (MHD_INVALID_SOCKET != daemon->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n    if (0 == daemon->worker_pool_size)\n    {\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_create_named_thread_ (&daemon->tid,\n                                      MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) ?\n                                      \"MHD-listen\" : \"MHD-single\",\n                                      daemon->thread_stack_size,\n                                      &MHD_polling_thread,\n                                      daemon) )\n      {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n        if (EAGAIN == errno)\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a new thread because it would have \" \\\n                       \"exceeded the system limit on the number of threads or \" \\\n                       \"no system resources available.\\n\"));\n        else\n#endif /* EAGAIN */\n        MHD_DLOG (daemon,\n                  _ (\"Failed to create listen thread: %s\\n\"),\n                  MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n        MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n    }\n    else   /* 0 < daemon->worker_pool_size */\n    {\n      /* Coarse-grained count of connections per thread (note error\n       * due to integer division). Also keep track of how many\n       * connections are leftover after an equal split. */\n      unsigned int conns_per_thread = daemon->connection_limit\n                                      / daemon->worker_pool_size;\n      unsigned int leftover_conns = daemon->connection_limit\n                                    % daemon->worker_pool_size;\n\n      mhd_assert (2 <= daemon->worker_pool_size);\n      i = 0;     /* we need this in case fcntl or malloc fails */\n\n      /* Allocate memory for pooled objects */\n      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                    * daemon->worker_pool_size);\n      if (NULL == daemon->worker_pool)\n        goto thread_failed;\n\n      /* Start the workers in the pool */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n      {\n        /* Create copy of the Daemon object for each worker */\n        struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n        memcpy (d, daemon, sizeof (struct MHD_Daemon));\n        /* Adjust polling params for worker daemons; note that memcpy()\n           has already copied MHD_USE_INTERNAL_POLLING_THREAD thread mode into\n           the worker threads. */\n        d->master = daemon;\n        d->worker_pool_size = 0;\n        d->worker_pool = NULL;\n        if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n          goto thread_failed;\n        }\n        if (! MHD_mutex_init_ (&d->new_connections_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise mutex.\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n        if (0 != (*pflags & MHD_USE_ITC))\n        {\n          if (! MHD_itc_init_ (d->itc))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create worker inter-thread \" \\\n                         \"communication channel: %s\\n\"),\n                      MHD_itc_last_strerror_ () );\n#endif\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n          if (MHD_D_IS_USING_SELECT_ (d) &&\n              (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (d->itc), daemon)) )\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"File descriptor for worker inter-thread \" \\\n                         \"communication channel exceeds maximum value.\\n\"));\n#endif\n            MHD_itc_destroy_chk_ (d->itc);\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n        }\n        else\n          MHD_itc_set_invalid_ (d->itc);\n\n#ifdef HAVE_LISTEN_SHUTDOWN\n        mhd_assert ((MHD_ITC_IS_VALID_ (d->itc)) || \\\n                    (MHD_INVALID_SOCKET != d->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (MHD_ITC_IS_VALID_ (d->itc));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n\n        /* Divide available connections evenly amongst the threads.\n         * Thread indexes in [0, leftover_conns) each get one of the\n         * leftover connections. */\n        d->connection_limit = conns_per_thread;\n        if (i < leftover_conns)\n          ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (d) &&\n            (MHD_NO == setup_epoll_to_listen (d)) )\n        {\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n#endif\n        /* Some members must be used only in master daemon */\n#if defined(MHD_USE_THREADS)\n        memset (&d->per_ip_connection_mutex, 0x7F,\n                sizeof(d->per_ip_connection_mutex));\n#endif /* MHD_USE_THREADS */\n#ifdef DAUTH_SUPPORT\n        d->nnc = NULL;\n        d->nonce_nc_size = 0;\n        d->digest_auth_random_copy = NULL;\n#if defined(MHD_USE_THREADS)\n        memset (&d->nnc_lock, 0x7F, sizeof(d->nnc_lock));\n#endif /* MHD_USE_THREADS */\n#endif /* DAUTH_SUPPORT */\n\n        /* Spawn the worker thread */\n        if (! MHD_create_named_thread_ (&d->tid,\n                                        \"MHD-worker\",\n                                        daemon->thread_stack_size,\n                                        &MHD_polling_thread,\n                                        d))\n        {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == errno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new pool thread because it would \" \\\n                         \"have exceeded the system limit on the number of \" \\\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create pool thread: %s\\n\"),\n                    MHD_strerror_ (errno));\n#endif\n          /* Free memory for this worker; cleanup below handles\n           * all previously-created workers. */\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n      }\n    }\n  }\n  else\n  { /* Daemon without internal threads */\n    if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n    if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  }\n#endif\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif\n\nfree_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}\n...\nstatic enum MHD_Result\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set,\n                          int fd_setsize)\n{\n  MHD_socket ds;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  mhd_assert (0 < fd_setsize);\n  (void) fd_setsize; /* Mute compiler warning */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize; /* Mute compiler warning */\n  mhd_assert (((int) FD_SETSIZE) <= fd_setsize);\n  fd_setsize = FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  { /* Have ITC */\n    bool need_to_clear_itc = true; /* ITC is always non-blocking, it is safe to clear even if ITC not activated */\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (MHD_itc_r_fd_ (daemon->itc),\n                                         NULL, fd_setsize))\n      need_to_clear_itc = FD_ISSET (MHD_itc_r_fd_ (daemon->itc), \\\n                                    (fd_set *) _MHD_DROP_CONST (read_fd_set)); /* Skip clearing, if not needed */\n    if (need_to_clear_itc)\n      MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  /* select connection thread handling type */\n  ds = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ds) &&\n       (! daemon->was_quiesced) )\n  {\n    bool need_to_accept;\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (ds, NULL, fd_setsize))\n      need_to_accept = FD_ISSET (ds,\n                                 (fd_set *) _MHD_DROP_CONST (read_fd_set));\n    else                                       /* Cannot check whether new connection are pending */\n      need_to_accept = daemon->listen_nonblk;  /* Try to accept if non-blocking */\n\n    if (need_to_accept)\n      (void) MHD_accept_connection (daemon);\n  }\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* do not have a thread per connection, process all connections now */\n    struct MHD_Connection *pos;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      MHD_socket cs;\n      bool r_ready;\n      bool w_ready;\n      bool has_err;\n\n      cs = pos->socket_fd;\n      if (MHD_INVALID_SOCKET == cs)\n        continue;\n\n      if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (cs, NULL, fd_setsize))\n      {\n        r_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (read_fd_set));\n        w_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (write_fd_set));\n        has_err = (NULL != except_fd_set) &&\n                  FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (except_fd_set));\n      }\n      else\n      { /* Cannot check the real readiness */\n        r_ready = pos->sk_nonblck;\n        w_ready = r_ready;\n        has_err = false;\n      }\n      call_handlers (pos,\n                     r_ready,\n                     w_ready,\n                     has_err);\n    }\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    urhn = urh->prev;\n    /* update urh state based on select() output */\n    urh_from_fdset (urh,\n                    read_fd_set,\n                    write_fd_set,\n                    except_fd_set,\n                    fd_setsize);\n    /* call generic forwarding function for passing data */\n    process_urh (urh);\n    /* Finished forwarding? */\n    if ( (0 == urh->in_buffer_size) &&\n         (0 == urh->out_buffer_size) &&\n         (0 == urh->in_buffer_used) &&\n         (0 == urh->out_buffer_used) )\n    {\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection (urh->connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_YES;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_epoll (struct MHD_Daemon *daemon,\n           int32_t millisec)\n{\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  static const char *const upgrade_marker = \"upgrade_ptr\";\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n  struct epoll_event events[MAX_EVENTS];\n  struct epoll_event event;\n  int timeout_ms;\n  int num_events;\n  unsigned int i;\n  MHD_socket ls;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  bool run_upgraded = false;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  bool need_to_accept;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO; /* we're down! */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (daemon->connections < daemon->connection_limit) &&\n       (! daemon->listen_socket_in_epoll) &&\n       (! daemon->at_limit) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n  if ( (daemon->was_quiesced) &&\n       (daemon->listen_socket_in_epoll) )\n  {\n    if ( (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          ls,\n                          NULL)) &&\n         (ENOENT != errno) )   /* ENOENT can happen due to race with\n                                  #MHD_quiesce_daemon() */\n      MHD_PANIC (\"Failed to remove listen FD from epoll set.\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if ( ( (! daemon->upgrade_fd_in_epoll) &&\n         (-1 != daemon->epoll_upgrade_fd) ) )\n  {\n    event.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (upgrade_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        daemon->epoll_upgrade_fd,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->upgrade_fd_in_epoll = true;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (daemon->listen_socket_in_epoll) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ||\n         (daemon->was_quiesced) ) )\n  {\n    /* we're at the connection limit, disable listen socket\n for event loop for now */\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        ls,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove listen FD from epoll set.\\n\"));\n    daemon->listen_socket_in_epoll = false;\n  }\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  timeout_ms = get_timeout_millisec_int (daemon, millisec);\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: Used mostly for uniformity here as same situation is\n   * signaled in epoll mode by non-empty eready DLL. */\n  daemon->data_already_pending = false;\n\n  need_to_accept = false;\n  /* drain 'epoll' event queue; need to iterate as we get at most\n     MAX_EVENTS in one system call here; in practice this should\n     pretty much mean only one round, but better an extra loop here\n     than unfair behavior... */\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n  {\n    /* update event masks */\n    num_events = epoll_wait (daemon->epoll_fd,\n                             events,\n                             MAX_EVENTS,\n                             timeout_ms);\n    if (-1 == num_events)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_YES;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_wait failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n    for (i = 0; i < (unsigned int) num_events; i++)\n    {\n      /* First, check for the values of `ptr` that would indicate\n         that this event is not about a normal connection. */\n      if (NULL == events[i].data.ptr)\n        continue;     /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if (upgrade_marker == events[i].data.ptr)\n      {\n        /* activity on an upgraded connection, we process\n           those in a separate epoll() */\n        run_upgraded = true;\n        continue;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n      if (epoll_itc_marker == events[i].data.ptr)\n      {\n        /* It's OK to clear ITC here as all external\n           conditions will be processed later. */\n        MHD_itc_clear_ (daemon->itc);\n        continue;\n      }\n      if (daemon == events[i].data.ptr)\n      {\n        /* Check for error conditions on listen socket. */\n        /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n        if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n          need_to_accept = true;\n        continue;\n      }\n      /* this is an event relating to a 'normal' connection,\n         remember the event and if appropriate mark the\n         connection as 'eready'. */\n      pos = events[i].data.ptr;\n      /* normal processing: update read/write data */\n      if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n      {\n        pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n        if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_insert (daemon->eready_head,\n                       daemon->eready_tail,\n                       pos);\n          pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      }\n      else\n      {\n        if (0 != (events[i].events & EPOLLIN))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n          if ( ( (0 != (MHD_EVENT_LOOP_INFO_READ & pos->event_loop_info)) ||\n                 (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n        if (0 != (events[i].events & EPOLLOUT))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n          if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n      }\n    }\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if (need_to_accept)\n  {\n    unsigned int series_length = 0;\n\n    /* Run 'accept' until it fails or daemon at limit of connections.\n     * Do not accept more then 10 connections at once. The rest will\n     * be accepted on next turn (level trigger is used for listen\n     * socket). */\n    while ( (MHD_NO != MHD_accept_connection (daemon)) &&\n            (series_length < 10) &&\n            (daemon->connections < daemon->connection_limit) &&\n            (! daemon->at_limit) )\n      series_length++;\n  }\n\n  /* Handle timed-out connections; we need to do this here\n     as the epoll mechanism won't call the 'MHD_connection_handle_idle()' on everything,\n     as the other event loops do.  As timeouts do not get an explicit\n     event, we need to find those connections that might have timed out\n     here.\n\n     Connections with custom timeouts must all be looked at, as we\n     do not bother to sort that (presumably very short) list. */\n  prev = daemon->manual_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n  }\n  /* Connections with the default timeout are sorted by prepending\n     them to the head of the list whenever we touch the connection;\n     thus it suffices to iterate from the tail until the first\n     connection is NOT timed out */\n  prev = daemon->normal_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n    if (MHD_CONNECTION_CLOSED != pos->state)\n      break; /* sorted by timeout, no need to visit the rest! */\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (run_upgraded || (NULL != daemon->eready_urh_head))\n    run_epoll_for_upgrade (daemon);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* process events for connections */\n  prev = daemon->eready_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevE;\n    call_handlers (pos,\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_READ_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_ERROR));\n    if (MHD_EPOLL_STATE_IN_EREADY_EDLL ==\n        (pos->epoll_state & (MHD_EPOLL_STATE_SUSPENDED\n                             | MHD_EPOLL_STATE_IN_EREADY_EDLL)))\n    {\n      if ( ((MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_READ_READY)) ) ||\n           ((MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY)) ) ||\n           (MHD_EVENT_LOOP_INFO_CLEANUP == pos->event_loop_info) )\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n    }\n  }\n\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: The conditional compilation and the runtime 'use_accept4' flag make both accept4() and accept() paths potentially reachable in different build/config combinations. When USE_ACCEPT4 is defined and _DEBUG is not, only the accept4() branch is compiled (and reachable). When _DEBUG and USE_ACCEPT4 are defined, both branches are compiled and the runtime const bool use_accept4 controls which branch executes. When USE_ACCEPT4 is not defined, only the accept() branch is compiled. There is no statically unreachable code in this fragment."
}