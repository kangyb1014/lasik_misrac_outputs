{
  "user_message": "An agent A claimed that the following get_session code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_session.\n```c\nstatic struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n                                        MHD_COOKIE_KIND,\n                                        COOKIE_NAME);\n  if (cookie != NULL)\n  {\n    /* find existing session */\n    ret = sessions;\n    while (NULL != ret)\n    {\n      if (0 == strcmp (cookie, ret->sid))\n        break;\n      ret = ret->next;\n    }\n    if (NULL != ret)\n    {\n      ret->rc++;\n      return ret;\n    }\n  }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n  {\n    fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n    return NULL;\n  }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n            sizeof (ret->sid),\n            \"%X%X%X%X\",\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the value returned by MHD_lookup_connection_value (cookie) is not guaranteed to be a NUL-terminated string or the buffer it points to does not contain a terminating '\\0' within its allocated bounds, then strcmp(cookie, ret->sid) will read past the end of the cookie buffer (or, if ret->sid were ever not NUL-terminated, past that buffer). While ret->sid is set with snprintf (which ensures NUL-termination), the external cookie pointer is not proven here to be NUL-terminated or size-limited; therefore this use of strcmp can result in out-of-bounds accesses and violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in the absence of a documented guarantee from MHD_lookup_connection_value that the returned pointer refers to a NUL-terminated string within its object bounds. strcmp reads until a terminating '\\0' from both pointers; ret->sid is NUL-terminated (set via snprintf) but cookie is only checked for NULL. MISRA C 2023 Rule 21.17 requires that uses of <string.h> functions must not be able to read past the bounds of the objects they reference. Unless the MHD_lookup_connection_value contract is proven to return a properly NUL-terminated C string, this use of strcmp can potentially access beyond the cookie buffer and thus violates Rule 21.17. If the API does guarantee NUL-termination, the code would be compliant; otherwise a fix (validate/terminate the cookie, use a bounded comparison such as strncmp with a known length, or document the guarantee) is required."
}