{
  "user_message": "An agent A claimed that the following get_session code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_session.\n```c\nstatic struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n                                        MHD_COOKIE_KIND,\n                                        COOKIE_NAME);\n  if (cookie != NULL)\n  {\n    /* find existing session */\n    ret = sessions;\n    while (NULL != ret)\n    {\n      if (0 == strcmp (cookie, ret->sid))\n        break;\n      ret = ret->next;\n    }\n    if (NULL != ret)\n    {\n      ret->rc++;\n      return ret;\n    }\n  }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n  {\n    fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n    return NULL;\n  }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n            sizeof (ret->sid),\n            \"%X%X%X%X\",\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand (),\n            (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'connection' is declared as 'struct MHD_Connection *connection' even though get_session does not modify the object it points to. According to MISRA C 2023 R8.13 the pointer should be const-qualified when possible (e.g. 'const struct MHD_Connection *connection'), unless the called API (MHD_lookup_connection_value) requires a non-const pointer. The return pointer is intentionally non-const because the function allocates and mutates the Session object, so leaving the return type non-const is appropriate.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 recommends const-qualifying pointer targets when possible, but in this code get_session must call MHD_lookup_connection_value. The libmicrohttpd API declares that function to take a (non-const) struct MHD_Connection * parameter, so get_session cannot change its parameter to const struct MHD_Connection * without creating an incompatible pointer type or requiring a cast that would defeat const-correctness. Because the external API requires a non-const pointer, the pointer cannot reasonably be made const here, so this is not a violation of MISRA C 2023 R8.13. (If the called API were const-correct, then changing the parameter to const would be appropriate.)"
}