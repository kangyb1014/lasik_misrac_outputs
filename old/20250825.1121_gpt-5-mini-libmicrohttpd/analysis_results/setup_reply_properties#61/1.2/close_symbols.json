{
  "user_message": "Target function code is:\n```c\nstatic void\nsetup_reply_properties (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n  enum replyBodyUse use_rp_body;\n  bool use_chunked;\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust reply properties ** */\n\n  c->keepalive = keepalive_possible (c);\n  use_rp_body = is_reply_body_needed (c, c->rp.responseCode);\n  c->rp.props.send_reply_body = (use_rp_body > RP_BODY_HEADERS_ONLY);\n  c->rp.props.use_reply_body_headers = (use_rp_body >= RP_BODY_HEADERS_ONLY);\n\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ( (NULL == r->upgrade_handler) ||\n               (RP_BODY_NONE == use_rp_body) );\n#endif /* UPGRADE_SUPPORT */\n\n  if (c->rp.props.use_reply_body_headers)\n  {\n    if ((MHD_SIZE_UNKNOWN == r->total_size) ||\n        (0 != (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED)))\n    { /* Use chunked reply encoding if possible */\n\n      /* Check whether chunked encoding is supported by the client */\n      if (! MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n        use_chunked = false;\n      /* Check whether chunked encoding is allowed for the reply */\n      else if (0 != (r->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n        use_chunked = false;\n      else\n        /* If chunked encoding is supported and allowed, and response size\n         * is unknown, use chunked even for non-Keep-Alive connections.\n         * See https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3\n         * Also use chunked if it is enforced by application and supported by\n         * the client. */\n        use_chunked = true;\n    }\n    else\n      use_chunked = false;\n\n    if ( (MHD_SIZE_UNKNOWN == r->total_size) &&\n         (! use_chunked) )\n    {\n      /* End of the stream is indicated by closure */\n      c->keepalive = MHD_CONN_MUST_CLOSE;\n    }\n  }\n  else\n    use_chunked = false; /* chunked encoding cannot be used without body */\n\n  c->rp.props.chunked = use_chunked;\n#ifdef _DEBUG\n  c->rp.props.set = true;\n#endif /* _DEBUG */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'setup_reply_properties': {'callees': ['keepalive_possible', 'is_reply_body_needed'], 'callers': ['build_header_response']}, 'keepalive_possible': {'callees': ['MHD_lookup_header_token_ci'], 'callers': ['setup_reply_properties']}, 'is_reply_body_needed': {'callees': [], 'callers': ['setup_reply_properties', 'MHD_queue_response']}, 'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (full definition)",
    "struct MHD_Response (full definition)",
    "type/definition of c->rp and c->rp.props (inner reply-properties struct/union)",
    "enum replyBodyUse and values (RP_BODY_HEADERS_ONLY, RP_BODY_NONE, RP_BODY_NONE etc.)",
    "mhd_assert (macro or function definition)",
    "MHD_IS_HTTP_VER_1_1_COMPAT (macro or inline function)",
    "MHD_SIZE_UNKNOWN (macro/constant)",
    "MHD_RAF_HAS_TRANS_ENC_CHUNKED (macro/constant)",
    "MHD_RF_HTTP_1_0_COMPATIBLE_STRICT (macro/constant)",
    "MHD_RF_HTTP_1_0_SERVER (macro/constant)",
    "MHD_CONN_MUST_CLOSE (macro/constant)",
    "definition of bool (stdbool.h or project typedef)",
    "preprocessor feature macros: _DEBUG and UPGRADE_SUPPORT (their definitions/usage)"
  ],
  "explanation": "For checking whether the target function uses compiler language extensions you must inspect not only the source text shown but also any macros, types or member declarations that could expand to or rely on extensions. Reason for each symbol: \n\n- struct MHD_Connection (full definition): the function accesses c->rp, c->keepalive, c->rq.http_ver etc. The connection struct or its member declarations could use anonymous structs/unions, bit-fields, attributes, or other compiler-specific extensions; you must examine the actual definition.\n\n- struct MHD_Response (full definition): code reads r->total_size, r->flags_auto, r->flags, r->upgrade_handler. The response type might contain flexible array members, nonstandard attributes, bit-fields, or other extensions that would make the target function use extensions indirectly.\n\n- type/definition of c->rp and c->rp.props (inner reply-properties struct/union): the function manipulates rp.props fields and relies on their layout. Anonymous/unnamed nested structs/unions or compiler-specific qualifiers could be present here.\n\n- enum replyBodyUse and values (RP_BODY_HEADERS_ONLY, RP_BODY_NONE, etc.): the code compares enum values; if these are defined using nonstandard tricks (e.g., macros wrapping typeof or extensions) that would matter.\n\n- mhd_assert (macro or function definition): this macro is invoked inside the function. Many projects implement assert-like macros using statement-expression ({ ... }), typeof, __attribute__ or builtin intrinsics \u2014 all possible compiler extensions. You must inspect its definition.\n\n- MHD_IS_HTTP_VER_1_1_COMPAT (macro or inline function): used in a conditional. A macro might expand to token-pasting, statement-expression, or compiler builtins; check its definition for extensions.\n\n- MHD_SIZE_UNKNOWN (macro/constant): used in comparisons. Its definition could be e.g. ((size_t)-1) or some expression that uses extensions \u2014 inspect to be sure.\n\n- MHD_RAF_HAS_TRANS_ENC_CHUNKED (macro/constant): used in a bitwise test; its definition could be nonstandard (e.g. using enums with attributes or extension macros).\n\n- MHD_RF_HTTP_1_0_COMPATIBLE_STRICT and MHD_RF_HTTP_1_0_SERVER (macros/constants): same rationale as other flag macros \u2014 their definitions might use extensions.\n\n- MHD_CONN_MUST_CLOSE (macro/constant): assigned to c->keepalive; its definition could be an enum or macro that uses extensions.\n\n- definition of bool (stdbool.h or project typedef): the function uses bool. Check whether the project uses standard _Bool/stdbool.h or a nonstandard typedef (e.g., int or custom), or defines macros that rely on extensions.\n\n- preprocessor feature macros: _DEBUG and UPGRADE_SUPPORT (their definitions/usage): these control conditional compilation within the function; the code compiled under those branches may use extensions (e.g., additional asserts, attributes). You need the definitions to know which code actually compiles and whether any compiled branch relies on extensions.\n\nCollecting these definitions allows an analyzer to see whether any macros/types expanded into compiler-specific constructs (statement expressions, typeof, nested/anonymous structs/unions if not standard for the language level in use, __attribute__ uses, builtin functions, nested functions, etc.), and so determine if the target function (as compiled in the project) violates the MISRA prohibition on language extensions."
}