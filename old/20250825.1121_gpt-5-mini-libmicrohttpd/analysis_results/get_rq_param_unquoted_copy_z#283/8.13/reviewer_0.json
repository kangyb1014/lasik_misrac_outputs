{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code reads from param->value.str through a const pointer to the struct but the string member itself is not const-qualified. If value.str is declared as a plain char * (i.e. mutable pointer to mutable data) while the data is only read (memcpy, MHD_str_unquote), this violates MISRA C 2023 Rule 8.13 \u2014 the pointer should be declared to point to const-qualified data (const char *). If, instead, value.str is already declared as const char *, then there is no violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_param_unquoted_copy_z:\nstruct MHD_RqDAuthParam\n{\n  /**\n   * The string with length, NOT zero-terminated\n   */\n  struct _MHD_str_w_len value;\n  /**\n   * True if string must be \"unquoted\" before processing.\n   * This member is false if the string is used in DQUOTE marks, but no\n   * backslash-escape is used in the string.\n   */\n  bool quoted;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 R8.13 says pointers should point to const-qualified types whenever possible. In this function we only read from param->value.str (and write into buf), so the concern would be with the declaration of the member value.str in struct _MHD_str_w_len: if it is declared as plain char * but the pointed-to characters are never modified, then that declaration should be changed to const char * and the program would violate R8.13 as asserted by agent A. However, the provided snippet does not show the definition of struct _MHD_str_w_len (and thus the type of value.str). Therefore you cannot determine from this function alone that a MISRA 8.13 violation actually occurs. Note also that the issue (if any) is in the struct member declaration, not in this function: this function uses a const pointer to the struct (correct), and buf is a writable destination (so char * is appropriate). Recommendation: inspect the definition of _MHD_str_w_len; if value.str is declared as char * but the data is read-only, change it to const char * (or document why the data must remain mutable)."
}