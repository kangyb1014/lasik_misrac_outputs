{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function receives a pointer to const struct (const struct MHD_RqDAuthParam *param) and only reads param->value.str (it never modifies the pointed-to characters). If the underlying member is declared as a non-const pointer (e.g. char *str in struct _MHD_str_w_len), that declaration violates MISRA C 2023 Rule 8.13 \u2014 the pointer should be declared to point to a const-qualified type (e.g. const char *str) because the data is used read-only. Note: the single statement mhd_assert(NULL != param->value.str); itself is not a pointer declaration, but it exposes the underlying non-const pointer declaration which should be const-qualified.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_param_unquoted_copy_z:\nstruct MHD_RqDAuthParam\n{\n  /**\n   * The string with length, NOT zero-terminated\n   */\n  struct _MHD_str_w_len value;\n  /**\n   * True if string must be \"unquoted\" before processing.\n   * This member is false if the string is used in DQUOTE marks, but no\n   * backslash-escape is used in the string.\n   */\n  bool quoted;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. Rule 8.13 concerns pointer declarations (they should point to const-qualified types when appropriate), not mere uses of pointers inside a function. In the shown function there is no declaration of a pointer-to-non-const that should be const: the function parameter is already a pointer to a const struct (const struct MHD_RqDAuthParam *param), so accesses to param->value.* are treated as read-only here. The assertion mhd_assert(NULL != param->value.str) is just a use, not a declaration. Whether a Rule 8.13 violation actually exists depends on how struct _MHD_str_w_len::str is declared and on the wider program semantics. If that member is declared as char *str and it is never modified anywhere (i.e. it is only read), then the declaration could be improved to const char *str and that declaration would be a Rule 8.13 issue. But nothing in the snippet proves that; the provided code alone does not violate MISRA C 2023 Rule 8.13."
}