{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memcpy(buf, param->value.str, param->value.len) can write param->value.len bytes into buf and then the code writes a terminating NUL at buf[param->value.len]. The function signature provides no buf size or contract ensuring buf is at least param->value.len+1 bytes, so if buf refers to a smaller object (for example: char buf[8]; param->value.len == 10) the memcpy will write past the end of buf (and the following buf[param->value.len]=0 will also write out of bounds). Similarly, nothing in this fragment guarantees that param->value.str actually contains at least param->value.len bytes, so memcpy may read beyond the source object. Therefore Rule 21.17 is violated.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown fragment there is no guarantee that the destination buffer buf is large enough to hold param->value.len bytes plus the terminating NUL, nor is there a guarantee that param->value.str actually refers to an object containing at least param->value.len bytes. The memcpy(buf, param->value.str, param->value.len) and the subsequent buf[param->value.len] = 0 therefore may read or write beyond the bounds of the source or destination objects. The mhd_assert checks do not establish a compile-time or semantic guarantee (and may be disabled), so they do not remove the out\u2011of\u2011bounds possibility for purposes of Rule 21.17. The only way this would not be a violation is if an externally provable contract (or an additional parameter) guarantees buf is at least param->value.len+1 and param->value.str has at least param->value.len bytes \u2014 but no such guarantee is visible here. Thus Agent A\u2019s violation report is justified."
}