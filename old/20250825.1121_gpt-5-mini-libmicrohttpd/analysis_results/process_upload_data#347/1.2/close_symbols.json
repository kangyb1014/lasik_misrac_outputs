{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'process_upload_data': {'callees': ['do_append'], 'callers': []}, 'do_append': {'callees': [], 'callers': ['process_upload_data']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct UploadContext",
    "enum MHD_Result",
    "enum MHD_ValueKind",
    "do_append (prototype)",
    "request_refused_response",
    "internal_error_response",
    "MHD_YES",
    "MHD_NO",
    "PATH_MAX",
    "WINDOWS",
    "_WIN32",
    "__CYGWIN__",
    "O_LARGEFILE",
    "O_CREAT",
    "O_EXCL",
    "O_WRONLY",
    "S_IRUSR",
    "S_IWUSR",
    "S_IRWXU",
    "mkdir",
    "snprintf",
    "fprintf",
    "strcmp",
    "strstr",
    "strchr",
    "isprint",
    "open",
    "write",
    "close",
    "unlink",
    "free",
    "strdup",
    "strerror",
    "errno"
  ],
  "explanation": "To decide whether process_upload_data uses any compiler language extensions we must inspect the definitions/implementations of all external symbols, macros and types the function relies on because any of those may be implemented using compiler-specific extensions (macros that expand to builtin/extension tokens, attributes, thread-local mechanisms, nonstandard types, or platform-specific language features). Brief reasons for each: \n\n- struct UploadContext: needed to know the exact member types (category, language, fd, filename, response). The struct could use compiler extensions (bit-fields, flexible array, packed/attribute annotations) that would violate the rule. \n- enum MHD_Result: return type; must check whether it is a plain enum or uses compiler-specific extension (e.g. nonstandard underlying type or attributes). Also to identify MHD_YES / MHD_NO definitions. \n- enum MHD_ValueKind: declared parameter type \u2014 ensure it's a standard enum and not an extension. \n- do_append (prototype): determine whether this identifier is a normal function or a macro/inline/attribute-wrapped symbol implemented with compiler extensions. \n- request_refused_response, internal_error_response: these identifiers may be macros or objects created via compiler extensions; need their definitions to confirm no extension use. \n- MHD_YES, MHD_NO: check whether these are ordinary enum constants or macros that could hide extensions. \n- PATH_MAX: used to size the local array; PATH_MAX could be a non-constant macro or use compiler extension to compute size \u2014 need its definition. \n- WINDOWS, _WIN32, __CYGWIN__: preprocessor target macros select alternate code paths. To know which branches are active (and whether any branch introduces extensions, e.g. Windows-specific APIs or casts), their definitions/usage must be known. \n- O_LARGEFILE, O_CREAT, O_EXCL, O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU: file-flag and permission macros \u2014 they could be defined in implementation headers using extension constructs; also O_LARGEFILE presence changes control flow and may imply nonstandard behavior. \n- mkdir: platform-dependent function/macro \u2014 on Windows it may be a different API or macro; prototype/definition must be checked for extensions. \n- snprintf: may be a macro or builtin mapping to compiler intrinsic; need to see if it uses compiler-specific builtins or attributes. \n- fprintf, strcmp, strstr, strchr, isprint, open, write, close, unlink, free, strdup, strerror: all standard library calls/macros \u2014 some implementations expose them as macros or builtins (or use attributes/inline/asm) which would be a language extension; their definitions must be checked. \n- errno: often a macro that expands to a thread-local location (may use compiler thread-local extensions); its definition must be inspected to ensure no extension usage.\n\nIn short: to determine whether the target function uses language extensions you must inspect the declarations/definitions of each of the above symbols (macros, types, functions and platform selection macros) because any of them could be implemented by the headers or codebase using compiler-specific extension syntax or attributes."
}