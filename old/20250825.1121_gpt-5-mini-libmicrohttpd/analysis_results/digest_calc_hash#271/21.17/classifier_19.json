{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of digest_calc_hash:\n```c\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function digest_calc_hash:\nstruct DigestAlgorithm\n{\n  /**\n   * A context for the digest algorithm, already initialized to be\n   * useful for @e init, @e update and @e digest.\n   */\n  union DigestCtx ctx;\n\n  /**\n   * The hash calculation algorithm.\n   */\n  enum MHD_DigestBaseAlgo algo;\n\n  /**\n   * Buffer for hex-print of the final digest.\n   */\n#ifdef _DEBUG\n  bool uninitialised; /**< The structure has been not set-up */\n  bool algo_selected; /**< The algorithm has been selected */\n  bool ready_for_hashing; /**< The structure is ready to hash data */\n  bool hashing; /**< Some data has been hashed, but the digest has not finalised yet */\n#endif /* _DEBUG */\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nvoid\nMHD_MD5_finish (struct Md5Ctx *ctx,\n                uint8_t digest[MD5_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See RFC 1321, Clauses 3.1 and 3.2 (steps 1 and 2). */\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (MD5_BLOCK_SIZE - bytes_have < MD5_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < MD5_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              MD5_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    md5_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          MD5_BLOCK_SIZE - MD5_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed data as little-endian value.\n     See RFC 1321, clauses 2 and 3.2 (step 2). */\n  _MHD_PUT_64BIT_LE_SAFE (ctx->buffer + MD5_BLOCK_SIZE_WORDS - 2,\n                          num_bits);\n  /* Process the full final block. */\n  md5_transform (ctx->H, ctx->buffer);\n\n  /* Put in LE mode the hash as the final digest.\n     See RFC 1321, clauses 2 and 3.5 (step 5). */\n#ifndef _MHD_PUT_32BIT_LE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[MD5_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_LE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_LE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address. */\n    memcpy (digest, alig_dgst, MD5_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_LE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_LE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_LE ((void *) (digest + 0 * MD5_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 1 * MD5_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 2 * MD5_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_LE ((void *) (digest + 3 * MD5_BYTES_IN_WORD), ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_LE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Md5Ctx));\n}\n...\n#define MHD_MD5_finish_reset(ctx, digest) MHD_MD5_finish(ctx,digest),MHD_MD5_reset(ctx)\n...\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n...\n#define MHD_SHA256_finish_reset(ctx, digest) MHD_SHA256_finish(ctx,digest),MHD_SHA256_reset(ctx)\n...\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n...\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    memcpy (X, M, sizeof(X));\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n}\n...\nstatic void\nsha256_transform (uint32_t H[SHA256_DIGEST_SIZE_WORDS],\n                  const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 paragraph 6.2. */\n  uint32_t a = H[0];\n  uint32_t b = H[1];\n  uint32_t c = H[2];\n  uint32_t d = H[3];\n  uint32_t e = H[4];\n  uint32_t f = H[5];\n  uint32_t g = H[6];\n  uint32_t h = H[7];\n\n  /* Data buffer, used as cyclic buffer.\n     See FIPS PUB 180-4 paragraphs 5.2.1, 6.2. */\n  uint32_t W[16];\n\n#ifndef _MHD_GET_32BIT_BE_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT32_ALIGN))\n  {\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, SHA256_BLOCK_SIZE);\n    /* The W[] buffer itself will be used as the source of the data,\n     * but data will be reloaded in correct bytes order during\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_32BIT_BE_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimization.\n     See FIPS PUB 180-4 formulae 4.2, 4.3. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.4, 4.5, 4.6, 4.7. */\n#define SIG0(x)  (_MHD_ROTR32 ((x), 2) ^ _MHD_ROTR32 ((x), 13) ^ \\\n                  _MHD_ROTR32 ((x), 22) )\n#define SIG1(x)  (_MHD_ROTR32 ((x), 6) ^ _MHD_ROTR32 ((x), 11) ^ \\\n                  _MHD_ROTR32 ((x), 25) )\n#define sig0(x)  (_MHD_ROTR32 ((x), 7) ^ _MHD_ROTR32 ((x), 18) ^ \\\n                  ((x) >> 3) )\n#define sig1(x)  (_MHD_ROTR32 ((x), 17) ^ _MHD_ROTR32 ((x),19) ^ \\\n                  ((x) >> 10) )\n\n  /* One step of SHA-256 computation,\n     see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n           second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other data as well\n           every time when used. */\n#define SHA2STEP32(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer,\n     See FIPS PUB 180-4 paragraph 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 paragraph 3.1.2. */\n  /* Use cast to (const void*) to mute compiler alignment warning,\n   * data was already aligned in previous step */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_BE ((const void*)(((const uint8_t*) (buf)) + \\\n                                   (t) * SHA256_BYTES_IN_WORD))\n\n  /* 'W' generation and assignment for 16 <= t <= 63.\n     See FIPS PUB 180-4 paragraph 6.2.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as cyclic buffer.\n   * Note: ((t-16)&0xf) have same value as (t&0xf) */\n#define Wgen(w,t) ( (w)[(t - 16) & 0xf] + sig1 ((w)[((t) - 2) & 0xf])   \\\n                    + (w)[((t) - 7) & 0xf] + sig0 ((w)[((t) - 15) & 0xf]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP32(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP32(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7]);\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0] = \\\n                  GET_W_FROM_DATA (data, 0));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1] = \\\n                  GET_W_FROM_DATA (data, 1));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2] = \\\n                  GET_W_FROM_DATA (data, 2));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3] = \\\n                  GET_W_FROM_DATA (data, 3));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4] = \\\n                  GET_W_FROM_DATA (data, 4));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5] = \\\n                  GET_W_FROM_DATA (data, 5));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6] = \\\n                  GET_W_FROM_DATA (data, 6));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7] = \\\n                  GET_W_FROM_DATA (data, 7));\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8] = \\\n                  GET_W_FROM_DATA (data, 8));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9] = \\\n                  GET_W_FROM_DATA (data, 9));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10] = \\\n                  GET_W_FROM_DATA (data, 10));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11] = \\\n                  GET_W_FROM_DATA (data, 11));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12] = \\\n                  GET_W_FROM_DATA (data, 12));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13] = \\\n                  GET_W_FROM_DATA (data, 13));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14] = \\\n                  GET_W_FROM_DATA (data, 14));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15] = \\\n                  GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 48 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xe49b69c1), W[16 & 0xf] = \\\n                Wgen (W,16));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xefbe4786), W[17 & 0xf] = \\\n                Wgen (W,17));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x0fc19dc6), W[18 & 0xf] = \\\n                Wgen (W,18));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x240ca1cc), W[19 & 0xf] = \\\n                Wgen (W,19));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x2de92c6f), W[20 & 0xf] = \\\n                Wgen (W,20));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4a7484aa), W[21 & 0xf] = \\\n                Wgen (W,21));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5cb0a9dc), W[22 & 0xf] = \\\n                Wgen (W,22));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x76f988da), W[23 & 0xf] = \\\n                Wgen (W,23));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x983e5152), W[24 & 0xf] = \\\n                Wgen (W,24));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa831c66d), W[25 & 0xf] = \\\n                Wgen (W,25));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb00327c8), W[26 & 0xf] = \\\n                Wgen (W,26));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xbf597fc7), W[27 & 0xf] = \\\n                Wgen (W,27));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xc6e00bf3), W[28 & 0xf] = \\\n                Wgen (W,28));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd5a79147), W[29 & 0xf] = \\\n                Wgen (W,29));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x06ca6351), W[30 & 0xf] = \\\n                Wgen (W,30));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x14292967), W[31 & 0xf] = \\\n                Wgen (W,31));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x27b70a85), W[32 & 0xf] = \\\n                Wgen (W,32));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x2e1b2138), W[33 & 0xf] = \\\n                Wgen (W,33));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x4d2c6dfc), W[34 & 0xf] = \\\n                Wgen (W,34));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x53380d13), W[35 & 0xf] = \\\n                Wgen (W,35));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x650a7354), W[36 & 0xf] = \\\n                Wgen (W,36));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x766a0abb), W[37 & 0xf] = \\\n                Wgen (W,37));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x81c2c92e), W[38 & 0xf] = \\\n                Wgen (W,38));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x92722c85), W[39 & 0xf] = \\\n                Wgen (W,39));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xa2bfe8a1), W[40 & 0xf] = \\\n                Wgen (W,40));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa81a664b), W[41 & 0xf] = \\\n                Wgen (W,41));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xc24b8b70), W[42 & 0xf] = \\\n                Wgen (W,42));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xc76c51a3), W[43 & 0xf] = \\\n                Wgen (W,43));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xd192e819), W[44 & 0xf] = \\\n                Wgen (W,44));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd6990624), W[45 & 0xf] = \\\n                Wgen (W,45));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xf40e3585), W[46 & 0xf] = \\\n                Wgen (W,46));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x106aa070), W[47 & 0xf] = \\\n                Wgen (W,47));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x19a4c116), W[48 & 0xf] = \\\n                Wgen (W,48));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x1e376c08), W[49 & 0xf] = \\\n                Wgen (W,49));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x2748774c), W[50 & 0xf] = \\\n                Wgen (W,50));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x34b0bcb5), W[51 & 0xf] = \\\n                Wgen (W,51));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x391c0cb3), W[52 & 0xf] = \\\n                Wgen (W,52));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4ed8aa4a), W[53 & 0xf] = \\\n                Wgen (W,53));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5b9cca4f), W[54 & 0xf] = \\\n                Wgen (W,54));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x682e6ff3), W[55 & 0xf] = \\\n                Wgen (W,55));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x748f82ee), W[56 & 0xf] = \\\n                Wgen (W,56));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x78a5636f), W[57 & 0xf] = \\\n                Wgen (W,57));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x84c87814), W[58 & 0xf] = \\\n                Wgen (W,58));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x8cc70208), W[59 & 0xf] = \\\n                Wgen (W,59));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x90befffa), W[60 & 0xf] = \\\n                Wgen (W,60));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xa4506ceb), W[61 & 0xf] = \\\n                Wgen (W,61));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xbef9a3f7), W[62 & 0xf] = \\\n                Wgen (W,62));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc67178f2), W[63 & 0xf] = \\\n                Wgen (W,63));\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n    static const uint32_t K[80] =\n    { UINT32_C (0x428a2f98),  UINT32_C (0x71374491),  UINT32_C (0xb5c0fbcf),\n      UINT32_C (0xe9b5dba5),  UINT32_C (0x3956c25b),  UINT32_C (0x59f111f1),\n      UINT32_C (0x923f82a4),  UINT32_C (0xab1c5ed5),  UINT32_C (0xd807aa98),\n      UINT32_C (0x12835b01),  UINT32_C (0x243185be),  UINT32_C (0x550c7dc3),\n      UINT32_C (0x72be5d74),  UINT32_C (0x80deb1fe),  UINT32_C (0x9bdc06a7),\n      UINT32_C (0xc19bf174),  UINT32_C (0xe49b69c1),  UINT32_C (0xefbe4786),\n      UINT32_C (0x0fc19dc6),  UINT32_C (0x240ca1cc),  UINT32_C (0x2de92c6f),\n      UINT32_C (0x4a7484aa),  UINT32_C (0x5cb0a9dc),  UINT32_C (0x76f988da),\n      UINT32_C (0x983e5152),  UINT32_C (0xa831c66d),  UINT32_C (0xb00327c8),\n      UINT32_C (0xbf597fc7),  UINT32_C (0xc6e00bf3),  UINT32_C (0xd5a79147),\n      UINT32_C (0x06ca6351),  UINT32_C (0x14292967),  UINT32_C (0x27b70a85),\n      UINT32_C (0x2e1b2138),  UINT32_C (0x4d2c6dfc),  UINT32_C (0x53380d13),\n      UINT32_C (0x650a7354),  UINT32_C (0x766a0abb),  UINT32_C (0x81c2c92e),\n      UINT32_C (0x92722c85),  UINT32_C (0xa2bfe8a1),  UINT32_C (0xa81a664b),\n      UINT32_C (0xc24b8b70),  UINT32_C (0xc76c51a3),  UINT32_C (0xd192e819),\n      UINT32_C (0xd6990624),  UINT32_C (0xf40e3585),  UINT32_C (0x106aa070),\n      UINT32_C (0x19a4c116),  UINT32_C (0x1e376c08),  UINT32_C (0x2748774c),\n      UINT32_C (0x34b0bcb5),  UINT32_C (0x391c0cb3),  UINT32_C (0x4ed8aa4a),\n      UINT32_C (0x5b9cca4f),  UINT32_C (0x682e6ff3),  UINT32_C (0x748f82ee),\n      UINT32_C (0x78a5636f),  UINT32_C (0x84c87814),  UINT32_C (0x8cc70208),\n      UINT32_C (0x90befffa),  UINT32_C (0xa4506ceb),  UINT32_C (0xbef9a3f7),\n      UINT32_C (0xc67178f2) };\n    /* One step of SHA-256 computation with working variables rotation,\n       see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP32RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n    uint32_t tmp_h_ = (vH);                                           \\\n    SHA2STEP32((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));  \\\n    (vH) = (vG);                                                      \\\n    (vG) = (vF);                                                      \\\n    (vF) = (vE);                                                      \\\n    (vE) = (vD);                                                      \\\n    (vD) = (vC);                                                      \\\n    (vC) = (vB);                                                      \\\n    (vB) = (vA);                                                      \\\n    (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n\n    /* During last 48 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 64; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n\n  /* Compute intermediate hash.\n     See FIPS PUB 180-4 paragraph 6.2.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n...\nstatic void\nsha512_256_transform (uint64_t H[SHA512_256_HASH_SIZE_WORDS],\n                      const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 clause 6.7, 6.4. */\n  uint64_t a = H[0];\n  uint64_t b = H[1];\n  uint64_t c = H[2];\n  uint64_t d = H[3];\n  uint64_t e = H[4];\n  uint64_t f = H[5];\n  uint64_t g = H[6];\n  uint64_t h = H[7];\n\n  /* Data buffer, used as a cyclic buffer.\n     See FIPS PUB 180-4 clause 5.2.2, 6.7, 6.4. */\n  uint64_t W[16];\n\n#ifndef _MHD_GET_64BIT_BE_ALLOW_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT64_ALIGN))\n  { /* The input data is unaligned */\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, sizeof(W));\n    /* The W[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_64BIT_BE_ALLOW_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimisation.\n     See FIPS PUB 180-4 formulae 4.8, 4.9. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.10, 4.11, 4.12, 4.13. */\n#define SIG0(x)  \\\n  ( _MHD_ROTR64 ((x), 28) ^ _MHD_ROTR64 ((x), 34) ^ _MHD_ROTR64 ((x), 39) )\n#define SIG1(x)  \\\n  ( _MHD_ROTR64 ((x), 14) ^ _MHD_ROTR64 ((x), 18) ^ _MHD_ROTR64 ((x), 41) )\n#define sig0(x)  \\\n  ( _MHD_ROTR64 ((x), 1) ^ _MHD_ROTR64 ((x), 8) ^ ((x) >> 7) )\n#define sig1(x)  \\\n  ( _MHD_ROTR64 ((x), 19) ^ _MHD_ROTR64 ((x), 61) ^ ((x) >> 6) )\n\n  /* One step of SHA-512/256 computation,\n     see FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: the first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n           the second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other\n           data as well every time when used. */\n#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer for 0 <= t <= 15,\n     See FIPS PUB 180-4 clause 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 clause 3.1.2. */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_64BIT_BE (((const uint64_t*) (buf)) + (t))\n\n  /* 'W' generation and assignment for 16 <= t <= 79.\n     See FIPS PUB 180-4 clause 6.4.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as a cyclic buffer.\n   * Note: ((t-16) & 15) have same value as (t & 15) */\n#define Wgen(w,t) ( (w)[(t - 16) & 15] + sig1 ((w)[((t) - 2) & 15])   \\\n                    + (w)[((t) - 7) & 15] + sig0 ((w)[((t) - 15) & 15]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP64(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP64(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), W[0]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), W[1]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), W[2]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), W[3]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), W[4]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), W[5]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), W[6]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), W[7]);\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), W[8]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), W[9]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), W[10]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), W[11]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), W[12]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), W[13]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), W[14]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), \\\n                W[0] = GET_W_FROM_DATA (data, 0));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), \\\n                W[1] = GET_W_FROM_DATA (data, 1));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), \\\n                W[2] = GET_W_FROM_DATA (data, 2));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), \\\n                W[3] = GET_W_FROM_DATA (data, 3));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), \\\n                W[4] = GET_W_FROM_DATA (data, 4));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), \\\n                W[5] = GET_W_FROM_DATA (data, 5));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), \\\n                W[6] = GET_W_FROM_DATA (data, 6));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), \\\n                W[7] = GET_W_FROM_DATA (data, 7));\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), \\\n                W[8] = GET_W_FROM_DATA (data, 8));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), \\\n                W[9] = GET_W_FROM_DATA (data, 9));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), \\\n                W[10] = GET_W_FROM_DATA (data, 10));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), \\\n                W[11] = GET_W_FROM_DATA (data, 11));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), \\\n                W[12] = GET_W_FROM_DATA (data, 12));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), \\\n                W[13] = GET_W_FROM_DATA (data, 13));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), \\\n                W[14] = GET_W_FROM_DATA (data, 14));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), \\\n                W[15] = GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 64 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n     K values. */\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xe49b69c19ef14ad2), \\\n              W[16 & 15] = Wgen (W,16));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xefbe4786384f25e3), \\\n              W[17 & 15] = Wgen (W,17));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x0fc19dc68b8cd5b5), \\\n              W[18 & 15] = Wgen (W,18));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x240ca1cc77ac9c65), \\\n              W[19 & 15] = Wgen (W,19));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x2de92c6f592b0275), \\\n              W[20 & 15] = Wgen (W,20));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4a7484aa6ea6e483), \\\n              W[21 & 15] = Wgen (W,21));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5cb0a9dcbd41fbd4), \\\n              W[22 & 15] = Wgen (W,22));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x76f988da831153b5), \\\n              W[23 & 15] = Wgen (W,23));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x983e5152ee66dfab), \\\n              W[24 & 15] = Wgen (W,24));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa831c66d2db43210), \\\n              W[25 & 15] = Wgen (W,25));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb00327c898fb213f), \\\n              W[26 & 15] = Wgen (W,26));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xbf597fc7beef0ee4), \\\n              W[27 & 15] = Wgen (W,27));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xc6e00bf33da88fc2), \\\n              W[28 & 15] = Wgen (W,28));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd5a79147930aa725), \\\n              W[29 & 15] = Wgen (W,29));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x06ca6351e003826f), \\\n              W[30 & 15] = Wgen (W,30));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x142929670a0e6e70), \\\n              W[31 & 15] = Wgen (W,31));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x27b70a8546d22ffc), \\\n              W[32 & 15] = Wgen (W,32));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x2e1b21385c26c926), \\\n              W[33 & 15] = Wgen (W,33));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x4d2c6dfc5ac42aed), \\\n              W[34 & 15] = Wgen (W,34));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x53380d139d95b3df), \\\n              W[35 & 15] = Wgen (W,35));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x650a73548baf63de), \\\n              W[36 & 15] = Wgen (W,36));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x766a0abb3c77b2a8), \\\n              W[37 & 15] = Wgen (W,37));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x81c2c92e47edaee6), \\\n              W[38 & 15] = Wgen (W,38));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x92722c851482353b), \\\n              W[39 & 15] = Wgen (W,39));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xa2bfe8a14cf10364), \\\n              W[40 & 15] = Wgen (W,40));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa81a664bbc423001), \\\n              W[41 & 15] = Wgen (W,41));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xc24b8b70d0f89791), \\\n              W[42 & 15] = Wgen (W,42));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xc76c51a30654be30), \\\n              W[43 & 15] = Wgen (W,43));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xd192e819d6ef5218), \\\n              W[44 & 15] = Wgen (W,44));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd69906245565a910), \\\n              W[45 & 15] = Wgen (W,45));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xf40e35855771202a), \\\n              W[46 & 15] = Wgen (W,46));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x106aa07032bbd1b8), \\\n              W[47 & 15] = Wgen (W,47));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x19a4c116b8d2d0c8), \\\n              W[48 & 15] = Wgen (W,48));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x1e376c085141ab53), \\\n              W[49 & 15] = Wgen (W,49));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x2748774cdf8eeb99), \\\n              W[50 & 15] = Wgen (W,50));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x34b0bcb5e19b48a8), \\\n              W[51 & 15] = Wgen (W,51));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x391c0cb3c5c95a63), \\\n              W[52 & 15] = Wgen (W,52));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4ed8aa4ae3418acb), \\\n              W[53 & 15] = Wgen (W,53));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5b9cca4f7763e373), \\\n              W[54 & 15] = Wgen (W,54));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x682e6ff3d6b2b8a3), \\\n              W[55 & 15] = Wgen (W,55));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x748f82ee5defb2fc), \\\n              W[56 & 15] = Wgen (W,56));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x78a5636f43172f60), \\\n              W[57 & 15] = Wgen (W,57));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x84c87814a1f0ab72), \\\n              W[58 & 15] = Wgen (W,58));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x8cc702081a6439ec), \\\n              W[59 & 15] = Wgen (W,59));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x90befffa23631e28), \\\n              W[60 & 15] = Wgen (W,60));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xa4506cebde82bde9), \\\n              W[61 & 15] = Wgen (W,61));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xbef9a3f7b2c67915), \\\n              W[62 & 15] = Wgen (W,62));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc67178f2e372532b), \\\n              W[63 & 15] = Wgen (W,63));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xca273eceea26619c), \\\n              W[64 & 15] = Wgen (W,64));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xd186b8c721c0c207), \\\n              W[65 & 15] = Wgen (W,65));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xeada7dd6cde0eb1e), \\\n              W[66 & 15] = Wgen (W,66));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xf57d4f7fee6ed178), \\\n              W[67 & 15] = Wgen (W,67));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x06f067aa72176fba), \\\n              W[68 & 15] = Wgen (W,68));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x0a637dc5a2c898a6), \\\n              W[69 & 15] = Wgen (W,69));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x113f9804bef90dae), \\\n              W[70 & 15] = Wgen (W,70));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x1b710b35131c471b), \\\n              W[71 & 15] = Wgen (W,71));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x28db77f523047d84), \\\n              W[72 & 15] = Wgen (W,72));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x32caab7b40c72493), \\\n              W[73 & 15] = Wgen (W,73));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x3c9ebe0a15c9bebc), \\\n              W[74 & 15] = Wgen (W,74));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x431d67c49c100d4c), \\\n              W[75 & 15] = Wgen (W,75));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x4cc5d4becb3e42b6), \\\n              W[76 & 15] = Wgen (W,76));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x597f299cfc657e2a), \\\n              W[77 & 15] = Wgen (W,77));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5fcb6fab3ad6faec), \\\n              W[78 & 15] = Wgen (W,78));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x6c44198c4a475817), \\\n              W[79 & 15] = Wgen (W,79));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 clause 4.2.3 for K values. */\n    static const uint64_t K[80] =\n    { UINT64_C (0x428a2f98d728ae22), UINT64_C (0x7137449123ef65cd),\n      UINT64_C (0xb5c0fbcfec4d3b2f), UINT64_C (0xe9b5dba58189dbbc),\n      UINT64_C (0x3956c25bf348b538), UINT64_C (0x59f111f1b605d019),\n      UINT64_C (0x923f82a4af194f9b), UINT64_C (0xab1c5ed5da6d8118),\n      UINT64_C (0xd807aa98a3030242), UINT64_C (0x12835b0145706fbe),\n      UINT64_C (0x243185be4ee4b28c), UINT64_C (0x550c7dc3d5ffb4e2),\n      UINT64_C (0x72be5d74f27b896f), UINT64_C (0x80deb1fe3b1696b1),\n      UINT64_C (0x9bdc06a725c71235), UINT64_C (0xc19bf174cf692694),\n      UINT64_C (0xe49b69c19ef14ad2), UINT64_C (0xefbe4786384f25e3),\n      UINT64_C (0x0fc19dc68b8cd5b5), UINT64_C (0x240ca1cc77ac9c65),\n      UINT64_C (0x2de92c6f592b0275), UINT64_C (0x4a7484aa6ea6e483),\n      UINT64_C (0x5cb0a9dcbd41fbd4), UINT64_C (0x76f988da831153b5),\n      UINT64_C (0x983e5152ee66dfab), UINT64_C (0xa831c66d2db43210),\n      UINT64_C (0xb00327c898fb213f), UINT64_C (0xbf597fc7beef0ee4),\n      UINT64_C (0xc6e00bf33da88fc2), UINT64_C (0xd5a79147930aa725),\n      UINT64_C (0x06ca6351e003826f), UINT64_C (0x142929670a0e6e70),\n      UINT64_C (0x27b70a8546d22ffc), UINT64_C (0x2e1b21385c26c926),\n      UINT64_C (0x4d2c6dfc5ac42aed), UINT64_C (0x53380d139d95b3df),\n      UINT64_C (0x650a73548baf63de), UINT64_C (0x766a0abb3c77b2a8),\n      UINT64_C (0x81c2c92e47edaee6), UINT64_C (0x92722c851482353b),\n      UINT64_C (0xa2bfe8a14cf10364), UINT64_C (0xa81a664bbc423001),\n      UINT64_C (0xc24b8b70d0f89791), UINT64_C (0xc76c51a30654be30),\n      UINT64_C (0xd192e819d6ef5218), UINT64_C (0xd69906245565a910),\n      UINT64_C (0xf40e35855771202a), UINT64_C (0x106aa07032bbd1b8),\n      UINT64_C (0x19a4c116b8d2d0c8), UINT64_C (0x1e376c085141ab53),\n      UINT64_C (0x2748774cdf8eeb99), UINT64_C (0x34b0bcb5e19b48a8),\n      UINT64_C (0x391c0cb3c5c95a63), UINT64_C (0x4ed8aa4ae3418acb),\n      UINT64_C (0x5b9cca4f7763e373), UINT64_C (0x682e6ff3d6b2b8a3),\n      UINT64_C (0x748f82ee5defb2fc), UINT64_C (0x78a5636f43172f60),\n      UINT64_C (0x84c87814a1f0ab72), UINT64_C (0x8cc702081a6439ec),\n      UINT64_C (0x90befffa23631e28), UINT64_C (0xa4506cebde82bde9),\n      UINT64_C (0xbef9a3f7b2c67915), UINT64_C (0xc67178f2e372532b),\n      UINT64_C (0xca273eceea26619c), UINT64_C (0xd186b8c721c0c207),\n      UINT64_C (0xeada7dd6cde0eb1e), UINT64_C (0xf57d4f7fee6ed178),\n      UINT64_C (0x06f067aa72176fba), UINT64_C (0x0a637dc5a2c898a6),\n      UINT64_C (0x113f9804bef90dae), UINT64_C (0x1b710b35131c471b),\n      UINT64_C (0x28db77f523047d84), UINT64_C (0x32caab7b40c72493),\n      UINT64_C (0x3c9ebe0a15c9bebc), UINT64_C (0x431d67c49c100d4c),\n      UINT64_C (0x4cc5d4becb3e42b6), UINT64_C (0x597f299cfc657e2a),\n      UINT64_C (0x5fcb6fab3ad6faec), UINT64_C (0x6c44198c4a475817)};\n\n    /* One step of SHA-512/256 computation with working variables rotation,\n       see FIPS PUB 180-4 clause 6.4.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP64RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n  uint64_t tmp_h_ = (vH);                                             \\\n  SHA2STEP64((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));    \\\n  (vH) = (vG);                                                        \\\n  (vG) = (vF);                                                        \\\n  (vF) = (vE);                                                        \\\n  (vE) = (vD);                                                        \\\n  (vD) = (vC);                                                        \\\n  (vC) = (vB);                                                        \\\n  (vB) = (vA);                                                        \\\n  (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n    /* During last 64 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 80; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Compute and store the intermediate hash.\n     See FIPS PUB 180-4 clause 6.4.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n...\n_MHD_static_inline void\ncalc_userhash (struct DigestAlgorithm *da,\n               const char *username, const size_t username_len,\n               const char *realm, const size_t realm_len,\n               uint8_t *digest_bin)\n{\n  mhd_assert (NULL != username);\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_calc_hash (da, digest_bin);\n}\n...\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return MHD_DAUTH_WRONG_HEADER;\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3)))\n    return MHD_DAUTH_WRONG_ALGO;\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop)))\n    return MHD_DAUTH_WRONG_QOP;\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  else if (params->userhash && (NULL == params->username.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  else if (params->userhash && (digest_size * 2 > params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  else if (params->userhash && (digest_size * 4 < params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n\n  if (NULL == params->realm.value.str)\n    return MHD_DAUTH_WRONG_REALM;\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len))\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->nc.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n      return MHD_DAUTH_WRONG_HEADER;\n\n    if (NULL == params->cnonce.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->cnonce.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len)\n      return MHD_DAUTH_TOO_LARGE;\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str)\n    return MHD_DAUTH_WRONG_URI;\n  else if (0 == params->uri.value.len)\n    return MHD_DAUTH_WRONG_URI;\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len)\n    return MHD_DAUTH_TOO_LARGE;\n\n  if (NULL == params->nonce.value.str)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (0 == params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n\n  if (NULL == params->response.value.str)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (0 == params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (digest_size * 4 < params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  if (! is_param_equal (&params->realm, realm, realm_len))\n    return MHD_DAUTH_WRONG_REALM;\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      if (! is_param_equal (&params->username, username, username_len))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname)\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      if (0 > res)\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size))\n      return MHD_DAUTH_WRONG_USERNAME;\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci))\n      return MHD_DAUTH_NONCE_STALE;    /* Too large 'nc' value */\n  }\n  else\n    nci = 1; /* Force 'nc' value */\n  /* Got 'nc' digital value */\n\n  /* Get 'nonce' with basic checks */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  if ((NONCE_STD_LEN (digest_size) != unquoted.len) ||\n      (! get_nonce_timestamp (unquoted.str, unquoted.len, &nonce_time)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, invalid nonce format.\\n\"));\n#endif\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (1)\n  {\n    uint64_t t;\n\n    t = MHD_monotonic_msec_counter ();\n    /*\n     * First level vetting for the nonce validity: if the timestamp\n     * attached to the nonce exceeds `nonce_timeout', then the nonce is\n     * stale.\n     */\n    if (TRIM_TO_TIMESTAMP (t - nonce_time) > (nonce_timeout * 1000))\n      return MHD_DAUTH_NONCE_STALE; /* too old */\n  }\n  if (1)\n  {\n    enum MHD_CheckNonceNC_ nonce_nc_check;\n    /*\n     * Checking if that combination of nonce and nc is sound\n     * and not a replay attack attempt. Refuse if nonce was not\n     * generated previously.\n     */\n    nonce_nc_check = check_nonce_nc (connection,\n                                     unquoted.str,\n                                     NONCE_STD_LEN (digest_size),\n                                     nonce_time,\n                                     nci);\n    if (MHD_CHECK_NONCENC_STALE == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. If this happens a lot, you should \"\n                     \"probably increase the size of the nonce array.\\n\"));\n      else\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. This is expected when client \" \\\n                     \"uses RFC2069-compatible mode and makes more than one \" \\\n                     \"request.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_STALE;\n    }\n    else if (MHD_CHECK_NONCENC_WRONG == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Received nonce that was not \"\n                   \"generated by MHD. This may indicate an attack attempt.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_WRONG;\n    }\n    mhd_assert (MHD_CHECK_NONCENC_OK == nonce_nc_check);\n  }\n  /* The nonce was generated by MHD, is not stale and nonce-nc combination was\n     not used before */\n\n  /* ** Build H(A2) and check URI match in the header and in the request ** */\n\n  /* Get 'uri' */\n  mhd_assert (! da->hashing);\n  digest_update_str (da, connection->rq.method);\n  digest_update_with_colon (da);\n#if 0\n  /* TODO: add support for \"auth-int\" */\n  digest_update_str (da, hentity);\n  digest_update_with_colon (da);\n#endif\n  unq_res = get_unquoted_param_copy (&params->uri, tmp1, ptmp2, &tmp2_size,\n                                     &unq_copy);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  digest_update (da, unq_copy.str, unq_copy.len);\n  /* The next check will modify copied URI string */\n  if (! check_uri_match (connection, unq_copy.str, unq_copy.len))\n    return MHD_DAUTH_WRONG_URI;\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  /* Skip digest calculation external error check, the next one checks both */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A2) */\n\n  /* ** Build H(A1) ** */\n  if (NULL == userdigest)\n  {\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calc_userdigest (da,\n                     username, username_len,\n                     realm, realm_len,\n                     password,\n                     hash1_bin);\n  }\n  /* TODO: support '-sess' versions */\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A1) */\n\n  /* **  Check 'response' ** */\n\n  mhd_assert (! da->hashing);\n  digest_reset (da);\n  /* Update digest with H(A1) */\n  mhd_assert (sizeof (tmp1) >= (digest_size * 2));\n  if (NULL == userdigest)\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n  else\n    MHD_bin_to_hex (userdigest, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A1) is not needed anymore, reuse the buffer.\n   * Use hash1_bin for the client's 'response' decoded to binary form. */\n  unq_res = get_unquoted_param (&params->response, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  if (digest_size != MHD_hex_to_bin (unquoted.str, unquoted.len, hash1_bin))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  /* Update digest with 'nonce' text value */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    /* Update digest with 'nc' text value */\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'cnonce' value */\n    unq_res = get_unquoted_param (&params->cnonce, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'qop' value */\n    unq_res = get_unquoted_param (&params->qop_raw, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n  }\n  /* Update digest with H(A2) */\n  MHD_bin_to_hex (hash2_bin, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A2) is not needed anymore, reuse the buffer.\n   * Use hash2_bin for the calculated response in binary form */\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 != memcmp (hash1_bin, hash2_bin, digest_size))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  if (MHD_DAUTH_BIND_NONCE_NONE != daemon->dauth_bind_type)\n  {\n    mhd_assert (sizeof(tmp1) >= (NONCE_STD_LEN (digest_size) + 1));\n    /* It was already checked that 'nonce' (including timestamp) was generated\n       by MHD. */\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calculate_nonce (nonce_time,\n                     connection->rq.http_mthd,\n                     connection->rq.method,\n                     daemon->digest_auth_random,\n                     daemon->digest_auth_rand_size,\n                     connection->addr,\n                     (size_t) connection->addr_len,\n                     connection->rq.url,\n                     connection->rq.url_len,\n                     connection->rq.headers_received,\n                     realm,\n                     realm_len,\n                     daemon->dauth_bind_type,\n                     da,\n                     tmp1);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (! is_param_equal (&params->nonce, tmp1,\n                          NONCE_STD_LEN (digest_size)))\n      return MHD_DAUTH_NONCE_OTHER_COND;\n    /* The 'nonce' was generated in the same conditions */\n  }\n\n  return MHD_DAUTH_OK;\n}\n...\n#define MHD_MD5_SUPPORT 1\n...\n#define MHD_SHA256_SUPPORT 1\n...\n#define MHD_SHA512_256_SUPPORT 1\n...\n#define MHD_MD5_HAS_FINISH 1\n...\n#define MHD_SHA256_HAS_FINISH 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ndigest_update (da, \"\", 1);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The string literal \"\" is an array of one char (the terminating NUL), so passing size 1 reads only that byte. A possible violation would be if the caller passed a larger size than the object provides (for example digest_update(da, \"\", 2)) or if digest_update internally ignored the provided length and used a string.h routine that assumes a longer buffer, which could then read past the object bounds."
}