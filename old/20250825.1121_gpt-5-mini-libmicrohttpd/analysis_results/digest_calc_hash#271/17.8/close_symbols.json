{
  "user_message": "Target function code is:\n```c\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}, 'MHD_MD5_finish': {'callees': ['md5_transform', '_MHD_PUT_64BIT_LE_SAFE'], 'callers': ['digest_calc_hash']}, 'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'calculate_nonce': {'callees': ['MHD_bin_to_hex', 'digest_get_size', 'digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['calculate_add_nonce', 'digest_auth_check_all_inner']}, 'calc_userdigest': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userdigest', 'digest_auth_check_all_inner']}, 'calc_userhash': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct DigestAlgorithm",
    "mhd_assert",
    "MHD_MD5_finish",
    "MHD_MD5_finish_reset",
    "MHD_SHA256_finish",
    "MHD_SHA256_finish_reset",
    "MHD_SHA512_256_finish",
    "MHD_MD5_SUPPORT",
    "MHD_MD5_HAS_FINISH",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA256_HAS_FINISH",
    "MHD_SHA512_256_SUPPORT",
    "_DEBUG"
  ],
  "explanation": "For deciding whether digest_calc_hash modifies its parameter variables (violating the MISRA rule that a function parameter shall not be modified):\n\n- struct DigestAlgorithm: needed to confirm that 'da' is a pointer, to inspect its fields (ready_for_hashing, hashing, ctx) and to determine whether any accesses are to the pointer itself or to the object it points to.\n\n- mhd_assert: the macro is invoked using 'da' members; its definition must be inspected to ensure it does not expand to code that assigns to the local parameters (e.g. uses the identifier 'da' or 'digest' in an assignment), which would be a direct violation.\n\n- MHD_MD5_finish, MHD_MD5_finish_reset, MHD_SHA256_finish, MHD_SHA256_finish_reset, MHD_SHA512_256_finish: these callees may be implemented as macros or inline functions; if any are macros they could expand to code that assigns to the identifier 'digest' (the parameter variable) rather than only writing to *digest. Their definitions/prototypes must be checked to ensure they do not reassign the caller's parameter variable.\n\n- MHD_MD5_SUPPORT, MHD_MD5_HAS_FINISH, MHD_SHA256_SUPPORT, MHD_SHA256_HAS_FINISH, MHD_SHA512_256_SUPPORT: these compile-time configuration macros determine which branches of the function are compiled. The analyzer must know their setting (or inspect all variants) to see which callees/macros are actually used and whether any compiled branch contains code that assigns to the parameter variables.\n\n- _DEBUG: controls compilation of assignments to fields of *da (e.g. da->ready_for_hashing, da->hashing). Although modifying the object pointed to is allowed by the MISRA rule, the presence/absence of these assignments affects whether only the pointee is modified (permitted) and whether any debug macros expand differently; so the _DEBUG definition must be known.\n\nTogether these symbols let the next agent determine whether any expansion or compiled branch contains an assignment to the parameter identifiers 'da' or 'digest' (which would violate the MISRA rule), as opposed to permitted modifications of the objects they point to."
}