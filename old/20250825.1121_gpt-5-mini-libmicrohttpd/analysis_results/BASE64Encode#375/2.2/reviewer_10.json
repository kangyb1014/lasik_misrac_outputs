{
  "user_message": "An agent A claimed that the following BASE64Encode code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of BASE64Encode.\n```c\nstatic ssize_t\nBASE64Encode (const void *in, size_t len, char **output)\n{\n#define FILLCHAR '='\n  const char *cvt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    \"abcdefghijklmnopqrstuvwxyz\"\n                    \"0123456789+/\";\n  const char *data = in;\n  char *opt;\n  ssize_t ret;\n  size_t i;\n  char c;\n  ret = 0;\n\n  opt = malloc (2 + (len * 4 / 3) + 8);\n  if (NULL == opt)\n  {\n    return -1;\n  }\n  for (i = 0; i < len; ++i)\n  {\n    c = (data[i] >> 2) & 0x3F;\n    opt[ret++] = cvt[(int) c];\n    c = (data[i] << 4) & 0x3F;\n    if (++i < len)\n    {\n      c = (char) (c | ((data[i] >> 4) & 0x0F));\n    }\n    opt[ret++] = cvt[(int) c];\n    if (i < len)\n    {\n      c = (char) (c | ((data[i] << 2) & 0x3F));\n      if (++i < len)\n      {\n        c = (char) (c | ((data[i] >> 6) & 0x03));\n      }\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      ++i;\n      opt[ret++] = FILLCHAR;\n    }\n    if (i < len)\n    {\n      c = data[i] & 0x3F;\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      opt[ret++] = FILLCHAR;\n    }\n  }\n  *output = opt;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement '(void) upload_data_size;' is an expression-statement that performs no observable action (a no-op). It is executed but has no side effects, so removing it would not change program behaviour. Therefore it constitutes dead code under MISRA C 2023 Rule 2.2. (The same applies to the other '(void) <param>;' lines used to silence compiler warnings.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function BASE64Encode:\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Reset (struct SHA1Context *context)\n{\n  if (! context)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  context->length_low = 0;\n  context->length_high = 0;\n  context->message_block_index = 0;\n  context->intermediate_hash[0] = 0x67452301;\n  context->intermediate_hash[1] = 0xEFCDAB89;\n  context->intermediate_hash[2] = 0x98BADCFE;\n  context->intermediate_hash[3] = 0x10325476;\n  context->intermediate_hash[4] = 0xC3D2E1F0;\n  context->computed = 0;\n  context->corrupted = 0;\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Input (struct SHA1Context *context, const unsigned char *message_array,\n           unsigned length)\n{\n  if (! length)\n  {\n    return SHA1_RESULT_SUCCESS;\n  }\n  if (! context || ! message_array)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->computed)\n  {\n    context->corrupted = 1;\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  while (length-- && ! context->corrupted)\n  {\n    context->message_block[context->message_block_index++]\n      = (*message_array & 0xFF);\n    context->length_low += 8;\n    if (context->length_low == 0)\n    {\n      context->length_high++;\n      if (context->length_high == 0)\n      {\n        context->corrupted = 1;\n      }\n    }\n    if (context->message_block_index == 64)\n    {\n      SHA1ProcessMessageBlock (context);\n    }\n    message_array++;\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Result (struct SHA1Context *context, unsigned char\n            Message_Digest[SHA1HashSize])\n{\n  int i;\n\n  if (! context || ! Message_Digest)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (! context->computed)\n  {\n    SHA1PadMessage (context);\n    for (i = 0; i < 64; ++i)\n    {\n      context->message_block[i] = 0;\n    }\n    context->length_low = 0;\n    context->length_high = 0;\n    context->computed = 1;\n  }\n  for (i = 0; i < SHA1HashSize; ++i)\n  {\n    Message_Digest[i]\n      = (unsigned char) (context->intermediate_hash[i >> 2]\n                         >> 8 * (3 - (i & 0x03)));\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The statements like (void) upload_data_size; (and the other (void) <param>; lines) are expression-statements that do not produce any observable side effect at runtime. They are reachable and executed on each call of ahc_cb, and removing them would not change the program\u2019s observable behaviour, therefore they meet the definition of dead code in MISRA C 2023 Rule 2.2. (They are not initializations, nor unreachable code.) Note: these casts are commonly used to suppress compiler warnings about unused parameters, but under a strict reading of Rule 2.2 they are still dead code; to comply you should remove/omit unused parameters, use a permitted annotation mechanism or a project-accepted pattern for indicating intentional unused parameters that is allowed by your coding standard."
}