{
  "user_message": "Target function code is:\n```c\nint\nMHD_add_to_fd_set_ (MHD_socket fd,\n                    fd_set *set,\n                    MHD_socket *max_fd,\n                    int fd_setsize)\n{\n  if ( (NULL == set) ||\n       (MHD_INVALID_SOCKET == fd) )\n    return 0;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (! MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (fd,\n                                         set,\n                                         fd_setsize))\n    return 0;\n  MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_ (fd,\n                                     set,\n                                     fd_setsize);\n  if ( (NULL != max_fd) &&\n       ( (fd > *max_fd) ||\n         (MHD_INVALID_SOCKET == *max_fd) ) )\n    *max_fd = fd;\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_SCKT_FD_FITS_FDSET_SETSIZE_",
    "MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_",
    "FD_SETSIZE",
    "fd_set (type / implementation)",
    "FD_SET / FD_CLR / FD_ZERO macros (platform implementation)",
    "MHD_socket (typedef)",
    "MHD_INVALID_SOCKET",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "any helper macros/functions used by the MHD_SCKT_* macros (e.g. fd-to-word/bit helpers)"
  ],
  "explanation": "Explain why each symbol is required:\n\n- MHD_SCKT_FD_FITS_FDSET_SETSIZE_: This check is called before any modification of the fd_set. Its definition must be inspected to see how it computes fit (indexing, masking, pointer arithmetic) and whether it calls or expands to any string.h functions (memcpy/memset/memcmp/strlen/etc.) or performs out-of-bounds reads. Without its body you cannot determine if the guard is sufficient or if it itself performs unsafe string operations.\n\n- MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_: This macro/function actually modifies the fd_set. You must examine its implementation to ensure it does not invoke any string.h functions that could write/read beyond the fd_set buffer (for example via mem* or by computing an incorrect offset). It also must be verified to use the same indexing logic as the fit-check.\n\n- FD_SETSIZE: The numeric limit determining fd_set capacity. The code uses FD_SETSIZE (and possibly overrides fd_setsize). To prove there is no out-of-bounds access you need the value and semantics of FD_SETSIZE on the target platform; some implementations and conditional compilation paths depend on it.\n\n- fd_set (type / implementation): The internal layout of fd_set (bit-field, array of longs/ints, size) is required to reason about whether operations on it access valid memory and whether any mem* operations would be bounded correctly. Platform-specific fd_set implementations can differ and some implementations of FD_SET/FD_ZERO might use memset.\n\n- FD_SET / FD_CLR / FD_ZERO macros (platform implementation): Many projects either use the standard FD_* macros or wrap them. Their implementations may use bit-twiddling or call memset/memcpy. You must inspect them to ensure they do not call string.h functions that could operate beyond the fd_set bounds.\n\n- MHD_socket (typedef): The underlying type (int, SOCKET, unsigned) affects range checks and comparisons against MHD_INVALID_SOCKET and max_fd. Knowing its range is necessary to determine whether arithmetic or comparisons could produce values that lead to out-of-bounds indexing of fd_set or to mistaken use of string functions on other types.\n\n- MHD_INVALID_SOCKET: The sentinel value is used in comparisons that affect whether max_fd is updated. Its exact value is needed to reason about branch behavior and to ensure no invalid socket value can cause unsafe accesses in the fd_set helpers.\n\n- HAS_FD_SETSIZE_OVERRIDABLE (configuration macro): This compile-time configuration changes whether fd_setsize is overridden with FD_SETSIZE. The chosen path affects which size is passed to the MHD_SCKT_* helpers and therefore whether accesses can exceed the actual fd_set capacity. You must check both branches (defined and undefined) to be sure no string.h functions would be invoked out-of-bounds.\n\n- Any helper macros/functions used by the MHD_SCKT_* macros (e.g. fd-to-word/bit helpers): The MHD_SCKT_* macros often rely on lower-level helpers (compute word index, bit mask, byte offset). Those helpers must be examined for pointer arithmetic, indexing, or calls to memcpy/memset that could violate bounds. If the MHD_SCKT_* definitions reference additional symbols, include and inspect them as well.\n\nOverall: the target function itself does not call string.h routines, but the correctness and safety (with respect to <string.h> functions) depend entirely on the implementations of the MHD_SCKT_* helpers, the fd_set layout and FD_* macros, FD_SETSIZE, and platform/configuration macros. Inspecting those symbols is necessary to determine any possible out-of-bounds string.h usage."
}