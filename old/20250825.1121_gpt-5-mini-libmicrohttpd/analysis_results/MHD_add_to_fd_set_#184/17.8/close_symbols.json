{
  "user_message": "Target function code is:\n```c\nint\nMHD_add_to_fd_set_ (MHD_socket fd,\n                    fd_set *set,\n                    MHD_socket *max_fd,\n                    int fd_setsize)\n{\n  if ( (NULL == set) ||\n       (MHD_INVALID_SOCKET == fd) )\n    return 0;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (! MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (fd,\n                                         set,\n                                         fd_setsize))\n    return 0;\n  MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_ (fd,\n                                     set,\n                                     fd_setsize);\n  if ( (NULL != max_fd) &&\n       ( (fd > *max_fd) ||\n         (MHD_INVALID_SOCKET == *max_fd) ) )\n    *max_fd = fd;\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "FD_SETSIZE",
    "MHD_SCKT_FD_FITS_FDSET_SETSIZE_",
    "MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_",
    "MHD_INVALID_SOCKET",
    "FD_SET",
    "fd_set (type)"
  ],
  "explanation": "- HAS_FD_SETSIZE_OVERRIDABLE: conditional macro that controls whether the assignment to the parameter fd_setsize (fd_setsize = (int) FD_SETSIZE;) is compiled. If defined, the assignment is omitted and the potential parameter modification may not occur.\\n- FD_SETSIZE: used on the right-hand side of the assignment to fd_setsize; knowing its definition is needed to understand the assignment expression and whether it may expand to something with side effects.\\n- MHD_SCKT_FD_FITS_FDSET_SETSIZE_: macro/function called with fd_setsize: its definition may itself modify the fd_setsize token (if a macro) or have side effects that affect whether a parameter is modified. To prove compliance with the MISRA rule you must inspect whether this callee/macro modifies any parameter identifiers.\\n- MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_: same reason as above: this macro/function is invoked with the local parameter identifiers (set, fd_setsize). If it is a macro it could expand into code that assigns to those identifiers (which would be a modification of a function parameter). Its definition is required to determine whether the function parameter itself is changed.\\n- MHD_INVALID_SOCKET: constant used in comparisons; include its definition to ensure it is a simple constant and not a macro with side effects that could be interpreted as modifying a parameter.\\n- FD_SET and fd_set (type): the add-to-fdset macro likely uses FD_SET/fd_set internals. Inspecting these macros/types ensures that only the object pointed to by set is modified (allowed) and that the pointer parameter 'set' itself is not reassigned by macro expansion."
}