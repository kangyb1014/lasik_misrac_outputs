{
  "user_message": "Target function code is:\n```c\nint\nMHD_add_to_fd_set_ (MHD_socket fd,\n                    fd_set *set,\n                    MHD_socket *max_fd,\n                    int fd_setsize)\n{\n  if ( (NULL == set) ||\n       (MHD_INVALID_SOCKET == fd) )\n    return 0;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (! MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (fd,\n                                         set,\n                                         fd_setsize))\n    return 0;\n  MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_ (fd,\n                                     set,\n                                     fd_setsize);\n  if ( (NULL != max_fd) &&\n       ( (fd > *max_fd) ||\n         (MHD_INVALID_SOCKET == *max_fd) ) )\n    *max_fd = fd;\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_INVALID_SOCKET",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "FD_SETSIZE",
    "MHD_SCKT_FD_FITS_FDSET_SETSIZE_",
    "MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_",
    "MHD_socket (typedef)",
    "fd_set (type)",
    "NULL"
  ],
  "explanation": "Explain why each symbol is required to determine whether the controlling expressions are invariant:\n\n- MHD_INVALID_SOCKET\n  - The if conditions compare fd and *max_fd against MHD_INVALID_SOCKET. If this macro is a compile-time constant (or evaluates to some constant expression), it impacts whether those comparisons are invariant. Its definition/value is needed to decide if the controlling expressions depend on runtime values or only on constants.\n\n- HAS_FD_SETSIZE_OVERRIDABLE\n  - Controls the #ifndef branch that assigns fd_setsize = (int) FD_SETSIZE. Whether this macro is defined changes whether fd_setsize is forcibly set to a compile-time constant inside the function (which could make later expressions invariant). You must know whether this macro is defined at compile time.\n\n- FD_SETSIZE\n  - Used (under the #ifndef) to overwrite fd_setsize with a compile-time constant. The actual value and whether it is a compile-time constant affects whether subsequent expressions that use fd_setsize can be invariant.\n\n- MHD_SCKT_FD_FITS_FDSET_SETSIZE_\n  - This macro/function is the controlling expression in the second if (! MHD_SCKT_FD_FITS_FDSET_SETSIZE_(...)). Its definition determines whether the expression depends on the runtime parameters (fd, set, fd_setsize) or expands to a constant expression; therefore its body/expansion is required to assess invariance.\n\n- MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_\n  - Although not a controlling expression, its definition may share macros/logic with MHD_SCKT_FD_FITS_FDSET_SETSIZE_ or rely on the same fd_setsize/FD_SETSIZE semantics. Knowing its definition helps confirm whether any macros used in the controlling expression are constant or parameter-dependent.\n\n- MHD_socket (typedef)\n  - The type/representation of fd and *max_fd can affect comparisons (signed/unsigned, special sentinel values). Knowing MHD_socket typedef is required to determine if comparisons like (MHD_INVALID_SOCKET == fd) or (fd > *max_fd) are meaningful runtime checks or collapse to invariant results.\n\n- fd_set (type)\n  - Provided to understand whether any macros/functions operating on fd_set (in the called macros) are implemented as compile-time constructs. Also needed to reason about whether set is ever NULL/constant; helps assess dependence of MHD_SCKT_FD_FITS_FDSET_SETSIZE_ on runtime state.\n\n- NULL\n  - The code compares pointers against NULL. While NULL is normally a compile-time macro, confirming its definition/representation (0, ((void*)0), etc.) is needed to ensure pointer comparisons are not trivially invariant in the given build/configuration.\n\nIn summary: to decide whether any of the if controlling expressions are invariant you must inspect the macro definitions and type aliases listed above (especially MHD_INVALID_SOCKET, HAS_FD_SETSIZE_OVERRIDABLE, FD_SETSIZE, and MHD_SCKT_FD_FITS_FDSET_SETSIZE_) because they determine whether the comparisons depend on runtime values or reduce to compile-time constants."
}