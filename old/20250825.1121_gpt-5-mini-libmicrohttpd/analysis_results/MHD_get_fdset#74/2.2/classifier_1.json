{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_fdset:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset (struct MHD_Daemon *daemon,\n               fd_set *read_fd_set,\n               fd_set *write_fd_set,\n               fd_set *except_fd_set,\n               MHD_socket *max_fd)\n{\n  return MHD_get_fdset2 (daemon,\n                         read_fd_set,\n                         write_fd_set,\n                         except_fd_set,\n                         max_fd,\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n                         daemon->fdset_size_set_by_app ?\n                         ((unsigned int) daemon->fdset_size) :\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         );\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_get_fdset:\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset2 (struct MHD_Daemon *daemon,\n                fd_set *read_fd_set,\n                fd_set *write_fd_set,\n                fd_set *except_fd_set,\n                MHD_socket *max_fd,\n                unsigned int fd_setsize)\n{\n  if ( (NULL == daemon) ||\n       (NULL == read_fd_set) ||\n       (NULL == write_fd_set) ||\n       MHD_D_IS_USING_THREADS_ (daemon) ||\n       MHD_D_IS_USING_POLL_ (daemon))\n    return MHD_NO;\n\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_get_fdset2() called with except_fd_set \"\n                 \"set to NULL. Such behavior is unsupported.\\n\"));\n  }\n#endif\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_get_fdset2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (daemon->shutdown)\n      return MHD_YES;\n\n    /* we're in epoll mode, use the epoll FD as a stand-in for\n       the entire event set */\n\n    return MHD_add_to_fd_set_ (daemon->epoll_fd,\n                               read_fd_set,\n                               max_fd,\n                               (int) fd_setsize) ? MHD_YES : MHD_NO;\n  }\n#endif\n\n  return internal_get_fdset2 (daemon,\n                              read_fd_set,\n                              write_fd_set,\n                              except_fd_set,\n                              max_fd,\n                              (int) fd_setsize);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset (struct MHD_Daemon *daemon,\n               fd_set *read_fd_set,\n               fd_set *write_fd_set,\n               fd_set *except_fd_set,\n               MHD_socket *max_fd)\n{\n  return MHD_get_fdset2 (daemon,\n                         read_fd_set,\n                         write_fd_set,\n                         except_fd_set,\n                         max_fd,\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n                         daemon->fdset_size_set_by_app ?\n                         ((unsigned int) daemon->fdset_size) :\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         ((unsigned int) _MHD_SYS_DEFAULT_FD_SETSIZE)\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n                         );\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: MHD_get_fdset is a thin, active wrapper that forwards its arguments (including a compile-time selected fd_setsize argument) to MHD_get_fdset2. Removing the wrapper would change the public API and thus program behaviour for callers, so the function is not dead code. The preprocessor-conditioned argument selection is compile-time configuration, and there are no executed statements whose removal would not affect behaviour (unreachable branches would not be considered dead code per the rule)."
}