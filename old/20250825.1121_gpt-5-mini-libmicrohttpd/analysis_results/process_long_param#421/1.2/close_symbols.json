{
  "user_message": "Target function code is:\n```c\nstatic enum PerfRepl_param_result\nprocess_long_param (const char *param, const char *next_param)\n{\n  const size_t param_len = strlen (param);\n\n  if ((MHD_STATICSTR_LEN_ (\"all-cpus\") == param_len) &&\n      (0 == memcmp (param, \"all-cpus\", MHD_STATICSTR_LEN_ (\"all-cpus\"))))\n    return process_param__all_cpus (\"--all-cpus\");\n  else if ((MHD_STATICSTR_LEN_ (\"threads\") <= param_len) &&\n           (0 == memcmp (param, \"threads\", MHD_STATICSTR_LEN_ (\"threads\"))))\n    return process_param__threads (\"--threads\",\n                                   param + MHD_STATICSTR_LEN_ (\"threads\"),\n                                   next_param);\n  else if ((MHD_STATICSTR_LEN_ (\"thread-per-conn\") == param_len) &&\n           (0 == memcmp (param, \"thread-per-conn\",\n                         MHD_STATICSTR_LEN_ (\"thread-per-conn\"))))\n    return process_param__thread_per_conn (\"--thread-per-conn\");\n  else if ((MHD_STATICSTR_LEN_ (\"epoll\") == param_len) &&\n           (0 == memcmp (param, \"epoll\", MHD_STATICSTR_LEN_ (\"epoll\"))))\n    return process_param__epoll (\"--epoll\");\n  else if ((MHD_STATICSTR_LEN_ (\"poll\") == param_len) &&\n           (0 == memcmp (param, \"poll\", MHD_STATICSTR_LEN_ (\"poll\"))))\n    return process_param__poll (\"--poll\");\n  else if ((MHD_STATICSTR_LEN_ (\"select\") == param_len) &&\n           (0 == memcmp (param, \"select\", MHD_STATICSTR_LEN_ (\"select\"))))\n    return process_param__select (\"--select\");\n  else if ((MHD_STATICSTR_LEN_ (\"empty\") == param_len) &&\n           (0 == memcmp (param, \"empty\", MHD_STATICSTR_LEN_ (\"empty\"))))\n    return process_param__empty (\"--empty\");\n  else if ((MHD_STATICSTR_LEN_ (\"tiny\") == param_len) &&\n           (0 == memcmp (param, \"tiny\", MHD_STATICSTR_LEN_ (\"tiny\"))))\n    return process_param__tiny (\"--tiny\");\n  else if ((MHD_STATICSTR_LEN_ (\"medium\") == param_len) &&\n           (0 == memcmp (param, \"medium\", MHD_STATICSTR_LEN_ (\"medium\"))))\n    return process_param__medium (\"--medium\");\n  else if ((MHD_STATICSTR_LEN_ (\"large\") == param_len) &&\n           (0 == memcmp (param, \"large\", MHD_STATICSTR_LEN_ (\"large\"))))\n    return process_param__large (\"--large\");\n  else if ((MHD_STATICSTR_LEN_ (\"shared\") == param_len) &&\n           (0 == memcmp (param, \"shared\", MHD_STATICSTR_LEN_ (\"shared\"))))\n    return process_param__shared (\"--shared\");\n  else if ((MHD_STATICSTR_LEN_ (\"single\") == param_len) &&\n           (0 == memcmp (param, \"single\", MHD_STATICSTR_LEN_ (\"single\"))))\n    return process_param__single (\"--single\");\n  else if ((MHD_STATICSTR_LEN_ (\"unique\") == param_len) &&\n           (0 == memcmp (param, \"unique\", MHD_STATICSTR_LEN_ (\"unique\"))))\n    return process_param__unique (\"--unique\");\n  else if ((MHD_STATICSTR_LEN_ (\"connections\") <= param_len) &&\n           (0 == memcmp (param, \"connections\",\n                         MHD_STATICSTR_LEN_ (\"connections\"))))\n    return process_param__connections (\"--connections\",\n                                       param\n                                       + MHD_STATICSTR_LEN_ (\"connections\"),\n                                       next_param);\n  else if ((MHD_STATICSTR_LEN_ (\"timeout\") <= param_len) &&\n           (0 == memcmp (param, \"timeout\",\n                         MHD_STATICSTR_LEN_ (\"timeout\"))))\n    return process_param__timeout (\"--timeout\",\n                                   param + MHD_STATICSTR_LEN_ (\"timeout\"),\n                                   next_param);\n  else if ((MHD_STATICSTR_LEN_ (\"date-header\") == param_len) &&\n           (0 == memcmp (param, \"date-header\",\n                         MHD_STATICSTR_LEN_ (\"date-header\"))))\n    return process_param__date_header (\"--date-header\");\n  else if ((MHD_STATICSTR_LEN_ (\"help\") == param_len) &&\n           (0 == memcmp (param, \"help\", MHD_STATICSTR_LEN_ (\"help\"))))\n    return process_param__help (\"--help\");\n  else if ((MHD_STATICSTR_LEN_ (\"version\") == param_len) &&\n           (0 == memcmp (param, \"version\", MHD_STATICSTR_LEN_ (\"version\"))))\n    return process_param__version (\"--version\");\n\n  fprintf (stderr, \"Unrecognised parameter: --%s.\\n\", param);\n  return PERF_RPL_PARAM_ERROR;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'process_long_param': {'callees': ['process_param__all_cpus', 'process_param__threads', 'process_param__thread_per_conn', 'process_param__epoll', 'process_param__poll', 'process_param__select', 'process_param__empty', 'process_param__tiny', 'process_param__medium', 'process_param__large', 'process_param__shared', 'process_param__single', 'process_param__unique', 'process_param__connections', 'process_param__timeout', 'process_param__date_header', 'process_param__help', 'process_param__version'], 'callers': ['process_params']}, 'process_param__all_cpus': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__threads': {'callees': ['get_param_value'], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__thread_per_conn': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__epoll': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__poll': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__select': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__empty': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__tiny': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__medium': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__large': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__shared': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__single': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__unique': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__connections': {'callees': ['get_param_value'], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__timeout': {'callees': ['get_param_value'], 'callers': ['process_short_param', 'process_long_param']}, 'process_param__date_header': {'callees': [], 'callers': ['process_long_param']}, 'process_param__help': {'callees': [], 'callers': ['process_long_param']}, 'process_param__version': {'callees': [], 'callers': ['process_short_param', 'process_long_param']}, 'process_params': {'callees': ['process_long_param', 'process_short_params_str', 'mhd_tool_str_to_uint'], 'callers': ['main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_STATICSTR_LEN_",
    "enum PerfRepl_param_result",
    "PERF_RPL_PARAM_ERROR",
    "process_param__all_cpus",
    "process_param__threads",
    "process_param__thread_per_conn",
    "process_param__epoll",
    "process_param__poll",
    "process_param__select",
    "process_param__empty",
    "process_param__tiny",
    "process_param__medium",
    "process_param__large",
    "process_param__shared",
    "process_param__single",
    "process_param__unique",
    "process_param__connections",
    "process_param__timeout",
    "process_param__date_header",
    "process_param__help",
    "process_param__version",
    "strlen",
    "memcmp",
    "fprintf",
    "stderr",
    "size_t"
  ],
  "explanation": "- MHD_STATICSTR_LEN_: This macro is used repeatedly to compute literal lengths. Its definition must be inspected to ensure it does not use compiler extensions (e.g. statement-expressions ({...}), typeof, nonstandard builtins, or GCC/Clang-specific attributes).\n- enum PerfRepl_param_result: The function return type; its declaration/definition is needed to check whether any non\u2011standard extensions (attributes, packed enums, explicit underlying-type extensions) are used.\n- PERF_RPL_PARAM_ERROR: The returned error constant\u2014its definition may be a macro or enum expression that could use extensions (casts, GNU extensions). Verify it is standard C.\n- process_param__all_cpus, process_param__threads, process_param__thread_per_conn, process_param__epoll, process_param__poll, process_param__select, process_param__empty, process_param__tiny, process_param__medium, process_param__large, process_param__shared, process_param__single, process_param__unique, process_param__connections, process_param__timeout, process_param__date_header, process_param__help, process_param__version: The prototypes/definitions of all called functions must be checked for compiler extensions in their declarations or definitions (e.g. function attributes like __attribute__, Microsoft declspec, inline asm, nonstandard calling conventions, GCC variadic macros used in their headers, or use of language extensions in their parameter types).\n- strlen, memcmp, fprintf, stderr: These standard library symbols appear in the function. While normally standard, their declarations (in included headers) sometimes contain compiler-specific attributes (e.g. __attribute__((format)) or other extensions). Inspecting the actual declarations used by the build (stdio.h/string.h) ensures no forbidden extensions are being pulled into this translation unit in a way that affects compliance analysis.\n- size_t: The typedef for size_t should be confirmed from the included headers/implementation to ensure no nonstandard type aliases or extensions are used.\n\nIn short: inspect the macro and all called-function prototypes/definitions and the relevant standard headers so you can detect any use of compiler-specific language extensions (attributes, builtins, statement-expressions, typeof, asm, declspec, etc.) that would violate the MISRA rule."
}