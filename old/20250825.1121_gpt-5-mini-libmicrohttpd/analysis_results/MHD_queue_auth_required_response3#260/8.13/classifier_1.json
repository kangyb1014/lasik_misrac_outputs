{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_queue_auth_required_response3:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_required_response3 (struct MHD_Connection *connection,\n                                   const char *realm,\n                                   const char *opaque,\n                                   const char *domain,\n                                   struct MHD_Response *response,\n                                   int signal_stale,\n                                   enum MHD_DigestAuthMultiQOP mqop,\n                                   enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                   int userhash_support,\n                                   int prefer_utf8)\n{\n  struct DigestAlgorithm da;\n  char *buf_ptr;\n  enum MHD_Result ret;\n\n  buf_ptr = NULL;\n  digest_setup_zero (&da);\n  ret = queue_auth_required_response3_inner (connection,\n                                             realm,\n                                             opaque,\n                                             domain,\n                                             response,\n                                             signal_stale,\n                                             mqop,\n                                             malgo3,\n                                             userhash_support,\n                                             prefer_utf8,\n                                             &buf_ptr,\n                                             &da);\n  digest_deinit (&da);\n  if (NULL != buf_ptr)\n    free (buf_ptr);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_queue_auth_required_response3:\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo; /**< Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  if (0 == (((unsigned int) malgo3) & MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Only non-'session' algorithms are supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  malgo3 =\n    (enum MHD_DigestAuthMultiAlgo3)\n    (malgo3\n     & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    if (0 == (((unsigned int) malgo3)\n              & (MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_BASE_ALGO_SHA512_256\n                 | MHD_DIGEST_BASE_ALGO_SHA512_256)))\n      MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n    else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"No requested algorithm is supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC (_ (\"Wrong 'mqop' value, API violation\"));\n\n  mqop = (enum MHD_DigestAuthMultiQOP)\n         (mqop\n          & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n#ifdef HAVE_MESSAGES\n    if ((0 != userhash_support) || (0 != prefer_utf8))\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'userhash' and 'charset' ('prefer_utf8') parameters \" \\\n                   \"are not compatible with RFC2069 and ignored.\\n\"));\n    if (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n      MHD_DLOG (connection->daemon,\n                _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                   \"non-standard extension.\\n\"));\n#endif\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The nonce array size is zero.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_realm) + 3; /* 3 for '\", ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < realm_len)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'realm' is too large.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) ||\n      (NULL != memchr (realm, '\\n', realm_len)))\n    return MHD_NO;\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_qop) + 3; /* 3 for '\", ' */\n    buf_size += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_algo) + 2; /* 2 for ', ' */\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_nonce) + 3; /* 3 for '\", ' */\n  buf_size += NONCE_STD_LEN (digest_get_size (da)); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_opaque) + 3; /* 3 for '\", ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) ||\n        (NULL != memchr (opaque, '\\n', opaque_len)))\n      return MHD_NO;\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_domain) + 3; /* 3 for '\", ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) ||\n        (NULL != memchr (domain, '\\n', domain_len)))\n      return MHD_NO;\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += MHD_STATICSTR_LEN_ (str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += MHD_STATICSTR_LEN_ (str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += MHD_STATICSTR_LEN_ (str_stale) + 2; /* 2 for ', ' */\n\n  /* The calculated length is for string ended with \", \". One character will\n   * be used for zero-termination, the last one will not be used. */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE,\n          MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE));\n  p += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm,\n          MHD_STATICSTR_LEN_ (prefix_realm));\n  p += MHD_STATICSTR_LEN_ (prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  if (1)\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < quoted_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'realm' is too large after 'quoting'.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop,\n            MHD_STATICSTR_LEN_ (prefix_qop));\n    p += MHD_STATICSTR_LEN_ (prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_,\n            MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_));\n    p += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    }\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce,\n          MHD_STATICSTR_LEN_ (prefix_nonce));\n  p += MHD_STATICSTR_LEN_ (prefix_nonce);\n  mhd_assert ((buf_size - p) >= (NONCE_STD_LEN (digest_get_size (da))));\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"TLS library reported hash calculation error, nonce could \"\n                   \"not be generated.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Could not register nonce. Client's requests with this \"\n                 \"nonce will be always 'stale'. Probably clients' requests \"\n                 \"are too intensive.\\n\"));\n#endif /* HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning for builds without messages */\n  }\n  p += NONCE_STD_LEN (digest_get_size (da));\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque,\n            MHD_STATICSTR_LEN_ (prefix_opaque));\n    p += MHD_STATICSTR_LEN_ (prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain,\n            MHD_STATICSTR_LEN_ (prefix_domain));\n    p += MHD_STATICSTR_LEN_ (prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset,\n            MHD_STATICSTR_LEN_ (str_charset));\n    p += MHD_STATICSTR_LEN_ (str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash,\n            MHD_STATICSTR_LEN_ (str_userhash));\n    p += MHD_STATICSTR_LEN_ (str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale,\n            MHD_STATICSTR_LEN_ (str_stale));\n    p += MHD_STATICSTR_LEN_ (str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n            MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          MHD_STATICSTR_LEN_ ( \\\n                                            MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to add Digest auth header.\\n\"));\n    }\n#endif /* HAVE_MESSAGES */\n    free (hdr_name);\n  }\n  return MHD_NO;\n}\n...\nstruct DigestAlgorithm\n{\n  /**\n   * A context for the digest algorithm, already initialized to be\n   * useful for @e init, @e update and @e digest.\n   */\n  union DigestCtx ctx;\n\n  /**\n   * The hash calculation algorithm.\n   */\n  enum MHD_DigestBaseAlgo algo;\n\n  /**\n   * Buffer for hex-print of the final digest.\n   */\n#ifdef _DEBUG\n  bool uninitialised; /**< The structure has been not set-up */\n  bool algo_selected; /**< The algorithm has been selected */\n  bool ready_for_hashing; /**< The structure is ready to hash data */\n  bool hashing; /**< Some data has been hashed, but the digest has not finalised yet */\n#endif /* _DEBUG */\n}\n...\n#define digest_setup_zero(da) (void)0\n...\n#define digest_deinit(da) (void)0\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The function already uses const for input string parameters (realm, opaque, domain). The non-const pointer parameters are intentionally non-const because they are modified: response is updated (headers added), da is initialised/used, connection is used in calls that may mutate state, and buf_ptr is an output parameter whose pointee (*buf_ptr) is set/cleared and must point to a mutable buffer. Therefore no opportunity to add const qualifiers without preventing required modifications."
}