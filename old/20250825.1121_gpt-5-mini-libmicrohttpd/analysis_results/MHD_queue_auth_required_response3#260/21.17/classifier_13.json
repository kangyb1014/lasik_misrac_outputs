{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_queue_auth_required_response3:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_required_response3 (struct MHD_Connection *connection,\n                                   const char *realm,\n                                   const char *opaque,\n                                   const char *domain,\n                                   struct MHD_Response *response,\n                                   int signal_stale,\n                                   enum MHD_DigestAuthMultiQOP mqop,\n                                   enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                   int userhash_support,\n                                   int prefer_utf8)\n{\n  struct DigestAlgorithm da;\n  char *buf_ptr;\n  enum MHD_Result ret;\n\n  buf_ptr = NULL;\n  digest_setup_zero (&da);\n  ret = queue_auth_required_response3_inner (connection,\n                                             realm,\n                                             opaque,\n                                             domain,\n                                             response,\n                                             signal_stale,\n                                             mqop,\n                                             malgo3,\n                                             userhash_support,\n                                             prefer_utf8,\n                                             &buf_ptr,\n                                             &da);\n  digest_deinit (&da);\n  if (NULL != buf_ptr)\n    free (buf_ptr);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_queue_auth_required_response3:\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo; /**< Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  if (0 == (((unsigned int) malgo3) & MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Only non-'session' algorithms are supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  malgo3 =\n    (enum MHD_DigestAuthMultiAlgo3)\n    (malgo3\n     & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    if (0 == (((unsigned int) malgo3)\n              & (MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_BASE_ALGO_SHA512_256\n                 | MHD_DIGEST_BASE_ALGO_SHA512_256)))\n      MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n    else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"No requested algorithm is supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC (_ (\"Wrong 'mqop' value, API violation\"));\n\n  mqop = (enum MHD_DigestAuthMultiQOP)\n         (mqop\n          & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n#ifdef HAVE_MESSAGES\n    if ((0 != userhash_support) || (0 != prefer_utf8))\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'userhash' and 'charset' ('prefer_utf8') parameters \" \\\n                   \"are not compatible with RFC2069 and ignored.\\n\"));\n    if (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n      MHD_DLOG (connection->daemon,\n                _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                   \"non-standard extension.\\n\"));\n#endif\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The nonce array size is zero.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_realm) + 3; /* 3 for '\", ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < realm_len)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'realm' is too large.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) ||\n      (NULL != memchr (realm, '\\n', realm_len)))\n    return MHD_NO;\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_qop) + 3; /* 3 for '\", ' */\n    buf_size += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_algo) + 2; /* 2 for ', ' */\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_nonce) + 3; /* 3 for '\", ' */\n  buf_size += NONCE_STD_LEN (digest_get_size (da)); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_opaque) + 3; /* 3 for '\", ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) ||\n        (NULL != memchr (opaque, '\\n', opaque_len)))\n      return MHD_NO;\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_domain) + 3; /* 3 for '\", ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) ||\n        (NULL != memchr (domain, '\\n', domain_len)))\n      return MHD_NO;\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += MHD_STATICSTR_LEN_ (str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += MHD_STATICSTR_LEN_ (str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += MHD_STATICSTR_LEN_ (str_stale) + 2; /* 2 for ', ' */\n\n  /* The calculated length is for string ended with \", \". One character will\n   * be used for zero-termination, the last one will not be used. */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE,\n          MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE));\n  p += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm,\n          MHD_STATICSTR_LEN_ (prefix_realm));\n  p += MHD_STATICSTR_LEN_ (prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  if (1)\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < quoted_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'realm' is too large after 'quoting'.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop,\n            MHD_STATICSTR_LEN_ (prefix_qop));\n    p += MHD_STATICSTR_LEN_ (prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_,\n            MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_));\n    p += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    }\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce,\n          MHD_STATICSTR_LEN_ (prefix_nonce));\n  p += MHD_STATICSTR_LEN_ (prefix_nonce);\n  mhd_assert ((buf_size - p) >= (NONCE_STD_LEN (digest_get_size (da))));\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"TLS library reported hash calculation error, nonce could \"\n                   \"not be generated.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Could not register nonce. Client's requests with this \"\n                 \"nonce will be always 'stale'. Probably clients' requests \"\n                 \"are too intensive.\\n\"));\n#endif /* HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning for builds without messages */\n  }\n  p += NONCE_STD_LEN (digest_get_size (da));\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque,\n            MHD_STATICSTR_LEN_ (prefix_opaque));\n    p += MHD_STATICSTR_LEN_ (prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain,\n            MHD_STATICSTR_LEN_ (prefix_domain));\n    p += MHD_STATICSTR_LEN_ (prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset,\n            MHD_STATICSTR_LEN_ (str_charset));\n    p += MHD_STATICSTR_LEN_ (str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash,\n            MHD_STATICSTR_LEN_ (str_userhash));\n    p += MHD_STATICSTR_LEN_ (str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale,\n            MHD_STATICSTR_LEN_ (str_stale));\n    p += MHD_STATICSTR_LEN_ (str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n            MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          MHD_STATICSTR_LEN_ ( \\\n                                            MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to add Digest auth header.\\n\"));\n    }\n#endif /* HAVE_MESSAGES */\n    free (hdr_name);\n  }\n  return MHD_NO;\n}\n...\n#define digest_setup_zero(da) (void)0\n...\n#define digest_deinit(da) (void)0\n...\nstruct DigestAlgorithm\n{\n  /**\n   * A context for the digest algorithm, already initialized to be\n   * useful for @e init, @e update and @e digest.\n   */\n  union DigestCtx ctx;\n\n  /**\n   * The hash calculation algorithm.\n   */\n  enum MHD_DigestBaseAlgo algo;\n\n  /**\n   * Buffer for hex-print of the final digest.\n   */\n#ifdef _DEBUG\n  bool uninitialised; /**< The structure has been not set-up */\n  bool algo_selected; /**< The algorithm has been selected */\n  bool ready_for_hashing; /**< The structure is ready to hash data */\n  bool hashing; /**< Some data has been hashed, but the digest has not finalised yet */\n#endif /* _DEBUG */\n}\n...\nsize_t\nMHD_str_quote (const char *unquoted,\n               size_t unquoted_len,\n               char *result,\n               size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  r = 0;\n  w = 0;\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (unquoted_len * 2 <= buf_size)\n  {\n    /* Fast loop: the output will fit the buffer with any input string content */\n    while (unquoted_len > r)\n    {\n      const char chr = unquoted[r++];\n      if (('\\\\' == chr) || ('\\\"' == chr))\n        result[w++] = '\\\\'; /* Escape current char */\n      result[w++] = chr;\n    }\n  }\n  else\n  {\n    if (unquoted_len > buf_size)\n      return 0; /* Quick fail: the output buffer is too small */\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n    while (unquoted_len > r)\n    {\n      if (buf_size <= w)\n        return 0; /* The output buffer is too small */\n      else\n      {\n        const char chr = unquoted[r++];\n        if (('\\\\' == chr) || ('\\\"' == chr))\n        {\n          result[w++] = '\\\\'; /* Escape current char */\n          if (buf_size <= w)\n            return 0; /* The output buffer is too small */\n        }\n        result[w++] = chr;\n      }\n    }\n  }\n\n  mhd_assert (w >= r);\n  mhd_assert (w <= r * 2);\n  return w;\n}\n...\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n...\n_MHD_static_inline enum MHD_DigestBaseAlgo\nget_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3)\n{\n  unsigned int base_algo;\n\n  base_algo =\n    ((unsigned int) algo3)\n    & ~((unsigned int)\n        (MHD_DIGEST_AUTH_ALGO3_NON_SESSION\n         | MHD_DIGEST_AUTH_ALGO3_NON_SESSION));\n  return (enum MHD_DigestBaseAlgo) base_algo;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nbuf_size += realm_len * 2;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The line itself (buf_size += realm_len * 2;) does not call any <string.h> function and therefore does not directly violate MISRA C 2023 Rule 21.17. The surrounding code, however, uses strlen(), memchr() and MHD_str_quote() on realm; a violation can occur if the caller passes an invalid realm pointer (NULL) or a non\u2013NUL-terminated string \u2014 strlen()/memchr() would then access beyond the object bounds. Another possible violation scenario is integer overflow: if realm_len is extremely large so that realm_len * 2 (or the accumulated buf_size) wraps and a too-small buffer is allocated, subsequent memcpy/MHD_str_quote writes could exceed the allocated buffer. In normal use (realm != NULL, NUL-terminated, and realm_len bounded by _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) the code is written to allocate sufficient space and so does not violate the rule."
}