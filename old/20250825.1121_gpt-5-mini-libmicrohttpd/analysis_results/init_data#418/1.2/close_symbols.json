{
  "user_message": "Target function code is:\n```c\nstatic int\ninit_data (void)\n{\n  unsigned int i;\n\n  if (tool_params.medium)\n    body_dyn_size = 8U * 1024U;\n  else if (tool_params.large)\n    body_dyn_size = 1024U * 1024U;\n  else\n    body_dyn_size = 0;\n\n  if (! init_response_body_data ())\n    return 25;\n\n  if (tool_params.unique)\n    return 0; /* Responses are generated on-fly */\n\n  if (tool_params.single)\n  {\n    resp_single = create_response_object ();\n    if (NULL == resp_single)\n    {\n      fprintf (stderr, \"Failed to create response.\\n\");\n      return 25;\n    }\n    return 0;\n  }\n\n  /* Use more responses to minimise waiting in threads while the response\n     used by other thread. */\n  if (! tool_params.thread_per_conn)\n    num_resps = 16 * get_num_threads ();\n  else\n    num_resps = 16 * get_cpu_core_count ();\n\n  resps = (struct MHD_Response **)\n          malloc ((sizeof(struct MHD_Response *)) * num_resps);\n  if (NULL == resps)\n  {\n    if (NULL != body_dyn)\n    {\n      free (body_dyn);\n      body_dyn = NULL;\n    }\n    fprintf (stderr, \"Failed to allocate memory.\\n\");\n    return 25;\n  }\n  for (i = 0; i < num_resps; ++i)\n  {\n    resps[i] = create_response_object ();\n    if (NULL == resps[i])\n    {\n      fprintf (stderr, \"Failed to create responses.\\n\");\n      break;\n    }\n  }\n  if (i == num_resps)\n    return 0; /* Success */\n\n  /* Cleanup */\n  while (--i < num_resps)\n    MHD_destroy_response (resps[i]);\n  free (resps);\n  resps = NULL;\n  num_resps = 0;\n  if (NULL != body_dyn)\n    free (body_dyn);\n  body_dyn = NULL;\n  return 32;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'init_data': {'callees': ['init_response_body_data', 'create_response_object', 'get_num_threads', 'get_cpu_core_count', 'MHD_destroy_response'], 'callers': ['main']}, 'init_response_body_data': {'callees': [], 'callers': ['init_data']}, 'create_response_object': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_create_response_empty'], 'callers': ['init_data']}, 'get_num_threads': {'callees': ['get_cpu_core_count', 'get_process_cpu_core_count'], 'callers': ['check_param__connections', 'init_data', 'run_mhd']}, 'get_cpu_core_count': {'callees': ['detect_cpu_core_count'], 'callers': ['detect_process_cpu_core_count', 'get_num_threads', 'check_apply_param__all_cpus', 'check_apply_param__threads', 'init_data']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "init_response_body_data",
    "create_response_object",
    "MHD_create_response_from_buffer_static",
    "MHD_create_response_empty",
    "get_num_threads",
    "get_cpu_core_count",
    "get_process_cpu_core_count",
    "detect_cpu_core_count",
    "detect_process_cpu_core_count",
    "MHD_destroy_response",
    "__builtin_unreachable",
    "struct MHD_Response",
    "tool_params",
    "body_dyn_size",
    "body_dyn",
    "resp_single",
    "resps",
    "num_resps"
  ],
  "explanation": "For checking the MISRA rule on language extensions you must inspect any symbol that the target function calls or depends on (and transitive callees or object declarations) because an extension may be introduced there rather than in init_data itself. Short rationale for each item:\n- init_response_body_data: called directly by init_data; its implementation may use compiler-builtins or nonstandard extensions.\n- create_response_object: called to create response objects; its body (and helpers it calls) may use extensions (e.g. GCC-specific attributes or builtins).\n- MHD_create_response_from_buffer_static / MHD_create_response_empty: callees of create_response_object per the call graph; inspect for compiler builtins, asm, attributes or other extensions.\n- get_num_threads / get_cpu_core_count / get_process_cpu_core_count: used to compute num_resps; their implementations may use platform-specific or compiler-specific intrinsics.\n- detect_cpu_core_count / detect_process_cpu_core_count: transitive callees that are likely to use OS/CPU detection techniques and may invoke compiler extensions or builtins.\n- MHD_destroy_response: called during cleanup; the call graph already shows it leads to __builtin_unreachable \u2014 inspect its definition to confirm use of compiler builtin.\n- __builtin_unreachable: explicit compiler builtin (GCC/clang). If reached in callees, this is a language extension that must be flagged.\n- struct MHD_Response: the type definition may include nonstandard constructs or compiler attributes on members or flexible/zero-length arrays implemented as extensions.\n- tool_params: the global/config object accessed by init_data; its declaration may use compiler-specific attributes, bit-fields with implementation-defined widths, or macros that are extensions.\n- body_dyn_size, body_dyn, resp_single, resps, num_resps: globals manipulated by init_data; their declarations could carry attributes (section, alignment), use GCC extensions, or be macros that expand to extensions.\n\nInspecting these symbols (their declarations and full definitions/transitive callees) is necessary to determine whether init_data, via direct use or indirect dependency, uses any language/compiler extensions that would violate the MISRA rule."
}