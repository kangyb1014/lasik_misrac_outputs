{
  "user_message": "Target function code is:\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'calculate_add_nonce': {'callees': ['MHD_get_master', 'digest_get_size', 'calculate_nonce', 'get_nonce_nc_idx', '__builtin_unreachable', 'is_slot_available'], 'callers': ['calculate_add_nonce_with_retry']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, '__builtin_rotateleft32': {'callees': [], 'callers': ['fast_simple_hash', 'calculate_add_nonce_with_retry', 'md5_transform']}, 'digest_reset': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'queue_auth_required_response3_inner': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'digest_init_one_time', 'get_base_digest_algo', 'MHD_get_master', 'digest_get_size', 'MHD_str_quote', 'calculate_add_nonce_with_retry', 'MHD_queue_response'], 'callers': ['MHD_queue_auth_required_response3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_ROTL32",
    "_MHD_ROTR32",
    "__builtin_rotateleft32",
    "random",
    "rand",
    "HAVE_RANDOM",
    "HAVE_RAND",
    "HAVE_MESSAGES",
    "MHD_DIGEST_HAS_EXT_ERROR",
    "digest_ext_error",
    "NONCE_STD_LEN",
    "MAX_DIGEST",
    "DAUTH_JUMPBACK_MAX",
    "UINT64_C",
    "uintptr_t"
  ],
  "explanation": "Explain why each symbol is required to check for language extensions:\n\n- _MHD_ROTL32 / _MHD_ROTR32\n  Need the macro definitions to see whether they expand to standard C code or to compiler-specific intrinsics/builtins/inline assembly (e.g. __builtin_rotateleft32 or asm statements). If they expand to a compiler builtin or asm expression, that is a language extension.\n\n- __builtin_rotateleft32\n  This is a common compiler builtin. Its presence in the expansion would be an explicit compiler extension; the definition/use must be inspected to report a violation.\n\n- random / rand\n  The code conditionally calls random() or rand() depending on HAVE_RANDOM/HAVE_RAND. random() is a POSIX/library extension (not ISO C); rand() is ISO C but platform behavior can vary. We must see which function is actually selected to determine if an extension is used.\n\n- HAVE_RANDOM / HAVE_RAND / HAVE_MESSAGES / MHD_DIGEST_HAS_EXT_ERROR\n  These preprocessor flags control which code paths are compiled. To know whether extension-using code is actually compiled in, we must inspect their definitions (or build configuration) and any code they enable/disable.\n\n- digest_ext_error\n  Checked under MHD_DIGEST_HAS_EXT_ERROR. It may be a function or macro; its implementation might use extensions. We must inspect it when the feature macro is enabled.\n\n- NONCE_STD_LEN / MAX_DIGEST\n  These macros determine array sizes (char nonce2[NONCE_STD_LEN(MAX_DIGEST)+1]). If NONCE_STD_LEN or MAX_DIGEST expand to expressions that rely on non-standard features (e.g. variable-length arrays, statement expressions, typeof, gcc extension tricks), that would be an extension. We must inspect the definitions to ensure only standard C is used.\n\n- DAUTH_JUMPBACK_MAX\n  Used in bitwise/mask arithmetic that influences timestamp2. If it is defined using extensions (e.g. complex macros, builtins), that matters for MISRA rule checking.\n\n- UINT64_C\n  This macro is normally from <inttypes.h> (C99). We must confirm it is the standard macro and not replaced by a compiler-specific extension macro.\n\n- uintptr_t\n  This typedef (from <stdint.h>) is used in a cast of a pointer to an integer. While uintptr_t is standard C99, some projects/platforms may provide it as an extension or may substitute non-standard types; its presence and usage must be checked to ensure no non-standard behavior or compiler-specific typedefs are in use.\n\nOverall: the listed symbols/macros/functions control conditional compilation paths or may expand to compiler-specific builtins/asm. Inspecting their definitions is necessary to decide whether the target function uses language/compiler extensions (and therefore violates the cited MISRA prohibition)."
}