{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of request_completed_callback:\n```c\nstatic void\nrequest_completed_callback (void *cls,\n                            struct MHD_Connection *connection,\n                            void **req_cls,\n                            enum MHD_RequestTerminationCode toe)\n{\n  struct Request *request = *req_cls;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == request)\n    return;\n  if (NULL != request->session)\n    request->session->rc--;\n  if (NULL != request->pp)\n    MHD_destroy_post_processor (request->pp);\n  free (request);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function request_completed_callback:\n_MHD_EXTERN enum MHD_Result\nMHD_destroy_post_processor (struct MHD_PostProcessor *pp)\n{\n  enum MHD_Result ret;\n\n  if (NULL == pp)\n    return MHD_YES;\n  if (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n  /* These internal strings need cleaning up since\n     the post-processing may have been interrupted\n     at any stage */\n  if ( (pp->xbuf_pos > 0) ||\n       ( (pp->state != PP_Done) &&\n         (pp->state != PP_Init) ) )\n    ret = MHD_NO;\n  else\n    ret = MHD_YES;\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n    free (pp->nested_boundary);\n  free (pp);\n  return ret;\n}\n...\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      /* initial phase */\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: (no key)'=' */\n        /* Empty key with value */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* Case: (no key)'&' */\n        /* Empty key without value */\n        poff++;\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: (no key)'\\n' or (no key)'\\r' */\n        pp->state = PP_Done;\n        poff++;\n        break;\n      default:\n        /* normal character, key start, advance! */\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      /* key phase */\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: 'key=' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        /* Case: 'key&' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        /* Case: 'key\\n' or 'key\\r' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        /* No advance here, 'PP_Done' will be selected by next 'PP_Init' phase */\n        pp->state = PP_Callback;\n        break;\n      default:\n        /* normal character, advance! */\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        /* case 'key==' */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* case 'value&' */\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: 'value\\n' or 'value\\r' */\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback; /* No poff advance here to set PP_Done in the next iteration */\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        /* character, may be part of escaping */\n        poff++;\n        continue;\n      default:\n        /* normal character, no more escaping! */\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      /* unexpected data at the end, fail! */\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            /* key too long, cannot parse! */\n            pp->state = PP_Error;\n            continue;\n          }\n          /* compute key, if we have not already */\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n#ifdef _DEBUG\n      else\n        mhd_assert (0 != pp->buffer_pos);\n#endif /* _DEBUG */\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    case PP_NextBoundary:\n    case PP_ProcessEntryHeaders:\n    case PP_PerformCheckMultipart:\n    case PP_ProcessValueToBoundary:\n    case PP_PerformCleanup:\n    case PP_Nested_Init:\n    case PP_Nested_PerformMarking:\n    case PP_Nested_ProcessEntryHeaders:\n    case PP_Nested_ProcessValueToBoundary:\n    case PP_Nested_PerformCleanup:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n\n  /* save remaining data for next iteration */\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len); /* it must be always non-zero here */\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    /* compute key, if we have not already */\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n...\nstatic void\nfree_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n  {\n    free (pp->content_name);\n    pp->content_name = NULL;\n  }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n  {\n    free (pp->content_type);\n    pp->content_type = NULL;\n  }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n  {\n    free (pp->content_filename);\n    pp->content_filename = NULL;\n  }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n  {\n    free (pp->content_transfer_encoding);\n    pp->content_transfer_encoding = NULL;\n  }\n}\n...\nstatic void\nresponse_completed_callback (void *cls,\n                             struct MHD_Connection *connection,\n                             void **req_cls,\n                             enum MHD_RequestTerminationCode toe)\n{\n  struct UploadContext *uc = *req_cls;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == uc)\n    return; /* this request wasn't an upload request */\n  if (NULL != uc->pp)\n  {\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n  }\n  if (-1 != uc->fd)\n  {\n    (void) close (uc->fd);\n    if (NULL != uc->filename)\n    {\n      fprintf (stderr,\n               \"Upload of file `%s' failed (incomplete or aborted), removing file.\\n\",\n               uc->filename);\n      (void) unlink (uc->filename);\n    }\n  }\n  if (NULL != uc->filename)\n    free (uc->filename);\n  free (uc);\n}\n...\nstatic void\nrequest_completed (void *cls, struct MHD_Connection *connection,\n                   void **req_cls, enum MHD_RequestTerminationCode toe)\n{\n  struct connection_info_struct *con_info = *req_cls;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == con_info)\n    return;\n\n  if (con_info->connectiontype == POST)\n  {\n    MHD_destroy_post_processor (con_info->postprocessor);\n    if (con_info->answerstring)\n      free (con_info->answerstring);\n  }\n\n  free (con_info);\n  *req_cls = NULL;\n}\n...\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: MHD_destroy_post_processor calls post_process_urlencoded (MHD_destroy_post_processor -> post_process_urlencoded), and in the provided code post_process_urlencoded does not call MHD_destroy_post_processor (nor call any function that in turn calls it). Therefore there is no direct or indirect recursion here. (Only a hypothetical violation would occur if some callback invoked by post_process_urlencoded called MHD_destroy_post_processor on the same pp, but no such path exists in the supplied code.)"
}