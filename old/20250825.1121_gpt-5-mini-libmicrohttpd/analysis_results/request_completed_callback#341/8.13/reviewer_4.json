{
  "user_message": "An agent A claimed that the following request_completed_callback code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of request_completed_callback.\n```c\nstatic void\nrequest_completed_callback (void *cls,\n                            struct MHD_Connection *connection,\n                            void **req_cls,\n                            enum MHD_RequestTerminationCode toe)\n{\n  struct Request *request = *req_cls;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == request)\n    return;\n  if (NULL != request->session)\n    request->session->rc--;\n  if (NULL != request->pp)\n    MHD_destroy_post_processor (request->pp);\n  free (request);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe string literal \"\\n\" has type char[] but should be passed to a parameter declared as pointer-to-const. If post_process_urlencoded is declared to take a non-const pointer (e.g. char *buf, size_t len), then passing the string literal here violates MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type whenever possible. The fix is to declare the function parameter as const char * (or otherwise ensure the function does not attempt to modify the data).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function request_completed_callback:\n_MHD_EXTERN enum MHD_Result\nMHD_destroy_post_processor (struct MHD_PostProcessor *pp)\n{\n  enum MHD_Result ret;\n\n  if (NULL == pp)\n    return MHD_YES;\n  if (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n  /* These internal strings need cleaning up since\n     the post-processing may have been interrupted\n     at any stage */\n  if ( (pp->xbuf_pos > 0) ||\n       ( (pp->state != PP_Done) &&\n         (pp->state != PP_Init) ) )\n    ret = MHD_NO;\n  else\n    ret = MHD_YES;\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n    free (pp->nested_boundary);\n  free (pp);\n  return ret;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as applied to the shown request_completed_callback. The request_completed_callback function does not pass the string literal \"\\n\" (that call appears in MHD_destroy_post_processor in the additional code), and MISRA C 2023 Rule 8.13 concerns how pointer types are declared (parameters/variables should be const-qualified where possible), not the mere presence of a string literal at a call site. Whether there is a Rule 8.13 violation depends on the declaration of post_process_urlencoded: if its buffer parameter is declared as a non-const pointer but the function does not (and need not) modify the pointed-to data, then the function prototype should be changed to take a pointer-to-const and that declaration would be the location of a MISRA 8.13 concern. With the source shown, no definitive violation in request_completed_callback can be established. To resolve the potential issue, inspect the prototype of post_process_urlencoded and make its buffer parameter const char * if the function never modifies the data."
}