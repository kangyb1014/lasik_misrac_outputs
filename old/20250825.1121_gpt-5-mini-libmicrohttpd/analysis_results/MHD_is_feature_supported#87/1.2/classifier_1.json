{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_is_feature_supported:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_is_feature_supported:\n#define _MHD_EXTERN __attribute__((visibility(\"default\")))extern\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\nenum MHD_FEATURE\n{\n  /**\n   * Get whether messages are supported. If supported then in debug\n   * mode messages can be printed to stderr or to external logger.\n   */\n  MHD_FEATURE_MESSAGES = 1,\n\n  /**\n   * Get whether HTTPS is supported.  If supported then flag\n   * #MHD_USE_TLS and options #MHD_OPTION_HTTPS_MEM_KEY,\n   * #MHD_OPTION_HTTPS_MEM_CERT, #MHD_OPTION_HTTPS_MEM_TRUST,\n   * #MHD_OPTION_HTTPS_MEM_DHPARAMS, #MHD_OPTION_HTTPS_CRED_TYPE,\n   * #MHD_OPTION_HTTPS_PRIORITIES can be used.\n   */\n  MHD_FEATURE_TLS = 2,\n  MHD_FEATURE_SSL = 2,\n\n  /**\n   * Get whether option #MHD_OPTION_HTTPS_CERT_CALLBACK is\n   * supported.\n   */\n  MHD_FEATURE_HTTPS_CERT_CALLBACK = 3,\n\n  /**\n   * Get whether IPv6 is supported. If supported then flag\n   * #MHD_USE_IPv6 can be used.\n   */\n  MHD_FEATURE_IPv6 = 4,\n\n  /**\n   * Get whether IPv6 without IPv4 is supported. If not supported\n   * then IPv4 is always enabled in IPv6 sockets and\n   * flag #MHD_USE_DUAL_STACK is always used when #MHD_USE_IPv6 is\n   * specified.\n   */\n  MHD_FEATURE_IPv6_ONLY = 5,\n\n  /**\n   * Get whether `poll()` is supported. If supported then flag\n   * #MHD_USE_POLL can be used.\n   */\n  MHD_FEATURE_POLL = 6,\n\n  /**\n   * Get whether `epoll()` is supported. If supported then Flags\n   * #MHD_USE_EPOLL and\n   * #MHD_USE_EPOLL_INTERNAL_THREAD can be used.\n   */\n  MHD_FEATURE_EPOLL = 7,\n\n  /**\n   * Get whether shutdown on listen socket to signal other\n   * threads is supported. If not supported flag\n   * #MHD_USE_ITC is automatically forced.\n   */\n  MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET = 8,\n\n  /**\n   * Get whether socketpair is used internally instead of pipe to\n   * signal other threads.\n   */\n  MHD_FEATURE_SOCKETPAIR = 9,\n\n  /**\n   * Get whether TCP Fast Open is supported. If supported then\n   * flag #MHD_USE_TCP_FASTOPEN and option\n   * #MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE can be used.\n   */\n  MHD_FEATURE_TCP_FASTOPEN = 10,\n\n  /**\n   * Get whether HTTP Basic authorization is supported. If supported\n   * then functions #MHD_basic_auth_get_username_password and\n   * #MHD_queue_basic_auth_fail_response can be used.\n   */\n  MHD_FEATURE_BASIC_AUTH = 11,\n\n  /**\n   * Get whether HTTP Digest authorization is supported. If\n   * supported then options #MHD_OPTION_DIGEST_AUTH_RANDOM,\n   * #MHD_OPTION_NONCE_NC_SIZE and\n   * #MHD_digest_auth_check() can be used.\n   */\n  MHD_FEATURE_DIGEST_AUTH = 12,\n\n  /**\n   * Get whether postprocessor is supported. If supported then\n   * functions #MHD_create_post_processor(), #MHD_post_process() and\n   * #MHD_destroy_post_processor() can\n   * be used.\n   */\n  MHD_FEATURE_POSTPROCESSOR = 13,\n\n  /**\n  * Get whether password encrypted private key for HTTPS daemon is\n  * supported. If supported then option\n  * ::MHD_OPTION_HTTPS_KEY_PASSWORD can be used.\n  */\n  MHD_FEATURE_HTTPS_KEY_PASSWORD = 14,\n\n  /**\n   * Get whether reading files beyond 2 GiB boundary is supported.\n   * If supported then #MHD_create_response_from_fd(),\n   * #MHD_create_response_from_fd64 #MHD_create_response_from_fd_at_offset()\n   * and #MHD_create_response_from_fd_at_offset64() can be used with sizes and\n   * offsets larger than 2 GiB. If not supported value of size+offset is\n   * limited to 2 GiB.\n   */\n  MHD_FEATURE_LARGE_FILE = 15,\n\n  /**\n   * Get whether MHD set names on generated threads.\n   */\n  MHD_FEATURE_THREAD_NAMES = 16,\n  MHD_THREAD_NAMES = 16,\n\n  /**\n   * Get whether HTTP \"Upgrade\" is supported.\n   * If supported then #MHD_ALLOW_UPGRADE, #MHD_upgrade_action() and\n   * #MHD_create_response_for_upgrade() can be used.\n   */\n  MHD_FEATURE_UPGRADE = 17,\n\n  /**\n   * Get whether it's safe to use same FD for multiple calls of\n   * #MHD_create_response_from_fd() and whether it's safe to use single\n   * response generated by #MHD_create_response_from_fd() with multiple\n   * connections at same time.\n   * If #MHD_is_feature_supported() return #MHD_NO for this feature then\n   * usage of responses with same file FD in multiple parallel threads may\n   * results in incorrect data sent to remote client.\n   * It's always safe to use same file FD in multiple responses if MHD\n   * is run in any single thread mode.\n   */\n  MHD_FEATURE_RESPONSES_SHARED_FD = 18,\n\n  /**\n   * Get whether MHD support automatic detection of bind port number.\n   * @sa #MHD_DAEMON_INFO_BIND_PORT\n   */\n  MHD_FEATURE_AUTODETECT_BIND_PORT = 19,\n\n  /**\n   * Get whether MHD supports automatic SIGPIPE suppression.\n   * If SIGPIPE suppression is not supported, application must handle\n   * SIGPIPE signal by itself.\n   */\n  MHD_FEATURE_AUTOSUPPRESS_SIGPIPE = 20,\n\n  /**\n   * Get whether MHD use system's sendfile() function to send\n   * file-FD based responses over non-TLS connections.\n   * @note Since v0.9.56\n   */\n  MHD_FEATURE_SENDFILE = 21,\n\n  /**\n   * Get whether MHD supports threads.\n   */\n  MHD_FEATURE_THREADS = 22,\n\n  /**\n   * Get whether option #MHD_OPTION_HTTPS_CERT_CALLBACK2 is\n   * supported.\n   */\n  MHD_FEATURE_HTTPS_CERT_CALLBACK2 = 23,\n\n  /**\n   * Get whether automatic parsing of HTTP Cookie header is supported.\n   * If disabled, no MHD_COOKIE_KIND will be generated by MHD.\n   * MHD versions before 0x00097701 always support cookie parsing.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_HTTPS_COOKIE_PARSING = 24,\n\n  /**\n   * Get whether the early version the Digest Authorization (RFC 2069) is\n   * supported (digest authorisation without QOP parameter).\n   * Since #MHD_VERSION 0x00097701 it is always supported if Digest Auth\n   * module is built.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_RFC2069 = 25,\n\n  /**\n   * Get whether the MD5-based hashing algorithms are supported for Digest\n   * Authorization.\n   * Currently it is always supported if Digest Auth module is built\n   * unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_MD5 = 26,\n\n  /**\n   * Get whether the SHA-256-based hashing algorithms are supported for Digest\n   * Authorization.\n   * It is always supported since #MHD_VERSION 0x00096200 if Digest Auth\n   * module is built unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_SHA256 = 27,\n\n  /**\n   * Get whether the SHA-512/256-based hashing algorithms are supported\n   * for Digest Authorization.\n   * It it always supported since #MHD_VERSION 0x00097701 if Digest Auth\n   * module is built unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_SHA512_256 = 28,\n\n  /**\n   * Get whether QOP with value 'auth-int' (authentication with integrity\n   * protection) is supported for Digest Authorization.\n   * Currently it is always not supported.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_AUTH_INT = 29,\n\n  /**\n   * Get whether 'session' algorithms (like 'MD5-sess') are supported for Digest\n   * Authorization.\n   * Currently it is always not supported.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION = 30,\n\n  /**\n   * Get whether 'userhash' is supported for Digest Authorization.\n   * It is always supported since #MHD_VERSION 0x00097701 if Digest Auth\n   * module is built.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_USERHASH = 31,\n\n  /**\n   * Get whether any of hashing algorithms is implemented by external\n   * function (like TLS library) and may fail due to external conditions,\n   * like \"out-of-memory\".\n   *\n   * If result is #MHD_YES then functions which use hash calculations\n   * like #MHD_digest_auth_calc_userhash(), #MHD_digest_auth_check3() and others\n   * potentially may fail even with valid input because of out-of-memory error\n   * or crypto accelerator device failure, however in practice such fails are\n   * unlikely.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_EXTERN_HASH = 32,\n\n  /**\n   * Get whether MHD was built with asserts enabled.\n   * For debug builds the error log is always enabled even if #MHD_USE_ERROR_LOG\n   * is not specified for daemon.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DEBUG_BUILD = 33,\n\n  /**\n   * Get whether MHD was build with support for overridable FD_SETSIZE.\n   * This feature should be always available when the relevant platform ability\n   * is detected.\n   * @sa #MHD_OPTION_APP_FD_SETSIZE\n   * @note Available since #MHD_VERSION 0x00097705\n   */\n  MHD_FEATURE_FLEXIBLE_FD_SETSIZE = 34\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n```\nFocus on the above code fragment and judge whether it violates the rule 1.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The identifier _MHD_EXTERN expands to __attribute__((visibility(\"default\")))extern which uses GCC's __attribute__ extension (visibility attribute). This is a compiler-specific language extension and therefore violates MISRA C 2023 Rule 1.2."
}