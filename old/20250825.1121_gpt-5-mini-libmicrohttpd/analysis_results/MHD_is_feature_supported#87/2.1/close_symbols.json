{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_is_feature_supported': {'callees': [], 'callers': ['show_help', 'check_param_port', 'check_param__epoll', 'check_param__poll', 'print_perf_warnings']}, 'show_help': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param_port': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__epoll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__poll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'print_perf_warnings': {'callees': ['MHD_is_feature_supported'], 'callers': ['run_mhd']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_FEATURE",
    "MHD_YES",
    "MHD_NO",
    "HAVE_MESSAGES",
    "HTTPS_SUPPORT",
    "GNUTLS_VERSION_MAJOR",
    "GNUTLS_VERSION_NUMBER",
    "HAVE_INET6",
    "IPPROTO_IPV6",
    "IPV6_V6ONLY",
    "HAVE_POLL",
    "EPOLL_SUPPORT",
    "HAVE_LISTEN_SHUTDOWN",
    "_MHD_ITC_SOCKETPAIR",
    "TCP_FASTOPEN",
    "BAUTH_SUPPORT",
    "DAUTH_SUPPORT",
    "HAVE_POSTPROCESSOR",
    "HAVE_PREAD64",
    "HAVE_PREAD",
    "_WIN32",
    "HAVE_LSEEK64",
    "MHD_USE_THREAD_NAME_",
    "UPGRADE_SUPPORT",
    "MHD_USE_GETSOCKNAME",
    "MHD_SEND_SPIPE_SUPPRESS_POSSIBLE",
    "MHD_SEND_SPIPE_SUPPRESS_NEEDED",
    "_MHD_HAVE_SENDFILE",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "COOKIE_SUPPORT",
    "MHD_MD5_SUPPORT",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA512_256_SUPPORT",
    "MHD_MD5_TLSLIB",
    "MHD_SHA256_TLSLIB",
    "_DEBUG",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "uint64_t",
    "off_t",
    "_FILE_OFFSET_BITS"
  ],
  "explanation": "To assess unreachable code in MHD_is_feature_supported you must know which conditional compilation branches and switch labels actually exist at compile time and whether every enumerator can be dispatched by the switch. Required symbols and why:\n\n- enum MHD_FEATURE: needed to know the set of enumerators and their values (to determine whether the switch covers all possible values or leaves unreachable case/default branches).\n- MHD_YES, MHD_NO: return macros used in each branch; knowing them is required to confirm branches produce visible returns (and thus whether subsequent code is unreachable).\n\nAll following symbols are preprocessor/compile-time configuration macros used in #if / #ifdef expressions inside the function. Each one determines whether the corresponding case\u2019s code (the return MHD_YES / MHD_NO) is compiled in or out. To determine reachability of the code associated with a given case you must know whether the macro is defined and, for numeric macros, its value:\n- HAVE_MESSAGES, HTTPS_SUPPORT, GNUTLS_VERSION_MAJOR, GNUTLS_VERSION_NUMBER,\n  HAVE_INET6, IPPROTO_IPV6, IPV6_V6ONLY, HAVE_POLL, EPOLL_SUPPORT,\n  HAVE_LISTEN_SHUTDOWN, _MHD_ITC_SOCKETPAIR, TCP_FASTOPEN,\n  BAUTH_SUPPORT, DAUTH_SUPPORT, HAVE_POSTPROCESSOR,\n  HAVE_PREAD64, HAVE_PREAD, _WIN32, HAVE_LSEEK64,\n  MHD_USE_THREAD_NAME_, UPGRADE_SUPPORT, MHD_USE_GETSOCKNAME,\n  MHD_SEND_SPIPE_SUPPRESS_POSSIBLE, MHD_SEND_SPIPE_SUPPRESS_NEEDED,\n  _MHD_HAVE_SENDFILE, MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS,\n  COOKIE_SUPPORT, MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, MHD_SHA512_256_SUPPORT,\n  MHD_MD5_TLSLIB, MHD_SHA256_TLSLIB, _DEBUG, HAS_FD_SETSIZE_OVERRIDABLE\n  \u2014 each controls compilation/selection of a branch. Without their definitions/values you cannot determine which return statements are present and therefore cannot conclude whether any code is unreachable.\n\n- uint64_t, off_t, _FILE_OFFSET_BITS: the logic in the MHD_FEATURE_LARGE_FILE (and related RESPONSES_SHARED_FD checks) depends on sizeof(uint64_t) > sizeof(off_t) (and platform file-offset settings). You must know the target typedefs/size model (or _FILE_OFFSET_BITS) to evaluate whether a particular conditional expression yields MHD_YES or MHD_NO at compile time; that affects whether code under those alternatives is compiled and whether other code becomes unreachable.\n\nIn short: determine which #if/#ifdef branches are active (the listed macros and numeric GNUTLS macros), and the complete enum definition. With those symbols you can decide which case labels correspond to compiled return statements and therefore whether any code in the function is unreachable (MISRA rule)."
}