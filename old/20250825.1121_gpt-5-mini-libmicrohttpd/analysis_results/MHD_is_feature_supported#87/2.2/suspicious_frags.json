{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_is_feature_supported:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_is_feature_supported:\nenum MHD_FEATURE\n{\n  /**\n   * Get whether messages are supported. If supported then in debug\n   * mode messages can be printed to stderr or to external logger.\n   */\n  MHD_FEATURE_MESSAGES = 1,\n\n  /**\n   * Get whether HTTPS is supported.  If supported then flag\n   * #MHD_USE_TLS and options #MHD_OPTION_HTTPS_MEM_KEY,\n   * #MHD_OPTION_HTTPS_MEM_CERT, #MHD_OPTION_HTTPS_MEM_TRUST,\n   * #MHD_OPTION_HTTPS_MEM_DHPARAMS, #MHD_OPTION_HTTPS_CRED_TYPE,\n   * #MHD_OPTION_HTTPS_PRIORITIES can be used.\n   */\n  MHD_FEATURE_TLS = 2,\n  MHD_FEATURE_SSL = 2,\n\n  /**\n   * Get whether option #MHD_OPTION_HTTPS_CERT_CALLBACK is\n   * supported.\n   */\n  MHD_FEATURE_HTTPS_CERT_CALLBACK = 3,\n\n  /**\n   * Get whether IPv6 is supported. If supported then flag\n   * #MHD_USE_IPv6 can be used.\n   */\n  MHD_FEATURE_IPv6 = 4,\n\n  /**\n   * Get whether IPv6 without IPv4 is supported. If not supported\n   * then IPv4 is always enabled in IPv6 sockets and\n   * flag #MHD_USE_DUAL_STACK is always used when #MHD_USE_IPv6 is\n   * specified.\n   */\n  MHD_FEATURE_IPv6_ONLY = 5,\n\n  /**\n   * Get whether `poll()` is supported. If supported then flag\n   * #MHD_USE_POLL can be used.\n   */\n  MHD_FEATURE_POLL = 6,\n\n  /**\n   * Get whether `epoll()` is supported. If supported then Flags\n   * #MHD_USE_EPOLL and\n   * #MHD_USE_EPOLL_INTERNAL_THREAD can be used.\n   */\n  MHD_FEATURE_EPOLL = 7,\n\n  /**\n   * Get whether shutdown on listen socket to signal other\n   * threads is supported. If not supported flag\n   * #MHD_USE_ITC is automatically forced.\n   */\n  MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET = 8,\n\n  /**\n   * Get whether socketpair is used internally instead of pipe to\n   * signal other threads.\n   */\n  MHD_FEATURE_SOCKETPAIR = 9,\n\n  /**\n   * Get whether TCP Fast Open is supported. If supported then\n   * flag #MHD_USE_TCP_FASTOPEN and option\n   * #MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE can be used.\n   */\n  MHD_FEATURE_TCP_FASTOPEN = 10,\n\n  /**\n   * Get whether HTTP Basic authorization is supported. If supported\n   * then functions #MHD_basic_auth_get_username_password and\n   * #MHD_queue_basic_auth_fail_response can be used.\n   */\n  MHD_FEATURE_BASIC_AUTH = 11,\n\n  /**\n   * Get whether HTTP Digest authorization is supported. If\n   * supported then options #MHD_OPTION_DIGEST_AUTH_RANDOM,\n   * #MHD_OPTION_NONCE_NC_SIZE and\n   * #MHD_digest_auth_check() can be used.\n   */\n  MHD_FEATURE_DIGEST_AUTH = 12,\n\n  /**\n   * Get whether postprocessor is supported. If supported then\n   * functions #MHD_create_post_processor(), #MHD_post_process() and\n   * #MHD_destroy_post_processor() can\n   * be used.\n   */\n  MHD_FEATURE_POSTPROCESSOR = 13,\n\n  /**\n  * Get whether password encrypted private key for HTTPS daemon is\n  * supported. If supported then option\n  * ::MHD_OPTION_HTTPS_KEY_PASSWORD can be used.\n  */\n  MHD_FEATURE_HTTPS_KEY_PASSWORD = 14,\n\n  /**\n   * Get whether reading files beyond 2 GiB boundary is supported.\n   * If supported then #MHD_create_response_from_fd(),\n   * #MHD_create_response_from_fd64 #MHD_create_response_from_fd_at_offset()\n   * and #MHD_create_response_from_fd_at_offset64() can be used with sizes and\n   * offsets larger than 2 GiB. If not supported value of size+offset is\n   * limited to 2 GiB.\n   */\n  MHD_FEATURE_LARGE_FILE = 15,\n\n  /**\n   * Get whether MHD set names on generated threads.\n   */\n  MHD_FEATURE_THREAD_NAMES = 16,\n  MHD_THREAD_NAMES = 16,\n\n  /**\n   * Get whether HTTP \"Upgrade\" is supported.\n   * If supported then #MHD_ALLOW_UPGRADE, #MHD_upgrade_action() and\n   * #MHD_create_response_for_upgrade() can be used.\n   */\n  MHD_FEATURE_UPGRADE = 17,\n\n  /**\n   * Get whether it's safe to use same FD for multiple calls of\n   * #MHD_create_response_from_fd() and whether it's safe to use single\n   * response generated by #MHD_create_response_from_fd() with multiple\n   * connections at same time.\n   * If #MHD_is_feature_supported() return #MHD_NO for this feature then\n   * usage of responses with same file FD in multiple parallel threads may\n   * results in incorrect data sent to remote client.\n   * It's always safe to use same file FD in multiple responses if MHD\n   * is run in any single thread mode.\n   */\n  MHD_FEATURE_RESPONSES_SHARED_FD = 18,\n\n  /**\n   * Get whether MHD support automatic detection of bind port number.\n   * @sa #MHD_DAEMON_INFO_BIND_PORT\n   */\n  MHD_FEATURE_AUTODETECT_BIND_PORT = 19,\n\n  /**\n   * Get whether MHD supports automatic SIGPIPE suppression.\n   * If SIGPIPE suppression is not supported, application must handle\n   * SIGPIPE signal by itself.\n   */\n  MHD_FEATURE_AUTOSUPPRESS_SIGPIPE = 20,\n\n  /**\n   * Get whether MHD use system's sendfile() function to send\n   * file-FD based responses over non-TLS connections.\n   * @note Since v0.9.56\n   */\n  MHD_FEATURE_SENDFILE = 21,\n\n  /**\n   * Get whether MHD supports threads.\n   */\n  MHD_FEATURE_THREADS = 22,\n\n  /**\n   * Get whether option #MHD_OPTION_HTTPS_CERT_CALLBACK2 is\n   * supported.\n   */\n  MHD_FEATURE_HTTPS_CERT_CALLBACK2 = 23,\n\n  /**\n   * Get whether automatic parsing of HTTP Cookie header is supported.\n   * If disabled, no MHD_COOKIE_KIND will be generated by MHD.\n   * MHD versions before 0x00097701 always support cookie parsing.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_HTTPS_COOKIE_PARSING = 24,\n\n  /**\n   * Get whether the early version the Digest Authorization (RFC 2069) is\n   * supported (digest authorisation without QOP parameter).\n   * Since #MHD_VERSION 0x00097701 it is always supported if Digest Auth\n   * module is built.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_RFC2069 = 25,\n\n  /**\n   * Get whether the MD5-based hashing algorithms are supported for Digest\n   * Authorization.\n   * Currently it is always supported if Digest Auth module is built\n   * unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_MD5 = 26,\n\n  /**\n   * Get whether the SHA-256-based hashing algorithms are supported for Digest\n   * Authorization.\n   * It is always supported since #MHD_VERSION 0x00096200 if Digest Auth\n   * module is built unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_SHA256 = 27,\n\n  /**\n   * Get whether the SHA-512/256-based hashing algorithms are supported\n   * for Digest Authorization.\n   * It it always supported since #MHD_VERSION 0x00097701 if Digest Auth\n   * module is built unless manually disabled in a custom build.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_SHA512_256 = 28,\n\n  /**\n   * Get whether QOP with value 'auth-int' (authentication with integrity\n   * protection) is supported for Digest Authorization.\n   * Currently it is always not supported.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_AUTH_INT = 29,\n\n  /**\n   * Get whether 'session' algorithms (like 'MD5-sess') are supported for Digest\n   * Authorization.\n   * Currently it is always not supported.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION = 30,\n\n  /**\n   * Get whether 'userhash' is supported for Digest Authorization.\n   * It is always supported since #MHD_VERSION 0x00097701 if Digest Auth\n   * module is built.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DIGEST_AUTH_USERHASH = 31,\n\n  /**\n   * Get whether any of hashing algorithms is implemented by external\n   * function (like TLS library) and may fail due to external conditions,\n   * like \"out-of-memory\".\n   *\n   * If result is #MHD_YES then functions which use hash calculations\n   * like #MHD_digest_auth_calc_userhash(), #MHD_digest_auth_check3() and others\n   * potentially may fail even with valid input because of out-of-memory error\n   * or crypto accelerator device failure, however in practice such fails are\n   * unlikely.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_EXTERN_HASH = 32,\n\n  /**\n   * Get whether MHD was built with asserts enabled.\n   * For debug builds the error log is always enabled even if #MHD_USE_ERROR_LOG\n   * is not specified for daemon.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_FEATURE_DEBUG_BUILD = 33,\n\n  /**\n   * Get whether MHD was build with support for overridable FD_SETSIZE.\n   * This feature should be always available when the relevant platform ability\n   * is detected.\n   * @sa #MHD_OPTION_APP_FD_SETSIZE\n   * @note Available since #MHD_VERSION 0x00097705\n   */\n  MHD_FEATURE_FLEXIBLE_FD_SETSIZE = 34\n}\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\n#define HAVE_MESSAGES 1\n...\n#define HAVE_INET6 1\n...\n#define HAVE_POLL 1\n...\n#define EPOLL_SUPPORT 1\n...\n#define HAVE_LISTEN_SHUTDOWN 1\n...\n#define BAUTH_SUPPORT 1\n...\n#define DAUTH_SUPPORT 1\n...\n#define HAVE_POSTPROCESSOR 1\n...\n#define HAVE_PREAD64 1\n...\n#define HAVE_PREAD 1\n...\n#define HAVE_LSEEK64 1\n...\n#define MHD_USE_THREAD_NAME_ \n...\n#define UPGRADE_SUPPORT 1\n...\n#define MHD_USE_GETSOCKNAME 1\n...\n#define MHD_SEND_SPIPE_SUPPRESS_POSSIBLE 1\n...\n#define MHD_SEND_SPIPE_SUPPRESS_NEEDED 1\n...\n#define _MHD_HAVE_SENDFILE \n...\n#define MHD_USE_POSIX_THREADS 1\n...\n#define COOKIE_SUPPORT 1\n...\n#define MHD_MD5_SUPPORT 1\n...\n#define MHD_SHA256_SUPPORT 1\n...\n#define MHD_SHA512_256_SUPPORT 1\n...\nstatic void\nshow_help (void)\n{\n  printf (\"Usage: %s [OPTIONS] [PORT_NUMBER]\\n\", self_name);\n  printf (\"Start MHD-based web-server optimised for fast replies.\\n\");\n  printf (\"\\n\");\n  printf (\"Threads options (mutually exclusive):\\n\");\n  printf (\"  -A,     --all-cpus        use all available CPU cores (for \\n\"\n          \"                            testing with remote client)\\n\");\n  printf (\"  -t NUM, --threads=NUM     use NUM threads\\n\");\n  printf (\"  -P,     --thread-per-conn use thread-per-connection mode,\\n\"\n          \"                            the number of threads are limited only\\n\"\n          \"                            by the number of connection\\n\");\n  printf (\"\\n\");\n  printf (\"Force polling function (mutually exclusive):\\n\");\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_EPOLL))\n    printf (\"  -e,     --epoll           use 'epoll' functionality\\n\");\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_POLL))\n    printf (\"  -p,     --poll            use poll() function\\n\");\n  printf (\"  -s,     --select          use select() function\\n\");\n  printf (\"\\n\");\n  printf (\"Response body size options (mutually exclusive):\\n\");\n  printf (\"  -E,     --empty           empty response, 0 bytes\\n\");\n  printf (\"  -T,     --tiny            tiny response, 3 bytes (default)\\n\");\n  printf (\"  -M,     --medium          medium response, 8 KB\\n\");\n  printf (\"  -L,     --large           large response, 1 MB\\n\");\n  printf (\"\\n\");\n  printf (\"Response use options (mutually exclusive):\\n\");\n  printf (\"  -S,     --shared          pool of pre-generated shared response\\n\"\n          \"                            objects (default)\\n\");\n  printf (\"  -I,     --single          single pre-generated response object\\n\"\n          \"                            used for all requests\\n\");\n  printf (\"  -U,     --unique          response object generated for every\\n\"\n          \"                            request and used one time only\\n\");\n  printf (\"\\n\");\n  printf (\"Other options:\\n\");\n  printf (\"  -c NUM, --connections=NUM reject more than NUM client \\n\"\n          \"                            connections\\n\");\n  printf (\"  -O NUM, --timeout=NUM     set connection timeout to NUM seconds,\\n\"\n          \"                            zero means no timeout\\n\");\n  printf (\"          --date-header     use the 'Date:' header in every\\n\"\n          \"                            reply\\n\");\n  printf (\"          --help            display this help and exit\\n\");\n  printf (\"  -V,     --version         output version information and exit\\n\");\n  printf (\"\\n\");\n  printf (\"This tool is part of GNU libmicrohttpd suite.\\n\");\n  printf (\"%s\\n\", tool_copyright);\n}\n...\nstatic void\ncheck_param_port (void)\n{\n  if (0 != tool_params.port)\n    return;\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    tool_params.port = PERF_REPL_PORT_FALLBACK;\n}\n...\nstatic int\ncheck_param__epoll (void)\n{\n  if (! tool_params.epoll)\n    return ! 0;\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_EPOLL))\n  {\n    fprintf (stderr, \"'epoll' was requested, but this MHD build does not \"\n             \"support 'epoll' functionality.\\n\");\n    return 0;\n  }\n  return ! 0;\n}\n...\nstatic int\ncheck_param__poll (void)\n{\n  if (! tool_params.poll)\n    return ! 0;\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_POLL))\n  {\n    fprintf (stderr, \"poll() was requested, but this MHD build does not \"\n             \"support polling by poll().\\n\");\n    return 0;\n  }\n  return ! 0;\n}\n...\nstatic void\nprint_perf_warnings (void)\n{\n  int newline_needed = 0;\n#if defined (_DEBUG)\n  fprintf (stderr, \"WARNING: Running with debug asserts enabled, \"\n           \"the performance is suboptimal.\\n\");\n  newline_needed |=  ! 0;\n#endif /* _DEBUG */\n#if defined(__GNUC__) && ! defined (__OPTIMIZE__)\n  fprintf (stderr, \"WARNING: The tools is compiled without enabled compiler \"\n           \"optimisations, the performance is suboptimal.\\n\");\n  newline_needed |=  ! 0;\n#endif /* __GNUC__ && ! __OPTIMIZE__ */\n#if defined(__GNUC__) && defined (__OPTIMIZE_SIZE__)\n  fprintf (stderr, \"WARNING: The tools is compiled with size-optimisations, \"\n           \"the performance is suboptimal.\\n\");\n#endif /* __GNUC__ && ! __OPTIMIZE__ */\n#if MHD_VERSION >= 0x00097701\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_DEBUG_BUILD))\n  {\n    fprintf (stderr, \"WARNING: The libmicrohttpd is compiled with \"\n             \"debug asserts enabled, the performance is suboptimal.\\n\");\n    newline_needed |=  ! 0;\n  }\n#endif /* MHD_VERSION >= 0x00097701 */\n  if (newline_needed)\n    printf (\"\\n\");\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif",
    "  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif"
  ],
  "explanation": "Most other case branches in MHD_is_feature_supported are conditioned on compile-time macros so only one branch is compiled into the final binary; those compiled branches return meaningful, differing values depending on feature/configuration and therefore are not redundant. The default path (break; then return MHD_NO) is intentional fallback behavior. The two reported fragments are the only places in the function where both the #ifdef and #else branches return the identical value, making the conditional preprocessor construct redundant in the resulting compiled code and warranting investigation for possible dead/redundant code. No other compiled operations in the shown function are obviously removable without changing program behaviour given the provided defines and usages."
}