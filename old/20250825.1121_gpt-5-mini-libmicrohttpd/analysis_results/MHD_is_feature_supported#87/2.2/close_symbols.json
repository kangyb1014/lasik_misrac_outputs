{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_is_feature_supported': {'callees': [], 'callers': ['show_help', 'check_param_port', 'check_param__epoll', 'check_param__poll', 'print_perf_warnings']}, 'show_help': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param_port': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__epoll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__poll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'print_perf_warnings': {'callees': ['MHD_is_feature_supported'], 'callers': ['run_mhd']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_FEATURE",
    "MHD_FEATURE_MESSAGES",
    "MHD_FEATURE_TLS",
    "MHD_FEATURE_HTTPS_CERT_CALLBACK",
    "MHD_FEATURE_HTTPS_CERT_CALLBACK2",
    "MHD_FEATURE_IPv6",
    "MHD_FEATURE_IPv6_ONLY",
    "MHD_FEATURE_POLL",
    "MHD_FEATURE_EPOLL",
    "MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET",
    "MHD_FEATURE_SOCKETPAIR",
    "MHD_FEATURE_TCP_FASTOPEN",
    "MHD_FEATURE_BASIC_AUTH",
    "MHD_FEATURE_DIGEST_AUTH",
    "MHD_FEATURE_POSTPROCESSOR",
    "MHD_FEATURE_HTTPS_KEY_PASSWORD",
    "MHD_FEATURE_LARGE_FILE",
    "MHD_FEATURE_THREAD_NAMES",
    "MHD_FEATURE_UPGRADE",
    "MHD_FEATURE_RESPONSES_SHARED_FD",
    "MHD_FEATURE_AUTODETECT_BIND_PORT",
    "MHD_FEATURE_AUTOSUPPRESS_SIGPIPE",
    "MHD_FEATURE_SENDFILE",
    "MHD_FEATURE_THREADS",
    "MHD_FEATURE_HTTPS_COOKIE_PARSING",
    "MHD_FEATURE_DIGEST_AUTH_RFC2069",
    "MHD_FEATURE_DIGEST_AUTH_MD5",
    "MHD_FEATURE_DIGEST_AUTH_SHA256",
    "MHD_FEATURE_DIGEST_AUTH_SHA512_256",
    "MHD_FEATURE_DIGEST_AUTH_AUTH_INT",
    "MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION",
    "MHD_FEATURE_DIGEST_AUTH_USERHASH",
    "MHD_FEATURE_EXTERN_HASH",
    "MHD_FEATURE_DEBUG_BUILD",
    "MHD_FEATURE_FLEXIBLE_FD_SETSIZE",
    "MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "HAVE_MESSAGES",
    "HTTPS_SUPPORT",
    "GNUTLS_VERSION_MAJOR",
    "GNUTLS_VERSION_NUMBER",
    "HAVE_INET6",
    "IPPROTO_IPV6",
    "IPV6_V6ONLY",
    "HAVE_POLL",
    "EPOLL_SUPPORT",
    "HAVE_LISTEN_SHUTDOWN",
    "_MHD_ITC_SOCKETPAIR",
    "TCP_FASTOPEN",
    "BAUTH_SUPPORT",
    "DAUTH_SUPPORT",
    "HAVE_POSTPROCESSOR",
    "HAVE_PREAD64",
    "_WIN32",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "MHD_USE_THREAD_NAME_",
    "UPGRADE_SUPPORT",
    "MHD_USE_GETSOCKNAME",
    "MHD_SEND_SPIPE_SUPPRESS_POSSIBLE",
    "MHD_SEND_SPIPE_SUPPRESS_NEEDED",
    "_MHD_HAVE_SENDFILE",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "COOKIE_SUPPORT",
    "MHD_MD5_SUPPORT",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA512_256_SUPPORT",
    "MHD_MD5_TLSLIB",
    "MHD_SHA256_TLSLIB",
    "_DEBUG",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "uint64_t",
    "off_t",
    "show_help",
    "check_param_port",
    "check_param__epoll",
    "check_param__poll",
    "print_perf_warnings"
  ],
  "explanation": "To judge whether MHD_is_feature_supported contains dead code you must know which compile-time conditionals and type-sizes actually exist and how the function is used at call sites. The required symbols are:\n\n- MHD_FEATURE and each MHD_FEATURE_* enumerator: define the switch domain; needed to see which case labels are meaningful and whether any case is redundant or unreachable in the build.\n- MHD_Result, MHD_YES, MHD_NO: the return type and return values \u2014 needed to determine whether returns are no-ops or redundant and whether removing them would change behaviour.\n- All preprocessor macros used in the function (#if/#ifdef): HAVE_MESSAGES, HTTPS_SUPPORT, GNUTLS_VERSION_MAJOR, GNUTLS_VERSION_NUMBER, HAVE_INET6, IPPROTO_IPV6, IPV6_V6ONLY, HAVE_POLL, EPOLL_SUPPORT, HAVE_LISTEN_SHUTDOWN, _MHD_ITC_SOCKETPAIR, TCP_FASTOPEN, BAUTH_SUPPORT, DAUTH_SUPPORT, HAVE_POSTPROCESSOR, HAVE_PREAD64, _WIN32, HAVE_PREAD, HAVE_LSEEK64, MHD_USE_THREAD_NAME_, UPGRADE_SUPPORT, MHD_USE_GETSOCKNAME, MHD_SEND_SPIPE_SUPPRESS_POSSIBLE, MHD_SEND_SPIPE_SUPPRESS_NEEDED, _MHD_HAVE_SENDFILE, MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS, COOKIE_SUPPORT, MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, MHD_SHA512_256_SUPPORT, MHD_MD5_TLSLIB, MHD_SHA256_TLSLIB, _DEBUG, HAS_FD_SETSIZE_OVERRIDABLE \u2014 because each controls whether a case compiles to MHD_YES or MHD_NO (or which code path exists). Dead-code analysis depends on the actual definitions of these macros at build time.\n- uint64_t and off_t: sizeof(uint64_t) > sizeof(off_t) is evaluated at compile time and determines control flow for the LARGE_FILE and RESPONSES_SHARED_FD cases; the concrete typedefs / sizes are needed to decide if branches are redundant.\n- Callers (show_help, check_param_port, check_param__epoll, check_param__poll, print_perf_warnings): to determine whether particular case labels are ever executed at runtime (and thus whether code is actually executed so that \"dead code\" could exist). Knowing how callers derive and pass enum values is necessary to tell if a code path is executed but removable without effect.\n\nWith these symbols you can determine which lines are compiled in, which branches evaluate to identical outcomes, whether any executed operations are redundant across all builds and call sites, and thus whether MISRA dead-code rule is violated."
}