{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_is_feature_supported': {'callees': [], 'callers': ['show_help', 'check_param_port', 'check_param__epoll', 'check_param__poll', 'print_perf_warnings']}, 'show_help': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param_port': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__epoll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'check_param__poll': {'callees': ['MHD_is_feature_supported'], 'callers': ['check_apply_params']}, 'print_perf_warnings': {'callees': ['MHD_is_feature_supported'], 'callers': ['run_mhd']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_FEATURE",
    "MHD_Result",
    "_MHD_EXTERN",
    "MHD_YES",
    "MHD_NO",
    "HAVE_MESSAGES",
    "HTTPS_SUPPORT",
    "GNUTLS_VERSION_MAJOR",
    "GNUTLS_VERSION_NUMBER",
    "HAVE_INET6",
    "IPPROTO_IPV6",
    "IPV6_V6ONLY",
    "HAVE_POLL",
    "EPOLL_SUPPORT",
    "HAVE_LISTEN_SHUTDOWN",
    "_MHD_ITC_SOCKETPAIR",
    "TCP_FASTOPEN",
    "BAUTH_SUPPORT",
    "DAUTH_SUPPORT",
    "HAVE_POSTPROCESSOR",
    "HAVE_PREAD64",
    "_WIN32",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "MHD_USE_THREAD_NAME_",
    "UPGRADE_SUPPORT",
    "MHD_USE_GETSOCKNAME",
    "MHD_SEND_SPIPE_SUPPRESS_POSSIBLE",
    "MHD_SEND_SPIPE_SUPPRESS_NEEDED",
    "_MHD_HAVE_SENDFILE",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "COOKIE_SUPPORT",
    "MHD_MD5_SUPPORT",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA512_256_SUPPORT",
    "MHD_MD5_TLSLIB",
    "MHD_SHA256_TLSLIB",
    "_DEBUG",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "uint64_t",
    "off_t"
  ],
  "explanation": "To determine whether MHD_is_feature_supported can violate the MISRA rule for well\u2011formed for loops you must know exactly which code is actually compiled and what the named symbols expand to, because: \n\n- enum MHD_FEATURE: identifies the switch values; needed to be sure no hidden for\u2011loop constructs are introduced by enum/value macros.\n- MHD_Result, _MHD_EXTERN: function/result type and linkage macros (ensure these macros do not expand to code containing loops or side effects). \n- MHD_YES, MHD_NO: returned identifiers \u2014 must confirm they are simple constants (no macro/function bodies that could contain or call code with for loops or modify loop counters).\n- All conditional compilation macros (HAVE_MESSAGES, HTTPS_SUPPORT, GNUTLS_VERSION_MAJOR, GNUTLS_VERSION_NUMBER, HAVE_INET6, IPPROTO_IPV6, IPV6_V6ONLY, HAVE_POLL, EPOLL_SUPPORT, HAVE_LISTEN_SHUTDOWN, _MHD_ITC_SOCKETPAIR, TCP_FASTOPEN, BAUTH_SUPPORT, DAUTH_SUPPORT, HAVE_POSTPROCESSOR, HAVE_PREAD64, _WIN32, HAVE_PREAD, HAVE_LSEEK64, MHD_USE_THREAD_NAME_, UPGRADE_SUPPORT, MHD_USE_GETSOCKNAME, MHD_SEND_SPIPE_SUPPRESS_POSSIBLE, MHD_SEND_SPIPE_SUPPRESS_NEEDED, _MHD_HAVE_SENDFILE, MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS, COOKIE_SUPPORT, MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, MHD_SHA512_256_SUPPORT, MHD_MD5_TLSLIB, MHD_SHA256_TLSLIB, _DEBUG, HAS_FD_SETSIZE_OVERRIDABLE): these determine which case branches are compiled. You must inspect the definitions of any enabled branch to confirm that none introduce a for loop (directly or via macro/function expansions) that would need to be checked for MISRA compliance.\n- uint64_t, off_t: used in sizeof comparisons in the LARGEF_FILE branch. Their definitions/widths affect the compiled expression and might influence whether additional code (macros or inline helpers) is pulled in; also confirm these are plain types (no overloaded macros) and that the sizeof expression does not cause side effects relevant to MISRA loop rules.\n\nIn short: to assess MISRA's for\u2011loop requirements you must know which conditional symbols are defined and the exact definitions of all macros/typedefs returned or referenced (especially MHD_YES/MHD_NO and any macros that could expand into code containing for loops). The symbols above are precisely those that govern compilation of alternate bodies or might themselves expand to code affecting for\u2011loop well\u2011formedness."
}