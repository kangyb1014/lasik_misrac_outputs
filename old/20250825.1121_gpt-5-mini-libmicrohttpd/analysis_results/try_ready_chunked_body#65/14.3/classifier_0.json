{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of try_ready_chunked_body:\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_chunked_body:\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n...\nsize_t\nMHD_pool_get_free (struct MemoryPool *pool)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#ifdef MHD_ASAN_POISON_ACTIVE\n  if ((pool->end - pool->pos) <= _MHD_RED_ZONE_SIZE)\n    return 0;\n#endif /* MHD_ASAN_POISON_ACTIVE */\n  return (pool->end - pool->pos) - _MHD_RED_ZONE_SIZE;\n}\n...\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n...\nbool\nMHD_pool_is_resizable_inplace (struct MemoryPool *pool,\n                               void *block,\n                               size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  if (NULL != block)\n  {\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (pool->size >= block_offset);\n    mhd_assert (pool->size >= block_offset + block_size);\n    return (pool->pos ==\n            ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size));\n  }\n  return false; /* Unallocated blocks cannot be resized in-place */\n}\n...\n#define MHD_SIZE_UNKNOWN UINT64_MAX\n...\n#define MHD_CONTENT_READER_END_OF_STREAM ((ssize_t)-1)\n...\n#define MHD_CONTENT_READER_END_WITH_ERROR ((ssize_t)-2)\n...\nstatic void\nconnection_close_error (struct MHD_Connection *connection,\n                        const char *emsg)\n{\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              \"%s\\n\",\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void) emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}\n...\nsize_t\nMHD_uint32_to_strx (uint32_t val,\n                    char *buf,\n                    size_t buf_size)\n{\n  size_t o_pos = 0; /**< position of the output character */\n  int digit_pos = 8; /** zero-based, digit position in @a 'val' */\n  int digit;\n\n  /* Skip leading zeros */\n  do\n  {\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  } while ((0 == digit) && (0 != digit_pos));\n\n  while (o_pos < buf_size)\n  {\n    buf[o_pos++] =\n      (char) ((digit <= 9) ?\n              ('0' + (char) digit) :\n              ('A' + (char) digit - 10));\n    if (0 == digit_pos)\n      return o_pos;\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  }\n  return 0; /* The buffer is too small */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (128 > size)\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the controlling expression compares constant 128 with the non-constant variable 'size' (computed from connection->write_buffer_size + MHD_pool_get_free(...)), so it is not invariant. (A violating scenario would be if the expression were always true/false at compile time, e.g. if (128 > 128) or if (0).)"
}