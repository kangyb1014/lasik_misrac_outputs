{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of process_value:\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function process_value:\nvoid\nMHD_unescape_plus (char *arg)\n{\n  char *p;\n\n  for (p = strchr (arg, '+'); NULL != p; p = strchr (p + 1, '+'))\n    *p = ' ';\n}\n...\n_MHD_EXTERN size_t\nMHD_http_unescape (char *val)\n{\n  return MHD_str_pct_decode_in_place_lenient_ (val, NULL);\n}\n...\nsize_t\nMHD_str_pct_decode_in_place_lenient_ (char *str,\n                                      bool *broken_encoding)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  size_t len;\n  size_t res;\n\n  len = strlen (str);\n  res = MHD_str_pct_decode_lenient_n_ (str, len, str, len, broken_encoding);\n  str[res] = 0;\n\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  if (NULL != broken_encoding)\n    *broken_encoding = false;\n  r = 0;\n  w = 0;\n  while (0 != str[r])\n  {\n    const char chr = str[r++];\n    if ('%' == chr)\n    {\n      const char d1 = str[r++];\n      if (0 == d1)\n      {\n        if (NULL != broken_encoding)\n          *broken_encoding = true;\n        str[w++] = chr; /* Copy \"as is\" */\n        str[w] = 0;\n        return w;\n      }\n      else\n      {\n        const char d2 = str[r++];\n        if (0 == d2)\n        {\n          if (NULL != broken_encoding)\n            *broken_encoding = true;\n          str[w++] = chr; /* Copy \"as is\" */\n          str[w++] = d1; /* Copy \"as is\" */\n          str[w] = 0;\n          return w;\n        }\n        else\n        {\n          const int h = toxdigitvalue (d1);\n          const int l = toxdigitvalue (d2);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n          {\n            if (NULL != broken_encoding)\n              *broken_encoding = true;\n            str[w++] = chr; /* Copy \"as is\" */\n            str[w++] = d1;\n            str[w++] = d2;\n            continue;\n          }\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          str[w++] = (char) out;\n          continue;\n        }\n      }\n    }\n    str[w++] = chr;\n  }\n  str[w] = 0;\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n...\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      /* initial phase */\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: (no key)'=' */\n        /* Empty key with value */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* Case: (no key)'&' */\n        /* Empty key without value */\n        poff++;\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: (no key)'\\n' or (no key)'\\r' */\n        pp->state = PP_Done;\n        poff++;\n        break;\n      default:\n        /* normal character, key start, advance! */\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      /* key phase */\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: 'key=' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        /* Case: 'key&' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        /* Case: 'key\\n' or 'key\\r' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        /* No advance here, 'PP_Done' will be selected by next 'PP_Init' phase */\n        pp->state = PP_Callback;\n        break;\n      default:\n        /* normal character, advance! */\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        /* case 'key==' */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* case 'value&' */\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: 'value\\n' or 'value\\r' */\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback; /* No poff advance here to set PP_Done in the next iteration */\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        /* character, may be part of escaping */\n        poff++;\n        continue;\n      default:\n        /* normal character, no more escaping! */\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      /* unexpected data at the end, fail! */\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            /* key too long, cannot parse! */\n            pp->state = PP_Error;\n            continue;\n          }\n          /* compute key, if we have not already */\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n#ifdef _DEBUG\n      else\n        mhd_assert (0 != pp->buffer_pos);\n#endif /* _DEBUG */\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    case PP_NextBoundary:\n    case PP_ProcessEntryHeaders:\n    case PP_PerformCheckMultipart:\n    case PP_ProcessValueToBoundary:\n    case PP_PerformCleanup:\n    case PP_Nested_Init:\n    case PP_Nested_PerformMarking:\n    case PP_Nested_ProcessEntryHeaders:\n    case PP_Nested_ProcessValueToBoundary:\n    case PP_Nested_PerformCleanup:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n\n  /* save remaining data for next iteration */\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len); /* it must be always non-zero here */\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    /* compute key, if we have not already */\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nprocess_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "In the provided code there is no direct or indirect recursion: post_process_urlencoded calls process_value, and process_value does not call post_process_urlencoded nor itself. Therefore the shown code does not violate Rule 17.2. (Note: an indirect violation could occur if the application callback pp->ikvi invoked by process_value were implemented to call post_process_urlencoded or process_value again \u2014 that would create an indirect recursive cycle, but that is not present in the supplied code.)"
}