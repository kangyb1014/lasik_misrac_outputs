{
  "user_message": "An agent A claimed that the following MHD_ip_limit_del code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_ip_limit_del.\n```c\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable nodep is declared as void ** but is only used to read the pointer returned by tfind (it is not used to modify the pointed-to pointer). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible \u2014 e.g. declare it as void * const *nodep (pointer to a const pointer) or const void * const *nodep if the pointed-to object should also be const. Since nodep is not const-qualified, the rule is violated in this scenario.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. nodep is only used to read the pointer returned by tfind (it is not used to modify *nodep), so the pointer should be to a const-qualified pointed-to object per MISRA C 2023 Rule 8.13. The appropriate qualification is to make nodep a pointer to a const pointer (void * const *nodep) \u2014 this prevents assignments through *nodep while still allowing modification of the object pointed to by *nodep via the cast to struct MHD_IPCount *. Declaring nodep as const void * const * would be overly strict because the code modifies the pointed-to MHD_IPCount object (found_key->count). Note: assigning the tfind return may require an explicit cast to the chosen pointer-to-pointer type depending on the platform's prototype for tfind; that is a separate compatibility issue and does not negate the need for the const qualification under Rule 8.13."
}