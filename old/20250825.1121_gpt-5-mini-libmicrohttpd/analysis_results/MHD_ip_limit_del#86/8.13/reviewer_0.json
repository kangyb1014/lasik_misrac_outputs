{
  "user_message": "An agent A claimed that the following MHD_ip_limit_del code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_ip_limit_del.\n```c\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'nodep' is declared as void ** but it is only used to read the pointer stored in the tree (it is not used to modify the pointee). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Here 'nodep' should be a pointer-to-const-pointer (for example: void * const *nodep or const void * const *nodep depending on the intended constness of the stored pointers). As written, the code fails to const-qualify the pointee and therefore violates Rule 8.13. Recommended fix: change the declaration to a const-qualified pointer-to-pointer and adjust the assignment to match (or add an explicit, justified cast if required to match the tfind prototype).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The local variable nodep is only used to read the pointer returned by tfind (it is dereferenced to obtain the stored pointer, but the pointer stored in the tree is never modified via nodep). According to MISRA C:2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible; here the pointee (*nodep) could and should be const-qualified. Declaring nodep as e.g. const void * const *nodep (or const void * *nodep with an appropriate const on the pointed-to object) would better express that the code does not modify the stored pointer. Note that changing the declaration may require an explicit, justified cast at the assignment from tfind if the tfind prototype / return type does not match; such a cast would need to be documented to satisfy MISRA requirements. As written, the code fails to add the const qualification and therefore violates Rule 8.13."
}