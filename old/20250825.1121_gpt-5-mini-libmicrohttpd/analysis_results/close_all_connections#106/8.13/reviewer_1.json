{
  "user_message": "An agent A claimed that the following close_all_connections code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of close_all_connections.\n```c\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    while (NULL != susp)\n    {\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the function MHD_itc_activate_ is declared to take a non-const char * (e.g. int MHD_itc_activate_(struct MHD_itc_ itc, char *event)), then passing the string literal \"e\" (which should be treated as pointer to immutable characters) violates MISRA C 2023 Rule 8.13. The pointer parameter should be changed to point to const-qualified type (const char *) so that string literals are passed to a const-qualified pointer. If, however, the prototype already declares the parameter as const char *, then there is no violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function close_all_connections:\nstruct MHD_Daemon\n{\n\n  /**\n   * Callback function for all requests.\n   */\n  MHD_AccessHandlerCallback default_handler;\n\n  /**\n   * Closure argument to default_handler.\n   */\n  void *default_handler_cls;\n\n  /**\n   * Daemon's flags (bitfield).\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  enum MHD_FLAG options;\n\n  /**\n   * Head of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_head;\n\n  /**\n   * Tail of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_tail;\n\n  /**\n   * Head of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_head;\n\n  /**\n   * Tail of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_tail;\n\n  /**\n   * _MHD_YES if the @e listen_fd socket is a UNIX domain socket.\n   */\n  enum MHD_tristate listen_is_unix;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Head of EDLL of connections ready for processing (in epoll mode).\n   */\n  struct MHD_Connection *eready_head;\n\n  /**\n   * Tail of EDLL of connections ready for processing (in epoll mode)\n   */\n  struct MHD_Connection *eready_tail;\n\n  /**\n   * File descriptor associated with our epoll loop.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  int epoll_fd;\n\n  /**\n   * true if the @e listen_fd socket is in the 'epoll' set,\n   * false if not.\n   */\n  bool listen_socket_in_epoll;\n\n#ifdef UPGRADE_SUPPORT\n#ifdef HTTPS_SUPPORT\n  /**\n   * File descriptor associated with the #run_epoll_for_upgrade() loop.\n   * Only available if #MHD_USE_HTTPS_EPOLL_UPGRADE is set.\n   */\n  int epoll_upgrade_fd;\n\n  /**\n   * true if @e epoll_upgrade_fd is in the 'epoll' set,\n   * false if not.\n   */\n  bool upgrade_fd_in_epoll;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Head of EDLL of upgraded connections ready for processing (in epoll mode).\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_head;\n\n  /**\n   * Tail of EDLL of upgraded connections ready for processing (in epoll mode)\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_tail;\n#endif /* UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * Head of the XDLL of ALL connections with a default ('normal')\n   * timeout, sorted by timeout (earliest at the tail, most recently\n   * used connection at the head).  MHD can just look at the tail of\n   * this list to determine the timeout for all of its elements;\n   * whenever there is an event of a connection, the connection is\n   * moved back to the tail of the list.\n   *\n   * All connections by default start in this list; if a custom\n   * timeout that does not match @e connection_timeout_ms is set, they\n   * are moved to the @e manual_timeout_head-XDLL.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode as each thread\n   * needs only one connection-specific timeout.\n   */\n  struct MHD_Connection *normal_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a default timeout,\n   * sorted by timeout (earliest timeout at the tail).\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *normal_timeout_tail;\n\n  /**\n   * Head of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.  MHD will do a O(n) scan over this list to\n   * determine the current timeout.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_tail;\n\n  /**\n   * Function to call to check if we should accept or reject an\n   * incoming request.  May be NULL.\n   */\n  MHD_AcceptPolicyCallback apc;\n\n  /**\n   * Closure argument to apc.\n   */\n  void *apc_cls;\n\n  /**\n   * Function to call when we are done processing\n   * a particular request.  May be NULL.\n   */\n  MHD_RequestCompletedCallback notify_completed;\n\n  /**\n   * Closure argument to @e notify_completed.\n   */\n  void *notify_completed_cls;\n\n  /**\n   * Function to call when we are starting/stopping\n   * a connection.  May be NULL.\n   */\n  MHD_NotifyConnectionCallback notify_connection;\n\n  /**\n   * Closure argument to @e notify_connection.\n   */\n  void *notify_connection_cls;\n\n  /**\n   * Function to call with the full URI at the\n   * beginning of request processing.  May be NULL.\n   * <p>\n   * Returns the initial pointer to internal state\n   * kept by the client for the request.\n   */\n  LogCallback uri_log_callback;\n\n  /**\n   * Closure argument to @e uri_log_callback.\n   */\n  void *uri_log_callback_cls;\n\n  /**\n   * Function to call when we unescape escape sequences.\n   */\n  UnescapeCallback unescape_callback;\n\n  /**\n   * Closure for @e unescape_callback.\n   */\n  void *unescape_callback_cls;\n\n  /**\n   * Listen port.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  uint16_t port;\n\n#ifdef HAVE_MESSAGES\n  /**\n   * Function for logging error messages (if we\n   * support error reporting).\n   */\n  MHD_LogCallback custom_error_log;\n\n  /**\n   * Closure argument to @e custom_error_log.\n   */\n  void *custom_error_log_cls;\n#endif\n\n  /**\n   * Pointer to master daemon (NULL if this is the master)\n   */\n  struct MHD_Daemon *master;\n\n  /**\n   * Listen socket.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  MHD_socket listen_fd;\n\n  /**\n   * Listen socket is non-blocking.\n   */\n  bool listen_nonblk;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Worker daemons (one per thread)\n   */\n  struct MHD_Daemon *worker_pool;\n#endif\n\n  /**\n   * Table storing number of connections per IP\n   */\n  void *per_ip_connection_count;\n\n  /**\n   * Number of active parallel connections.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  unsigned int connections;\n\n  /**\n   * Size of the per-connection memory pools.\n   */\n  size_t pool_size;\n\n  /**\n   * Increment for growth of the per-connection memory pools.\n   */\n  size_t pool_increment;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Size of threads created by MHD.\n   */\n  size_t thread_stack_size;\n\n  /**\n   * Number of worker daemons\n   */\n  unsigned int worker_pool_size;\n\n  /**\n   * The select thread handle (if we have internal select)\n   */\n  MHD_thread_handle_ID_ tid;\n\n  /**\n   * Mutex for per-IP connection counts.\n   */\n  MHD_mutex_ per_ip_connection_mutex;\n\n  /**\n   * Mutex for (modifying) access to the \"cleanup\", \"normal_timeout\" and\n   * \"manual_timeout\" DLLs.\n   */\n  MHD_mutex_ cleanup_connection_mutex;\n\n  /**\n   * Mutex for any access to the \"new connections\" DL-list.\n   */\n  MHD_mutex_ new_connections_mutex;\n#endif\n\n  /**\n   * Our #MHD_OPTION_SERVER_INSANITY level, bits indicating\n   * which sanity checks are off.\n   */\n  enum MHD_DisableSanityCheck insanity_level;\n\n  /**\n   * Whether to allow/disallow/ignore reuse of listening address.\n   * The semantics is the following:\n   * 0: ignore (user did not ask for neither allow/disallow, use SO_REUSEADDR\n   *    except W32)\n   * >0: allow (use SO_REUSEPORT on most platforms, SO_REUSEADDR on Windows)\n   * <0: disallow (mostly no action, SO_EXCLUSIVEADDRUSE on Windows or SO_EXCLBIND\n   *     on Solaris)\n   */\n  int listening_address_reuse;\n\n\n  /**\n   * Inter-thread communication channel (also used to unblock\n   * select() in non-threaded code).\n   */\n  struct MHD_itc_ itc;\n\n  /**\n   * Are we shutting down?\n   */\n  volatile bool shutdown;\n\n  /**\n   * Has this daemon been quiesced via #MHD_quiesce_daemon()?\n   * If so, we should no longer use the @e listen_fd (including\n   * removing it from the @e epoll_fd when possible).\n   */\n  volatile bool was_quiesced;\n\n  /**\n   * Did we hit some system or process-wide resource limit while\n   * trying to accept() the last time? If so, we don't accept new\n   * connections until we close an existing one.  This effectively\n   * temporarily lowers the \"connection_limit\" to the current\n   * number of connections.\n   */\n  bool at_limit;\n\n  /*\n   * Do we need to process resuming connections?\n   */\n  volatile bool resuming;\n\n  /**\n   * Indicate that new connections in @e new_connections_head list\n   * need to be processed.\n   */\n  volatile bool have_new;\n\n  /**\n   * 'True' if some data is already waiting to be processed.\n   * If set to 'true' - zero timeout for select()/poll*()\n   * is used.\n   * Should be reset each time before processing connections\n   * and raised by any connection which require additional\n   * immediately processing (application does not provide\n   * data for response, data waiting in TLS buffers etc.)\n   */\n  bool data_already_pending;\n\n  /**\n   * Limit on the number of parallel connections.\n   */\n  unsigned int connection_limit;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Maximum number of connections per IP, or 0 for\n   * unlimited.\n   */\n  unsigned int per_ip_connection_limit;\n\n  /**\n   * The strictness level for parsing of incoming data.\n   * @see #MHD_OPTION_CLIENT_DISCIPLINE_LVL\n   */\n  int client_discipline;\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  /**\n   * The value of FD_SETSIZE used by the daemon.\n   * For external sockets polling this is the value provided by the application\n   * via MHD_OPTION_APP_FD_SETSIZE or current FD_SETSIZE value.\n   * For internal threads modes this is always current FD_SETSIZE value.\n   */\n  int fdset_size;\n\n  /**\n   * Indicates whether @a fdset_size value was set by application.\n   * 'false' if default value is used.\n   */\n  bool fdset_size_set_by_app;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /**\n   * True if SIGPIPE is blocked\n   */\n  bool sigpipe_blocked;\n\n#ifdef HTTPS_SUPPORT\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Head of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_head;\n\n  /**\n   * Tail of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_tail;\n#endif /* UPGRADE_SUPPORT */\n\n  /**\n   * Desired cipher algorithms.\n   */\n  gnutls_priority_t priority_cache;\n\n  /**\n   * What kind of credentials are we offering\n   * for SSL/TLS?\n   */\n  gnutls_credentials_type_t cred_type;\n\n  /**\n   * Server x509 credentials\n   */\n  gnutls_certificate_credentials_t x509_cred;\n\n  /**\n   * Diffie-Hellman parameters\n   */\n  gnutls_dh_params_t dh_params;\n\n  /**\n   * Server PSK credentials\n   */\n  gnutls_psk_server_credentials_t psk_cred;\n\n#if GNUTLS_VERSION_MAJOR >= 3\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for SNI support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK.\n   */\n  gnutls_certificate_retrieve_function2 *cert_callback;\n\n  /**\n   * Function that can be used to obtain the shared key.\n   */\n  MHD_PskServerCredentialsCallback cred_callback;\n\n  /**\n   * Closure for @e cred_callback.\n   */\n  void *cred_callback_cls;\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for OCSP stapling support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK2.\n   */\n  gnutls_certificate_retrieve_function3 *cert_callback2;\n#endif\n\n  /**\n   * Pointer to our SSL/TLS key (in ASCII) in memory.\n   */\n  const char *https_mem_key;\n\n  /**\n   * Pointer to our SSL/TLS certificate (in ASCII) in memory.\n   */\n  const char *https_mem_cert;\n\n  /**\n   * Pointer to 0-terminated HTTPS passphrase in memory.\n   */\n  const char *https_key_password;\n\n  /**\n   * Pointer to our SSL/TLS certificate authority (in ASCII) in memory.\n   */\n  const char *https_mem_trust;\n\n  /**\n   * Our Diffie-Hellman parameters in memory.\n   */\n  gnutls_dh_params_t https_mem_dhparams;\n\n  /**\n   * true if we have initialized @e https_mem_dhparams.\n   */\n  bool have_dhparams;\n\n  /**\n   * true if ALPN is disabled.\n   */\n  bool disable_alpn;\n\n  #endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n\n  /**\n   * Character array of random values.\n   */\n  const char *digest_auth_random;\n\n  /**\n   * Size of @a digest_auth_random.\n   */\n  size_t digest_auth_rand_size;\n\n  /**\n   * The malloc'ed copy of the @a digest_auth_random.\n   */\n  void *digest_auth_random_copy;\n\n  /**\n   * An array that contains the map nonce-nc.\n   */\n  struct MHD_NonceNc *nnc;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * A rw-lock for synchronizing access to @e nnc.\n   */\n  MHD_mutex_ nnc_lock;\n#endif\n\n  /**\n   * Size of the nonce-nc array.\n   */\n  unsigned int nonce_nc_size;\n\n  /**\n   * Nonce bind type.\n   */\n  unsigned int dauth_bind_type;\n\n  /**\n   * Default nonce validity length.\n   */\n  unsigned int dauth_def_nonce_timeout;\n\n  /**\n   * Default maximum nc (nonce count) value.\n   */\n  uint32_t dauth_def_max_nc;\n#endif\n\n#ifdef TCP_FASTOPEN\n  /**\n   * The queue size for incoming SYN + DATA packets.\n   */\n  unsigned int fastopen_queue_size;\n#endif\n\n  /**\n   * The size of queue for listen socket.\n   */\n  unsigned int listen_backlog_size;\n\n  /* TODO: replace with a single member */\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_listen_fd;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_epoll_fd;\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_num_connections;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_flags;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_port;\n\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  /**\n   * If set to 'true', accept() function will be used instead of accept4() even\n   * if accept4() is available.\n   * This is a workaround for zzuf, which does not support sockets created\n   * by accept4() function.\n   * There is no API to change the value of this member, it can be flipped\n   * only by direct access to the struct member.\n   */\n  bool avoid_accept4;\n#endif /* _DEBUG */\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_UpgradeResponseHandle\n{\n  /**\n   * The connection for which this is an upgrade handle.  Note that\n   * because a response may be shared over many connections, this may\n   * not be the only upgrade handle for the response of this connection.\n   */\n  struct MHD_Connection *connection;\n\n#ifdef HTTPS_SUPPORT\n  /**\n   * Kept in a DLL per daemon.\n   */\n  struct MHD_UpgradeResponseHandle *next;\n\n  /**\n   * Kept in a DLL per daemon.\n   */\n  struct MHD_UpgradeResponseHandle *prev;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing urhs that are epoll-ready.\n   */\n  struct MHD_UpgradeResponseHandle *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing urhs that are epoll-ready.\n   */\n  struct MHD_UpgradeResponseHandle *prevE;\n\n  /**\n   * Specifies whether urh already in EDLL list of ready connections.\n   */\n  bool in_eready_list;\n#endif\n\n  /**\n   * The buffer for receiving data from TLS to\n   * be passed to the application.  Contains @e in_buffer_size\n   * bytes (unless @e in_buffer_size is zero). Do not free!\n   */\n  char *in_buffer;\n\n  /**\n   * The buffer for receiving data from the application to\n   * be passed to TLS.  Contains @e out_buffer_size\n   * bytes (unless @e out_buffer_size is zero). Do not free!\n   */\n  char *out_buffer;\n\n  /**\n   * Size of the @e in_buffer.\n   * Set to 0 if the TLS connection went down for reading or socketpair\n   * went down for writing.\n   */\n  size_t in_buffer_size;\n\n  /**\n   * Size of the @e out_buffer.\n   * Set to 0 if the TLS connection went down for writing or socketpair\n   * went down for reading.\n   */\n  size_t out_buffer_size;\n\n  /**\n   * Number of bytes actually in use in the @e in_buffer.  Can be larger\n   * than @e in_buffer_size if and only if @a in_buffer_size is zero and\n   * we still have bytes that can be forwarded.\n   * Reset to zero if all data was forwarded to socketpair or\n   * if socketpair went down for writing.\n   */\n  size_t in_buffer_used;\n\n  /**\n   * Number of bytes actually in use in the @e out_buffer. Can be larger\n   * than @e out_buffer_size if and only if @a out_buffer_size is zero and\n   * we still have bytes that can be forwarded.\n   * Reset to zero if all data was forwarded to TLS connection or\n   * if TLS connection went down for writing.\n   */\n  size_t out_buffer_used;\n\n  /**\n   * The socket we gave to the application (r/w).\n   */\n  struct UpgradeEpollHandle app;\n\n  /**\n   * If @a app_sock was a socketpair, our end of it, otherwise\n   * #MHD_INVALID_SOCKET; (r/w).\n   */\n  struct UpgradeEpollHandle mhd;\n\n  /**\n   * Emergency IO buffer we use in case the memory pool has literally\n   * nothing left.\n   */\n  char e_buf[RESERVE_EBUF_SIZE];\n\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Set to true after the application finished with the socket\n   * by #MHD_UPGRADE_ACTION_CLOSE.\n   *\n   * When BOTH @e was_closed (changed by command from application)\n   * AND @e clean_ready (changed internally by MHD) are set to\n   * #MHD_YES, function #MHD_resume_connection() will move this\n   * connection to cleanup list.\n   * @remark This flag could be changed from any thread.\n   */\n  volatile bool was_closed;\n\n  /**\n   * Set to true if connection is ready for cleanup.\n   *\n   * In TLS mode functions #MHD_connection_finish_forward_() must\n   * be called before setting this flag to true.\n   *\n   * In thread-per-connection mode, true in this flag means\n   * that connection's thread exited or about to exit and will\n   * not use MHD_Connection::urh data anymore.\n   *\n   * In any mode true in this flag also means that\n   * MHD_Connection::urh data will not be used for socketpair\n   * forwarding and forwarding itself is finished.\n   *\n   * When BOTH @e was_closed (changed by command from application)\n   * AND @e clean_ready (changed internally by MHD) are set to\n   * true, function #MHD_resume_connection() will move this\n   * connection to cleanup list.\n   * @remark This flag could be changed from thread that process\n   * connection's recv(), send() and response.\n   */\n  volatile bool clean_ready;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is conditionally correct. MISRA C 2023 Rule 8.13 requires pointer types to be const-qualified whenever possible. In the snippet close_all_connections the call MHD_itc_activate_(daemon->itc, \"e\") passes a string literal. If the prototype of MHD_itc_activate_ is declared with a non-const pointer parameter (e.g. char *event) then that declaration fails to follow the intent of Rule 8.13 (the parameter should be const char * if the function does not modify the pointed data). The actual violation is in the function declaration/prototype (accepting a non-const char * for data that is not intended to be modified), not in the call-site per se. If the function is already declared as taking const char * (or otherwise appropriately const-qualified), then there is no Rule 8.13 violation for this call."
}