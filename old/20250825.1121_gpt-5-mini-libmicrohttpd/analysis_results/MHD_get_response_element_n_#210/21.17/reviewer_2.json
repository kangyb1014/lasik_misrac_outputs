{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nRule 21.17 can be violated. The code calls MHD_str_equal_caseless_bin_n_(pos->header, key, pos->header_size) using pos->header_size as the byte count. The only protections are assertions (mhd_assert) and a comparison pos->header_size == key_len. If assertions are disabled, or if the caller supplied a key pointer whose accessible buffer is smaller than key_len (but key_len nonetheless equals pos->header_size), MHD_str_equal_caseless_bin_n_ will read key_len bytes from key and may access beyond the bounds of key \u2014 violating Rule 21.17. In short, the function relies on caller-supplied key_len and assertions rather than guaranteeing at runtime that the key buffer is at least key_len bytes, so an out\u2011of\u2011bounds access is possible.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call to MHD_str_equal_caseless_bin_n_(pos->header, key, pos->header_size) assumes that the key buffer is accessible for pos->header_size bytes. The only local protections are asserts (mhd_assert) and the equality test pos->header_size == key_len; neither guarantees at runtime that the object pointed to by key actually contains key_len accessible bytes (asserts may be compiled out, and key_len is supplied by the caller). If MHD_str_equal_caseless_bin_n_ is implemented using standard <string.h> routines such as memcmp/memcpy/strlen (or otherwise reads key_len bytes from key), then an out\u2011of\u2011bounds access can occur, violating MISRA C 2023 Rule 21.17. Because the function relies on caller-supplied length and assertions rather than enforcing or checking buffer bounds at runtime, the reported violation is valid."
}