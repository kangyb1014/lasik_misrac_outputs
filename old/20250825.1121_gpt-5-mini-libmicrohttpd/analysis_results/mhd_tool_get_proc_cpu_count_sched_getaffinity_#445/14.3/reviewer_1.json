{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count_sched_getaffinity_ code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count_sched_getaffinity_.\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY) && defined(HAVE_GETPID)\n  /* Glibc style */\n  if (0 >= ret)\n  {\n    cpu_set_t cur_set;\n    if (0 == sched_getaffinity (getpid (), sizeof (cur_set), &cur_set))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_set);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_set))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int set_size_cpus = 256 * CPU_SETSIZE;\n    const size_t set_size_bytes = CPU_ALLOC_SIZE (set_size_cpus);\n    cpu_set_t *p_set;\n\n    p_set = CPU_ALLOC (set_size_cpus);\n    if (NULL != p_set)\n    {\n      if (0 == sched_getaffinity (getpid (), set_size_bytes, p_set))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (set_size_bytes, p_set);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (set_size_cpus, p_set);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_set);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_SCHED_GETAFFINITY && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression 'if (0 >= ret)' is invariant at that point: 'ret' is initialized to -1 immediately before the check and is not modified before the test, so the condition is always true. This makes the controlling expression effectively constant and thus violates MISRA C 2023 Rule 14.3 (no applicable exception applies).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function mhd_tool_get_proc_cpu_count_sched_getaffinity_:\n#define HAVE_SCHED_GETAFFINITY 1\n...\n#define HAVE_GETPID 1\n...\n#define HAVE_CPU_COUNT 1\n...\n#define CPU_SETSIZE_SAFE CPU_SETSIZE\n...\n#define HAVE_CPU_COUNT_S 1\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown function ret is initialized to -1 immediately before the first if (0 >= ret) and is not modified in between, so the controlling expression is invariant (always true) at that point. None of the rule 14.3 exceptions apply (this is not an intentional infinite loop nor a do-while constant-false integer-constant expression). Preprocessor configuration does not change the fact that, in the compiled path where the block exists, the expression is effectively constant. Therefore the code violates MISRA C 2023 Rule 14.3. (A simple remediation is to remove the redundant if or restructure so the test is meaningful once ret may have been updated.)"
}