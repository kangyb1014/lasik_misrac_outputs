{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY) && defined(HAVE_GETPID)\n  /* Glibc style */\n  if (0 >= ret)\n  {\n    cpu_set_t cur_set;\n    if (0 == sched_getaffinity (getpid (), sizeof (cur_set), &cur_set))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_set);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_set))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int set_size_cpus = 256 * CPU_SETSIZE;\n    const size_t set_size_bytes = CPU_ALLOC_SIZE (set_size_cpus);\n    cpu_set_t *p_set;\n\n    p_set = CPU_ALLOC (set_size_cpus);\n    if (NULL != p_set)\n    {\n      if (0 == sched_getaffinity (getpid (), set_size_bytes, p_set))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (set_size_bytes, p_set);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (set_size_cpus, p_set);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_set);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_SCHED_GETAFFINITY && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_sched_getaffinity_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SCHED_GETAFFINITY",
    "HAVE_GETPID",
    "HAVE_CPU_COUNT",
    "HAVE_CPU_COUNT_S",
    "MHD_FUNC_CPU_COUNT_S_GETS_CPUS",
    "cpu_set_t",
    "sched_getaffinity",
    "getpid",
    "CPU_COUNT",
    "CPU_COUNT_S",
    "CPU_SETSIZE_SAFE",
    "CPU_SETSIZE",
    "CPU_ISSET",
    "CPU_ALLOC_SIZE",
    "CPU_ALLOC",
    "CPU_FREE",
    "size_t",
    "NULL"
  ],
  "explanation": "Each listed symbol appears in the target function or controls conditional compilation and must be inspected to determine whether the code relies on compiler/language extensions (MISRA rule). Brief reasons:\n- HAVE_SCHED_GETAFFINITY, HAVE_GETPID, HAVE_CPU_COUNT, HAVE_CPU_COUNT_S, MHD_FUNC_CPU_COUNT_S_GETS_CPUS: preprocessor feature-test macros that enable alternate code paths. Their definitions (or how they are set) determine which code is compiled and therefore which implementation details need checking for extensions.\n- cpu_set_t: type used for CPU affinity sets. Its definition may be a typedef or a compiler/system-specific type that could use nonstandard language features.\n- sched_getaffinity, getpid: system/library calls; their declaration macros/attributes (e.g. __attribute__ or other vendor-specific annotations) or use may involve compiler-specific extensions.\n- CPU_COUNT, CPU_COUNT_S, CPU_ISSET: macros or inline helpers to inspect cpu_set_t. These are often implemented as complex macros or inline functions and may use compiler extensions (asm, statement-expressions, typeof, inline asm, GCC attributes); their definitions must be reviewed.\n- CPU_SETSIZE_SAFE, CPU_SETSIZE: constants/macros controlling loops and allocation sizes; their definitions may be implementation-specific (could be macros relying on extensions) and affect code paths.\n- CPU_ALLOC_SIZE, CPU_ALLOC, CPU_FREE: allocation helpers/macros for cpu_set_t; often implemented as macros or functions which can use nonstandard constructs (alloca, GNU macros, attributes). Inspect definitions for extensions.\n- size_t, NULL: standard types/macros used in the code; included so the reviewer checks whether the headers providing them in the build environment introduce any compiler-specific extensions or attributes that would make this translation unit use language extensions.\n\nReviewing the definitions/declarations of these symbols (in system headers and project headers) lets the next analyzer determine whether any compiler-specific language extensions are used in the compiled code paths of the target function."
}