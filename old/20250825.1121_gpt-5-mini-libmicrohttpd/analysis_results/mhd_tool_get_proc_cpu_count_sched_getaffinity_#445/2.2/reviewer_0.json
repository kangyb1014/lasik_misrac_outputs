{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count_sched_getaffinity_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count_sched_getaffinity_.\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY) && defined(HAVE_GETPID)\n  /* Glibc style */\n  if (0 >= ret)\n  {\n    cpu_set_t cur_set;\n    if (0 == sched_getaffinity (getpid (), sizeof (cur_set), &cur_set))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_set);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_set))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int set_size_cpus = 256 * CPU_SETSIZE;\n    const size_t set_size_bytes = CPU_ALLOC_SIZE (set_size_cpus);\n    cpu_set_t *p_set;\n\n    p_set = CPU_ALLOC (set_size_cpus);\n    if (NULL != p_set)\n    {\n      if (0 == sched_getaffinity (getpid (), set_size_bytes, p_set))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (set_size_bytes, p_set);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (set_size_cpus, p_set);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_set);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_SCHED_GETAFFINITY && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe conditional test if (0 >= ret) is always true at this point because ret was initialized to -1 immediately before the block and is not modified beforehand. The comparison operation is therefore executed but removing that if (i.e. executing the body unconditionally) would not change behaviour \u2014 this constitutes dead code under MISRA C 2023 Rule 2.2. (Additionally, the fallback loop under the #else is not compiled when HAVE_CPU_COUNT is defined, so that alternative path is not present in the translation unit.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function mhd_tool_get_proc_cpu_count_sched_getaffinity_:\n#define HAVE_SCHED_GETAFFINITY 1\n...\n#define HAVE_GETPID 1\n...\n#define HAVE_CPU_COUNT 1\n...\n#define CPU_SETSIZE_SAFE CPU_SETSIZE\n...\n#define HAVE_CPU_COUNT_S 1\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown configuration (HAVE_SCHED_GETAFFINITY and HAVE_GETPID defined, and ret is a local initialized to -1 immediately before the block), the test if (0 >= ret) that directly follows int ret = -1; will always evaluate to true. That conditional test is therefore a redundant operation: removing the test (i.e. executing the body unconditionally) would not change program behaviour. Under MISRA C 2023 Rule 2.2 (\u201cany operation that is executed but whose removal would not affect program behaviour constitutes dead code\u201d) this constitutes dead code. Note: other configuration combinations (different macro settings) could alter whether the block is present, but given the provided macro definitions the diagnosis is correct for the project build shown."
}