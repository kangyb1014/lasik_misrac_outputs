{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_run_wait:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_run_wait:\n#define MHD_D_IS_USING_POLL_(d) (0!=((d)->options&MHD_USE_POLL))\n...\n#define MHD_D_IS_USING_EPOLL_(d) (0!=((d)->options&MHD_USE_EPOLL))\n...\n#define MHD_D_IS_USING_SELECT_(d) (0==(d->options&(MHD_USE_POLL|MHD_USE_EPOLL)))\n...\n#define MHD_D_IS_USING_THREADS_(d) (0!=(d->options&(MHD_USE_INTERNAL_POLLING_THREAD)))\n...\n#define HAVE_POLL 1\n...\n#define EPOLL_SUPPORT 1\n...\n#define HAVE_MESSAGES 1\n...\n#define MHD_thread_handle_ID_is_valid_handle_(hndl_id) MHD_thread_handle_is_valid_((hndl_id).handle)\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }"
  ],
  "explanation": "All other controlling expressions in the function depend on runtime values or are compile-time conditional compilation and therefore are not invariant at runtime:\n\n- The initial \"if ((daemon->shutdown) || MHD_D_IS_USING_THREADS_(daemon))\" depends on daemon->shutdown and daemon->options at runtime.\n- \"if (0 > millisec)\" depends on the runtime parameter millisec.\n- The poll/epoll/select branches use macros that examine daemon->options (MHD_D_IS_USING_POLL_, MHD_D_IS_USING_EPOLL_, MHD_D_IS_USING_SELECT_) and thus are runtime-dependent.\n- The nested \"if (daemon->fdset_size_set_by_app && (((int) FD_SETSIZE) < daemon->fdset_size))\" depends on daemon fields (fdset_size_set_by_app, fdset_size); FD_SETSIZE is a compile-time macro but combined expression is not invariant.\n- The mhd_assert macro expands to ((void)0) as provided, so it does not produce a controlling expression.\n- Preprocessor #ifdef/#endif (HAVE_POLL, EPOLL_SUPPORT, HAVE_MESSAGES, HAS_FD_SETSIZE_OVERRIDABLE) are resolved at compile time and do not create runtime invariant controlling expressions.\n\nGiven the rule and its exceptions, the sole runtime-compiled invariant controlling expression in this function is the literal \"if (1)\" fallback; other conditionals should not be flagged because they are not invariant at runtime."
}