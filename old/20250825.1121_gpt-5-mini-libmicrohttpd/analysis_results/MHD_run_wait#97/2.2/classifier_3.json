{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_run_wait:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_run_wait:\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_epoll (struct MHD_Daemon *daemon,\n           int32_t millisec)\n{\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  static const char *const upgrade_marker = \"upgrade_ptr\";\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n  struct epoll_event events[MAX_EVENTS];\n  struct epoll_event event;\n  int timeout_ms;\n  int num_events;\n  unsigned int i;\n  MHD_socket ls;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  bool run_upgraded = false;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  bool need_to_accept;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO; /* we're down! */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (daemon->connections < daemon->connection_limit) &&\n       (! daemon->listen_socket_in_epoll) &&\n       (! daemon->at_limit) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n  if ( (daemon->was_quiesced) &&\n       (daemon->listen_socket_in_epoll) )\n  {\n    if ( (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          ls,\n                          NULL)) &&\n         (ENOENT != errno) )   /* ENOENT can happen due to race with\n                                  #MHD_quiesce_daemon() */\n      MHD_PANIC (\"Failed to remove listen FD from epoll set.\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if ( ( (! daemon->upgrade_fd_in_epoll) &&\n         (-1 != daemon->epoll_upgrade_fd) ) )\n  {\n    event.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (upgrade_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        daemon->epoll_upgrade_fd,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->upgrade_fd_in_epoll = true;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (daemon->listen_socket_in_epoll) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ||\n         (daemon->was_quiesced) ) )\n  {\n    /* we're at the connection limit, disable listen socket\n for event loop for now */\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        ls,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove listen FD from epoll set.\\n\"));\n    daemon->listen_socket_in_epoll = false;\n  }\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  timeout_ms = get_timeout_millisec_int (daemon, millisec);\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: Used mostly for uniformity here as same situation is\n   * signaled in epoll mode by non-empty eready DLL. */\n  daemon->data_already_pending = false;\n\n  need_to_accept = false;\n  /* drain 'epoll' event queue; need to iterate as we get at most\n     MAX_EVENTS in one system call here; in practice this should\n     pretty much mean only one round, but better an extra loop here\n     than unfair behavior... */\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n  {\n    /* update event masks */\n    num_events = epoll_wait (daemon->epoll_fd,\n                             events,\n                             MAX_EVENTS,\n                             timeout_ms);\n    if (-1 == num_events)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_YES;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_wait failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n    for (i = 0; i < (unsigned int) num_events; i++)\n    {\n      /* First, check for the values of `ptr` that would indicate\n         that this event is not about a normal connection. */\n      if (NULL == events[i].data.ptr)\n        continue;     /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if (upgrade_marker == events[i].data.ptr)\n      {\n        /* activity on an upgraded connection, we process\n           those in a separate epoll() */\n        run_upgraded = true;\n        continue;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n      if (epoll_itc_marker == events[i].data.ptr)\n      {\n        /* It's OK to clear ITC here as all external\n           conditions will be processed later. */\n        MHD_itc_clear_ (daemon->itc);\n        continue;\n      }\n      if (daemon == events[i].data.ptr)\n      {\n        /* Check for error conditions on listen socket. */\n        /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n        if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n          need_to_accept = true;\n        continue;\n      }\n      /* this is an event relating to a 'normal' connection,\n         remember the event and if appropriate mark the\n         connection as 'eready'. */\n      pos = events[i].data.ptr;\n      /* normal processing: update read/write data */\n      if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n      {\n        pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n        if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_insert (daemon->eready_head,\n                       daemon->eready_tail,\n                       pos);\n          pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      }\n      else\n      {\n        if (0 != (events[i].events & EPOLLIN))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n          if ( ( (0 != (MHD_EVENT_LOOP_INFO_READ & pos->event_loop_info)) ||\n                 (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n        if (0 != (events[i].events & EPOLLOUT))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n          if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n      }\n    }\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if (need_to_accept)\n  {\n    unsigned int series_length = 0;\n\n    /* Run 'accept' until it fails or daemon at limit of connections.\n     * Do not accept more then 10 connections at once. The rest will\n     * be accepted on next turn (level trigger is used for listen\n     * socket). */\n    while ( (MHD_NO != MHD_accept_connection (daemon)) &&\n            (series_length < 10) &&\n            (daemon->connections < daemon->connection_limit) &&\n            (! daemon->at_limit) )\n      series_length++;\n  }\n\n  /* Handle timed-out connections; we need to do this here\n     as the epoll mechanism won't call the 'MHD_connection_handle_idle()' on everything,\n     as the other event loops do.  As timeouts do not get an explicit\n     event, we need to find those connections that might have timed out\n     here.\n\n     Connections with custom timeouts must all be looked at, as we\n     do not bother to sort that (presumably very short) list. */\n  prev = daemon->manual_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n  }\n  /* Connections with the default timeout are sorted by prepending\n     them to the head of the list whenever we touch the connection;\n     thus it suffices to iterate from the tail until the first\n     connection is NOT timed out */\n  prev = daemon->normal_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n    if (MHD_CONNECTION_CLOSED != pos->state)\n      break; /* sorted by timeout, no need to visit the rest! */\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (run_upgraded || (NULL != daemon->eready_urh_head))\n    run_epoll_for_upgrade (daemon);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* process events for connections */\n  prev = daemon->eready_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevE;\n    call_handlers (pos,\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_READ_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_ERROR));\n    if (MHD_EPOLL_STATE_IN_EREADY_EDLL ==\n        (pos->epoll_state & (MHD_EPOLL_STATE_SUSPENDED\n                             | MHD_EPOLL_STATE_IN_EREADY_EDLL)))\n    {\n      if ( ((MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_READ_READY)) ) ||\n           ((MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY)) ) ||\n           (MHD_EVENT_LOOP_INFO_CLEANUP == pos->event_loop_info) )\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n    }\n  }\n\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n...\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define MHD_thread_handle_ID_is_valid_handle_(hndl_id) MHD_thread_handle_is_valid_((hndl_id).handle)\n...\n#define MHD_D_IS_USING_THREADS_(d) (0!=(d->options&(MHD_USE_INTERNAL_POLLING_THREAD)))\n...\n#define MHD_D_IS_USING_POLL_(d) (0!=((d)->options&MHD_USE_POLL))\n...\n#define MHD_D_IS_USING_EPOLL_(d) (0!=((d)->options&MHD_USE_EPOLL))\n...\n#define MHD_D_IS_USING_SELECT_(d) (0==(d->options&(MHD_USE_POLL|MHD_USE_EPOLL)))\n...\n#define HAVE_POLL 1\n...\n#define EPOLL_SUPPORT 1\n...\n#define HAVE_MESSAGES 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define mhd_assert(ignore) ((void)0)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The macro #define mhd_assert(ignore) ((void)0) causes every mhd_assert(...) call to expand to a no-op. For example, mhd_assert(!MHD_thread_handle_ID_is_valid_handle_(daemon->tid)); becomes ((void)0); this statement is executed but has no effect and could be removed without changing program behaviour. Those no-op assertion calls therefore constitute dead code and violate MISRA C 2023 Rule 2.2."
}