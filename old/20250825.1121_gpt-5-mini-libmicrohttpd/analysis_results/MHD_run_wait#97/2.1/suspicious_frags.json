{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_run_wait:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_run_wait:\n#define HAVE_POLL 1\n...\n#define EPOLL_SUPPORT 1\n...\n#define HAVE_MESSAGES 1\n...\n#define MHD_D_IS_USING_POLL_(d) (0!=((d)->options&MHD_USE_POLL))\n...\n#define MHD_D_IS_USING_EPOLL_(d) (0!=((d)->options&MHD_USE_EPOLL))\n...\n#define MHD_D_IS_USING_SELECT_(d) (0==(d->options&(MHD_USE_POLL|MHD_USE_EPOLL)))\n...\n#define MHD_D_IS_USING_THREADS_(d) (0!=(d->options&(MHD_USE_INTERNAL_POLLING_THREAD)))\n...\n#define MHD_thread_handle_ID_is_valid_handle_(hndl_id) MHD_thread_handle_is_valid_((hndl_id).handle)\n...\n#define mhd_assert(ignore) ((void)0)\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */",
    "if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }",
    "#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif",
    "mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));",
    "mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));"
  ],
  "explanation": "I selected fragments that can create (or mask) unreachable code and therefore should be inspected:\n\n- The conditional compilation combined with 'else' tokens around the HAVE_POLL and EPOLL_SUPPORT blocks forms an else-if chain that is sensitive to which macros are defined. Mixing #ifdef/#endif with 'else' can produce configurations where some branches become compile-time unreachable or where the final branch is forced to be taken. These two blocks (the entire HAVE_POLL block and the entire EPOLL_SUPPORT block) should be examined in context of all build configurations to ensure no branch is permanently unreachable.\n\n- The 'if (1) { ... }' final branch is a constant-true condition. Although in the present source it participates in the preprocessor-controlled else-if chain, a constant condition is a common source of unreachable-code issues (it may hide or make other branches unreachable depending on preprocessing). The whole final block (including the nested FD_SETSIZE/ MHD_DLOG section) should be reviewed.\n\n- The two mhd_assert(...) usages (one immediately after the early return check, and one inside the final block) are implemented as an empty macro (mhd_assert(ignore) ((void)0)). That means the expressions passed to mhd_assert are not evaluated in the compiled program; any code or side effects they contain are effectively removed and thus not executed. These assertion expressions should be checked because they may hide code that the author expected to run (or expected to guard runtime behaviour), which can lead to unreachable code or omitted checks.\n\nWhy other fragments were NOT selected:\n\n- The early return 'if ((daemon->shutdown) || MHD_D_IS_USING_THREADS_(daemon)) return MHD_NO;' is a runtime conditional that legitimately short-circuits the function for some daemon states. It is not compile-time unreachable and is intended behaviour, so it does not by itself indicate unreachable code.\n\n- The body of the poll/epoll/select chain (res = MHD_poll_all / MHD_epoll / MHD_select and the MHD_cleanup_connections calls) are runtime-selected branches (based on daemon->options) and are compiled in (HAVE_POLL and EPOLL_SUPPORT are defined in the provided macros). Because they can be selected at runtime depending on options, they are not inherently unreachable \u2014 only their reachability across different build configurations or with different macros needs inspection (hence the surrounding blocks are reported).\n\n- The MHD_DLOG function itself contains a safe early return (if the error-log option is not set) before any use of varargs; the implementation shown does not present an obvious unreachable-code issue by itself.\n\n- The conditional block guarded by HAS_FD_SETSIZE_OVERRIDABLE/HAVE_MESSAGES is included in the 'if (1)' fragment to be investigated. Note that HAS_FD_SETSIZE_OVERRIDABLE was not defined in the provided additional definitions, so that nested block will be excluded in that build \u2014 I included it because such nested #ifdefs can produce different reachability in other builds and are thus worth inspecting.\n\nIn summary: I flagged the preprocessor-driven else-if structure (HAVE_POLL / EPOLL_SUPPORT / final if (1)), the constant 'if (1)' final branch, and both mhd_assert uses because these are the places most likely to produce unreachable (or effectively removed) code across builds or cause code to be omitted at compile time. Other lines are runtime-dependent and do not look statically unreachable given the provided macro definitions."
}