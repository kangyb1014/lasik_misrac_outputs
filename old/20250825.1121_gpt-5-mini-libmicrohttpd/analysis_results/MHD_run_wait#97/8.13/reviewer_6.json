{
  "user_message": "An agent A claimed that the following MHD_run_wait code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_wait.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes a string literal through the _() macro into MHD_DLOG where the resulting pointer is effectively treated as a non-const char*. If either the _() macro (e.g. gettext) returns char * or MHD_DLOG's prototype takes a char * (non-const) for the format string, a pointer to a non-const-qualified type is used where a const-qualified pointer would be appropriate. This violates MISRA C 2023 Rule 8.13 (the format string should be a const char *).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a MISRA 8.13 violation from the snippet. MISRA C:2023 Rule 8.13 is about pointer declarations/prototypes: pointers should be to const-qualified types where possible. The call site in MHD_run_wait passes a string via the _() macro into MHD_DLOG, but the snippet does not show the declaration of MHD_DLOG nor the definition of the _() macro. If MHD_DLOG is declared to take a const char * (as is typical for format strings) then there is no violation. If MHD_DLOG were declared to take char * (non-const), that declaration \u2014 not this call site \u2014 would be what violates 8.13. Likewise, if _() expands to a function returning char * (e.g. historical gettext), that alone is not proof of a violation unless a non-const pointer type is used where const could have been used in a declaration.\n\nTherefore the agent\u2019s claim is speculative: it describes a possible scenario that would violate 8.13 (a non-const prototype for a function that should take const char *), but the provided code does not prove the violation. To decide definitively you must inspect the prototypes/definitions of MHD_DLOG and the _() macro/function."
}