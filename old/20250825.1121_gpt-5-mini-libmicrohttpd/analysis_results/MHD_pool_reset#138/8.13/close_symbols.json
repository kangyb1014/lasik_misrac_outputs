{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reset': {'callees': [], 'callers': ['transmit_error_response_len', 'connection_reset']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'connection_reset': {'callees': ['MHD_connection_close_', 'MHD_destroy_response', 'MHD_pool_reset'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (full definition)",
    "mp_ptr_le_ (declaration/prototype)",
    "mp_ptr_diff_ (declaration/prototype)",
    "_MHD_UNPOISON_MEMORY (macro or function declaration)",
    "_MHD_POISON_MEMORY (macro or function declaration)",
    "memmove (prototype from <string.h>)",
    "memset (prototype from <string.h>)",
    "__asan_region_is_poisoned (declaration/prototype, conditional)"
  ],
  "explanation": "- struct MemoryPool (full definition): Required to know the declared type of pool->memory (and types of pos, end, size, is_mmap). The const-qualification (or lack thereof) of pool->memory is central to determining whether pointers returned/used should be const.\n- mp_ptr_le_ (declaration/prototype): Used to test keep against pool->memory; its parameter types (const void * vs void *) inform whether keep is treated as a const pointer in other code and whether the helper expects const-qualified pointers.\n- mp_ptr_diff_ (declaration/prototype): Used in bounds arithmetic with keep and pool->memory; its parameter types indicate whether it expects/accepts const-qualified pointers and so bear on whether keep should be const.\n- _MHD_UNPOISON_MEMORY (macro or function declaration): This operates on memory regions; its signature shows whether it accepts const-qualified pointers or requires mutable pointers (i.e. whether passing a const pointer would be incompatible).\n- _MHD_POISON_MEMORY (macro or function declaration): Same rationale as UNPOISON: its parameter types show whether the code requires non-const pointers for poisoning operations.\n- memmove (prototype from <string.h>): memmove's parameters are (void *dest, const void *src, size_t). Knowing that the source is const supports changing keep's parameter type to const void * (if keep is only used as a source).\n- memset (prototype from <string.h>): Shows that destination must be mutable (void *), confirming that pool->memory must be non-const if it is being zeroed here.\n- __asan_region_is_poisoned (declaration/prototype, conditional): If present, this function is called with keep; its parameter types (likely const void *) affect whether keep may be const.\n\nCollectively these symbols show (1) whether pool->memory must be mutable (written by memset, memmove dest, poisoning macros) and (2) whether keep is only read (thus a candidate to be const) or is passed to functions that require non-const pointers. That is exactly what is needed to decide if the function violates the MISRA rule about qualifying pointers with const whenever possible."
}