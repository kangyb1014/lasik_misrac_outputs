{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reset': {'callees': [], 'callers': ['transmit_error_response_len', 'connection_reset']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'connection_reset': {'callees': ['MHD_connection_close_', 'MHD_destroy_response', 'MHD_pool_reset'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (definition: fields memory, size, pos, end, is_mmap)",
    "mp_ptr_le_ (macro/function)",
    "mp_ptr_diff_ (macro/function)",
    "mhd_assert (macro/function)",
    "_MHD_UNPOISON_MEMORY (macro/function)",
    "_MHD_POISON_MEMORY (macro/function)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE (macro)",
    "MHD_sys_page_size_ (value)",
    "VirtualFree, VirtualAlloc, MEM_DECOMMIT, MEM_COMMIT, PAGE_READWRITE (Win32 symbols/constants)",
    "abort (function)",
    "__asan_region_is_poisoned and MHD_ASAN_POISON_ACTIVE/HAVE___ASAN_REGION_IS_POISONED (ASAN symbols/macros)",
    "memmove (stdlib)",
    "memset (stdlib)",
    "transmit_error_response_len (caller)",
    "connection_reset (caller)",
    "definitions/locations where pool->memory and pool->size are initialized/allocated",
    "types: uint8_t, size_t, NULL"
  ],
  "explanation": "For a correct MISRA C assessment of whether memmove/memset use can access out-of-bounds memory you must be able to reason precisely about pointer values, object sizes, and any runtime checks that constrain them. Each listed symbol is required as follows:\n\n- struct MemoryPool (definition: fields memory, size, pos, end, is_mmap)\n  - You need the exact layout and types of pool->memory and pool->size (and is_mmap) to know the base pointer and the allocated object size against which memmove/memset are measured.\n\n- mp_ptr_le_ (macro/function)\n  - Used in an assertion to ensure keep is within pool->memory; you must know its semantics to determine whether the assertion actually bounds keep.\n\n- mp_ptr_diff_ (macro/function)\n  - Used to compute the byte offset of keep from pool->memory in an assertion that ensures copy_bytes fits; you must know how this computes differences (units, signed/unsigned behavior) to validate the bound math.\n\n- mhd_assert (macro/function)\n  - All the in-function safety checks are implemented with this macro. You must know whether it is active in the build (can be a no-op in release) and its side effects to determine whether the checks are enforced at runtime.\n\n- _MHD_UNPOISON_MEMORY and _MHD_POISON_MEMORY (macros/functions)\n  - These are invoked with addresses and sizes; their implementations might perform additional checks, change memory (ASAN/unpoison), or be no-ops. Understanding them is necessary to reason about any extra pointer checks or side effects and to ensure they don\u2019t silently touch out-of-range memory.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE (macro)\n  - Used to set pool->pos from new_size. While not directly used by memmove/memset, it affects later invariants and the poison range calculation (pos/new_size relations) \u2014 you need its definition to reason about arithmetic and potential overflow.\n\n- MHD_sys_page_size_ (value)\n  - Used to compute to_recommit (rounded page count). The page-size value affects to_recommit and thus to_zero; you need it to confirm the recomputation does not create OOB sizes when used with pool->size.\n\n- VirtualFree, VirtualAlloc, MEM_DECOMMIT, MEM_COMMIT, PAGE_READWRITE (Win32 symbols/constants)\n  - The Windows branch decommits/recommits pages and updates to_zero. To reason about the effect on memory ranges and whether memset/memmove operate in valid pages you must know the syscall semantics and flags used.\n\n- abort (function)\n  - Called on an unexpected VirtualAlloc failure; knowing this is only required to reason about control flow on failure (safety guarantees vs crash).\n\n- __asan_region_is_poisoned and MHD_ASAN_POISON_ACTIVE/HAVE___ASAN_REGION_IS_POISONED (ASAN symbols/macros)\n  - If ASAN checks are compiled in, they assert that keep region is not poisoned; you need these to know whether additional run-time safety validation occurs for the memmove source.\n\n- memmove (stdlib)\n  - The rule under analysis targets standard string/memory functions. You must reason about memmove\u2019s required constraints (destination and source regions of length copy_bytes must be valid and non-overflowing) and confirm the code meets them.\n\n- memset (stdlib)\n  - Same as memmove: you must check that the destination (&pool->memory[copy_bytes]) and length (to_zero) are within the allocated object bounds.\n\n- transmit_error_response_len (caller)\n  - One of the call sites of MHD_pool_reset. You need its implementation to see what new_size and keep/copy_bytes values it passes, to determine whether new_size <= pool->size (or other required invariants) are ensured by callers.\n\n- connection_reset (caller)\n  - The other call site of MHD_pool_reset; likewise needed to see argument values/constraints passed into the function in real call contexts.\n\n- definitions/locations where pool->memory and pool->size are initialized/allocated\n  - To establish the true allocated object bounds of pool->memory (how many bytes allocated) you must inspect the allocator/initialization sites that set pool->size and pool->memory. Without that you cannot conclude memmove/memset operate within the actual allocation.\n\n- types: uint8_t, size_t, NULL\n  - Required to reason about pointer arithmetic, integer under/overflow, and how sizes are interpreted in the code.\n\nTogether these symbols let an analyst determine whether the memmove and memset length and pointer expressions (copy_bytes, new_size, to_zero, pool->size, and computed offsets via mp_ptr_diff_) can cause reads or writes beyond the allocated object referenced by pool->memory, satisfying the evidence required by the MISRA rule check."
}