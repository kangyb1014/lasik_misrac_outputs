{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reset': {'callees': [], 'callers': ['transmit_error_response_len', 'connection_reset']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'connection_reset': {'callees': ['MHD_connection_close_', 'MHD_destroy_response', 'MHD_pool_reset'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (definition)",
    "mhd_assert (macro/function)",
    "mp_ptr_le_ (macro/inline)",
    "mp_ptr_diff_ (macro/inline)",
    "_MHD_UNPOISON_MEMORY (macro/function)",
    "_MHD_POISON_MEMORY (macro/function)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE (macro/function)",
    "memmove (symbol)",
    "memset (symbol)",
    "__asan_region_is_poisoned and related compile-time flags (MHD_ASAN_POISON_ACTIVE, HAVE___ASAN_REGION_IS_POISONED)",
    "VirtualFree (Windows API)",
    "VirtualAlloc (Windows API)",
    "abort (symbol)"
  ],
  "explanation": "You must inspect these symbols to decide whether MHD_pool_reset violates the MISRA rule forbidding modification of function parameters (the pointer variables pool and keep, and scalar parameters copy_bytes/new_size). For each symbol: \n\n- struct MemoryPool (definition): needed to confirm that assignments like pool->pos and pool->end modify the object pointed to by pool (allowed) and not the pool parameter itself (disallowed). Also to verify types of pool->memory, pool->size etc.\n\n- mhd_assert (macro/function): this is used repeatedly. If mhd_assert is a macro it could expand to code that assigns to a parameter variable (e.g. by using the parameter as an lvalue). You must inspect its definition to ensure it produces no assignment to pool, keep, copy_bytes, or new_size.\n\n- mp_ptr_le_ and mp_ptr_diff_ (macros/inlines): these are used in assertions and may be macros that manipulate pointer or integer arguments. Verify they do not assign to caller arguments (e.g. do not use them as lvalues or perform hidden assignment to parameters).\n\n- _MHD_UNPOISON_MEMORY and _MHD_POISON_MEMORY (macros/functions): these may be macros that expand to instrumentation code. Confirm they do not modify the pointer parameters or scalar parameters (they should operate on memory regions but must not reassign pool/keep/new_size/copy_bytes variables).\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE (macro/function): this computes pool->pos from new_size. If this macro is implemented in a way that writes to its argument (e.g. via side-effecting macro using the identifier as lvalue) it could modify new_size; you must check its definition to ensure it only returns a value and does not change the new_size parameter.\n\n- memmove and memset (symbols): standard functions but could be wrapped by project macros. Confirm their project-level definitions (if any) do not reassign the passed-in pointer variables (keep or &pool->memory) or scalar parameters.\n\n- __asan_region_is_poisoned and related flags (MHD_ASAN_POISON_ACTIVE, HAVE___ASAN_REGION_IS_POISONED): when enabled the function calls __asan_region_is_poisoned(keep, copy_bytes). Verify the implementation or macro wrappers do not perform assignments to keep or copy_bytes (unlikely, but must be confirmed because this conditional branch touches those parameters).\n\n- VirtualFree, VirtualAlloc (Windows API) and abort: these are called inside the _WIN32 block. Ensure any project wrappers or macros around these APIs do not reassign local parameters. Also inspect abort (or its wrapper) for unexpected side effects.\n\nIn short: inspect definitions of the struct and every macro/wrapper used in the function body. The goal is to prove no macro/inline/function used in the body performs an assignment to the parameter identifiers (pool, keep, copy_bytes, new_size). The listed symbols are the minimal set that can hide such side effects."
}