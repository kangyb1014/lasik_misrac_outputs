{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reset (struct MemoryPool *pool,\n                void *keep,\n                size_t copy_bytes,\n                size_t new_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (copy_bytes <= new_size);\n  mhd_assert (copy_bytes <= pool->size);\n  mhd_assert (keep != NULL || copy_bytes == 0);\n  mhd_assert (keep == NULL || mp_ptr_le_ (pool->memory, keep));\n  /* (keep == NULL || pool->memory + pool->size >= (uint8_t*) keep + copy_bytes) */\n  mhd_assert ((keep == NULL) || \\\n              (pool->size >= mp_ptr_diff_ (keep, pool->memory) + copy_bytes));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (keep, copy_bytes));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n  _MHD_UNPOISON_MEMORY (pool->memory, new_size);\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n  {\n    if (0 != copy_bytes)\n      memmove (pool->memory,\n               keep,\n               copy_bytes);\n  }\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n  {\n    size_t to_zero;   /** Size of area to zero-out */\n\n    to_zero = pool->size - copy_bytes;\n    _MHD_UNPOISON_MEMORY (pool->memory + copy_bytes, to_zero);\n#ifdef _WIN32\n    if (pool->is_mmap)\n    {\n      size_t to_recommit;     /** Size of decommitted and re-committed area. */\n      uint8_t *recommit_addr;\n      /* Round down to page size */\n      to_recommit = to_zero - to_zero % MHD_sys_page_size_;\n      recommit_addr = pool->memory + pool->size - to_recommit;\n\n      /* De-committing and re-committing again clear memory and make\n       * pages free / available for other needs until accessed. */\n      if (VirtualFree (recommit_addr,\n                       to_recommit,\n                       MEM_DECOMMIT))\n      {\n        to_zero -= to_recommit;\n\n        if (recommit_addr != VirtualAlloc (recommit_addr,\n                                           to_recommit,\n                                           MEM_COMMIT,\n                                           PAGE_READWRITE))\n          abort ();      /* Serious error, must never happen */\n      }\n    }\n#endif /* _WIN32 */\n    memset (&pool->memory[copy_bytes],\n            0,\n            to_zero);\n  }\n  pool->pos = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  pool->end = pool->size;\n  _MHD_POISON_MEMORY (((uint8_t *) pool->memory) + new_size, \\\n                      pool->size - new_size);\n  return pool->memory;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reset': {'callees': [], 'callers': ['transmit_error_response_len', 'connection_reset']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'connection_reset': {'callees': ['MHD_connection_close_', 'MHD_destroy_response', 'MHD_pool_reset'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "pool->is_mmap (field)",
    "mhd_assert",
    "mp_ptr_le_",
    "mp_ptr_diff_",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_UNPOISON_MEMORY",
    "_MHD_POISON_MEMORY",
    "MHD_ASAN_POISON_ACTIVE",
    "HAVE___ASAN_REGION_IS_POISONED",
    "__asan_region_is_poisoned",
    "_WIN32",
    "MHD_sys_page_size_",
    "VirtualFree",
    "VirtualAlloc",
    "MEM_DECOMMIT",
    "MEM_COMMIT",
    "PAGE_READWRITE",
    "NULL"
  ],
  "explanation": "For checking MISRA C rule \u201cControlling expressions shall not be invariant\u201d we must know which controlling expressions in MHD_pool_reset are compile-time or otherwise invariant. The following symbols are needed and why:\n\n- struct MemoryPool\n  - The function reads/writes pool->memory, pool->size, pool->pos, pool->end and pool->is_mmap. Knowing the struct layout and types (signed/unsigned integer widths, pointer types) is required to determine whether comparisons like (pool->size > copy_bytes) or (keep == pool->memory) are potentially constant/invariant.\n\n- pool->is_mmap (field)\n  - The Windows branch uses if (pool->is_mmap). To decide if that controlling expression can be invariant we need the field type and semantics (e.g. boolean, integer) and whether callers ever set it constant.\n\n- mhd_assert\n  - Many invariants are established by mhd_assert lines. Whether mhd_assert expands to code that introduces runtime controlling expressions (and whether it is enabled in the build) affects the set of controlling expressions present in the compiled function. We must inspect its definition to see if assertions become if()-type constructs that could themselves be invariant.\n\n- mp_ptr_le_\n  - Used in an assert (keep == NULL || mp_ptr_le_(pool->memory, keep)). Need its definition/semantics to know whether that assert is compile-time constant or implies other invariants on keep and pool->memory.\n\n- mp_ptr_diff_\n  - Used in an assert ((pool->size >= mp_ptr_diff_(keep, pool->memory) + copy_bytes)). Its definition/return type is needed to reason about pointer arithmetic and whether the resultant comparisons are invariant.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE\n  - Used to compute pool->pos. Its macro/definition could be a constant-foldable expression (compile-time invariant for given new_size) or introduce side effects; must know to decide whether any controlling expression that depends on pool->pos/new_size becomes invariant.\n\n- _MHD_UNPOISON_MEMORY and _MHD_POISON_MEMORY\n  - These macros/functions may be no-ops in some builds (so controls inside them disappear) or may contain controlling expressions or calls that affect invariance of surrounding code. Need their definitions to know whether they inject or remove controlling expressions.\n\n- MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED\n  - Preprocessor macros that control presence of the ASAN-related if/assert. Whether that #if is true changes whether __asan_region_is_poisoned appears in the compiled code; these are compile-time controlling conditions for inclusion of code and so affect whether any controlling expression is invariant in the final translation unit.\n\n- __asan_region_is_poisoned\n  - If the ASAN branch is compiled in, this function is used inside an assert controlling expression. Its prototype/semantics matter to know whether that expression is constant or not.\n\n- _WIN32\n  - Controls inclusion of the entire Windows-specific branch (VirtualFree/VirtualAlloc). Whether this is defined determines whether the Windows controlling expressions exist at all in the compiled function.\n\n- MHD_sys_page_size_\n  - Used to compute to_recommit (round-down to page size). Its value (compile-time constant or variable) matters to see whether to_recommit becomes zero invariantly and thus whether the subsequent if (VirtualFree(...)) or the earlier to_recommit computation is invariant.\n\n- VirtualFree and VirtualAlloc\n  - The return value of VirtualFree is used in an if() controlling expression. To determine if that controlling expression can be invariant we need the declaration/semantics and typical return domain (non-zero on success). Also VirtualAlloc is used in a following comparison; semantics needed to understand that controlling expression.\n\n- MEM_DECOMMIT, MEM_COMMIT, PAGE_READWRITE\n  - Constants passed to VirtualFree/VirtualAlloc. If any of these are defined such that calls are compile-time no-ops or stubbed, the control flow may change; their presence is needed to reason about the Windows branch\u2019s control expressions.\n\n- NULL\n  - The code tests keep against NULL; the definition/type of NULL (0 or ((void*)0)) is needed to reason about constant propagation and whether (NULL != keep) can be considered invariant in specific builds or translation units.\n\nNote: Standard library functions memmove, memset and abort are used but do not introduce controlling expressions whose invariance needs further symbols beyond the ones above (their semantics are standard). The list focuses on symbols that affect whether any of the if/assert controlling expressions can be considered invariant (compile-time constant or always true/false) in typical builds."
}