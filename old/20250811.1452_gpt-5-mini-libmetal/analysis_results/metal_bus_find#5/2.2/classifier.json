{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_bus_find code that contains useful probe functions that print useful logs to a file \"/tmp/logs/42.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_bus_find as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_bus_find:\n```c\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_bus_find:\nint metal_bus_register(struct metal_bus *bus)\n{\n\tif (!bus || !bus->name || !strlen(bus->name))\n\t\treturn -EINVAL;\n\tif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n\tmetal_list_init(&bus->devices);\n\tmetal_list_add_tail(&_metal.common.bus_list, &bus->node);\n\tmetal_log(METAL_LOG_DEBUG, \"registered %s bus\\n\", bus->name);\n\treturn 0;\n}\n...\nint metal_device_open(const char *bus_name, const char *dev_name,\n\t\t      struct metal_device **device)\n{\n\tstruct metal_bus *bus;\n\tint error;\n\n\tif (!bus_name || !strlen(bus_name) ||\n\t    !dev_name || !strlen(dev_name) ||\n\t    !device)\n\t\treturn -EINVAL;\n\n\terror = metal_bus_find(bus_name, &bus);\n\tif (error)\n\t\treturn error;\n\n\tif (!bus->ops.dev_open)\n\t\treturn -ENODEV;\n\n\terror = (*bus->ops.dev_open)(bus, dev_name, device);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n...\nvoid metal_linux_bus_finish(void)\n{\n\tstruct linux_bus *lbus;\n\tstruct metal_bus *bus;\n\n\tfor_each_linux_bus(lbus) {\n\t\tif (metal_bus_find(lbus->bus_name, &bus) == 0)\n\t\t\tmetal_bus_unregister(bus);\n\t}\n}\n...\nstatic int metal_linux_register_bus(struct linux_bus *lbus)\n{\n\tlbus->bus.name = lbus->bus_name;\n\tlbus->bus.ops  = metal_linux_bus_ops;\n\treturn metal_bus_register(&lbus->bus);\n}\n...\nvoid metal_sys_finish(void)\n{\n\n\t/* Shutdown IRQ handling */\n\tmetal_linux_irq_shutdown();\n\tmetal_linux_bus_finish();\n\tclose(_metal.pagemap_fd);\n\n}\n...\nstruct metal_bus {\n\tconst char\t\t*name;\n\tstruct metal_bus_ops\tops;\n\tstruct metal_list\tdevices;\n\tstruct metal_list\tnode;\n}\n...\nstruct metal_list {\n\tstruct metal_list *next, *prev;\n}\n</additional code>\nJudge whether the above metal_bus_find code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "Violation occurs when callers use metal_bus_find(bus->name, NULL) to check for existence (for example metal_bus_register). Because metal_bus_find only treats a found bus as success when the 'result' pointer is non-NULL (the condition '&& result'), calls with result == NULL will never observe success even when a matching bus exists. Thus the existence-check call in metal_bus_register (and similar calls) is effectively dead code: it is executed but cannot affect program behaviour (it will never return 0), so the project contains dead code in this usage scenario.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n    FILE *f = fopen(\"/tmp/logs/42.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"metal_bus_find called: name=\\\"%s\\\" result=%p\\n\",\n                (name ? name : \"(null)\"), (void *)result);\n    }\n\n    struct metal_list *node;\n    struct metal_bus *bus;\n\n    metal_list_for_each(&_metal.common.bus_list, node) {\n        bus = metal_container_of(node, struct metal_bus, node);\n\n        if (strcmp(bus->name, name) == 0) {\n            if (f) fprintf(f, \"  match found: bus=%p name=\\\"%s\\\" result=%p\\n\",\n                            (void *)bus, bus->name, (void *)result);\n\n            if (result) {\n                /* preserve original behaviour */\n                *result = bus;\n                if (f) fprintf(f, \"  assigned *result = %p, returning 0\\n\", (void *)bus);\n                if (f) fclose(f);\n                return 0;\n            }\n            if (f) fprintf(f, \"  result is NULL, skipping assignment and continuing search\\n\");\n        } else {\n            if (f) fprintf(f, \"  no match: bus->name=\\\"%s\\\"\\n\", bus->name);\n        }\n    }\n\n    if (f) {\n        fprintf(f, \"no matching bus found, returning -ENOENT\\n\");\n        fclose(f);\n    }\n\n    return -ENOENT;\n}\n"
}