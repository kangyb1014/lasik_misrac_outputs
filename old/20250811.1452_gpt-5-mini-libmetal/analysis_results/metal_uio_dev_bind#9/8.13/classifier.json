{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_bind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/75.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_bind as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_bind:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_bind:\nstruct linux_device {\n\tstruct metal_device\t\tdevice;\n\tchar\t\t\t\tdev_name[PATH_MAX];\n\tchar\t\t\t\tdev_path[PATH_MAX];\n\tchar\t\t\t\tcls_path[PATH_MAX];\n\tmetal_phys_addr_t\t\tregion_phys[METAL_MAX_DEVICE_REGIONS];\n\tstruct linux_driver\t\t*ldrv;\n\tstruct sysfs_device\t\t*sdev;\n\tstruct sysfs_attribute\t\t*override;\n\tint\t\t\t\tfd;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\nJudge whether the above metal_uio_dev_bind code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The function metal_uio_dev_bind takes a non-const pointer to struct linux_driver (struct linux_driver *ldrv) even though it only reads from the driver structure (reads drv_name and sdrv) and does not modify the driver object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type when possible (i.e., const struct linux_driver *ldrv). The current signature prevents conveying that the function will not modify the driver structure and thus violates Rule 8.13.",
  "test_code": "static int metal_uio_dev_bind(struct linux_device *ldev,\n                              struct linux_driver *ldrv)\n{\n    /* Logging to /tmp/logs/75.txt to trace control path and state for the violation scenario */\n    FILE *log = fopen(\"/tmp/logs/75.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter metal_uio_dev_bind: ldev=%p ldrv=%p dev_name=%s drv_name=%s\\n\",\n                (void *)ldev, (void *)ldrv,\n                (ldev && ldev->dev_name[0]) ? ldev->dev_name : \"(null)\",\n                (ldrv && ldrv->drv_name) ? ldrv->drv_name : \"(null)\");\n    }\n\n    struct sysfs_attribute *attr;\n    int result;\n\n    if (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0) {\n        if (log != NULL) {\n            fprintf(log, \"driver already bound: %s == %s -> return 0\\n\",\n                    ldev->sdev->driver_name, ldrv->drv_name);\n            fclose(log);\n        }\n        return 0;\n    }\n\n    if (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n        if (log != NULL) {\n            fprintf(log, \"device %s in use by driver %s -> -EBUSY\\n\",\n                    ldev->dev_name, ldev->sdev->driver_name);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        return -EBUSY;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"attempt to get device override attribute for %s\\n\", ldev->dev_name);\n    }\n\n    attr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n    if (!attr) {\n        if (log != NULL) {\n            fprintf(log, \"device %s has no override -> -errno(%d)\\n\", ldev->dev_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"device %s has no override\\n\", ldev->dev_name);\n        return -errno;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"writing driver name '%s' to device override for %s\\n\",\n                ldrv->drv_name, ldev->dev_name);\n    }\n\n    result = sysfs_write_attribute(attr, ldrv->drv_name,\n                                   strlen(ldrv->drv_name));\n    if (result) {\n        if (log != NULL) {\n            fprintf(log, \"failed to set override on %s -> -errno(%d)\\n\", ldev->dev_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\", ldev->dev_name);\n        return -errno;\n    }\n    ldev->override = attr;\n\n    if (log != NULL) {\n        fprintf(log, \"got device override attribute, attempt to get driver bind attribute for %s\\n\", ldrv->drv_name);\n    }\n\n    attr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n    if (!attr) {\n        if (log != NULL) {\n            fprintf(log, \"driver %s has no bind attribute -> -ENOTSUP\\n\", ldrv->drv_name);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n        return -ENOTSUP;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"writing device name '%s' to driver bind attribute for %s\\n\",\n                ldev->dev_name, ldrv->drv_name);\n    }\n\n    result = sysfs_write_attribute(attr, ldev->dev_name,\n                                   strlen(ldev->dev_name));\n    if (result) {\n        if (log != NULL) {\n            fprintf(log, \"failed to bind %s to %s -> -errno(%d)\\n\", ldev->dev_name, ldrv->drv_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n                  ldev->dev_name, ldrv->drv_name);\n        return -errno;\n    }\n\n    metal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n              ldev->dev_name, ldrv->drv_name);\n\n    if (log != NULL) {\n        fprintf(log, \"bound device %s to driver %s -> return 0\\n\",\n                ldev->dev_name, ldrv->drv_name);\n        fclose(log);\n    }\n\n    return 0;\n}\n"
}