{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_bind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/79.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_bind as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_bind:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_bind:\nstruct linux_device {\n\tstruct metal_device\t\tdevice;\n\tchar\t\t\t\tdev_name[PATH_MAX];\n\tchar\t\t\t\tdev_path[PATH_MAX];\n\tchar\t\t\t\tcls_path[PATH_MAX];\n\tmetal_phys_addr_t\t\tregion_phys[METAL_MAX_DEVICE_REGIONS];\n\tstruct linux_driver\t\t*ldrv;\n\tstruct sysfs_device\t\t*sdev;\n\tstruct sysfs_attribute\t\t*override;\n\tint\t\t\t\tfd;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\nJudge whether the above metal_uio_dev_bind code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If one of the string objects is not NUL-terminated within its allocated bounds (for example ldev->dev_name filled via strncpy without a terminating '\\0'), then the calls to strlen() and strcmp() in metal_uio_dev_bind can read past the object bounds. A concrete violation scenario is: ldev->dev_name (an array of size PATH_MAX) contains no NUL byte within the PATH_MAX bytes \u2014 calling strlen(ldev->dev_name) or strcmp(..., ldev->dev_name) will scan past the buffer and may access memory beyond the object bounds, violating MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\n#include <errno.h>\n#include <string.h>\n\n/* Minimal logging level symbols (original code uses macros elsewhere) */\nenum { METAL_LOG_INFO = 0, METAL_LOG_ERROR = 1, METAL_LOG_DEBUG = 2 };\n\n/* Minimal forward declarations / simple structs to make this TU compile */\nstruct sysfs_attribute { int dummy; };\nstruct sysfs_device { const char *driver_name; };\nstruct sysfs_driver { int dummy; };\n\n/* Provide SYSFS_UNKNOWN constant used in the original code. */\nstatic const char SYSFS_UNKNOWN[] = \"unknown\";\n\n/* Minimal linux_device and linux_driver definitions with the fields used. */\nstruct linux_driver {\n    const char *drv_name;\n    const char *mod_name;\n    const char *cls_name;\n    struct sysfs_driver *sdrv;\n    int (*dev_open)(void *, void *);\n    void (*dev_close)(void *, void *);\n    void (*dev_irq_ack)(void *, void *, int);\n    int (*dev_dma_map)(void *, void *, uint32_t, void *, int, void *);\n    void (*dev_dma_unmap)(void *, void *, uint32_t, void *, int);\n};\n\nstruct linux_device {\n    /* keep only fields used by metal_uio_dev_bind */\n    char dev_name[PATH_MAX];\n    struct linux_driver *ldrv;\n    struct sysfs_device *sdev;\n    struct sysfs_attribute *override;\n    int fd;\n};\n\n/* External functions used by metal_uio_dev_bind (declared but not defined here) */\nextern struct sysfs_attribute *sysfs_get_device_attr(struct sysfs_device *sd,\n                                                     const char *name);\nextern struct sysfs_attribute *sysfs_get_driver_attr(struct sysfs_driver *sd,\n                                                     const char *name);\nextern int sysfs_write_attribute(struct sysfs_attribute *attr,\n                                 const char *buf, size_t len);\nextern void metal_log(int level, const char *fmt, ...);\n\n/* Helper that scans for a NUL within a bounded number of bytes without using string.h helpers.\n   Returns the index of the NUL (i.e., strlen) if found, otherwise returns SIZE_MAX. */\nstatic size_t safe_find_nul(const char *s, size_t max)\n{\n    size_t i;\n    if (s == NULL) {\n        return SIZE_MAX;\n    }\n    for (i = 0U; i < max; ++i) {\n        if (s[i] == '\\0') {\n            return i;\n        }\n    }\n    return SIZE_MAX; /* NUL not found within bound */\n}\n\n/* Probe logger: append a compact record of the control path and string state to the log file.\n   This function avoids treating possibly unterminated strings as %s format arguments. */\nstatic void probe_log_state(const char *stage,\n                            struct linux_device *ldev,\n                            struct linux_driver *ldrv)\n{\n    FILE *f = fopen(\"/tmp/logs/79.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"STAGE: %s\\n\", stage);\n    if (ldev) {\n        fprintf(f, \" ldev=%p\\n\", (void *)ldev);\n        /* dev_name is a fixed-size array PATH_MAX: check for NUL within PATH_MAX */\n        size_t dlen = safe_find_nul(ldev->dev_name, (size_t)PATH_MAX);\n        if (dlen == SIZE_MAX) {\n            fprintf(f, \"  dev_name: NO_NUL_WITHIN_PATH_MAX (address=%p)\\n\", (void *)ldev->dev_name);\n            /* Log a bounded preview to avoid overrun when printing */\n            fprintf(f, \"  dev_name[0..15]=\");\n            fwrite(ldev->dev_name, 1, (size_t)16 < (size_t)PATH_MAX ? 16 : (size_t)PATH_MAX, f);\n            fprintf(f, \"\\n\");\n        } else {\n            fprintf(f, \"  dev_name (len=%zu): \", dlen);\n            fwrite(ldev->dev_name, 1, dlen, f);\n            fprintf(f, \"\\n\");\n        }\n        fprintf(f, \"  override=%p\\n\", (void *)ldev->override);\n        if (ldev->sdev) {\n            /* For sdev->driver_name we don't know its allocated size here; scan conservatively */\n            const char *dname = ldev->sdev->driver_name;\n            size_t max_scan = 256U;\n            size_t slen = safe_find_nul(dname, max_scan);\n            if (slen == SIZE_MAX) {\n                fprintf(f, \"  sdev->driver_name: NO_NUL_WITHIN_%zu\\n\", max_scan);\n            } else {\n                fprintf(f, \"  sdev->driver_name (len=%zu): \", slen);\n                fwrite(dname, 1, slen, f);\n                fprintf(f, \"\\n\");\n            }\n            fprintf(f, \"  sdev=%p\\n\", (void *)ldev->sdev);\n        } else {\n            fprintf(f, \"  sdev=NULL\\n\");\n        }\n    } else {\n        fprintf(f, \" ldev=NULL\\n\");\n    }\n\n    if (ldrv) {\n        fprintf(f, \" ldrv=%p\\n\", (void *)ldrv);\n        if (ldrv->drv_name) {\n            const char *d = ldrv->drv_name;\n            size_t max_scan = 256U;\n            size_t slen = safe_find_nul(d, max_scan);\n            if (slen == SIZE_MAX) {\n                fprintf(f, \"  drv_name: NO_NUL_WITHIN_%zu\\n\", max_scan);\n            } else {\n                fprintf(f, \"  drv_name (len=%zu): \", slen);\n                fwrite(d, 1, slen, f);\n                fprintf(f, \"\\n\");\n            }\n        } else {\n            fprintf(f, \"  drv_name=NULL\\n\");\n        }\n    } else {\n        fprintf(f, \" ldrv=NULL\\n\");\n    }\n\n    fprintf(f, \"----\\n\");\n    fclose(f);\n}\n\n/* The instrumented metal_uio_dev_bind: preserves original control flow and calls, but adds\n   logging probes to /tmp/logs/79.txt that document the state just before string operations.\n   Note: the original strcmp/strlen calls remain to preserve the original logic and thereby\n   to demonstrate the potential violation when input strings are not properly NUL-terminated. */\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n                              struct linux_driver *ldrv)\n{\n    struct sysfs_attribute *attr;\n    int result;\n\n    /* Probe before first strcmp */\n    probe_log_state(\"entry_before_cmp_driver_names\", ldev, ldrv);\n\n    if (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n        return 0;\n\n    /* Probe before comparing against SYSFS_UNKNOWN */\n    probe_log_state(\"before_cmp_sysfs_unknown\", ldev, ldrv);\n\n    if (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n        metal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        return -EBUSY;\n    }\n\n    attr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n    if (!attr) {\n        metal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n\n    /* Probe immediately before writing the driver name using strlen */\n    probe_log_state(\"before_strlen_drv_name\", ldev, ldrv);\n\n    result = sysfs_write_attribute(attr, ldrv->drv_name,\n                                   strlen(ldrv->drv_name));\n    if (result) {\n        metal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n    ldev->override = attr;\n\n    attr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n    if (!attr) {\n        metal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n        return -ENOTSUP;\n    }\n\n    /* Probe immediately before writing the device name using strlen */\n    probe_log_state(\"before_strlen_dev_name\", ldev, ldrv);\n\n    result = sysfs_write_attribute(attr, ldev->dev_name,\n                                   strlen(ldev->dev_name));\n    if (result) {\n        metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n                  ldev->dev_name, ldrv->drv_name);\n        return -errno;\n    }\n\n    metal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n              ldev->dev_name, ldrv->drv_name);\n\n    return 0;\n}\n"
}