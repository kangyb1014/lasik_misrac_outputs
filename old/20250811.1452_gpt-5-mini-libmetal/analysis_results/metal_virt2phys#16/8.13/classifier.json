{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_virt2phys code that contains useful probe functions that print useful logs to a file \"/tmp/logs/131.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_virt2phys as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_virt2phys:\n```c\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_virt2phys:\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n...\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nextern struct metal_state _metal\n</additional code>\nJudge whether the above metal_virt2phys code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "metal_virt2phys takes a non-const void *addr even though the function only reads from the address (it converts the pointer to an integer and does not modify the pointee). This violates MISRA C 2023 Rule 8.13 which requires a pointer to be const-qualified whenever possible. A concrete call-site is in metal_shmem_try_map where metal_virt2phys(virt + offset, &phys[page]) passes a non-const pointer to a function that does not modify the referenced memory.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <inttypes.h>\n\n/* Minimal struct layout used by the function; the real definition\n   is expected to come from the rest of the project. */\nstruct metal_state {\n    int pagemap_fd;\n    unsigned int page_shift;\n};\n\nextern struct metal_state _metal;\n\n/* Original function instrumented with probes that write control-path\n   and state information to /tmp/logs/131.txt. The logic is preserved. */\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n    off_t offset;\n    uint64_t entry;\n    int error;\n    FILE *logf;\n\n    /* Open log file for append; ignore errors but continue to preserve logic. */\n    logf = fopen(\"/tmp/logs/131.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"metal_virt2phys: entered (addr=%p, phys=%p)\\n\", addr, (void *)phys);\n        fflush(logf);\n    }\n\n    if (_metal.pagemap_fd < 0) {\n        if (logf) {\n            fprintf(logf, \"metal_virt2phys: pagemap_fd < 0 (%d) -> return -EINVAL\\n\", _metal.pagemap_fd);\n            fclose(logf);\n        }\n        return -EINVAL;\n    }\n\n    offset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n    if (logf) {\n        fprintf(logf, \"metal_virt2phys: computed offset = 0x%llx (page_shift=%u)\\n\",\n                (unsigned long long)offset, _metal.page_shift);\n        fflush(logf);\n    }\n\n    error = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n    if (error < 0) {\n        if (logf) {\n            fprintf(logf, \"metal_virt2phys: pread failed (offset=0x%llx) - %s (errno=%d)\\n\",\n                    (unsigned long long)offset, strerror(errno), errno);\n            fclose(logf);\n        }\n        return -errno;\n    }\n\n    if (logf) {\n        fprintf(logf, \"metal_virt2phys: pagemap entry read = 0x%llx\\n\", (unsigned long long)entry);\n        fflush(logf);\n    }\n\n    /* Check page present and not swapped. */\n    if ((entry >> 62) != 2) {\n        if (logf) {\n            fprintf(logf, \"metal_virt2phys: page not present/swapped (offset=0x%llx, entry=0x%llx) -> return -ENOENT\\n\",\n                    (unsigned long long)offset, (unsigned long long)entry);\n            fclose(logf);\n        }\n        return -ENOENT;\n    }\n\n    *phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\n    if (logf) {\n        fprintf(logf, \"metal_virt2phys: resolved phys = 0x%lx\\n\", *phys);\n        fprintf(logf, \"metal_virt2phys: exit success (return 0)\\n\");\n        fclose(logf);\n    }\n\n    return 0;\n}\n"
}