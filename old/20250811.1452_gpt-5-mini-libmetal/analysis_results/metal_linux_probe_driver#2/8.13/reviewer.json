{
  "user_message": "An agent A claimed that the following metal_linux_probe_driver code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_driver.\n```c\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function metal_linux_probe_driver takes a non-const pointer to struct linux_bus (struct linux_bus *lbus) even though it does not modify the linux_bus object. According to MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible. Here lbus should be declared as const struct linux_bus *lbus because the function only reads from it. Keeping it non-const violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n                                    struct linux_driver *ldrv)\n{\n    char command[256];\n    int ret;\n    FILE *logf = fopen(\"/tmp/logs/19.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"ENTER %s: lbus=%p ldrv=%p bus_name=%s drv_name=%s sdrv=%p\\n\",\n                __func__, (void *)lbus, (void *)ldrv,\n                lbus ? lbus->bus_name : \"(null)\",\n                ldrv ? ldrv->drv_name : \"(null)\",\n                ldrv ? (void *)ldrv->sdrv : (void *)NULL);\n        fflush(logf);\n    }\n\n    /* Try probing the module and then open the driver. */\n    if (!ldrv->sdrv) {\n        ret = snprintf(command, sizeof(command),\n                       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n        if (logf) fprintf(logf, \"after snprintf1: ret=%d command='%s'\\n\", ret, command);\n        if (ret >= (int)sizeof(command)) {\n            if (logf) fprintf(logf, \"snprintf overflow detected, returning -EOVERFLOW\\n\");\n            if (logf) fclose(logf);\n            return -EOVERFLOW;\n        }\n        ret = system(command);\n        if (logf) fprintf(logf, \"system(modprobe) returned %d\\n\", ret);\n        if (ret < 0) {\n            if (logf) fprintf(logf, \"%s: executing system command '%s' failed.\\n\",\n                             __func__, command);\n        }\n        ldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n        if (logf) fprintf(logf, \"after first sysfs_open_driver: sdrv=%p\\n\", (void *)ldrv->sdrv);\n    }\n\n    /* Try sudo probing the module and then open the driver. */\n    if (!ldrv->sdrv) {\n        ret = snprintf(command, sizeof(command),\n                       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n        if (logf) fprintf(logf, \"after snprintf2: ret=%d command='%s'\\n\", ret, command);\n        if (ret >= (int)sizeof(command)) {\n            if (logf) fprintf(logf, \"snprintf overflow detected, returning -EOVERFLOW\\n\");\n            if (logf) fclose(logf);\n            return -EOVERFLOW;\n        }\n        ret = system(command);\n        if (logf) fprintf(logf, \"system(sudo modprobe) returned %d\\n\", ret);\n        if (ret < 0) {\n            if (logf) fprintf(logf, \"%s: executing system command '%s' failed.\\n\",\n                             __func__, command);\n        }\n        ldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n        if (logf) fprintf(logf, \"after second sysfs_open_driver: sdrv=%p\\n\", (void *)ldrv->sdrv);\n    }\n\n    /* If all else fails... */\n    ret = ldrv->sdrv ? 0 : -ENODEV;\n    if (logf) {\n        fprintf(logf, \"EXIT %s: final sdrv=%p return=%d\\n\", __func__, (void *)ldrv->sdrv, ret);\n        fclose(logf);\n    }\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown code metal_linux_probe_driver does not modify the linux_bus object: it only reads lbus->bus_name to build commands and to call sysfs_open_driver (it never assigns through lbus). According to MISRA C 2023 Rule 8.13 a pointer parameter should be const-qualified whenever possible, so the parameter could (and should, per the rule) be declared as const struct linux_bus *lbus. Note that ldrv must remain non-const because the function assigns ldrv->sdrv. Also be aware that changing the prototype requires updating all callers/definitions across translation units; and that qualifying the struct pointer as const does not automatically make its member types const. The agent A\u2019s claim is therefore correct."
}