{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_generic_dev_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/71.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_generic_dev_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_generic_dev_open:\n```c\nint metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,\n\t\t\t   struct metal_device **device)\n{\n\tstruct metal_list *node;\n\tstruct metal_device *dev;\n\n\t(void)bus;\n\n\tmetal_list_for_each(&_metal.common.generic_device_list, node) {\n\t\tdev = metal_container_of(node, struct metal_device, node);\n\t\tif (strcmp(dev->name, dev_name) == 0) {\n\t\t\t*device = dev;\n\t\t\treturn metal_generic_dev_sys_open(dev);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n```\n</target_code>\nJudge whether the above metal_generic_dev_open code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If a device name buffer is not NUL-terminated (for example a fixed-size char array filled exactly with characters and no '\\0'), calling strcmp(dev->name, dev_name) may read past the end of that buffer while searching for the terminator, causing an out-of-bounds access. In such a case the call to strcmp in metal_generic_dev_open violates MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <errno.h>\n\n/* Minimal compatible type definitions to preserve the original logic. */\nstruct metal_list {\n    struct metal_list *next;\n};\n\nstruct metal_device {\n    struct metal_list node; /* embedded list node as in original */\n    char *name;\n};\n\nstruct metal_common {\n    struct metal_list *generic_device_list;\n};\n\n/* Global that mimics the original location of the list head. */\nstruct {\n    struct metal_common common;\n} _metal = { { NULL } };\n\n/* Forward declarations to preserve original function signature and behavior. */\nstruct metal_bus;\nextern int metal_generic_dev_sys_open(struct metal_device *dev);\n\nint metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,\n                           struct metal_device **device)\n{\n    struct metal_list *node;\n    struct metal_device *dev;\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n\n    if (log != NULL) {\n        fprintf(log, \"enter metal_generic_dev_open: bus=%p dev_name=%p\\n\",\n                (void *)bus, (const void *)dev_name);\n    }\n\n    (void)bus;\n\n    /* Iterate the device list (preserving original logic). */\n    node = _metal.common.generic_device_list;\n    while (node != NULL) {\n        /* Compute pointer to containing metal_device from the embedded node. */\n        dev = (struct metal_device *)((char *)node - offsetof(struct metal_device, node));\n\n        if (log != NULL) {\n            fprintf(log, \"visiting node=%p dev=%p dev->name=%p\\n\",\n                    (void *)node, (void *)dev, (const void *)dev->name);\n        }\n\n        /*\n         * Original comparison is kept intact. If dev->name is not NUL-terminated,\n         * strcmp can read past dev->name's buffer bounds searching for '\\0',\n         * producing an out-of-bounds access (the violation scenario).\n         */\n        if (strcmp(dev->name, dev_name) == 0) {\n            *device = dev;\n\n            if (log != NULL) {\n                fprintf(log, \"match found: dev=%p name=\\\"%s\\\"\\n\",\n                        (void *)dev, dev->name ? dev->name : \"(null)\");\n                fprintf(log, \"calling metal_generic_dev_sys_open(dev=%p)\\n\", (void *)dev);\n            }\n\n            if (log != NULL) {\n                fclose(log);\n            }\n\n            return metal_generic_dev_sys_open(dev);\n        }\n\n        if (log != NULL) {\n            fprintf(log, \"no match for this device\\n\");\n        }\n\n        node = node->next;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"no device matched; returning -ENODEV\\n\");\n        fclose(log);\n    }\n\n    return -ENODEV;\n}\n"
}