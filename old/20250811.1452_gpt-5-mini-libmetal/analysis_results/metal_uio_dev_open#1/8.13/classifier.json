{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/11.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_open:\n```c\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n```\n</target_code>\nJudge whether the above metal_uio_dev_open code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The local variable 'instance' is declared as 'char *instance' but is only used for read-only string operations (passed to snprintf and not modified). According to MISRA C 2023 Rule 8.13, such a pointer should be to a const-qualified type (const char *). Thus the code violates Rule 8.13 by not qualifying 'instance' as pointing to const when possible.",
  "test_code": "#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n    FILE *logf = fopen(\"/tmp/logs/11.txt\", \"a\");\n    char *instance, path[SYSFS_PATH_MAX];\n    struct linux_driver *ldrv = ldev->ldrv;\n    unsigned long *phys, offset = 0, size = 0;\n    struct metal_io_region *io;\n    struct dlist *dlist;\n    int result, i;\n    void *virt;\n    int irq_info;\n\n    if (logf) {\n        fprintf(logf, \"enter: metal_uio_dev_open for %s:%s\\n\", lbus->bus_name, ldev->dev_name);\n        fprintf(logf, \"NOTE: 'instance' is declared as 'char *' (non-const) and used read-only \u2014 potential Rule 8.13 violation.\\n\");\n        fflush(logf);\n    }\n\n    ldev->fd = -1;\n    ldev->device.irq_info = (void *)-1;\n\n    ldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n    if (!ldev->sdev) {\n        if (logf) {\n            fprintf(logf, \"sysfs_open_device failed for %s:%s\\n\", lbus->bus_name, ldev->dev_name);\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n                  lbus->bus_name, ldev->dev_name);\n        return -ENODEV;\n    }\n    if (logf) {\n        fprintf(logf, \"opened sysfs device %s (%s)\\n\", ldev->sdev->path, ldev->dev_name);\n        fflush(logf);\n    }\n    metal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n              lbus->bus_name, ldev->dev_name);\n\n    result = metal_uio_dev_bind(ldev, ldrv);\n    if (result) {\n        if (logf) {\n            fprintf(logf, \"metal_uio_dev_bind failed: %d\\n\", result);\n            fclose(logf);\n        }\n        return result;\n    }\n\n    result = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n    if (result >= (int)sizeof(path)) {\n        if (logf) {\n            fprintf(logf, \"snprintf overflow building path (%d >= %zu)\\n\", result, sizeof(path));\n            fclose(logf);\n        }\n        return -EOVERFLOW;\n    }\n    dlist = sysfs_open_directory_list(path);\n    if (!dlist) {\n        if (logf) {\n            fprintf(logf, \"failed to scan class path %s\\n\", path);\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n                  path);\n        return -errno;\n    }\n\n    /* Probe: record that 'instance' is assigned from the directory list. */\n    dlist_for_each_data(dlist, instance, char) {\n        if (logf) {\n            fprintf(logf, \"dlist instance found: '%s' (pointer %p)\\n\", instance ? instance : \"(null)\", (void *)instance);\n            fprintf(logf, \"(Pointer 'instance' remains non-const in this code path \u2014 candidate for 'const char *')\\n\");\n            fflush(logf);\n        }\n\n        result = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n                          \"%s/%s\", path, instance);\n        if (result >= (int)sizeof(ldev->cls_path)) {\n            if (logf) {\n                fprintf(logf, \"snprintf overflow building cls_path\\n\");\n                fclose(logf);\n            }\n            return -EOVERFLOW;\n        }\n        result = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n                          \"/dev/%s\", instance);\n        if (result >= (int)sizeof(ldev->dev_path)) {\n            if (logf) {\n                fprintf(logf, \"snprintf overflow building dev_path\\n\");\n                fclose(logf);\n            }\n            return -EOVERFLOW;\n        }\n        break;\n    }\n    sysfs_close_list(dlist);\n\n    if (sysfs_path_is_dir(ldev->cls_path) != 0) {\n        if (logf) {\n            fprintf(logf, \"invalid device class path %s\\n\", ldev->cls_path);\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n                  ldev->cls_path);\n        return -ENODEV;\n    }\n\n    i = 0;\n    do {\n        if (!access(ldev->dev_path, F_OK))\n            break;\n        usleep(10);\n        i++;\n    } while (i < 1000);\n    if (i >= 1000) {\n        if (logf) {\n            fprintf(logf, \"timeout waiting for %s after %d tries\\n\", ldev->dev_path, i);\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n                  ldev->dev_path);\n        return -ENODEV;\n    }\n    result = metal_open(ldev->dev_path, 0);\n    if (result < 0) {\n        if (logf) {\n            fprintf(logf, \"metal_open failed for %s: %s\\n\", ldev->dev_path, strerror(-result));\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n                  ldev->dev_path, strerror(-result));\n        return result;\n    }\n    ldev->fd = result;\n\n    if (logf) {\n        fprintf(logf, \"device opened fd=%d path=%s\\n\", ldev->fd, ldev->dev_path);\n        fflush(logf);\n    }\n\n    metal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n              lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n    for (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n        phys = &ldev->region_phys[ldev->device.num_regions];\n        result = (result ? result :\n                 metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n        result = (result ? result :\n                 metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n        result = (result ? result :\n                 metal_uio_read_map_attr(ldev, i, \"size\", &size));\n        result = (result ? result :\n                 metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n        if (!result) {\n            io = &ldev->device.regions[ldev->device.num_regions];\n            metal_io_init(io, virt, phys, size, -1, 0, NULL);\n            ldev->device.num_regions++;\n            if (logf) {\n                fprintf(logf, \"mapped region %d: phys=%lu size=%lu virt=%p\\n\",\n                        ldev->device.num_regions - 1, (unsigned long)*phys, (unsigned long)size, virt);\n                fflush(logf);\n            }\n        }\n    }\n\n    irq_info = 1;\n    if (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n        if (logf) {\n            fprintf(logf, \"%s: No IRQ for device %s.\\n\", __func__, ldev->dev_name);\n            fclose(logf);\n        }\n        metal_log(METAL_LOG_INFO,\n                  \"%s: No IRQ for device %s.\\n\",\n                  __func__, ldev->dev_name);\n        ldev->device.irq_num =  0;\n        ldev->device.irq_info = (void *)-1;\n    } else {\n        ldev->device.irq_num =  1;\n        ldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n        metal_linux_irq_register_dev(&ldev->device, ldev->fd);\n        if (logf) {\n            fprintf(logf, \"IRQ registered, irq_num=%d irq_info=%p\\n\", ldev->device.irq_num, ldev->device.irq_info);\n            fclose(logf);\n        }\n    }\n\n    return 0;\n}\n"
}