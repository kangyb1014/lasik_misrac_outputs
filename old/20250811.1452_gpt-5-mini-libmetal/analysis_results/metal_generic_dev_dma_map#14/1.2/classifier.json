{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_generic_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/112.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_generic_dev_dma_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_generic_dev_dma_map:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_generic_dev_dma_map:\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n...\n#define METAL_DMA_DEV_W 2\n...\nstruct metal_device {\n\tconst char             *name;       /**< Device name */\n\tstruct metal_bus       *bus;        /**< Bus that contains device */\n\tunsigned int           num_regions; /**< Number of I/O regions in\n\t\t\t\t\t\t device */\n\tstruct metal_io_region regions[METAL_MAX_DEVICE_REGIONS]; /**< Array of\n\t\t\t\t\t\t\tI/O regions in device*/\n\tstruct metal_list      node;       /**< Node on bus' list of devices */\n\tint                    irq_num;    /**< Number of IRQs per device */\n\tvoid                   *irq_info;  /**< IRQ ID */\n}\n...\nstruct metal_bus {\n\tconst char\t\t*name;\n\tstruct metal_bus_ops\tops;\n\tstruct metal_list\tdevices;\n\tstruct metal_list\tnode;\n}\n</additional code>\nJudge whether the above metal_generic_dev_dma_map code violates the rule 1.2 or not.",
  "is_rule_violated": false,
  "scenario": "No language extensions detected. The function uses only standard C constructs (casts to void, standard library memcpy, standard types like uint32_t). No compiler-specific extensions (e.g. __attribute__, asm, typeof, statement expressions, nested functions) are present, so Rule 1.2 is not violated.",
  "test_code": ""
}