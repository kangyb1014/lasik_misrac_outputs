{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg",
    "METAL_DMA_DEV_W",
    "metal_cache_flush",
    "metal_cache_invalidate",
    "memcpy",
    "uint32_t",
    "struct metal_device",
    "struct metal_bus"
  ],
  "explanation": "struct metal_sg: The layout and member declarations (types of virt and len, presence of bit-fields, flexible array member, or compiler-specific attributes such as __attribute__((packed/aligned)) or compiler extensions) must be inspected to detect any language extensions used in the type definition and to ensure member access is standard C.\n\nMETAL_DMA_DEV_W: This macro may expand to compiler-specific tokens or use extension syntax (e.g. __extension__, GCC-specific constants, or pragma-like constructs). Its definition is needed to confirm it is a plain integral constant and not an extension.\n\nmetal_cache_flush (declaration/definition): The callee may be a macro or function annotated with compiler extensions (attributes, inline asm, builtin intrinsics, __attribute__, __asm__, or nonstandard calling conventions). Its prototype/definition must be checked to detect any language-extension usage that affects the caller or the call site semantics.\n\nmetal_cache_invalidate (declaration/definition): Same rationale as metal_cache_flush \u2014 its declaration/definition may contain compiler-specific extensions or macros that would make the call site depend on extensions.\n\nmemcpy (declaration/definition): Standard library implementations sometimes use compiler builtins or macros (e.g. __builtin_memcpy) or attributes; verify that the memcpy used here is the standard declaration and not a compiler-specific extension or macro.\n\nuint32_t (typedef/origin): Confirm whether uint32_t comes from a standard header (stdint.h) or from a compiler/SDK extension/type alias. If it is provided via a compiler extension, that could violate the rule.\n\nstruct metal_device and struct metal_bus (definitions): Although unused in the body, their definitions could include compiler-specific attributes or extensions. Their declarations should be checked to ensure no language extensions appear in parameter types.\n\nChecking these symbols (their macros, typedefs, declarations and definitions) is sufficient to determine whether the target function uses any compiler language extensions directly or via types/macros/callees it relies on."
}