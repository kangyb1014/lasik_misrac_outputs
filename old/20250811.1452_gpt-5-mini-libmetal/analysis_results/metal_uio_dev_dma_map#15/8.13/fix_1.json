{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef unsigned long metal_phys_addr_t;\nstruct metal_io_ops { /* empty; preserved as in original context */ };\nstruct metal_io_region {\n    void                    *virt;      /* base virtual address */\n    const metal_phys_addr_t *physmap;   /* table of base physical addresses */\n    size_t                  size;       /* size of the I/O region */\n    unsigned long           page_shift;\n    metal_phys_addr_t       page_mask;\n    unsigned int            mem_flags;\n    struct metal_io_ops     ops;\n};\nstruct metal_sg {\n    void *virt;                  /* CPU virtual address */\n    struct metal_io_region *io;  /* IO region */\n    int len;                     /* length */\n};\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    /* Use char * for address arithmetic while preserving original logic */\n    void *vaddr_sg_lo = NULL;\n    void *vaddr_sg_hi = NULL;\n    void *vaddr_lo = NULL;\n    void *vaddr_hi = NULL;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Open log file to record the control path and state information */\n    FILE *log = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter: %s, dev=%s, nents_in=%d\\n\", __func__,\n                (ldev != NULL) ? ldev->dev_name : \"(null)\", nents_in);\n    }\n\n    /* Check if the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* preserve original semantics: compute start and end addresses */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + sg_in[i].len;\n\n        if (log != NULL) {\n            fprintf(log, \"sg[%d]: virt=%p, len=%d, roi=[%p,%p)\\n\",\n                    i, vaddr_sg_lo, sg_in[i].len, vaddr_sg_lo, vaddr_sg_hi);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n\n            if (log != NULL) {\n                fprintf(log, \"  region[%d]: virt=%p, size=%zu, r=[%p,%p)\\n\",\n                        j, vaddr_lo, io->size, vaddr_lo, vaddr_hi);\n            }\n\n            if (vaddr_sg_lo >= vaddr_lo && vaddr_sg_hi <= vaddr_hi) {\n                if (log != NULL) {\n                    fprintf(log, \"  match: sg[%d] in region[%d]\\n\", i, j);\n                }\n                break;\n            }\n        }\n\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the warning and the failing addresses */\n            if (log != NULL) {\n                fprintf(log, \"warning: %s,%s: input address isn't MMIO addr: %p,%d.\\n\",\n                        __func__, (ldev != NULL) ? ldev->dev_name : \"(null)\",\n                        vaddr_sg_lo, sg_in[i].len);\n                /* Also log that sg_in was only read and not modified, demonstrating\n                 * that sg_in could be const-qualified (MISRA C Rule 8.13 scenario).\n                 */\n                fprintf(log, \"note: sg_in was not modified by %s; parameter is non-const -> Rule 8.13 violation scenario.\\n\",\n                        __func__);\n                fclose(log);\n            }\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* preserve original behavior: copy descriptors */\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n        if (log != NULL) {\n            fprintf(log, \"copied %d sg descriptors from %p to %p\\n\",\n                    nents_in, (void *)sg_in, (void *)sg_out);\n        }\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"exit: %s returning %d\\n\", __func__, nents_in);\n        fclose(log);\n    }\n\n    return nents_in;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\n/tmp/tmp1ujypdms/src/lib/system/linux/device.c:322:8: error: redefinition of 'struct metal_io_ops'\n  322 | struct metal_io_ops { /* empty; preserved as in original context */ };\n      |        ^~~~~~~~~~~~\nIn file included from /tmp/tmp1ujypdms/build/lib/include/metal/device.h:16,\n                 from /tmp/tmp1ujypdms/src/lib/system/linux/device.c:22:\n/tmp/tmp1ujypdms/build/lib/include/metal/io.h:40:8: note: originally defined here\n   40 | struct metal_io_ops {\n      |        ^~~~~~~~~~~~\n/tmp/tmp1ujypdms/src/lib/system/linux/device.c:323:8: error: redefinition of 'struct metal_io_region'\n  323 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\nIn file included from /tmp/tmp1ujypdms/build/lib/include/metal/device.h:16,\n                 from /tmp/tmp1ujypdms/src/lib/system/linux/device.c:22:\n/tmp/tmp1ujypdms/build/lib/include/metal/io.h:73:8: note: originally defined here\n   73 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\n/tmp/tmp1ujypdms/src/lib/system/linux/device.c:332:8: error: redefinition of 'struct metal_sg'\n  332 | struct metal_sg {\n      |        ^~~~~~~~\nIn file included from /tmp/tmp1ujypdms/build/lib/include/metal/device.h:18,\n                 from /tmp/tmp1ujypdms/src/lib/system/linux/device.c:22:\n/tmp/tmp1ujypdms/build/lib/include/metal/dma.h:33:8: note: originally defined here\n   33 | struct metal_sg {\n      |        ^~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:216: lib/CMakeFiles/metal-shared.dir/system/linux/device.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n\n/* Forward declarations to avoid redefinition of types that are provided\n * by the project's headers (they are included elsewhere in the build).\n */\nstruct linux_bus;\nstruct linux_device;\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    /* Use char * for address arithmetic while preserving original logic */\n    void *vaddr_sg_lo = NULL;\n    void *vaddr_sg_hi = NULL;\n    void *vaddr_lo = NULL;\n    void *vaddr_hi = NULL;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Open log file to record the control path and state information */\n    FILE *log = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter: %s, dev=%s, nents_in=%d\\n\", __func__,\n                (ldev != NULL) ? ldev->dev_name : \"(null)\", nents_in);\n    }\n\n    /* Check if the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* preserve original semantics: compute start and end addresses */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + sg_in[i].len;\n\n        if (log != NULL) {\n            fprintf(log, \"sg[%d]: virt=%p, len=%d, roi=[%p,%p)\\n\",\n                    i, vaddr_sg_lo, sg_in[i].len, vaddr_sg_lo, vaddr_sg_hi);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n\n            if (log != NULL) {\n                fprintf(log, \"  region[%d]: virt=%p, size=%zu, r=[%p,%p)\\n\",\n                        j, vaddr_lo, io->size, vaddr_lo, vaddr_hi);\n            }\n\n            if (vaddr_sg_lo >= vaddr_lo && vaddr_sg_hi <= vaddr_hi) {\n                if (log != NULL) {\n                    fprintf(log, \"  match: sg[%d] in region[%d]\\n\", i, j);\n                }\n                break;\n            }\n        }\n\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the warning and the failing addresses */\n            if (log != NULL) {\n                fprintf(log, \"warning: %s,%s: input address isn't MMIO addr: %p,%d.\\n\",\n                        __func__, (ldev != NULL) ? ldev->dev_name : \"(null)\",\n                        vaddr_sg_lo, sg_in[i].len);\n                /* Also log that sg_in was only read and not modified, demonstrating\n                 * that sg_in could be const-qualified (MISRA C Rule 8.13 scenario).\n                 */\n                fprintf(log, \"note: sg_in was not modified by %s; parameter is non-const -> Rule 8.13 violation scenario.\\n\",\n                        __func__);\n                fclose(log);\n            }\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* preserve original behavior: copy descriptors */\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n        if (log != NULL) {\n            fprintf(log, \"copied %d sg descriptors from %p to %p\\n\",\n                    nents_in, (void *)sg_in, (void *)sg_out);\n        }\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"exit: %s returning %d\\n\", __func__, nents_in);\n        fclose(log);\n    }\n\n    return nents_in;\n}\n",
  "explanation": "I removed the local typedef and the struct definitions that duplicated types already provided by the project's headers (metal/io.h, metal/dma.h, etc.). Redefining those structs caused the compilation errors. Instead, I added standard includes (stdio.h, string.h, stdint.h, stddef.h, errno.h) and forward-declarations for struct linux_bus and struct linux_device so the function can be compiled in the original compilation unit where the real type definitions are available. The function body and logic are preserved exactly as requested."
}