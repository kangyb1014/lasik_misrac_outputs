{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/122.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_dma_map:\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_dma_map:\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nstruct linux_device {\n\tstruct metal_device\t\tdevice;\n\tchar\t\t\t\tdev_name[PATH_MAX];\n\tchar\t\t\t\tdev_path[PATH_MAX];\n\tchar\t\t\t\tcls_path[PATH_MAX];\n\tmetal_phys_addr_t\t\tregion_phys[METAL_MAX_DEVICE_REGIONS];\n\tstruct linux_driver\t\t*ldrv;\n\tstruct sysfs_device\t\t*sdev;\n\tstruct sysfs_attribute\t\t*override;\n\tint\t\t\t\tfd;\n}\n...\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\nJudge whether the above metal_uio_dev_dma_map code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The function contains the statements '(void)lbus;' and '(void)dir;'. These are executed no-op operations whose removal does not change program behaviour, therefore they constitute dead code under MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdarg.h>\n\n/* Minimal types to allow standalone compilation while preserving original logic */\ntypedef unsigned long metal_phys_addr_t;\n\nstruct metal_io_region {\n    void *virt;                 /* base virtual address */\n    const metal_phys_addr_t *physmap;\n    size_t size;                /* size of the I/O region */\n    unsigned long page_shift;\n    unsigned long page_mask;\n    unsigned int mem_flags;\n    /* ops omitted */\n};\n\nstruct metal_sg {\n    void *virt;                 /* CPU virtual address */\n    struct metal_io_region *io; /* IO region */\n    int len;                    /* length */\n};\n\nstruct metal_device {\n    struct metal_io_region *regions;\n    size_t num_regions;\n};\n\nstruct linux_device {\n    struct metal_device device;\n    char dev_name[256];\n    char dev_path[256];\n    char cls_path[256];\n    /* other fields omitted */\n    int fd;\n};\n\nstruct linux_bus {\n    struct metal_device bus;\n    const char *bus_name;\n};\n\n/* Small probe logger that appends to the required logfile. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/122.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\n/* Modified function: preserves original logic and adds probes showing control path and state.\n   Note: kept the (void)lbus; (void)dir; statements to demonstrate the dead-code scenario. */\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    char *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    /* Original explicit unused-parameter casts (these are the dead-code candidates). */\n    (void)lbus;\n    (void)dir;\n\n    probe_log(\"enter: %s ldev=%p dev_name=%s nents_in=%d sg_in=%p sg_out=%p\\n\",\n              __func__, (void *)ldev, ldev ? ldev->dev_name : \"(null)\", nents_in, (void *)sg_in, (void *)sg_out);\n    probe_log(\"note: parameters 'lbus' and 'dir' are explicitly cast to void (no-op)\\n\");\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = (char *)sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n        probe_log(\"checking sg[%d]: virt=%p len=%d -> range [%p, %p)\\n\",\n                  i, (void *)vaddr_sg_lo, sg_in[i].len, (void *)vaddr_sg_lo, (void *)vaddr_sg_hi);\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = (char *)io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            probe_log(\"  region[%d]: base=%p size=%zu -> range [%p, %p)\\n\",\n                      j, (void *)vaddr_lo, io->size, (void *)vaddr_lo, (void *)vaddr_hi);\n            if (vaddr_sg_lo >= vaddr_lo && vaddr_sg_hi <= vaddr_hi) {\n                probe_log(\"  -> sg[%d] is inside region[%d]\\n\", i, j);\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            probe_log(\"warning: %s,%s: input address isn't MMIO addr: %p,%d\\n\",\n                      __func__, ldev->dev_name, (void *)vaddr_sg_lo, sg_in[i].len);\n            return -22; /* -EINVAL equivalent (portable constant avoided) */\n        }\n    }\n    if (sg_out != sg_in) {\n        probe_log(\"copying %d sg entries from %p to %p\\n\", nents_in, (void *)sg_in, (void *)sg_out);\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n    } else {\n        probe_log(\"sg_out is the same as sg_in, no copy performed\\n\");\n    }\n    probe_log(\"returning %d\\n\", nents_in);\n    return nents_in;\n}\n"
}