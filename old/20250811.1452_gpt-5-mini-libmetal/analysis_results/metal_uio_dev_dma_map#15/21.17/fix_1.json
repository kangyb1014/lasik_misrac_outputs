{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef uint64_t metal_phys_addr_t;\nstruct metal_io_region {\n    void                   *virt;      /* base virtual address */\n    const metal_phys_addr_t *physmap;  /* not used here */\n    size_t                  size;      /* size of the I/O region */\n    unsigned long           page_shift;\n    metal_phys_addr_t       page_mask;\n    unsigned int            mem_flags;\n    /* ops omitted */\n};\nstruct metal_sg {\n    void *virt;                 /* CPU virtual address */\n    struct metal_io_region *io; /* IO region (unused here) */\n    int len;                    /* length */\n};\nstruct device_container {\n    struct metal_io_region *regions;\n    size_t num_regions;\n};\nstatic void logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/127.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* use char* for pointer arithmetic to be standard-conforming */\n        vaddr_sg_lo = (char *)sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + (size_t)sg_in[i].len;\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the failing input address and length */\n            logf(\"%s,%s: input address isn't MMIO addr: vaddr=0x%p, len=%d\\n\",\n                 __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* Log detailed state before performing memcpy so a test harness\n           can detect overflow scenarios: addresses, element count, bytes */\n        size_t bytes = (size_t)nents_in * sizeof(struct metal_sg);\n        logf(\"%s: preparing to memcpy from sg_in=0x%p to sg_out=0x%p, nents_in=%d, bytes=%zu\\n\",\n             __func__, (void *)sg_in, (void *)sg_out, nents_in, bytes);\n\n        /* Perform the copy identical to original logic */\n        memcpy(sg_out, sg_in, bytes);\n\n        /* Log after memcpy to show completion of the control path */\n        logf(\"%s: memcpy completed\\n\", __func__);\n    }\n    return nents_in;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\n/tmp/tmp5p_4mkzp/src/lib/system/linux/device.c:324:8: error: redefinition of 'struct metal_io_region'\n  324 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\nIn file included from /tmp/tmp5p_4mkzp/build/lib/include/metal/device.h:16,\n                 from /tmp/tmp5p_4mkzp/src/lib/system/linux/device.c:24:\n/tmp/tmp5p_4mkzp/build/lib/include/metal/io.h:73:8: note: originally defined here\n   73 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\n/tmp/tmp5p_4mkzp/src/lib/system/linux/device.c:333:8: error: redefinition of 'struct metal_sg'\n  333 | struct metal_sg {\n      |        ^~~~~~~~\nIn file included from /tmp/tmp5p_4mkzp/build/lib/include/metal/device.h:18,\n                 from /tmp/tmp5p_4mkzp/src/lib/system/linux/device.c:24:\n/tmp/tmp5p_4mkzp/build/lib/include/metal/dma.h:33:8: note: originally defined here\n   33 | struct metal_sg {\n      |        ^~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:216: lib/CMakeFiles/metal-shared.dir/system/linux/device.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stddef.h>\n\n/* Forward declarations to avoid redefining types that are provided\n   by the project's headers. The full definitions live in the\n   project's include files (e.g. metal/io.h, metal/dma.h). */\nstruct metal_io_region;\nstruct metal_sg;\n\nstruct device_container {\n    struct metal_io_region *regions;\n    size_t num_regions;\n};\n\nstatic void logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/127.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\n/*\n * Keep the original signature. The definitions of struct linux_bus and\n * struct linux_device are expected to come from the surrounding project\n * headers; do not redefine them here to avoid conflicts.\n */\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* use char* for pointer arithmetic to be standard-conforming */\n        vaddr_sg_lo = (char *)sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + (size_t)sg_in[i].len;\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the failing input address and length */\n            logf(\"%s,%s: input address isn't MMIO addr: vaddr=0x%p, len=%d\\n\",\n                 __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* Log detailed state before performing memcpy so a test harness\n           can detect overflow scenarios: addresses, element count, bytes */\n        size_t bytes = (size_t)nents_in * sizeof(struct metal_sg);\n        logf(\"%s: preparing to memcpy from sg_in=0x%p to sg_out=0x%p, nents_in=%d, bytes=%zu\\n\",\n             __func__, (void *)sg_in, (void *)sg_out, nents_in, bytes);\n\n        /* Perform the copy identical to original logic */\n        memcpy(sg_out, sg_in, bytes);\n\n        /* Log after memcpy to show completion of the control path */\n        logf(\"%s: memcpy completed\\n\", __func__);\n    }\n    return nents_in;\n}\n",
  "explanation": "The build failure was due to redefinition of types (struct metal_io_region and struct metal_sg) that are already declared in the project's headers. I removed those duplicate definitions and added forward declarations instead so the compiler will use the project's canonical definitions. I kept the device_container, logf, and metal_uio_dev_dma_map implementations unchanged to preserve the original logic. Standard headers (stdio.h, stdarg.h, stdint.h, string.h, errno.h, stddef.h) were included to ensure used symbols are available."
}