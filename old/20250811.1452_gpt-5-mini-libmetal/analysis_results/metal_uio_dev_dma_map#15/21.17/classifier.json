{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/127.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_dma_map:\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_dma_map:\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\nJudge whether the above metal_uio_dev_dma_map code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If the caller passes sg_out pointing to an array that contains fewer than nents_in elements, the memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) will write past the end of the sg_out object. For example, if nents_in == 5 but sg_out points to an array of 3 struct metal_sg entries, the memcpy will overflow sg_out and thus violate MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n#include <stdarg.h>\n\ntypedef uint64_t metal_phys_addr_t;\n\nstruct metal_io_region {\n    void                   *virt;      /* base virtual address */\n    const metal_phys_addr_t *physmap;  /* not used here */\n    size_t                  size;      /* size of the I/O region */\n    unsigned long           page_shift;\n    metal_phys_addr_t       page_mask;\n    unsigned int            mem_flags;\n    /* ops omitted */\n};\n\nstruct metal_sg {\n    void *virt;                 /* CPU virtual address */\n    struct metal_io_region *io; /* IO region (unused here) */\n    int len;                    /* length */\n};\n\nstruct device_container {\n    struct metal_io_region *regions;\n    size_t num_regions;\n};\n\nstruct linux_device {\n    const char *dev_name;\n    struct device_container device;\n};\n\nstruct linux_bus {\n    /* unused in this test harness */\n    int dummy;\n};\n\n/* Simple logger helper that appends to the required file */\nstatic void logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/127.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\n/*\n * Modified metal_uio_dev_dma_map that preserves original logic but\n * logs detailed control path and state information to /tmp/logs/127.txt.\n * Pointer arithmetic uses char * casts so the code is standard-C compliant.\n */\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* use char* for pointer arithmetic to be standard-conforming */\n        vaddr_sg_lo = (char *)sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + (size_t)sg_in[i].len;\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the failing input address and length */\n            logf(\"%s,%s: input address isn't MMIO addr: vaddr=0x%p, len=%d\\n\",\n                 __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* Log detailed state before performing memcpy so a test harness\n           can detect overflow scenarios: addresses, element count, bytes */\n        size_t bytes = (size_t)nents_in * sizeof(struct metal_sg);\n        logf(\"%s: preparing to memcpy from sg_in=0x%p to sg_out=0x%p, nents_in=%d, bytes=%zu\\n\",\n             __func__, (void *)sg_in, (void *)sg_out, nents_in, bytes);\n\n        /* Perform the copy identical to original logic */\n        memcpy(sg_out, sg_in, bytes);\n\n        /* Log after memcpy to show completion of the control path */\n        logf(\"%s: memcpy completed\\n\", __func__);\n    }\n    return nents_in;\n}\n"
}