{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/120.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_dma_map:\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_dma_map:\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\nJudge whether the above metal_uio_dev_dma_map code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "The code performs pointer arithmetic on void* objects (e.g. vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len; and vaddr_hi = vaddr_lo + io->size;). Pointer arithmetic on void* is a compiler language extension in many toolchains (GNU C treats void* arithmetic as bytewise), so the source uses a language extension and thus violates MISRA C 2023 Rule 1.2.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n    FILE *log = NULL;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Open log file to record control path and state for the violation scenario */\n    log = fopen(\"/tmp/logs/120.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"ENTER %s: dev=%s, nents_in=%d\\n\",\n                __func__, (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\", nents_in);\n    }\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* The following pointer arithmetic on void* is a compiler extension\n           (used here to reproduce the violation scenario). */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\n        if (log) {\n            fprintf(log, \"sg[%d]: virt=%p, len=%d, computed_hi=%p\\n\",\n                    i, (void *)vaddr_sg_lo, sg_in[i].len, (void *)vaddr_sg_hi);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            if (log) {\n                fprintf(log, \"  region[%d]: base=%p, size=%zu, hi=%p\\n\",\n                        j, (void *)vaddr_lo, io->size, (void *)vaddr_hi);\n            }\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                if (log) {\n                    fprintf(log, \"  sg[%d] is within region[%d]\\n\", i, j);\n                }\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            if (log) {\n                fprintf(log, \"WARNING: %s,%s: input address isn't MMIO addr: sg_index=%d, virt=%p, len=%d\\n\",\n                        __func__, (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\",\n                        i, (void *)vaddr_sg_lo, sg_in[i].len);\n            }\n            if (log) fclose(log);\n            metal_log(METAL_LOG_WARNING,\n                      \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n                      __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n\n    if (log) {\n        fprintf(log, \"EXIT %s: returning %d\\n\", __func__, nents_in);\n        fclose(log);\n    }\n    return nents_in;\n}\n"
}