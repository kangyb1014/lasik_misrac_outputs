{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_shmem_register_generic code that contains useful probe functions that print useful logs to a file \"/tmp/logs/95.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_shmem_register_generic as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_shmem_register_generic:\n```c\nint metal_shmem_register_generic(struct metal_generic_shmem *shmem)\n{\n\t/* Make sure that we can be found. */\n\tmetal_assert(shmem->name && strlen(shmem->name) != 0);\n\n\t/* Statically registered shmem regions cannot have a destructor. */\n\tmetal_assert(!shmem->io.ops.close);\n\n\tmetal_list_add_tail(&_metal.common.generic_shmem_list,\n\t\t\t    &shmem->node);\n\treturn 0;\n}\n```\n</target_code>\nJudge whether the above metal_shmem_register_generic code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If shmem->name is non-NULL but does not point to a NUL-terminated character array (for example it points to a small buffer without a terminating '\\0' or to memory where no '\\0' exists within the accessible bounds), the call to strlen(shmem->name) may read past the valid object bounds and thus violate MISRA C 2023 Rule 21.17. A concrete violation scenario is: a caller sets shmem->name to point to a fixed-size buffer that contains characters but no terminating NUL; metal_shmem_register_generic then calls strlen and may access out-of-bounds memory while searching for the terminator.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Minimal supporting types to allow compilation. */\nstruct metal_node { int dummy; };\nstruct metal_io_inner { void (*close)(void); };\nstruct metal_io { struct metal_io_inner ops; };\nstruct metal_generic_shmem {\n    char *name;\n    struct metal_io io;\n    struct metal_node node;\n};\n\n/* Simple implementations to allow execution and logging. */\nvoid metal_assert(int cond)\n{\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f != NULL) {\n        fprintf(f, \"metal_assert: %s\\n\", cond ? \"true\" : \"false\");\n        fclose(f);\n    }\n    if (!cond) {\n        /* Abort to mimic typical assert behavior. */\n        abort();\n    }\n}\n\nvoid metal_list_add_tail(void *list, struct metal_node *node)\n{\n    (void) list; (void) node;\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f != NULL) {\n        fprintf(f, \"metal_list_add_tail called\\n\");\n        fclose(f);\n    }\n}\n\n/* Original function preserved as much as possible, with probes/logging. */\nint metal_shmem_register_generic(struct metal_generic_shmem *shmem)\n{\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f != NULL) {\n        fprintf(f, \"enter: metal_shmem_register_generic, shmem=%p\\n\", (void *)shmem);\n        if (shmem != NULL) {\n            fprintf(f, \"  shmem->name=%p\\n\", (void *)shmem->name);\n            if (shmem->name != NULL) {\n                /* Log first few bytes (if accessible) for diagnostic purposes. */\n                size_t i;\n                fprintf(f, \"  first bytes: \");\n                for (i = 0u; i < 4u; ++i) {\n                    /* Be careful not to read past if name is NULL; we only index when non-NULL.\n                       Note: reading *shmem->name + offsets may still be out-of-bounds if the\n                       caller provided a non-terminated buffer; that is the scenario this\n                       probe is intended to reveal when executed. */\n                    unsigned char c = (unsigned char) shmem->name[i];\n                    fprintf(f, \"%02X \", (unsigned) c);\n                }\n                fprintf(f, \"\\n\");\n            }\n        }\n        fclose(f);\n    }\n\n    /* Make sure that we can be found. */\n    metal_assert(shmem->name && strlen(shmem->name) != 0);\n\n    /* Statically registered shmem regions cannot have a destructor. */\n    metal_assert(!shmem->io.ops.close);\n\n    metal_list_add_tail(NULL, &shmem->node);\n    return 0;\n}\n\n/* Probe function that demonstrates the violation scenario:\n   - creates a small buffer without a terminating NUL\n   - assigns it to shmem->name and calls the function\n   When executed, strlen may read past the buffer bounds in search of a NUL. */\nvoid probe_non_terminated_name(void)\n{\n    struct metal_generic_shmem s;\n    /* Buffer intentionally without a terminating '\\0' to provoke the condition. */\n    char buf[4] = { 'A', 'B', 'C', 'D' };\n\n    s.name = buf; /* non-NULL but not NUL-terminated */\n    s.io.ops.close = NULL;\n\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f != NULL) {\n        fprintf(f, \"probe_non_terminated_name: calling metal_shmem_register_generic with non-terminated buffer at %p (size 4)\\n\", (void *)buf);\n        fclose(f);\n    }\n\n    /* This call may read beyond buf while strlen searches for '\\0'. */\n    /* It will either abort via metal_assert or exhibit out-of-bounds access during strlen. */\n    (void) metal_shmem_register_generic(&s);\n}\n\n/* Probe function that demonstrates the safe case: NUL-terminated name. */\nvoid probe_null_terminated_name(void)\n{\n    struct metal_generic_shmem s;\n    s.name = \"OK\";\n    s.io.ops.close = NULL;\n\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f != NULL) {\n        fprintf(f, \"probe_null_terminated_name: calling metal_shmem_register_generic with \\\"OK\\\"\\n\");\n        fclose(f);\n    }\n\n    (void) metal_shmem_register_generic(&s);\n}\n"
}