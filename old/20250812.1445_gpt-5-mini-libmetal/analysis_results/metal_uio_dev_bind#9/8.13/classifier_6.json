{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_bind:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_bind:\nstruct linux_device {\n\tstruct metal_device\t\tdevice;\n\tchar\t\t\t\tdev_name[PATH_MAX];\n\tchar\t\t\t\tdev_path[PATH_MAX];\n\tchar\t\t\t\tcls_path[PATH_MAX];\n\tmetal_phys_addr_t\t\tregion_phys[METAL_MAX_DEVICE_REGIONS];\n\tstruct linux_driver\t\t*ldrv;\n\tstruct sysfs_device\t\t*sdev;\n\tstruct sysfs_attribute\t\t*override;\n\tint\t\t\t\tfd;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The parameter 'ldrv' is only read (used in strcmp, sysfs_get_driver_attr and sysfs_write_attribute) and is not modified; therefore it should be declared as a pointer to a const-qualified type (e.g. 'const struct linux_driver *ldrv'). 'ldev' is modified (ldev->override = attr) and must remain non-const. Because 'ldrv' is not const-qualified despite being eligible, this violates MISRA C 2023 Rule 8.13."
}