{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg (definition)",
    "struct metal_bus (definition)",
    "struct metal_device (definition)",
    "METAL_DMA_DEV_W (macro definition)",
    "metal_cache_flush (declaration + definition)",
    "metal_cache_invalidate (declaration + definition)",
    "memcpy (declaration/implementation/macro)",
    "uint32_t (typedef / include <stdint.h>)"
  ],
  "explanation": "Provide the listed symbols so the next analyzer can detect any compiler-language extensions that are actually being used by or in the types/macros/functions referenced by the target function:\n\n- struct metal_sg (definition): the function indexes sg_out[i].virt and sg_out[i].len and takes sizeof(struct metal_sg). The struct declaration is needed to check for compiler extensions in the type (e.g. attribute((packed/aligned/section)), nonstandard bit-field types, GCC extensions in member declarations).\n\n- struct metal_bus (definition): although only cast away via (void)bus, the bus type definition could contain attributes or compiler-specific extensions that would make the translation unit use language extensions.\n\n- struct metal_device (definition): same reason as metal_bus \u2014 its declaration/definition may contain attributes or nonstandard constructs.\n\n- METAL_DMA_DEV_W (macro definition): used in a conditional; the macro itself may be defined using compiler extensions (statement-expressions ({ ... }), typeof, inline asm, or other nonstandard constructs). The macro definition must be inspected.\n\n- metal_cache_flush (declaration + definition): the callee\u2019s prototype or definition may use compiler-specific extensions (e.g. __attribute__, inline asm, builtin extensions, or nonstandard calling conventions). To determine whether the codebase uses language extensions, inspect these symbols.\n\n- metal_cache_invalidate (declaration + definition): same rationale as metal_cache_flush; its declaration/definition could contain explicit compiler extensions.\n\n- memcpy (declaration/implementation/macro): memcpy may be provided as a macro or inline wrapper that uses compiler builtins or extensions (e.g. __builtin_memcpy, statement-expressions, attributes). Check its actual declaration/implementation in the build environment/header to ensure no extension is used.\n\n- uint32_t (typedef / include <stdint.h>): the integer-width typedef\u2019s origin should be verified (standard <stdint.h> vs compiler-provided typedef using extensions). This ensures the code isn\u2019t relying on a nonstandard typedef or extension.\n\nThese symbols cover the user-defined types, macros and external functions that could hide language extensions; inspecting their declarations/definitions is necessary to decide whether the target function (or its direct dependencies) uses any compiler-specific language extensions as defined in compiler documentation."
}