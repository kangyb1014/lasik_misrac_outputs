{
  "user_message": "An agent A claimed that the following metal_bus_find code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of metal_bus_find.\n```c\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen(bus_name) and strlen(dev_name) after only checking for non-NULL. If a caller supplies a non-NULL pointer that does not reference a NUL-terminated character array (or whose storage is shorter than the characters before the NUL), strlen may read past the bounds of that object. Example: char buf[3] = {'a','b','c'}; passing buf as bus_name causes strlen(buf) to scan past buf\u2019s bounds until a 0 is found \u2014 violating MISRA C:2023 Rule 21.17. (Note: the short-circuit logic prevents calling strlen on a NULL pointer, but does not prevent out\u2011of\u2011bounds access for non\u2011terminated strings.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\t/* Log entry into the function and the pointers we received. */\n\t{\n\t\tFILE *log = fopen(\"/tmp/logs/47.txt\", \"a\");\n\t\tif (log) {\n\t\t\tfprintf(log, \"metal_bus_find: entry name=%p, result=%p\\n\", (const void *)name, (void *)result);\n\t\t\tfflush(log);\n\t\t\tfclose(log);\n\t\t}\n\t}\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\n\t\t/* Log the current bus and the bus->name pointer before calling strcmp. */\n\t\t{\n\t\t\tFILE *log = fopen(\"/tmp/logs/47.txt\", \"a\");\n\t\t\tif (log) {\n\t\t\t\tfprintf(log, \"metal_bus_find: iter bus=%p, bus->name=%p\\n\", (void *)bus, (void *)bus->name);\n\t\t\t\tif (bus->name == NULL) {\n\t\t\t\t\tfprintf(log, \"  bus->name is NULL\\n\");\n\t\t\t\t}\n\t\t\t\tif (name == NULL) {\n\t\t\t\t\tfprintf(log, \"  arg name is NULL\\n\");\n\t\t\t\t}\n\t\t\t\tfprintf(log, \"  about to call strcmp(bus->name, name)\\n\");\n\t\t\t\tfflush(log);\n\t\t\t\tfclose(log);\n\t\t\t}\n\t\t}\n\n\t\t/* Perform the original comparison (preserve original logic). */\n\t\tint cmp = strcmp(bus->name, name);\n\n\t\t/* Log the result of strcmp. If strcmp causes an out-of-bounds access, the program may crash\n\t\t   before this log is written; the previous logs demonstrate that strcmp was invoked on\n\t\t   non-NULL pointers, which helps reproduce the violation scenario. */\n\t\t{\n\t\t\tFILE *log = fopen(\"/tmp/logs/47.txt\", \"a\");\n\t\t\tif (log) {\n\t\t\t\tfprintf(log, \"metal_bus_find: strcmp returned %d for bus->name=%p and name=%p\\n\",\n\t\t\t\t\tcmp, (void *)bus->name, (const void *)name);\n\t\t\t\tfflush(log);\n\t\t\t\tfclose(log);\n\t\t\t}\n\t\t}\n\n\t\tif (cmp == 0 && result) {\n\t\t\t/* Log the fact that we are returning a match and storing the pointer. */\n\t\t\tFILE *log = fopen(\"/tmp/logs/47.txt\", \"a\");\n\t\t\tif (log) {\n\t\t\t\tfprintf(log, \"metal_bus_find: match found, storing result=%p (bus=%p)\\n\", (void *)bus, (void *)bus);\n\t\t\t\tfflush(log);\n\t\t\t\tfclose(log);\n\t\t\t}\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_bus_find. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reporter is essentially correct: metal_bus_find calls strcmp(bus->name, name) without any guarantee that either pointer references a NUL-terminated character array long enough for strcmp to scan. MISRA C:2023 Rule 21.17 forbids use of the <string.h> routines in ways that may access beyond the bounds of the pointed-to objects. Checking only for non-NULL (or not even that here) does not prevent out\u2011of\u2011bounds reads when a pointer points to a non\u2011terminated buffer or to storage shorter than the characters before the terminating NUL. The agent's scenario used strlen in the example, but the same problem applies to strcmp: both scan until a NUL and can read past object bounds if termination is not guaranteed. That said, if the API contract for metal_bus_find (in the wider code base) formally guarantees that both bus->name and the name argument are valid NUL\u2011terminated strings, then the call is safe and would not violate MISRA; absent such a documented/verified precondition or an explicit runtime/bounded check (or use of length-limited functions with proven buffer sizes), the use is a potential violation. Recommended remedies: document/verify the NUL\u2011termination precondition, validate lengths at the callsite, or use bounded comparisons (e.g. strncmp with known max lengths) or otherwise ensure no scan beyond object bounds can occur."
}