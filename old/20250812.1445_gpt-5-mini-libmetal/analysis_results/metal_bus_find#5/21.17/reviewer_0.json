{
  "user_message": "An agent A claimed that the following metal_bus_find code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of metal_bus_find.\n```c\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. metal_bus_find calls strcmp(bus->name, name) without validating the 'name' parameter. In the fragment metal_linux_bus_finish the code calls metal_bus_find(lbus->bus_name, &bus) without checking lbus->bus_name. If lbus->bus_name is NULL (or points to a non\u2013NUL-terminated buffer), strcmp will dereference/read past the object bounds, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\tFILE *log = NULL;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\n\t\t/* Probe: log control flow and state to help reproduce potential out-of-bounds\n\t\t   accesses when strcmp(bus->name, name) is called. This preserves the\n\t\t   original logic (we do not change the strcmp call or short-circuit it). */\n\t\tlog = fopen(\"/tmp/logs/47.txt\", \"a\");\n\t\tif (log) {\n\t\t\t/* Log pointers and nullness information only. Do not attempt to read\n\t\t\t   beyond the first byte of any string to avoid introducing new\n\t\t\t   out-of-bounds accesses. */\n\t\t\tfprintf(log, \"metal_bus_find: node=%p bus=%p bus->name=%p name=%p\\n\",\n\t\t\t\t(void *)node, (void *)bus, (void *)bus->name, (const void *)name);\n\n\t\t\tif (bus->name) {\n\t\t\t\tunsigned char c = (unsigned char)bus->name[0];\n\t\t\t\t/* Print first byte in hex and a printable character or '.' */\n\t\t\t\tfprintf(log, \"  bus->name[0]=0x%02x %c\\n\",\n\t\t\t\t\t(unsigned int)c, (c >= 32 && c <= 126) ? (char)c : '.');\n\t\t\t} else {\n\t\t\t\tfprintf(log, \"  bus->name is NULL\\n\");\n\t\t\t}\n\n\t\t\tif (name) {\n\t\t\t\tfprintf(log, \"  name is non-NULL\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(log, \"  name is NULL\\n\");\n\t\t\t}\n\n\t\t\tfflush(log);\n\t\t\tfclose(log);\n\t\t\tlog = NULL;\n\t\t}\n\n\t\t/* Preserve original behavior: perform the strcmp as in the original code. */\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_bus_find. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strcmp(bus->name, name) is called with both pointer parameters unchecked. MISRA C 2023 Rule 21.17 requires that use of <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. If 'name' (or even bus->name) can be NULL or can point to a non\u2013NUL-terminated buffer, the strcmp call may dereference a NULL pointer or read past the object bounds, violating the rule. The provided scenario (metal_linux_bus_finish passing lbus->bus_name without checking it) demonstrates a plausible path where 'name' could be invalid; the absence of checks or an explicit, documented contract that guarantees non-NULL, NUL-terminated inputs means the function as written does not meet the MISRA requirement. To comply, the code must either validate pointers/termination before calling strcmp or rely on and document a provable invariant (established elsewhere) that both arguments are valid NUL-terminated strings."
}