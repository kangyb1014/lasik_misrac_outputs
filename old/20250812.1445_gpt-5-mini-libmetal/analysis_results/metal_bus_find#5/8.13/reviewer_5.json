{
  "user_message": "An agent A claimed that the following metal_bus_find code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_bus_find.\n```c\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The loop iterates over the global bus list with a non-const iterator: 'struct metal_list *node' and the call metal_list_for_each(&_metal.common.bus_list, node) uses a non-const pointer even though the function only reads the list elements. Per MISRA C 2023 Rule 8.13, the iterator should be const-qualified when possible (e.g. 'const struct metal_list *node' and a const-aware for-each macro), or the API should return a const metal_bus (or accept 'const struct metal_bus **result') so that the read-only nature is reflected. As written the code fails to use const where it could, so the rule is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void metal_bus_find_log(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/43.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n    struct metal_list *node;\n    struct metal_bus *bus;\n\n    /* Log entry and inputs */\n    metal_bus_find_log(\"enter metal_bus_find: name=%p name_str=\\\"%s\\\" result=%p bus_list=%p\",\n                       (void *)name, (name ? name : \"(null)\"), (void *)result, (void *)&_metal.common.bus_list);\n\n    metal_list_for_each(&_metal.common.bus_list, node) {\n        /* Log the iterator node address */\n        metal_bus_find_log(\"iter: node=%p\", (void *)node);\n\n        bus = metal_container_of(node, struct metal_bus, node);\n\n        /* Log the container and its name (safe-guard when reading for logging) */\n        metal_bus_find_log(\"container_of -> bus=%p bus->name=\\\"%s\\\"\", (void *)bus,\n                           (bus && bus->name) ? bus->name : \"(null)\");\n\n        if (strcmp(bus->name, name) == 0 && result) {\n            *result = bus;\n            metal_bus_find_log(\"match: name=\\\"%s\\\" -> set *result=%p return=0\", bus->name, (void *)bus);\n            return 0;\n        }\n    }\n\n    metal_bus_find_log(\"exit metal_bus_find: not found return=%d\", -ENOENT);\n    return -ENOENT;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_bus_find. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 8.13 requires using const-qualified pointer types where that is possible without changing intended semantics or breaking interfaces. In this function the list iterator and container are effectively used to produce and return a non-const struct metal_bus * via the result parameter, so the pointers cannot be simply qualified const without changing the observable API/semantics (or changing the list/container macros).\n\n- The result parameter is intentionally struct metal_bus ** so the caller receives a modifiable pointer to a bus. Changing that to const struct metal_bus ** (or returning const struct metal_bus *) would change semantics and is not a straightforward safe conversion in C (pointer-to-pointer const conversions are not equivalent). Thus it\u2019s not possible to make the returned bus pointer const without redesigning the API.\n- Declaring the iterator as const struct metal_list *node might look possible in isolation, but metal_container_of and the need to obtain a non-const struct metal_bus * (to store into *result) mean you would have to cast away const or change other interfaces/macros. Casting away const to satisfy types would itself violate MISRA rules. If the list iteration macro and container_of had const-aware variants, the code could be updated; but as written you cannot safely add const here.\n\nBecause the pointers cannot reasonably be made const without further changes to surrounding APIs/macros or changing the function\u2019s contract, this instance does not constitute a violation of MISRA C 2023 Rule 8.13."
}