{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'size' is assigned to on the line 'size = metal_align_up(size, ps->page_size);'. This directly modifies a function parameter (a non-pointer parameter), which violates MISRA C 2023 Rule 17.8. Use a local variable (e.g. 'aligned_size') to hold the adjusted value instead of modifying the parameter.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\tFILE *logf = NULL;\n\tsize_t original_size = size; /* capture original parameter for logging */\n\n\t/* Open a probe log file for tracing control flow and state. */\n\tlogf = fopen(\"/tmp/logs/5.txt\", \"a\");\n\tif (logf) {\n\t\tfprintf(logf, \"enter metal_shmem_try_map: fd=%d, original_size=%zu, page_size=%zu, mmap_flags=0x%x\\n\",\n\t\t\tfd, original_size, ps->page_size, ps->mmap_flags);\n\t\tfflush(logf);\n\t}\n\n\t/* Note: the code below intentionally modifies the parameter 'size' to\n\t * reproduce the reported MISRA Rule 17.8 violation scenario. */\n\tsize = metal_align_up(size, ps->page_size);\n\tif (logf) {\n\t\tfprintf(logf, \"aligned size: from %zu to %zu (page_size=%zu)\\n\",\n\t\t\toriginal_size, size, ps->page_size);\n\t\tfflush(logf);\n\t}\n\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"metal_map failed: error=%d (%s), size=%zu, mmap_flags=0x%x\\n\",\n\t\t\t\terror, strerror(-error), size, ps->mmap_flags);\n\t\t\tfflush(logf);\n\t\t\tfclose(logf);\n\t\t}\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"metal_map succeeded: mem=%p, size=%zu\\n\", mem, size);\n\t\tfflush(logf);\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"mlock failed: errno=%d (%s)\\n\", errno, strerror(errno));\n\t\t\tfflush(logf);\n\t\t}\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"malloc(phys) failed: requested=%zu bytes\\n\", phys_size);\n\t\t\tfflush(logf);\n\t\t\tfclose(logf);\n\t\t}\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"malloc(io) failed: requested=%zu bytes\\n\", sizeof(*io));\n\t\t\tfflush(logf);\n\t\t\tfclose(logf);\n\t\t}\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (logf) {\n\t\tfprintf(logf, \"pagemap_fd=%d\\n\", _metal.pagemap_fd);\n\t\tfflush(logf);\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"no VA->PA mapping available: set phys[0]=0, pages=%zu\\n\", pages);\n\t\t\tfflush(logf);\n\t\t\tfclose(logf);\n\t\t}\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0) {\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t\t\tif (logf) {\n\t\t\t\t\tfprintf(logf, \"virt2phys failed for page %zu (offset=%zu): error=%d, phys[%zu]=%llu\\n\",\n\t\t\t\t\t\tpage, offset, error, page, (unsigned long long)phys[page]);\n\t\t\t\t\tfflush(logf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (logf) {\n\t\t\t\t\tfprintf(logf, \"virt2phys ok for page %zu (offset=%zu): phys[%zu]=%llu\\n\",\n\t\t\t\t\t\tpage, offset, page, (unsigned long long)phys[page]);\n\t\t\t\t\tfflush(logf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logf) {\n\t\t\tfprintf(logf, \"completed virt2phys loop for pages=%zu\\n\", pages);\n\t\t\tfflush(logf);\n\t\t\tfclose(logf);\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_shmem_try_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; the object pointed to by a pointer parameter may be modified, but a non\u2011pointer parameter variable itself shall not be assigned to. In the original code the parameter size (type size_t, passed by value) is reassigned on the line: size = metal_align_up(size, ps->page_size); \u2014 this is a direct modification of a function parameter and therefore violates Rule 17.8.\n\nRemediation: introduce a local variable (for example aligned_size or size_aligned) to hold the adjusted value and use that in subsequent expressions (pages, metal_map, mlock, malloc sizing, etc.), leaving the parameter size unchanged. Example: size_t aligned_size = metal_align_up(size, ps->page_size); pages = aligned_size / ps->page_size; and pass aligned_size where size was used.\n\n(The provided test code simply reproduces the same assignment and logging; that does not change the rule violation.)"
}