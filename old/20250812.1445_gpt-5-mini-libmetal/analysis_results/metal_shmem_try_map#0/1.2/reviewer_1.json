{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses the GCC/Clang variadic-macro extension '##__VA_ARGS__' (seen in the metal_log macro) to swallow a preceding comma when the variadic arguments are empty. This token-pasting behaviour is a documented compiler extension and thus violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void __metal_probe_write(const char *s)\n{\n    FILE *f = fopen(\"/tmp/logs/0.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"%s\\n\", s);\n    fclose(f);\n}\nstatic void __metal_probe_fmt(const char *tag, const char *fmt, ...)\n{\n    char buf[512];\n    va_list ap;\n\n    va_start(ap, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n\n    char out[600];\n    snprintf(out, sizeof(out), \"%s: %s\", tag, buf);\n    __metal_probe_write(out);\n}\n\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n                   struct metal_io_region **result)\n{\n    size_t pages, page, phys_size;\n    struct metal_io_region *io;\n    metal_phys_addr_t *phys;\n    uint8_t *virt;\n    void *mem;\n    int error;\n\n    /* Probe: initial inputs */\n    __metal_probe_fmt(\"probe\", \"enter metal_shmem_try_map: fd=%d requested_size=%zu page_size=%zu\",\n              fd, size, ps ? ps->page_size : 0);\n\n    size = metal_align_up(size, ps->page_size);\n    pages = size / ps->page_size;\n\n    __metal_probe_fmt(\"probe\", \"aligned size=%zu pages=%zu page_size=%zu\",\n              size, pages, ps->page_size);\n\n    error = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n    __metal_probe_fmt(\"probe\", \"after metal_map: error=%d mem=%p mmap_flags=0x%x\",\n              error, mem, ps->mmap_flags);\n\n    if (error) {\n        /* Probe: about to call metal_log for mmap failure (variadic with args) */\n        __metal_probe_fmt(\"probe_call_metal_log\",\n                  \"metal_log called with level=%d fmt='failed to mmap shmem %ld,0x%x - %s' args=(size=%zu, mmap_flags=0x%x, strerror=%s)\",\n                  METAL_LOG_WARNING, (long)size, ps->mmap_flags, strerror(-error), size, ps->mmap_flags, strerror(-error));\n\n        metal_log(METAL_LOG_WARNING,\n              \"failed to mmap shmem %ld,0x%x - %s\\n\",\n              size, ps->mmap_flags, strerror(-error));\n        __metal_probe_write(\"probe: returning due to metal_map error\");\n        return error;\n    }\n\n    error = mlock(mem, size);\n    __metal_probe_fmt(\"probe\", \"after mlock: error=%d errno=%d strerror=%s\",\n              error, errno, strerror(errno));\n\n    if (error) {\n        /* Probe: about to call metal_log for mlock failure (variadic with args) */\n        __metal_probe_fmt(\"probe_call_metal_log\",\n                  \"metal_log called with level=%d fmt='failed to mlock shmem - %s' args=(strerror=%s)\",\n                  METAL_LOG_WARNING, strerror(errno), strerror(errno));\n\n        metal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n              strerror(errno));\n    }\n\n    phys_size = sizeof(*phys) * pages;\n    phys = malloc(phys_size);\n    __metal_probe_fmt(\"probe\", \"after malloc phys: phys=%p phys_size=%zu\",\n              phys, phys_size);\n    if (!phys) {\n        __metal_probe_write(\"probe: phys malloc failed, unmapping and returning -ENOMEM\");\n        metal_unmap(mem, size);\n        return -ENOMEM;\n    }\n\n    io = malloc(sizeof(*io));\n    __metal_probe_fmt(\"probe\", \"after malloc io: io=%p\", io);\n    if (!io) {\n        __metal_probe_write(\"probe: io malloc failed, freeing phys, unmapping and returning -ENOMEM\");\n        free(phys);\n        metal_unmap(mem, size);\n        return -ENOMEM;\n    }\n\n    if (_metal.pagemap_fd < 0) {\n        phys[0] = 0;\n\n        /* Probe: _metal.pagemap_fd < 0 branch taken */\n        __metal_probe_fmt(\"probe\", \"pagemap_fd=%d -> using offset as pa, phys[0]=%llu\",\n                  _metal.pagemap_fd, (unsigned long long)phys[0]);\n\n        /* Probe: about to call metal_log with no variadic args (this is the call that demonstrates the empty-VA_ARGS case) */\n        __metal_probe_write(\"probe_call_metal_log: metal_log called with level=METAL_LOG_WARNING and a single string literal fmt, no variadic args\");\n\n        metal_log(METAL_LOG_WARNING,\n        \"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\n        metal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n    } else {\n        __metal_probe_fmt(\"probe\", \"pagemap_fd=%d -> resolving virt2phys for %zu pages\",\n                  _metal.pagemap_fd, pages);\n\n        for (virt = mem, page = 0; page < pages; page++) {\n            size_t offset = page * ps->page_size;\n\n            error = metal_virt2phys(virt + offset, &phys[page]);\n            if (error < 0)\n                phys[page] = METAL_BAD_OFFSET;\n\n            /* Probe: log each virt2phys resolution result (page, phys, error) */\n            __metal_probe_fmt(\"probe\", \"virt2phys page=%zu offset=%zu result_phys=%llu error=%d\",\n                      page, offset, (unsigned long long)phys[page], error);\n        }\n        metal_io_init(io, mem, phys, size, ps->page_shift, 0,\n            &metal_shmem_io_ops);\n    }\n    *result = io;\n\n    __metal_probe_fmt(\"probe\", \"exit metal_shmem_try_map: result_io=%p\", io);\n\n    return 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_shmem_try_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as given. The snippet of metal_shmem_try_map only calls the macro metal_log; it does not contain the macro definition or any use of token-pasting (##__VA_ARGS__) or other compiler-specific preprocessor constructs. MISRA C 2023 Rule 1.2 requires reporting only when a language/compiler extension is actually used (and documented as an extension). Agent A's claim that the code violates Rule 1.2 rests on an assumption about how metal_log is implemented (that it uses the GCC/Clang \u2018##__VA_ARGS__\u2019 extension). No evidence for that is present in the provided target_code or test_code, so you cannot conclude a Rule 1.2 violation from the function alone.\n\nIf you want to confirm the issue, inspect the metal_log macro definition (search for its #define) and check for use of GNU extensions such as \u2018##__VA_ARGS__\u2019 or other compiler-specific features. If that macro does use \u2018##__VA_ARGS__\u2019 (or other documented compiler extensions), then Agent A\u2019s reasoning would be valid and the project would violate Rule 1.2; if the macro uses only standard C (or C23\u2019s __VA_OPT__ where appropriate and allowed), then there is no violation. Recommended actions: locate the metal_log macro, and if it uses \u2018##__VA_ARGS__\u2019, replace with a MISRA-compliant alternative (explicit overloads, supplying a fixed argument, or using a standard feature supported by your required language version)."
}