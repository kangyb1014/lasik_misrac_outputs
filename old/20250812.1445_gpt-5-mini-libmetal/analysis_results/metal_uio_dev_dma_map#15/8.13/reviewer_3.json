{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function takes sg_in as a non-const pointer but only reads from it (it is used as the source to memcpy). In the fragment memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)); sg_in should be declared const struct metal_sg *sg_in (and memcpy's second parameter is const void *). Declaring sg_in const would satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_write_log(const char *fmt, ...)\n{\n    FILE *f;\n    va_list ap;\n    /* Try to create directory; ignore errors other than failure to create */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fflush(f);\n    fclose(f);\n}\nstatic void probe_log_entry(const char *func,\n                            struct linux_bus *lbus,\n                            struct linux_device *ldev,\n                            uint32_t dir,\n                            struct metal_sg *sg_in,\n                            int nents_in,\n                            struct metal_sg *sg_out)\n{\n    probe_write_log(\"ENTER %s: lbus=%p, ldev=%p, dir=%u, sg_in=%p, nents_in=%d, sg_out=%p\\n\",\n                    func, (void *)lbus, (void *)ldev, dir, (void *)sg_in, nents_in, (void *)sg_out);\n}\nstatic void probe_log_iter(int idx, void *vaddr_sg_lo, void *vaddr_sg_hi, size_t len)\n{\n    probe_write_log(\"  ITER %d: sg[%d].virt=%p, sg[%d].len=%zu, range=[%p - %p]\\n\",\n                    idx, idx, vaddr_sg_lo, idx, len, vaddr_sg_lo, vaddr_sg_hi);\n}\nstatic void probe_log_region_check(int idx, void *vaddr_lo, void *vaddr_hi)\n{\n    probe_write_log(\"    CHECK region %d: region.virt=%p, region.size_range=[%p - %p]\\n\",\n                    idx, vaddr_lo, vaddr_lo, vaddr_hi);\n}\nstatic void probe_log_matched_region(int sg_idx, int region_idx)\n{\n    probe_write_log(\"    MATCH sg[%d] -> region[%d]\\n\", sg_idx, region_idx);\n}\nstatic void probe_log_nomatch(int idx, void *vaddr_sg_lo, void *vaddr_sg_hi, int num_regions)\n{\n    probe_write_log(\"  NO MATCH for sg[%d]: range=[%p - %p], num_regions=%d\\n\",\n                    idx, vaddr_sg_lo, vaddr_sg_hi, num_regions);\n}\nstatic void probe_log_memcpy(void *dst, void *src, size_t bytes)\n{\n    probe_write_log(\"  MEMCPY: dst=%p, src=%p, bytes=%zu\\n\", dst, src, bytes);\n}\nstatic void probe_log_return(int ret)\n{\n    probe_write_log(\"RETURN: %d\\n\", ret);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    /* Probe: entry */\n    probe_log_entry(__func__, lbus, ldev, dir, sg_in, nents_in, sg_out);\n\n    (void)lbus;\n    (void)dir;\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\n        /* Probe: iteration details */\n        probe_log_iter(i, vaddr_sg_lo, vaddr_sg_hi, (size_t)sg_in[i].len);\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n\n            /* Probe: region check */\n            probe_log_region_check(j, vaddr_lo, vaddr_hi);\n\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                /* Probe: matched region */\n                probe_log_matched_region(i, j);\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            /* Log original warning as before */\n            metal_log(METAL_LOG_WARNING,\n              \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\n            /* Probe: no match, returning error */\n            probe_log_nomatch(i, vaddr_sg_lo, vaddr_sg_hi, (int)ldev->device.num_regions);\n            probe_log_return(-EINVAL);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in) {\n        /* Probe: about to memcpy */\n        probe_log_memcpy(sg_out, sg_in, (size_t)(nents_in * (int)sizeof(struct metal_sg)));\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n        /* Probe: after memcpy */\n        probe_write_log(\"  MEMCPY_DONE\\n\");\n    } else {\n        probe_write_log(\"  SKIP_MEMCPY: sg_out == sg_in\\n\");\n    }\n\n    probe_log_return(nents_in);\n    return nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In metal_uio_dev_dma_map the parameter sg_in is only read: its fields are accessed and it is used as the source for memcpy. The function never modifies the objects pointed to by sg_in, so declaring it as const struct metal_sg *sg_in would be appropriate and would satisfy MISRA C:2023 Rule 8.13 (pointer should point to a const-qualified type whenever possible). Using const is also compatible with memcpy's prototype (const void *src). The function is static (no external linkage/override constraints), so changing the parameter to a pointer-to-const is safe and does not force changes at call sites (non-const-to-const pointer conversion is implicit). The empty test log does not affect this static analysis finding."
}