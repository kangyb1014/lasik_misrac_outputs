{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameters lbus, ldev and sg_in are only read in the function (lbus is unused, ldev fields are only accessed for read, sg_in elements are read) and are not modified. According to MISRA C 2023 Rule 8.13 they should be const-qualified \u2014 e.g. const struct linux_bus *lbus, const struct linux_device *ldev, const struct metal_sg *sg_in. sg_out must remain non-const because it is written (memcpy).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_entry(const struct linux_bus *lbus,\n                            const struct linux_device *ldev,\n                            uint32_t dir,\n                            struct metal_sg *sg_in,\n                            int nents_in,\n                            struct metal_sg *sg_out)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f)\n        return;\n\n    fprintf(f, \"--- metal_uio_dev_dma_map ENTRY ---\\n\");\n    fprintf(f, \"lbus=%p, ldev=%p, dir=%u, nents_in=%d, sg_out=%p\\n\",\n            (void *)lbus, (void *)ldev, (unsigned)dir, nents_in, (void *)sg_out);\n\n    if (ldev) {\n        const int num_regions = (int)ldev->device.num_regions;\n        fprintf(f, \"dev_name=%s, num_regions=%d\\n\",\n                ldev->dev_name ? ldev->dev_name : \"(null)\", num_regions);\n        for (int r = 0; r < num_regions; ++r) {\n            const struct metal_io_region *io = &ldev->device.regions[r];\n            fprintf(f, \"  region[%d]: virt=%p, size=%zu\\n\",\n                    r, io->virt, (size_t)io->size);\n        }\n    }\n\n    for (int i = 0; i < nents_in; ++i) {\n        fprintf(f, \"  sg_in[%d]: virt=%p, len=%zu\\n\",\n                i, sg_in[i].virt, (size_t)sg_in[i].len);\n    }\n\n    fprintf(f, \"--- END ENTRY ---\\n\");\n    fclose(f);\n}\nstatic void probe_log_check_point(int idx,\n                                  void *vaddr_sg_lo,\n                                  void *vaddr_sg_hi,\n                                  void *vaddr_lo,\n                                  void *vaddr_hi,\n                                  int matched)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"check sg[%d]: sg_lo=%p sg_hi=%p region_lo=%p region_hi=%p => %s\\n\",\n            idx, vaddr_sg_lo, vaddr_sg_hi, vaddr_lo, vaddr_hi,\n            matched ? \"MATCHED\" : \"NO_MATCH\");\n    fclose(f);\n}\nstatic void probe_log_failure(int idx, void *vaddr_sg_lo, size_t sg_len)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"FAIL: sg[%d] not in any MMIO region: virt=%p len=%zu\\n\",\n            idx, vaddr_sg_lo, sg_len);\n    fclose(f);\n}\nstatic void probe_log_copy(int will_copy, int nents_in, struct metal_sg *sg_in, struct metal_sg *sg_out)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f)\n        return;\n    if (will_copy) {\n        fprintf(f, \"memcpy: copying %d entries (%zu bytes) from %p to %p\\n\",\n                nents_in, (size_t)(nents_in * sizeof(struct metal_sg)), (void *)sg_in, (void *)sg_out);\n    } else {\n        fprintf(f, \"no memcpy: sg_out == sg_in (%p)\\n\", (void *)sg_in);\n    }\n    fclose(f);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    /* Log entry and static state to help reproduce the Rule 8.13 scenario. */\n    probe_log_entry(lbus, ldev, dir, sg_in, nents_in, sg_out);\n\n    (void)lbus; /* keep original explicit discard of lbus to preserve intent */\n    (void)dir;  /* dir is not used by logic beyond being logged */\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                probe_log_check_point(i, vaddr_sg_lo, vaddr_sg_hi, vaddr_lo, vaddr_hi, 1);\n                break;\n            }\n            probe_log_check_point(i, vaddr_sg_lo, vaddr_sg_hi, vaddr_lo, vaddr_hi, 0);\n        }\n        if (j == (int)ldev->device.num_regions) {\n            probe_log_failure(i, vaddr_sg_lo, (size_t)sg_in[i].len);\n            metal_log(METAL_LOG_WARNING,\n              \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in) {\n        probe_log_copy(1, nents_in, sg_in, sg_out);\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n    } else {\n        probe_log_copy(0, nents_in, sg_in, sg_out);\n    }\n    return nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in spirit: lbus, ldev and sg_in are only read (lbus is unused) so, per MISRA C 2023 Rule 8.13, they should be declared to point to const-qualified types (e.g. const struct linux_bus *lbus, const struct linux_device *ldev, const struct metal_sg *sg_in). sg_out must remain non-const because it can be written (memcpy). Also, if you make ldev const you would need to adjust the local io variable to point to a const metal_io_region (const struct metal_io_region *io) to avoid discarding qualifiers. The memcpy call is compatible with a const-qualified source (memcpy takes a const void *src). One important caveat: if this function signature must match an external API/callback that requires non-const pointer types, the signature cannot be changed and a documented deviation (justification) is required. Absent that external constraint, the reported violation of Rule 8.13 is correct."
}