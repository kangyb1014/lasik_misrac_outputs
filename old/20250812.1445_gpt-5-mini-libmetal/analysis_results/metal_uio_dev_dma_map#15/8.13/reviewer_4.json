{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointers vaddr_lo (and vaddr_hi/vaddr_sg_lo/vaddr_sg_hi) are declared as void * but are only used for reading (comparisons and pointer arithmetic). They could be declared as pointing to const-qualified data (for example, const void *vaddr_lo) so that the pointee is const-qualified. Therefore the code fragment vaddr_hi = vaddr_lo + io->size; participates in a violation of MISRA C 2023 Rule 8.13 because the pointers point to non-const-qualified types even though the pointee is not modified.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    probe_log(\"enter: %s, dev_name=%s, nents_in=%d, sg_in=%p, sg_out=%p\",\n              __func__, ldev ? ldev->dev_name : \"(null)\", nents_in,\n              (void *)sg_in, (void *)sg_out);\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n        probe_log(\"outer-loop i=%d: sg[%d].virt=%p, len=%lu, sg_lo=%p, sg_hi=%p\",\n                  i, i, (void *)sg_in[i].virt, (unsigned long)sg_in[i].len,\n                  (void *)vaddr_sg_lo, (void *)vaddr_sg_hi);\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            probe_log(\"  inner-loop j=%d: io->virt=%p, io->size=%lu, vaddr_lo=%p, vaddr_hi=%p\",\n                      j, (void *)io->virt, (unsigned long)io->size,\n                      (void *)vaddr_lo, (void *)vaddr_hi);\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                probe_log(\"  match found at j=%d for outer i=%d: sg_lo=%p >= lo=%p and sg_hi=%p <= hi=%p\",\n                          j, i, (void *)vaddr_sg_lo, (void *)vaddr_lo,\n                          (void *)vaddr_sg_hi, (void *)vaddr_hi);\n                break;\n            }\n        }\n        probe_log(\"after inner-loop: i=%d, j=%d, num_regions=%d\",\n                  i, j, (int)ldev->device.num_regions);\n        if (j == (int)ldev->device.num_regions) {\n            probe_log(\"error: input address isn't MMIO addr for sg[%d]: virt=%p, len=%lu\",\n                      i, (void *)vaddr_sg_lo, (unsigned long)sg_in[i].len);\n            metal_log(METAL_LOG_WARNING,\n              \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            probe_log(\"returning -EINVAL from %s\", __func__);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in) {\n        probe_log(\"copying sg arrays: sg_out=%p, sg_in=%p, nents_in=%d\",\n                  (void *)sg_out, (void *)sg_in, nents_in);\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n        probe_log(\"copy complete\");\n    } else {\n        probe_log(\"no copy needed: sg_out == sg_in\");\n    }\n    probe_log(\"exit: returning %d\", nents_in);\n    return nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 8.13 recommends that a pointer used only to access (not modify) the object it points to should be declared to point to a const-qualified type. In metal_uio_dev_dma_map the local temporaries vaddr_sg_lo, vaddr_sg_hi, vaddr_lo and vaddr_hi are only assigned from existing region/sg pointers and used for pointer arithmetic and comparisons \u2014 there is no modification of the pointed-to memory. Therefore, per MISRA C 2023 Rule 8.13 they should be declared as pointers to const (for example const void *vaddr_lo, etc.).\n\nNotes/caveats: (1) Converting the locals to const pointers is safe when the source members (io->virt, sg_in[i].virt) are non-const (implicit qualification addition is allowed). (2) Pointer arithmetic on void * is a compiler extension; if strict standard-compliance is desired you may prefer const unsigned char * (or const uint8_t *)/const char * for arithmetic/comparisons. (3) If other code relies on modifying through these locals (it does not in the shown fragment) then making them const would be inappropriate. Given the shown code, the agent A\u2019s diagnosis is correct."
}