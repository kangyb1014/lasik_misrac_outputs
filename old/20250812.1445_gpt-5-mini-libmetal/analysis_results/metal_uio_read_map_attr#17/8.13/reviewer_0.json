{
  "user_message": "An agent A claimed that the following metal_uio_read_map_attr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_read_map_attr.\n```c\nstatic int metal_uio_read_map_attr(struct linux_device *ldev,\n\t\t\t\t   unsigned int index,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned long *value)\n{\n\tconst char *cls = ldev->cls_path;\n\tstruct sysfs_attribute *attr;\n\tchar path[SYSFS_PATH_MAX];\n\tint result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/maps/map%u/%s\", cls, index, name);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tattr = sysfs_open_attribute(path);\n\tif (!attr || sysfs_read_attribute(attr) != 0) {\n\t\tsysfs_close_attribute(attr);\n\t\treturn -errno;\n\t}\n\n\t*value = strtoul(attr->value, NULL, 0);\n\n\tsysfs_close_attribute(attr);\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'ldev' is declared as 'struct linux_device *ldev' but is only read (ldev->cls_path) and not modified. According to MISRA C 2023 Rule 8.13 it should be declared as 'const struct linux_device *ldev'. The other pointers are correctly qualified: 'name' is const (input) and 'value' must remain non-const (output).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_uio_read_map_attr(struct linux_device *ldev,\n                   unsigned int index,\n                   const char *name,\n                   unsigned long *value)\n{\n    const char *cls = ldev ? ldev->cls_path : \"(null)\";\n    struct sysfs_attribute *attr;\n    char path[SYSFS_PATH_MAX];\n    int result;\n\n    /* Open log early. We avoid making logging change returned errno for\n     * branches that return -errno by saving errno when needed. */\n    FILE *log = fopen(\"/tmp/logs/139.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"ENTER: metal_uio_read_map_attr: ldev=%p cls_path=%s index=%u name=%p\\n\",\n                (void *)ldev, cls, index, (const void *)name);\n        if (name)\n            fprintf(log, \"  name=\" \"%s\" \"\\n\", name);\n        fflush(log);\n    }\n\n    result = snprintf(path, sizeof(path), \"%s/maps/map%u/%s\", cls, index, name);\n    if (log) {\n        fprintf(log, \"  snprintf -> result=%d path=\\\"%s\\\"\\n\", result, path);\n        fflush(log);\n    }\n    if (result >= (int)sizeof(path)) {\n        if (log) {\n            fprintf(log, \"  ERROR: path overflow (result=%d, buf=%zu)\\n\", result, sizeof(path));\n            fclose(log);\n        }\n        return -EOVERFLOW;\n    }\n\n    attr = sysfs_open_attribute(path);\n    if (log) {\n        fprintf(log, \"  sysfs_open_attribute -> attr=%p\\n\", (void *)attr);\n        fflush(log);\n    }\n\n    if (!attr || sysfs_read_attribute(attr) != 0) {\n        /* preserve errno value that describes the sysfs failure */\n        int saved_errno = errno;\n\n        if (log) {\n            fprintf(log, \"  sysfs_read_attribute failed or attr==NULL, errno=%d (%s)\\n\",\n                    saved_errno, saved_errno ? strerror(saved_errno) : \"(no error)\");\n        }\n\n        sysfs_close_attribute(attr);\n\n        if (log) {\n            fprintf(log, \"  returning -errno = -%d\\n\", saved_errno);\n            fclose(log);\n        }\n\n        return -saved_errno;\n    }\n\n    if (log) {\n        fprintf(log, \"  attr->value=\\\"%s\\\"\\n\", attr->value ? attr->value : \"(null)\");\n        fflush(log);\n    }\n\n    *value = strtoul(attr->value, NULL, 0);\n\n    if (log) {\n        fprintf(log, \"  parsed value=%lu stored at %p\\n\", *value, (void *)value);\n    }\n\n    sysfs_close_attribute(attr);\n\n    if (log) {\n        fprintf(log, \"EXIT: metal_uio_read_map_attr -> 0\\n\");\n        fclose(log);\n    }\n\n    return 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_read_map_attr. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The parameter ldev is only read (ldev->cls_path) and never used to modify the pointed-to object, so per MISRA C 2023 Rule 8.13 it should be declared as pointing to a const-qualified type (i.e. const struct linux_device *ldev). There is no use in the function that requires a modifiable linux_device, the function is static (internal linkage) so changing the signature would not violate an external API, and no calls in the shown code require a non-const pointer. Therefore the claim of a Rule 8.13 violation is valid. (Any legitimate exception would need to be justified \u2014 for example if the function must match an external non-const API or passes ldev to callers that require a non-const pointer \u2014 none of which is shown.)"
}