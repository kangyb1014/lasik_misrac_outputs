{
  "user_message": "An agent A claimed that the following metal_shmem_open_generic code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open_generic.\n```c\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If either pointer passed to strcmp is NULL or points to a non\u2013NUL-terminated buffer (for example, name supplied by the caller is not NUL-terminated or shmem->name has been corrupted/not terminated), strcmp(shmem->name, name) may read past the bounds of the referenced object and thus violate the rule. There is no prior check for NULL or guaranteed termination in the shown code, so this use can violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint metal_shmem_open_generic(const char *name, size_t size,\n                             struct metal_io_region **result)\n{\n    struct metal_generic_shmem *shmem;\n    struct metal_list *node;\n    FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n    int iter = 0;\n\n    if (logf) {\n        fprintf(logf, \"metal_shmem_open_generic called: name=%p, size=%zu, result=%p\\n\",\n                (const void *)name, size, (void *)result);\n        fflush(logf);\n    }\n\n    /* Iterate the list head directly to avoid relying on macros. */\n    for (node = _metal.common.generic_shmem_list; node != NULL; node = node->next) {\n        iter++;\n        /* In our minimal model, node is the first member, so container_of is a cast. */\n        shmem = (struct metal_generic_shmem *)node;\n\n        if (logf) {\n            fprintf(logf, \"iter %d: node=%p, shmem=%p, shmem->name=%p, name=%p, io.size=%zu\\n\",\n                    iter,\n                    (void *)node,\n                    (void *)shmem,\n                    (const void *)shmem->name,\n                    (const void *)name,\n                    metal_io_region_size(&shmem->io));\n            fflush(logf);\n        }\n\n        /*\n         * Conservative logging behavior: avoid calling strcmp if either pointer is NULL.\n         * This prevents introducing additional undefined behaviour while still logging\n         * the pointers and the context to help reproduce the reported scenario.\n         */\n        if (shmem->name == NULL || name == NULL) {\n            if (logf) {\n                fprintf(logf, \"  -> Skipping strcmp because %s is NULL (shmem->name=%p, name=%p)\\n\",\n                        shmem->name == NULL ? \"shmem->name\" : \"name\",\n                        (const void *)shmem->name, (const void *)name);\n                fflush(logf);\n            }\n            /* To remain conservative, behave as if strings don't match and continue. */\n            continue;\n        }\n\n        /* Both pointers non-NULL: perform strcmp as in the original code and log the result. */\n        {\n            int cmp = strcmp(shmem->name, name);\n            if (logf) {\n                fprintf(logf, \"  -> strcmp(shmem->name, name) returned %d\\n\", cmp);\n                fflush(logf);\n            }\n            if (cmp != 0)\n                continue;\n        }\n\n        if (size <= metal_io_region_size(&shmem->io)) {\n            if (logf) {\n                fprintf(logf, \"  -> Found matching shmem (shmem=%p). Returning region %p.\\n\",\n                        (void *)shmem, (void *)&shmem->io);\n                fflush(logf);\n            }\n            if (result)\n                *result = &shmem->io;\n            if (logf)\n                fclose(logf);\n            return 0;\n        } else {\n            if (logf) {\n                fprintf(logf, \"  -> Name matched but region too small: requested=%zu, available=%zu\\n\",\n                        size, metal_io_region_size(&shmem->io));\n                fflush(logf);\n            }\n        }\n    }\n\n    if (logf) {\n        fprintf(logf, \"No matching shmem entry found. Returning -ENOENT\\n\");\n        fclose(logf);\n    }\n\n    return -ENOENT;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct as stated: strcmp(shmem->name, name) will read each argument until a NUL byte is seen and thus can read beyond the bounds of the objects referenced by those pointers if either pointer is NULL or not NUL\u2011terminated. MISRA C:2023 Rule 21.17 forbids uses of <string.h> functions that can result in out\u2011of\u2011bounds accesses. The shown snippet performs no NULL checks on name or shmem->name and does not otherwise demonstrate a guaranteed NUL\u2011termination invariant for those buffers, so the call is a potential violation.\n\nNote: If elsewhere in the program there is a documented and enforceable contract (and provable invariants) that both pointers are non\u2011NULL and point to valid NUL\u2011terminated arrays of sufficient storage, then the use could be compliant. However, in the absence of such evidence in the shown code, the agent\u2019s claim that this use may violate MISRA 21.17 is correct. Recommended fixes include validating pointers before calling strcmp, bounding comparisons (e.g. strncmp or checking lengths via a safe length function), or ensuring and proving that both stored and caller strings are always non\u2011NULL and NUL\u2011terminated."
}