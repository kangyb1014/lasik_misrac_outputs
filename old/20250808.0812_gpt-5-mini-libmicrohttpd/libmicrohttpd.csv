file,func,rule_index,classifier_answer,scenario,reviewer_comment,is_T_or_F
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,14.2,False,"No violation: the function MHD_digest_auth_calc_userdigest contains no for statements. MISRA C:2023 Rule 14.2 applies to for loops (their initialization, condition and iteration clauses); since there are no for loops in this function or in the inlined helper calls shown, the rule is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,17.8,False,"No violation: none of the function parameters are assigned to or otherwise modified. The pointer parameter userdigest_bin is passed to calc_userdigest and may cause modification of the pointed-to object (allowed by the rule), but the pointer itself is not changed. No assignments to algo3, username, realm, password, userdigest_bin, or bin_buf_size occur in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,21.17,True,"A caller provides a username or realm that is not NUL-terminated (for example, a fixed-size buffer filled from network input without a terminating '\0'). The function calls strlen(username) / strlen(realm) which will scan memory beyond the object's bounds looking for a NUL byte, causing an out-of-bounds access (undefined behavior).","The report is correct. The function calls strlen(username) and strlen(realm) on caller-supplied char pointers without any bounds or termination checks. strlen scans memory until it finds a NUL byte; if the caller supplies a non‑NUL‑terminated buffer (or a pointer to an object whose accessible bytes do not include a terminating '\0'), those strlen calls can read past the object bounds, producing undefined behavior and violating MISRA C 2023 Rule 21.17. 

To conform, the code must ensure the accesses cannot exceed the object bounds (for example: accept and use explicit lengths, use a bounded variant such as strnlen with a known maximum that is guaranteed not to exceed the object, or otherwise establish and document/verify the precondition that the pointers reference NUL-terminated arrays of sufficient size). As written, there is no such guarantee or check, so the reported violation is valid.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,21.14,False,"No use of memcmp to compare null-terminated strings in the provided code. The function MHD_digest_auth_calc_userdigest and the helper functions only call strlen to obtain lengths and pass explicit lengths to binary update routines; no memcmp call is present anywhere in the shown code, so the specific MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,8.13,False,"No violation: the userdigest_bin pointer is used to receive a computed digest (written by calc_userdigest → digest_calc_hash). Because the object pointed to is modified, the pointer must NOT be const-qualified; the code correctly uses a non-const void * and passes it to uint8_t * parameters that are written. Thus Rule 8.13 (prefer const where possible; do not use const if the callee modifies the object) is respected here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,2.1,False,"No violation: all branches in MHD_digest_auth_calc_userdigest are reachable depending on runtime inputs and build-time macros. The function can return early when digest_init_one_time fails, or proceed to the size check and take the > bin_buf_size branch or the else branch (where the digest is calculated). The optional MHD_DIGEST_HAS_EXT_ERROR block is compiled in only when the macro is defined; when it is defined its body is reachable at runtime if digest_ext_error(&da) is true. The apparent panic/assert in digest_get_size is only reachable if an invalid/unsupported algorithm slips through initialization, which digest_init_one_time prevents, so it is an assertion for defensive checking rather than unreachable code within correct builds. Therefore Rule 2.1 (no unreachable code) is not violated by the provided function implementation.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,1.2,False,"No compiler language extensions detected. The code uses standard C constructs (enum, struct, const, size_t, preprocessor conditionals). The _MHD_EXTERN token is a macro invocation, not an explicit compiler language extension; no compiler-specific keywords (e.g. __attribute__, typeof, asm, statement expressions, nested functions) are present. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_calc_userdigest,2.2,True,"The call to digest_deinit(&da) is dead code. In the provided project digest_deinit is defined as a no-op macro (#define digest_deinit(da) (void)0). The digest_deinit(&da) statement is executed but has no effect; removing it would not change program behaviour, so Rule 2.2 is violated.","The agent A’s report is correct under the conditions they stated. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not change program behaviour. If, for the given project configuration, digest_deinit is indeed defined as a no-op macro (e.g. #define digest_deinit(da) (void)0), then the statement digest_deinit(&da); is executed but has no observable effect and could be removed without changing behaviour—therefore it is dead code and violates Rule 2.2.

Notes and caveats:
- Dead-code determination is project-specific. If in some build configurations digest_deinit is a real function with side effects (or the macro expands to code that has observable effects or timing consequences), then the call would not be dead in that build and would not violate Rule 2.2 in that configuration. MISRA analysis must use the actual project (build-config) definitions.
- The test harness failing to compile does not change the semantic conclusion: given the claimed project-wide no-op definition, the call is dead.

Recommended remedies: remove the call when the deinit is a known no-op, or guard it with conditional compilation (only emit the call when a non‑no‑op deinit is present), or ensure the deinit macro produces an observable effect if it must remain in source for API symmetry.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,14.2,False,"No for-loop is present in get_rq_uname or the provided related functions. Since Rule 14.2 applies to for statements and none exist in the shown code, the rule is not violated (not applicable).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,17.8,False,"No violation: get_rq_uname does not assign to any of its parameter variables. It only modifies members of the object(s) pointed to by pointer parameters (e.g., uname_info->...), which is permitted. A violating scenario would be if the function reassigned a parameter pointer (for example, 'buf = buf + n;' or 'uname_info = some_other_pointer;') or modified a non-pointer parameter (for example, 'uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;').",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,21.17,True,"Violation: In the STANDARD and USERHASH branches there is no check that the remaining buffer (buf_size - buf_used) is large enough before calling get_rq_param_unquoted_copy_z which internally does memcpy(buf, param->value.str, param->value.len) and writes a terminating NUL. If param->value.len + 1 > buf_size - buf_used this results in writing beyond the bounds of buf. In the USERHASH branch, after copying the hex string there is likewise no check that the remaining buffer is large enough for the binary output of MHD_hex_to_bin, so that call can also write beyond buf. Both cases violate MISRA C 2023 Rule 21.17.","The report is correct. In the STANDARD branch the code sets uname_info->username = buf + buf_used and then calls get_rq_param_unquoted_copy_z without checking that buf_size - buf_used is large enough to hold the copied bytes plus the terminating NUL. If the helper actually copies param->value.len (or param length minus quotes) bytes and then writes a NUL (for example via memcpy or a manual copy), this can write past buf. Likewise in the USERHASH branch the hex string is copied into the remaining buffer without checking remaining space, and then MHD_hex_to_bin is invoked to write the binary output at buf + buf_used; there is no check that the remaining space can hold the binary output (res bytes). The final mhd_assert(buf_size >= buf_used) is only a postcondition/test and does not prevent the intermediate out-of-bounds writes.

The validity of the violation depends on the implementations of get_rq_param_unquoted_copy_z and MHD_hex_to_bin; if those helpers perform unbounded memcpy-like writes, then Rule 21.17 is violated. Given the presented scenario (and the example test helper implementations), the calls can indeed result in out-of-bounds accesses, so the report is correct. Recommended fix: check (param_len + 1) <= (buf_size - buf_used) before copying, or change the helpers to accept a destination size and fail safely if insufficient space, and check remaining space before calling MHD_hex_to_bin (e.g. ensure (hex_len/2) <= (buf_size - buf_used)).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,21.14,True,"Violation occurs when an extended-notation username is used: get_rq_uname produces a null-terminated username (uname_info->username) and later digest_auth_check_all_inner obtains r_uname via get_rq_extended_uname_copy_z (also null-terminated). The code in digest_auth_check_all_inner then uses memcmp(username, r_uname, username_len) to compare these null-terminated strings — this use of memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.","MISRA C:2023 Rule 21.14 forbids using the standard function memcmp to compare null-terminated strings. The supplied get_rq_uname implementation does not call memcmp; it only constructs and returns NUL-terminated strings (and lengths). Creating or returning NUL-terminated strings is not a violation. If digest_auth_check_all_inner later calls memcmp(username, r_uname, username_len) to compare those NUL-terminated strings, the violation would be at that memcmp call site, not inside get_rq_uname. The agent A did not provide the digest_auth_check_all_inner code (and their test harness failed to compile), so there is no direct evidence that a memcmp on NUL-terminated strings actually occurs. Therefore the report that get_rq_uname itself violates MISRA Rule 21.14 is incorrect. (Note: if another function indeed uses memcmp to compare NUL-terminated strings, that call would violate 21.14 and should be replaced by strcmp/strncmp or another appropriate string comparison.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,8.13,False,"No violation. get_rq_uname declares the input parameter params as const (const struct MHD_RqDAuth *params) so read-only input is const-qualified. The function writes into the provided buffer (buf) and populates uname_info, so those pointers are correctly non-const (uint8_t *buf and struct MHD_DigestAuthUsernameInfo *uname_info). There is no place where a pointer to a const-qualified type is subsequently used to modify the pointed-to object. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,2.1,True,"The final 'else' branch (mhd_assert(0); uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;) is effectively unreachable in the project: get_rq_uname is static and all callers only invoke it after checking that uname_type is neither MISSING nor INVALID, so only STANDARD, USERHASH or EXTENDED values reach this function. Consequently the default 'else' path cannot be executed in normal project use and is unreachable code.","The report is not correct. MISRA Rule 2.1 forbids code that cannot be reached by any possible program execution in the project; to claim a branch is unreachable you must show (for the whole project) that no execution path can ever take it. The final else in get_rq_uname is only asserted to be impossible at runtime (mhd_assert and precondition checks), but that is not a compile‑time proof of impossibility across the project. In particular:
- get_rq_uname is static so callers are limited to the translation unit, but the snippet does not prove (and there is no global, static-analysis evidence here) that every caller will always pass only STANDARD, USERHASH or EXTENDED. A change or a faulty caller could pass another enum value. That makes the else reachable in principle.
- The code relies on mhd_assert to detect impossible states at runtime. Assertions are runtime checks (and in some builds may be compiled out); they do not render the else branch provably unreachable for the purposes of MISRA’s requirement.
- The provided test harness failed to compile and therefore supplies no evidence that the branch is unreachable.
Because there is no incontrovertible project‑wide proof that the default else can never execute, the branch cannot be classified as unreachable code under MISRA 2.1. Therefore the agent A’s claim of a Rule 2.1 violation is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,1.2,False,"No compiler-specific language extensions are used in get_rq_uname or the related code. The code uses standard C features (enums, casts, inline via macros, preprocessor conditionals, standard types such as uint8_t and ssize_t provided by headers). No compiler-specific keywords, attributes, or extensions are present, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_uname,2.2,False,"No violation. All assignments and branch actions in get_rq_uname can affect observable behaviour depending on the uname_type path: the initial zeroing of uname_info members is required for the USERHASH/other paths where those members are not overwritten; each branch sets fields used later; the USERHASH special-case for res==0 avoids an out-of-bounds pointer; the final else is effectively unreachable in normal use but unreachable code is explicitly excluded from Rule 2.2. The mhd_assert calls expand to no-ops in production builds (so they are not executed), and thus are not ""dead code"" per the rule. Therefore the function does not contain executed operations whose removal would not change program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,14.2,False,"No violation: MHD_digest_auth_get_request_info3 contains no for-loops. The related for-loops in the provided additional code (for example in parse_dauth_params: for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p) and in find_auth_rq_header_: for (h = c->rq.headers_received; NULL != h; h = h->next)) are well-formed: the first clause initializes the single loop counter, the second clause is a side-effect-free condition that uses only the loop counter (and constants), and the third clause modifies only the loop counter. The loop counters are not modified in the loop bodies and called functions do not alter those loop counters; therefore MISRA C 2023 Rule 14.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,17.8,False,"No violation: the function parameter 'connection' is not modified. The code only reads from 'connection' and passes it to helper functions (MHD_get_rq_dauth_params_, MHD_calloc_, etc.). There is no assignment to the parameter variable 'connection' nor any re-assignment of the pointer; only objects reachable via the pointer are read. Thus Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,21.17,False,"No violation: buffer sizes for username, opaque and realm are computed (via get_rq_unames_size and explicit +1 allocations) so memcpy and other string writes are bounded by the allocated unif_buf_size and mhd_assert checks; functions that write into temporary stack buffers (e.g. unq[16]) check lengths before use. Therefore no use of <string.h> functions accesses beyond referenced object bounds in the shown control paths.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,21.14,False,"No direct use of the C standard library function memcmp is present in MHD_digest_auth_get_request_info3 or in the closely related helper functions shown. All string comparisons in the provided code use length-limited comparison helpers (e.g. MHD_str_equal_caseless_bin_n_, MHD_str_equal_caseless_quoted_s_bin_n_), and copying/unquoting routines explicitly handle lengths and zero-termination. Therefore there is no instance of memcmp being used to compare null-terminated strings in the provided code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,8.13,False,"No violation. The function already uses a const-qualified pointer for the input request parameters (const struct MHD_RqDAuth *params). All other pointers that are non-const point to buffers that the function (or called helpers) write into (info, unif_buf_ptr, info->opaque, info->realm, info->nc, etc.). Calls that only read from params receive the const pointer. The cast of info to struct MHD_DigestAuthUsernameInfo *is used because the function (get_rq_uname) populates that writable structure. Therefore there is no place where a pointer could/should be const-qualified but is not, and no pointer to const is incorrectly used for writable data.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,2.1,False,"No violation. The function contains no unreachable code: the early return when params == NULL is reachable; both branches of the uname_type check are reachable depending on get_rq_uname_type(params); the code that handles opaque, realm, cnonce and nc are all reachable depending on the request parameters. Internal mhd_assert() invocations are no-ops (defined to ((void)0)) so they do not introduce unreachable code. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,1.2,True,"The code uses a compiler-specific GCC/Clang attribute via the _MHD_EXTERN macro (defined as __attribute__((visibility(""default"")))extern). The use of __attribute__((...)) is a compiler language extension and therefore violates MISRA C 2023 Rule 1.2.","Agent A’s report is correct provided the macro expands as claimed. The GCC/Clang attribute syntax __attribute__((...)) is a compiler language extension (documented as such by those compilers). If _MHD_EXTERN expands to __attribute__((visibility(""default""))) extern, that is a use of a compiler-specific language extension and therefore breaches MISRA C 2023 Rule 1.2 (Language extensions should not be used). Note: the snippet shown does not include the macro definition, so you must confirm _MHD_EXTERN is indeed defined that way in the project. The test code failing to compile is likely due to the missing macro/headers in the isolated test harness and does not affect the rule assessment.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,MHD_digest_auth_get_request_info3,2.2,False,"No violation: all executed statements in MHD_digest_auth_get_request_info3 contribute to the returned MHD_DigestAuthInfo or affect control flow. Assertions are defined as mhd_assert((void)0) and thus compile to no-ops (not executed), but they are not executed code paths and do not constitute executed dead code. No operation can be removed without potentially changing observed behavior (buffer sizing, allocations, field initializations, parsing results, nc handling).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,14.2,False,"No violation: get_nonce_timestamp contains no for loop constructs. Rule 14.2 applies to for-statements; since this function uses if statements and calls MHD_strx_to_uint64_n_ (which contains a while loop), there is no for loop to be checked for the well-formed constraints, so the rule is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,17.8,True,"Violation occurs when the incoming noncelen parameter is zero. The function assigns to the parameter (noncelen = strlen(nonce);), i.e. it modifies a function parameter passed by value. This breaks MISRA C 2023 Rule 17.8 (a function parameter should not be modified). The specific control path is: entry -> noncelen == 0 -> assignment to noncelen -> subsequent processing uses the modified noncelen to compute the timestamp substring and parse it.","The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; this includes scalar (by-value) parameters. In the provided get_nonce_timestamp implementation, when noncelen == 0 the code assigns to the parameter noncelen (noncelen = strlen(nonce);), which is a direct modification of a function parameter and thus violates Rule 17.8. (Modifying the object pointed to by a pointer parameter would be allowed, but that exception does not apply to plain by-value parameters like noncelen.)

A compliant fix is to use a local variable (for example, size_t len = noncelen;) and modify that local copy instead of the parameter, e.g. if (len == 0) len = strlen(nonce); then use len in the rest of the function.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,21.17,True,"Violation occurs when noncelen is zero and nonce points to a buffer that is not NUL-terminated (for example a fixed-size binary digest). The call to strlen(nonce) will read past the end of that buffer searching for a '\0', resulting in an out-of-bounds access.","The report is correct. The function calls strlen(nonce) when noncelen == 0. If the caller supplied nonce as a fixed-size binary buffer that is not NUL-terminated (and noncelen was passed as 0), strlen will scan past the end looking for '\0' and can perform out‑of‑bounds reads. That behaviour is exactly what MISRA C 2023 Rule 21.17 forbids (string.h functions must not result in accesses beyond the bounds of the objects referenced). Note: if there is a documented or enforced precondition that nonce is a NUL‑terminated C string whenever noncelen==0 then the call would be safe, but the code as written does not enforce or check that precondition, so the potential out‑of‑bounds access makes the report valid. A safe fix is to require an explicit length (do not call strlen), or ensure/validate NUL termination within known bounds (e.g. use memchr with a known maximum length), or document and enforce the precondition.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,21.14,False,"No violation: get_nonce_timestamp does not call memcmp to compare null-terminated strings. It uses strlen to determine length when noncelen is zero and compares integer lengths against expected digest-derived sizes; the timestamp portion is parsed with MHD_strx_to_uint64_n_, which scans characters rather than using memcmp. No use of memcmp (direct or indirect) is present in the provided code paths.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,8.13,False,No violation. The function correctly qualifies nonce as const char *const since the function does not modify the pointed bytes. The ptimestamp parameter is a pointer to non-const uint64_t because the function (via MHD_strx_to_uint64_n_) writes the parsed timestamp into *ptimestamp; therefore it must not be a pointer-to-const. This conforms to Rule 8.13.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,2.1,False,"No violation: all code paths in get_nonce_timestamp are reachable depending on the runtime value of noncelen and the contents of nonce. The preprocessor may remove some comparisons when support macros are not defined, but that only changes which runtime checks exist — it does not introduce unreachable code. Both return false and the final return true can be reached at runtime for appropriate inputs, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,1.2,False,"No language extensions detected. The function uses standard C features (const, size_t, uint64_t, bool/false/true from <stdbool.h>, preprocessor conditionals and ordinary macros). Constructs such as inline (via _MHD_static_inline macro), switch/case labels, and hex-literal case constants are standard C, not compiler extensions. I inspected the conditional compilation blocks and macros — they are ordinary preprocessor usage, not compiler language extensions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_nonce_timestamp,2.2,False,"No violation: get_nonce_timestamp does not contain dead code. All executed operations (the optional strlen assignment, the conditional checks that may return false, and the timestamp conversion) affect control flow or outputs; the leading 'true' in the if-expression is a harmless constant used to simplify preprocessor composition and does not constitute an executed operation that can be removed without changing behavior. Conditional compilation can alter which comparisons are present, but that only changes reachable control paths, not produce code that is both executed and removable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,14.2,False,"No violation: the only for loop (in MHD_str_equal_caseless_bin_n_) is well-formed. First clause initializes loop counter (i = 0), second clause (i < len) uses the loop counter and a read-only object (len) which is not modified in the loop body, third clause (++i) modifies only the loop counter, and there is a single loop counter not modified in the body. Therefore Rule 14.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,17.8,False,"No violation: get_rq_extended_uname_copy_z does not assign to any of its parameter variables. It modifies the object pointed to by 'buf' (writes decoded bytes) which is permitted, and it indexes into 'uname_ext' and computes uname_ext + r for a call, but never reassigns the pointer parameters themselves.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,21.17,False,"No violation of MISRA C 2023 Rule 21.17. The function get_rq_extended_uname_copy_z does not call any of the <string.h> standard library functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.) targeted by Rule 21.17, so the rule is not applicable. (Note: there is a separate potential out‑of‑bounds risk if buf_size == 0 because the function writes buf[w] = 0 when w == 0; this is a different issue and not a violation of Rule 21.17 as stated.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,21.14,False,"No violation: get_rq_extended_uname_copy_z does not call memcmp to compare null-terminated strings. It uses MHD_str_equal_caseless_bin_n_ with an explicit length (MHD_STATICSTR_LEN_(MHD_DAUTH_EXT_PARAM_PREFIX)), which performs a bounded character-by-character comparison and does not rely on memcmp or null termination. Other helper functions shown (e.g. MHD_str_pct_decode_strict_n_) also do not use memcmp for string comparisons. Therefore Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,8.13,False,"No violation. In get_rq_extended_uname_copy_z the input string pointer uname_ext is declared const char * and is only used for read-only access (passed to functions that accept const char *). The output buffer buf is a non-const char * because the function writes into it (via MHD_str_pct_decode_strict_n_). No const-qualified pointer is passed to a function that modifies the pointed object, and no pointer that could be const is left unqualified. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,2.1,False,"No unreachable code found. All branches and statements in get_rq_extended_uname_copy_z can be reached depending on input values: initial early-return checks return on out-of-range lengths or missing prefix; the language-tag scan loop either returns on encountering invalid characters, exits and then returns if the closing quote is not found, or advances past the quote and proceeds to percent-decoding. The percent-decoder can return 0 for an empty suffix (valid, produces an empty decoded string) or return 0 to indicate broken encoding which triggers the subsequent error return. The final buf[w] = 0 and return (ssize_t)w are reachable when decoding succeeds (including the case of zero-length decoded output). Therefore Rule 2.1 (no unreachable code) is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,1.2,False,"No compiler language extensions detected. The function and related symbols use standard C constructs and portable macros only (macros like MHD_STATICSTR_LEN_ and MHD_DAUTH_EXT_PARAM_PREFIX, use of ssize_t which is a POSIX type, and standard control flow). There are no compiler-specific extensions present (no __attribute__, __asm__, typeof, statement expressions, compiler builtins or other extension tokens). Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,get_rq_extended_uname_copy_z,2.2,False,"No violation: there is no dead code in get_rq_extended_uname_copy_z. Every executed operation either influences control flow or output. The mhd_assert call expands to a no-op macro and therefore is not executed (so it is not 'dead code' as per the rule), and there are no other executed statements whose removal would not change program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,14.2,False,"No violation: digest_auth_check_all_inner contains no for loops, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. All loop constructs referenced in the additional code are outside the inspected function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,17.8,False,"No violation. The function does not assign to any of its parameter variables. The only parameter that leads to side-effects is pbuf (char **): the function creates a const local pointer ptmp2 = pbuf and passes that into helper routines which may modify *ptmp2 (i.e. the char * stored at the caller-provided location). MISRA Rule 17.8 allows modifying the object referred to by a pointer parameter but forbids modifying the pointer itself; here the pointer parameter pbuf is not reassigned (ptmp2 is a const pointer), so the rule is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,21.17,False,"No violation. All uses of <string.h> functions in digest_auth_check_all_inner are guarded by size checks or prior length calculations: get_buffer_for_size allocates or selects a buffer large enough (and callers add +1 where needed), memcpy in get_unquoted_param_copy copies param->value.len into a buffer allocated with param->value.len + 1, memcmp calls always use explicit lengths that do not exceed the involved buffers (lengths are checked earlier or come from strlen on NUL-terminated inputs), and MHD_bin_to_hex / MHD_hex_to_bin usages are preceded by mhd_assert checks ensuring target buffers are large enough. Therefore no path leads to an access beyond object bounds via the standard string functions listed in Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,21.14,True,"Violation occurs when the username is provided in extended notation: the code calls get_rq_extended_uname_copy_z to produce a zero-terminated r_uname and then uses memcmp(username, r_uname, username_len) to compare them. Both operands are null-terminated strings, and memcmp is used to compare them, which violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings).","Agent A's report is correct. In the extended-username branch the code does: username_len = strlen(username); r_uname is produced by get_rq_extended_uname_copy_z (the function name and the code comment indicate it returns a zero-terminated copy), then the code checks (username_len != (size_t) res) || (0 != memcmp(username, r_uname, username_len)). Because username was obtained via strlen it is a null-terminated C string, and r_uname is a zero-terminated C string, memcmp is being used to compare null-terminated strings — this is exactly what MISRA C 2023 Rule 21.14 forbids. (The other memcmp use in the function compares binary hash buffers and is not a string comparison and therefore is not a Rule 21.14 violation.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,8.13,False,"No violation: pointers that can be const are declared const (realm, username, password, userdigest, params, unquoted strings are treated as const), and pointers that must be non-const because the function or helper functions mutate state are non-const (connection, da, pbuf/ptmp2, buffers like tmp1/r_uname). Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,2.1,False,No unreachable code detected in digest_auth_check_all_inner. All control paths either execute reachable statements or return; the use of always-true blocks (if (1)) is intentional and reachable. Preprocessor-disabled sections (#if 0) are not considered unreachable code in compiled output. No dead code paths were found.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,1.2,False,"No language extensions are used in digest_auth_check_all_inner. The function uses standard C constructs, enums, structs, macros, and library-like helper functions only. There are no uses of compiler-specific extensions such as __attribute__, __builtin_..., typeof, nested functions, statement-expressions, inline asm, labels-as-values, or other vendor-specific language features in the function body.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,digest_auth_check_all_inner,2.2,False,"No violation: the function does not contain executed operations that can be removed without changing program behaviour. All statements either perform checks/updates (returns, digest updates, memory operations, nonce checks) or are compile-time/no-op assertions (mhd_assert expands to ((void)0)). The #if 0 sections are excluded by preprocessing. The occasional use of if (1) only provides an inner lexical scope for declarations and does not introduce dead, effectless operations.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,14.2,False,"No violation: the function calculate_add_nonce_with_retry contains no for loops. The only for loop in the related code (in calculate_nonce: for (h = first_header; NULL != h; h = h->next)) satisfies the three clauses — the initializer sets the loop counter, the condition has no side effects and uses only the loop counter, and the iteration expression modifies only the loop counter and does not use objects modified by the loop body. The loop counter is not modified within the loop body.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,17.8,False,"No violation: calculate_add_nonce_with_retry does not modify any of its parameter variables. It only modifies objects pointed to by pointer parameters (e.g. writes into *nonce and updates the DigestAlgorithm via digest_reset), which is permitted by the rule. There are no assignments to the parameter identifiers (no 'connection = ...', 'realm = ...', 'da = ...', or 'nonce = ...'), and the pointer parameter 'connection' is declared as a const pointer ('struct MHD_Connection *const connection'), preventing pointer reassignment.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,21.17,False,"No violation: all uses of string.h functions in calculate_add_nonce_with_retry are bounded. The function computes digest_size = digest_get_size(da) and only copies NONCE_STD_LEN(digest_size) bytes from a local nonce2 buffer into the caller-supplied nonce. The caller (queue_auth_required_response3_inner) allocates and guarantees at least NONCE_STD_LEN(digest_get_size(da)) bytes at buf + p (there is an mhd_assert and calculation of buf_size that reserves that space). strlen(realm) is used on a non-null realm provided by the caller. The stack buffer nonce2 is sized to the maximum NONCE_STD_LEN(MAX_DIGEST)+1, so calculate_add_nonce calls that write into nonce2 cannot overflow it. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,21.14,False,"The code uses memcmp in is_slot_available to compare nonce byte sequences with an explicit length (new_nonce_len). The nonce buffers are treated as fixed-length hex+timestamp data (NONCE_STD_LEN) and the comparison passes the exact length of the nonce without relying on NUL termination. Although nn->nonce is later NUL-terminated for safety, memcmp is used to compare fixed-length binary/string contents, not to compare C NUL-terminated strings; therefore this does not violate MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,8.13,False,"No violation. The non-const pointers in calculate_add_nonce_with_retry are justified: 'da' (struct DigestAlgorithm *) is modified via digest_reset() and is passed to calculate_add_nonce(), so it must be non-const; 'nonce' (char *) is written into (memcpy), so it must be non-const; 'realm' is correctly const-qualified. The connection parameter is declared as struct MHD_Connection *const (pointer itself constant) and is passed to calculate_add_nonce() which expects a non-const connection pointer, so it cannot be changed to point-to-const without changing the called function signature. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,2.1,False,"No violation found. With the provided configuration (HAVE_MESSAGES=1, HAVE_RANDOM=1 and no MHD_DIGEST_HAS_EXT_ERROR defined) there is no unreachable code in calculate_add_nonce_with_retry. Conditional compilation removes alternative branches (such as the HAVE_RAND and the fallback pseudo-random branch) so only the intended code remains; all statements in the compiled function can be reached depending on runtime values (e.g. the calculate_add_nonce return value and timestamp equality).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,1.2,True,The code relies on compiler-specific builtins via the macros _MHD_ROTL32 and _MHD_ROTR32 which expand to GCC/Clang __builtin_rotateleft32 and __builtin_rotateright32. These __builtin_* functions are compiler language extensions (GCC/Clang builtins) and thus violate MISRA C 2023 Rule 1.2 (language extensions should not be used).,"Not enough evidence to conclude a Rule 1.2 violation. The presented function uses the macros _MHD_ROTL32 and _MHD_ROTR32, but their definitions are not shown in the supplied code. MISRA C 2023 Rule 1.2 must be reported only when the code actually uses a compiler language extension (as documented by the compiler). The mere use of macro names that look like they could map to compiler builtins is not sufficient to establish a violation. If those macros expand to standard-C expressions or to user-defined functions, then there is no Rule 1.2 issue. If, however, their definitions expand to compiler-specific builtins such as __builtin_rotateleft32/__builtin_rotateright32 (and those builtins are documented as compiler extensions), then the report would be correct — but that requires inspecting the macro definitions or the headers where they are defined. Note also that the identifiers starting with an underscore and an uppercase letter may raise other portability/reserved-identifier concerns, but that is a separate matter from Rule 1.2.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,calculate_add_nonce_with_retry,2.2,False,"No violation: In the provided build configuration the function contains no executed operations that can be removed without changing program behaviour. Conditional branches that are not compiled in (e.g. blocks under undefined feature macros) are not executed and thus are not dead code per MISRA note 2. The mhd_assert macros are defined as no-ops (compile-time removed), so they are not executed. All runtime statements (timestamp sampling, alternate timestamp generation, digest_reset, calls to calculate_add_nonce and memcpy) influence the control flow or outputs and cannot be removed without changing behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,14.2,False,"No for-loops are present in queue_auth_required_response3_inner. The function uses if/while and calls helper functions, but contains no for statements, so MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,17.8,True,"queue_auth_required_response3_inner modifies several value parameters: malgo3 is reassigned after initial checks, mqop is reassigned to clear a flag, and userhash_support and prefer_utf8 are set to 0 in the RFC2069 branch. These reassignments modify function parameters and thus violate MISRA C 2023 Rule 17.8 (a function parameter should not be modified).","Agent A is correct. MISRA C:2023 Rule 17.8 states that a function parameter shall not be modified (the note only permits modifying the object pointed to by a pointer parameter, not reassigning the pointer or changing value parameters). In queue_auth_required_response3_inner the value parameters malgo3 and mqop are reassigned (e.g. malgo3 = ...; mqop = ...;) and the integer value parameters userhash_support and prefer_utf8 are set to 0. Those are direct modifications of function parameters and therefore violate Rule 17.8. (By contrast, the assignment *buf_ptr = buf modifies the object pointed to by a pointer parameter and is permitted by the rule's note.) To conform, the function should copy parameters it needs to change into local variables and modify those locals instead of reassigning the parameters themselves.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,21.17,False,"No violation: all uses of memcpy, MHD_str_quote, memchr and other <string.h> functions are guarded by explicit size calculations and assertions. The function precomputes buf_size from component lengths (including quoting worst-case), checks realm/opaque/domain lengths and disallows CR/LF, ensures (buf_size - p) is large enough before calling MHD_str_quote, and allocates buffers accordingly. The header name allocation copies the terminating NUL into a properly sized allocation. Nonce generation routines are called with buffers whose sizes have been asserted earlier. Therefore there is no scenario in this function where the string-handling calls can access beyond the bounds of their target objects.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,21.14,False,"No usage of memcmp is present in queue_auth_required_response3_inner or the closely related helper functions shown. All comparisons of strings use strlen/memchr or other string-aware functions; memcpy/memchr are used, but not memcmp against null-terminated strings.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,8.13,False,"No practical violation. The function already uses const-qualified pointers for input string parameters that are not modified (realm, opaque, domain). Pointers that refer to objects modified by this function or passed to callees that modify them are non-const as required (e.g. response, da, buf_ptr, hdr_name, buf). There is no place where a pointer points to non-const data while the data is not modified (i.e. could be made const), nor a pointer to const-qualified type that is modified by this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,1.2,False,"No violation: queue_auth_required_response3_inner does not use any compiler-specific language extensions (no __attribute__, __builtin_*, typeof, statement expressions, or other documented compiler extensions) — it uses standard C constructs and macros only.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/digestauth.c,queue_auth_required_response3_inner,2.2,True,"The statement ""(void) 0;"" used to mute compiler warnings in the branch where calculate_add_nonce_with_retry() fails is executed but has no effect on program behaviour. In addition, invocations of mhd_assert(...) expand to ((void)0) (no-op). These executed no-op operations are dead code according to MISRA C 2023 Rule 2.2: their removal would not affect program behaviour.","Not enough evidence to conclude a MISRA 2.2 violation. The agent’s argument rests on two assumptions: (a) mhd_assert expands to a no-op ((void)0), and (b) HAVE_MESSAGES (and any other related macros) are not defined in the project build so that the only thing executed in the failing branch is the literal ""(void)0;"". MISRA Rule 2.2 is evaluated for the project build configuration. If, in the actual project configuration, assertions are enabled or HAVE_MESSAGES is defined (or other conditional code produces side effects), the calls are not no-ops and therefore not dead. Conversely, only when the whole project is built such that every mhd_assert and any logging macros expand to ((void)0) and the branch in question is exercised at run-time would those executed no-op statements meet the literal definition of dead code. Because the code as presented uses conditional compilation and build-dependent macros, you cannot reliably claim a Rule 2.2 violation without examining the project’s active configuration. The provided test did not produce runtime evidence (it failed to build), so it does not prove the violation. Therefore the report is not correct as a definitive MISRA 2.2 violation; it might be correct for a specific build configuration, but that was not demonstrated.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,14.2,False,"No for statement is present in the provided function. The code uses a while loop but contains no 'for' loops, so MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable and thus not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,17.8,False,"No violation: the pointer parameter 'connection' is not reassigned or modified. The function alters members of the object pointed to (e.g. connection->rq.headers_received_tail) and passes the pointer to helper functions, which is permitted by MISRA C 2023 Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,21.17,False,"No actual violation. The code allocates cpy with hdr_len + 1 bytes, copies hdr_len bytes with memcpy and then writes cpy[hdr_len] = '\0'. parse_cookies_string receives (cpy + i, hdr_len - i) and only writes zero terminators at indices that are guaranteed to map to cpy + hdr_len (the extra byte) or to earlier positions within the allocated region. All string.h calls (memcpy/memset/memcpy in pool routines) are guarded by pool allocation logic and size checks. Therefore no accesses beyond the bounds of the referenced objects occur.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,21.14,False,"No violation: parse_cookie_header and the related functions do not call the standard memcmp to compare null-terminated strings. The function uses memcpy (not memcmp) to copy the header into an allocated buffer and then treats the buffer with explicit lengths. Header name comparisons in MHD_lookup_connection_value_n use length-aware MHD_str_equal_caseless_bin_n_ (called with explicit key_size), not memcmp on null-terminated strings. Therefore Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,8.13,False,"No violation. The pointer to the header text is declared as const char *hdr and is never modified; a mutable copy (char *cpy) is allocated and modified instead. saved_tail is deliberately a pointer to a mutable struct (struct MHD_HTTP_Req_Header *const) because the code assigns saved_tail->next = NULL in the malformed-cookie branch. All pointers that need to be non-const are non-const, and pointers that can be const are const-qualified, so Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,2.1,False,No reachable-unreachable code detected. All control paths either return early (when no cookie header or zero length) or assign parse_res before the switch; the switch covers all expected enum cases and the default contains an assertion to catch impossible values. There is no code that cannot be reached in any valid compilation/configuration of this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,1.2,False,"No compiler-specific language extensions detected in parse_cookie_header. The function uses only standard C constructs (enums, structs, pointers, size_t, bool, standard control flow, casts). There are no GCC/Clang extensions such as nested functions, statement expressions, typeof, asm, attribute((...)), or other documented compiler-specific language extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookie_header,2.2,False,"No violation: parse_cookie_header contains no executed operations that could be removed without changing program behaviour. All variables that are assigned (saved_tail, allow_partially_correct_cookie, parse_res) are used on control paths; early returns are meaningful. The mhd_assert invocations are preprocessor/no-op assertions (expand to ((void)0)) and do not produce executed side effects, and the conditional logging is compiled under HAVE_MESSAGES — none of these produce dead executable operations in the compiled function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,14.2,False,"The function try_ready_chunked_body contains no for statements, so MISRA C 2023 Rule 14.2 (a for loop shall be well-formed) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,17.8,False,"No violation: the function does not assign to the parameter variables 'connection' or 'p_finished'. It only modifies the objects they point to (connection->... fields and *p_finished), which is allowed by the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,21.17,False,"No violation: all uses of string handling functions (memcpy, memset) are guarded so they cannot access beyond object bounds. The code ensures connection->write_buffer_size > max_chunk_overhead, computes size_to_fill = write_buffer_size - max_chunk_overhead and caps ret to size_to_fill before copying into write_buffer at offset max_chunk_hdr_len. Indices written (max_chunk_hdr_len + ret and +1) are therefore <= write_buffer_size-1. For response->data copies, data_write_offset and response->data_size are asserted to be consistent so copying response->data[data_write_offset] for ret bytes stays within response->data. In MHD_pool_reallocate, shrinking cases are handled separately and memcpy to the new block only occurs when old_size <= new_size. MHD_uint32_to_strx is passed the correct buffer size. Hence Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,21.14,False,"No occurrence of the Standard Library function memcmp in try_ready_chunked_body or the closely related helper functions shown. The code uses memcpy and other functions but does not call memcmp to compare null-terminated strings, so Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,8.13,False,"No violation: Pointers that could be const are already const (response->data is const char * and only read). Pointers that are non-const are intentionally so because the function or callbacks modify the pointed objects (bool *p_finished is written, connection and response fields are updated, and the content-reader callback writes into the provided write buffer). Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,2.1,True,"If a response is constructed without a content-reader callback (response->crc == NULL) but also without contiguous response->data covering the current rsp_write_position (for example when using MHD_create_response_from_iovec that results in data_iov being used rather than response->data), execution can reach the branch labelled ""There is no way to reach this code"". In other words, the comment is incorrect and that branch is potentially reachable (it handles the case when no callback is available to provide chunked data). Because there exists a feasible control-path to that block, the function contains code that was presumed unreachable and therefore the project violates MISRA C 2023 Rule 2.1.","The agent's report is not correct. The branch guarded by ""if (NULL == response->crc) { /* There is no way to reach this code */ }"" is reachable in normal control flow. The earlier assertion mhd_assert (NULL != response->crc || NULL != response->data) only guarantees that at least one of response->crc or response->data is non-NULL; it does not guarantee that response->data covers the current rsp_write_position. If response->data is non-NULL but the condition testing whether the current rsp_write_position falls inside the contiguous data region fails, and response->crc is NULL, execution will take the else path and hit the NULL == response->crc branch. That is a perfectly feasible control path, so the code is not unreachable. MISRA C 2023 Rule 2.1 forbids unreachable code; because this block is reachable, there is no Rule 2.1 violation here. (Side note: mhd_assert may be disabled in non-debug builds, but that only affects runtime checks, not reachability of the branch in the source.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,1.2,False,"No violation: the function does not use any compiler-specific language extensions. It uses standard C types and constructs; compiler-specific features are conditionally referenced (e.g. __asan_region_is_poisoned) only under #if guards and are not language extensions themselves. No explicit compiler extensions (such as __attribute__, asm, typeof, or other vendor keywords) are present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_chunked_body,2.2,True,"The code contains an apparently unreachable/unused error-handling branch: the inner block guarded by 'if (NULL == response->crc)' (commented with ""There is no way to reach this code"") is dead. The project-level invariants (response must have either a data buffer covering the required position or a crc callback) make this branch effectively redundant; its presence constitutes dead code per MISRA C 2023 Rule 2.2.","Agent A's report is not correct. The inner ""if (NULL == response->crc)"" block is not provably dead from the snippet shown. The only check that relates crc and data is mhd_assert(NULL != response->crc || NULL != response->data) — an assertion, not a compile-time or guaranteed runtime invariant (and typically not present in release builds). That assertion merely ensures at least one of crc or data is non-NULL, it does not guarantee that the data buffer covers the current rsp_write_position. The else branch is entered when the current write position is not within the data buffer; in that situation response->crc must be non-NULL to supply data. If response->data is non-NULL but does not cover the position and response->crc is NULL, the branch in question would be executed and its behaviour (closing the connection) affects program behaviour. Thus the code is reachable in plausible runtime states unless there is a separate, project-level invariant (outside the provided code) that guarantees crc is always non-NULL whenever the data buffer does not cover the requested position. No such invariant or proof was provided; the test harness did not produce evidence. Because the claim of dead code relies on an unshown invariant and the branch can be exercised at runtime, the reported MISRA 2.2 violation is not supported by the evidence.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,14.2,False,The function try_ready_normal_body contains no for loop constructs; therefore MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable and is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,17.8,False,"No violation: the function does not assign to the pointer parameter 'connection' itself. It only modifies members of the object pointed to (e.g. connection->rp.resp_iov.iov, response->total_size, connection->state), which is permitted by Rule 17.8 (the object pointed to by a pointer parameter may be modified, but the pointer itself shall not be).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,21.17,True,"When response->data_iov is non-NULL, the code computes copy_size = response->data_iovcnt * sizeof(MHD_iovec_) and then does memcpy(dest, response->data_iov, copy_size) without verifying that the source buffer actually contains at least response->data_iovcnt elements. If response->data_iovcnt is larger than the actual number of elements (e.g. due to a bug, corrupted metadata, or maliciously crafted value), memcpy can read beyond the bounds of the object pointed to by response->data_iov, violating MISRA C 2023 Rule 21.17.","Agent A's report is correct. In try_ready_normal_body the memcpy call copies response->data_iovcnt * sizeof(MHD_iovec_) bytes from response->data_iov without any local check that the object pointed to by response->data_iov actually contains at least response->data_iovcnt elements. Per MISRA C 2023 Rule 21.17, calls to memcpy must not result in accesses beyond the bounds of the source or destination objects. Unless there exists a provable program-wide invariant (established and verifiable outside this function) that response->data_iov and response->data_iovcnt are always consistent and the allocated/source buffer is large enough, this use is potentially out-of-bounds and therefore violates the rule. The provided test snippet failing to compile does not invalidate the logical issue in the original code. Recommendation: either validate the count/size before memcpy, or ensure and document (and verify) the invariant that guarantees the source buffer length >= response->data_iovcnt * sizeof(MHD_iovec_).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,21.14,False,"The function does not call memcmp anywhere. It uses memcpy, memset and other functions but no memcmp is used to compare null-terminated strings, so Rule 21.14 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,8.13,True,"The code casts away const from response->data when calling the CRC callback: (char *) response->data. If response->data is (or should be) a const-qualified pointer (e.g. const char *), the cast removes const and passes a non-const char * to response->crc. That defeats the requirement that pointers should point to const-qualified types whenever possible and is a specific violation of MISRA C 2023 Rule 8.13.","Agent A's report is correct under the normal interpretation of the code. The code performs (char *) response->data when calling response->crc. If response->data is declared as const char * (as the cast indicates), casting away the const qualifier to call a function that takes a char * discards const and thus defeats the intent of making the pointer point to const-qualified data. MISRA C:2023 Rule 8.13 requires that pointers point to const-qualified types whenever possible (and conversely a pointer should not be made const-qualified if the pointed object is legitimately modified by the callee). The correct fixes are to either: (a) change the crc callback prototype to accept a const char * (if it does not modify the buffer), or (b) make response->data non-const only if the callback is allowed to modify the buffer. As written, the explicit cast-away-const is a violation of the rule. Note: if in some build of the project response->data is not const-qualified (i.e. declared as char *), then there is no violation — the assertion of a violation depends on the actual declarations. Given the presence of the cast in the code, the agent's scenario is valid and the report is correct in the likely/typical case.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,2.1,False,"No unreachable code was found in try_ready_normal_body. Each return is conditional and reachable depending on connection/response state (e.g. zero-length response, presence of data_iov, NULL crc, sendfile sender, crc returning negative/zero/positive). Therefore Rule 2.1 is not violated. (If a violation were to be created, it would result from inserting an unconditional return before the crc call, making the subsequent data_start/data_size update unreachable.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,1.2,False,"No violation: the function try_ready_normal_body uses only standard C features (casts, function calls, preprocessor conditionals, standard types). It does not use compiler-specific language extensions such as GCC/Clang __attribute__ annotations, statement-expressions, typeof, inline asm, or other extensions explicitly documented as compiler extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,try_ready_normal_body,2.2,False,"No executed operations in try_ready_normal_body qualify as dead code. All branches perform checks or state updates that influence control flow or observable behavior (returns, state changes, mutex operations, memory alloc/free decisions, connection close). Conditional compilation blocks are not executed when not defined and therefore are not ""dead code"" per the rule. No executed operation can be removed without potentially changing program behavior, so Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,14.2,False,"No violation: the function contains no for statements. MISRA C 2023 Rule 14.2 applies to for loops; since get_request_line_inner uses while and do...while only, the Rule is not applicable here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,17.8,False,"No violation: the function parameter 'c' (a pointer) is not assigned to or otherwise modified. Only the object it points to is modified (e.g. c->read_buffer, c->rq, c->state), which is allowed by Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,21.17,False,"No violation: get_request_line_inner does not call any string.h functions (memcpy, memset, strcpy, strncpy, strcat, strncat, strlen, memcmp, etc.). All buffer accesses are done via direct indexing and are protected by explicit bounds checks (e.g. loop condition p < c->read_buffer_offset, checks for p+1 == c->read_buffer_offset before accessing p+1). Therefore there is no use of the <string.h> functions that could produce out-of-bounds accesses and MISRA C 2023 Rule 21.17 is not violated by this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,21.14,True,"Violation occurs when the code zero-terminates the HTTP method in get_request_line_inner (c->read_buffer[p] = 0;) and then calls parse_http_std_method which uses memcmp to compare the (now) null-terminated method string against string literals. This causes memcmp to be used to compare null-terminated strings, violating MISRA C 2023 Rule 21.14.","The target function itself does not call memcmp and merely inserts a NUL (c->read_buffer[p] = 0) and passes both the pointer and the length (p) to parse_http_std_method. MISRA C:2023 Rule 21.14 forbids using memcmp to compare null‑terminated strings — but whether a violation occurs depends entirely on the implementation of parse_http_std_method, which is not shown. If parse_http_std_method uses memcmp to compare two NUL‑terminated strings (for example using lengths derived from strlen or including the terminating NUL), then that implementation would violate 21.14. However, if parse_http_std_method uses the explicit length argument (p) and compares fixed byte counts (e.g. memcmp(method, ""GET"", 3)) or otherwise does not use memcmp to compare NUL‑terminated strings, there is no violation in the shown code.

Because there is no evidence in the provided code that memcmp is used to compare NUL‑terminated strings, and the presence of a NUL byte alone does not make using memcmp illegal, the report as given is not proven correct. To confirm a true violation you must inspect the parse_http_std_method implementation (and any functions it calls) to see whether memcmp is used to compare NUL‑terminated strings or uses sizes derived from strlen/including the terminator. The supplied probe/test code did not compile and produced no additional evidence, so it does not change this conclusion.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,8.13,False,"No violation. In get_request_line_inner all pointers used to modify buffer memory are non-const (for example c->read_buffer is used to write NULs and spaces and to advance the buffer pointer). Functions that accept pointers to read-only data (parse_http_std_method, parse_http_version) take const char * parameters and do not modify the pointed data. There is no occurrence where a pointer is declared pointing to a const-qualified type and later used to modify the pointed object, nor a pointer that could reasonably be const but is left unqualified while never being used to modify data in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,2.1,False,"No reachable violation found. The function contains no statically unreachable statements: all branches depend on runtime state (connection fields, read buffer contents, and discipline level), and returns occur only as intended to terminate processing. There are no constant-controlling conditions that render blocks permanently unreachable, nor code after an unconditional return in the same block. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,1.2,False,"No MISRA Rule 1.2 violation found: the function uses only standard C language constructs (bool, pointers, pointer arithmetic, macros, character literals, and control flow). There are no compiler-specific language extensions (no inline assembly, no GCC statement-expressions, no typeof, no __attribute__ or other vendor-specific keywords) observable in the provided code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_request_line_inner,2.2,False,"No dead code found in get_request_line_inner. All local computations and control paths influence subsequent behavior (flags derived from discp_lvl are used in branching, and error/response paths have observable effects). The mhd_assert macros are no-ops but do not introduce executed dead code. Therefore Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,14.2,False,"No violation: the function contains no 'for' statements. It uses while and do/while loops only, so MISRA C 2023 Rule 14.2 (requirements for well-formed for loops) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,17.8,False,"No violation: the function does not assign to any of its pointer parameters. The code writes into the buffer pointed to by 'str' (e.g. str[name_start + name_len] = 0 and str[value_start + value_len] = 0) which is permitted by Rule 17.8 because the object referred to by a pointer parameter may be modified. The function does not reassign the pointer variables 'str' or 'connection', nor modify the non-const parameter 'str_len' (it is declared const). Calls that pass 'connection' to helper functions may cause those helpers to modify the pointee, which is allowed. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,21.17,False,"No practical violation. The code that calls parse_cookies_string (parse_cookie_header) allocates cpy with hdr_len + 1 bytes, copies hdr_len bytes with memcpy and places a terminating '\0' at cpy[hdr_len]. parse_cookies_string indexes and writes at offsets up to str_len (which equals hdr_len - offset) and thus may write at str[str_len] which corresponds to the allocated terminating byte in cpy. The memcpy in parse_cookie_header copies exactly hdr_len bytes into an hdr_len+1 buffer, which is safe. Therefore the use of memcpy and subsequent byte accesses/writes do not access beyond object bounds.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,21.14,False,"No usage of memcmp anywhere in parse_cookies_string; all comparisons are done on single characters and by length-aware operations (explicit indexing, checks against str_len, and explicit zero-termination). Therefore there is no scenario in which memcmp is used to compare null-terminated strings in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,8.13,False,"Not violated. The function parameter 'str' is declared as char * and the function explicitly modifies the buffer (zero-terminates name and value: str[name_start + name_len] = 0; str[value_start + value_len] = 0;). Therefore the pointer cannot be const-qualified. The other pointer parameter 'connection' is used for allocation and to store parsed values, so it must remain non-const. No pointer in this function could be made const without changing its semantics, so Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,2.1,False,No unreachable code found: all branches and statements in parse_cookies_string can be reached depending on input and connection->daemon->client_discipline settings; no code is provably unreachable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,1.2,False,"No violation: the function parse_cookies_string and the related code use only standard C language constructs (static functions, enums, bool, pointer arithmetic, preprocessor conditionals). There are no compiler-specific language extensions (no __attribute__, __asm, typeof, statement-expressions, anonymous structs/unions beyond standard C, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,parse_cookies_string,2.2,True,"Inside parse_cookies_string, the character-check expression used to detect end-of-value contains a duplicated alternative (';' == l) in the condition: if ((';' == l) || ('""' == l) || (',' == l) || (';' == l) || ('\\' == l) || (0 == l)) break; The second (';' == l) is redundant — it is an operation that is executed but whose removal would not affect program behaviour, i.e. dead code under MISRA C 2023 Rule 2.2.","Agent A is correct. The condition in the value-loop contains the same (';' == l) alternative twice; the second occurrence is redundant. Because the duplicate comparison has no side-effects and its removal cannot change the evaluated boolean result (nor program behaviour), it is an operation that may be executed yet whose removal would not affect behaviour, which fits MISRA C 2023 Rule 2.2’s definition of dead code. Removing the duplicated alternative (or otherwise eliminating the redundancy) is the appropriate fix.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,14.2,False,MHD_connection_handle_write contains no for loops; therefore MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable to this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,17.8,False,"No violation: the function does not assign to the parameter variable 'connection' anywhere. Only members of the object pointed to by 'connection' are read or modified (e.g. connection->write_buffer_send_offset, connection->state, etc.), which is permitted by Rule 17.8. There are no statements that reassign the pointer itself (no 'connection = ...' occurrences).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,21.17,False,"No violation: the code's uses of functions from <string.h> are limited to memcpy (in try_ready_normal_body) and memset (in MHD_send_hdr_and_body_). The memcpy copies copy_size = response->data_iovcnt * sizeof(MHD_iovec_) bytes from response->data_iov into a buffer allocated by MHD_connection_alloc_memory_ with the same size; a NULL check follows the allocation. The memset call initializes the msghdr structure with sizeof(msg) bytes. There are no strcpy/strncpy/strcat/strncat/strlen/strspn/memmove/memcmp uses in the shown code paths that could access beyond the bounds. Given these checks and matching allocation/copy sizes, the code does not result in accesses beyond object bounds, so MISRA C 2023 Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,21.14,False,"No violation: MHD_connection_handle_write and the related code do not call memcmp to compare null-terminated strings. The function uses send helpers (MHD_send_data_, MHD_send_hdr_and_body_, etc.) and numeric/state comparisons only; no use of memcmp is present, so there is no scenario where memcmp is used for null-terminated string comparison.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,8.13,True,"The local variable 'resp' in the HEADERS_SENDING case is declared as 'struct MHD_Response *const resp' (a const pointer to a non-const object). The function does not modify the pointed-to response object via 'resp' in that case, so 'resp' could and should be declared to point to a const-qualified type (for example: 'const struct MHD_Response *const resp'). This is a direct breach of MISRA C 2023 Rule 8.13, which requires pointers to point to const-qualified types whenever possible.","Agent A is correct. In the HEADERS_SENDING block the local variable is declared as
  struct MHD_Response *const resp;
and the code only performs read-only accesses to resp (reads of data_size, data_start, crc, total_size and passing resp->data as a data buffer). There are no assignments to any resp->... members and resp itself is not passed to any function that would modify the MHD_Response object. Therefore resp could safely be declared to point to a const-qualified type (for example const struct MHD_Response *const resp), which is exactly what MISRA C:2023 Rule 8.13 requires whenever possible. The only caveat would be if any called function required a non-const pointer to the MHD_Response struct itself (which does not occur here); absent that, the current declaration violates the “pointer should point to a const-qualified type whenever possible” requirement. Hence the report is correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,2.1,False,"No reachable code paths are provably unreachable. Each switch case either returns or falls through intentionally; assertion calls (mhd_assert(0)) are followed by return to prevent fall-through. The default case handles unexpected states. Conditional compilation (HTTPS_SUPPORT, UPGRADE_SUPPORT) only removes or includes case labels but does not leave any unreachable statements. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,1.2,False,"No language extensions are used. The function and its helpers use standard C/C99 and POSIX types and idioms (ssize_t, uint64_t, bool, __func__, standard library calls). There are no uses of compiler-specific extensions such as __attribute__, __builtin_... (not shown as such), typeof, statement-expressions, inline asm, label-as-values, or other documented compiler extensions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_connection_handle_write,2.2,True,"When a connection enters one of the switch cases that currently call mhd_assert(0) — for example MHD_CONNECTION_INIT — the mhd_assert(0) expression is executed. In the provided code mhd_assert is defined as ((void)0), so those executed assert statements have no effect; removing them would not change program behaviour. Thus these executed no-op assert calls constitute dead code and violate MISRA C 2023 Rule 2.2.","Agent A’s reasoning is only valid under a specific build-time assumption (that mhd_assert is defined globally as a no-op, e.g. #define mhd_assert(x) ((void)0)). If, in the actual project configuration, mhd_assert expands to a checking routine (one that aborts/logs on a failed condition), then the mhd_assert(0) calls are active checks and their removal would change behaviour, so they are not dead code. Rule 2.2 applies to the code as it exists in the project/build configuration: an executed statement that has no effect in that configuration is dead code and would violate the rule. Agent A did not demonstrate that in the real project build mhd_assert is a no-op; their test code used a different definition and failed to produce output. Therefore the blanket claim that the posted MHD_connection_handle_write violates MISRA C:2023 Rule 2.2 is not correct unless you can show the project actually defines mhd_assert as a no-op in the build being analysed. If you do have mhd_assert defined as ((void)0) in the project, then those reachable mhd_assert(0) calls are dead code and should be fixed (remove them or make the checks effective, or conditionally compile them so no no-op statements remain).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,14.2,False,The function keepalive_possible contains no for statements; control flow is implemented using if/return. Therefore MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable and not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,17.8,False,No violation: the function does not modify the pointer parameter 'connection' nor reassign it. It only creates a const alias 'c' (struct MHD_Connection *const c = connection) and reads/modifies no members of the pointer itself. All accesses are reads; the object pointed to may be inspected but not altered.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,21.17,False,"No violation in keepalive_possible: the function itself does not call any of the <string.h> string handling functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). The only string-related helper called is MHD_lookup_header_s_token_ci, but its implementation is not present here; a possible violation could only arise if that helper (or other called functions) internally used an unbounded string function resulting in an out-of-bounds access (for example, using strcpy into a fixed-size buffer without checking header length). To determine a real violation you must inspect implementations of MHD_lookup_header_s_token_ci and any header-parsing utilities to ensure they use bounds-checked operations.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,21.14,False,"keepalive_possible does not call the Standard Library function memcmp to compare null-terminated strings. All string/header comparisons are performed via MHD_lookup_header_s_token_ci -> MHD_lookup_header_token_ci which use explicit length checks (header_len == pos->header_size) and length-aware helper functions (e.g. MHD_str_equal_caseless_bin_n_ and MHD_str_has_token_caseless_) rather than memcmp on NUL-terminated buffers. No direct use of memcmp is present in the shown code, so Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,8.13,True,"The parameter 'connection' is declared as a pointer to a non-const struct MHD_Connection even though keepalive_possible only reads the object pointed to and does not modify it. According to MISRA C:2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. The function therefore violates Rule 8.13 because 'connection' could be 'const struct MHD_Connection *' (no in-function writes are performed).","Agent A’s claim is not correct. While keepalive_possible only reads the connection and response objects inside the function, you cannot unconditionally change the parameter to a pointer-to-const if the pointer is subsequently used where a non-const pointer is required. In this function the connection (alias c) is passed to MHD_lookup_header_s_token_ci which is declared to take a struct MHD_Connection * (non-const) in the provided test scaffolding (and is likely so in the real code because the lookup helper may modify internal state). That prevents changing the parameter type to const without cascaded API changes or casts. Also note that the local declaration struct MHD_Connection *const c makes the pointer itself const (you cannot reseat c), it does not make the pointed-to object const — which is what Rule 8.13 concerns. The test code failed to compile because the test scaffolding did not provide compatible/complete definitions for the connection/response types and their usage, so its failure does not demonstrate a Rule 8.13 violation. Therefore the report is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,2.1,False,No violation. Every branch and return in keepalive_possible is reachable depending on runtime state (e.g. c->keepalive == MHD_CONN_MUST_CLOSE; r->upgrade_handler != NULL when upgrade is requested; c->read_closed or c->discard_request; HTTP/1.0 request or response flag; HTTP/1.1 compatible version; or the final fallback). The #ifdef UPGRADE_SUPPORT code is included in the build (UPGRADE_SUPPORT is defined) so it is not dead; there are no statically unreachable statements in the function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,1.2,False,"No violation: the function and supporting code use only standard C constructs and macros. No compiler-specific language extensions are present (no __attribute__, typeof, __extension__, statement expressions, inline assembly, nested functions, or other compiler-only keywords).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,keepalive_possible,2.2,False,"No violation. Each executed statement in keepalive_possible either affects the returned keepalive decision (through comparisons, header lookups, or returns) or is an assertion/check that may alter behaviour if the asserted condition fails. There are no operations that are executed yet useless — no assignments, function calls, or expressions that can be removed without potentially changing the function outcome. Conditional compilation blocks (#ifdef UPGRADE_SUPPORT) are not executed when absent and are therefore unreachable, not dead. Therefore Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,14.2,False,"No violation: there are no ill-formed for loops in the provided get_no_space_err_status_code or the accompanying functions. The for loops present (e.g. in MHD_str_equal_caseless_bin_n_: for (i = 0; i < len; ++i) and in MHD_lookup_connection_value_n: for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)) satisfy Rule 14.2: the first clause initializes the loop counter, the second clause tests the counter without persistent side effects, and the third clause updates only the loop counter. The loop counters are not modified inside the loop bodies.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,17.8,False,"No violation: none of the function parameters (c, stage, add_element, add_element_size) are assigned or redefined inside get_no_space_err_status_code. Pointer parameters are only dereferenced or passed to other functions; add_element is const and not modified. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,21.17,True,"Calling strlen(c->rq.method) when c->rq.method may not be null-terminated. If c->rq.http_mthd == MHD_HTTP_MTHD_OTHER the code calls strlen(c->rq.method) without any bounded check. If the method buffer is not NUL-terminated within its allocated bounds, strlen will read beyond the object, violating Rule 21.17.","The report is correct. strlen(c->rq.method) is called with only an mhd_assert(NULL != c->rq.method) as a precondition; there is no evidence in the snippet that the object c->rq.method points to is NUL-terminated within its allocated bounds. MISRA C 2023 Rule 21.17 prohibits use of <string.h> functions that may access beyond the referenced object. An assertion that the pointer is non-NULL does not guarantee a NUL terminator (and assertions may be omitted in production builds), so the strlen call can potentially read past the object and thus violate Rule 21.17. (If, elsewhere in the program, it is provably guaranteed that c->rq.method is NUL-terminated whenever http_mthd == MHD_HTTP_MTHD_OTHER, then the violation would not hold — but no such guarantee is present in the provided code, so the agent’s report is correct.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,21.14,False,"No violation: the function and its helpers do not use memcmp to compare null-terminated strings. Header-name comparisons use MHD_str_equal_caseless_bin_n_ with an explicit length parameter (binary, fixed-length comparison), and MHD_lookup_connection_value_n also compares using a length-aware function or by pointer equality. No use of memcmp against null-terminated strings is present in the provided code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,8.13,True,"The function get_no_space_err_status_code takes a non-const pointer argument 'struct MHD_Connection *c' even though it only reads fields of the connection and does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Making 'c' a 'const struct MHD_Connection *' would be preferred, unless functions called with 'c' (e.g. MHD_lookup_connection_value_n) legitimately modify the connection. In the shown code, no modification of *c is performed in this function, so the non-const pointer is a violation scenario.","The reviewer inspected get_no_space_err_status_code and confirmed that the function itself does not directly modify the object pointed to by parameter c: it only reads fields of *c and uses those values. Under MISRA C 2023 Rule 8.13 a pointer parameter should be const-qualified when possible. So, on a surface level, the parameter could be declared as const struct MHD_Connection * to better reflect that this function does not mutate the connection.

However, the rule contains the important exception that a pointer must not be const-qualified if the pointer is passed to other functions that legitimately modify the pointed-to object or whose prototypes require a non-const pointer. The implementation shown calls other routines (for example MHD_lookup_connection_value_n and various project macros/wrappers). No prototypes for those functions are provided here, and the agent’s test replacement did not demonstrate that those callees accept a const pointer or do not modify the connection. Because the call-chain and prototypes are not shown, it is not possible to conclusively determine whether making c const is feasible without changing or casting when calling those functions. If any callee requires a non-const struct MHD_Connection * or may modify the connection, keeping the parameter non-const is justified and not a MISRA violation.

Conclusion: the observation that the function itself does not mutate *c is correct and this function is a candidate for a const-qualified pointer parameter. But the report as stated — claiming a violation — is not proven because the necessary verification of the callees’ prototypes/behaviour is missing. Therefore the report cannot be judged correct based on the provided evidence.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,2.1,False,No unreachable code found in get_no_space_err_status_code. All conditional branches and return paths are reachable depending on the values of the function arguments and connection state; there is no definite dead code path that cannot be executed.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,1.2,False,"No violation: the function and related code use only standard C constructs and macros. There are no compiler-specific language extensions present (e.g. __attribute__, __asm__, typeof, statement expressions, __extension__, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,get_no_space_err_status_code,2.2,True,"The mhd_assert invocations in get_no_space_err_status_code expand to ((void)0) in the provided project configuration; those statements are executed as no-op operations whose removal would not affect program behaviour, i.e. they are dead code and therefore violate MISRA C 2023 Rule 2.2.","MISRA C:2023 Rule 2.2 forbids executed operations whose removal would not affect program behaviour (i.e. dead code). If, in the project configuration, mhd_assert expands to a no-op such as ((void)0) (or to an inline function that merely casts its argument to void and does nothing observable), then each mhd_assert statement is an executed no-op: removing those statements would not change observable program behaviour (provided the asserted expressions have no side effects). That matches the definition of dead code, so the reported violation is correct for that project configuration. Caveats: if the assertion macro/function actually evaluates expressions with side effects (or performs logging/termination when enabled), removing it could change behaviour and it would not be dead code. Also, projects often handle this by keeping assertions active in release builds or by documenting an approved deviation from MISRA; absent such mitigation, the report is valid.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,14.2,False,"No for-loop constructs are present in MHD_queue_response. MISRA C 2023 Rule 14.2 concerns the well-formedness of for statements; since the function contains no for statements, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,17.8,True,"The function modifies the non-pointer parameter 'status_code' (status_code &= ~MHD_ICY_FLAG;). Rule 17.8 forbids modifying function parameters; although objects pointed to by pointer parameters may be modified, scalar parameters shall not be altered. The clearing of the MHD_ICY_FLAG on the incoming status_code parameter is a direct violation.","Correct. MISRA C:2023 Rule 17.8 states that function parameters shall not be modified. In MHD_queue_response the scalar parameter status_code (unsigned int) is modified in-place via the statement
  status_code &= ~MHD_ICY_FLAG;
This is a direct modification of a function parameter and therefore violates Rule 17.8. (The rule exception that allows modifying the object referred to by a pointer parameter is not relevant here because status_code is a scalar value parameter, not a pointer.)

Remediation: stop modifying the parameter and use a local copy, e.g. unsigned int sc = status_code; reply_icy = (0 != (sc & MHD_ICY_FLAG)); sc &= ~MHD_ICY_FLAG; then use sc throughout the function (or mark parameter const and use the local copy).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,21.17,False,"No violation: MHD_queue_response does not call any of the standard <string.h> functions listed in MISRA C 2023 Rule 21.17 (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn). The auxiliary functions invoked (e.g. MHD_str_equal_caseless_) do not rely on those standard string functions and perform only bounded character accesses on NUL-terminated strings, so there is no use of the specified string.h functions that could lead to out-of-bounds accesses within this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,21.14,False,No violation: the function and related helpers do not call memcmp to compare null-terminated strings. String comparisons are performed via bespoke routines (e.g. MHD_str_equal_caseless_ iterates over characters) and macros that wrap other helpers; no usage of memcmp is present in the shown code paths.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,8.13,True,"The function declares a local pointer 'daemon' as 'struct MHD_Daemon *daemon' but only reads from the daemon object (checks options, shutdown, sigpipe_blocked, etc.) and does not modify it. According to MISRA C 2023 Rule 8.13, such a pointer should point to a const-qualified type whenever possible (i.e. 'const struct MHD_Daemon *daemon'). Thus the code violates Rule 8.13 because a pointer that could be to a const-qualified type is not const-qualified.","Agent A’s observation (that the local variable 'daemon' is only read and not written in MHD_queue_response) is correct in isolation: within this function the code only inspects fields of *daemon and does not assign through the pointer. However, MISRA 8.13 requires a pointer to be const-qualified only when it is possible to do so across the interfaces actually used. In this function 'daemon' is passed to logging/macros and used with project-wide helper macros (e.g. MHD_DLOG, MHD_D_IS_USING_THREADS_) whose declarations/definitions are not shown. If any of those callees are declared to take a non-const pointer (or if their signatures are required to take a mutable daemon), then making the local pointer const would either cause a qualifier-discard when calling them or force changes to other prototypes. Because Agent A did not show that all callees accept a const-qualified pointer (nor that no macro/function requires a mutable daemon), the claim that this function violates MISRA 8.13 is not proven. In short: the pointer could be made const if the surrounding API/macros were also const-correct, but from the snippet alone there is insufficient evidence of an actual MISRA violation in the project as a whole.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,2.1,False,"No violation. All branches in MHD_queue_response are reachable depending on runtime state. For example, the early check ""if ((!connection->in_access_handler) && (!connection->suspended) && MHD_D_IS_USING_THREADS_(daemon)) return MHD_NO;"" might look to make the later thread-ID check unreachable, but that later check is inside a compiled #if and will be reached when connection->in_access_handler is true, connection->suspended is false, the daemon is using threads and the thread handle ID does not match the current thread. Many other guarded blocks (UPGRADE_SUPPORT, HAVE_MESSAGES, sendfile-related) are compiled in by the provided defines but their inner branches depend on runtime fields (response->upgrade_handler, response->flags, daemon->options, response->fd, etc.). No code is statically unreachable under the given definitions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,1.2,True,"The code uses a compiler-specific language extension: the macro _MHD_EXTERN is defined as __attribute__((visibility(""default""))) extern, which employs GCC/Clang __attribute__ syntax — an explicit compiler extension (non-standard C).","Agent A's claim is plausible but not verifiable from the supplied source fragment alone. MISRA C 2023 Rule 1.2 forbids use of compiler language extensions. The GCC/Clang form __attribute__((...)) is a compiler-specific extension; therefore if the project header defines _MHD_EXTERN as something like __attribute__((visibility(""default""))) extern (as Agent A asserts), then the code does use a non‑standard language extension and the reported violation would be correct.

However, the posted target_code only shows use of the macro _MHD_EXTERN — it does not show its definition. Without the macro's definition (or the preprocessed output), one cannot determine from the snippet whether a compiler extension is actually being used. The failure of the supplied test code to compile does not prove the presence of the __attribute__ usage; it only shows the test harness was incomplete.

Conclusion: the report by Agent A may be correct if _MHD_EXTERN expands to a GCC/Clang __attribute__ form, but that fact is not established by the provided code. To confirm the violation, the macro definition or the preprocessed source must be provided. Recommended actions: inspect the header that defines _MHD_EXTERN or run the preprocessor (e.g. gcc -E) to see its expansion. If it expands to __attribute__((...)) then this is a violation of MISRA Rule 1.2.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_queue_response,2.2,False,"No violation: I could not find any operation inside MHD_queue_response that is executed yet removable without changing program behaviour. Conditional compilation blocks (#if 0 / #ifdef) and mhd_assert() expand to nothing or are compile-time excluded and therefore are not executed (note 2). Calls that may appear redundant (e.g. logging calls via MHD_DLOG or the TODO-marked assignment to connection->rp.rsp_write_position) either affect observable behaviour (logging or subsequent state checks) or are needed by later code paths, so their removal would change behaviour. Therefore Rule 2.2 is not violated in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,14.2,True,"The for loop uses 'pos = pos->next' in the third clause while the loop body calls an external callback (iterator). If that callback modifies the linked list (for example removes or re-links nodes), the third-clause expression reads objects that may have been modified by the loop body — violating MISRA C 2023 Rule 14.2 (clause 3). In other words, the loop increment uses pos->next which could be altered by functions called in the loop body, so the for loop is not guaranteed to be well-formed under Rule 14.2.","Summary of rule: MISRA C 2023 Rule 14.2 requires that a for loop be well‑formed: there must be a single loop counter and the third clause must only modify that loop counter and must not use objects that may be modified in the loop body (the behaviour of called functions is considered part of the loop body).

Analysis of the code: the loop uses a single loop counter identifier pos. The third clause is pos = pos->next which reads the memory pointed to by pos (the next pointer) to update the loop counter. The loop body calls an external callback (iterator), and the rule explicitly considers effects of called functions as part of the loop body. If that callback is able to modify the linked list (for example by removing or relinking nodes, or freeing the current node), then the expression pos->next used in the third clause may access memory that was modified by the loop body. That violates clause 3 of Rule 14.2, because the third clause uses objects that can be modified by the loop body.

Caveat: if there is a proven, documented, and enforceable guarantee that the iterator callback cannot and will not modify the list (including not freeing or relinking nodes reachable from pos), then the code would not violate the rule in that specific context. Absent such a guarantee, the code as written is non‑conforming.

Conclusion: Agent A’s report is correct: the code can violate MISRA C 2023 Rule 14.2 as described (unless there is a guarantee that the callback cannot modify the list).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,17.8,False,"No violation: the function does not assign to or modify any of its parameters. Pointer parameters (connection, iterator_cls) are only dereferenced or passed to callbacks; the pointer values themselves are not changed.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,21.17,False,"No violation: MHD_get_connection_values does not call any of the <string.h> functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). It only iterates over linked headers and passes header/value pointers to an external iterator callback. There is no direct use of string-handling library routines that could access beyond the bounds of objects. Note: if the external iterator implementation uses unsafe string functions that access out-of-bounds, that would be a separate violation in the iterator, not in MHD_get_connection_values.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,21.14,False,No violation: MHD_get_connection_values does not call the library function memcmp to compare null-terminated strings. It only checks a bitmask (pos->kind & kind) and passes pos->header/pos->value to the iterator; no string comparison via memcmp occurs.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,8.13,True,"The function takes non-const pointers even though it only reads from the connection and its headers. In particular, the parameter 'struct MHD_Connection *connection' and the local iterator 'struct MHD_HTTP_Req_Header *pos' are non-const although the function does not modify the pointed-to objects. Per MISRA C 2023 Rule 8.13 these should be const-qualified (for example, 'const struct MHD_Connection *connection' and 'const struct MHD_HTTP_Req_Header *pos').","MISRA C:2023 Rule 8.13 requires a pointer to be const-qualified when the pointed-to object is not modified by the function. In the posted MHD_get_connection_values implementation the function only inspects the connection and header list fields (reads pos->kind, pos->header, pos->value, pos->next) and does not modify the pointed-to objects. Therefore, from a pure-rule point of view the parameter should be declared as const struct MHD_Connection *connection and the local loop pointer as const struct MHD_HTTP_Req_Header *pos (and any downstream uses that accept non-const should be adjusted to accept const).

That said, the rule also allows a non-const pointer when the function (or functions it calls) may modify the object. If the public API requires non-const (for backward compatibility) or the iterator callback is declared to take non-const pointers so that callers may legitimately modify the strings, keeping the parameters non-const is justified and not a violation. Absent such a justification in the shown code, the agent A report is correct: the function as written does not qualify the pointers as const and therefore violates Rule 8.13.
",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,2.1,False,No violation: all code paths are reachable. The early return (return -1) is executed only when connection == NULL; otherwise the loop over connection->rq.headers_received and the conditional invocation of iterator are reachable depending on runtime values. There is no code that can never be executed due to constant conditions or dead statements.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,1.2,True,"The function is declared with a compiler-specific attribute: the project-defined macro _MHD_EXTERN expands to __attribute__((visibility(""default""))) extern. The use of GCC-style __attribute__((...)) is a compiler language extension (documented as such in GCC), therefore the code violates MISRA C 2023 Rule 1.2 (language extensions should not be used).","The agent's reasoning is technically correct in principle but not proven by the supplied code. MISRA C:2023 Rule 1.2 forbids compiler language extensions that are documented as extensions (e.g. GCC __attribute__((...))). If the project macro _MHD_EXTERN actually expands to a GCC-specific attribute such as __attribute__((visibility(""default""))) then that use would be a language-extension and therefore a violation of Rule 1.2.

However, the source snippet you provided only shows the macro name _MHD_EXTERN and does not include its definition. You cannot conclude a Rule 1.2 violation from the call site alone without verifying the macro expansion or compiler-specific annotation in the project's headers or build configuration. Therefore the agent's reported violation is not confirmed by the given code as-is. To determine whether there is a real violation, examine the definition of _MHD_EXTERN (and any compiler flags) — if it indeed expands to a documented compiler extension (for example GCC __attribute__), then the report is correct; otherwise it is not.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_get_connection_values,2.2,False,"No violation: MHD_get_connection_values contains no dead code. All executed operations affect observable behaviour — the increment of ret impacts the return value, the iterator call affects external behaviour, and the NULL check/early return are necessary.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,14.2,False,The function MHD_set_connection_value_n contains no for statement. Rule 14.2 (well-formed for loops) applies only to for statements; since none are present the rule is not applicable and therefore not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,17.8,False,"No violation: none of the formal parameters are assigned to or modified. The function inspects key and value via strlen (allowed) and forwards all parameters unchanged to MHD_set_connection_value_n_nocheck_. The helper function writes into the object pointed to by connection (connection->rq.*) and stores the pointer values in the new header node; modifying the object pointed to by a pointer parameter is permitted by the rule. The pointer parameters themselves (connection, key, value) and the non-pointer parameters (kind, key_size, value_size) are not modified, and key/value are const, so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,21.17,True,Calling strlen on 'key' or 'value' can read past the provided object bounds if those buffers are not null-terminated within key_size/value_size. Example: passing a char buffer of length key_size that contains no terminating '\0' will cause strlen(key) to read beyond the buffer — a violation of MISRA C 2023 Rule 21.17.,"The report is correct. strlen reads bytes until it finds a '\0'; if the caller supplies a non-NULL pointer whose buffer is not NUL-terminated within the provided bounds, calling strlen(key) or strlen(value) can read past the end of the object and thus produce out-of-bounds accesses. That use of strlen therefore violates MISRA C 2023 Rule 21.17. In other words, the conditional ((key ? strlen(key) : 0) != key_size) (and the analogous value check) can invoke undefined behaviour when key or value do not contain a terminating '\0' within their valid storage.

Recommended action: avoid unbounded strlen on buffers whose termination is not guaranteed. Use a bounded scan (e.g. memchr with a known object size or an explicit loop limited to the known maximum number of bytes), or otherwise require/document that the pointers reference NUL-terminated strings. Do not call strlen unless you can guarantee the object contains the terminator within its bounds.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,21.14,False,No violation: the function does not call memcmp. It only uses strlen to check that provided key/value lengths match the null-terminated string lengths and then calls the nocheck helper. Therefore Rule 21.14 (prohibiting memcmp for null-terminated string comparison) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,8.13,False,No violation: the parameters 'key' and 'value' are declared as 'const char *' and are only read (strlen) and stored (assigned to pos->header/pos->value) without being modified by MHD_set_connection_value_n or MHD_set_connection_value_n_nocheck_. Thus pointers correctly point to const-qualified types and are not used by functions that modify the pointed-to objects.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,2.1,False,"No violation: both the return MHD_NO path and the call to MHD_set_connection_value_n_nocheck_ are reachable depending on the runtime values of 'kind', 'key', 'key_size', 'value', and 'value_size'. The condition uses runtime values (including a comparison with MHD_GET_ARGUMENT_KIND) so no code in this function is statically unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,1.2,True,"The code uses the macro _MHD_EXTERN which expands to the GNU compiler attribute __attribute__((visibility(""default""))) (a compiler-specific extension). Use of this attribute is a language extension (documented in GCC/clang docs) and thus violates MISRA C 2023 Rule 1.2 that disallows language extensions.","Agent A's report is correct provided the macro _MHD_EXTERN actually expands to the GNU attribute form (for example __attribute__((visibility(""default"")))) or any other compiler-specific attribute syntax. The GCC/Clang __attribute__((...)) facility is a compiler language extension (documented as such in compiler manuals), and MISRA C:2023 Rule 1.2 requires that language extensions not be used. Using the attribute via a macro does not avoid the use of a language extension — the expansion still introduces the compiler-specific construct that Rule 1.2 forbids. 

Note: If _MHD_EXTERN is defined only as a standard-specifier (e.g. empty or simply ""extern"") on the target compiler, then there is no violation. The presence or absence of a violation therefore depends on the actual definition of _MHD_EXTERN in the build environment. If it does expand to a GCC/Clang attribute, the report is correct and the code violates MISRA C 2023 Rule 1.2.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/connection.c,MHD_set_connection_value_n,2.2,False,"No applicable dead code. The function performs a runtime check of argument sizes and conditionally returns MHD_NO; each expression (the kind comparison and the ternary strlen evaluations) affects that decision. There is no operation executed whose removal would leave program behaviour unchanged, so Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,14.2,False,"No for loop is present in the provided MHD_pool_create function. Rule 14.2 applies to for statements; since there are no for statements in this function, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,17.8,False,No violation: the parameter 'max' is only read (used in comparisons and passed to ROUND_TO_ALIGN) and is never assigned to or otherwise modified within MHD_pool_create. Therefore Rule 17.8 is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,21.17,False,"No violation. MHD_pool_create does not call any of the <string.h> functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). It only allocates memory via malloc/mmap/VirtualAlloc, computes allocation sizes and initializes fields pos/end/size. The only macro referenced (_MHD_POISON_MEMORY) is defined as a no-op here. No pointer arithmetic or string-handling calls in this function can cause accesses beyond object bounds, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,21.14,False,"MHD_pool_create does not call the C library function memcmp anywhere. Therefore there is no use of memcmp to compare null-terminated strings in this function. (A violating scenario would be, for example, using memcmp(s1, s2, strlen(s1)) or memcmp(s1, s2, strlen(s2)) to compare two NUL-terminated strings.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,8.13,False,"No violation: the pointer 'pool' and the member 'pool->memory' are used to modify the allocated MemoryPool object and the memory buffer (fields are assigned, _MHD_POISON_MEMORY presumably writes into the buffer). Therefore they cannot be const-qualified. There are no pointers in this function that could reasonably be made to point to const-qualified types without changing the function semantics.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,2.1,True,"When building for Windows (_WIN32) the code that handles mapping failures by comparing pool->memory to MAP_FAILED becomes effectively unreachable: VirtualAlloc() returns NULL on failure (not MAP_FAILED), so the 'if (MAP_FAILED == pool->memory)' branch that performs the fallback allocation will never be taken for Windows mappings. As a result the intended fallback path is not reachable in that build configuration and the code relies on a POSIX-specific sentinel (MAP_FAILED), violating MISRA C 2023 Rule 2.1 (no unreachable code).","The report is not correct. MISRA 2.1 forbids code that can never be executed in any build/runtime configuration of the project. The fallback branch (if (MAP_FAILED == pool->memory)) is not inherently unreachable in the Windows build: pool->memory is explicitly set to MAP_FAILED for the “small allocation” path earlier in the function, so that branch can be taken on Windows for those inputs. In other words, the MAP_FAILED test can be true on Windows (for the small-allocation case), so the code is potentially executable and therefore not unreachable per MISRA 2.1. 

Agent A’s observation points out a real portability/logic bug — VirtualAlloc returns NULL on failure, so a failed Windows mapping won’t be detected by comparing to MAP_FAILED — but that is a correctness/portability defect, not an instance of unreachable code under MISRA 2.1. To address the underlying bug, the code should use platform-appropriate failure checks (e.g. test for NULL on Windows) or conditionalize the failure test on the platform, but that is a different MISRA rule/concern than 2.1.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,1.2,False,"No violation: the function uses only standard C constructs (structs, sizeof, standard types like uintptr_t and bool from C99/C11, preprocessor conditionals, and platform APIs such as mmap/VirtualAlloc). There are no compiler language extensions (no GCC/Clang/MSC specific keywords like __attribute__, __typeof__, __asm, or non-standard statement expressions) evident in the provided code, so MISRA C 2023 Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_create,2.2,False,"No executed statements are redundant. The only no-op macros (mhd_assert, _MHD_POISON_MEMORY) expand to ((void)0) so they do not generate executed operations; unreachable branches are controlled by compile-time macros and therefore are not executed. All executed assignments and allocations affect subsequent behavior (alloc_size, pool->memory, pool->pos/end/size, is_mmap). Consequently Rule 2.2 (no dead code) is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,14.2,False,"No for-loop present in MHD_pool_reallocate; Rule 14.2 (well-formed for loops) is not applicable. The function uses only if statements and returns, so there is no opportunity to violate the for-loop clauses.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,17.8,False,"No violation: MHD_pool_reallocate updates fields of the MemoryPool object (pool->pos, pool->end checks) and the memory pointed to by 'old' but never assigns to the parameter variables themselves (pool, old, old_size, new_size). The pointer parameters are not reassigned, only the objects they point to are modified, which is allowed by Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,21.17,False,"The uses of memcpy and memset are bounds-checked by the surrounding logic. When shrinking (old_size > new_size) the code zeroes the tail of the original block with memset((uint8_t*)old + new_size, 0, old_size - new_size) — the asserts guarantee old points into the pool and old_size bytes are valid, so the range [old+new_size, old+old_size) is within bounds. If a new block must be allocated, asize is computed from new_size and the available space is checked before allocation; the code only reaches memcpy(new_blc, old, old_size) when old_size <= new_size (the shrinking case returns early), so the destination new_blc (which holds at least new_size bytes) is large enough. Additional asserts (and optional ASAN checks) ensure the old pointer/size are valid. Therefore no out-of-bounds accesses via the string functions occur.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,21.14,False,"MHD_pool_reallocate does not call memcmp. The function uses memcpy and memset to move and zero raw memory and performs pointer arithmetic and size checks; there is no use of memcmp to compare null-terminated strings, so no violation occurs.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,8.13,False,"The parameter 'old' is written to by this function: calls to memset((uint8_t *)old + new_size, ...), _MHD_UNPOISON_MEMORY(old, ...), memcpy(new_blc, old, old_size) (reads) and later memset(old,0,old_size)/_MHD_POISON_MEMORY(old,old_size) modify the object pointed to by 'old'. Because the function modifies the pointee, the pointer must be non-const. The function signature uses void *old (non-const), so Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,2.1,False,"No reachable unreachable code found. All branches in MHD_pool_reallocate are reachable depending on the values of 'old', 'old_size', 'new_size' and pool state (e.g. the 'old' block being the last allocated block vs. not). The early assertions are no-ops (mhd_assert expands to ((void)0)), so they do not render any statements unreachable. The checks for size wrap-around and available space intentionally gate returns (return NULL) and are reachable in overflow/insufficient-space scenarios. The shrinking/non-shrinking paths and the in-place-resize vs allocate-new-block paths are all reachable, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,1.2,False,"No violation: the function uses standard C types and constructs only. Optional use of __asan_region_is_poisoned is a sanitizer runtime function (guarded by preprocessor) and not a language/compiler extension. No compiler-specific extensions (attributes, typeof, inline asm, GCC/Clang builtins, or other documented extensions) are used.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/memorypool.c,MHD_pool_reallocate,2.2,True,"In a build where debugging/ASAN support is disabled the instrumentation macros used in MHD_pool_reallocate are defined as no-ops (for example _MHD_POISON_MEMORY, _MHD_UNPOISON_MEMORY and mhd_assert are defined as (void)0). Calls to these macros become executed no-op statements whose removal would not change program behaviour. Thus those calls constitute dead code under MISRA C 2023 Rule 2.2.","Not correct. MISRA Rule 2.2 forbids operations that are executed but whose removal would not affect program behaviour (i.e. true dead code). The calls in MHD_pool_reallocate (mhd_assert, _MHD_POISON_MEMORY, _MHD_UNPOISON_MEMORY) are instrumentation hooks that in some configurations expand to active code (ASAN/diagnostic builds) and in others expand to no-ops. Removing those calls from the source would change behaviour in the builds where they are active, so they are not dead code in the context of the project as a whole. Determination of dead code must consider the intended build configurations; a macro that conditionally expands to a no-op does not by itself make the call dead code. (The supplied test modifications and compile failure do not change this conclusion.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,14.2,True,"The for loop in the VxWorks section is not well-formed: the third clause (enb_set &= enb_set - 1) modifies an object (enb_set) that is not the loop counter (ret). Per Rule 14.2 the third clause shall modify only the loop counter. Additionally, the second clause (0 != enb_set) uses an object that is modified by the third clause, which is disallowed by the rule.","Agent A is correct. The for statement ""for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1) ++ret;"" violates Rule 14.2: the third clause modifies enb_set (a non‑counter object) rather than only the loop counter (ret), contrary to clause 3. In addition the second clause tests enb_set while that object is modified by the loop control expression, which is contrary to the intent of clause 2 (the condition may only use the loop counter and/or an appropriate loop flag). Thus the reported violation is valid.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,17.8,False,"No violation: mhd_tool_get_sys_cpu_count_special_api_ has no function parameters to modify. All pointer arguments in the body are used to refer to local objects (e.g. &psd_data, &sysInfo) and the objects they point to may be modified by called APIs, which is permitted. The code does not reassign or modify any function parameter (there are none), so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,21.17,False,"No violation. The only string.h function usages are memset on objects using sizeof of the same object (e.g. memset(&psd_data, 0, sizeof(psd_data)) and memset(&sysInfo, 0, sizeof(sysInfo))). These calls do not access beyond the bounds of the referenced objects. No other <string.h> functions (memcpy, strcpy, etc.) are used, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,21.14,False,"The function does not call memcmp anywhere. It only uses memset to initialize structures and performs API calls (GetProcAddress, LoadLibraryA, etc.). There is no comparison of null-terminated strings using memcmp, so Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,8.13,False,No violation: all pointer parameters that are used to modify the pointed object are non-const as required (e.g. &psd_data passed to pstat_getdynamic and &sysInfo passed to GetNativeSystemInfo/GetSystemInfo). There are no pointers that should be const-qualified but are not. Casts to (void *) for memset and GetProcAddress are used only to match API prototypes and do not create a pointer-to-non-const when a const-qualified pointer would be appropriate.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,2.1,False,"No violation: all code is either behind conditional compilation macros (platform-specific) or guarded by runtime checks on variable 'ret' and handles. Each block can be reached on appropriate platforms or runtime conditions, so there is no statically unreachable code in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,1.2,False,"No violation: the function uses platform-specific APIs and standard casts/types but does not use any compiler language extensions (no __attribute__, inline assembly, compiler-specific keywords, or other documented extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_special_api_,2.2,False,"No violation. The function contains conditional, platform-specific branches that may or may not be compiled in, but there is no executed operation which can be removed without changing program behaviour. Each assignment or call either affects the return value 'ret' (which is tested later) or performs an observable system interaction. No variable is assigned and then overwritten before use on the same control path, and the zeroing (memset) calls are initializations used before system calls (not clearly removable). Conditional compilation removes unreachable code for other platforms (not 'dead' by MISRA's definition).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,14.2,False,"The function contains no for loop constructs. MISRA C 2023 Rule 14.2 concerns well-formed for statements (their init, condition, and iteration expressions and loop counter usage). Since mhd_tool_get_sys_cpu_count_sysconf_fallback_ has no for statement, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,17.8,False,"No violation: the function mhd_tool_get_sys_cpu_count_sysconf_fallback_ has no parameters, so MISRA C 2023 Rule 17.8 (a function parameter should not be modified) cannot be violated. The function only uses local variables and conditional sysconf calls; no pointer or non-pointer parameters are modified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,21.17,False,"No violation: the function mhd_tool_get_sys_cpu_count_sysconf_fallback_ does not call any of the string handling functions from <string.h> (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). The code only calls sysconf, performs integer comparisons and casts. Therefore MISRA C 2023 Rule 21.17 (which restricts out-of-bounds accesses via string.h functions) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,21.14,False,The function mhd_tool_get_sys_cpu_count_sysconf_fallback_ performs only sysconf calls and integer/long checks; it contains no use of memcmp nor any comparison of null-terminated strings. Therefore Rule 21.14 (prohibiting memcmp for null-terminated string comparison) is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,8.13,False,"No violation: the function mhd_tool_get_sys_cpu_count_sysconf_fallback_ does not use any pointers. Rule 8.13 concerns pointer const-qualification; because there are no pointer variables or pointer parameters in this function (only int and long scalars and calls to sysconf which takes an integer argument and returns a long), there is no opportunity or need to apply const-qualification to a pointer. Therefore the rule is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,2.1,False,"No reachable unreachable code: given HAVE_SYSCONF and HAS_DECL__SC_NPROCESSORS_CONF are defined (and HAS_DECL__SC_CRAY_NCPU is not), all compiled branches are reachable at runtime. The function initializes value to -1, then assigns from sysconf when 0 >= value, checks for failure/overflow and returns accordingly. There are no statements that can never be executed (no dead code introduced by constant conditions). Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,1.2,False,"No violation: the function uses only standard ISO C constructs and POSIX library call sysconf plus standard preprocessor conditionals. There are no compiler-specific language extensions (such as __attribute__, __asm__, typeof, nested functions, statement expressions, or other extensions documented as compiler-specific).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_fallback_,2.2,False,"No violation. Given HAVE_SYSCONF and HAS_DECL__SC_NPROCESSORS_CONF are defined, the code within the #if is active and all operations influence the return value (sysconf is invoked and its result checked for errors and overflow). There is no executed assignment or statement that could be removed without changing the behavior: the initializations serve as needed fallbacks for conditional paths, the sysconf calls determine the returned count, and the overflow/error checks affect control flow. Unreachable code (excluded by macros) is not considered dead code by the rule, and nothing executed in the compiled function is redundant.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,14.2,False,Rule 14.2 (well-formed for loops) is not applicable because the function contains no for statements. There are only conditional preprocessor branches and if statements; therefore there is no possibility of violating the for-loop well-formedness clauses in this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,17.8,False,"The function mhd_tool_get_sys_cpu_count_sysconf_ has no parameters. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (or modifying pointer parameters themselves rather than the pointed-to object). Since this function declares no parameters and does not modify any parameter, the rule is not applicable and is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,21.17,False,"The function only calls sysconf and performs integer checks; it does not call any of the <string.h> functions (memcpy, strcpy, strlen, etc.). Therefore there is no potential for out-of-bounds access from string-handling functions and Rule 21.17 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,21.14,False,"No violation in the provided function: mhd_tool_get_sys_cpu_count_sysconf_ does not call the Standard Library function memcmp. A concrete violation scenario (not present here) would be if the code compared two null-terminated strings using memcmp, for example: if (memcmp(str1, str2, strlen(str1)) == 0) or if (memcmp(str1, str2, strlen(str1) + 1) == 0). Such use of memcmp to compare null-terminated strings would violate MISRA C 2023 Rule 21.14; instead functions like strcmp or strncmp should be used.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,8.13,False,"No violation: the function mhd_tool_get_sys_cpu_count_sysconf_ contains no pointer declarations or pointer parameters. MISRA C 2023 Rule 8.13 concerns pointer types and const qualification; since this function does not use pointers at all, the rule is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,2.1,False,"No violation. Given HAVE_SYSCONF and HAS_DECL__SC_NPROCESSORS_ONLN as defined, the code paths are reachable depending on runtime results of sysconf. The initial tests (if (0 >= value)) cannot be treated as statically constant because value is overwritten by sysconf, so subsequent branches and returns may be taken at runtime (e.g. sysconf can return -1 on error, causing later branches/returns to execute). No code in the function is proven unreachable at source level, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,1.2,False,"No violation: the function uses standard C constructs, conditional compilation and the POSIX/sysconf macros. It does not use any compiler-specific language extensions (for example GCC __attribute__, statement-expressions ({ ... }), typeof, asm, or non-standard keywords). The presence of build-time feature macros (HAVE_SYSCONF, HAS_DECL__SC_NPROCESSORS_ONLN) and POSIX _SC_NPROCESSORS_ONLN are not compiler language extensions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysconf_,2.2,False,"No violation: all executed operations in mhd_tool_get_sys_cpu_count_sysconf_ contribute to the function result. With HAVE_SYSCONF and HAS_DECL__SC_NPROCESSORS_ONLN defined the sysconf call(s), subsequent checks and casts determine the returned value or error; none of the executed statements are redundant or removable without changing behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,14.2,True,"The overall code violates MISRA C 2023 Rule 14.2 due to a for loop in mhd_tool_get_proc_cpu_count_w32_. The loop
  for (count_by_proc_aff_mask = 0; 0 != proc_aff; proc_aff &= proc_aff - 1)
modifies proc_aff in the third clause while the second clause uses proc_aff. Clause 2 of Rule 14.2 requires the loop condition to not depend on objects that are modified in the loop body/third clause (other than the loop counter), and clause 3 requires the third clause to modify only the loop counter. Here the third clause modifies proc_aff (not the declared loop counter), and the condition depends on that object, so the for statement is not well-formed.","Agent A's report is correct. The described for statement (for (count_by_proc_aff_mask = 0; 0 != proc_aff; proc_aff &= proc_aff - 1)) uses count_by_proc_aff_mask as the loop counter (initialized in the first clause) but the loop condition (second clause) depends on proc_aff and the third clause modifies proc_aff. MISRA C 2023 R14.2 requires that the third clause may modify only the loop counter (and the second clause may only use the loop counter and optionally a loop flag). Here proc_aff is neither the declared loop counter nor an allowed loop counter modification in the third clause, so the for statement is not well-formed under R14.2. A compliant fix is to make proc_aff the loop counter or to introduce a separate temporary loop-flag variable (e.g. temp = proc_aff; for (count_by_proc_aff_mask = 0, temp != 0; temp &= temp - 1) ... ), or convert the construct to an equivalent while loop that makes the loop control explicit.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,17.8,False,"The function has no parameters, so there is nothing that can be modified with respect to Rule 17.8. Therefore the rule is not applicable. (A violation scenario would be if the function accepted a pointer parameter and then modified the pointer itself — e.g. void f(int *p) { p = NULL; } — which would violate Rule 17.8.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,21.17,False,"No violation: mhd_tool_get_proc_cpu_count and the provided helper functions do not call any string-handling functions from <string.h> (no memcpy, memmove, memset, strcpy, strncpy, strcat, strncat, strlen, strspn, memcmp, etc.). Buffer/size parameters are derived from sizeof or CPU_ALLOC_SIZE and dynamic allocations are checked for NULL before use. Therefore Rule 21.17 (preventing out-of-bounds accesses from <string.h> functions) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,21.14,False,"No violation found: the function and its helper functions do not call memcmp to compare null-terminated strings. A specific violation scenario (not present here) would be if the code used memcmp(s1, s2, strlen(s1) + 1) or memcmp(s1, s2, strlen(s1)) to compare C-style null-terminated strings instead of using strcmp/strncmp or another appropriate string function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,8.13,False,No violation: mhd_tool_get_proc_cpu_count contains only int variables and function calls returning int; it declares no pointer types and does not manipulate pointers. Therefore MISRA C 2023 Rule 8.13 (pointer const-qualification) is not applicable to this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,2.1,False,"No violation. The function contains conditional compilation alternatives (#if / #else / #endif) that select one implementation at compile time; excluded branches are not part of the translation unit and therefore are not ""unreachable code"" in the built project. All statements present in the compiled translation unit are reachable along some control path (the function checks return values and conditionally returns; there are no statements that can never be executed, no code after unconditional returns, and no constant-false branches compiled).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,1.2,False,"No violation. The function uses only standard C constructs and preprocessor checks for predefined macros (__linux__, __GLIBC__) and calls to other functions. There are no compiler-specific language extensions (such as GCC statement-expressions, typeof, asm, attributes, zero-length arrays, or other non-standard language features) used in this snippet. The use of predefined platform macros is not a language-extension use that violates MISRA C 2023 Rule 1.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count,2.2,False,"No violation. The function conditionally calls a sequence of platform-specific helper functions and returns on the first successful (>0) result. None of the executed operations are redundant: each call may affect behavior on different platforms/configurations or when earlier helpers fail. The preprocessor selection and the runtime conditional returns make the code reachable and effective; there is no operation executed that could be removed without changing program behaviour, so Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,14.2,False,"No for loop is present in mhd_tool_get_sys_cpu_count_sysctl_fallback_. Rule 14.2 concerns the well-formedness of for statements (initialization, test, and iteration clauses and use of a single loop counter). Since the function contains no for statement, Rule 14.2 is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,17.8,False,"No violation: mhd_tool_get_sys_cpu_count_sysctl_fallback_ has no parameters, so Rule 17.8 (a function parameter should not be modified) is not applicable. The function only uses local variables and does not modify any function parameters or pointer parameters.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,21.17,False,"Not violated. The function does not call any of the string-handling functions from <string.h> (memcpy, strcpy, strlen, etc.). The only functions that write into user-provided buffers are sysctlbyname and sysctl; both are called with &ret and a value_size initialized to sizeof(ret), and the code verifies that the returned size equals sizeof(ret) before accepting the value (otherwise ret is set to -1). Therefore there is no risk of accesses beyond the bounds of the objects referenced by pointer parameters as covered by Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,21.14,False,"No violation in the provided function: the function does not call the standard library function memcmp anywhere. It uses sysctlbyname/sysctl and compares integer values and sizes, not null-terminated strings. A concrete violating scenario (not present here) would be if the code compared null-terminated strings using memcmp, e.g. memcmp(buf, ""hw.ncpu"", strlen(""hw.ncpu"") + 1) to check names — that would violate MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,8.13,False,"No violation. The code either passes pointers to const-qualified types where appropriate (the string literal ""hw.ncpu"" is passed to sysctlbyname which expects a const char *), or passes non-const pointers when the callee modifies the pointed-to objects (addresses of ret and value_size are passed to sysctlbyname/sysctl and those functions write into them, and mib is a non-const int[] passed to sysctl which expects a non-const int *). Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,2.1,False,"No unreachable code in mhd_tool_get_sys_cpu_count_sysctl_fallback_. All statements can be reached depending on platform macros and run-time state: ret is initialized to -1 so the guarded 'if (0 >= ret)' blocks are entered, and the final 'if (0 >= ret) return -1;' executes when no platform-specific sysctl succeeded. Preprocessor exclusions on __linux__ remove platform-specific attempts on that platform but do not create unreachable code within a given translation; they are conditional compilation, not unreachable code. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,1.2,False,"No language/compiler-specific extensions are used. The function uses standard C constructs, preprocessor conditionals and platform/configuration macros (e.g. __linux__, HAVE_SYSCTLBYNAME, HAVE_SYSCTL) which are not compiler language extensions. There are no GCC/Clang __attribute__ markers, asm statements, typeof, nested functions, or other documented compiler-specific extensions in the code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_sys_cpu_count_sysctl_fallback_,2.2,False,"No violation. The function contains no executed operations that could be removed without changing program behaviour. All statements (initialization of ret, the conditional sysctl/sysctlbyname blocks under compile-time guards, and the final check/return) can affect the result depending on build-time macros and run-time outcomes. Because conditional compilation may include platform-specific code paths, those statements are not dead code. (Unreachable code note: conditional compilation that removes code is not ‘‘dead’’ in the sense of executed-but-redundant; it is simply omitted.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,14.2,False,No for loop present in mhd_tool_get_system_cpu_count; Rule 14.2 (well-formed for loops) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,17.8,False,"No violation: mhd_tool_get_system_cpu_count has no parameters, so there is nothing to modify. The function only uses local variable 'res' and calls other functions; none of its (non-existent) parameters are modified, so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,21.17,False,"No violation: the code only uses memset from <string.h> and always passes the size computed with sizeof on the target object (e.g. memset(&psd_data, 0, sizeof(psd_data)); memset(&sysInfo, 0, sizeof(sysInfo));). There are no uses of strcpy, strncpy, strcat, strncat, memcpy, memmove, strlen, memcmp, or other string functions that could access beyond object bounds. All observed uses of string.h functions supply correct sizes, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,21.14,False,"No violation: the implementation of mhd_tool_get_system_cpu_count and its helper functions do not call memcmp to compare null-terminated strings. String literals appear only as arguments to system APIs (e.g. sysctlbyname, LoadLibraryA, GetProcAddress) and are not compared with memcmp, so MISRA C 2023 Rule 21.14 is not breached.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,8.13,False,"No violation: mhd_tool_get_system_cpu_count itself uses no pointer parameters. The helper functions and API calls (e.g. passing &ret and &value_size to sysctlbyname/sysctl, passing cpu_set_t pointers to sched_getaffinity/cpuset_getaffinity, passing allocated buffers to CPU_COUNT_S) all pass pointers that are intended to be modified by the callee. Therefore pointers are not overqualified as const and there is no place where a pointer should point to a const-qualified type whenever possible.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,2.1,False,"No violation. All branches in mhd_tool_get_system_cpu_count are conditionally reachable either by platform-specific preprocessing or by runtime values returned from helper functions. The code uses preprocessor conditionals to include/exclude platform-specific checks; this is not a MISRA 2.1 unreachable-code violation because no statement that remains in the compiled translation unit is provably unreachable at compile time. For example, on Linux (__linux__ or __GLIBC__ defined) the path that checks for (2 < res) and the subsequent (0 < res) block (which calls mhd_tool_get_proc_cpu_count()) can be exercised at runtime; on non-Linux the alternate (0 < res) return is reachable. Preprocessor-excluded code (e.g. #if 0 blocks) is removed before compilation and thus not considered unreachable code in the compiled program.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,1.2,False,"No violation: the function and related code use standard C constructs and platform conditional macros but do not use compiler-specific language extensions (e.g. typeof, __attribute__, statement-expressions, __extension__, or other compiler-only keywords). Conditional compilation and platform macros are standard preprocessor usage, not language extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_system_cpu_count,2.2,False,"No violation: the function contains platform- and runtime-dependent calls and conditional returns; there is no executed operation that can be removed without changing behaviour. All executed statements (calls, checks and returns) influence the return value depending on build-time macros and runtime results, so no dead code per MISRA C:2023 Rule 2.2 is present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,14.2,False,"The for loop at 'for (cpu_num = 0; cpu_num < max_num; ++cpu_num)' is well-formed: the first clause initializes the single loop counter (cpu_num = 0), the second clause ('cpu_num < max_num') has no side effects and only uses the loop counter, and the third clause ('++cpu_num') modifies only the loop counter. The loop counter is not modified in the loop body. The subsequent do/while that increments cpu_num is in an alternate path (when max_num <= 0) and does not affect the correctness of the for loop. Therefore no violation of MISRA C 2023 Rule 14.2 is present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,17.8,False,"No violation: mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ has no parameters. Rule 17.8 forbids modifying function parameters (or modifying a pointer parameter itself); since this function declares no parameters, it cannot violate the rule. Local pointer cpuset_ptr is a local variable (not a parameter) and may be modified without violating Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,21.17,False,"No violation: mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ does not call any of the <string.h> functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.), so MISRA C 2023 Rule 21.17 (which restricts use of those functions to avoid out-of-bounds accesses) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,21.14,False,"No violation: the function mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ does not call memcmp or otherwise use memcmp to compare null-terminated strings. It uses cpuset APIs (cpuset_create, cpuset_isset, cpuset_destroy), sched_getaffinity_np, sysconf and sysctl/sysctlbyname variants. Therefore MISRA C 2023 Rule 21.14 is not violated in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,8.13,False,"No violation: cpuset_ptr is created by cpuset_create(), populated/modified by sched_getaffinity_np(), and destroyed by cpuset_destroy(). Because the object pointed-to is initialized/modified by these functions, the pointer must not be to a const-qualified type. cpuset_isset() only reads the cpuset, but that does not justify marking cpuset_ptr as const because other API calls modify it. Therefore Rule 8.13 (use const where possible) is not violated here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,2.1,False,"No violation: the function contains conditional compilation and an if (1) used as a fallback branch, but there is no statically unreachable compiled code in the provided project configuration. The large block is compiled only when HAVE_SCHED_GETAFFINITY_NP and HAVE_GETPID are defined; otherwise it is omitted entirely (not unreachable). The runtime branches (including the else combined with the follow-up if (1)) are reachable depending on sysconf/cpuset results, so there is no code that is compiled into the project but can never be executed.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,1.2,False,"No violation: the function uses standard C syntax, preprocessor conditionals and platform APIs (cpuset, sched_getaffinity_np, sysconf) but does not use any compiler language extensions (no __attribute__, typeof, statement-expressions, inline asm, __extension__, or other documented compiler-specific language features).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_sched_getaffinity_np_,2.2,False,"Although the code contains an apparent constant conditional (if (1)), this is used intentionally to form an 'else if' when the prior #if block is present (the comment 'Combined with the next \`if\`' documents that). The block guarded by that conditional performs the fallback counting when sysconf information is not available; removing the conditional block (or the check) would change behavior in configurations where the first branch is not taken. Therefore there is no operation present that is executed but whose removal would not affect program behaviour across the different build configurations — i.e. no dead code per MISRA C 2023 Rule 2.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,14.2,False,"No violation: the single for loop (for (i = 0; i < CPU_SETSIZE_SAFE; ++i)) is well-formed. The first clause initializes the loop counter (i = 0). The second clause (i < CPU_SETSIZE_SAFE) has no persistent side effects and uses only the loop counter and a compile-time constant. The third clause (++i) modifies only the loop counter. The loop body modifies ret, which is not the loop counter, and does not modify any object used in the second or third clauses. Therefore Rule 14.2 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,17.8,False,"No violation: the function mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ has no parameters (signature: void), so there are no function parameters that could be modified; therefore Rule 17.8 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,21.17,False,"No violation: the function does not call any of the <string.h> functions listed by MISRA C 2023 Rule 21.17 (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). All buffer operations are performed via cpuset_getaffinity / CPU_ALLOC / CPU_FREE and CPU_COUNT/CPU_COUNT_S/CPU_ISSET, which are not string.h functions. Therefore Rule 21.17 is not applicable here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,21.14,False,"No violation: the function contains no use of memcmp or any string comparison functions. It only uses cpuset_getaffinity, CPU_COUNT/CPU_COUNT_S, CPU_ALLOC, CPU_FREE and bitset checks. Therefore MISRA C 2023 Rule 21.14 (which forbids using memcmp to compare null‑terminated strings) is not violated. (A violating scenario would be if the code used memcmp to compare two null‑terminated strings, e.g. memcmp(s1, s2, strlen(s1)+1), which does not occur here.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,8.13,False,"No violation: all pointers that reference cpuset storage are used by functions that modify the pointed-to object (cpuset_getaffinity fills cur_mask and p_mask). Because the objects are written to, the pointers must be non-const; therefore they are correctly declared as non-const and Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,2.1,False,"No violation. The function contains conditional compilation branches that are conditionally included, but there is no statically unreachable statement within the compiled function: control reaches the top-level if (0 >= ret) (ret initialized to -1) and then either the CPU affinity code paths (when HAVE_CPUSET_GETAFFINITY is defined) execute or are excluded by the preprocessor. All code that remains after preprocessing can be reached at runtime and there are no dead statements or code after an unconditional return. With the provided symbol set (HAVE_CPU_COUNT and HAVE_CPU_COUNT_S defined, but HAVE_CPUSET_GETAFFINITY not defined) the large affinity block is excluded and the remaining code returns -1 — still no unreachable code is present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,1.2,False,"No violation: the function uses only standard C constructs and macros/types (cpuset_t, CPU_COUNT, CPU_ALLOC, etc.). There are no compiler-specific language extensions (no __attribute__, typeof, statement expressions, inline asm, platform-specific keywords, or other documented compiler extensions) present in the function, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/mhd_tool_get_cpu_count.c,mhd_tool_get_proc_cpu_count_cpuset_getaffinity_,2.2,False,"No violation. The function contains conditional compilation blocks that include or exclude alternative implementations depending on feature macros (e.g. HAVE_CPUSET_GETAFFINITY, HAVE_CPU_COUNT, HAVE_CPU_COUNT_S). All code that can be executed affects the return value (ret) and thus program behaviour; there are no executed statements whose removal would not change behaviour. Code that is not compiled due to #if/#ifdef is not ""dead code"" per the rule (it's simply excluded).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,14.2,False,No for loop present in fill_v1_form; Rule 14.2 (well-formed for loop) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,17.8,False,"No violation: fill_v1_form does not modify any of its parameters. The function only reads from session->value_1 (allowed: the object pointed to by a pointer may be accessed/modified, but here it is only read), casts and uses local pointer 'reply', and passes the parameters to other functions without assigning to them. There are no assignments to cls, mime, session, or connection (the pointer parameters themselves are never modified), and no parameter is used as an lvalue. Thus Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,21.17,False,"No violation. The function computes the exact required buffer length using snprintf(NULL,0, ...), allocates reply_len+1 bytes and then calls snprintf(reply, reply_len+1, FORM_V1, session->value_1). No functions from <string.h> (memcpy, strcpy, strcat, strlen, etc.) are used in fill_v1_form itself, and the snprintf calls are bounded by the allocated size, preventing writes beyond the buffer. The helper add_session_cookie also uses snprintf with an explicit destination size (cstr[256]), so it does not violate the rule either.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,21.14,True,"Violation occurs in add_response_header_connection where memcmp is used to compare hdr->value (a null-terminated header value) with the literal ""close"" using memcmp(hdr->value, ""close"", 5). This uses memcmp to compare null-terminated string data and therefore violates MISRA C 2023 Rule 21.14.","The claim is not correct for the provided fill_v1_form code. The source shown contains no use of memcmp (or any string comparison at all), so it cannot violate MISRA C 2023 Rule 21.14. The scenario offered by agent A points to a different routine (add_response_header_connection) where memcmp(hdr->value, ""close"", 5) might occur — that would be a potential violation if it indeed uses memcmp to compare null-terminated strings — but that function is not part of the submitted fill_v1_form code. The supplied test/logging code also contains no memcmp and failed to compile, so it does not demonstrate a violation in fill_v1_form. Therefore the report that fill_v1_form violates Rule 21.14 is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,8.13,True,"The function fill_v1_form accepts a non-const pointer 'struct Session *session' but does not modify the Session object; it only reads session->value_1 and session->sid (and passes the pointer to other functions that also do not modify it in this path). According to MISRA C 2023 Rule 8.13, the pointer should be to a const-qualified type whenever possible. Therefore this is a violation: session could (and should) be declared const struct Session *session.","Not correct. MISRA R8.13 requires a pointer to be const-qualified when the pointed-to object is never modified, but you must consider calls and external API constraints. In this function the session pointer is passed to add_session_cookie (and could be required by the callback API), so we cannot determine from the code shown that the object is never modified. If add_session_cookie or the framework callback signature requires a non-const pointer, then making the parameter const would be incorrect. Because the report assumes no callees modify session without proving that (and without checking API constraints), the claim of a definite MISRA 8.13 violation is not justified. If, however, you can guarantee that none of the callees modify session and the callback signature is not mandated to be non-const, then changing the parameter to const struct Session *session would satisfy R8.13.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,2.1,False,"No violation: analysis of fill_v1_form shows no unreachable code paths — all statements can be reached depending on input/return conditions (error returns, response NULL vs non-NULL, header add success/failure).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,1.2,False,"No compiler-specific language extensions are used in fill_v1_form or the nearby helper functions. The code contains only standard C constructs (casts, standard library functions, typedefs, function calls). There are no uses of compiler extensions such as __attribute__, __asm__, typeof, statement-expressions, nested functions, or other vendor-specific keywords documented as extensions, so MISRA C 2023 Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_form,2.2,False,"No violation: the function contains no executed operations whose removal would not affect program behaviour. All variables are used; control-flow branches perform observable actions (memory allocation, response creation, header modifications, logging). The (void)cls; statement intentionally suppresses an unused-parameter diagnostic and does not constitute dead code in the sense of an operation that should be removed. Therefore Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,14.2,False,"serve_simple_form contains no for statements. MISRA C 2023 Rule 14.2 concerns the well-formedness of for loops (initialisation, condition and iteration expressions and single loop counter). As there are no for loops in serve_simple_form (nor in the immediate code paths it calls), the rule is not applicable and is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,17.8,False,"No violation: serve_simple_form does not modify any of its function parameters. It copies the const void *cls value into a local pointer (const char *form) and only passes pointer parameters to other functions; it does not reassign cls, mime, session or connection. The function may modify the object pointed to by session via add_session_cookie (allowed by the rule), but it does not modify the pointer parameters themselves.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,21.17,True,"Calling serve_simple_form with a pointer to an object that is not NUL-terminated (for example, the first member array of a struct which is not terminated, while the next struct member contains the terminating '\0'). strlen(form) will read past the bounds of the first array into the adjacent member to find the terminator — this is an access beyond the bounds of the object referenced by 'form', violating Rule 21.17.","The report is correct. serve_simple_form calls strlen(form) on the pointer derived from cls without any guarantee that the pointed-to array is NUL-terminated. If a caller passes a pointer to an array that does not contain a terminating '\0' (for example the first member of a struct where the terminator is in the next member), strlen will read past the bounds of that array to find a terminator — this is an out-of-bounds access / undefined behavior and therefore violates MISRA C 2023 Rule 21.17. (The provided test harness failing to compile does not change the correctness of the reasoning: the code as written can cause out-of-bounds access for some valid calls.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,21.14,False,"No violation: serve_simple_form does not use memcmp to compare null-terminated strings. The function only uses strlen, MHD_create_response_from_buffer_static, add_session_cookie and MHD_add_response_header. There is no use of memcmp in this function; any memcmp usage (if present) would be in other helper functions not called here for null-terminated string comparisons.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,8.13,False,"No violation: serve_simple_form takes cls as const void * and assigns it to const char *form, then passes form to MHD_create_response_from_buffer_static which accepts a const void * buffer. None of the called functions modify the data pointed to by form (the response keeps a reference to the buffer but treats it as const and does not write into it). Therefore the pointer is correctly const-qualified and Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,2.1,False,"No unreachable code: all statements in serve_simple_form are reachable. The if-statement body (error log) can execute when MHD_add_response_header returns a value other than MHD_YES; the main return path via ret is always reachable. There are no early returns, dead branches, or statements placed after a guaranteed-return or infinite-loop, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,1.2,False,"No language extensions are used. The function and the referenced helpers use only standard C constructs (static, enums, pointers, function calls, macros limited to constants). There are no compiler-specific extensions such as __attribute__, __asm, typeof, statement-expressions, nested functions, or other documented compiler extensions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,serve_simple_form,2.2,False,"No violation: serve_simple_form does not contain dead code. Each executed operation has observable effect (creating response, adding session cookie/header, queuing response, destroying response). The local declaration 'const char *form = cls;' is an initialization (note 3) and not considered dead code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,14.2,False,"The function contains no 'for' statements. MISRA C 2023 Rule 14.2 applies to the structure of 'for' loops; since there are no 'for' loops in fill_v1_v2_form, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,17.8,False,"No violation: the function does not modify any of its parameter variables. Pointer parameters (session, connection, mime, cls) are only dereferenced or passed to other functions; the objects they point to may be used/modified (e.g. session->value_1/value_2, add_session_cookie(session,...)), which is permitted by the rule, but the pointer variables themselves are never reassigned or modified. The cast of reply to (void *) when creating the response does not modify any parameter.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,21.17,False,"No violation: the function does not call any of the string.h functions listed by MISRA C 2023 Rule 21.17 (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). It uses snprintf (from <stdio.h>) to compute the required buffer length and then to write into a buffer of size reply_len + 1, matching the length reported by the first snprintf call. Therefore there is no access beyond the bounds of objects via the <string.h> functions covered by the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,21.14,True,"When a response already has a ""Connection"" header, add_response_header_connection uses mhd_assert with memcmp: mhd_assert (already_has_close == (0 == memcmp (hdr->value, ""close"", 5))); hdr->value is a null-terminated header string (terminated earlier via buf[pos] = 0). Using memcmp to compare that null-terminated string to the literal ""close"" (a null-terminated string literal) constitutes comparing null-terminated strings with memcmp, which violates MISRA C 2023 Rule 21.14.","The presented fill_v1_v2_form function contains no use of memcmp (or any string comparison calls). It only calls MHD_add_response_header (and other library/helper functions). If an internal function such as add_response_header_connection uses memcmp to compare a null-terminated header string to ""close"", that internal function would be the locus of a Rule 21.14 violation — not fill_v1_v2_form itself. The agent’s scenario therefore describes a plausible MISRA violation, but it is misattributed: the violation would be in the header-handling code (MHD_add_response_header / add_response_header_connection), not in the shown fill_v1_v2_form code. Also, the supplied test code did not compile so no runtime evidence was produced. Hence the report that fill_v1_v2_form violates MISRA C 2023 Rule 21.14 is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,8.13,False,"No violation. The pointers in fill_v1_v2_form are const-qualified where appropriate and non-const where modification is required. Examples: 'mime' is const char * because it is only read; 'cls' is const void * (unused) which is fine; 'session' is struct Session * and is deliberately non-const because add_session_cookie(session, response) modifies the session state; 'reply' is char * and is written by snprintf, so it must not be const. The cast (void *)reply is required by the MHD API. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,2.1,False,"No violation. All code paths in fill_v1_v2_form are reachable depending on runtime conditions: 1) snprintf(NULL,0,...) can return negative -> early return; 2) malloc can return NULL -> early return; 3) snprintf into reply can return a different value (negative or different length) -> free and return; 4) MHD_create_response_from_buffer_with_free_callback can return NULL -> free and set ret=MHD_NO; else normal success path. There is no unreachable statement in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,1.2,False,"No language/compiler-specific extensions are used in fill_v1_v2_form. The function uses only standard C constructs (enum, struct, casts, snprintf, malloc/free, function calls and macros). The helper symbols shown are macros and library-like functions, not compiler language extensions (no inline asm, attributes, GCC/MSC-specific keywords, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/sessions.c,fill_v1_v2_form,2.2,False,"No dead code found in fill_v1_v2_form: every executed statement has an observable effect on program behaviour (error checking, memory allocation/free, snprintf to determine/produce the reply buffer, response creation/queueing, header addition and logging). The (void) cls; line is an intentional no-op to suppress an unused-parameter warning and does not constitute dead code in the sense of an operation that could be removed without affecting program behaviour (it documents intent and prevents compiler diagnostics).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,14.2,False,"No violation: The code does not violate MISRA C 2023 Rule 14.2. The only for loop present is in MHD_str_equal_caseless_n_. That loop uses a single loop counter 'i' initialized in the first clause, the condition 'i < maxlen' has no side effects and only uses the loop counter and an unmodified parameter, and the iteration expression '++i' modifies only the loop counter. The loop counter is not modified elsewhere in the loop body. All clauses meet the requirements of Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,17.8,False,"No violation: the function does not modify the pointer parameter 'destination' itself. The code only writes through the pointer (assigns to *destination and then fills the allocated buffer). Rule 17.8 allows modification of the object referred to by a pointer parameter but forbids changing the pointer parameter value (e.g., assigning to destination). All parameters 'buf' and 'key' are const and not modified. The control path that demonstrates the behavior: when *destination is NULL and a quoted key=value is found, the function allocates memory and stores the pointer into *destination and copies the string into that buffer — this modifies the pointee, not the parameter.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,21.17,False,"No violation: try_get_value ensures the header buffer is NUL-terminated before any use of strstr/strchr/strlen, checks for expected '=' and '""' characters before accessing subsequent bytes, computes the value length from the location of the closing quote and allocates exactly value_length+1 bytes, and copies exactly value_length bytes and appends a NUL. Therefore the <string.h> calls do not access beyond the bounds of the referenced objects.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,21.14,False,"No violation in the provided try_get_value implementation. The function uses strlen, strstr, strchr and memcpy; it does not call memcmp. A specific violation scenario would be if the code attempted to compare null-terminated strings with memcmp, for example: if (0 == memcmp(spos, key, strlen(key))) { ... } — using memcmp to compare C strings (null-terminated) would violate MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,8.13,False,"No violation. The destination parameter is correctly declared as char ** because try_get_value modifies the object pointed to by that pointer: it assigns *destination (malloc) and writes into the allocated buffer. According to Rule 8.13 a pointer must not point to a const-qualified type if the function modifies the pointed-to object, so making destination point to non-const is appropriate. The buf and key parameters are const char * and are only read, which follows the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,2.1,False,"No violation. The function try_get_value contains no statements that can never be reached: all conditional branches (returns and continue) are reachable depending on input (destination pointer, contents of buf and key, memory allocation result). The while loop can exit normally when strstr returns NULL, and the function then implicitly returns (void). There is no dead code (no code after unconditional return that is nonetheless syntactically present and unreachable). Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,1.2,False,"No language extensions are used. The function uses only standard C constructs and standard library functions (strlen, strstr, strchr, malloc, memcpy). There are no compiler-specific attributes, inline assembly, typeof, statement expressions, extended integer types, or other documented compiler extensions present, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,try_get_value,2.2,False,"No violation. The function try_get_value contains no dead code: every executed assignment, branch and memory operation affects subsequent control flow or observable state (bpos is used to continue the search, klen and vlen are used to compute offsets and allocation size, the malloc, null-termination and memcpy write the allocated buffer which is returned via destination, and the various early returns change control flow). There are no operations that are executed yet removable without changing program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,14.2,False,The function post_process_multipart contains no for statements; it uses while and switch constructs. MISRA C 2023 Rule 14.2 (requirements for well-formed for loops) is therefore not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,17.8,False,"No violation: the function modifies the object pointed to by the pointer parameter pp (members like pp->buffer_pos, pp->state, etc.), which is permitted. Neither pointer parameter itself (pp or post_data) nor the scalar parameter post_data_len is reassigned in the function. Thus Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,21.17,False,"No violation. All uses of the <string.h> functions in post_process_multipart and the related helper functions are guarded so that source and destination ranges are within the allocated buffer. memcpy in post_process_multipart copies at most pp->buffer_size - pp->buffer_pos bytes into the allocated buffer (allocated as buffer_size + 1 bytes), memmove calls use ranges computed from pp->buffer_pos and ioff that are bounded by buffer_size, and memcmp/memchr in find_boundary and process_value_to_boundary are only invoked after checks that ensure the buffer contains the required number of bytes. The strlen call in MHD_create_post_processor is used only after ensuring the pointer references a valid, NUL-terminated string. Therefore no accesses beyond object bounds occur.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,21.14,True,"Violation occurs when the code uses memcmp to compare a null-terminated C string (boundary) with bytes read from the input buffer. For example, process_value_to_boundary and find_boundary call memcmp with the 'boundary' pointer (which is derived from a C string and for which blen is strlen(boundary)). Using memcmp on such null-terminated strings to perform string comparisons violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings). A concrete scenario: receiving multipart data whose boundary is the C string ""myboundary"" (blen == strlen(""myboundary"")), the code uses memcmp(&buf[newline + 4], boundary, blen) to detect the boundary — this is memcmp comparing bytes from a null-terminated string and thus violates the rule.","Agent A is correct. The code calls memcmp(&buf[i], boundary, blen) (in find_boundary and process_value_to_boundary) where `boundary` is a conventional null-terminated C string and `blen` is derived from strlen(boundary) (e.g. pp->nlen = strlen(pp->nested_boundary) elsewhere). That is exactly using memcmp to compare a null-terminated string (the boundary) with bytes, which falls under MISRA C 2023 Rule 21.14 (“memcmp shall not be used to compare null terminated strings”). process_multipart_headers also uses memcmp with the string literal ""\r\n\r\n"" and a length of 4, which similarly uses memcmp on a null-terminated string literal. If the intent is to compare C strings, MISRA expects string comparison functions (e.g. strcmp/strncmp or other approved means); memcmp is only allowed for non–null-terminated byte sequences. Therefore the reported violation is correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,8.13,False,No violation: the function correctly declares post_data as const char * (source buffer) and uses non-const char * for buf and struct MHD_PostProcessor *pp where the pointed objects are modified. No pointer points to a const-qualified type while being used to modify the pointed object; therefore Rule 8.13 is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,2.1,False,"No reachable-unreachable code found. All control paths in post_process_multipart are reachable depending on run-time values (pp->skip_rn and pp->state). The labelled gotos (AGAIN, END) are used and reachable; switch fall-throughs are intentional and annotated. The default MHD_PANIC branch is reachable if pp->state holds an unexpected enumerator value, so it is not unreachable. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,1.2,False,"No language extensions used in post_process_multipart. The function only uses standard C features (pointer arithmetic, goto, switch, standard library calls like memcpy/strstr/strdup/free/memmove). The visible MHD_PANIC macro references BUILTIN_NOT_REACHED in its definition in additional code, but that macro's expansion is not shown as a compiler-specific builtin here; based on the provided code the function itself does not directly use any compiler language extensions, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_multipart,2.2,False,"No violation: post_process_multipart implements an active state machine where every executed operation can affect parser state, buffer content, or control flow (including early returns). There are no executed statements that, if removed, would leave program behaviour unchanged — e.g. assignments to state variables, memmove/memcpy, goto/labels and returns all influence subsequent behaviour. Therefore Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,14.2,True,"Violation in MHD_unescape_plus: the for loop uses strchr(...) in its third clause (p = strchr(p + 1, '+')), which reads the string object that is modified in the loop body (*p = ' '). The third clause therefore uses an object that is modified in the loop body, violating MISRA C 2023 Rule 14.2 (the third clause shall not use objects that are modified in the for loop body).","The report as stated is not correct. MISRA C:2023 Rule 14.2 concerns the well‑formedness of for statements (their three clauses). The shown process_value function contains no for statement, so it cannot itself directly violate Rule 14.2. Agent A’s narrative points to a for loop inside MHD_unescape_plus (not shown). If MHD_unescape_plus indeed uses a header like for (...; ...; p = strchr(p + 1, '+')) while its body modifies the same string buffer (e.g. *p = ' '), then that for loop would violate Rule 14.2 because the third clause uses objects that are modified in the loop body. However, that is a potential violation in MHD_unescape_plus, not in process_value, and you cannot confirm it from the material provided (the MHD_unescape_plus implementation was not included and the test build failed). Therefore the specific report that process_value violates Rule 14.2 is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,17.8,True,"The function modifies its pointer parameters 'value_start' and 'value_end'. Specifically, value_end is assigned (value_end = last_escape;) and value_start is incremented (value_start += delta;). This changes the pointer parameters themselves, which violates MISRA C 2023 Rule 17.8 (function parameter should not be modified).","Correct. MISRA C:2023 Rule 17.8 prohibits modifying a formal parameter itself; only the object pointed to by a pointer parameter may be modified. In process_value the pointer parameters are reassigned/updated: value_end = last_escape; and value_start += delta; (they are formal pointer parameters, not the objects they point to). Those statements modify the pointer parameters and therefore violate Rule 17.8. To comply, introduce local variables (e.g. const char *vs = value_start; const char *ve = value_end;) and operate on those instead of modifying the formal parameters.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,21.17,True,"The initial memcpy(xbuf, pp->xbuf, pp->xbuf_pos) can read more bytes from pp->xbuf than pp->xbuf actually contains. In the struct, pp->xbuf is only 2 bytes long, but process_value uses pp->xbuf_pos as the copy length without checking it against sizeof(pp->xbuf). If pp->xbuf_pos > sizeof(pp->xbuf) (for example due to corrupted state or an unexpected code path that sets xbuf_pos > 2), the memcpy will access pp->xbuf beyond its bounds, violating MISRA C 2023 Rule 21.17.","The report is correct. The initial memcpy(xbuf, pp->xbuf, pp->xbuf_pos) uses pp->xbuf_pos as the source length but there is no check in process_value that pp->xbuf_pos <= sizeof(pp->xbuf). The top assertion checks pp->xbuf_pos < sizeof(xbuf) (i.e. the destination buffer size), not against sizeof(pp->xbuf) (the source size). If sizeof(pp->xbuf) is smaller than sizeof(xbuf) (or pp->xbuf_pos was corrupted or set unexpectedly greater than sizeof(pp->xbuf)), the memcpy will read beyond the bounds of pp->xbuf, which is exactly what MISRA C 2023 Rule 21.17 forbids. Relying on mhd_assert is not sufficient because assertions may be compiled out and do not themselves prevent out-of-bounds access. To fix this, the code must ensure (e.g. by an explicit runtime check or by design invariant enforced at all call sites) that pp->xbuf_pos <= sizeof(pp->xbuf) before copying, or restrict the copied length to the actual source size.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,21.14,False,"No use of memcmp in process_value or the related functions shown. The code uses memcpy/memmove/strchr/strlen and custom unescape routines but does not call memcmp. Therefore Rule 21.14 is not violated. (Hypothetical violation example: calling memcmp(xbuf, ""abc"", strlen(""abc"")+1) to compare null-terminated strings would violate the rule.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,8.13,False,"No violation. The input pointers value_start, value_end and last_escape are declared as const char * and are only read (used for memcpy, comparisons and pointer arithmetic). The pp parameter is non-const because the function modifies members of the struct (pp->xbuf_pos, pp->xbuf, pp->must_ikvi, pp->value_offset, pp->state). There is no case where a pointer to a const-qualified type is used to modify the object pointed to, nor a non-const pointer that could be const-qualified. Thus Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,2.1,True,In post_process_urlencoded the 'case PP_Error:' label inside the switch is unreachable because the surrounding while loop condition explicitly requires (pp->state != PP_Error). The code under that case (abort(); break;) can never be reached at runtime. This constitutes unreachable code and thus violates MISRA C 2023 Rule 2.1.,"The report is not correct. Agent A's claim references a 'case PP_Error:' label inside post_process_urlencoded and asserts it is unreachable because a surrounding while tests (pp->state != PP_Error). The supplied target code is process_value and contains no switch or case labels — it does set pp->state = PP_Error in an error path and then returns, but there is no while condition checking pp->state in this function that would render code unreachable. The supplied test/logging code also failed to compile, so no demonstration of unreachable code was provided. To prove a MISRA 2.1 violation one must show an actual unreachable statement/label in the real function; that evidence is missing and the reasoning is based on a different function than the one shown. Therefore the report is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,1.2,False,"No use of compiler-specific language extensions detected. The function uses standard C constructs (pointer arithmetic, casts, standard library functions like memcpy/memmove, and the 'bool' type which is part of the C standard via <stdbool.h>); there are no occurrences of compiler-specific keywords or builtins (e.g. __attribute__, typeof, __asm__, statement expressions, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value,2.2,False,"No violation: analysis found no executed operation within process_value that can be removed without changing program behaviour. The mhd_assert calls expand to ((void)0) and thus are not executed; all assignments and branches affect subsequent control flow or state used either within the function or by future calls (e.g. pp->xbuf_pos, pp->must_ikvi, pp->value_offset, and the ikvi callback). Therefore Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,14.2,False,No for statement is present in process_value_to_boundary; the function uses while loops only. MISRA C 2023 Rule 14.2 applies to for loops and therefore is not applicable here. No for-loop related violations (such as multiple loop counters or modification of the loop counter in the body) occur in this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,17.8,False,"No violation: the code does not assign to any function parameter variable. It modifies the object pointed to by pp (pp->...) and the object referred to by ioffptr ((*ioffptr) += ...), which is allowed. The pointer parameters pp, ioffptr and boundary themselves are not reassigned or modified, so MISRA C 2023 Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,21.17,False,"No violation: the code guards all uses of memchr and memcmp so they cannot read beyond pp->buffer_pos. The inner while condition (newline + 4 < pp->buffer_pos) ensures the memchr length argument is positive and that any '' found is at least 4 bytes before buffer_pos, making the subsequent memcmp(""\r\n--"", &buf[newline], 4) safe. The check (newline + blen + 4 <= pp->buffer_pos) guarantees the memcmp(&buf[newline + 4], boundary, blen) only reads bytes within the buffer. When memchr returns NULL the code sets newline = pp->buffer_pos - 4 so no out-of-bounds comparisons occur. The write buf[newline] = '\0' is only performed after a successful boundary detection, which is itself only done when the boundary bytes are confirmed to be inside the buffer. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,21.14,False,"No violation: all uses of memcmp compare fixed-length byte sequences (explicit lengths 4, 2 or blen) and do not rely on null terminators. For example memcmp(""\r\n--"", &buf[newline], 4) explicitly compares four bytes (excluding the literal's NUL), and memcmp(&buf[newline+4], boundary, blen) compares blen bytes of the boundary buffer; none of these use memcmp to compare C-style null-terminated strings.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,8.13,False,No violation: the function uses a non-const pointer 'buf' because it writes into the buffer (buf[newline] = '\0') and updates offsets; thus the pointer must be non-const. The boundary pointer is correctly declared const char * since it is only read. Local pointer 'r' is const char * and is only used for inspection. Therefore the code follows the intent of Rule 8.13.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,2.1,False,"No reachable-code violations found. All statements in process_value_to_boundary are reachable via the loop, break, and return conditions: the infinite while(1) loop contains reachable break or return paths (boundary detection leads to break; buffer-full error returns; normal flow breaks out and continues). The final ikvi call and subsequent statements are reachable depending on runtime conditions (must_ikvi, newline, and ikvi return value). No code is literally unreachable at compile-time or logically impossible to reach, so MISRA C 2023 Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,1.2,False,"No language extensions are used. The code uses only standard C constructs (pointer arithmetic with &pp[1], casts, standard library functions memchr/memcmp, enums, size_t, and a function pointer call). There are no compiler-specific extensions (no __attribute__, inline asm, typeof, GCC/Clang keywords, pragmas, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,process_value_to_boundary,2.2,True,"The assignment buf[newline] = '\0' is executed when the boundary is found, but it only writes a terminating NUL into the internal buffer which is not required by subsequent operations (the ikvi callback is passed an explicit length). Removing this assignment would not affect program behaviour, so it constitutes dead code under Rule 2.2.","The claim is not supported. Agent A’s argument rests on the narrow observation that the ikvi callback is passed an explicit length, so the explicit NUL write appears unnecessary for that single call. MISRA Rule 2.2 requires proof that removing an executed operation would not affect program behaviour anywhere in the project. The provided evidence (a logging build that did not compile) does not establish that the assignment has no effect. In practice the assignment buf[newline] = '\0' can affect behaviour beyond the immediate ikvi() call: it mutates shared buffer state that other code (current or future) may treat as a C‑string, may rely upon for diagnostics/logging, or may inspect later when the buffer is reused. Because the removal could change program behaviour and no definitive proof was given that it cannot, the report of a Rule 2.2 violation is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,14.2,False,"No for-loops are present in post_process_urlencoded; the function uses while and switch constructs only, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,17.8,False,"No violation: the function post_process_urlencoded does not assign to any of its parameter variables (pp, post_data, post_data_len). It only modifies the object pointed to by pp (e.g. pp->state, pp->buffer_pos, flags), which is allowed. There are no statements like 'pp = ...' or 'post_data = ...' that would modify the pointer parameters themselves. The cast and use of &pp[1] to derive kbuf uses the pointer value but does not modify the parameter variable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,21.17,False,"No violation. The two uses of memcpy are guarded by checks that ensure pp->buffer_pos + key_len < pp->buffer_size (rejecting overflow) and the code reserves space for the terminating NUL before writing it. start_key/end_key and end_value are derived from post_data and, when set to &post_data[poff], may point to the one-past-end element only for pointer arithmetic (not dereferenced). Pointer arithmetic and memcpy lengths are computed so that reads and writes remain within the referenced objects.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,21.14,False,"No violation: the function post_process_urlencoded and the related helper functions do not call memcmp anywhere. Only memcpy, memmove, strchr, and string-length related functions are used, so there is no use of memcmp to compare null-terminated strings.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,8.13,False,"No violation: all pointers that refer to the input buffer are const-qualified (post_data, start_key, end_key, start_value, end_value, last_escape). The mutable buffer pointer (kbuf) is intentionally non-const because the function writes into it, and pp is non-const because the function modifies its fields (state, buffer_pos, must_unescape_key, etc.). Therefore the code complies with Rule 8.13.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,2.1,True,The switch contains a 'case PP_Error' label that can never be reached because the enclosing while loop condition requires (pp->state != PP_Error) to enter the loop. Thus the 'case PP_Error' branch is statically unreachable and violates MISRA C 2023 Rule 2.1 (no unreachable code).,"Agent A is correct. The loop condition explicitly requires (pp->state != PP_Error) to enter the loop, so at the point the switch(pp->state) is evaluated the value PP_Error cannot occur (barring undefined/implementation‑defined external interference). Therefore the switch label case PP_Error inside the loop is not reachable by the program logic as written and is a violation of MISRA C 2023 Rule 2.1 (unreachable code) unless a documented deviation is supplied. Note: one could argue runtime concurrency or asynchronous modification of pp->state might make that label reachable, but the code contains no synchronization/volatile semantics to rely on that; under normal static analysis the case is unreachable.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,1.2,False,"No violation: post_process_urlencoded uses only standard C constructs (pointer arithmetic, casts, standard library calls, macros and enum/struct usage). There is no direct use of compiler-specific builtins or extensions in the function body as provided. Note: the MHD_PANIC macro shown in additional code references BUILTIN_NOT_REACHED which may map to a compiler builtin (e.g. __builtin_unreachable) in its definition; that definition was not provided, so based on the supplied sources the function itself does not violate Rule 1.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/postprocessor.c,post_process_urlencoded,2.2,False,"No violation. The function contains no executed operations that could be removed without changing program behaviour. The only apparent redundant branch is the 'case PP_Error' within the switch; however the while-loop condition prohibits entering the loop with pp->state == PP_Error, so that branch is unreachable. Note 2 of MISRA C 2023 Rule 2.2 states that unreachable code is not considered dead code. No other executed statements are redundant.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,14.2,False,"No violation: send_bad_request contains no 'for' loop, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. The function performs response creation, queuing and destruction without any loop counters or loop bodies.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,17.8,False,"The function send_bad_request takes a pointer parameter 'struct MHD_Connection *con' but does not modify the pointer variable itself — it only passes 'con' to MHD_queue_response. No assignment to 'con' or other modification of the parameter occurs. (Note: the callee MHD_queue_response may modify the object pointed to by 'con', which is permitted by the rule.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,21.17,False,"No violation in the presented code. BAD_REQUEST_PAGE is defined as adjacent string literals which the compiler concatenates into a single null-terminated string literal; calling strlen(BAD_REQUEST_PAGE) reads up to that NUL and therefore does not access beyond the bounds. A concrete violation scenario would be if strlen were called on a non-null-terminated buffer (for example, a char array filled without a terminating '\0' or a pointer into a larger buffer where no NUL exists before the buffer end); in that case strlen could read past the object bounds and violate Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,21.14,False,"No violation: send_bad_request does not call memcmp nor compare null-terminated strings. It only calls strlen(BAD_REQUEST_PAGE) to obtain the size of a static constant buffer, then creates, queues and destroys an MHD_Response. Therefore MISRA C 2023 Rule 21.14 is not violated in this function or the provided supporting code snippets.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,8.13,False,"No violation. send_bad_request passes a const-qualified pointer ((const void *) BAD_REQUEST_PAGE) to MHD_create_response_from_buffer_static which accepts a const void *buffer and stores it in the response object. The provided library code does not modify the pointed-to buffer (no writes to response->data, and destruction/freeing is done via callback if present). Thus the pointer points to a const-qualified type where appropriate and there is no function that modifies the pointed object, so MISRA C 2023 Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,2.1,False,"No violation: send_bad_request contains no unreachable code. All statements (response creation, queueing, destruction and return) are reachable in normal control flow; functions it calls may return error codes, but that does not make any statement in send_bad_request unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,1.2,False,"No language extensions are used. The function uses only standard C constructs (static function, enum, cast, calls to library functions). There are no compiler-specific keywords, attributes, inline assembly, or other documented compiler extensions present in the snippet, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,send_bad_request,2.2,False,"No violation: send_bad_request contains no dead code. The sequence of operations — creating the response, queuing it, destroying the local reference and returning the result — are all required for correct resource management and protocol behaviour. MHD_queue_response increments the response reference count and installs it on the connection; MHD_destroy_response then releases the local reference. Removing any of these calls would change resource ownership, lifetime or error handling (e.g. leaking or prematurely freeing the response) and thus affect program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,14.2,False,"No violation. Each for loop in SHA1ProcessMessageBlock uses a single loop counter 'i' that is initialized in the first clause (e.g. i = 0 or i = 16), the second clause is a simple relational expression that uses only 'i' (no persistent side effects and does not reference objects modified in the loop body), and the third clause is i++ which modifies only the loop counter. The loop counter is not modified inside the loop body. All three clauses therefore conform to the requirements of MISRA C 2023 Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,17.8,False,"No violation: the function does not modify the pointer parameter 'context' itself. It only modifies the object pointed to (context->intermediate_hash[], context->message_block_index, etc.), which is allowed by Rule 17.8. (A concrete violating scenario would be an assignment to the parameter itself, e.g. 'context = NULL;' or 'context++;' inside the function.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,21.17,False,"No violation. The only uses of <string.h> functions are strlen and strncpy in ws_get_accept_value. The code checks that strlen(key) == WS_KEY_LEN before copying, so the source contains a NUL at key[WS_KEY_LEN]. The destination buffer is allocated with WS_KEY_LEN + WS_GUID_LEN + 1 bytes and the two strncpy calls copy WS_KEY_LEN+1 and WS_GUID_LEN+1 bytes respectively, which fit exactly into the allocated buffer. SHA1ProcessMessageBlock itself does not call any <string.h> functions and its indexed accesses (message_block[i*4 + ...]) are bounded (i in 0..15 => max index 63). Therefore no string.h function can access beyond the bounds of its object parameters.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,21.14,False,"No violation: the provided code does not call memcmp anywhere. String operations use strlen and strncpy, and the SHA1 message processing manipulates byte arrays directly; therefore memcmp is not used to compare null-terminated strings.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,8.13,False,"No violation: SHA1ProcessMessageBlock modifies members of the object pointed to by the parameter 'context' (it updates context->intermediate_hash[...] and context->message_block_index). Since the function writes to the pointed-to object, the pointer must not be to a const-qualified type. Therefore rule 8.13 (pointer should point to const whenever possible, and should not point to const if function modifies the object) is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,2.1,False,"No unreachable code: every statement in SHA1ProcessMessageBlock can be reached during normal operation. The four for-loops cover i ranges 0..15, 16..79, and the function body executes sequentially to update context->intermediate_hash and reset message_block_index. The function is invoked from SHA1PadMessage and SHA1Input so all paths (message block processing and padding-triggered processing) can reach the loops and final updates. There are no unconditional returns, dead branches, or code after a return that would be unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,1.2,False,"No violation: the function uses only standard C features (stdint types, arrays, macros, bitwise ops, and standard control flow). There are no compiler-specific language extensions present (no __attribute__, __builtin_*, __asm, nonstandard keywords, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,SHA1ProcessMessageBlock,2.2,False,"No violation. The SHA1ProcessMessageBlock implementation does not contain dead code: every computed value (W[], A, B, C, D, E, temp) is used in subsequent computations, the K[] constants are referenced, and the final updates to context->intermediate_hash and message_block_index affect observable program state. There are no assignments or operations whose removal would leave program behaviour unchanged.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,14.2,True,"The for loop in ws_receive_frame uses two loop counters (i and j) in the first and third clauses (for (i = idx_first_data, j = 0; i < *length; i++, j++)), violating MISRA C 2023 Rule 14.2 (there shall only be one loop counter in a for loop).","Agent A is correct. The for statement for (i = idx_first_data, j = 0; i < *length; i++, j++) violates MISRA C 2023 Rule 14.2 because it uses two loop counters. The rule requires there shall be only one loop counter in a for loop; the first clause shall initialize the loop counter and the third clause shall modify only that loop counter. Here the first clause initializes both i and j and the third clause increments both, so the loop is not well‑formed under Rule 14.2. (The second clause uses only i, but that does not make the loop compliant because multiple counters are still present.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,17.8,False,"No violation: the function does not modify any of its pointer parameters themselves (frame, length, type). It writes to the objects pointed to via *type and *length, which is permitted by the rule (the object referred to by a pointer parameter may be modified). No assignment to the pointer variables occurs.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,21.17,False,"No violation: ws_receive_frame does not call any of the <string.h> functions listed in MISRA C 2023 Rule 21.17 (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn). The function performs manual byte-wise copying using indexed accesses and XOR, so Rule 21.17 (which constrains use of the standard string functions) is not applicable. Note: there is an unrelated potential logic issue — if *length < idx_first_data then data_length will underflow and subsequent indexing of frame may access out-of-bounds — but that is not a violation of Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,21.14,False,No violation: ws_receive_frame does not call memcmp. All comparisons are byte-wise (frame[0] == ...) and it operates on raw frame bytes rather than using memcmp on null-terminated strings.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,8.13,True,"The function ws_receive_frame takes a non-const pointer unsigned char *frame but never modifies the buffer it points to (it only reads from it). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type (i.e., const unsigned char *frame) whenever possible. Therefore the current signature violates the rule.","Agent A is correct. The parameter frame is only ever read (frame[0], frame[1], indexed reads into frame used to compute masks and to unmask payload) and never written to, so per MISRA C 2023 Rule 8.13 it should be declared as pointing to a const-qualified type (e.g. const unsigned char *frame). There is no evidence in the function that the object pointed to by frame is modified, and the function does not return a pointer into that buffer that would prevent qualification. Changing the signature to const unsigned char *frame is the appropriate fix (call sites would need to accept the const qualification or cast when necessary).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,2.1,False,No reachable-unreachable code scenario: all control paths in ws_receive_frame are reachable. The function first handles the text-frame case (frame[0] == WS_FIN | WS_OPCODE_TEXT_FRAME) with nested branches for extended payload lengths (flength == 126 or 127) and the default (other flength values). The other top-level branches (close frame and default opcode extraction) are reachable when frame[0] matches those conditions. There is no code that can never be executed given the control-flow and input-dependent conditions.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,1.2,False,"No language extensions used. The function uses standard C types and library functions (unsigned char, size_t, ssize_t, malloc) and standard control flow; there are no compiler-specific keywords, attributes, inline assembly, or other documented compiler extensions present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_receive_frame,2.2,True,"When a connection-close WebSocket frame is received, ws_receive_frame sets *type = WS_OPCODE_CON_CLOSE_FRAME and returns msg == NULL. In the caller (run_usock) the very next statement checks if (NULL == msg) and breaks out of the receive loop, so the value written to *type is never observed or used. The assignment to *type in the close-frame branch is therefore an executed operation whose removal would not change behaviour of the current program — i.e. dead code under MISRA C 2023 Rule 2.2.","MISRA C:2023 Rule 2.2 forbids dead code: an operation that is executed but whose removal would not affect program behaviour anywhere in the project. The agent’s claim is plausible as a local scenario (if every caller checks for NULL msg and returns/ignores *type when msg==NULL, then writing *type in the close-frame case has no observable effect and could be dead). However, whether that assignment is actually dead is a whole‑project property that cannot be established from the single function alone. The assignment writes to caller-supplied storage (int *type) and could be observed by some caller or by later code, could affect aliased or memory-mapped data in unusual build configurations, or be relied on by other call sites. Also the provided test (instrumented code) did not produce evidence (it failed to compile), so there is no demonstrated proof that removal would not change behaviour. Therefore the report as stated is not provably correct: you need a project-wide analysis (all call sites of ws_receive_frame and the uses of *type) to conclude a Rule 2.2 violation. In short: the claim is plausible but not established from the supplied information, so the report is not correct as presented.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,14.2,False,"The function ws_get_accept_value contains no for loop constructs. Therefore MISRA C 2023 Rule 14.2 (requirements on for-loop well-formedness) is not applicable to this function. Note: other functions shown in the additional code (e.g. SHA1ProcessMessageBlock, SHA1Result, BASE64Encode) do contain for loops and would need separate review against Rule 14.2, but the ws_get_accept_value function itself does not violate Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,17.8,False,No violation: ws_get_accept_value does not modify the pointer parameters themselves. It assigns to *val via the call to BASE64Encode(val) and then writes into the allocated buffer (*val)[len] = '\0'; modifying the object pointed to by val is permitted by Rule 17.8; the parameter val (the pointer variable) is never reassigned. The key parameter is const and not modified. Therefore the rule is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,21.17,False,"No violation. The function checks strlen(key) == WS_KEY_LEN, so key is NUL-terminated at index WS_KEY_LEN. It allocates WS_KEY_LEN + WS_GUID_LEN + 1 bytes. The first strncpy copies WS_KEY_LEN + 1 bytes (WS_KEY_LEN characters plus the terminating NUL) into the buffer start; the second strncpy copies WS_GUID_LEN + 1 bytes (GUID plus its NUL) into str + WS_KEY_LEN. Both copies fit exactly into the allocated buffer and do not write beyond bounds. SHA1Input is called with WS_KEY_GUID_LEN (WS_KEY_LEN + WS_GUID_LEN), i.e. the concatenated bytes without the trailing NUL, which is also within bounds. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,21.14,False,"No use of memcmp in ws_get_accept_value; the function computes SHA1 and base64-encodes the result using strlen/strncpy/malloc and SHA1 functions. There is no memcmp call comparing null-terminated strings, so Rule 21.14 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,8.13,False,"No violation: the function correctly declares 'key' as 'const char *' since it is only read, and declares 'char **val' (non-const) because the function (via BASE64Encode and by assigning/terminating (*val)[len]) modifies the object pointed to by 'val' (it produces and writes into the returned buffer). Rule 8.13 allows non-const pointers when the pointed-to object is modified; changing 'val' to point-to-const would be incorrect here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,2.1,False,"No violation. All control paths in ws_get_accept_value are reachable: initial parameter check returns on NULL/length mismatch; malloc failure returns; SHA1Result failure frees allocated buffer and returns; on success the buffer is freed and execution continues to BASE64Encode; if BASE64Encode fails the function returns, otherwise it writes the terminator and returns success. There is no code that can never be executed (no dead/unreachable statements).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,1.2,False,"No violation: the function uses only standard C constructs and standard library / common POSIX types. There are no compiler-specific extensions (no inline assembly, attributes, typeof, statement-expressions, GCC/Clang __builtin or __attribute__ usage, or other documented compiler extensions). ssize_t is a POSIX type, not a compiler language extension, so it does not constitute a Rule 1.2 violation.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ws_get_accept_value,2.2,False,"No applicable dead-code scenario found. Every executed operation in ws_get_accept_value contributes to the produced accept value or to resource management (allocation/free, hashing steps, base64 encoding and null-termination). Removing any of these operations would change observable behaviour (memory usage, returned result or correctness).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,14.2,False,"The for loop for (i = 0; i < MAX_CLIENTS; i++) is well-formed: the first clause (i = 0) initializes the single loop counter, the second clause (i < MAX_CLIENTS) is a side-effect-free expression using only the loop counter and a constant, and the third clause (i++) modifies only the loop counter. The loop body does modify CLIENT_SOCKS[i], but that object is not used in any of the for clauses. Hence Rule 14.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,17.8,False,"No violation: the function parameter 'cls' (void *cls) is not modified. The code assigns the parameter to a local pointer variable (struct WsData *ws = cls) and manipulates or frees the object pointed to by that pointer, which is allowed by the rule. At no point is the pointer parameter value (cls) itself reassigned or modified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,21.17,False,"No violation. The code uses snprintf(NULL, 0) to compute buf_size, then allocates text as buf_size + 1 and calls snprintf(text, buf_size + 1, ...) so the destination buffer is large enough to hold the formatted string and the terminating NUL. The source msg is produced by ws_receive_frame which explicitly NUL-terminates the message (msg[j] = '\0') and sets *length accordingly, so using ""%s"" with snprintf cannot read beyond the msg buffer. ws_send_frame copies exactly the number of bytes given by the length parameter (buf_size) and the text buffer was allocated with buf_size + 1, so the copy does not access out of bounds. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,21.14,False,"No violation: the provided run_usock function and its related helper functions do not call memcmp. All string handling uses snprintf, direct memory copies/xor in ws_receive_frame, and ws_send_frame builds response buffers; there is no use of memcmp to compare null-terminated strings anywhere in the shown code, so MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,8.13,False,"No violation: run_usock receives a void *cls which is converted to struct WsData *ws and ws is later freed and its fields are accessed/modified (e.g. checking and clearing CLIENT_SOCKS entry, calling free(ws)). Because the function modifies/frees the object pointed to, the pointer must not be const-qualified. Similarly, msg (returned by ws_receive_frame) is freed by this function, so it must be a non-const pointer. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,2.1,False,"No violation: all branches and statements in run_usock are reachable given plausible runtime inputs. The while(1) loop can exit via the recv() <= 0 condition, ws_receive_frame returning NULL, or by break when sent == -1 or on receiving a close frame; the post-loop cleanup (mutex lock, client removal, free(ws), MHD_upgrade_action) is reachable after these breaks. There are no syntactically or semantically unreachable statements in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,1.2,False,"No language/compiler-specific extensions are used in run_usock. The code uses standard C constructs, POSIX types/APIs (ssize_t, pthreads, recv/send), and library functions; there are no compiler-specific keywords or __attribute__/__declspec, inline assembly, or other documented compiler extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,run_usock,2.2,False,"No specific violation: run_usock contains no dead code. All executed operations influence program behavior (message parsing/sending, resource cleanup and client table update). There is no operation whose removal would not affect behavior.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,14.2,False,"The function contains no for loop constructs; Rule 14.2 applies to for statements. Since is_websocket_request has no for statement, there is no possibility of an ill-formed for loop in this function, so the rule is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,17.8,False,"No violation: none of the function parameters are modified. The function only (a) casts the unused pointer parameter 'con' to void to suppress a compiler warning, and (b) performs read-only operations (comparisons and calls to strcmp and strstr) using the pointer parameters 'upg_header' and 'con_header'. No assignment to any parameter identifier occurs and no pointer parameter itself is overwritten, so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,21.17,False,"No violation. Both upg_header and con_header are checked for NULL before use, and they originate from MHD_lookup_connection_value/MHD_lookup_connection_value_n which provide C NUL-terminated strings (pos->value). Therefore calling strcmp(upg_header, WS_UPGRADE_VALUE) and strstr(con_header, ""Upgrade"") does not access beyond the bounds of the objects.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,21.14,False,"No violation in the provided code. The function uses strcmp to compare null-terminated strings, not memcmp. A specific violation scenario would be replacing the strcmp call with memcmp, for example: if ((upg_header != NULL) && (con_header != NULL) && (0 == memcmp(upg_header, WS_UPGRADE_VALUE, strlen(WS_UPGRADE_VALUE))) && (NULL != strstr(con_header, ""Upgrade""))) ... — that use of memcmp to compare null-terminated strings would violate MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,8.13,True,"The parameter 'con' is declared as struct MHD_Connection *con even though the function does not inspect or modify the object pointed to. According to MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible, so 'con' could be declared const (e.g. const struct MHD_Connection *con). This missing const qualification is a violation unless the function signature is mandated by an external API requiring a non-const pointer.","MISRA C 2023 Rule 8.13 requires a pointer to point to a const-qualified type whenever possible. In the shown code the parameter con is not inspected or modified (original code even casts it away with (void) con), so it could be declared as const struct MHD_Connection *con. Therefore, absent an overriding requirement, the non-const declaration is contrary to the rule. The only valid justification for keeping it non-const would be that the function prototype must match an external API or callback type that requires a non-const pointer; the agent explicitly noted that caveat. (The provided test harness failed to compile because of missing/unspecified MHD types/macros, but that does not affect the applicability of the rule.) Given the above, the agent’s report is correct: this is a violation of Rule 8.13 unless the signature is mandated by an external API.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,2.1,False,No unreachable code. The function evaluates its inputs and returns either MHD_YES or MHD_NO based on runtime conditions; there are no statements that cannot be reached (the cast (void)con only suppresses an unused-parameter warning and is not unreachable code).,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,1.2,False,"No language extensions are used. The function uses standard C constructs: static function linkage, cast-to-void to suppress unused-parameter warnings, the conditional (?:) operator, and standard library functions strcmp and strstr. The WS_UPGRADE_VALUE macro and the enum definitions are standard C preprocessor and enum usage, not compiler-specific extensions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,is_websocket_request,2.2,True,The cast-to-void statement '(void) con;' inside is_websocket_request is an executed no-op whose removal would not affect program behaviour. That statement is therefore dead code (an operation executed but having no effect) and violates MISRA C 2023 Rule 2.2.,"Agent A's report is not correct. The statement (void) con; is an idiomatic way to indicate an unused parameter and to suppress a compiler warning. Although the cast-to-void expression has no observable runtime effect (and thus, taken strictly by the bare wording, could be seen as having no effect if removed), MISRA's intent for Rule 2.2 is to prohibit genuinely redundant/unused code that should be removed because it serves no purpose and may hide faults. The (void) parameter-cast is a deliberate, documented no-op to convey intent and to suppress spurious diagnostics; this is a recognized and accepted idiom and not a problematic piece of dead code in practice. Therefore the claim that this specific statement constitutes a Rule 2.2 violation is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,14.2,True,BASE64Encode contains a for loop where the loop counter 'i' is modified inside the loop body (multiple ++i and ++i in branches). This violates MISRA C 2023 Rule 14.2: the loop counter shall not be modified in the loop body and the third clause shall only modify the loop counter.,"The report is correct. MISRA C 2023 Rule 14.2 requires that a for loop have a single loop counter that is initialized in the first clause, is the only object modified by the third clause, and is not modified in the body of the loop. In the provided BASE64Encode implementation the loop is declared as for (i = 0; i < len; ++i) but the body contains multiple modifications of the same loop counter (if (++i < len) { ... }, if (++i < len) { ... }, and ++i in the else). Those in-body increments modify the loop counter and therefore violate Rule 14.2 (clauses 3 and 4). Note: the original ahc_cb snippet shown earlier did not include BASE64Encode, but in the supplied test code the BASE64Encode function is present and exhibits the violation; if that function is part of the codebase the reported violation is valid.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,17.8,False,"No violation — the function only modifies the object pointed to by the pointer parameter req_cls (assigning to *req_cls), not the pointer parameter req_cls itself. Other parameters are unused or only read. This complies with MISRA C 2023 Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,21.17,True,"Violation occurs in ws_get_accept_value: the function uses strlen(key) and then calls strncpy(str, key, WS_KEY_LEN + 1). If the header value (key) is not NUL-terminated (pos->value is returned with value_size == WS_KEY_LEN), strlen(key) will read past the buffer and strncpy will copy WS_KEY_LEN+1 bytes, causing a one-byte out-of-bounds read. Thus use of string.h functions can access beyond object bounds.","The report is correct. The code calls MHD_lookup_connection_value_n to obtain ws_key_header together with an explicit length (key_size) and then calls ws_get_accept_value(ws_key_header, &ws_ac_value) without providing the length. If ws_get_accept_value uses string.h functions such as strlen(key) and strncpy(..., WS_KEY_LEN + 1) as described, those calls can read past the non-NUL-terminated header buffer (strlen will scan past the buffer looking for '\0', and strncpy copying WS_KEY_LEN+1 bytes will read one byte past a length-only buffer of WS_KEY_LEN). That is exactly the sort of out-of-bounds access forbidden by MISRA C 2023 Rule 21.17. Note: the small number of other uses of string functions in ahc_cb (e.g. strlen on the constant header name, strcmp on method/version) are safe; the problematic path arises from treating a length-delimited header value as a NUL-terminated C string. To fix: ensure the header value is copied into a local buffer that is NUL-terminated (using memcpy and explicitly setting the terminator) or change ws_get_accept_value to accept a pointer+length and avoid strlen/strncpy on non-terminated data.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,21.14,True,"The violation occurs in add_response_header_connection where memcmp is used to compare an HTTP header value to the literal ""close"": mhd_assert (already_has_close == (0 == memcmp (hdr->value, ""close"", 5))); hdr->value is a null-terminated header string. Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.","MISRA C:2023 Rule 21.14 forbids using memcmp to compare null‑terminated strings (you must use the string comparison functions instead). The ahc_cb implementation you provided does not call memcmp: it uses strcmp and library calls such as MHD_add_response_header / MHD_lookup_connection_value. The agent A’s scenario alleges a memcmp in add_response_header_connection (mhd_assert (already_has_close == (0 == memcmp (hdr->value, ""close"", 5)));). That snippet is not present in the ahc_cb source you gave, so ahc_cb itself does not violate Rule 21.14.

If the asserted memcmp actually exists inside the Microhttpd library (in add_response_header_connection) and it compares a null‑terminated header string to a literal via memcmp, then that library code would indeed violate MISRA C 2023 Rule 21.14. However, based on the supplied ahc_cb code and the failing test build (no evidence produced), there is no proof in the materials you provided that ahc_cb violates the rule. Therefore the report that ahc_cb itself violates Rule 21.14 is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,8.13,False,"No violation: ahc_cb and the called functions properly use const qualifiers. Header values returned by MHD_lookup_connection_value(_n) are const char * and are not modified; ws_get_accept_value, which does allocate and modify the returned buffer, uses a char ** parameter and returns a non-const char * (ws_ac_value) which is then passed to functions accepting const char * when no modification is performed. The void **req_cls parameter is used to modify the pointer stored by the caller, so it must not be const. All pointer uses conform to the rule: pointers that point to objects that will be modified are non-const, and pointers that point to objects that are only read are const-qualified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,2.1,False,"No violation: all statements in ahc_cb are reachable depending on input and connection state. The initial *req_cls check returns early for the first request and the remaining path is executed on subsequent calls. Each conditional (is_websocket_request, method/version checks, header presence/values, ws_get_accept_value, and MHD_add_response_header failures) can be true or false depending on run-time inputs, so there is no statically unreachable code in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,1.2,False,"No violation: the function ahc_cb and referenced code do not use any compiler-specific language extensions (no GCC/Clang attributes, nested functions, inline assembly, typeof, statement-expressions, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/websocket_threaded_example.c,ahc_cb,2.2,False,"No dead code present. Every executed operation in ahc_cb either affects control flow (returns, assignments to *req_cls), performs necessary checks and side-effects (header lookups, calls to send_* helpers, response creation/queuing, memory allocation/free), or suppresses unused-parameter warnings. Removing any of these operations would change program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,14.2,False,"MHD_select contains no for loop constructs, so MISRA C:2023 Rule 14.2 (A for loop shall be well-formed) is not applicable to this function. (Note: helper functions in the additional code, such as internal_get_fdset2 and internal_run_from_select, do contain for loops and should be reviewed separately if desired.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,17.8,True,"The function modifies its non-pointer parameter 'millisec' (assigned 0 in multiple places). Specifically, millisec is reassigned in the branch that handles suspend/resume and again when err_state is set. This is a direct violation of MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).",Agent A is correct. The function parameter millisec (type int32_t) is assigned to within MHD_select (e.g. millisec = 0 in the branch handling suspend/resume and again after err_state is set). MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; these assignments modify a non-pointer parameter and therefore violate the rule. (A simple remediation is to copy the parameter to a local variable and modify that local variable instead.),NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,21.17,False,"No violation: MHD_select and the referenced helper functions do not call string-handling functions in a way that can write beyond object bounds. The only <string.h> function usage in the provided code is memset(&addrstorage, 0, (size_t)addrlen) in MHD_accept_connection, and addrlen is explicitly initialized to sizeof(addrstorage) immediately before the memset, so the write is bounded. Other uses (e.g. strerror) do not write into caller buffers. No calls to memcpy/memmove/strcpy/strncpy/strcat/strncat/strlen/strspn with unbounded lengths are present, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,21.14,False,"No occurrence of memcmp comparing null-terminated strings in MHD_select or any referenced functions. The code uses select, FD_SET operations and strerror/errno; there is no use of memcmp for string comparison, so the specific violation scenario does not apply.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,8.13,False,"No violation. The fd_set objects (rs, ws, es) are non-const when passed to functions that modify them (internal_get_fdset2 and select), and are passed as const fd_set * to internal_run_from_select which does not modify the sets. internal_get_fdset2 and MHD_add_to_fd_set_ require non-const pointers because they modify the fd_sets; internal_run_from_select correctly declares its parameters as const fd_set * so the pointer is const-qualified wherever possible. Therefore Rule 8.13 is not violated in MHD_select.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,2.1,False,"No reachable unreachable-code path found in MHD_select: all branches and returns can be exercised depending on daemon state, options, and runtime results (daemon->shutdown, MHD_D_IS_USING_THREAD_PER_CONN_, internal_get_fdset2 result, itc/listen socket presence, millisec value, MHD_get_timeout64 return, select() result and errno). The only code excluded by preprocessor conditionals is not present in the translation unit and therefore not a MISRA 2.1 unreachable-code violation within the built configuration.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,1.2,False,"No violation: the MHD_select implementation uses standard C (C99) constructs only — stdint types, bool, standard library calls, macros and conditional compilation — and does not use compiler-specific extensions such as __attribute__, __builtin_*, typeof, asm, or MSVC-specific keywords. No explicit compiler extensions are present in the supplied code or the referenced symbols.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_select,2.2,True,"The initial assignments to timeout.tv_sec = 0 and timeout.tv_usec = 0 at the start of MHD_select are executed unconditionally but are either overwritten later (when tv is set to &timeout) or never used (when tv is set to NULL). Removing those initial assignments would not change program behaviour, so they constitute dead code under MISRA C 2023 Rule 2.2.","The initial two assignments timeout.tv_sec = 0; timeout.tv_usec = 0; are executed unconditionally but have no observable effect on program behaviour in the original function. In every path where the timeval is actually used by select (i.e. when tv is set to &timeout) the code later reassigns both timeout.tv_sec and timeout.tv_usec before the select call; in the paths where tv is set to NULL the timeout object is never read. No other function called in the interim reads timeout. Therefore removing those two assignments would not change the program behaviour, which matches the definition of dead code in MISRA C 2023 Rule 2.2. (Note: initialization at declaration would not be considered the same as these later assignment operations, per the rule’s note, and the test harness added by agent A is unnecessary to reach this conclusion.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,14.2,False,No violation: the only for loop in MHD_start_daemon_va is for (i = 0; i < daemon->worker_pool_size; ++i). Clause 1 sets the loop counter (i = 0). Clause 2 uses the loop counter and daemon->worker_pool_size and has no persistent side effects; daemon->worker_pool_size is not modified within the loop body. Clause 3 modifies only the loop counter (++i). There is a single loop counter (i) and it is not modified inside the loop body. Therefore the for loop is well-formed per Rule 14.2.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,17.8,False,"No violation: MHD_start_daemon_va does not modify any of its formal parameters. The incoming 'flags' and 'port' parameters are read but not assigned to; flags is copied into a local variable 'eflags' and modifications are applied to that local copy (via 'pflags'). Pointer parameters (apc_cls, dh_cls) and function-pointer parameters are never reassigned. The va_list 'ap' is forwarded to parse_options_va (by value) and not modified in this function. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,21.17,True,"When DAUTH support is enabled and the MHD_OPTION_DIGEST_AUTH_RANDOM_COPY option is used, parse_options_va stores the user-supplied pointer (daemon->digest_auth_random) and a size (daemon->digest_auth_rand_size), then MHD_start_daemon_va later allocates daemon->digest_auth_random_copy and calls memcpy(daemon->digest_auth_random_copy, daemon->digest_auth_random, daemon->digest_auth_rand_size) without validating that daemon->digest_auth_random is non-NULL or that it points to at least daemon->digest_auth_rand_size bytes. If the caller provides a NULL pointer or a pointer to a smaller buffer than the declared size, the memcpy will read out-of-bounds (or dereference NULL), violating Rule 21.17.","Agent A's report is correct. In the DAUTH_SUPPORT block MHD_start_daemon_va checks only daemon->digest_auth_random_copy (used as a marker) before allocating and calling memcpy, but it does not validate daemon->digest_auth_random or that digest_auth_rand_size is consistent with the actual buffer. The code does: daemon->digest_auth_random_copy = malloc(...); memcpy(daemon->digest_auth_random_copy, daemon->digest_auth_random, daemon->digest_auth_rand_size); If the caller supplied a NULL source pointer or a pointer to a smaller buffer than digest_auth_rand_size, memcpy would read out-of-bounds (or dereference NULL), which violates MISRA C 2023 Rule 21.17. The reported violation is therefore correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,21.14,False,"No violation: the provided MHD_start_daemon_va function and the related helper functions contain no usage of the Standard Library function memcmp for comparing null-terminated strings. The code uses memcpy, strlen and other APIs but does not call memcmp to compare C strings, so MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,8.13,False,"No violation: pointers to const (e.g. pservaddr / params->pserver_addr) are only used for read-only operations (memcpy, bind, getsockname). Pointers that are modified (e.g. pflags) are non-const. Where casts remove const to call third-party APIs, the code explicitly drops const (e.g. _MHD_DROP_CONST) rather than keeping a const-qualified pointer for a callee that expects a modifiable pointer. Therefore Rule 8.13 is not violated in MHD_start_daemon_va.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,2.1,False,"No reachable violation. The code contains a return before the thread_failed and free_and_fail labels, but the thread_failed label (and the gotos targeting it) are both enclosed in the same conditional compilation region (#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)). When those macros are defined, the goto statements that jump to thread_failed and the label itself are compiled together, so the label is reachable via those gotos. When those macros are not defined, the label and gotos are absent. Therefore there is no unreachable code in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,1.2,True,"The project uses GNU C extensions: the _MHD_EXTERN macro expands to __attribute__((visibility(""default""))) which is a GCC/Clang attribute (a compiler language extension). This is an explicit use of a compiler extension and thus violates MISRA C 2023 Rule 1.2.","Not enough evidence to confirm the reported violation. The mere appearance of the identifier _MHD_EXTERN at the start of the function does not by itself violate MISRA Rule 1.2 — the rule is concerned with the use of compiler language extensions (for example GCC/Clang __attribute__((...))). Agent A’s claim depends on the definition of the macro _MHD_EXTERN. If in the project _MHD_EXTERN is defined to expand to a GNU/Clang attribute such as __attribute__((visibility(""default""))), that is an explicit use of a compiler extension and would be a Rule 1.2 violation. However, the provided code snippet does not include the macro definition, and the supplied test code does not demonstrate the macro expanding to an extension (and did not compile), so the violation cannot be confirmed from the material given. To decide definitively: inspect the header that defines _MHD_EXTERN (and any platform-specific config headers or build flags). If it expands to a compiler-specific attribute documented as an extension (e.g. __attribute__), then the report is correct; if it expands to a standard C token (e.g. extern) or to nothing on some compilers, then there is no Rule 1.2 violation in this translation unit. Recommendation: locate and show the definition of _MHD_EXTERN (and any conditional definitions) and the compiler documentation showing the attribute is an extension to produce a conclusive finding.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_start_daemon_va,2.2,False,"No executed operations in MHD_start_daemon_va constitute dead code. The function contains conditional compilation and many guarded branches that are executed only when required; all executed operations contribute to observable behaviour (resource allocation, flag manipulation, socket operations, initialization and cleanup). No operation was found that is executed but could be removed without changing program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,14.2,False,"The function MHD_ip_count_unlock contains no for-loop constructs. MISRA C:2023 Rule 14.2 applies to the structure of for statements; because there are no for statements in this function (only an assertion and a conditional call to MHD_mutex_unlock_chk_), the rule is not applicable to this code and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,17.8,False,"No violation in the provided function. The function only reads members of the pointer parameter (daemon->master, &daemon->per_ip_connection_mutex) and uses (void) daemon to silence unused-parameter warnings. It does not assign to or otherwise modify the pointer parameter itself. A specific violation scenario (not present here) would be if the function assigned to the parameter, e.g. ""daemon = NULL;"" or ""daemon++"", which would modify the pointer variable and violate MISRA C 2023 Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,21.17,False,"No violation: MHD_ip_count_unlock does not call any <string.h> functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn). It only performs an assertion and a mutex-unlock call, so there is no risk of accesses beyond object bounds via string handling functions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,21.14,False,No violation in the provided function. MHD_ip_count_unlock does not call memcmp or any string-comparison routine; it only asserts master is NULL and conditionally unlocks a mutex. A specific violation scenario (hypothetical): if the function used memcmp to compare a null-terminated daemon string (for example comparing daemon->https_key_password to a literal using memcmp) that would violate MISRA C 2023 Rule 21.14 (memcmp must not be used to compare null-terminated strings).,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,8.13,False,"No violation. The function MHD_ip_count_unlock takes a non-const pointer (struct MHD_Daemon *daemon) and calls MHD_mutex_unlock_chk_(&daemon->per_ip_connection_mutex), which modifies the mutex member of the pointed-to object (it unlocks the mutex). Because the function modifies state through the pointer, the pointer must not be const-qualified; therefore Rule 8.13 (prefer const when possible, and not const when the object is modified) is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,2.1,False,"No violation. The function uses conditional compilation to include either the mutex-unlock call or a (void) daemon; with MHD_USE_POSIX_THREADS defined (as in the provided additional code) the unlock call is compiled in and reachable. If neither threading macro is defined the alternative (void) daemon; branch is compiled in instead. mhd_assert expands to a no-op, so it does not make any subsequent code unreachable. Therefore there is no unreachable code in this function under any compilation configuration.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,1.2,False,"No violation: the function uses only standard C constructs (static, void, preprocessor conditionals, macro calls and a cast-to-void to silence unused parameter). There are no compiler-specific language extensions (for example no __attribute__, __asm__, typeof, statement expressions, or other documented compiler extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_unlock,2.2,False,"MHD_ip_count_unlock does not violate Rule 2.2. With MHD_USE_POSIX_THREADS defined (as in the provided additional code) the function executes MHD_mutex_unlock_chk_(&daemon->per_ip_connection_mutex), which performs a real mutex unlock and thus its removal would change program behaviour in multithreaded builds. The mhd_assert macro expands to ((void)0) (a compile-time no-op) and therefore is not executed; the (void)daemon; branch is guarded by the #else and is not present in the compiled multithreaded build. No executed operation in this function is removable without affecting behaviour, so it is not dead code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,14.2,False,MHD_accept_connection contains no for statements (no loop counters or for clauses to analyze). Rule 14.2 is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,17.8,False,"No violation — the function parameter 'daemon' (a pointer) is never assigned to or modified. Only the object pointed to by 'daemon' (daemon->...) is read or its members are updated, which is permitted by Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,21.17,False,"No violation. The only C standard library string function used is memset(&addrstorage, 0, (size_t) addrlen) with addrlen initialised to (socklen_t) sizeof(addrstorage) immediately before the call. The code ensures addrlen represents the size of the 'addrstorage' object and later checks that any value returned by accept() does not exceed sizeof(addrstorage) before using it. Therefore memset cannot access beyond the bounds of addrstorage and no other <string.h> functions are used that could overflow buffers.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,21.14,False,No violation: the function MHD_accept_connection and the related code do not call memcmp to compare null-terminated strings (no use of memcmp is present). The code uses memcpy for copying binary sockaddr_storage data and uses strerror/errno for error messages. Therefore Rule 21.14 (memcmp shall not be used to compare null terminated strings) is not applicable here.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,8.13,False,"No violation: pointers in MHD_accept_connection that reference local objects are passed to functions that are expected to modify them (accept/accept4 receive struct sockaddr * and socklen_t * and update the address and length; daemon is non-const because the function may update daemon->at_limit and reads/writes other members). No pointer could be made const without changing semantics, and no pointer to const is used where the callee modifies the pointee.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,2.1,False,"No violation. The potentially redundant branches are resolved by preprocessor conditionals (e.g. USE_ACCEPT4) so the compiled function contains only reachable code paths; runtime decisions (accept4 vs accept failure handling, socket error handling, and subsequent returns) are all reachable depending on system state. There is no code in the compiled translation unit that cannot be executed at runtime.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,1.2,False,"No compiler language extensions are used. The code uses standard C constructs, conditional compilation macros, and platform/library APIs (e.g. accept4(), fcntl(), ioctlsocket()) but no compiler-specific extensions such as __attribute__, __asm__, typeof, statement-expressions, nested functions, labels-as-values, or other constructs documented as compiler extensions. Conditional use of platform/system APIs is not a language extension.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_accept_connection,2.2,False,"No violation: I found no dead code in MHD_accept_connection. All assignments and operations either influence subsequent control flow, call functions with potential side-effects (e.g. socket operations, logging) or pass state into internal_add_connection. Conditional assignments that might be redundant in some runs (e.g. setting sk_nonbl = true in the else branch) are necessary in other runs and/or reflect observable state passed on to later logic, so their removal could change behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,14.2,False,"No violation: The for loops in MHD_stop_daemon are well-formed. Each for uses a single loop counter (i) initialized in the first clause (i = 0), the second clause uses daemon->worker_pool_size which is not modified by the loop body in the relevant master/worker usage, and the third clause only modifies the loop counter (++i). The body does call functions, but those calls do not modify daemon->worker_pool_size (worker elements have a non-NULL master so they do not free or change the master's worker_pool_size). Therefore all three clauses meet the requirements of MISRA C 2023 Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,17.8,False,"No violation. The function modifies members of the object pointed to by the parameter (e.g. daemon->shutdown, daemon->worker_pool[i].shutdown), which is allowed. The pointer parameter 'daemon' itself is never assigned to or otherwise modified (no statements like `daemon = ...`), only dereferenced and passed by address to recursive calls. free(daemon) deallocates the pointee but does not modify the pointer variable. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,21.17,False,"No use of string.h functions in MHD_stop_daemon or related code paths shown. The function and the helper routines only call socket, thread, memory free, and TLS/epoll APIs; there are no calls to memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn (or other <string.h> functions) in the provided code, so there is no opportunity for out-of-bounds access via those functions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,21.14,False,No violation: the function MHD_stop_daemon and the provided related code do not call memcmp to compare null-terminated strings (no calls to memcmp are present).,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,8.13,False,"No violation: MHD_stop_daemon takes a non-const pointer (struct MHD_Daemon *daemon) and modifies the pointee (e.g. daemon->shutdown = true; sets worker_pool[i].shutdown; frees daemon; destroys mutexes, closes sockets, etc.). Because the function intentionally modifies the object pointed to, the pointer must not be const; this conforms to MISRA C 2023 Rule 8.13.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,2.1,False,"No specific unreachable-code scenario found. The function contains conditional compilation and runtime assertions but no statically unreachable statements; all branches are reachable depending on build-time options and runtime state, and assert(false) is reachable only if an unexpected runtime condition occurs (so it is not statically unreachable).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,1.2,False,"No use of compiler-specific language extensions in MHD_stop_daemon. The function uses standard C constructs (conditionals, standard types like bool, macros and preprocessor line continuations). Any potentially compiler-specific builtins (e.g. BUILTIN_NOT_REACHED) appear only in macro definitions outside this function and are not directly present in MHD_stop_daemon.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_stop_daemon,2.2,False,"No dead code found. Every executed operation in MHD_stop_daemon affects program behaviour (e.g. setting daemon->shutdown, signalling worker threads via ITC or shutdown(fd), joining threads, closing sockets, freeing resources). Assertions and diagnostic checks are intended for diagnostics and do not constitute dead code in the sense of Rule 2.2. There is no executed operation whose removal would not affect the program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,14.2,False,No 'for' loops are present in MHD_poll_listen_socket; therefore Rule 14.2 (well-formed for loops) cannot be violated by this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,17.8,False,"No violation: the function does not assign to either parameter. The pointer parameter 'daemon' is only dereferenced to modify the object it points to (allowed); the integer parameter 'may_block' is only read, not modified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,21.17,False,"No violation in the provided code. The only C library string function used is memset(&p, 0, sizeof(p)); sizeof(p) correctly equals the total size of the array p (two struct pollfd elements), and subsequent indexed writes to p are guarded by poll_count which can be incremented at most twice in the shown logic. A concrete violation scenario (hypothetical): if p were smaller than the number of times poll_count could be incremented (e.g. p had size 1 but code could increment poll_count twice), then writes to p[poll_count] would access beyond bounds and memset/memory writes could overrun the object.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,21.14,False,No violation: MHD_poll_listen_socket (and the closely related functions shown) do not call memcmp or use memcmp to compare null-terminated strings. The function performs socket/poll/accept operations and inter-thread signaling; no string comparisons via memcmp are present.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,8.13,False,"No violation: the function parameter 'struct MHD_Daemon *daemon' must be non-const because MHD_poll_listen_socket (and the functions it calls) modify the daemon state (e.g. resume_suspended_connections modifies daemon->resuming and lists, new_connections_list_process_ clears daemon->have_new and mutates connection lists, MHD_accept_connection and internal_add_connection update daemon connection state, MHD_itc_clear_ reads/updates inter-thread channel state). Therefore the pointer correctly points to a non-const type and Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,2.1,False,"No violation: all statements in MHD_poll_listen_socket are reachable depending on runtime conditions. The function contains only conditional branches and early returns that are based on runtime data (daemon->listen_fd, daemon->itc, daemon->options, may_block, poll results, errno, daemon->shutdown, daemon->have_new, poll revents). There are no constant-false conditionals, no code after an unconditional return, and no constructs that make any portion of the function permanently unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,1.2,False,"No language extensions are used. The function and referenced macros expand to standard C library calls and constructs only (poll, read, accept, strerror, errno, standard control structures, macros, and typedefs/enum). There are no compiler-specific extensions present such as __attribute__, __asm__, typeof (statement expressions), nested functions, __extension__, __builtin_* intrinsics, or other non-standard keywords. The macros shown (e.g. MHD_sys_poll_ -> poll, MHD_itc_clear_ calling read) rely on standard POSIX/C APIs and standard preprocessor macros; therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_poll_listen_socket,2.2,True,"The assignments p[poll_count].revents = 0 (in both places where a pollfd slot is prepared) are dead code. The p array is zeroed by the initial memset(&p, 0, sizeof(p)); therefore explicitly setting revents to 0 immediately afterwards is an operation that is executed but whose removal would not affect program behaviour (the field is already zero). Removing those statements would not change the function's behaviour, so Rule 2.2 is violated.","The two assignments p[poll_count].revents = 0 are redundant given the unconditional memset(&p, 0, sizeof(p)) performed earlier. They are executed in normal control flow and removing them would not change observable behaviour of the function (the revents fields are already zero). Under MISRA C 2023 Rule 2.2 (an executed operation whose removal would not affect program behaviour is dead code) these statements qualify as dead code.

Caveats: a definitive determination of a Rule 2.2 violation is a project‑level judgment, but for the provided function the assignments are redundant. Only if some external, atypical effects applied (for example p being volatile or memory‑mapped, or the prior memset being removed by other project code) would the conclusion change. Otherwise the agent A report is correct — these assignments are dead code and should be removed or formally justified/deviated from per the project’s MISRA process.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,14.2,False,"No violation: MHD_ip_count_lock contains no for loop; MISRA C 2023 Rule 14.2 applies only to for statements, so it is not applicable here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,17.8,False,"No violation: the function does not modify the parameter 'daemon' itself. It only reads daemon->master, takes the address of a member (&daemon->per_ip_connection_mutex) and passes it to MHD_mutex_lock_chk_. The pointer variable 'daemon' is never reassigned or altered; in the non-thread case it is cast to void to avoid an unused-parameter warning. All of these actions comply with Rule 17.8 (modifying the pointed-to object is allowed, but the pointer variable is not modified).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,21.17,False,"No violation. The function MHD_ip_count_lock does not call any functions from <string.h> nor perform any string/buffer copies; it only asserts and locks a mutex. A concrete violation scenario (hypothetical) would be if the function (or a called helper) used a string function unsafely, e.g. strcpy(buf, daemon->ip) where buf is smaller than daemon->ip resulting in access beyond the bounds of buf.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,21.14,False,No violation: MHD_ip_count_lock does not call memcmp or compare null-terminated strings. It performs a pointer equality check (NULL == daemon->master) and calls a mutex lock macro; no use of memcmp is present.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,8.13,False,"No violation: the function uses daemon->per_ip_connection_mutex with MHD_mutex_lock_chk_, which locks/modifies the mutex. Because the pointed-to object is modified, the pointer must not be const-qualified per Rule 8.13, so the current non-const pointer usage is appropriate.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,2.1,False,"No violation. The function uses conditional compilation to produce two alternate, reachable implementations: when MHD_USE_POSIX_THREADS or MHD_USE_W32_THREADS is defined it calls MHD_mutex_lock_chk_(&daemon->per_ip_connection_mutex); otherwise it casts daemon to void to avoid an unused-parameter warning. Each branch is reachable depending on the build configuration and there is no statically unreachable (dead) code in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,1.2,False,"No violation: the function uses only standard C constructs and preprocessor conditionals. The code relies on standard macros and conditional compilation (defined(MHD_USE_POSIX_THREADS)), a cast to void to silence unused-parameter warnings, and standard function/macro calls. There are no compiler-specific language extensions (no inline assembly, no GCC/Clang __attribute__ or typeof, no statement expressions, no Microsoft-specific extensions, etc.).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_ip_count_lock,2.2,True,"When the project is built without thread support, the function body reduces to a no-op: the assertion is a no-op and the cast (void) daemon; has no effect on behaviour. Those executed operations (the no-op assertion and the void cast) can be removed without changing program behaviour, i.e. they are dead code. Specifically, given the provided macro definitions (mhd_assert expands to ((void)0)), the mhd_assert line is a no-op and therefore dead; similarly the (void) daemon; statement is an executed no-op in the non-thread build, and its removal would not affect behaviour.","Agent A is correct. In the non-thread build both executed statements in MHD_ip_count_lock are no-ops: mhd_assert expands to ((void)0) (a full-expression that does nothing) and the (void) daemon; cast likewise only discards the parameter value. Removing those statements would not change the behaviour of the built project, so they meet the definition of dead code in MISRA C 2023 Rule 2.2. (If mhd_assert expands to a checking expression in other build configurations, then those configurations would not exhibit dead code — but the rule applies to the actual project build, and the scenario as given shows dead code in the non-thread build.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,14.2,False,MHD_polling_thread contains no for statements — it uses while loops and conditionals only. Therefore the specific constraints for 'for' statements in MISRA C 2023 Rule 14.2 are not applicable to this function; no violation is present.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,17.8,False,"No violation in MHD_polling_thread: the function receives 'void *cls' and immediately assigns it to a local pointer 'daemon' (struct MHD_Daemon *daemon = cls;). The pointer parameter 'cls' itself is never modified; only the object it points to (daemon->...) is modified, which is allowed by Rule 17.8. A concrete violation scenario would be if the function modified the parameter pointer itself, e.g. 'cls = (void *)((char *)cls + 4);' or 'cls = NULL;'. Such an assignment to the parameter variable 'cls' would violate MISRA C 2023 Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,21.17,False,"No violation. The function and related code use string.h functions (memset, strerror via MHD_strerror_) with correct object sizes and without passing pointer/length arguments that could cause out-of-bounds access. Examples: memset(&p,0,sizeof(p)) and memset(&addrstorage,0,(size_t)addrlen) use the full object size; MHD_strerror_(errno) returns a pointer to an internal string (no user buffer is written into). No calls to strcpy/strncpy/strcat/strncat/strlen/etc. are made with potentially undersized buffers in the shown code paths, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,21.14,False,"No occurrence of memcmp comparing null-terminated strings in MHD_polling_thread or in the related functions shown. The code uses signal, poll/epoll/select, socket and list manipulation APIs; there is no use of memcmp to compare null-terminated strings, so the Rule 21.14 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,8.13,False,"No violation: the function converts the incoming void *cls to struct MHD_Daemon * and modifies the daemon object (writes daemon->tid, daemon->sigpipe_blocked, calls cleanup that modifies state). Because the function modifies the object pointed to, the pointer must not be const-qualified; this complies with MISRA C 2023 Rule 8.13.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,2.1,False,No violation. All conditional branches in MHD_polling_thread are controlled by runtime daemon->options or runtime results (e.g. sigemptyset/pthread_sigmask) even though feature macros enable compilation of those branches. The nested #ifdef/#else sequence for poll/epoll/select forms an if/else-if/else chain where each alternative can be taken depending on daemon->options at runtime. The while loop is controlled by daemon->shutdown and the post-loop cleanup paths are guarded by runtime option flags. Therefore there is no unreachable code in this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,1.2,False,"No violation: the function does not use any compiler language extensions. The code uses standard C constructs, POSIX APIs (pthread_sigmask, sigset_t) and project macros that expand to standard C types/empty tokens; there are no documented compiler-specific extensions such as __attribute__, __asm__, typeof, __extension__ or other vendor-specific keywords.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,MHD_polling_thread,2.2,False,"No violation: MHD_polling_thread contains no executed operations that can be removed without changing program behaviour. All assignments and calls (thread ID set, sigmask handling, the loop invoking poll/epoll/select, cleanup and shutdown sequences) affect daemon state or control flow and are reachable/used in normal operation.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,14.2,False,No 'for' loop is present in thread_main_handle_connection; therefore MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable to this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,17.8,False,"No violation: the function parameter 'data' (void *data) is never assigned to or modified. The code copies it into a local pointer variable (struct MHD_Connection *con = data;) and only modifies the pointee (fields of *con), which is allowed by the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,21.17,False,"No violation: the only use of a <string.h> function is memset(&p, 0, sizeof(p)) where p is a locally declared array of struct pollfd (declared under the same HAVE_POLL guard). sizeof(p) correctly reflects the actual array size (1 + EXTRA_SLOTS), and the call is inside the same conditional compilation region that defines p, so the memset cannot access beyond the bounds of p. No other <string.h> functions are used in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,21.14,False,No violation: the function thread_main_handle_connection and the related code do not call the Standard Library function memcmp to compare null-terminated strings. String comparisons are performed using helpers such as MHD_str_equal_caseless_ and lookup functions; standard memory functions used are memcpy/memmove/memset for non-string buffer manipulation. Thus Rule 21.14 is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,8.13,False,"Not violated. The function receives a pointer parameter (void *data) which is cast to struct MHD_Connection *con and the function modifies the pointed object throughout (e.g. MHD_thread_handle_ID_set_current_thread_ID_(&con->tid), con->rp.response is destroyed and set to NULL, shutdown(con->socket_fd, SHUT_WR), possible state transitions such as con->state changes and calls that update connection fields). Because the pointer is used to modify the referred object, it must not point to a const-qualified type. Thus Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,2.1,False,"No violation: the function contains conditional compilation blocks and runtime branches, but none of the code is provably unreachable in all configurations. Preprocessor-guarded sections (e.g. HAVE_POLL, UPGRADE_SUPPORT, WINDOWS) produce code only when the corresponding feature is enabled — this is conditional compilation, not unreachable code. Runtime branches (e.g. cases that goto exit or return when certain connection states occur) are reachable depending on connection state or daemon options. Comments like ""how did we get here!?"" are advisory but do not indicate truly unreachable code. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,1.2,False,"No language extensions detected. The function uses standard C/C99 constructs and platform APIs (select/poll, macros) but no compiler-specific language extensions (no asm, typeof, statement-expressions, attributes, nonstandard keywords or calling-convention extensions are present in the provided code).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,thread_main_handle_connection,2.2,True,"The project contains executed operations that have no effect on program behaviour: the ""if (1) { /* pseudo-branch for local variables scope */ ... }"" construct inside call_handlers is a constant-true conditional used only to scope local variables. The evaluation of that constant condition is executed yet it does not affect program behaviour; removing the constant conditional (the ""if (1)"" itself) would not change the program semantics. A concrete path that exercises this is when a connection reaches MHD_CONNECTION_CHUNKED_BODY_UNREADY (so call_handlers runs the branch that contains the pseudo-branch). The provided test code logs entry, each select/poll + call_handlers invocation, the connection state, and exit to /tmp/logs/122.txt so you can observe the control path that leads into the area where the constant-true pseudo-branch is executed.","The report is not correct. The supplied thread_main_handle_connection implementation does not contain any constant-true ""if (1) { ... }"" pseudo-branch; the agent A's claim locates that construct inside call_handlers, which is not part of the provided function or translation unit. Rule 2.2 forbids executed operations whose removal would not affect program behaviour, but no such executed, redundant conditional appears in the shown thread_main_handle_connection code. The test harness the agent provided is a simplified translation that omits the body of call_handlers (and thus cannot demonstrate the alleged if(1) being executed), and the test output was not produced. Therefore there is no evidence that thread_main_handle_connection itself contains dead code violating MISRA C 2023 Rule 2.2. (If call_handlers in another translation unit actually contains an if(1) used solely for scoping, that should be inspected in its own right; removal could change variable lifetimes and implementation-defined side-effects, so a careful analysis would be needed before declaring a Rule 2.2 violation.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,14.2,False,No violation: Neither parse_options nor parse_options_va contain any for statements. The code uses while and switch constructs; therefore MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,17.8,False,"No violation: parse_options does not modify its parameters. Neither 'daemon' nor 'params' is assigned to or altered; they are passed to parse_options_va and used as the last named parameter to va_start, which does not modify the pointer parameter itself.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,21.17,True,"When the caller passes MHD_OPTION_HTTPS_MEM_DHPARAMS with a NULL pointer for the PEM string and the daemon has MHD_USE_TLS set in options, parse_options_va calls strlen(pstr) without checking pstr for NULL. That results in undefined behaviour (read through a NULL pointer) and thus a violation of MISRA C 2023 Rule 21.17.","The claim is correct in substance. While the short parse_options wrapper shown in the ""original code"" does not itself call any string functions, the provided parse_options_va demonstrates an unguarded call to strlen(pstr). If the caller can legitimately pass a NULL pointer as the MHD_OPTION_HTTPS_MEM_DHPARAMS argument, then calling strlen(pstr) invokes undefined behaviour (a NULL dereference) and therefore violates MISRA C 2023 Rule 21.17. The only circumstance in which this would not be a MISRA violation is if the API has a documented, enforced precondition that the pointer argument is never NULL (i.e. callers are forbidden from passing NULL and that is part of the contract). Absent such a guaranteed non-NULL precondition, the report is correct. Recommended fix: check pstr for NULL before calling strlen (or require and enforce a non-NULL contract in the API documentation and at runtime).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,21.14,False,No violation: neither parse_options nor parse_options_va call memcmp to compare null-terminated strings. The code uses strlen to obtain string length and assigns/passes const char * values; string comparisons via memcmp are not present.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,8.13,True,"The function parse_options accepts non-const pointers (struct MHD_Daemon *daemon and struct MHD_InterimParams_ *params) but neither parse_options nor the called helper parse_options_va modify the objects pointed to. Because the pointers can be const-qualified (i.e., const struct MHD_Daemon * and const struct MHD_InterimParams_ *), the lack of const qualification is a violation of MISRA C 2023 Rule 8.13.","Agent A's report is correct given the supplied code. MISRA C 2023 Rule 8.13 advises that pointer parameters be const-qualified when the pointed-to objects are not modified by the function. In the provided parse_options and parse_options_va snippets neither function modifies *daemon or *params, so the parameters should be declared as pointers to const (e.g. const struct MHD_Daemon *daemon, const struct MHD_InterimParams_ *params). 

Caveats: this conclusion assumes there are no other translation-unit-level uses (callers or callees) that require non-const access to those objects and that changing the signatures (including parse_options_va) to const is feasible across the code base. Also note that making the last named parameter of a variadic function const is allowed (va_start uses the address of that parameter), so the variadic nature does not prevent adding const. The failed compilation of the supplied test harness is unrelated to the const-qualification issue. 

Recommendation: if no modification occurs anywhere reachable from these functions, change the parameter types to const and update all declarations/definitions/callers accordingly to satisfy MISRA Rule 8.13.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,2.1,True,parse_options_va contains switch labels 'case MHD_OPTION_END:' (both in the outer option switch and in the inner switch used for MHD_OPTION_ARRAY) that are never reachable because the surrounding while loops only enter the switch when opt != MHD_OPTION_END (while (MHD_OPTION_END != (opt = ...))). Those case labels are therefore unreachable code and violate MISRA C 2023 Rule 2.1.,"The report is not substantiated. The wrapper parse_options shown contains no unreachable code. The claim that case labels for MHD_OPTION_END inside parse_options_va are “never reachable” depends entirely on the (not provided) body of parse_options_va and on assumptions about control flow that are not proven by the information given. In particular: (a) the presence of a while loop that tests while (MHD_OPTION_END != (opt = ...)) only shows that the switch expression is not equal to MHD_OPTION_END at the moment the switch is entered in that loop iteration — it does not by itself prove that the case label is unreachable (execution could still reach the label via fall‑through from a previous case in the same switch, via a goto, or via other control paths in other uses of that switch); (b) the inner switch mentioned may be switching on a different value or on opt after it has been changed, so the END case might be reachable there; and (c) the agent’s attempted runtime logging did not produce output (failed to compile), so no empirical evidence was provided. Because the necessary code and proof that the case labels can never be reached were not shown, the claim of a MISRA Rule 2.1 violation cannot be accepted as correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,1.2,False,"No violation: parse_options uses only standard C language features (static function, enum return type, and variadic argument handling via va_list/va_start/va_end). No compiler-specific/pragmas or documented language extensions are used.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/daemon.c,parse_options,2.2,False,"No violation: parse_options is a necessary variadic wrapper that initializes a va_list, forwards it to parse_options_va, and cleans up. parse_options_va itself calls parse_options recursively in several places (e.g. handling MHD_OPTION_ARRAY). The operations in parse_options are executed and removing them would change program behaviour (callers expect the variadic wrapper), so there is no dead code here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,14.2,False,"The function answer_to_connection contains no for loops; therefore MISRA C 2023 Rule 14.2 (requirements on well-formed for loops) cannot be violated by this function. No for-statement exists in the provided target function, so there is no scenario of a malformed for loop to report.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,17.8,False,"No violation: the function does not assign to any parameter variable itself. The only write through a pointer parameter is '*req_cls = connection;', which modifies the object pointed to by req_cls (allowed by the rule). No pointer parameters are reassigned (e.g. req_cls = ..., connection = ...), so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,21.17,False,"No violation. The code protects all uses of string.h functions against out‑of‑bounds access: the memcmp calls are only reached after the corresponding length checks (username_len == strlen(""root"") and password_len == strlen(""pa$$w0rd"")) and auth_info->password is checked for NULL before use. The MHD_basic_auth_get_username_password3 implementation allocates a decoded buffer and explicitly zero‑terminates username and password, so reading username_len/password_len bytes is within bounds. The other uses (strcmp with method and strlen on string literals) are applied to values provided by the MHD API which are documented as null‑terminated, so they do not cause out‑of‑bounds accesses.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,21.14,True,"The function uses memcmp to compare the nul-terminated username and password buffers returned by MHD_basic_auth_get_username_password3 against string literals (""root"" and ""pa$$w0rd""). The MHD_basic_auth_get_username_password3 function explicitly NUL-terminates the decoded username/password, so memcmp is being used to compare null-terminated strings, which violates MISRA C 2023 Rule 21.14.","Correct. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null‑terminated strings. In the code memcmp(auth_info->username, ""root"", auth_info->username_len) and memcmp(auth_info->password, ""pa$$w0rd"", auth_info->password_len) are used where both operands are C strings (the library call documents that the decoded username/password are NUL‑terminated). Even though the code first checks the lengths and only compares the exact character bytes (excluding the terminating NUL), it is still using memcmp to compare null‑terminated strings, so the report is valid. (If the library did not NUL‑terminate the buffers, memcmp could be appropriate; given the stated behavior, this is a violation.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,8.13,False,"No violation. The function already uses const for input strings (const char *url, *method, *version, *upload_data) and leaves non-const pointers for objects that the function or called APIs modify (struct MHD_Connection *connection, struct MHD_Response *response, void **req_cls which is assigned *req_cls = connection, and struct MHD_BasicAuthInfo *auth_info whose members point into an allocated, mutable buffer). Making req_cls or connection point to const would be incorrect because the function modifies the object pointed to (it stores connection into *req_cls and passes connection to functions that update connection state). The MHD_BasicAuthInfo members are non-const by API design because the allocation returns mutable buffers and MHD_free is later called. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,2.1,False,No violation: analysis found no unreachable code in answer_to_connection. All early returns (method check and initial *req_cls check) are intentional; every path that reaches the cleanup at the end initializes 'response' and sets 'ret' before the final MHD_destroy_response(response) and return. No statements in the function are unreachable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,1.2,False,"No violation: the function uses only standard C language constructs (standard types, standard library functions, casts to void to silence warnings, static variables). It does not use any compiler-specific language extensions such as GCC/Clang __attribute__ annotations, typeof, statement-expressions, inline asm, nested functions, or other extensions documented as non-standard in compilers.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/basicauthentication.c,answer_to_connection,2.2,True,The explicit (void) parameter casts at the start of answer_to_connection are executed no-op operations whose removal would not affect program behaviour. Those casts constitute dead code under MISRA C 2023 Rule 2.2.,"The report is not correct. The (void) parameter casts are the usual idiom to explicitly discard unused parameters; they evaluate the operand (so they are not pure textual comments) and can matter in corner cases (e.g. when the operand is volatile or when timing of evaluation matters per Rule 2.2 note 1). More importantly, MISRA’s notion of “dead code” targets executed operations whose removal would not affect program behaviour; the explicit discards communicate intent, suppress compiler diagnostics and — in general — can affect behaviour in edge cases, so they should not be treated as dead code in this context. Thus flagging those (void) casts as a Rule 2.2 violation is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,14.2,False,"MHD_MD5_update contains no for statements — it uses if, while and do/while in helper functions. Therefore MISRA C 2023 Rule 14.2 (for loop well-formed) is not applicable and is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,17.8,True,The function modifies the pointer parameter 'data' (e.g. data += bytes_left; data += MD5_BLOCK_SIZE). MISRA C 2023 Rule 17.8 requires that a pointer parameter itself shall not be modified (though the object pointed to may be). Thus incrementing the parameter 'data' inside MHD_MD5_update violates the rule. A concrete violation path: when bytes_have != 0 and length >= bytes_left the code does data += bytes_left; or when there are full blocks the code does data += MD5_BLOCK_SIZE in the while loop — both modify the pointer parameter.,"Agent A is correct. The function parameter 'data' is a pointer parameter (declared as const uint8_t *data) and the code performs pointer arithmetic on it (data += bytes_left; data += MD5_BLOCK_SIZE;). That modifies the pointer parameter itself rather than the object it points to, which is exactly what MISRA C 2023 Rule 17.8 forbids. To comply, make a local copy of the pointer (for example: const uint8_t *p = data;) and modify the local copy instead of the parameter.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,21.17,False,"No violation: memcpy calls are bounded by MD5_BLOCK_SIZE. bytes_have is computed as ctx->count & (MD5_BLOCK_SIZE - 1), so 0 <= bytes_have < MD5_BLOCK_SIZE. In the partial-block-merge branch, bytes_left = MD5_BLOCK_SIZE - bytes_have; if length >= bytes_left the code copies exactly bytes_left bytes (filling the buffer) and then processes the block (bytes_have set to 0). Otherwise length < bytes_left, so bytes_have + length < MD5_BLOCK_SIZE and the final memcpy copies length (< bytes_left) into the remaining space. In the full-block path bytes_have is 0 and final length < MD5_BLOCK_SIZE. Also there is an assertion that data != NULL when length > 0. Therefore no memcpy or other string.h call can access beyond the bounds of ctx->buffer or data, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,21.14,False,"No violation: MHD_MD5_update does not call memcmp. The function uses memcpy and md5_transform to process binary data buffers, and does not compare null-terminated strings with memcmp.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,8.13,False,"No violation: the 'data' parameter is declared as 'const uint8_t *' and is only used for read-only operations (memcpy source and passed to md5_transform). The function never writes through 'data' (it only advances the pointer value), so the pointer correctly points to a const-qualified type. A violation would occur if the code wrote to *data or passed it to a callee that modified the pointed-to object (or removed const via a cast), but that is not the case here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,2.1,False,"No violation. In the provided MHD_MD5_update implementation there is no unreachable code: the only early-return (if (0 == length) return;) is conditional on the compile-time macro MHD_FAVOR_SMALL_CODE. When that macro is defined the early return is omitted, but the subsequent runtime checks (while (MD5_BLOCK_SIZE <= length) and if (0 != length)) ensure that no code path dereferences data when length == 0. All branches are reachable depending on runtime values and compile-time configuration, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,1.2,False,"No violation: the function uses only standard C constructs (standard types, casts, memcpy, arithmetic, control flow). There are no compiler-specific extensions such as __attribute__, __asm__, typeof, statement expressions, nested functions, or other documented compiler extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/md5.c,MHD_MD5_update,2.2,True,"When MHD_FAVOR_SMALL_CODE is defined, the early 'if (0 == length) return;' shortcut is omitted. A call to MHD_MD5_update with length == 0 still executes operations such as computing bytes_have and performing ctx->count += length (adding zero). Those executed operations have no effect on program behaviour for length == 0, so they constitute dead code per MISRA C 2023 Rule 2.2.","The report is not correct. MISRA Rule 2.2 targets operations that can be removed from the project without changing program behaviour. The statements in MHD_MD5_update (bytes_have calculation, ctx->count += length, subsequent branches/loops) are required for the normal (length != 0) case: they determine buffering, block processing and the maintained byte count. They are therefore not universally removable. The fact that, for one particular call where length == 0, some executed operations have no observable effect in that single execution does not make them dead code under Rule 2.2. Additionally, Note 1 points out timing can be observable behaviour (so removal may change timing), and reads/writes could matter for volatile or memory-mapped contexts. For these reasons the agent A’s claim that the code violates MISRA C 2023 Rule 2.2 is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,14.2,False,No for-loop present in send_iov_nontls (uses while for tracking sends). MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,17.8,True,The value parameter 'push_data' (a by-value function parameter) is assigned to (modified) inside the function in at least two places: once when _MHD_IOV_MAX < items_to_send (push_data = false) and once in the Windows-specific branch when items_to_send > UINT32_MAX (cnt_w = UINT32_MAX; push_data = false). Assigning to the by-value parameter 'push_data' violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).,"The report is correct. The parameter push_data is a by-value function parameter and it is assigned to inside the function (e.g. push_data = false in the _MHD_IOV_MAX branch and again in the Windows branch when items_to_send > UINT32_MAX). MISRA C 2023 Rule 17.8 states a function parameter shall not be modified (the object addressed by a pointer parameter may be modified, but not the parameter itself). Assigning to push_data therefore violates Rule 17.8. 

Remediation: copy the parameter into a local variable at the function start (e.g. bool local_push = push_data;) and modify local_push instead; then use local_push in subsequent calls/logic. This preserves behavior while complying with the rule.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,21.17,False,"No violation: the only <string.h> function used in send_iov_nontls is memset(&msg, 0, sizeof(struct msghdr)), which writes exactly the size of the local 'msg' object, so there is no access beyond the bounds of the referenced object. No other string.h functions (memcpy, memmove, memset on external buffers, strcpy, strncpy, etc.) are used. Pointer arithmetic on the iov array (r_iov->iov + r_iov->sent) and subsequent indexing are not string.h calls and therefore are outside the scope of Rule 21.17. (Note: separate logic errors such as r_iov->sent > r_iov->cnt would be out-of-bounds issues but are not caused by any string.h function in this routine.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,21.14,False,"No violation: send_iov_nontls does not call memcmp nor compare null-terminated strings using memcmp. No usage of memcmp is present in the provided code or the referenced helper functions, so Rule 21.14 is not triggered.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,8.13,False,"No violation: send_iov_nontls legitimately modifies the object pointed to by r_iov. The function updates r_iov->sent (r_iov->sent++;), and adjusts the current iov element by assigning to r_iov->iov[r_iov->sent].iov_base and subtracting from r_iov->iov[r_iov->sent].iov_len. Because the pointed-to object is modified, the pointer must not be to a const-qualified type. The parameter is declared as 'struct MHD_iovec_track_ *const r_iov' (a const pointer to a non-const object), which is appropriate and conforms to MISRA C 2023 Rule 8.13.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,2.1,False,"No reachable-code violation in the provided project configuration. All executable statements in send_iov_nontls are reachable depending on runtime conditions or chosen compile-time configuration: the I/O path selection is resolved by preprocessing (HAVE_SENDMSG selects the first branch), error handling and positive-send handling are reachable at runtime, and the use of if (1) is redundant but does not produce unreachable code. There are no statements that can never be executed in the built project.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,1.2,False,"No violation: the function does not use any compiler language extensions (no GCC/Clang __attribute__, __builtin_*, typeof, nested functions, statement-expressions, asm, or other vendor-specific keywords). Platform-specific macros (e.g. MSG_NOSIGNAL, MSG_MORE, WSASend) are OS/library APIs or feature-test macros, not language extensions. The provided helper macros (mhd_assert, MHD_socket_get_error_) are standard preprocessor macros and do not introduce language extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,send_iov_nontls,2.2,True,The project defines mhd_assert as ((void)0). The call mhd_assert(0 == (connection->daemon->options & MHD_USE_TLS)); is therefore an executed no-op expression statement whose presence or removal would not affect program behaviour. This qualifies as dead code under MISRA C 2023 Rule 2.2.,"The report is correct for the scenario Agent A described. If mhd_assert is defined as a macro that expands to ((void)0) (i.e. the assertion and its operand are removed by the preprocessor), the statement

  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));

becomes an executed no-op expression statement whose presence or removal will not change program behaviour. Under MISRA C 2023 Rule 2.2 (“A project shall not contain dead code”), that is dead code and therefore a violation.

Caveats/nuances:
- If mhd_assert is an actual function (even an empty inline function) the argument expression is still evaluated at the call site. In that case the call is not a pure no-op because the read/evaluation of connection->daemon->options occurs; removal could still change timing or observable behaviour on some embedded platforms (see Note 1 of Rule 2.2). Whether that is “dead code” then depends on whether removal can be proven to have no effect, so the violation is not automatic in that configuration.
- In short: given Agent A’s explicit assumption that mhd_assert is ((void)0), their claim of a Rule 2.2 violation is correct. If mhd_assert is implemented differently (so the assertion’s operand is evaluated), the conclusion may differ and requires further analysis.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,14.2,False,"No for loop present in MHD_send_data_. Rule 14.2 concerns the well-formedness of for statements (initialization, condition, iteration and single loop counter). The provided function contains no for statements, so the rule is not applicable and is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,17.8,True,"The function modifies its non-pointer parameters 'buffer_size' and 'push_data'. Specifically, when buffer_size > SSIZE_MAX (or > MHD_SCKT_SEND_MAX_SIZE_ for plaintext), the code assigns to 'buffer_size' and sets 'push_data = false' — this modifies function parameters and thus violates MISRA C 2023 Rule 17.8.","The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified (the object referred to by a pointer parameter may be modified, but the pointer itself shall not be). In MHD_send_data_ the non-pointer parameters buffer_size (type size_t) and push_data (type bool) are assigned to: buffer_size = SSIZE_MAX; push_data = false; (and similarly buffer_size = MHD_SCKT_SEND_MAX_SIZE_; push_data = false; in the plaintext branch). Those statements modify value parameters and therefore violate Rule 17.8. (The pointer parameters are not being reassigned; the violation is due to direct assignment to the value parameters.)

Remediation: introduce local copies (e.g. size_t send_size = buffer_size; bool do_push = push_data;) and use/modify those locals instead of reassigning the parameters.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,21.17,False,"No violation: MHD_send_data_ does not call any of the <string.h> string handling functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.) nor does it pass buffers to such functions. The function uses send (via MHD_send4_) and gnutls_record_send for transmission; these are not <string.h> functions covered by MISRA C 2023 Rule 21.17. No out-of-bounds string handling via <string.h> is present in the shown code or the closely related helper functions, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,21.14,False,No usage of the C library function memcmp is present in the provided MHD_send_data_ function or the accompanying helper code. There are no comparisons of null-terminated strings via memcmp in the shown code paths; data is sent via send/gnutls_record_send and socket/error checks are numeric or flag-based. Therefore Rule 21.14 (memcmp shall not be used to compare null-terminated strings) is not violated by this code.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,8.13,False,"No violation: the function parameter 'buffer' is declared as 'const char *' and MHD_send_data_ never writes through that pointer. It only passes the pointer to send/gnutls_record_send which take/read the data; the function does not modify the pointed-to object, so Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,2.1,True,"When the project is built without HTTPS_SUPPORT (i.e. HTTPS_SUPPORT is not defined), the local constant tls_conn is initialised to false unconditionally. The 'if (tls_conn)' branch of MHD_send_data_ can never be taken, so all code in that branch is unreachable in that build configuration. This violates MISRA C 2023 Rule 2.1 because unreachable code is present in the project.","Agent A is correct. In the configuration where HTTPS_SUPPORT is not defined the code path does make tls_conn a local const initialized to false, and there is no code that can change it. Therefore the test if (tls_conn) can never succeed and every statement in that then-branch is unreachable in that build configuration. MISRA C 2023 Rule 2.1 forbids unreachable code in the project, so the reported violation is valid. Practical fixes include moving the whole TLS branch behind the HTTPS_SUPPORT preprocessor guard (so it is absent when HTTPS_SUPPORT is not defined), or making tls_conn a runtime-evaluated value only in TLS-enabled builds (so the branch is not provably always false).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,1.2,False,"No language extensions are used. The function and surrounding code employ standard C (C99) features only (ssize_t, bool, enums, macros and conditional compilation). There are no compiler-specific keywords or extensions such as __attribute__, __asm, typeof, nested functions, statement expressions, or other vendor-specific constructs documented as compiler extensions; therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_send.c,MHD_send_data_,2.2,False,"No executed dead code in MHD_send_data_. All operations that run affect program behaviour. The apparent ""dead"" fragments are either: 1) conditional compile-time branches (e.g. the TLS block when HTTPS_SUPPORT is not defined) which are unreachable because they are not compiled/never executed — per MISRA note 2 unreachable code is not considered dead code; or 2) code paths in helper functions (pre_send_setopt/post_send_setopt) that are marked as ""Dead code currently"" in comments but are guarded by feature macros and/or runtime conditions and are therefore not executed in typical builds; these are unreachable rather than executed-and-removable. No executed operation in MHD_send_data_ can be removed without changing behaviour, so Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,14.2,False,"No violation: the code (including related functions MHD_get_response_element_n_ and MHD_str_equal_caseless_bin_n_) uses for loops that are well-formed. For example, MHD_get_response_element_n_ uses for (pos = response->first_header; NULL != pos; pos = pos->next) where the loop counter is initialised in the first clause, the condition has no persistent side effects, and the increment updates only the loop counter. MHD_str_equal_caseless_bin_n_ uses for (i = 0; i < len; ++i) which also meets the requirements. No for loop counter is modified inside the loop bodies, and only a single loop counter is used per for loop.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,17.8,False,"No violation. MHD_del_response_header does not assign to any of its parameters (response, header, content). It updates members of the object pointed to by response (response->flags_auto and calls that mutate response), which is permitted by the rule. A violation would occur if the code assigned to the pointer parameters themselves (for example: header = some_other_ptr; or response = NULL;), but no such assignment exists in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,21.17,False,"No violation: All uses of string.h functions (strlen, memcmp) operate on buffers whose lengths are verified beforehand. header and content are checked for NULL and strlen is used to obtain header_len/content_len; comparisons with pos->header_size/pos->value_size ensure memcmp only reads within the allocated extents. Calls that compare against static header names use MHD_STATICSTR_LEN_ and the caseless comparison that reads exactly that length. Therefore no out-of-bounds accesses occur.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,21.14,True,"The function computes header_len = strlen(header) and content_len = strlen(content) (both inputs are null-terminated strings) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare them. This is memcmp being used to compare null-terminated strings, which violates MISRA C 2023 Rule 21.14.","The report is correct. The code computes header_len = strlen(header) and content_len = strlen(content), so header and content are null-terminated C strings. It then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare those strings. MISRA C 2023 Rule 21.14 forbids use of memcmp to compare null-terminated strings; using memcmp with pointers that refer to C strings (even when comparing only the non‑NUL bytes) violates the rule. (The failing test build is irrelevant to the correctness of the reported rule violation.) Suggested remedies: ensure both operands are non‑string binary buffers before using memcmp, or use the appropriate string functions (e.g. strcmp/strncmp) with guaranteed NUL-termination, or otherwise make explicit and documented that the buffers are non‑NUL-terminated binary data.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,8.13,False,"No violation. The function declares 'header' and 'content' as 'const char *' (they are not modified) and declares 'response' as 'struct MHD_Response *' (non-const) because the function removes headers, frees memory and updates response->flags_auto. The local 'pos' pointer refers to modifiable header structures which are freed/modified, so it must be non-const. All pointer qualifications are appropriate for the operations performed (e.g. memcmp takes const void*), so Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,2.1,False,"No unreachable code found in MHD_del_response_header. All conditional branches either return a result (early returns for NULL inputs and for the special ""Connection"" header case), or are part of the reachable loop that may return MHD_YES when a matching header/value pair is found; if not found the function returns MHD_NO at the end. There are no statements that cannot be reached due to preceding unconditional returns or constant conditions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,1.2,True,"The code uses the _MHD_EXTERN macro in the function declaration. In the provided additional code that macro expands to __attribute__((visibility(""default""))) extern — a compiler-specific attribute (GCC/Clang extension). Because __attribute__((...)) is a language/compiler extension explicitly documented by compilers, Rule 1.2 is violated.","Agent A's report is correct. The code uses the macro _MHD_EXTERN in the function declaration; if that macro expands to __attribute__((visibility(""default""))) extern (the GNU/Clang attribute syntax), then a compiler-specific language extension is being used. MISRA C 2023 Rule 1.2 prohibits use of language/compiler extensions that are explicitly documented as extensions. The GNU __attribute__ construct is a documented compiler extension, so this use violates Rule 1.2. (If in a different configuration _MHD_EXTERN expands to a standard token such as plain extern, there would be no violation; the violation only applies when the attribute expansion is present.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_del_response_header,2.2,False,"No violation: every executed operation in MHD_del_response_header contributes to control flow or modifies response state (checks for NULL, header length, special-case connection handling, iteration removing matching header and updating flags). There is no code that is executed but could be removed without affecting program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,14.2,False,"The file_reader implementation contains no for statements. Rule 14.2 concerns the well-formedness of for loops; since there are no for loops in this function, the rule is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,17.8,True,"The function modifies its scalar parameter 'max' inside file_reader: the line 'if (max > SSIZE_MAX) max = SSIZE_MAX;' assigns to the parameter 'max', which violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).","Agent A is correct. MISRA C 2023 Rule 17.8 prohibits modifying a function parameter; in the original file_reader the scalar parameter 'max' is assigned to (if (max > SSIZE_MAX) max = SSIZE_MAX;), which is a direct breach of that rule. (The allowance in the rule for modifying the object referred to by a pointer parameter does not apply here because 'max' is a scalar parameter, not a pointed-to object.) Recommended fix: do not assign to the parameter — introduce a local variable (e.g. size_t to_read = max; if (to_read > SSIZE_MAX) to_read = SSIZE_MAX;) and use that local variable for subsequent calls.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,21.17,False,"No violation: the function file_reader does not call any of the <string.h> string-handling functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). All buffer operations are done via read/pread/ReadFile which do not belong to <string.h>, and there are checks that limit the requested read size (clamping to SSIZE_MAX or INT32_MAX) and validate offsets. Therefore Rule 21.17 (no out-of-bounds access via <string.h> functions) is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,21.14,False,"No violation: the function does not call memcmp or perform comparisons of null-terminated strings. It only performs numeric checks (e.g. offset64 < 0, n == 0, n < 0) and file I/O calls (pread/pread64/read/lseek/ReadFile).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,8.13,True,"The function file_reader takes a generic closure pointer cls of type void * and immediately assigns it to struct MHD_Response *response but never modifies the response object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Here cls/response could and should be const (e.g. const void *cls and const struct MHD_Response *response) because the function only reads from it. The lack of const qualification on cls is a violation.","MISRA R8.13 does encourage using const-qualified pointees when possible. Superficially the function only reads from the object pointed to by cls, so inside the body a const-qualified pointer would be more appropriate. However, in real use this function is an implementation of a library callback (file_reader is the content-reader passed to libmicrohttpd) and therefore its parameter type must match the externally-specified callback prototype (void *cls). That external API constraint prevents changing the signature to const void *cls (or changing the pointer type the library expects), so the lack of const here is not a genuine MISRA violation but an acceptable/necessary exception due to the required callback prototype. In short: the agent’s reasoning is incomplete — the code could be made const if it were a purely internal function, but because it implements an externally-specified callback its parameter type cannot be changed; therefore the report as presented is not correct without acknowledging the API constraint. If this function truly is internal and not constrained by an external prototype, then making cls/response const would be the correct fix.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,2.1,False,"No violation: the file_reader implementation does not contain unreachable code in the compiled translation unit. The conditional compilation selects a single platform-specific implementation (non-Windows when !_WIN32 || __CYGWIN__), and with the provided build-time symbols (HAVE_PREAD64, HAVE_PREAD, HAVE_LSEEK64) the pread64 path is chosen; the other alternative branches are excluded by the preprocessor and so are not present in the translation unit. At runtime all remaining statements are reachable depending on input values (e.g. offset64 < 0, read returning 0 or <0). Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,1.2,False,"No compiler language extensions are used. The code uses standard C types (uint64_t, int64_t, uintptr_t) and POSIX/Windows API types and functions (ssize_t, pread64, read, ReadFile, OVERLAPPED). These are platform APIs or standard integer types rather than compiler language extensions (no use of compiler-specific keywords or built-ins such as __attribute__, __asm, typeof, nested functions, __builtin_..., or other documented compiler extensions). Conditional compilation handles platform differences. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,file_reader,2.2,True,"When the project is configured with HAVE_PREAD64 (and the build is non-Windows), the code paths for the alternative read/seek implementations (the #elif HAVE_PREAD and the subsequent lseek-based branches) are never compiled or executed in this build configuration. Those excluded branches in the source are effectively dead for this project configuration: they will never be part of the produced binary and therefore represent code in the project that has no effect on the program behaviour for this configuration.","Agent A misinterprets MISRA C:2023 Rule 2.2. The rule (and its notes) defines dead code as operations that are executed but whose removal would not affect program behaviour; it explicitly distinguishes unreachable code from dead code (note 2). Code excluded by preprocessor conditionals (e.g. the #elif/#else branches not selected in a given build) is not present in the produced binary for that configuration and therefore is not executed; such excluded source is not ""dead code"" under the quoted MISRA definition. Moreover, the alternative branches can be selected in other build configurations (they are conditional, not inherently redundant). The test/probe attempt failing to compile does not change this semantic point. Therefore the report that this file_reader code violates MISRA C 2023 Rule 2.2 for the described configuration is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,14.2,False,"No violation: the only for loop is in MHD_get_response_element_n_. It initializes the loop counter (pos = response->first_header), the condition (NULL != pos) references only the loop counter and has no persistent side effects, and the iteration expression (pos = pos->next) modifies only the loop counter. There is a single loop counter that is not modified in the loop body. Thus Rule 14.2 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,17.8,False,"No violation. The function does not assign to any of its pointer parameters (response, header, content). It only dereferences 'response' to modify the object it points to (e.g. response->flags_auto) and passes header/content to helper functions. Pointer parameters themselves are never reassigned, so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,21.17,True,"If a caller passes a NULL header pointer (header == NULL) to MHD_add_response_header, the function immediately calls MHD_str_equal_caseless_(header, ...). MHD_str_equal_caseless_ dereferences str1 (header) without a NULL check, causing an access through a NULL pointer (out-of-bounds/undefined behavior). Similarly, add_response_entry uses strlen(header) without validating header != NULL. Therefore use of standard string functions can result in accesses beyond the bounds of the object referenced by the pointer parameters — violation of MISRA C 2023 Rule 21.17.","Not correct. MISRA C:2023 Rule 21.17 concerns the Standard Library string.h functions (memcpy, strlen, strcpy, etc.) being used in a way that can access beyond the bounds of the objects passed to them. The snippet you provided does not call any standard string.h functions directly — it calls library helpers such as MHD_str_equal_caseless_ and add_response_entry. Those helpers might internally use standard string functions, but agent A gave no implementation showing that they call strlen/strcmp/etc. with a potentially NULL pointer.

Agent A’s hypothetical (header == NULL) describes undefined behavior if the implementation of MHD_str_equal_caseless_ or add_response_entry dereferences header or calls strlen(header) without a NULL check. That would be a real bug (and could violate MISRA rules), but you cannot conclude Rule 21.17 is violated from the shown code alone. To demonstrate a 21.17 violation you must show a direct call to a string.h routine with a pointer that can be NULL/out-of-bounds or show the implementation of the helper that does so. In addition, many APIs document preconditions (header must be non-NULL); if that precondition exists, lack of a NULL check in the caller is not a 21.17 fault.

Finally, the test code provided by agent A used strlen in a helper and attempted to build, but it failed to compile and produced no runtime evidence. In summary: the report is not supported by the provided code and therefore is not correct as stated.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,21.14,True,"When handling the ""Connection"" header and the response already contains a Connection header, the code uses memcmp(hdr->value, ""close"", 5) to compare hdr->value (a null-terminated string) with the literal ""close"". Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.","Agent A's report is correct. The scenario (and the provided test code) shows a memcmp(hdr->value, ""close"", 5) call where hdr->value is a null-terminated string and the second operand is the null-terminated string literal ""close"". MISRA C 2023 Rule 21.14 states that memcmp shall not be used to compare null-terminated strings; using memcmp here to test string equality therefore violates that rule. (Note: the MHD_add_response_header excerpt did not include the Connection-handler body, but the agent's scenario/test_code demonstrates the memcmp usage in the connection handling path.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,8.13,False,"No violation: MHD_add_response_header and the called helpers use const-qualified pointers for header and content parameters and never modify the objects pointed to by those pointers. Any modification or freeing is performed on separately allocated copies (e.g. hdr->header, hdr->value), not on the const inputs, so the rule is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,2.1,False,"No violation: MHD_add_response_header contains only conditional branches and early returns that depend on run-time values (the header and content strings). Each block is reachable for appropriate input (e.g. ""Connection"", ""Transfer-Encoding"", ""Date"", ""Content-Length"", or other headers), and the final fall-through return is reachable when none of the special headers match. No unreachable code was identified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,1.2,True,"The code uses a compiler-specific attribute via the _MHD_EXTERN macro which expands to __attribute__((visibility(""default"")))extern. __attribute__ is a GCC/Clang language extension and therefore violates MISRA C 2023 Rule 1.2 (language extensions should not be used).","The target code as shown contains the identifier _MHD_EXTERN before the function return type, but the code fragment does not include the definition of that macro. MISRA C 2023 Rule 1.2 only applies when a language/compiler extension is actually used (and that extension is documented as an extension by the compiler). Agent A asserts that _MHD_EXTERN expands to __attribute__((visibility(""default""))) extern, and if that is true then it would indeed use GCC/Clang’s __attribute__ extension and therefore violate Rule 1.2. However, that assertion is not proven by the provided code: the macro definition (or the preprocessed output) is not shown, so you cannot confirm from the snippet whether a compiler-specific attribute is actually present.

Conclusion: the report is not demonstrably correct based on the supplied code. If in your build environment _MHD_EXTERN expands to a __attribute__ form (or any other non‑standard attribute syntax), then the code does violate MISRA 2023 Rule 1.2. To confirm and fix: inspect the macro definition or the preprocessed source (gcc -E) to see the real expansion; if it contains __attribute__ (or other compiler extension), remove or conditionally hide it for MISRA‑checked builds (or provide a standard-compliant alternative).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_add_response_header,2.2,False,"No violation: MHD_add_response_header contains no executed operations that could be removed without changing program behaviour. All branches perform meaningful checks, side-effects (flags modifications, header insertions/removals, frees), or return values that affect control flow. Note: mhd_assert is defined as ((void)0) in the provided code, so assertion calls are not executed and therefore are not dead code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,14.2,False,"No violation: the function add_response_entry_n contains no for loops, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. All control flow is via if statements and an unconditional return; therefore there is no opportunity for the specific for-loop constraints to be breached.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,17.8,False,"No violation. The function only reads its parameters and passes them to memchr and MHD_add_response_entry_no_check_. It does not assign to any parameter. (A violating scenario would be if the function assigned to a parameter, e.g. ""header = header + 1;"" or ""response = NULL;"", which would modify a pointer parameter and breach Rule 17.8.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,21.17,True,"Calling add_response_entry_n with header == NULL and header_len > 0 (or content == NULL and content_len > 0) leads to memchr being invoked with a NULL pointer and a non-zero length. That causes access beyond the bounds of the referenced object (NULL), violating MISRA C 2023 Rule 21.17.","Agent A is correct. The function calls memchr(header, ..., header_len) and memchr(content, ..., content_len) without ensuring header and content are non-NULL when the corresponding lengths are non-zero. If a caller passes header == NULL with header_len > 0 (or content == NULL with content_len > 0), memchr will be invoked with a NULL pointer and a non-zero size, which is undefined behavior (access beyond the bounds of the referenced object) and thus violates MISRA C 2023 Rule 21.17. To comply, the code must ensure that whenever a non-zero length is passed the pointer is valid (e.g. add checks header != NULL and content != NULL when header_len/content_len > 0), or establish and enforce a documented precondition that callers never pass NULL with non-zero length and provide the necessary static/proof evidence of that precondition.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,21.14,False,No violation: add_response_entry_n does not call memcmp. It uses memchr and memcpy and strlen to handle buffer lengths and to detect disallowed characters; there is no use of memcmp to compare null-terminated strings in the shown code paths.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,8.13,False,No violation. The pointer parameters 'header' and 'content' are correctly declared as pointers to const-qualified types because the function does not modify the data they point to (only inspects them via memchr and forwards them). The 'response' parameter is a non-const pointer because it is passed to MHD_add_response_entry_no_check_ which is expected to modify the response object. Therefore Rule 8.13 is respected.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,2.1,False,"No reachable-code violation. All return statements in add_response_entry_n are on distinct, reachable conditional paths (response NULL, zero header_len, zero content_len, invalid characters found via memchr on header/content, or the final successful call to MHD_add_response_entry_no_check_). Each branch can be exercised by providing appropriate inputs, so there is no unreachable code within this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,1.2,False,"No language extensions are used in add_response_entry_n; it only uses standard C types and library functions (size_t, NULL, memchr, return of a function). Therefore MISRA C 2023 Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry_n,2.2,False,No violation: add_response_entry_n performs runtime input validation and rejects headers/contents containing prohibited characters or zero lengths before delegating to MHD_add_response_entry_no_check_. All executed operations affect program behaviour (they prevent invalid inputs from reaching the underlying function and thus are not removable without changing behaviour). No dead code is present in this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,14.2,False,"No violation. The for loop uses a single loop counter (pos). First clause initializes the loop counter (pos = response->first_header). Second clause tests only the loop counter (NULL != pos) and has no persistent side effects. Third clause modifies only the loop counter (pos = pos->next) and does not use any object that is modified in the loop body. The loop body does not modify pos or pos->next (it only reads fields and may call MHD_str_equal_caseless_bin_n_, which in this context is a read-only check). Therefore Rule 14.2 is satisfied. Note: if a function called in the body were to modify pos or pos->next, that would create a violation, but that is not the case here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,17.8,False,"No violation: MHD_get_response_element_n_ does not modify any of its parameters. The pointer parameters (response and key) are only read, key is const, key_len and kind are used but not assigned to, and only local variable 'pos' is updated. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,21.17,False,"No violation: The function asserts key != NULL, key[0] != 0 and key_len != 0 and only calls MHD_str_equal_caseless_bin_n_ when pos->header_size == key_len. By ensuring the comparison length is the same for both pointers the code does not cause accesses beyond the supplied lengths. Assuming pos->header and key are valid objects of at least header_size bytes (the caller/allocator responsibility), this use will not read past the buffers and therefore does not violate MISRA C 2023 Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,21.14,False,No violation. MHD_get_response_element_n_ compares header names using MHD_str_equal_caseless_bin_n_ with an explicit length (pos->header_size) and per-character comparison; it does not call memcmp or any other Standard Library function to compare null-terminated strings.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,8.13,False,"No violation. The function takes 'response' as a non-const pointer but does not modify the MHD_Response itself; it returns a pointer to a MHD_HTTP_Res_Header (non-const) found in the response. Because the caller is expected to be able to modify the returned header, the parameter cannot be made const without changing the API (or changing the return type to a const header pointer). The 'key' parameter is already const-qualified. Therefore there is no actionable opportunity to add const-qualification here that preserves the original behavior; Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,2.1,False,"No unreachable code in MHD_get_response_element_n_. All statements (assertions, loop, conditional check and final return) are potentially reachable at runtime: mhd_assert is defined as a no-op, so there are no early-exit paths removed by assertions; the for-loop iterates over response->first_header and may return from the body when the three conditions match or fall-through to the final return NULL. There are no constant-false conditions or unreachable branches in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,1.2,False,"No language extensions are used in the provided code. The function uses only standard C constructs (structs, enum, pointers, size_t, for-loop, function calls). There are no compiler-specific tokens or extensions present (e.g. __attribute__, __asm__, __extension__, typeof, _Pragma, or other vendor-specific keywords). Therefore MISRA C 2023 Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_get_response_element_n_,2.2,False,"No dead code found in MHD_get_response_element_n_. The function performs a necessary traversal and conditional checks; there are no executed operations whose removal would not affect program behaviour. The mhd_assert macro is defined as ((void)0), so its arguments are not evaluated and therefore those assertions do not constitute executed dead code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,14.2,False,"No for-loop present in add_response_entry or in the directly shown helper add_response_entry_n; Rule 14.2 (well-formed for loop) is not applicable. Neither the function nor the provided callees contain a for statement, so there is no possibility of violating the for-loop constraints described by Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,17.8,False,"No violation. The function add_response_entry does not assign to or modify any of its parameters (response, kind, header, content). It only reads them (strlen and passing to add_response_entry_n). Therefore MISRA C 2023 Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,21.17,True,"When add_response_entry is called with header == NULL and content != NULL (for example, via MHD_add_response_header(response, NULL, ""some-content"") or MHD_add_response_footer(response, NULL, ""some-content"")), the function calls strlen(header) without checking header for NULL. The strlen call dereferences the NULL pointer and therefore results in an access beyond the bounds of the object referenced by the header pointer, violating MISRA C 2023 Rule 21.17.","The report is correct. The function calls strlen(header) without checking header for NULL; if the caller supplies header == NULL (as in the scenario), strlen(NULL) dereferences a null pointer and therefore can access memory out of the bounds of the object referenced by the pointer parameter. That use of a string.h function violates MISRA C 2023 Rule 21.17. (The code does check content for NULL before calling strlen(content), so only the header side is problematic. The remedy is to ensure header is non-NULL before calling strlen or handle a NULL header explicitly.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,21.14,False,"No violation: the function does not call memcmp to compare null-terminated strings. It uses strlen to obtain lengths and memchr to scan within provided lengths; memcmp is not present anywhere in the shown code paths, so MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,8.13,False,"No violation in the shown code. Both parameters header and content are declared as const char * and are only used in read-only operations (strlen) within add_response_entry; they are forwarded unchanged to add_response_entry_n. There is no evidence in the provided snippet that the buffers are modified here, so Rule 8.13 is satisfied. (A potential violation would occur if add_response_entry_n had a prototype taking non-const char * and actually modified the data — that would require changing the callee to accept const or not modifying the pointed objects.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,2.1,False,No unreachable code in add_response_entry. The function has two reachable control paths: if content == NULL the function returns early; otherwise it computes header_len and content_len and forwards to add_response_entry_n. There is no code that can never be executed. (Note: a potential NULL header would cause undefined behaviour at runtime but that is not the same as unreachable code and does not violate MISRA C 2023 Rule 2.1.),,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,1.2,False,"The function uses only standard C constructs (static function, enums, size_t, NULL, strlen, ternary operator). No compiler-specific language extensions (no __attribute__, inline asm, typeof, statement expressions, or other documented compiler extensions) are present in add_response_entry, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_entry,2.2,False,"No dead code in add_response_entry: all executed operations (the NULL check on content, the strlen(header) and strlen(content) computations, and the call to add_response_entry_n) contribute to the function behaviour and cannot be removed without changing program behaviour.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,14.2,False,"No violation: the only for loop (in MHD_get_response_element_n_) initializes the loop counter (pos = response->first_header), uses a side-effect-free condition (NULL != pos) that only depends on the loop counter, and updates only the loop counter (pos = pos->next). The loop counter is not modified inside the loop body. Therefore Rule 14.2 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,17.8,False,"No violation: the function does not reassign its pointer parameters. The function modifies members of the object pointed to by 'response' (e.g. response->flags_auto and linked-list insertion), which is permitted by the rule. The 'value' parameter is a 'const char *' and is only read; neither 'value' nor 'response' pointers are assigned to new values anywhere in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,21.17,True,"The function can write beyond the allocated buffer when inserting the ""close"" token: memmove copies norm_len + 1 bytes from buf + old_value_len to buf + old_value_len + prefix_length, but buf was allocated with size old_value_len + norm_len (no extra space for the prefix or the extra byte). The code relies on mhd_assert to check sufficient space but mhd_assert is a no-op, so the memcpy/memmove may access/write beyond the allocated buf causing out-of-bounds access.","The report is correct. The code allocates buf_size = old_value_len + norm_len (where norm_len was computed as a capacity for the normalized value including space for a terminating NUL). Later, when value_has_close && !already_has_close, the code does
  if (0 != norm_len)
    memmove(buf + prefix + old_value_len, buf + old_value_len, norm_len + 1);
which moves norm_len+1 bytes (the normalized bytes plus the NUL) to a destination that starts prefix bytes further into the same buffer. The allocated space after that destination is buf_size - (prefix + old_value_len) = norm_len - prefix, so the memmove will write past the end of the allocation whenever prefix > 0 (and typically prefix == length of ""close, "" > 0). The code contains an mhd_assert that would check for sufficient space, but assertions can be no-ops in production, so the code still allows an out-of-bounds access. This is precisely a violation of MISRA C 2023 Rule 21.17 (use of string functions must not result in accesses beyond object bounds).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,21.14,True,"When a response already has a Connection header, the code uses memcmp(hdr->value, ""close"", 5) to check whether the existing header value equals the string ""close"". This uses memcmp to compare a null-terminated string (the header value) against the null-terminated literal ""close"", which violates MISRA C 2023 Rule 21.14.","Agent A's report is correct. The code calls memcmp(hdr->value, ""close"", 5) to test whether the existing Connection header equals the string ""close"". The literal ""close"" is a null-terminated string and hdr->value is treated as a header string here; using memcmp to compare string contents (even when passing a length that omits the terminating NUL) is precisely what MISRA C 2023 Rule 21.14 forbids. Therefore this use of memcmp violates Rule 21.14. (Note: other memcmp uses in the file that compare fixed-sized binary buffers with explicit sizes may be acceptable; the specific memcmp against ""close"" is the violation.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,8.13,False,"No violation: add_response_header_connection correctly uses const for input strings where possible (value and key are const-qualified). Pointers that are non-const (hdr, buf, response) are intentionally non-const because the function modifies header/value memory and response flags. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,2.1,False,"No unreachable code identified in add_response_header_connection. All code paths are reachable depending on input and flags (e.g. the #ifdef UPGRADE_SUPPORT block is active in the provided build, the if (1) block is intentionally used as a local scope, and returns occur on legitimate conditional branches).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,1.2,False,"No violation: the function uses only standard C constructs and library calls (size_t, ssize_t, malloc/free, memcpy, memmove, memset, macros). There are no compiler-specific keywords, attributes, inline asm, or other documented compiler extensions present in the provided code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,add_response_header_connection,2.2,True,The unconditional 'if (1) { /* local scope */ ... }' is executed every call but its presence (the 'if (1)' test and branch operation) has no effect on program behaviour; removing the if(1) wrapper would not change the function semantics. Therefore the 'if (1)' branch constitutes dead code per MISRA C 2023 Rule 2.2.,"MISRA C 2023 Rule 2.2 forbids ‘‘dead code’’ defined as any operation that is executed but whose removal would not affect program behaviour. In the submitted function the if (1) { ... } wrapper is an unconditional conditional: the condition is always true, the branch is always taken, and removing the if (1) wrapper (leaving only the inner compound statement) does not change the observable behaviour of the function. Therefore the if (1) expression and the branch that implements it are executed but removable without effect and meet the definition of dead code in Rule 2.2. The usual, less intrusive way to obtain the inner scope is to use a plain compound statement { ... } (or move the local declaration out), which preserves the intended scoping without an unconditional if. For these reasons the agent A’s report is correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,14.2,False,"No violation: the function contains no for statements. Rule 14.2 applies specifically to for loops; this code uses a while loop to iterate over variadic arguments, so the for-loop well-formedness requirements are not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,17.8,False,"No violation: the function does not modify its value parameters. The pointer parameter 'response' itself is not reassigned; only the object it points to is modified (response->flags = flags), which is permitted by the rule. The non-pointer parameter 'flags' is only inspected and not assigned. The varargs handling reads options via va_arg into a local 'ro' and does not modify any function parameter. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,21.17,False,"No violation: MHD_set_response_options does not call any of the <string.h> functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.) nor any other standard string-handling routine. All operations are bitwise flag checks, integer assignments and va_arg handling; there is no use of pointer parameters to string functions that could cause out-of-bounds accesses.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,21.14,False,"No violation in the provided function. The code does not call memcmp. A typical violation scenario (hypothetical) would be if the function compared a NUL-terminated string such as a header name or response->data using memcmp, for example: memcmp(response->data, ""Content-Length"", strlen(""Content-Length"") + 1); this would violate MISRA C 2023 Rule 21.14 because memcmp must not be used to compare null-terminated strings (use strcmp/strncmp or safe string APIs instead).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,8.13,False,"No violation. MHD_set_response_options assigns to response->flags (response->flags = flags;) and thus modifies the object pointed to by the response parameter. Rule 8.13 allows the pointer to be non-const when the function modifies the pointed-to object, so the non-const struct MHD_Response *response parameter is appropriate.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,2.1,True,"The switch statement inside the va_arg loop contains a 'case MHD_RO_END' branch, but the while loop condition is 'while (MHD_RO_END != (ro = va_arg(...)))', so the MHD_RO_END case is never reachable. Thus the function contains unreachable code (violation of MISRA C 2023 Rule 2.1).","The report is correct. The while condition assigns ro and immediately checks for MHD_RO_END, only entering the loop body when ro != MHD_RO_END. Therefore the switch case labeled case MHD_RO_END inside that body can never be executed (it is unreachable). (Separately, the use of va_arg(ap, enum MHD_ResponseOptions) is questionable because arguments passed through '...' are subject to default promotions and should be retrieved with the promoted type, but that does not affect the reachability conclusion.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,1.2,True,"The function declaration uses the GCC-specific function attribute __attribute__((visibility(""default""))) (via _MHD_EXTERN), which is a compiler language extension explicitly documented by compilers such as GCC/Clang. This use of a compiler attribute violates MISRA C 2023 Rule 1.2 (language extensions should not be used).","Agent A's report is not supported by the provided snippet. The target code shows the token _MHD_EXTERN but does not show its definition. The presence of a macro name alone does not prove a language extension is used: _MHD_EXTERN may expand to nothing or to a standard extern, or it may be a portability macro that expands to a compiler attribute on some toolchains. MISRA C 2023 Rule 1.2 should be reported only when a compiler language extension is actually used (e.g., __attribute__((...)) as documented by a compiler). Agent A substituted an explicit GCC attribute in the test code, and that attribute would be a compiler extension and thus would violate Rule 1.2; however, that substitution is not evidence that the original code uses the extension. To decide definitively you must inspect the definition of _MHD_EXTERN (and any included headers or preprocessor output). If _MHD_EXTERN expands to a compiler-specific attribute (such as __attribute__((visibility(",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/response.c,MHD_set_response_options,2.2,False,"The only suspicious code is the 'case MHD_RO_END' label inside the switch within the va_arg loop. That label is unreachable because the loop condition prevents ro from being MHD_RO_END, so it cannot be executed. Note 2 of Rule 2.2 explicitly states unreachable code is not dead code. No operation that is executed (i.e. reachable at runtime) would be removable without changing program behaviour, so Rule 2.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,14.2,False,"MHD_monotonic_sec_counter_init contains no for statements (no loop constructs of type 'for' are present), so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,17.8,False,"No violation: MHD_monotonic_sec_counter_init has no parameters. The function only modifies local and static/global objects (mono_clock_id, mono_clock_start, gettime_start, sys_clock_start, etc.) and passes addresses of locals/globals to external APIs (e.g., &ts, &cur_time, &mono_clock_service). This is permitted because the rule forbids modifying a function's own parameters (none here); modifying objects referred to by pointer parameters of called functions is allowed.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,21.17,False,"No use of any <string.h> functions in MHD_monotonic_sec_counter_init. The function only calls time-related APIs (clock_gettime, clock_get_time, time, gettimeofday, timespec_get, gethrtime, QueryPerformanceCounter, GetTickCount64, etc.), so there is no possibility of string handling functions accessing out-of-bounds memory. Therefore Rule 21.17 is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,21.14,False,The function MHD_monotonic_sec_counter_init contains no call to memcmp or any string comparisons using memcmp. All operations are clock/time related; therefore there is no occurrence of using memcmp to compare null-terminated strings.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,8.13,False,"No violation in MHD_monotonic_sec_counter_init: the function does not declare pointer variables that could/should be const-qualified. All uses of addresses (e.g. &ts, &cur_time, &tsg, &tv) are passed to APIs that fill/modify those objects (clock_gettime, clock_get_time, timespec_get, gettimeofday), so the pointers must be to mutable objects. There are no unnecessary non-const pointer declarations that should be const-qualified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,2.1,True,"The function contains branches that are never reachable at runtime due to constant conditionals. For example, the initial ""if (0) { ... } else ..."" means the if(0) body is unreachable; similarly platform-specific constructs use ""if (1) { ... } else"" (e.g. Windows _WIN32 branches or gethrtime branches) so the corresponding else branches are unreachable when those if(1) blocks are compiled in. Compiling with HAVE_CLOCK_GETTIME (and the other provided macros) leaves the if(0) branch unreachable and thus violates MISRA C 2023 Rule 2.1 (no unreachable code).","Agent A is correct. MISRA C 2023 Rule 2.1 forbids unreachable code in the project. The function contains literal constant conditionals (e.g. if (0) { ... } else ... and several if (1) { ... } else ...) such that, in any translation unit where those constructs are compiled in, the taken/untaken branch is provably never executed. Those unreachable branches remain in the translation unit (they are not removed by the preprocessor) and therefore violate the “no unreachable code” requirement. The use here is a syntactic trick to chain platform-specific blocks, but that does not avoid the fact that the unreachable branch bodies are present in compiled code; to conform you would need to reorganize the logic (for example use preprocessor #elif chains or exclude the unreachable branches entirely) or provide a documented, justified deviation. Therefore the report is correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,1.2,False,"No language extensions are used. The function uses standard C constructs and preprocessor conditionals to select platform APIs (clock_gettime, clock_get_time, GetTickCount64, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time). Those are platform APIs/headers, not compiler language extensions (no GCC/Clang-specific keywords, statement-expressions, typeof, attributes, asm, or other documented compiler extensions are present).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_mono_clock.c,MHD_monotonic_sec_counter_init,2.2,True,The operation '(void) mono_clock_source;' (used to suppress a compiler warning when HAVE_CLOCK_GET_TIME is not defined) is executed but has no effect on program behaviour; removing it would not change the program. This is a dead operation and thus violates MISRA C 2023 Rule 2.2.,"Agent A is correct. The statement “(void) mono_clock_source;” (in the #else branch when HAVE_CLOCK_GET_TIME is not defined) is an executed no-op: it has no side‑effects and removing it does not change program behaviour (it only suppresses a compiler warning). By the rule’s own definition (“Any operation that is executed but whose removal would not affect program behaviour constitutes dead code”) this is dead code and therefore a violation of MISRA C 2023 Rule 2.2. (Note: this is distinct from an initialization; the cast-to-void is an executed expression statement, not an initialization.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,14.2,False,"No for loop is present in the ahc_echo function or nearby code; therefore MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. The function contains no for statements, so none of the four clauses or loop-counter constraints can be violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,17.8,False,"No violation. The function modifies the object pointed to by the pointer parameter 'req_cls' (assigning to *req_cls), but it does not modify the pointer parameter 'req_cls' itself. The rule allows modifying the object referred to by a pointer parameter while forbidding modification of the pointer variable. No other function parameters are reassigned in the body, so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,21.17,False,"No violation: the function only calls strcmp and strlen on strings (method, BUSYPAGE, param->response_page) which are expected to be null‑terminated by their providers; no string handling call writes or reads beyond object bounds in the shown code path.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,21.14,False,"No violation: ahc_echo compares null-terminated strings using strcmp (e.g. checks on method using strcmp(method, ""GET"") and strcmp(method, ""POST"")). There is no use of memcmp to compare null-terminated strings in ahc_echo or the supplied supporting code, so MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,8.13,False,"No violation: parameters that refer to objects not modified are const-qualified (url, method, version, upload_data, and response_page). The function modifies the pointer value stored via req_cls (i.e. *req_cls) but does not modify the object pointed to by that pointer, so it is appropriate that req_cls is a pointer-to-pointer and does not require the pointed-to type to be const-qualified. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,2.1,False,No unreachable code present. All statements in ahc_echo can be reached depending on the values of method and *req_cls: the early return handles non-GET/POST methods; the &aptr != *req_cls branch executes on the first call for a request and can return for POST; subsequent calls (when *req_cls == &aptr) skip that branch and execute the final response path. There are no statements that are never reachable at compile/run time.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,1.2,False,"No language extensions are used in ahc_echo; all constructs are standard C (casts, (void) unused, static local, enum, pointer comparisons). Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/refuse_post_example.c,ahc_echo,2.2,True,The (void) <param> expression statements (e.g. (void) cls; (void) url; (void) version; (void) upload_data; (void) upload_data_size;) are executed but have no effect on program behaviour — removing them does not change the control flow or state. Those no-op casts therefore constitute dead code under MISRA C 2023 Rule 2.2.,"The report is not correct. The five (void) parameter-cast statements are a conventional, intentional way to reference unused parameters so as to suppress compiler warnings and to document intent; they are not considered a defect under MISRA practice. Strictly speaking those casts perform no observable runtime action and removing them would not change program behaviour, but MISRA’s concern with “dead code” targets code that is genuinely redundant in intent (unused routines, unreachable blocks, leftover logic) rather than the deliberate unused-parameter idiom. In short: this idiom is the accepted way to mark unused parameters and does not constitute a Rule 2.2 violation in normal MISRA application. If you prefer, you may instead remove truly unnecessary casts or adopt an approved project annotation for unused parameters to satisfy both the compiler and static-analysis tools.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,14.2,False,No for loop is present in post_iterator; therefore Rule 14.2 (for loop well-formedness) is not applicable and not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,17.8,True,The function assigns to the parameter 'size' (size = (size_t)(...)) to crop extra data before calling memcpy. Modifying the function parameter variable 'size' violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).,"The report is correct. The parameter size is a non-pointer function parameter (size_t size) and the code assigns to it (size = (size_t)(...)) to crop extra data. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; therefore the assignment to size is a violation. 

To fix this while preserving behavior, use a local variable (for example: size_t to_copy = size;) and modify that local variable before calling memcpy, or otherwise compute the adjusted length into a new local variable. Note that the rule still allows modifying the object pointed to by a pointer parameter, but not the parameter variables themselves (including non-pointer parameters and pointer parameters as variables).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,21.17,False,"No violation: post_iterator performs explicit bounds checks before memcpy and null-termination. It returns early when off >= sizeof(session->value_X) - 1 and crops size when size + off would exceed the buffer, ensuring writes to session->value_X[off .. size+off] remain within the 64-byte arrays and placing the NUL at an allowed index.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,21.14,False,"No violation in the provided code. The function uses strcmp to compare the null-terminated keys (e.g. strcmp(""DONE"", key), strcmp(""v1"", key), strcmp(""v2"", key)). A concrete violation scenario would be if the code used memcmp to compare the null-terminated strings, for example: if (0 == memcmp(""DONE"", key, strlen(""DONE"")+1)) or if (0 == memcmp(""DONE"", key, sizeof(""DONE""))) which would violate MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,8.13,True,"The local pointer 'request' is declared as a non-const pointer (struct Request *request = cls;) even though post_iterator does not modify the Request object itself. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible (e.g. const struct Request *request). Thus the code violates Rule 8.13.","Agent A's report is correct. In post_iterator the local pointer 'request' is only used to read the Request object (to obtain request->session) and the function does not modify the Request object itself. MISRA C 2023 Rule 8.13 directs that a pointer should point to a const-qualified type whenever possible. Therefore declaring the local variable as const struct Request *request = cls; would be more compliant. Making request const does not prevent modifying the Session object reachable via the session pointer (you still can obtain a non-const struct Session * from the member and modify that), so the change is safe for the shown code. (The test harness failing to compile is unrelated to the rule — it likely lacks required type/feature definitions or headers — but does not invalidate the correctness of the rule violation assessment.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,2.1,False,No violation: all statements in post_iterator are reachable depending on the runtime value of `key`. Each conditional either returns early or falls through to the final fprintf/return for unsupported keys. There is no code that can never be executed (no statements after unconditional returns within the same block that are unreachable).,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,1.2,False,"No language extensions are used in post_iterator: all constructs are standard C (static function, enums, casts to void for unused params, standard library calls and types like uint64_t/size_t). Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,post_iterator,2.2,True,The explicit (void) expressions for unused parameters ( (void) kind; (void) filename; (void) content_type; (void) transfer_encoding; ) are executed but have no effect; removing them does not change the runtime behaviour. These no-op expression statements therefore constitute dead code according to MISRA C 2023 Rule 2.2.,"Agent A is correct. The four explicit (void) expression-statements are no-op evaluations: they have no side-effects and removing them does not change the program behaviour. Under MISRA C 2023 Rule 2.2 (“Any operation that is executed but whose removal would not affect program behaviour constitutes dead code”), such executed no-op statements meet the definition of dead code and therefore violate the rule. (The test harness details and failed compilation are irrelevant to the logical determination: the presence of these (void) casts in the source makes them no-op operations and thus subject to Rule 2.2.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,14.2,False,"No for loop is present in the fill_v1_v2_form function, so MISRA C 2023 Rule 14.2 (about well-formed for loops) is not applicable to this function. The function uses library calls and other helper functions but does not contain any 'for' statements itself; therefore it does not violate Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,17.8,False,"No violation: The function does not modify any of its parameter variables. The only pointer parameter used to modify state is 'session' via add_session_cookie(session, ...), which modifies the object pointed to (allowed). The parameter pointers themselves are not reassigned or altered. The (void) cls; line only suppresses an unused-parameter warning and does not modify cls.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,21.17,True,"strlen is called on session->value_1 and session->value_2 (fixed-size char arrays). If those arrays are not guaranteed to contain a terminating '\0' within their bounds, strlen can read past the end of the arrays -> out-of-bounds access. Thus Rule 21.17 is violated: use of strlen may access beyond the bounds of the objects referenced by their pointer parameters.","The report is correct. strlen(session->value_1) and strlen(session->value_2) (and the subsequent snprintf with %s) require that those arrays contain a NUL within their bounds. The snippet does not show the definition of struct Session or any guarantee that value_1/value_2 are NUL-terminated or otherwise terminated within their array bounds. If that guarantee does not exist, strlen and the %s conversions can read past the end of the arrays, which is exactly the situation MISRA C 2023 Rule 21.17 forbids (string functions must not be able to access beyond object bounds). Note also snprintf with %s is subject to the same requirement. If there is a separate, provable invariant that those arrays are always NUL-terminated (or the code ensures termination before these calls), then the code can be compliant; absent such a guarantee the claim of a Rule 21.17 violation is valid. Recommended fixes include using bounded length checks (e.g. strnlen(session->value_1, sizeof session->value_1)) and using length-limited formatting (e.g. ""%.*s"" with the bounded length) or otherwise ensuring the arrays are NUL-terminated within their storage bounds before calling these functions.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,21.14,True,"The code base uses memcmp to compare a header value to the literal ""close"" inside add_response_header_connection: mhd_assert (already_has_close == (0 == memcmp (hdr->value, ""close"", 5))); hdr->value is a null-terminated string and ""close"" is a null-terminated literal. Using memcmp for comparing null-terminated strings violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings).","The reported violation is not correct for the provided function. The body of fill_v1_v2_form contains no call to memcmp (it uses strlen, malloc, snprintf, and response helpers). Agent A’s scenario points to a different function (add_response_header_connection) where memcmp(hdr->value, ""close"", 5) was cited — that would be a concern if hdr->value is a null‑terminated string being compared via memcmp to a string literal, because MISRA C 2023 Rule 21.14 forbids using memcmp to compare null‑terminated strings. But that violation, if present, is in a different function, not in fill_v1_v2_form. Also, the test/instrumentation code failed to compile and provides no evidence affecting fill_v1_v2_form. Therefore the specific report that fill_v1_v2_form violates Rule 21.14 is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,8.13,False,"No violation: pointers that can be const are const (cls, mime). The non-const pointers are intentionally non-const because they are modified by called functions: 'session' is passed to add_session_cookie (likely mutates session), 'reply' is written by snprintf and later freed via the response free-callback, and 'connection'/'response' are used by APIs that modify their state. The (void *) cast on reply matches the API expecting a void * that will be freed. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,2.1,False,"No unreachable code found in fill_v1_v2_form. All statements are reachable depending on runtime conditions: the early returns handle malloc failure and response creation failure; error branches (e.g. failed header additions) log messages but do not contain dead code; normal execution proceeds to queue, destroy and return the result. There are no code constructs that are never reachable (no unconditional branches that skip later code), so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,1.2,False,"No compiler language extensions are used in fill_v1_v2_form. The function uses only standard C constructs (enum, casts, standard library functions like malloc, snprintf, free, and taking function pointer &free). No compiler-specific keywords or extensions are present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,fill_v1_v2_form,2.2,True,"The explicit cast-to-void statement '(void) cls;' is a no-op operation executed solely to silence an unused-parameter warning. Removing that single statement would not change program behaviour, so it constitutes dead code and thus violates MISRA C 2023 Rule 2.2.","The agent’s argument is not correct. While the expression statement ""(void) cls;"" has no runtime effect and removing it would not change program behaviour, MISRA’s intent here is to ban truly redundant/forgotten code that could hide logic errors — not the common, deliberate idiom used to document and suppress an unused-parameter warning. The single void-cast idiom is a well‑known, intentional means of marking a parameter as intentionally unused; it is not a latent logic fault and is the appropriate way to silence compiler warnings in many contexts. Therefore the presence of that statement should not be reported as a Rule 2.2 violation in practice. (If your project policy disallows the idiom, prefer other documented mechanisms such as compiler attributes, a project-wide UNUSED_PARAM macro, or omitting the parameter name where allowed.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,14.2,False,No for loop is present in serve_simple_form; Rule 14.2 (well-formed for loop) is therefore not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,17.8,False,"No violation: serve_simple_form does not assign to or otherwise modify any of its parameter variables. It copies the incoming cls pointer into a local const char *form and uses that local variable, and it calls add_session_cookie(session) which may modify the object pointed to by session (allowed by Rule 17.8). No pointer parameter itself is changed.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,21.17,True,"Calling strlen(form) where form is derived from the opaque parameter cls. If cls does not point to a NUL-terminated character array (for example, a fixed-length buffer passed without a terminating '\0'), strlen(form) will continue reading memory past the object's bounds until a NUL byte is found, causing an out-of-bounds access and undefined behavior.","The agent A report is correct. The call strlen(form) can read bytes past the end of the object referenced by cls unless cls is guaranteed to point to a NUL-terminated char array. The function's parameter is declared as const void *cls (opaque) and the code does not otherwise ensure or verify that cls references a NUL-terminated buffer, so strlen may access out-of-bounds memory and invoke undefined behavior. That violates MISRA C 2023 Rule 21.17, which forbids use of string.h functions that can access beyond the bounds of the referenced objects. (A NULL check alone is insufficient; absence of an explicit contract or a prior-checked length makes the use of strlen here unsafe.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,21.14,True,"The codebase uses memcmp inside add_response_header_connection to compare an existing response header value (hdr->value) against the literal ""close"" using memcmp(hdr->value, ""close"", 5). hdr->value is a null-terminated string (buf[pos] = 0 earlier), so memcmp is being used to compare null-terminated strings. This violates MISRA C 2023 Rule 21.14 (the Standard Library function memcmp shall not be used to compare null terminated strings).","Agent A's finding is correct in substance but needs a small clarification: the serve_simple_form() function you provided does not itself call memcmp, so it does not directly violate MISRA C:2023 Rule 21.14. However, serve_simple_form() calls MHD_add_response_header(), and Agent A reports that the implementation of add_response_header_connection (an internal helper invoked by MHD_add_response_header) contains a call like memcmp(hdr->value, ""close"", 5) where hdr->value was made null-terminated earlier (buf[pos] = 0). If that implementation is present as described, then memcmp is being used to compare null-terminated strings and that is a violation of MISRA C 2023 Rule 21.14. The provided test harness failing to compile does not invalidate the static code issue: using memcmp to compare null-terminated strings is forbidden by the rule and should be replaced by a string comparison function (e.g. strcmp/strncmp) or refactored so that memcmp is used only on non–null-terminated byte buffers.

Summary: the reported violation is correct if the internal add_response_header_connection contains the described memcmp on a null-terminated string. serve_simple_form itself does not contain the memcmp.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,8.13,False,"serve_simple_form does not violate Rule 8.13: all pointers that can and should be const are already const (cls -> const void *, mime -> const char *). The session pointer is passed to add_session_cookie which accepts a non-const struct Session *; serve_simple_form does not modify session itself but cannot change its parameter to const without changing the called function's prototype. No pointer is pointing to a const-qualified type while being modified, and no additional const-qualification is possible in the local function without altering other code, so the rule is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,2.1,False,No violation: serve_simple_form contains no unreachable code. All statements are reachable: MHD_create_response_from_buffer_static can return NULL triggering the early return; the fprintf branch runs when MHD_add_response_header returns MHD_NO; ret is assigned from MHD_queue_response and is returned after MHD_destroy_response. There are no dead branches or statements that cannot be executed at runtime.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,1.2,False,"No violation: serve_simple_form uses standard C constructs only (standard function definition, pointer casts, library calls). It does not use compiler-specific language extensions such as nested functions, statement expressions, typeof, asm, or GNU attributes.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,serve_simple_form,2.2,False,"No violation: serve_simple_form contains no dead code. All executed operations (creating the response, adding session cookie, attempting to add Content-Encoding header, queuing the response, destroying the response) contribute to program behaviour (response content/headers, connection state and diagnostics). The conditional fprintf is an observable side effect (diagnostic output) when header addition fails and thus cannot be considered dead. There is no unreachable code in the function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,14.2,False,"The function not_found_page contains no for loop statements. MISRA C 2023 Rule 14.2 applies to the well-formedness of for loops; since there are no for statements in this function (and no introduced code changes), the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,17.8,False,"No violation: not_found_page does not assign to any of its parameters (cls, mime, session, connection). It only casts unused parameters to void to silence warnings and passes pointer values to other functions; modifying the objects pointed to (via MHD_queue_response / MHD_add_response_header) is allowed by the rule, but the parameter pointers themselves are not reassigned or modified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,21.17,False,"No violation: not_found_page calls strlen(NOT_FOUND_ERROR) to obtain the exact length of the static, null-terminated string literal and passes that length and the pointer to MHD_create_response_from_buffer_static, which stores the buffer pointer and the explicit size. No subsequent string.h call in not_found_page dereferences beyond the provided buffer bounds. The call to MHD_add_response_header uses the provided mime as a header value (not the response buffer) and does not cause any out-of-bounds string access in this code path. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,21.14,True,"Violation occurs in add_response_header_connection where memcmp is used to compare hdr->value and the literal ""close"". hdr->value is a null-terminated string (buf[pos]=0 in the code that builds it), and the code uses memcmp(hdr->value, ""close"", 5) to detect the presence of the token. Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.","The asserted violation is incorrect for the provided not_found_page code. Rule 21.14 forbids using memcmp to compare null-terminated strings, but the target function does not call memcmp anywhere. The only call that could lead to library code doing comparisons is MHD_add_response_header, but that is part of libmicrohttpd (not shown). Agent A’s scenario points at add_response_header_connection (a library internals function) rather than the not_found_page function itself. The supplied modified test code failed to compile and produced no evidence. Conclusion: you cannot conclude that the shown not_found_page code violates MISRA C 2023 Rule 21.14. If a violation exists it would be in the library implementation (inspect the add_response_header_connection source); if that code uses memcmp to compare null-terminated strings, replace with strcmp/strncmp or otherwise avoid memcmp on NUL-terminated strings to comply with Rule 21.14.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,8.13,False,"No violation. The function not_found_page declares cls and mime as pointers to const (const void *cls, const char *mime) and passes them to APIs that accept const pointers. It does not attempt to modify the objects pointed to by those pointers. Other non-const pointers (session, connection, response) are non-const because they are used with functions that may modify the pointed objects. Therefore Rule 8.13 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,2.1,False,"No reachable-unreachable-code scenario: the function not_found_page contains no unreachable statements. All branches (response allocation failure, queueing response, header addition failure) can be reached at runtime depending on allocation and API return values, so there is no unreachable code in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,1.2,False,"The function not_found_page and related code use only standard C language constructs (static function, enum return type, casts, (void) to silence unused-parameter warnings, standard library calls like strlen and fprintf). No compiler-specific keywords, attributes, inline assembler, or other documented compiler extensions are present in the provided code, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,not_found_page,2.2,True,The two explicit casts to void — “(void) cls;” and “(void) session;” — are executed no-op statements whose removal would not affect program behaviour. They therefore constitute dead code per MISRA C 2023 Rule 2.2.,"The report is not correct. The two (void) casts are the common idiom to mark parameters intentionally unused and to suppress compiler warnings; they have no side effects but are not the kind of ‘‘dead code’’ intended by MISRA C Rule 2.2. Rule 2.2 targets code that is executed yet superfluous to program behaviour (and in practice covers unreachable/useless computations or statements that should be removed). Marking unused parameters with (void)param is a deliberate and documented no-op and is an accepted way to indicate intent — it does not constitute a MISRA 2.2 violation in this context. If you prefer to avoid the casts, you can (a) omit the parameter names in the function definition if allowed by your style, or (b) use a documented UNUSED macro; but that is a stylistic change, not a Rule 2.2 requirement.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,14.2,False,"Not applicable: create_response contains no for statements. The only loop present is a while loop that increments a single counter (i) in its body: i = 0; while ((pages[i].url != NULL) && (0 != strcmp (pages[i].url, url))) i++; Hence Rule 14.2 (for-loop well-formedness) is not violated by this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,17.8,True,"create_response reassigns pointer parameters 'method' and 'url'. Specifically, the code contains 'method = MHD_HTTP_METHOD_GET;' and 'url = request->post_url;'. These statements modify the pointer parameters themselves (the pointer variables), which violates MISRA C 2023 Rule 17.8: a function parameter shall not be modified.","Agent A is correct. The code reassigns the pointer parameters 'method' and 'url' (statements method = MHD_HTTP_METHOD_GET; and url = request->post_url;), which modifies the pointer parameters themselves. MISRA C 2023 Rule 17.8 prohibits modifying function parameters; while the object referred to by a pointer parameter may be modified, the pointer variable itself shall not be changed. (Modifying *req_cls is allowed because that changes the object referenced, not the parameter variable.) To comply, assign the incoming parameters to local variables (e.g. const char *local_method = method; const char *local_url = url;) and modify those locals instead of the parameter variables.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,21.17,False,"No violation: create_response only calls standard string functions with well-defined, null-terminated string objects. strcmp is used to compare method against constant string literals (e.g. MHD_HTTP_METHOD_POST/GET/HEAD) and to compare pages[i].url (a table of null-terminated strings) to url; strlen is applied to the string literal METHOD_ERROR. These uses do not read beyond the bounds of the referenced objects. Therefore Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,21.14,False,"No violation: create_response and its callees do not use memcmp to compare null-terminated strings. All string comparisons in create_response use strcmp (e.g. comparing method and url) or bounded/caseless helper functions (e.g. MHD_str_equal_caseless_n_), and buffer operations use memcpy/memmove for copying, not memcmp for string comparison. Therefore Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,8.13,False,"No violation: pointers to const are used where the pointed-to data is not modified. The function only reassigns the const char * parameters (method, url) to point to other const strings, it does not modify the characters they point to. Functions that modify objects (e.g. post_iterator modifying session->value_1/value_2, create_response updating session->start, request->pp, etc.) receive non-const pointers (struct Request *, struct Session *), so no const-qualified pointer is used to modify its pointee. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,2.1,False,"No unreachable code in create_response: all statements are guarded by runtime conditions or reachable via the function's control flow. The initial allocation branch (request == NULL) returns early only when appropriate; POST handling (method == ""POST"") is conditional and its early returns depend on runtime return values and upload_data_size; the GET/HEAD dispatch is conditional and reachable when method matches; the final fallback that creates METHOD_ERROR is reachable for unsupported methods. There are no constant false conditions or statements that are provably never executed, so Rule 2.1 is not violated for this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,1.2,False,"No compiler-specific language extensions detected. The function and referenced code use only standard C constructs (function definitions, casts, standard types like size_t, uint64_t, time_t, usual library calls, and macros). There are no __attribute__, __asm, typeof, statement-expressions, inline assembly, or other compiler-specific keywords present in create_response or the nearby functions. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/post_example.c,create_response,2.2,True,"The two explicit (void) casts at the start of create_response — (void) cls; and (void) version; — are executed no-op statements. They do not affect program behaviour and therefore constitute dead code under MISRA C 2023 Rule 2.2. A concrete scenario: whenever create_response is called (any HTTP request), these two statements are executed but removing them would not change the observable behaviour of the program.","The report is not correct. The two lines “(void) cls;” and “(void) version;” are the idiomatic way in C to mark parameters as intentionally unused and to suppress compiler warnings. Although they are syntactically expressions with no effect, they are not the kind of ‘‘dead code’’ MISRA 2.2 targets (code that can be removed without intended documentation/clarity or without changing program behaviour in a meaningful way). In practice compilers will typically generate no runtime effect for these casts, and MISRA guidance and common interpretation treat these casts as an explicit documentation/suppression mechanism rather than removable dead code. The provided instrumentation attempt (which failed to compile) does not demonstrate a MISRA 2.2 violation. If a project policy disallows this idiom, that would be a separate (project-specific) rule, but under MISRA C 2023 Rule 2.2 the agent A’s claim is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,14.2,False,"No for loop present in ahc_echo; Rule 14.2 (well-formed for loop) is not applicable. The function contains no for statements, so there are no loop counters, second- or third-clause side effects, or body modifications to check.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,17.8,False,"No violation in the provided ahc_echo: the function modifies *req_cls (the object pointed to by the pointer parameter req_cls) but does not assign to the parameter variable req_cls itself. Per MISRA C 2023 Rule 17.8 the object referred to by a pointer parameter may be modified, while the pointer parameter itself shall not be modified. A concrete violating change would be, for example, assigning to the parameter variable (e.g. req_cls = &already_called_marker;) or assigning to another parameter variable (e.g. connection = some_value;). Such an assignment to the parameter itself would violate Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,21.17,False,"No violation: ahc_echo only calls strlen on PAGE and DENIED, which are string literals (NUL-terminated). These strlen calls read up to the terminating NUL within the bounds of the literals. No other <string.h> functions are used on potentially undersized buffers, so there is no out-of-bounds access via string handling functions in this function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,21.14,False,No violation: the ahc_echo function and related code do not call memcmp to compare null-terminated strings. String comparisons are done either by MHD_str_equal_caseless_ (char-by-char until '\0') or by size-limited comparisons (e.g. MHD_str_equal_caseless_bin_n_ or explicit key_size checks). Only memcpy/memchr/strlen are used; no memcmp is used to compare NUL-terminated strings.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,8.13,False,"No violation. All pointers to character data that are not modified are declared as pointers to const (e.g. url, method, version, upload_data, username, password, realm). Pointers used to modify the pointed object (e.g. req_cls is void ** and the function stores a marker address into *req_cls, and response/connection objects are non-const because they are passed to API functions that mutate or destroy them) are non-const as required. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,2.1,False,"No unreachable code. The conditional that checks if (&already_called_marker != *req_cls) is a runtime-dependent branch: on the first invocation the function returns early (setting *req_cls), and on subsequent invocations the remainder of the function is executed. There are no constant false/true conditions, no code guarded by predicates that can never hold, and no statements after unconditional returns that are unreachable. All code paths are potentially reachable at runtime, so Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,1.2,False,"No compiler-specific language extensions are used in ahc_echo or the provided supporting code. There are no uses of __attribute__, __asm__, __builtin_*, typeof, __extension__, or other vendor-specific keywords; only standard C constructs and conditional compilation macros are present. Therefore Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example.c,ahc_echo,2.2,True,"The series of explicit void-cast statements used solely to silence compiler warnings (e.g. (void) cls; (void) url; etc.) are executed statements that have no effect on program behaviour. Their removal would not change runtime behaviour, so they constitute dead code per MISRA C 2023 Rule 2.2.","The report is not correct. MISRA C 2023 Rule 2.2 targets truly dead code whose removal would not affect the program’s observable behaviour. The explicit (void) parameter casts in ahc_echo are a standard, deliberate idiom to document and suppress “unused parameter” diagnostics. They are not ordinary dead code in the sense that they carry intent (documentation) and can affect compilation and generated code (and therefore potentially timing or side‑effects in corner cases such as volatile/trap representations). MISRA practice permits explicit unused‑parameter annotations; removing them only affects diagnostics and possibly compiler code generation, not the semantic intent of the function. Therefore the agent A claim that those (void) casts are a Rule 2.2 violation is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,14.2,False,"No violation: the for loop ""for (i = 0; i < (size_t) res; i++)"" is well-formed. The first clause initializes the single loop counter i, the second clause uses i and the unmodified object res (no persistent side effects and res is not modified in the loop body), and the third clause increments only the loop counter. The loop body modifies fn[i], which is not used in the loop clauses. Therefore MISRA C 2023 Rule 14.2 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,17.8,False,"No violation: process_upload_data does not modify any of its parameters. The pointer parameter 'cls' is assigned to a local pointer 'uc' and only the object it points to is modified (allowed by the rule). Other parameters (kind, key, filename, content_type, transfer_encoding, data, off, size) are only read or cast to void, not written. Therefore Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,21.17,False,"No violation: the code’s uses of <string.h> functions (strcmp, strstr, strchr, snprintf, strdup) do not result in out-of-bounds accesses. The function checks for NULL where needed (filename, uc->category, uc->language), uses snprintf which is bounds-safe, and checks the return value of the second snprintf before indexing the buffer. There are no calls that can read past object bounds under the shown logic.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,21.14,False,"No violation in the provided code. The function uses strcmp to compare null‑terminated strings (e.g. if (0 == strcmp(key, ""category"")) and if (0 != strcmp(key, ""upload""))). There is no use of memcmp to compare null‑terminated strings. A specific violation scenario (hypothetical): if the code instead used memcmp(key, ""upload"", strlen(""upload"") + 1) or memcmp(key, ""upload"", 6) to test equality, that would violate MISRA C 2023 Rule 21.14. For example, replacing the check if (0 != strcmp(key, ""upload"")) with if (0 != memcmp(key, ""upload"", strlen(""upload"") + 1)) and executing the upload control path when key == ""upload"" would demonstrate the rule violation.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,8.13,False,"No violation: all input character buffers are declared as const where appropriate (key, filename, content_type, transfer_encoding, data). Functions that modify pointed-to objects (do_append modifies *ret and the UploadContext fields like uc->filename) accept non-const pointers. The write() call accepts a const void * buffer per POSIX, so passing data (const char *) is correct. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,2.1,False,"No violation: all statements in process_upload_data are reachable along some control-flow paths. The function performs early returns for keys ""category"" and ""language"", returns for unexpected keys, and otherwise proceeds through checks (filename NULL, missing form data, fd == -1 creating/opening file, write error handling) to the final return. There are no statements that cannot be reached due to constant conditions or mutually exclusive guards; platform-specific blocks are conditional compilation, not unreachable code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,1.2,False,"No violation: process_upload_data does not use any compiler language extensions. It uses standard C constructs (function, casts, standard library and POSIX calls, preprocessor conditionals) but no compiler-specific extensions such as __attribute__, asm, typeof, statement expressions, nonstandard calling conventions, or other features documented as extensions by compilers. The conditional compilation and casts are standard C preprocessor and casting, and platform-specific macros (e.g. _WIN32, O_LARGEFILE) are ordinary portability checks, not language extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,process_upload_data,2.2,True,"The explicit (void) casts for unused parameters (kind, content_type, transfer_encoding, off) are executed but have no effect on program behaviour; removing them would not change the program's behaviour, so they constitute dead code under MISRA C 2023 Rule 2.2.","The report is not correct. Agent A has misapplied Rule 2.2. The four lines “(void) kind; (void) content_type; (void) transfer_encoding; (void) off;” are the common, documented idiom to mark parameters as intentionally unused and to suppress compiler warnings. They are no-op expression-statements that have no side-effects in this code; removing them would not change the program semantics — but MISRA’s intent is to ban genuinely superfluous or unreachable code that indicates a design/maintenance problem, not to forbid the well-known, deliberate ‘‘cast-to-void’’ idiom used to document unused parameters or to suppress spurious diagnostics. In practice MISRA guidance recognises such idioms (or otherwise permits handling unused parameters via omitting the parameter name in the function definition, or via an agreed project annotation/macro). If a project policy prefers to avoid the cast-to-void lines, use an accepted alternative (e.g. omit the parameter name in the function definition where allowed or use a project macro to mark unused parameters) or provide a documented deviation. The provided test code failing to compile does not change this judgement.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,14.2,False,The function generate_page contains no 'for' statements. Therefore MISRA C 2023 Rule 14.2 (requirements on well-formed for loops) is not applicable to this function and is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,17.8,False,"No violation. The function only modifies the objects pointed to by pointer parameters (for example: *upload_data_size = 0; *req_cls = uc; uc->connection = connection; and writes into structures obtained via pointers). These are allowed by MISRA C 2023 Rule 17.8 (the pointed-to object may be modified). The code does not reassign any of the pointer parameters themselves (there are no statements like req_cls = ..., upload_data_size = ..., url = ..., method = ..., connection = ...), and const-qualified pointers (e.g. const char *url) are not modified.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,21.17,True,"When the function is called with an empty URL string (url == """"), the initial strcmp(url, ""/"") check is true so the code enters the file-download branch. The code subsequently uses &url[1] (for strstr and to read url[1]) and strrchr(&url[1], '.') which accesses one-past-end for the empty string (url has only the terminating '\0'), causing out-of-bounds access. This is a violation of MISRA C 2023 Rule 21.17.","The report is correct. If generate_page is called with url == """" (a zero-length string), the initial check (0 != strcmp(url, ""/"")) evaluates true and the code enters the file-download branch. That branch immediately uses &url[1] in calls such as strstr(&url[1], "".."") and strrchr(&url[1], '.'), and also dereferences url[1] in the test ('/' != url[1]). For an empty string the storage contains only the terminating '\0' at index 0, so &url[1] is a pointer one-past-the-end of the array; passing that pointer to string.h functions (which will attempt to read characters) or dereferencing url[1] results in reading beyond the bounds of the object. MISRA C 2023 Rule 21.17 forbids such uses of the string-handling functions that can access beyond object bounds. Therefore the scenario described by agent A demonstrates a real violation. A correct remediation is to check the URL length (or test url[0] != '\0' and ensure url has at least two elements) before using &url[1] or dereferencing url[1].",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,21.14,True,"Violation occurs in add_response_header_connection: the code uses memcmp to compare an existing Connection header value with the literal ""close"" (mhd_assert (already_has_close == (0 == memcmp (hdr->value, ""close"", 5)))). This performs a memcmp-based comparison against a null-terminated string (hdr->value is treated as a NUL-terminated buffer earlier: buf[pos] = 0). The problematic control path is when MHD_add_response_header is called for the ""Connection"" header while a Connection header is already present (i.e. updating an existing header). In that situation add_response_header_connection reaches the branch that contains the memcmp call and compares hdr->value (a null-terminated C string) to the literal ""close"" using memcmp, violating MISRA C 2023 Rule 21.14.","The reported violation is not correct as stated. The generate_page function shown does not itself call memcmp nor perform any direct comparison of null‑terminated strings with memcmp. The agent’s scenario points to a memcmp call inside add_response_header_connection (invoked indirectly via MHD_add_response_header) — if that function actually calls memcmp to compare hdr->value against ""close"" and hdr->value is a NUL‑terminated C string, then that other function would violate MISRA C 2023 Rule 21.14. However, that violation would belong to add_response_header_connection (or wherever the memcmp is used), not to generate_page. The test code did not compile and no direct evidence was produced that generate_page itself contains the forbidden memcmp. In short: the underlying memcmp usage (if present) would be a valid MISRA finding, but agent A’s claim that generate_page itself violates Rule 21.14 is incorrect — the violation would be in the other function invoked by generate_page, not in generate_page’s code shown.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,8.13,False,"No violation. All character-buffer pointers that are not modified are const-qualified (url, method, version, upload_data). Pointers that are non-const are deliberately so because the function modifies the referenced objects (size_t *upload_data_size is written to; void **req_cls is used to store/retrieve the UploadContext pointer; struct UploadContext *uc fields are modified). The unused void *cls parameter is part of the required callback signature and cannot be changed. Therefore Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,2.1,False,"No violation: generate_page contains no unreachable code. All conditional branches either return a result or proceed to reachable code; the #ifdef/#endif sequence around libmagic is structured so the 'mime = NULL;' assignment is the matching 'else' when libmagic is enabled and simply the only statement when it is not, so there is no dead (unreachable) block. Local blocks and early returns are all reachable depending on runtime inputs (url and method).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,1.2,False,"No language extensions used: the function uses only standard C and POSIX APIs and preprocessor conditionals; no compiler-specific extensions (e.g. nested functions, typeof, asm, __attribute__, statement expressions) are present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,generate_page,2.2,True,The two explicit no-op casts at function start—(void) cls and (void) version—are executed operations that have no effect on program behaviour; their removal would not change functionality (they only suppress compiler warnings). Therefore the project contains dead code violating MISRA C 2023 Rule 2.2.,"Agent A is correct. The two statements ""(void) cls;"" and ""(void) version;"" are executed no-op expressions: they perform no observable action and their removal would not change program behaviour. Under MISRA C 2023 Rule 2.2 (""Any operation that is executed but whose removal would not affect program behaviour constitutes dead code""), these statements meet the definition of dead code and therefore constitute a violation. Note: this is a common idiom to suppress compiler warnings, but that intent does not change the fact that the operations are executed and have no effect. To comply, remove the statements and instead use alternatives such as omitting the parameter name in the function definition (e.g. ""void * /*cls*/"") or use compiler-specific/standard ways to indicate intentionally unused parameters (macros or attributes) that do not introduce executed no-op code.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,14.2,False,"No violation: both for loops are well-formed. Each loop initializes a single loop counter in the first clause (language_idx, category_idx), the second clause tests the counter by indexing constant arrays (languages[...] and categories[...]) which are not modified in the loop body and have no persistent side effects, and the third clause only increments the respective loop counter. The counters are not modified elsewhere in the loop body. Thus MISRA C 2023 Rule 14.2 is satisfied.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,17.8,False,"No violation: update_directory has no parameters to modify. All pointer objects passed to helper functions (e.g., list_directory takes struct ResponseDataContext *rdc) are not reassigned; only the objects they point to (fields of *rdc) are modified, which is permitted by the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,21.17,False,"No violation. The uses of strlen and memcpy are guarded by explicit size checks that ensure the number of bytes copied is strictly less than the allocated buffer size (initial header: rdc.buf_len > len; footer: rdc.buf_len - rdc.off > len). All memcpy/strlen calls reference objects whose bounds are respected, so there is no out-of-bounds access of the pointer parameters to the <string.h> functions. Note: there is a logic bug (the final memcpy writes to rdc.buf instead of &rdc.buf[rdc.off], which likely overwrites earlier data), but this does not cause an access beyond the bounds of the destination buffer and thus does not violate MISRA C 2023 Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,21.14,False,"No violation in update_directory: the function does not call memcmp to compare null-terminated strings. It uses memcpy for copying known byte counts, strlen for lengths, and snprintf/stat for operations. There is no memcmp usage in this function (nor any direct comparison of C-strings via memcmp); therefore Rule 21.14 is not violated here. Note: helper functions (e.g. MHD_str_equal_caseless_) in other translation units may use memcmp internally, but that is outside the scope of update_directory and was not present in the provided function.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,8.13,False,No violation: pointers that are not used to modify the pointed-to objects are const-qualified (language is const struct Language *; category is const char *). Pointers that are used to modify objects are non-const as required (rdc.buf and dir_name are writable and used as destinations for snprintf/memcpy and for list_directory). Therefore Rule 8.13 is not violated in the shown update_directory implementation.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,2.1,False,"No unreachable code detected. All return statements are conditional (e.g. malloc failure, buffer-too-small checks, stat() failures, snprintf() errors, list_directory() returning MHD_NO) and can be reached at runtime depending on inputs and environment. The final footer-copy path is reachable when the language/category loops complete normally. (Note: there is a likely logic bug where the footer is copied with memcpy(rdc.buf, INDEX_PAGE_FOOTER, len) instead of copying at rdc.off, but that is a correctness issue, not unreachable code.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,1.2,False,"No language extensions detected: update_directory and the provided helper code use standard C and POSIX APIs only (malloc, snprintf, stat, opendir, readdir, realloc, etc.). There are no compiler-specific extensions such as GCC __attribute__, nested functions, statement expressions, typeof, or inline assembler in the shown update_directory implementation.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/demo.c,update_directory,2.2,False,"No violation: review of update_directory and related code did not reveal any executed operations that are removable without affecting program behaviour. All executed statements (allocations, memcpy, snprintf, stat, list_directory, free, update_cached_response, MHD response creation and header manipulation) have observable effects relied on by subsequent calls or state (including the static initial_allocation update).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,14.2,False,"No for-loops are present in the function print_perf_warnings, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,17.8,False,"No violation: print_perf_warnings has no function parameters, so there are no parameters to modify. A representative violation scenario would be if the function accepted a pointer or scalar parameter and assigned to the parameter itself (e.g., void f(int *p) { p = NULL; } or void g(int x) { x = 0; }), which would violate Rule 17.8 (reassigning the parameter variable). Note that modifying the pointee (e.g., *p = 1) is allowed, but reassigning p is not.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,21.17,False,No violation: print_perf_warnings does not call any functions from <string.h> (only fprintf and printf are used) so there is no risk of out-of-bounds accesses via standard string handling functions.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,21.14,False,"No violation in the provided function. The function print_perf_warnings does not call memcmp or otherwise use the standard library function memcmp to compare null-terminated strings. (A specific violation scenario would be, for example, if the code compared two C strings using memcmp(s1, s2, strlen(s1)) or memcmp(s1, s2, n) where n is derived from one string length — that would violate MISRA C 2023 Rule 21.14.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,8.13,False,No pointer variables are declared or used in print_perf_warnings. The function only uses integer locals and passes string literals and integer values to fprintf/printf and calls MHD_is_feature_supported (no pointer parameters in the shown code). Thus there is no pointer that should or should not point to a const-qualified type — Rule 8.13 is not applicable here.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,2.1,False,"No violation. The function contains conditional compilation and runtime checks, but there is no statically unreachable statement in the compilation unit. All blocks that exist after preprocessing can be executed depending on build-time macros or runtime results (e.g. MHD_is_feature_supported may return MHD_YES when _DEBUG is defined), and the final if (newline_needed) is a normal runtime guard. Therefore Rule 2.1 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,1.2,False,"No violation: the function uses standard C constructs only (static function, preprocessor conditionals, fprintf/printf, integer ops). The use of checks like defined(__GNUC__) and __OPTIMIZE__ are conditional compilation macros, not language extensions; no compiler-specific language extensions (e.g. __attribute__, nonstandard keywords, inline assembler, or other documented compiler extensions) are present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,print_perf_warnings,2.2,False,"No violation. Every executed statement in print_perf_warnings either emits a diagnostic (fprintf) or updates newline_needed which affects whether the trailing newline is printed. Removing any of those executed operations would change observable program behaviour (output to stderr or stdout). Conditional compilation may omit code entirely, but omitted code is not executed and therefore not dead code per MISRA 2.2 (note 2).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,14.2,False,"No for loop is present in the detect_cpu_core_count function, so MISRA C 2023 Rule 14.2 (well-formed for loop) is not applicable. (Note: other helper functions in the additional code contain for loops, but the target function itself contains none.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,17.8,False,"The function detect_cpu_core_count has no parameters. Rule 17.8 concerns modification of function parameters (or modifying pointer parameters themselves); since there are no parameters to modify, the rule is not applicable to this function and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,21.17,False,"No violation: detect_cpu_core_count itself does not call any <string.h> functions. The only uses of string.h functions in the provided surrounding code are safe memset() calls that use sizeof on the actual destination objects (for example memset(&psd_data, 0, sizeof(psd_data)) and memset(&sysInfo, 0, sizeof(sysInfo))). There are no calls to strcpy/strncpy/strcat/strncat/memcpy/memmove/memcmp/strlen/strspn on buffers where the length argument or source/destination pointers could lead to out‑of‑bounds access in the shown code paths.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,21.14,False,No violation: the function detect_cpu_core_count and the related functions do not call or use memcmp to compare null-terminated strings. String handling in the provided code is limited to format strings passed to fprintf/printf and literal comparisons (none present) — there is no use of memcmp for string comparison in the shown code paths.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,8.13,False,"No pointers are used in detect_cpu_core_count; the function uses only integer variables and calls to other functions. There is neither a pointer parameter nor any pointer object in the function, so MISRA C 2023 Rule 8.13 (pointer const-qualification) is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,2.1,False,No reachable-code violation: all branches in detect_cpu_core_count are reachable depending on runtime return values of mhd_tool_get_system_cpu_count() and mhd_tool_get_proc_cpu_count(). The #ifdef block is controlled by conditional compilation (may remove code if MHD_REAL_CPU_COUNT is not defined) but that is not an instance of unreachable code within the compiled project. Therefore Rule 2.1 is not violated.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,1.2,False,"No language extensions are used. The function uses only standard C constructs (conditional compilation, standard library functions fprintf/printf, integer types, and casts). There are no compiler-specific keywords, attributes, built-in functions, inline assembly, statement-expressions, or other documented compiler extensions present in detect_cpu_core_count or the related helper functions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/tools/perf_replies.c,detect_cpu_core_count,2.2,False,"No violation. The function detect_cpu_core_count contains no dead code: all executed statements (assigning sys_cpu_count, fallback assignments, fprintf/printf calls, and the final return) affect program behaviour (values returned or observable output). Conditional compilation (e.g. #ifdef MHD_REAL_CPU_COUNT) does not introduce dead code — the code is either compiled in or out. There are no executed operations whose removal would leave behaviour unchanged.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,14.2,False,No for-loop statements are present in the ahc_echo function; therefore MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,17.8,False,No violation: the function modifies the object pointed to by the pointer parameter req_cls (assigns to *req_cls) but does not modify the pointer parameter variable req_cls itself. The (void) casts are not modifications. Modifying the pointee is permitted by Rule 17.8; only changing the pointer parameter would violate the rule.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,21.17,True,"A caller provides a url pointer that is not a valid NUL-terminated C string (for example a buffer that does not contain a terminating '\0' within its allocated bounds). The call to strstr(url, ""../"") scans the url buffer until a NUL byte is found; if the url buffer is not NUL-terminated within its bounds this will read beyond the end of the object referenced by 'url' and thus violate MISRA C 2023 Rule 21.17.","The report is correct in the sense that the code as written can cause a <string.h> routine to read past the bounds of the object referenced by its pointer parameters unless a caller-side guarantee exists that the parameters are valid NUL-terminated strings. Specifically:

- strstr(url, ""../"") requires that url points to a NUL-terminated character array. The function does not check url for NULL nor otherwise validate that it is NUL-terminated within its allocated bounds. If a caller passes a buffer that is not NUL-terminated within its object bounds, strstr will scan beyond the object and thus can violate MISRA C 2023 Rule 21.17.
- Similarly, strcmp(method, ""GET"")/strcmp(method, ""HEAD"") assume method is a NUL-terminated string and are unchecked.
- The later use open(url + 1, ...) also assumes url is at least one byte long and NUL-terminated; if url points at an empty string or not NUL-terminated this can produce out-of-bounds reads when the open implementation reads the pathname.

If the surrounding API (the code that calls ahc_echo) provides a documented, enforced contract that url and method are non-NULL and NUL-terminated within their object bounds, then the call sites comply with Rule 21.17 because the preconditions are satisfied by the caller. However, the ahc_echo implementation itself does not validate those preconditions, so in the absence of a guaranteed caller contract the code is potentially non-compliant. MISRA expects either that such preconditions are established by the calling context (and that this is documented/assured) or that the function checks/limits accesses (for example by using bounded string functions or by checking lengths) to ensure no out-of-bounds access can occur.

Therefore Agent A’s scenario is a valid demonstration of a potential Rule 21.17 violation unless a caller-side guarantee is present; the report is correct as a potential violation.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,21.14,True,"When a response already contains a ""Connection"" header and its value equals the token ""close"" (stored as a null-terminated string), add_response_header_connection uses memcmp(hdr->value, ""close"", 5) to test equality. That call uses memcmp to compare a null-terminated string (hdr->value) against a literal, which violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings).","The report is correct in substance. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null‑terminated strings. If, as the scenario states, add_response_header_connection calls memcmp(hdr->value, ""close"", 5) while hdr->value is a NUL‑terminated C string (buf[pos] = 0 makes it so), that use of memcmp is a MISRA 21.14 violation. Note that the ahc_echo code shown does not itself contain memcmp; the alleged violation lies in the other function (add_response_header_connection). If hdr->value were non‑NUL terminated binary data then memcmp would be appropriate, but given the scenario (hdr->value made NUL‑terminated) the report is correct and the code should use a string comparison function (e.g. strcmp/strncmp with proper length checks or otherwise ensure the comparison is not performed on null‑terminated strings).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,8.13,False,"No violation: the function uses const-qualified pointers for input character data (method, url, version, upload_data). The mutable pointers (e.g. void **req_cls, void *cls, and the pointer stored in *req_cls) point to non-const objects that the function may modify, so they must not be const. The upload_data_size parameter appears unused in this callback but its non-const type is imposed by the external callback signature and cannot be made const here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,2.1,False,"No violation: all code paths in ahc_echo are reachable depending on inputs. The initial early return (when method is not GET/HEAD) and the first-call check using &aptr vs *req_cls intentionally return early, but subsequent calls reach the rest of the function (file-open, stat, response-creation). There is no dead/unreachable statement that can never be executed; each block can be executed under some valid combination of inputs and states.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,1.2,False,"No violation: the function uses only standard C constructs (enum, pointers, casts, standard POSIX APIs like open/fstat/close, and uint64_t from stdint.h). No compiler-specific language extensions (such as GCC statement-expressions, __attribute__, typeof, nested functions, or inline assembler) are present in the provided ahc_echo code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example.c,ahc_echo,2.2,True,"The explicit cast-to-void expression statements at the start of ahc_echo — (void) cls; (void) version; (void) upload_data; (void) upload_data_size; — are executed but have no effect on program behaviour. Removing them would not change program behaviour, so they constitute dead code under MISRA C 2023 Rule 2.2.","Agent A is correct. The four expression-statements (void) cls; (void) version; (void) upload_data; (void) upload_data_size; are executed but have no effect on the observable program behaviour in this function: they do not modify state, do not produce side-effects, and removing them would not change the function's behaviour (they only exist to suppress compiler warnings). Under the quoted MISRA C 2023 Rule 2.2 (“Any operation that is executed but whose removal would not affect program behaviour constitutes dead code”), those statements meet the definition of dead code.

Note: a possible exception is if a parameter is volatile (or its evaluation has other side-effects); in that case the read could be observable and the statement would not be dead. In the supplied ahc_echo code the parameters are ordinary non-volatile pointers/objects, so the (void) casts are dead code. Also note that while this idiom is common to silence unused-parameter warnings, it still violates the literal wording of Rule 2.2 unless an approved deviation or alternative suppression mechanism is used.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,14.2,False,"No violation: the for loop ""for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)"" in parse_dauth_params conforms to Rule 14.2 — the first clause initializes the single loop counter p, the second clause is a side-effect-free compile-time constant bound, and the third clause increments only the loop counter. No other for loops in parse_dauth_params violate the rule.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,17.8,False,"No violation. parse_dauth_params updates members of the object pointed to by the pointer parameter 'pdauth' (e.g. pdauth->userhash, pdauth->algo3, pdauth->qop) which is allowed by MISRA 17.8; it does not assign to or otherwise modify the pointer parameter variables themselves ('pdauth' or 'str').",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,21.17,False,"No violation. The only <string.h> function used in parse_dauth_params is memset(&userhash, 0, sizeof(userhash)) and memset(&algorithm, 0, sizeof(algorithm)), both of which operate on the full objects with their correct sizeof values. All byte-wise comparisons and calls to MHD_str_equal_caseless_bin_n_ pass a length that is guarded by checks (tk_name->len <= left where left = str_len - i), so MHD_str_equal_* is only invoked with buffer sizes that are within the provided str_len bounds. All other parsing advances check str_len before indexing. Therefore no use of string.h functions can access beyond object bounds.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,21.14,False,"No violation: parse_dauth_params and the helper comparison functions use custom length-bounded comparison routines (e.g. MHD_str_equal_caseless_bin_n_ and related macros) rather than memcmp. These routines iterate and compare characters case-insensitively and operate on explicit lengths (not on null-terminated strings). There is no use of the standard memcmp to compare NUL-terminated strings, so Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,8.13,True,"The function assigns slices of the input const char *str into parameter structures whose member 'value.str' is a non-const pointer (param->value.str = str + value_start). This stores a pointer to const data into a non-const pointer, which violates MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible). The problematic assignment is at: param->value.str = str + value_start;","Agent A’s report is correct in the relevant case. The code assigns a pointer derived from the function parameter str (type const char *) into param->value.str. If MHD_RqDAuthParam::value.str is declared as a non-const pointer (char *), that stores a pointer to const data into a non-const pointer and therefore discards the const qualifier — this contradicts MISRA C 2023 Rule 8.13, which requires pointers to point to const-qualified types whenever possible. The only situation in which this would not be a violation is if value.str is already declared as const char * (or if the pointed-to object must be modified later, in which case the rule’s exception could apply). In short: given the test code (where value.str is non-const) and the shown assignment (param->value.str = str + value_start;), the reported violation of Rule 8.13 is valid.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,2.1,False,"No unreachable code found. All statements in parse_dauth_params are reachable depending on input: early return statements are conditional on input/state (malformed headers, missing separators, etc.), the main parsing loop can exit to the post-processing section, and the post-processing code is reachable when parsing completes. No unconditional dead code or statements placed after an unconditional return were detected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,1.2,False,"No language extensions are used. The function uses standard C constructs and project macros (e.g. _MHD_S_STR_W_LEN) and standard types (bool). There are no compiler-specific extensions (such as GCC/MSC attributes, inline assembly, typeof, statement-expressions, zero-length arrays, or other documented compiler extensions) present in parse_dauth_params.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/gen_auth.c,parse_dauth_params,2.2,False,"No dead code detected: every assignment, branch and loop in parse_dauth_params is used to parse and validate input and to populate pdauth; temporary variables userhash and algorithm are consumed in postprocessing. No executed operations were identified that could be removed without changing behavior.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,14.2,False,"MHD_queue_basic_auth_required_response3 contains no for-statement; Rule 14.2 (well-formed for loops) is therefore not applicable to this function. (Other provided helper functions in the additional code do contain for-loops, but they are outside the target function.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,17.8,False,"No violation: none of the function parameters are assigned to or altered. The function reads 'connection', 'realm', 'prefer_utf8' and uses 'response' in calls but does not modify the pointer parameters themselves (only objects they point to may be modified via other calls), so Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,21.17,True,"If the caller passes a NULL realm pointer, the call to strlen(realm) will dereference a NULL pointer and thus the use of the string function strlen results in an access beyond the bounds of the object referenced by its pointer parameter (invalid pointer). This triggers a violation of MISRA C 2023 Rule 21.17.","Agent A is correct. In the original MHD_queue_basic_auth_required_response3 the code calls realm_len = strlen(realm) without checking whether realm is NULL. If a caller passes NULL for realm this will dereference an invalid (NULL) pointer and invoke undefined behavior. That is exactly the kind of out-of-bounds / invalid access of a string.h routine that MISRA C 2023 Rule 21.17 forbids. (MHD_str_quote later would also access realm, but the immediate strlen(realm) alone is sufficient to demonstrate the violation.) To fix, the function must ensure realm is non-NULL before calling strlen/other string.h functions (for example by treating NULL as an empty string or returning an error), or the API must be constrained/documented and enforced so the pointer can never be NULL.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,21.14,True,"The code uses memcmp to compare what are effectively null-terminated strings: in add_response_header_connection there is an assertion that uses memcmp(hdr->value, ""close"", 5). hdr->value is a NUL-terminated buffer (buf[pos] = 0 earlier) and the literal ""close"" is also NUL-terminated. Using memcmp for string comparison in this way violates MISRA C 2023 Rule 21.14.","The claim is not correct as applied to the presented function. The MHD_queue_basic_auth_required_response3 implementation itself does not call memcmp; it uses memcpy and builds a NUL-terminated header string which it passes to MHD_add_response_header. The memcmp call that Agent A references (memcmp(hdr->value, ""close"", 5)) is said to occur in add_response_header_connection — a different routine — so any MISRA 21.14 violation would belong to that routine, not to MHD_queue_basic_auth_required_response3.

Two additional points:
- MISRA C 2023 Rule 21.14 indeed forbids using memcmp to compare null-terminated strings. If add_response_header_connection uses memcmp to compare a NUL-terminated header value against the literal ""close"", that would be a violation in that routine (it should use strcmp/strncmp or otherwise ensure a non-string fixed-length comparison).
- Agent A’s supplied probe code failed to compile and produced no runtime evidence tying a memcmp misuse to this function, so there is no proof in the submission that MHD_queue_basic_auth_required_response3 itself violates the rule.

Recommendation: inspect add_response_header_connection (or any other routine that actually calls memcmp) and, if it compares a null-terminated string using memcmp, replace that with an appropriate string comparison (strcmp/strncmp) or otherwise ensure the comparison is on non-null-terminated raw memory.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,8.13,False,"No violation: all pointer parameters and local pointers are appropriately const-qualified or non-const as required. The input 'realm' is const char * since it is not modified. The response and connection pointers are non-const because they are passed to functions that modify the objects (MHD_add_response_header, MHD_queue_response). The dynamically allocated header buffer h_str is a modifiable char * because it is filled and then freed. No const-qualified pointer is subsequently used to modify the pointee.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,2.1,False,No unreachable code found. All branches in MHD_queue_basic_auth_required_response3 are potentially reachable depending on inputs: the early return when response is NULL; the malloc-failure path; the prefer_utf8 == 0 and prefer_utf8 != 0 branches; the MHD_add_response_header success and failure branches. No code appears statically unreachable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,1.2,False,"No violation: the function uses only standard C constructs and library functions. There are no compiler-specific keywords or extensions (no __attribute__, no asm, no typeof, no __builtin_ identifiers, no nonstandard pragmas). Macros such as _MHD_EXTERN and MHD_STATICSTR_LEN_ are ordinary macros, not language extensions.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/basicauth.c,MHD_queue_basic_auth_required_response3,2.2,True,The mhd_assert calls in MHD_queue_basic_auth_required_response3 expand to ((void)0) (see mhd_assert macro). These assertion calls are executed statements that have no effect on program state; removing them would not change behavior. Therefore they constitute dead code and violate MISRA C 2023 Rule 2.2.,"Not enough evidence to accept the claim as a definite MISRA 2.2 violation. Whether the mhd_assert calls are “dead code” depends on the project-wide definition and configuration of mhd_assert. If, in the actual project and build configuration, mhd_assert is defined everywhere as a no-op (for example expanding to ((void)0) or an empty inline function), then those assertion statements are operations that do not affect program behaviour and their presence would meet the textual definition of dead code and thus would violate Rule 2.2. However, in many projects mhd_assert is a macro that can be enabled in some builds (e.g. debug builds) to perform runtime checks. In that common situation removing the calls would change behaviour in some configurations, so they are not “dead code” for the project as a whole and do not violate Rule 2.2.

Agent A assumed mhd_assert expands to ((void)0) without demonstrating that this is the project-wide, fixed definition. The provided test snippet defines mhd_assert as a no-op locally, but that local test does not prove the real project uses a no-op definition in all builds. The test also failed to compile so it provides no run-time evidence. Therefore the report as stated is not correct unless the reporter can show that mhd_assert is unconditionally a no-op across the entire project and all build configurations.

Conclusion: the report is not correct as a general claim; it would only be correct if the project-definitions make mhd_assert permanently a no-op (in which case the specific assertions would be dead code).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,14.2,False,No for loop is present in ahc_echo; therefore Rule 14.2 (well-formed for loops) is not applicable. All loop-related constraints cannot be violated because there are no for statements in the function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,17.8,False,No violation. The function modifies the object pointed to by the pointer parameter 'req_cls' (assigns to *req_cls) which is allowed by Rule 17.8; it does not modify the pointer parameter variable 'req_cls' itself. No other function parameters are assigned to. Thus the code conforms to Rule 17.8.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,21.17,False,"No violation. The calls into <string.h> are guarded so they cannot access out-of-bounds memory: strcmp(method, ""GET"") is invoked on the HTTP library-supplied method (the microhttpd API supplies a non-NULL, NUL-terminated method); the username memcmp is only executed after checking auth_info != NULL and that auth_info->username_len equals strlen(""Aladdin""); MHD_basic_auth_get_username_password3 allocates a buffer, copies/decodes into it and explicitly NUL-terminates username/password, so the memcmp length matches the actual contained bytes; similarly the password checks ensure auth_info->password is non-NULL and the length equals strlen(""open sesame"") before memcmp. All strlen/memcmp/memcmp usages therefore operate within the bounds of their pointed-to objects.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,21.14,True,"The code uses memcmp to compare authentication username and password to string literals (""Aladdin"" and ""open sesame""). Even though it first checks lengths, memcmp is still used to compare C strings; this violates MISRA C 2023 Rule 21.14 which forbids using memcmp to compare null-terminated strings.","The claim is not correct. Rule 21.14 forbids using memcmp to compare null‑terminated C strings (i.e. using memcmp where the intent/semantics are string comparison relying on '\0'). In this code the comparisons are guarded by explicit length checks and memcmp is invoked with an explicit byte count derived from those lengths: username_len is compared to strlen(""Aladdin"") and password_len to strlen(""open sesame"") (and password is checked for NULL). Therefore memcmp is being used to compare fixed byte sequences of known length (excluding the terminating '\0' from the literal since strlen() does not include it), not to perform an unbounded null‑terminated string comparison. In other words the code treats the credential fields as length‑specified buffers (which may not be null‑terminated) and only then compares the exact number of bytes — this is not what MISRA Rule 21.14 forbids. (If the intent were to compare C null‑terminated strings, then using strcmp/strncmp would be appropriate; but given the length checks and possible non‑NULL‑terminated auth_info fields, memcmp here is appropriate and does not violate 21.14.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,8.13,False,"No violation. The non-const pointers in the code are used to modify the referenced objects (or are required to be non-const by other functions). Examples: MHD_basic_auth_get_username_password3 writes zero terminators into the decoded buffer via ret->username and ret->password, so those members must be char * (not const char *). The function also assigns to *req_cls, so req_cls must be a pointer to non-const. All pointers that are only read are already const-qualified (e.g. method, url, version, upload_data are const char *). Therefore Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,2.1,False,"No violation: the ahc_echo function contains no unreachable code. All return paths and branches (early returns for non-GET, first-call suspension via req_cls, authentication failure/success branches) are reachable in normal execution and no statements are dead.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,1.2,False,"No violation: the ahc_echo function uses only standard C language features and library calls. There are no compiler-specific extensions (no inline assembly, typeof, statement-expressions, nested functions, GCC attributes, or other documented compiler extensions) used in the function or the provided supporting code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/authorization_example.c,ahc_echo,2.2,False,"No violation. The ahc_echo implementation contains no executed operations that could be removed without changing program behaviour. All executed statements either affect control flow (the first-call short-circuit via *req_cls), perform authentication checks, allocate/free resources, queue/destroy responses, or return appropriate results. The (void) parameter-cast lines are only to suppress unused-parameter warnings and do not constitute dead code in the sense of Rule 2.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,14.2,False,"No violation: add_new_user_entry contains no for loops. Rule 14.2 concerns well-formed for statements; since the function has no 'for' statement, the rule is not applicable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,17.8,False,"No violation: none of the function parameters are modified. The pointer parameters are declared as const char *const and are only copied into structure members (entry->username, entry->realm). The integer parameters are copied into structure members (entry->allow_area_1, entry->allow_area_2). No assignment to or modification of any parameter variable occurs. A specific violation scenario would be if the function assigned to a parameter (e.g. username = NULL; or ++password), which would violate Rule 17.8, but that does not occur here.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,21.17,False,"No violation in this function: add_new_user_entry does not directly call any <string.h> functions and passes explicit buffer sizes (sizeof(entry->...)) to the digest helper functions. There is no evidence in this function that any pointer parameter could be used to access beyond the bounds of the destination buffers. Any potential out-of-bounds access would be the responsibility of the called functions (e.g. MHD_digest_auth_calc_userhash / MHD_digest_auth_calc_userdigest) to honor the provided size. Thus, based on the provided code alone, Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,21.14,False,"No violation: the function add_new_user_entry and the provided helper functions do not call memcmp to compare null-terminated strings. String lengths are obtained via strlen and passed to digest/calculation functions; no memcmp usage or string-to-string comparisons with memcmp appear in the shown code, so MISRA C 2023 Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,8.13,False,"No violation: The function parameters username, password and realm are declared as pointers to const (const char *const), and the struct UserEntry stores username and realm as const char *; the function does not modify the characters pointed to by these pointers — it only stores the pointers and writes into the UserEntry fields (via a non-const pointer to the struct). The non-const pointer 'entry' is required because the function modifies the pointed-to UserEntry fields. Therefore Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,2.1,False,"No unreachable code found in add_new_user_entry. All conditional blocks are guarded by a runtime variable (res) so execution of each hash/digest call depends on prior runtime results. A specific hypothetical violation scenario would be if res were initialized to the constant MHD_NO before the first guarded if (for example, replacing ""res = MHD_YES;"" with ""res = MHD_NO;"" at compile time), making all subsequent if (MHD_NO != res) blocks unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,1.2,False,"No violation: the function uses only standard C constructs (static function linkage, const qualifiers, enums, sizeof, pointer arithmetic, standard control flow). There are no compiler-specific extensions (no GCC __attribute__, no inline assembly, no typeof, no nonstandard keywords or pragmas) referenced in the code or accompanying symbols.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/digest_auth_example_adv.c,add_new_user_entry,2.2,True,"The initialization 'res = MHD_YES;' is immediately followed by the test 'if (MHD_NO != res)'; because res is set to MHD_YES directly before the test, that comparison is always true. The evaluation of that comparison and its condition is therefore an executed operation whose removal would not affect program behaviour (the guarded call would still be executed). This constitutes dead code under MISRA C 2023 Rule 2.2.","Agent A is correct. In the original function res is unconditionally set to MHD_YES immediately before the test if (MHD_NO != res). That test therefore always evaluates to true at that program point, so the comparison and the conditional decision are executed operations whose removal (i.e. making the call unconditional) would not change program behaviour. That meets the definition of dead code in MISRA C:2023 Rule 2.2. (The subsequent checks that depend on res are not dead; only the first comparison immediately after the unconditional assignment is redundant.) The added logging test code and its build failure do not change that logical observation. Recommendation: remove the redundant test (call unconditionally) or restructure so res is not assigned immediately before the check if the intent is to keep the conditional form.)",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,14.2,False,No violation: ahc_echo contains no for loops. Rule 14.2 (well-formed for loops) is not applicable because the function uses no 'for' statements; control-flow uses 'if' and other constructs only.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,17.8,False,"No violation: the function does not assign to any of its parameter variables. It dereferences req_cls and stores into *req_cls (modifying the object pointed to), which is allowed by the rule (pointer parameter itself is not modified).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,21.17,False,"No violation. The call to strlen(url) obtains the number of characters excluding the terminating NUL and MHD_create_response_from_buffer_copy copies exactly that many bytes (memcpy(mhd_copy, buffer, size)). Provided url is a valid, null-terminated string (as supplied by the HTTP library), there is no read or write beyond the bounds of the object. Note: if url were NULL (which would make strlen undefined), that would be a separate null-pointer/UB issue, but the shown code as used with a valid URL does not violate Rule 21.17.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,21.14,False,"No violation: the ahc_echo function and the provided related functions do not call the standard library function memcmp to compare null-terminated strings. String comparisons shown use character-by-character checks, strcmp, strstr, or length-aware routines; therefore Rule 21.14 is not violated. (A violating scenario would be, for example, calling memcmp(s1, s2, strlen(s1)) to compare two NUL-terminated strings.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,8.13,False,"No violation: pointers that refer to mutable objects (req_cls -> used to store/modify req, connection -> passed to functions that modify connection state, req -> allocated and modified) are non-const. Read-only data (url, method, version, upload_data) are declared const char * and only read. No pointer to a const-qualified type is modified by the function, and no pointer could reasonably be made const without changing required semantics, so Rule 8.13 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,2.1,False,"No violation: the function contains no unreachable code. All control paths are reachable — when *req_cls is NULL it allocates and returns; when req exists and req->timerfd != -1 it sends a response and returns; otherwise it creates the timer, suspends the connection and returns. There are no statements that can never be executed.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,1.2,False,"No compiler-specific language extensions are used in ahc_echo. The function uses only standard C constructs and POSIX/Linux APIs (timerfd_create, epoll_ctl, etc.). There are no GCC/clang-specific extensions (no __attribute__, inline asm, statement-expressions, typeof, nested functions, or other compiler-specific language extensions).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/suspend_resume_epoll.c,ahc_echo,2.2,False,"No dead-code found in ahc_echo. All executed operations affect program behaviour (allocation and timer/epoll setup, response creation/queueing, suspension). The (void) parameter-cast lines are compile-time annotations to suppress unused-parameter warnings and do not generate executable operations; therefore they are not dead code per the rule definition.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,14.2,False,"The function compress_buf contains no for statements — it uses do/while loops only. MISRA C 2023 Rule 14.2 concerns well‑formed for loops; since there are no for loops in this function, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,17.8,True,The value parameter 'src_size' is modified inside the function (src_size -= CHUNK). Modifying a value parameter violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).,"Agent A is correct. The function modifies the value parameter src_size (src_size -= CHUNK), which is a direct modification of a function parameter variable. MISRA C 2023 Rule 17.8 prohibits modifying function parameters; although objects referred to by pointer parameters may be modified, value parameters themselves shall not be changed. Other modifications in the function (e.g. *offset, *dest, *dest_size, fields of *strm) are modifications of objects referred to by pointer parameters and are permitted by the rule. To comply, make a local copy (e.g. size_t remaining = src_size) and update that instead of modifying the parameter.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,21.17,True,"When the provided tmp buffer passed into compress_buf is smaller than CHUNK (the function assumes tmp has CHUNK bytes), the memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) can read beyond the bounds of the tmp object. This occurs because 'have' may be up to CHUNK and the function never checks the actual size of the tmp buffer, so memcpy may access beyond tmp's bounds and thus violate MISRA C 2023 Rule 21.17.","Agent A is correct. The code calls memcpy(tmp, ..., have) where have is computed as CHUNK - strm->avail_out after calling deflate with avail_out set to CHUNK and next_out set to tmp. Nothing in compress_buf checks or documents the actual size of the object pointed to by tmp, so if the caller supplies a tmp buffer smaller than CHUNK the memcpy can read beyond tmp (and deflate itself may already have written beyond tmp). MISRA C 2023 Rule 21.17 requires that uses of string/memory functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters; this use can do so unless the function guarantees (e.g. by an API contract or an explicit size parameter/check) that tmp is at least CHUNK bytes. Absent such a guarantee or a runtime check, the report of a Rule 21.17 violation is correct. Recommended fixes: add a tmp_size parameter and bound have by tmp_size, allocate tmp inside the function to CHUNK, or document and enforce (assert/check) that tmp is at least CHUNK bytes.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,21.14,False,"No violation: the function compress_buf does not call memcmp anywhere. It uses memcpy, realloc, deflate, free and sets/reads buffer sizes explicitly; there is no comparison of null-terminated strings using memcmp and thus Rule 21.14 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,8.13,False,No violation. The parameter 'src' is declared as 'const void *' (input data not modified) and is assigned to the stream input pointer in a way that preserves const-correctness for reading. The buffers that are modified (tmp passed as output buffer and *dest which is realloc'd and written to) are declared without const so they can be written to. Thus pointers are const-qualified whenever possible and non-const when the pointed-to object is modified.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,2.1,False,No violation. All code paths are reachable: the outer do/while iterates with flush = Z_NO_FLUSH while src_size > CHUNK and finally with flush = Z_SYNC_FLUSH when the remaining src_size <= CHUNK. The inner do/while is entered each outer iteration and repeats while strm->avail_out == 0. The early return on realloc failure is reachable. Therefore there is no unreachable code in this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,1.2,False,"No violation: the function uses only standard C constructs and zlib-defined types (uInt, Bytef) and standard library functions (realloc, memcpy, free). There are no compiler-specific keywords or extensions such as __attribute__, __asm__, typeof, __declspec, or other documented compiler extensions. Casting to zlib typedefs and use of enums/macros is not a language extension.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/http_chunked_compression.c,compress_buf,2.2,True,The update '*offset += strm->avail_in;' inside compress_buf is never observed by the only shown caller (read_cb passes a local 'offset' that is not used after the call). Therefore that write is an executed operation whose removal would not change program behaviour in the given project context — it is dead code.,"Agent A’s report is not sufficiently supported. MISRA C 2023 Rule 2.2 is a project‑level prohibition on dead code — an executed operation is dead only if its removal cannot affect the program behaviour anywhere in the project. The reporter’s argument relies on a single shown caller that (allegedly) passes a local offset that is not used after the call. That is a local observation, not a whole‑project proof. The write *offset += strm->avail_in modifies memory visible to the caller via the pointer parameter; removing that write could change behaviour for other callers or configurations that do inspect the updated value after the call. The test harness failing to compile does not demonstrate that the write is unobserved in the complete project. Therefore the claim that the update is dead code is not proven and the report is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,14.2,False,"No for-loop statements are present in the ahc_echo function, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. A search of the function reveals no 'for' constructs; therefore there is no violation of Rule 14.2.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,17.8,False,"No violation: ahc_echo modifies the object pointed to by the pointer parameter req_cls (assigns *req_cls = &aptr and later *req_cls = NULL) but does not modify the pointer parameter itself. No function parameter pointer is reassigned, so Rule 17.8 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,21.17,False,"No violation: the uses of the <string.h> functions in ahc_echo do not produce out‑of‑bounds accesses. The only string.h functions used are strcmp(method, MHD_HTTP_METHOD_GET) and strlen(emsg). MHD_HTTP_METHOD_GET is a compile‑time NUL‑terminated literal; method is supplied by the HTTP library and is expected to be a NUL‑terminated method string; emsg is a 1024 byte buffer filled via snprintf with the buffer size passed, ensuring a terminating NUL before strlen is called. The code does not invoke any of the listed string.h functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strspn, etc.) in a way that can read past the referenced object bounds, so Rule 21.17 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,21.14,False,"No violation: the ahc_echo function and the supplied related functions do not call memcmp to compare null-terminated strings. Comparisons are done with strcmp and custom char-by-char routines (e.g. MHD_str_equal_caseless_), and memchr/memcpy are used appropriately. No memcmp usage comparing NUL-terminated strings is present.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,8.13,False,"No violation. The pointers that might superficially appear non-const are either already const (url, method, version, upload_data) or must be non-const because the function (or callbacks it registers) modifies the pointed-to objects. In particular, req_cls is a void** that the function writes into (*req_cls = &aptr; *req_cls = NULL) so it must not point to a const-qualified type. Other pointers such as connection, response, file and dir are passed to APIs or callbacks that may modify the referenced objects; therefore making them const would be incorrect. The unused cls parameter could theoretically be const, but changing its type would break the expected API; as written the code does not violate Rule 8.13.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,2.1,False,"No violation. The ahc_echo function contains no unreachable code: all statements and branches can be reached depending on run-time inputs (method value, req_cls pointer, whether the requested path is a regular file, open directory success/failure, and response-creation results). The early returns are based on runtime conditions (e.g., unexpected method, first-call behaviour via req_cls, file open/fstat failures, response creation failures), not compile-time constants, so no code is permanently dead or unreachable.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,1.2,False,"No violation: the ahc_echo function and related code do not use any compiler-specific language extensions (no asm, attributes, typeof, statement expressions, inline assembly, GCC/Clang attribute keywords, or other compiler-only constructs). All constructs used are standard C or common POSIX APIs provided by system headers, so Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/examples/fileserver_example_dirs.c,ahc_echo,2.2,True,Violation: the explicit (void) casts for unused parameters (e.g. (void) cls; (void) version; (void) upload_data; (void) upload_data_size;) are executed no-op statements whose removal would not affect program behaviour — they constitute dead code per MISRA C 2023 Rule 2.2.,"The report is not correct. Although the (void) parameter casts are no‑op expression statements (they do not change program state), MISRA Rule 2.2 is intended to prohibit genuinely redundant code that can safely be removed and that increases maintenance risk. The idiom (void) parameter; is a standard, intentional way to mark an unused parameter and suppress compiler diagnostics. Such statements document intent and, in the strict sense used by MISRA, cannot be assumed harmless to remove (e.g. removal can alter timing or observable behaviour of an embedded system — see Note 1 of the rule). In practice MISRA guidance and tool chains treat explicit discards of unused parameters as an acceptable pattern rather than a Rule 2.2 violation. Therefore the claim that those casts constitute a Rule 2.2 violation is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,14.2,False,No for-loop present in the function answer_to_connection; therefore Rule 14.2 (well-formed for loops) is not applicable.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,17.8,False,"No violation. The function modifies the objects pointed to by pointer parameters (e.g. *req_cls = (void *)con_info; and *upload_data_size = 0;), which is permitted by Rule 17.8. The pointer parameters themselves (req_cls, upload_data_size, method, etc.) are not reassigned. Therefore the code complies with MISRA C 2023 Rule 17.8.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,21.17,True,"Calling strcmp(method, ...) without ensuring 'method' is a valid, null-terminated string can read past the bounds of the object referenced by 'method' (or dereference a NULL pointer). For example, if the HTTP library passes a non-null pointer that does not point to a NUL-terminated buffer (or passes NULL), the strcmp calls (strcmp(method, ""POST"") and strcmp(method, ""GET"")) can access memory beyond the object bounds, violating MISRA C 2023 Rule 21.17.","MISRA C 2023 Rule 21.17 requires that calls to the <string.h> functions must not cause accesses beyond the bounds of the objects referenced by the pointer parameters. strcmp reads both operands until it finds a NUL byte, and it dereferences the pointers; therefore the operands must be valid, non-NULL pointers to NUL-terminated buffers (or otherwise proven to have sufficient accessible storage). In the posted answer_to_connection the code calls strcmp(method, ""POST"") and strcmp(method, ""GET"") without first checking that method is non-NULL or otherwise guaranteed to be a valid NUL-terminated string by the surrounding context. If the HTTP library ever supplied a NULL pointer or a pointer to a non-NUL-terminated buffer the strcmp calls could read out of bounds (or dereference NULL), which would violate Rule 21.17.

So the agent A report is correct in the general sense: the code, as written, can violate MISRA C 2023 Rule 21.17 unless there is an explicit, documented API contract that method is always a valid, non-NULL, NUL-terminated string. If such a contract exists and is relied upon, the code is acceptable; otherwise it should be hardened (for example, check method != NULL before use, or use an API that provides method length or otherwise prove the buffer bounds prior to calling strcmp).",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,21.14,False,No violation: answer_to_connection and the related code use strcmp and MHD_str_equal_caseless_/MHD_str_equal_caseless_n_ for string comparisons. There is no use of memcmp to compare null-terminated strings in the provided function or the shown related functions.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,8.13,False,"No violation. The function already const-qualifies all pointer parameters that can be const (url, method, version, upload_data). Pointers that are non-const are intentionally so: size_t *upload_data_size and void **req_cls are modified by this function (they cannot point to const-qualified types), and the callback signature (void *cls, struct MHD_Connection *connection) is imposed by the external library and cannot be changed here. Therefore Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,2.1,False,"No violation. All control paths in answer_to_connection are reachable: the initial-connection branch (*req_cls == NULL) is taken for first requests (both GET and POST), subsequent requests take the later branches (GET returns askpage; POST processes upload_data when upload_data_size != 0; when upload_data_size == 0 either returns the prepared answerstring or falls through to errorpage). The final errorpage path is reachable for methods other than GET/POST or for POST requests without an answerstring. Therefore Rule 2.1 (no unreachable code) is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,1.2,False,"No violation: the function uses only standard C constructs (pointer casts, standard library functions, sizeof, strcmp, malloc, free, snprintf) and no compiler-specific extensions (no inline asm, attributes, typeof, statement expressions, GCC-specific keywords, or non-standard linkage). No evidence of compiler-documented extensions in answer_to_connection or the provided surrounding code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,answer_to_connection,2.2,True,The three explicit cast-to-void statements at the start of answer_to_connection ((void) cls; (void) url; (void) version;) are executed no-op expression-statements whose removal would not affect program behaviour. These evaluated-but-effectless statements meet the definition of dead code in MISRA C 2023 Rule 2.2.,"Agent A’s report is not correct. The three (void) casts are no‑op expression‑statements that have no runtime side effects, but they are a deliberate idiom to document/suppress unused‑parameter diagnostics. MISRA Rule 2.2 targets ‘‘dead code’’ in the sense of operations or blocks that remain in the program but serve no intended purpose and whose removal is indicative of obsolete or unreachable functionality. The (void) param; idiom is intentionally used to mark a parameter as unused and to avoid compiler warnings; it is not the kind of leftover/obsolete code that Rule 2.2 is intended to forbid. (Removing those casts would not change program behaviour, but they are a purposeful, conventional annotation rather than unintended dead code.) Therefore the reported violation of MISRA C 2023 Rule 2.2 is incorrect.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,14.2,False,"No violation: the function iterate_post contains no for loops, so MISRA C 2023 Rule 14.2 (well-formed for loops) is not applicable. There are no loop counters, no loop-related clauses, and no functions called from within a for loop body to consider.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,17.8,False,"No violation: iterate_post does not modify any function parameter itself. The code assigns the parameter coninfo_cls to a local pointer variable (con_info) and updates the object pointed to (con_info->answerstring), which is allowed by MISRA C 2023 Rule 17.8 (the pointee may be modified, but the pointer parameter must not be modified). All other parameters are left unchanged (unused parameters are cast to void).",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,21.17,True,"Violation occurs when the POST field named ""name"" has 'data' of length 'size' that is not null-terminated. The code checks only that size > 0 and size <= MAXNAMESIZE, then passes 'data' (which may not be '\0'-terminated) to snprintf with a ""%s"" format specifier. snprintf will read beyond the provided object bounds searching for a terminator, resulting in an out-of-bounds access.","The scenario described by agent A is correct about the runtime defect: if the POST field 'data' is not NUL-terminated, using snprintf with the ""%s"" format will cause the library to read bytes past the provided buffer (searching for a terminator), so there is a potential out‑of‑bounds read.

However, the specific MISRA C 2023 rule cited by agent A (21.17) as given in your excerpt explicitly concerns the string handling functions from <string.h> (memcpy, strcpy, strlen, etc.). snprintf is a <stdio.h> formatting function, not one of the <string.h> functions named in the rule text. Therefore the code exhibits a genuine out‑of‑bounds string/read risk, but it is not a direct violation of MISRA C 2023 Rule 21.17 as stated. The report is a correct identification of a bug, but it misattributes the violation to 21.17.

Recommended fixes: ensure the incoming data is NUL-terminated within size before using ""%s"", or use a bounded format such as ""%.*s"" with the known size, or copy/terminate the input into a local buffer of size+1 before passing to snprintf.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,21.14,False,"No violation in the provided code. The function uses strcmp(key, ""name"") to compare a null-terminated string, which is permitted. A specific violation scenario (hypothetical) would be if the code used memcmp(key, ""name"", strlen(""name"") + 1) or memcmp(key, ""name"", 4) to compare the null-terminated string ""name"" with key, which would contravene MISRA C 2023 Rule 21.14.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,8.13,False,"No violation. The function uses const for all input character pointers (key, filename, content_type, transfer_encoding, data) where the function does not modify the pointed-to characters. The coninfo_cls parameter is a non-const void * that is cast to struct connection_info_struct * and used to modify the connection_info_struct (con_info->answerstring is assigned). Because the function modifies the object pointed to by coninfo_cls, that pointer must not be const. Therefore Rule 8.13 is respected.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,2.1,False,"No violation: all statements in iterate_post are reachable. The function tests key and either returns MHD_NO (when key equals ""name""), with nested paths for malloc success/failure and size checks, or returns MHD_YES for other keys. The (void) casts simply suppress unused-parameter warnings and do not create unreachable code.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,1.2,False,"No language extensions are used in the provided iterate_post function. The function uses only standard C constructs (static function, casts to void to silence unused-parameter warnings, standard library calls malloc and snprintf, standard integer types uint64_t/size_t, and enums). There are no compiler-specific keywords or extensions (for example no __attribute__, __builtin_*, typeof, inline assembly, nested functions, statement expressions, or other vendor-specific extensions) in iterate_post. Therefore MISRA C 2023 Rule 1.2 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/doc/examples/simplepost.c,iterate_post,2.2,True,"The (void) cast statements for unused parameters (e.g. (void) kind; (void) filename; etc.) are executed operations that have no effect on program behaviour; their removal would not change program behaviour, therefore they constitute dead code under MISRA C 2023 Rule 2.2.","The report is not correct. The five (void) casts are the usual idiom to mark parameters as intentionally unused and to suppress compiler warnings; they are not the kind of accidental, functionally-superfluous code that Rule 2.2 aims to forbid. Rule 2.2 targets executed operations whose removal would not affect program behaviour; in practice these (void) expressions document intent and affect build-time diagnostics (and, in some build/tool chains, analysis results), so treating them as dead code is not appropriate. The agent’s empirical attempt (the test harness) also failed to produce evidence (it did not compile), so it does not demonstrate that the casts are forbidden or that they break the rule. If you want to avoid any question, common alternatives are: omit parameter names for unused parameters in the function definition, or use a dedicated macro (e.g. UNUSED_PARAM(x)) implemented portably. But the claim that the shown (void) statements violate MISRA C:2023 Rule 2.2 is not correct.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,14.2,False,"The function MHD_create_named_thread_ (and related code shown) contains no for statements. MISRA C 2023 Rule 14.2 applies only to for loops and their clauses; because there are no for loops present in the provided code, the rule is not applicable and therefore not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,17.8,False,"No violation: MHD_create_named_thread_ does not assign to any of its parameters. Pointer parameters (handle_id, thread_name, start_routine, arg) are only dereferenced or passed to other functions/macros that may modify the pointed-to objects; the pointer variables themselves are never modified (no assignments to handle_id, thread_name, etc.). The only local pointer assignment is to new_tid_ptr which is a local const pointer initialized from a helper — this does not modify the parameter. Hence Rule 17.8 is not violated.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,21.17,False,No violation: MHD_create_named_thread_ does not call any of the <string.h> functions listed by MISRA C 2023 Rule 21.17 (memcpy/memmove/memset/strcmp/strcpy/etc.). It only stores the thread_name pointer and delegates thread creation; therefore there is no string library access that could read or write beyond object bounds within this function.,,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,21.14,False,"No violation in the provided function. The code never calls memcmp to compare null‑terminated strings. (A possible violation scenario would be if thread_name were compared to a literal or another C string using memcmp, e.g. memcmp(thread_name, ""name"", strlen(""name"") + 1) or memcmp(thread_name, other, n) to determine equality — that would violate MISRA C 2023 Rule 21.14.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,8.13,True,The struct MHD_named_helper_param_ stores the thread name in a non-const char * (param->name). Assigning the const-qualified thread_name (const char *) to this non-const pointer discards const qualification. This violates MISRA C 2023 Rule 8.13 which requires a pointer to point to a const-qualified type whenever possible (and avoid removing const qualification).,"The report is correct. The code assigns the parameter thread_name (type const char *) to param->name. If param->name is declared as a non-const char * (as Agent A states), that assignment discards the const qualifier and therefore violates the MISRA C 2023 intent of Rule 8.13 (pointers should point to const-qualified types whenever possible; qualifiers must not be discarded). 

If the string is not to be modified by the thread starter, the proper fix is to make the helper struct field const char *name so the const qualification is preserved. If the thread function will modify the string, then the caller should supply a non-const buffer (or the code should make a mutable copy) so no const is discarded. In either case, the current assignment (const char * -> char *) is non-conformant with Rule 8.13.",NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,2.1,False,"No reachable-code violation found. The function contains only conditional compilation branches (#if/#else) and normal control flow; every compiled path ends with a reachable return and there are no statements that can never be executed at run time. (Note: there is a logical issue in the non-MHD_USE_THREAD_ATTR_SETNAME branch where 'return ! 0;' yields 0 even on success, but that is a logic bug, not unreachable code.)",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,1.2,False,"No violation: the function does not use any compiler language extensions. There are no compiler-specific keywords or constructs (no __attribute__, __asm__, typeof, statement-expression, or other nonstandard language features). Conditional compilation and #error are standard preprocessor features. Note: pthread_attr_setname_np is a nonstandard library function (POSIX extension), but it is a library API, not a compiler language extension, so it does not trigger Rule 1.2 per the given requirement.",,NA
/ssd_home/yeongbin/lasik/misrac_subjects/libmicrohttpd/srcs/libmicrohttpd-1.0.1/src/microhttpd/mhd_threads.c,MHD_create_named_thread_,2.2,False,"No dead code found. All executed operations in MHD_create_named_thread_ contribute to program behaviour: the function's two mutually exclusive compile-time branches (with and without MHD_USE_THREAD_ATTR_SETNAME) perform necessary initialization, error handling, and thread-handle updates. Control-flow branches that set errno and mark handles invalid are effective on error, and the success-path stores the native thread handle. Conditional compilation removes unreachable alternatives at build time rather than leaving executed-but-redundant code. Therefore MISRA C 2023 Rule 2.2 is not violated.",,NA
