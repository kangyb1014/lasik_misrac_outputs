{
  "user_message": "Target function code is:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}, 'MHD_create_thread_': {'callees': [], 'callers': ['MHD_create_named_thread_']}, 'new_connection_process_': {'callees': ['MHD_pool_create', 'MHD_DLOG', '__builtin_unreachable', 'MHD_connection_set_initial_state_', 'MHD_create_named_thread_', 'MHD_pool_destroy', 'MHD_ip_limit_del'], 'callers': ['internal_add_connection', 'new_connections_list_process_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_USE_THREAD_ATTR_SETNAME (preprocessor macro)",
    "HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD (preprocessor macro)",
    "HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI (preprocessor macro)",
    "MHD_thread_handle_ID_get_native_handle_ptr_ (macro or inline accessor)",
    "MHD_thread_handle_ID_set_invalid_ (function/macro)",
    "MHD_thread_handle_ID_set_native_handle_ (function/macro)",
    "MHD_thread_handle_ID_ (typedef/opaque type)",
    "MHD_THREAD_START_ROUTINE_ (function-pointer typedef / calling-convention macro)",
    "pthread_attr_setname_np (platform-specific function or macro)",
    "pthread_attr_setstacksize (function)",
    "pthread_attr_init (function)",
    "pthread_create (function)",
    "pthread_attr_destroy (function)",
    "pthread_t, pthread_attr_t (typedefs from pthread.h)",
    "named_thread_starter (function used as thread starter)",
    "struct MHD_named_helper_param_ (structure definition)",
    "MHD_create_thread_ (prototype of the internal thread-creation wrapper)",
    "malloc, free (stdlib functions)",
    "errno, EINVAL (errno macros)",
    "Relevant headers: <pthread.h>, <errno.h>, <stdlib.h> (header-level macros/attributes)"
  ],
  "explanation": "For each item below: we need the symbol definition/declaration so we can inspect whether it uses any compiler language extensions (attributes, calling-convention pragmas, builtin keywords, compiler-specific keywords, or macro expansions that expand to such extensions).\n\n- MHD_USE_THREAD_ATTR_SETNAME: controls which code path is compiled; must inspect its definition to know which code to analyze for extensions.\n- HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD / HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI: select different pthread_attr_setname_np variants; the selected variant may be a macro/wrapper that uses compiler-specific extensions.\n- MHD_thread_handle_ID_get_native_handle_ptr_: this accessor may be a macro or inline function that expands to nonstandard constructs (cast tricks, attributes) \u2014 we must inspect it.\n- MHD_thread_handle_ID_set_invalid_ / MHD_thread_handle_ID_set_native_handle_: these may be macros or functions; their definitions could use compiler-specific extensions (attributes, asm, pragmas) that would violate the MISRA rule.\n- MHD_thread_handle_ID_: the underlying typedef/opaque type (for thread handle) could be a typedef that uses compiler-specific types or attributes (e.g., attributes on typedefs) so we must check it.\n- MHD_THREAD_START_ROUTINE_: the thread-function pointer type may include calling-convention or attribute macros (e.g., __attribute__, __stdcall) \u2014 must examine its definition for extensions.\n- pthread_attr_setname_np / pthread_attr_setstacksize / pthread_attr_init / pthread_create / pthread_attr_destroy: although POSIX functions, some platforms provide them as macros or wrappers that may use compiler extensions; their declarations could have compiler-specific attributes (nonstandard) that count as language extensions.\n- pthread_t, pthread_attr_t: these typedefs come from pthread.h and could be aliases to compiler-specific types or use attributes \u2014 inspect their definitions.\n- named_thread_starter: the starter function prototype/definition (not in this snippet) could use extensions in its declaration or definition; needed because it is passed as a start routine.\n- struct MHD_named_helper_param_: check the struct definition for any use of extension features (bit-fields with non-standard widths, flexible array fields implemented via compiler extension, attribute annotations, etc.).\n- MHD_create_thread_: the internal wrapper's prototype/definition may include attributes or extensions (calling conventions, inline/always_inline macros, etc.) that affect the code path used here.\n- malloc, free: although standard, their macros/headers should be inspected for any project-specific redefinitions that could use extensions.\n- errno, EINVAL: errno may be a macro or expanded to a compiler builtin or function-like macro on some platforms; need to confirm no extension is used.\n- Relevant headers (<pthread.h>, <errno.h>, <stdlib.h>): many compiler-specific extensions are introduced via headers as macros or attributes; the header-level declarations must be checked for __attribute__, __builtin_*, pragmas, or other compiler-specific constructs.\n\nCollecting the above symbol definitions/declarations lets an analyzer determine whether any of the identifiers used in the function expand to or rely on compiler language extensions (attributes, builtins, calling-convention annotations, asm, pragmas, nonstandard keywords). Only with those definitions can the MISRA rule (disallow language extensions) be reliably evaluated for this function."
}