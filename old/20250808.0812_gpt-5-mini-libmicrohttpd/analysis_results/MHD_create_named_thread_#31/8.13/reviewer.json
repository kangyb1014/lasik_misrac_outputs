{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The struct MHD_named_helper_param_ stores the thread name in a non-const char * (param->name). Assigning the const-qualified thread_name (const char *) to this non-const pointer discards const qualification. This violates MISRA C 2023 Rule 8.13 which requires a pointer to point to a const-qualified type whenever possible (and avoid removing const qualification).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal type definitions to preserve the original function signature */\ntypedef struct MHD_thread_handle_ID_ MHD_thread_handle_ID_;\ntypedef void *(*MHD_THREAD_START_ROUTINE_)(void *);\n\n/* Prototype of an external function used by this code (not defined here). */\nint MHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                        size_t stack_size,\n                        MHD_THREAD_START_ROUTINE_ start_routine,\n                        void *arg);\n\n/* The helper-parameter structure. Make name const to avoid discarding\n * the const qualifier when assigning a const char * thread_name. */\nstruct MHD_named_helper_param_\n{\n  MHD_THREAD_START_ROUTINE_ start_routine;\n  void *arg;\n  const char *name; /* changed to 'const char *' to preserve const qualification */\n};\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n  struct MHD_named_helper_param_ *param;\n  FILE *log = fopen(\"/tmp/logs/251.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"MHD_create_named_thread_: entry\\n\");\n    fprintf(log, \"  thread_name ptr=%p\\n\", (const void *) thread_name);\n  }\n\n  if (NULL == thread_name)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"  thread_name is NULL -> EINVAL, return 0\\n\");\n      fclose(log);\n    }\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"  malloc failed -> return 0\\n\");\n      fclose(log);\n    }\n    return 0;\n  }\n\n  /* Assign fields. param->name is now const char *, so assigning\n   * thread_name (const char *) preserves the const qualification. */\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"  param=%p, param->name ptr=%p\\n\", (void *) param, (const void *) param->name);\n    if (param->name != NULL)\n      fprintf(log, \"  param->name content=\\\"%s\\\"\\n\", param->name);\n  }\n\n  /* Preserve original behavior: attempt to create thread with named starter. */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            /* named_thread_starter */ start_routine,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    if (log != NULL)\n    {\n      fprintf(log, \"  MHD_create_thread_ failed -> freed param, return 0, errno=%d\\n\", errno);\n      fclose(log);\n    }\n    return 0;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"  MHD_create_thread_ succeeded -> returning 1\\n\");\n    fclose(log);\n  }\n\n  return ! 0;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code assigns the parameter thread_name (type const char *) to param->name. If param->name is declared as a non-const char * (as Agent A states), that assignment discards the const qualifier and therefore violates the MISRA C 2023 intent of Rule 8.13 (pointers should point to const-qualified types whenever possible; qualifiers must not be discarded). \n\nIf the string is not to be modified by the thread starter, the proper fix is to make the helper struct field const char *name so the const qualification is preserved. If the thread function will modify the string, then the caller should supply a non-const buffer (or the code should make a mutable copy) so no const is discarded. In either case, the current assignment (const char * -> char *) is non-conformant with Rule 8.13."
}