{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified post_iterator code that contains useful probe functions that print useful logs to a file \"/tmp/logs/389.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of post_iterator as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of post_iterator:\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function post_iterator:\nstruct Request\n{\n\n  /**\n   * Associated session.\n   */\n  struct Session *session;\n\n  /**\n   * Post processor handling form data (IF this is\n   * a POST request).\n   */\n  struct MHD_PostProcessor *pp;\n\n  /**\n   * URL to serve in response to this POST (if this request\n   * was a 'POST')\n   */\n  const char *post_url;\n\n}\n...\nstruct Session\n{\n  /**\n   * We keep all sessions in a linked list.\n   */\n  struct Session *next;\n\n  /**\n   * Unique ID for this session.\n   */\n  char sid[33];\n\n  /**\n   * Reference counter giving the number of connections\n   * currently using this session.\n   */\n  unsigned int rc;\n\n  /**\n   * Time when this session was last active.\n   */\n  time_t start;\n\n  /**\n   * String submitted via form.\n   */\n  char value_1[64];\n\n  /**\n   * Another value submitted via form.\n   */\n  char value_2[64];\n\n}\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\nenum MHD_ValueKind\n{\n\n  /**\n   * Response header\n   * @deprecated\n   */\n  MHD_RESPONSE_HEADER_KIND = 0,\n#define MHD_RESPONSE_HEADER_KIND \\\n  _MHD_DEPR_IN_MACRO ( \\\n    \"Value MHD_RESPONSE_HEADER_KIND is deprecated and not used\") \\\n  MHD_RESPONSE_HEADER_KIND\n\n  /**\n   * HTTP header (request/response).\n   */\n  MHD_HEADER_KIND = 1,\n\n  /**\n   * Cookies.  Note that the original HTTP header containing\n   * the cookie(s) will still be available and intact.\n   */\n  MHD_COOKIE_KIND = 2,\n\n  /**\n   * POST data.  This is available only if a content encoding\n   * supported by MHD is used (currently only URL encoding),\n   * and only if the posted content fits within the available\n   * memory pool.  Note that in that case, the upload data\n   * given to the #MHD_AccessHandlerCallback will be\n   * empty (since it has already been processed).\n   */\n  MHD_POSTDATA_KIND = 4,\n\n  /**\n   * GET (URI) arguments.\n   */\n  MHD_GET_ARGUMENT_KIND = 8,\n\n  /**\n   * HTTP footer (only for HTTP 1.1 chunked encodings).\n   */\n  MHD_FOOTER_KIND = 16\n}\n</additional code>\nJudge whether the above post_iterator code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function assigns to the parameter 'size' (size = (size_t)(...)) to crop extra data before calling memcpy. Modifying the function parameter variable 'size' violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <time.h>\n\n/* Minimal required declarations (as in the additional code). */\nstruct Session\n{\n  struct Session *next;\n  char sid[33];\n  unsigned int rc;\n  time_t start;\n  char value_1[64];\n  char value_2[64];\n};\n\nstruct Request\n{\n  struct Session *session;\n  struct MHD_PostProcessor *pp;\n  const char *post_url;\n};\n\nenum MHD_Result\n{\n  MHD_NO = 0,\n  MHD_YES = 1\n};\n\nenum MHD_ValueKind\n{\n  MHD_RESPONSE_HEADER_KIND = 0,\n  MHD_HEADER_KIND = 1,\n  MHD_COOKIE_KIND = 2,\n  MHD_POSTDATA_KIND = 4,\n  MHD_GET_ARGUMENT_KIND = 8,\n  MHD_FOOTER_KIND = 16\n};\n\n/* Helper: log control path and state to a file. Do not modify its parameters. */\nstatic void\nlog_state(const char *event, const char *key, uint64_t off, size_t size, const struct Session *session)\n{\n  FILE *f = fopen(\"/tmp/logs/389.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  fprintf(f, \"EVENT: %s\\n\", event);\n  if (key != NULL)\n  {\n    fprintf(f, \"  key=%s\\n\", key);\n  }\n  fprintf(f, \"  off=%llu size=%zu\\n\", (unsigned long long) off, size);\n  if (session != NULL)\n  {\n    fprintf(f, \"  session.sid=%s\\n\", session->sid);\n    fprintf(f, \"  session.value_1='%s'\\n\", session->value_1);\n    fprintf(f, \"  session.value_2='%s'\\n\", session->value_2);\n  }\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  /* Log entry into the function */\n  log_state(\"enter\", key, off, size, session);\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    log_state(\"done_key\", key, off, size, session);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    log_state(\"v1_branch_start\", key, off, size, session);\n    if (off >= sizeof(session->value_1) - 1)\n    {\n      log_state(\"v1_discard_extra\", key, off, size, session);\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= sizeof(session->value_1))\n    {\n      /* Violation scenario: the parameter 'size' is modified to crop extra data. */\n      log_state(\"v1_crop_before\", key, off, size, session);\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n      log_state(\"v1_crop_after\", key, off, size, session);\n    }\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    log_state(\"v1_done\", key, off, size, session);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    log_state(\"v2_branch_start\", key, off, size, session);\n    if (off >= sizeof(session->value_2) - 1)\n    {\n      log_state(\"v2_discard_extra\", key, off, size, session);\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= sizeof(session->value_2))\n    {\n      log_state(\"v2_crop_before\", key, off, size, session);\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n      log_state(\"v2_crop_after\", key, off, size, session);\n    }\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    log_state(\"v2_done\", key, off, size, session);\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  log_state(\"unsupported_key\", key, off, size, session);\n  return MHD_YES;\n}\n"
}