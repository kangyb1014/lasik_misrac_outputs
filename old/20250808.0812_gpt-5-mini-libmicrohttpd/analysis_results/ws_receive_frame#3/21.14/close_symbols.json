{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "memcmp",
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "malloc",
    "run_usock"
  ],
  "explanation": "- memcmp: The MISRA rule centers on use of the library function memcmp. To decide if ws_receive_frame violates the rule we must check whether it (directly) calls memcmp or whether any macro/alias in-scope expands to memcmp.\n- WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: These are macros/constants referenced in the function. Although they are most likely integer constants, they could (rarely) be implemented as complex macros or inline constructs that expand to function calls or expressions that themselves use memcmp. The definitions must be checked to exclude hidden memcmp usage.\n- malloc: The function allocates memory with malloc. A project may wrap/define malloc as a macro or custom function; the wrapper could (unlikely) use memcmp or other string comparison. Confirming the actual symbol ensures no indirect memcmp usage via allocation wrapper.\n- run_usock: The caller is included because callers or inlined caller code might supply macros/types or instrumentations (or cause inlining) that bring memcmp into the compiled body of ws_receive_frame. Checking the caller and build context helps ensure no indirect/inlined memcmp usage affects the target function.\n\nThese symbols are sufficient to determine whether memcmp is used directly or indirectly in the target function. If any of these definitions are ordinary constants/standard malloc and memcmp are not present in the function body or in expanded macros, then ws_receive_frame does not violate the MISRA rule."
}