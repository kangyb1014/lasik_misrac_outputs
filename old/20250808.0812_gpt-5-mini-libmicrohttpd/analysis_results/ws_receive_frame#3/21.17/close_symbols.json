{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "run_usock",
    "frame buffer allocation / recv buffer in run_usock (the variable and allocation/recv site that creates/populates the 'frame' buffer)",
    "the variable passed as ssize_t *length by run_usock (provenance and initial value of *length)",
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "Any buffer-size constants or macros used when creating 'frame' in run_usock (e.g. RECV_BUFSIZE, MAX_FRAME_SIZE)",
    "malloc (allocator implementation / prototype from <stdlib.h>)"
  ],
  "explanation": "To determine whether ws_receive_frame can cause out-of-bounds accesses (the MISRA rule about string.h functions is about out-of-bounds string operations, but we must still check any buffer/indexing that could be out-of-bounds even though this function does not call string.h):\n\n- run_usock: ws_receive_frame is only called by run_usock (per the static call graph). You must inspect run_usock to see how it constructs the 'frame' buffer and the lifetime/validity of the pointer passed in. The caller may validate frame contents or length; absence of checks in the caller can make the indexing in ws_receive_frame unsafe.\n\n- frame buffer allocation / recv buffer in run_usock (the variable and allocation/recv site that creates/populates the 'frame' buffer): The function indexes frame at multiple offsets (frame[0], frame[1], frame[idx_first_mask + 0..3], frame[idx_first_data .. *length-1]). You need the exact allocation size and how many bytes are written into 'frame' to ensure these indexes are within the buffer.\n\n- the variable passed as ssize_t *length by run_usock (provenance and initial value of *length): ws_receive_frame uses *length to compute data_length and loop bounds (for i = idx_first_data; i < *length; i++). The correctness of those bounds depends on the initial *length value supplied by the caller \u2014 you must inspect where that value comes from and whether it reflects the actual number of bytes available in 'frame'.\n\n- WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: These macros/constants determine which branch is executed. The text-frame branch performs multiple indexed reads; the other branches do not. Knowing their values is necessary to reason about control flow and which indexing code can run.\n\n- Any buffer-size constants or macros used when creating 'frame' in run_usock (e.g. RECV_BUFSIZE, MAX_FRAME_SIZE): If the caller uses a fixed receive buffer size or limits reads by such macros, those limits must be checked against the indexing offsets computed in ws_receive_frame to ensure no out-of-bounds access.\n\n- malloc (allocator implementation / prototype from <stdlib.h>): ws_receive_frame allocates msg with malloc(data_length + 1) and then writes msg[j] for j = 0..data_length and a terminating '\\0'. You need the standard malloc semantics (and whether the project replaces it) to confirm the allocated size matches the written range.\n\nThese symbols (caller + buffer allocation + length provenance + the WS_* constants + allocator) are sufficient to reason about whether any indexing in ws_receive_frame can access beyond the bounds of the provided buffers. No standard <string.h> functions are called in this function, but the same out-of-bounds concerns apply to the explicit byte copies and the null termination performed here; the listed symbols let the next analyst verify bounds safety."
}