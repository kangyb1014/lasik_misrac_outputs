{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling serve_simple_form with a pointer to an object that is not NUL-terminated (for example, the first member array of a struct which is not terminated, while the next struct member contains the terminating '\\0'). strlen(form) will read past the bounds of the first array into the adjacent member to find the terminator \u2014 this is an access beyond the bounds of the object referenced by 'form', violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_YesNo { MHD_NO = 0, MHD_YES = 1 };\nstruct MHD_Response {\n  const void *buf;\n  size_t len;\n};\nconst char *MHD_HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\nstruct MHD_Response *\nMHD_create_response_from_buffer_static (size_t len, const void *buf)\n{\n  struct MHD_Response *r = (struct MHD_Response *) malloc (sizeof (*r));\n  if (r != NULL)\n  {\n    r->buf = buf;\n    r->len = len;\n  }\n  return r;\n}\nenum MHD_YesNo\nMHD_add_response_header (struct MHD_Response *resp,\n                         const char *header,\n                         const char *value)\n{\n  /* pretend it always succeeds */\n  (void) resp; (void) header; (void) value;\n  return MHD_YES;\n}\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *conn,\n                    int status_code,\n                    struct MHD_Response *resp)\n{\n  /* log queueing event for visibility */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"MHD_queue_response: conn=%p status=%d resp=%p len=%zu\\n\",\n             (void *) conn, status_code, (void *) resp, (resp ? resp->len : 0));\n    fclose (f);\n  }\n  (void) resp; (void) status_code; (void) conn;\n  return MHD_HTTP_OK;\n}\nvoid\nMHD_destroy_response (struct MHD_Response *resp)\n{\n  free (resp);\n}\nvoid probe_violation (void)\n{\n  /* ensure log directory exists (ignore errors) */\n  (void) mkdir (\"/tmp/logs\", 0777);\n\n  struct Container {\n    char a[4];    /* not NUL-terminated */\n    char term;    /* adjacent member holding the terminator */\n  } c;\n\n  c.a[0] = 'A'; c.a[1] = 'B'; c.a[2] = 'C'; c.a[3] = 'D';\n  c.term = '\\0'; /* terminator lives in the adjacent object */\n\n  /* log the setup so test log shows why strlen must read past c.a */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"probe_violation: container at %p, a=%p, term at %p value=0x%02X\\n\",\n             (void *) &c, (void *) c.a, (void *) &c.term, (unsigned char) c.term);\n    fclose (f);\n  }\n\n  /* Call serve_simple_form with a pointer to the non-NUL-terminated array. */\n  (void) serve_simple_form ((const void *) c.a, \"text/html\", NULL, NULL);\n}\n\nvoid\nadd_session_cookie (struct Session *session, struct MHD_Response *response)\n{\n  (void) session; (void) response; /* no-op for this test harness */\n}\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* log entry and the bytes at the start of form (not assuming NUL) */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"enter serve_simple_form: form=%p mime=%s session=%p connection=%p\\n\",\n               (void *) form, (mime ? mime : \"(null)\"), (void *) session, (void *) connection);\n      /* dump a few bytes starting at form for visibility (print as chars and hex) */\n      if (form != NULL)\n      {\n        fprintf (f, \"form bytes: \");\n        for (size_t i = 0U; i < 8U; ++i)\n        {\n          unsigned char c = (unsigned char) form[i];\n          fprintf (f, \"%c(0x%02X) \", (c >= 32 && c < 127) ? (char) c : '.', c);\n        }\n        fprintf (f, \"\\n\");\n      }\n      fclose (f);\n    }\n  }\n\n  /* return static form */\n  {\n    size_t len = strlen (form); /* POTENTIAL OUT-OF-BOUNDS read if 'form' isn't NUL-terminated */\n\n    /* log the computed length */\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"strlen(form) -> %zu\\n\", len);\n      fclose (f);\n    }\n\n    response = MHD_create_response_from_buffer_static (len, form);\n  }\n\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* log exit */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"exit serve_simple_form: ret=%d\\n\", ret);\n      fclose (f);\n    }\n  }\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. serve_simple_form calls strlen(form) on the pointer derived from cls without any guarantee that the pointed-to array is NUL-terminated. If a caller passes a pointer to an array that does not contain a terminating '\\0' (for example the first member of a struct where the terminator is in the next member), strlen will read past the bounds of that array to find a terminator \u2014 this is an out-of-bounds access / undefined behavior and therefore violates MISRA C 2023 Rule 21.17. (The provided test harness failing to compile does not change the correctness of the reasoning: the code as written can cause out-of-bounds access for some valid calls.)"
}