{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_del_response_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/398.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_del_response_header as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_del_response_header:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_del_response_header:\nstruct MHD_HTTP_Res_Header\n{\n  /**\n   * Headers are kept in a double-linked list.\n   */\n  struct MHD_HTTP_Res_Header *next;\n\n  /**\n   * Headers are kept in a double-linked list.\n   */\n  struct MHD_HTTP_Res_Header *prev;\n\n  /**\n   * The name of the header (key), without the colon.\n   */\n  char *header;\n\n  /**\n   * The length of the @a header, not including the final zero termination.\n   */\n  size_t header_size;\n\n  /**\n   * The value of the header.\n   */\n  char *value;\n\n  /**\n   * The length of the @a value, not including the final zero termination.\n   */\n  size_t value_size;\n\n  /**\n   * Type of the value.\n   */\n  enum MHD_ValueKind kind;\n\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n...\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;\n  if (0 == hdr->value_size)\n  {\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n  }\n  else\n  {\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }\n  }\n  return MHD_YES;\n}\n...\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n...\n#define _MHD_remove_header(presponse, phdr) do{mhd_assert(NULL!=presponse->first_header);mhd_assert(NULL!=presponse->last_header);if(NULL==phdr->prev){mhd_assert(phdr==presponse->first_header);presponse->first_header=phdr->next;}else{mhd_assert(phdr!=presponse->first_header);mhd_assert(phdr==phdr->prev->next);phdr->prev->next=phdr->next;}if(NULL==phdr->next){mhd_assert(phdr==presponse->last_header);presponse->last_header=phdr->prev;}else{mhd_assert(phdr!=presponse->last_header);mhd_assert(phdr==phdr->next->prev);phdr->next->prev=phdr->prev;}\\\n}while(0)\n...\nbool\nMHD_str_equal_caseless_bin_n_ (const char *const str1,\n                               const char *const str2,\n                               size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; ++i)\n  {\n    const char c1 = str1[i];\n    const char c2 = str2[i];\n    if (charsequalcaseless (c1, c2))\n      continue;\n    else\n      return 0;\n  }\n  return ! 0;\n}\n...\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n...\n#define MHD_HTTP_HEADER_CONNECTION \"Connection\"\n...\n#define MHD_HTTP_HEADER_TRANSFER_ENCODING \"Transfer-Encoding\"\n...\n#define MHD_HTTP_HEADER_DATE \"Date\"\n...\n#define MHD_HTTP_HEADER_CONTENT_LENGTH \"Content-Length\"\n</additional code>\nJudge whether the above MHD_del_response_header code violates the rule 21.14 or not.",
  "is_rule_violated": true,
  "scenario": "The function computes header_len = strlen(header) and content_len = strlen(content) (both inputs are null-terminated strings) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare them. This is memcmp being used to compare null-terminated strings, which violates MISRA C 2023 Rule 21.14.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <stdint.h>\n\n/* Minimal types and constants to allow compilation and preserve logic */\n\ntypedef enum MHD_Result { MHD_NO = 0, MHD_YES = 1 } MHD_Result;\n\nenum MHD_ValueKind { MHD_HEADER_KIND };\n\nenum MHD_ResponseAutoFlags\n{\n  MHD_RAF_HAS_CONNECTION_HDR = 0x01,\n  MHD_RAF_HAS_CONNECTION_CLOSE = 0x02,\n  MHD_RAF_HAS_TRANS_ENC_CHUNKED = 0x04,\n  MHD_RAF_HAS_DATE_HDR = 0x08,\n  MHD_RAF_HAS_CONTENT_LENGTH = 0x10\n};\n\nstruct MHD_HTTP_Res_Header\n{\n  struct MHD_HTTP_Res_Header *next;\n  struct MHD_HTTP_Res_Header *prev;\n  char *header;\n  size_t header_size;\n  char *value;\n  size_t value_size;\n  enum MHD_ValueKind kind;\n};\n\nstruct MHD_Response\n{\n  struct MHD_HTTP_Res_Header *first_header;\n  struct MHD_HTTP_Res_Header *last_header;\n  unsigned int flags_auto;\n  unsigned int flags;\n  void *upgrade_handler;\n};\n\n/* String constants (no macros as required) */\nstatic const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nstatic const char MHD_HTTP_HEADER_TRANSFER_ENCODING[] = \"Transfer-Encoding\";\nstatic const char MHD_HTTP_HEADER_DATE[] = \"Date\";\nstatic const char MHD_HTTP_HEADER_CONTENT_LENGTH[] = \"Content-Length\";\n\n/* Helper: static string length function to replace the macro use */\nstatic size_t staticstr_len(const char *s)\n{\n  return strlen(s);\n}\n\n/* Simple caseless binary compare used elsewhere in the code */\nstatic int charsequalcaseless(char a, char b)\n{\n  unsigned char ua = (unsigned char) a;\n  unsigned char ub = (unsigned char) b;\n  if (ua >= 'A' && ua <= 'Z') ua = (unsigned char)(ua - 'A' + 'a');\n  if (ub >= 'A' && ub <= 'Z') ub = (unsigned char)(ub - 'A' + 'a');\n  return ua == ub;\n}\n\nbool MHD_str_equal_caseless_bin_n_ (const char *const str1,\n                                    const char *const str2,\n                                    size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; ++i)\n  {\n    const char c1 = str1[i];\n    const char c2 = str2[i];\n    if (charsequalcaseless (c1, c2))\n      continue;\n    else\n      return 0;\n  }\n  return ! 0;\n}\n\n/* Minimal implementation of get element by key (linear search) */\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (response == NULL || key == NULL || key_len == 0U)\n    return NULL;\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n\n/* Minimal list removal routine, replacing the macro in the original code */\nstatic void _MHD_remove_header (struct MHD_Response *presponse,\n                                struct MHD_HTTP_Res_Header *phdr)\n{\n  if (NULL == presponse || NULL == phdr)\n    return;\n\n  if (NULL == phdr->prev)\n  {\n    presponse->first_header = phdr->next;\n  }\n  else\n  {\n    phdr->prev->next = phdr->next;\n  }\n\n  if (NULL == phdr->next)\n  {\n    presponse->last_header = phdr->prev;\n  }\n  else\n  {\n    phdr->next->prev = phdr->prev;\n  }\n}\n\n/* Logging helper that appends to /tmp/logs/398.txt; tries to create dir if needed */\nstatic void log_state(const char *fmt, ...)\n{\n  FILE *f = NULL;\n  /* attempt to create parent directory (ignore errors) */\n  (void) mkdir(\"/tmp/logs\", 0755);\n  f = fopen(\"/tmp/logs/398.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n/* Forward declaration of the connection-specific deletion (kept minimal) */\nstatic enum MHD_Result del_response_header_connection (struct MHD_Response *response,\n                                                       const char *value);\n\n/* The modified MHD_del_response_header with logging probes. Preserves original logic. */\nenum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  log_state(\"ENTER MHD_del_response_header: response=%p, header=%p, content=%p\", (void *)response, (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    log_state(\"NULL parameter: header=%p content=%p\", (const void *)header, (const void *)content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  log_state(\"computed header_len=%zu for header='%s'\", header_len, header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (staticstr_len(MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    log_state(\"delegating to del_response_header_connection branch\");\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  log_state(\"computed content_len=%zu for content='%s'\", content_len, content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    log_state(\"iterating header node: pos=%p header_size=%zu value_size=%zu\", (void *)pos, pos->header_size, pos->value_size);\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      log_state(\"memcmp succeeded for header_len=%zu content_len=%zu; removing header node %p\", header_len, content_len, (void *)pos);\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (staticstr_len(MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        log_state(\"matched Transfer-Encoding header; clearing TRANS_ENC_CHUNKED flag(0x%X)\", response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      }\n      else if ( (staticstr_len(MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        log_state(\"matched Date header; clearing DATE_HDR flag(0x%X)\", response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      }\n      else if ( (staticstr_len(MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        log_state(\"matched Content-Length header; checking for other content-length headers\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          log_state(\"no other Content-Length header found; clearing CONTENT_LENGTH flag(0x%X)\", response->flags_auto);\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n      }\n      log_state(\"header removed, returning MHD_YES\");\n      return MHD_YES;\n    }\n    else\n    {\n      /* Log mismatch details */\n      int hcmp = 0;\n      int vcmp = 0;\n      if (header_len == pos->header_size)\n        hcmp = memcmp(header, pos->header, header_len);\n      else\n        hcmp = -1;\n      if (content_len == pos->value_size)\n        vcmp = memcmp(content, pos->value, content_len);\n      else\n        vcmp = -1;\n      log_state(\"comparison failed: hcmp=%d vcmp=%d (header_len=%zu pos->header_size=%zu content_len=%zu pos->value_size=%zu)\", hcmp, vcmp, header_len, pos->header_size, content_len, pos->value_size);\n    }\n    pos = pos->next;\n  }\n  log_state(\"no matching header found; returning MHD_NO\");\n  return MHD_NO;\n}\n\n/* Minimal implementation of del_response_header_connection to allow linking. */\nstatic enum MHD_Result del_response_header_connection (struct MHD_Response *response,\n                                                       const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr;\n\n  log_state(\"ENTER del_response_header_connection: response=%p value='%s'\", (void *)response, value ? value : \"(null)\");\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     staticstr_len(MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n  {\n    log_state(\"no Connection header present\");\n    return MHD_NO;\n  }\n\n  /* A simplified token removal: if value matches exactly hdr->value, remove token */\n  if (strlen(value) != hdr->value_size)\n  {\n    log_state(\"token length mismatch: value_len=%zu hdr->value_size=%zu\", strlen(value), hdr->value_size);\n    return MHD_NO;\n  }\n  if (0 != memcmp(hdr->value, value, hdr->value_size))\n  {\n    log_state(\"token content mismatch\");\n    return MHD_NO;\n  }\n\n  /* remove header entirely for simplicity */\n  _MHD_remove_header(response, hdr);\n  free(hdr->value);\n  free(hdr->header);\n  free(hdr);\n  response->flags_auto &= ~((enum MHD_ResponseAutoFlags) (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE));\n  log_state(\"Connection header removed\");\n  return MHD_YES;\n}\n"
}