{
  "user_message": "An agent A claimed that the following get_no_space_err_status_code code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of get_no_space_err_status_code.\n```c\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function get_no_space_err_status_code takes a non-const pointer argument 'struct MHD_Connection *c' even though it only reads fields of the connection and does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Making 'c' a 'const struct MHD_Connection *' would be preferred, unless functions called with 'c' (e.g. MHD_lookup_connection_value_n) legitimately modify the connection. In the shown code, no modification of *c is performed in this function, so the non-const pointer is a violation scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <assert.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n/* Unique, non-conflicting test-only types and names so this file can\n   be compiled alongside other project files without symbol collisions. */\n\nenum test_connection_state\n{\n  TEST_CONNECTION_REQ_LINE_RECEIVED = 1,\n  TEST_CONNECTION_HEADERS_RECEIVED = 2\n};\n\nstruct field_lines_t {\n  char *start;\n  size_t size;\n};\n\nstruct request_t {\n  struct field_lines_t field_lines;\n  size_t req_target_len;\n  int http_mthd; /* treat as an int for simplicity */\n  char *method;\n};\n\nstruct test_connection {\n  enum test_connection_state state;\n  struct request_t rq;\n  char *read_buffer;\n  size_t read_buffer_offset;\n  /* If >0, indicates a Host header value length available from\n     connection lookup (so we don't need a separate lookup function). */\n  size_t host_value_len;\n};\n\nenum test_proc_recv_stage {\n  TEST_PROC_RECV_HEADERS = 1,\n  TEST_PROC_RECV_BODY_CHUNKED = 2,\n};\n\n/* Constants (kept as variables, not macros). */\nstatic const size_t TEST_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ = 4;\nstatic const size_t TEST_MAX_REASONABLE_HEADERS_SIZE_ = 1024;\nstatic const size_t TEST_MAX_REASONABLE_REQ_TARGET_SIZE_ = 8192;\nstatic const size_t TEST_MIN_REASONABLE_HEADERS_SIZE_ = 32;\nstatic const size_t TEST_MIN_REASONABLE_REQ_TARGET_SIZE_ = 64;\nstatic const size_t TEST_MIN_REASONABLE_REQ_METHOD_SIZE_ = 4;\nstatic const char TEST_HTTP_HEADER_HOST[] = \"Host\";\n\n/* HTTP status codes used by the function. */\nstatic const unsigned int HTTP_CONTENT_TOO_LARGE = 413;\nstatic const unsigned int HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;\nstatic const unsigned int HTTP_NOT_IMPLEMENTED = 501;\nstatic const unsigned int HTTP_URI_TOO_LONG = 414;\n\n/* The function preserves the original logic of get_no_space_err_status_code\n   as closely as possible but uses the test-prefixed types above to avoid\n   name collisions with the rest of the project. */\nstatic unsigned int\nget_no_space_err_status_code_test(struct test_connection *c,\n                                 enum test_proc_recv_stage stage,\n                                 const char *add_element,\n                                 size_t add_element_size)\n{\n  FILE *log = fopen(\"/tmp/logs/43.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entering get_no_space_err_status_code_test: c=%p, state=%d, stage=%d, add_element=%p, add_element_size=%zu\\n\",\n            (void *)c, c ? c->state : -1, (int)stage, (const void *)add_element, add_element_size);\n  }\n\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  /* Keep the original assertions' intent using standard assert(). */\n  assert(c != NULL);\n  assert(TEST_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  assert(TEST_PROC_RECV_HEADERS <= stage);\n  assert((0 == add_element_size) || (NULL != add_element));\n\n  if (TEST_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    assert(NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n    if (log) fprintf(log, \"Computed opt_headers_size (partial read buffer) = %zu\\n\", opt_headers_size);\n  }\n  else\n  {\n    opt_headers_size = c->rq.field_lines.size;\n    if (log) fprintf(log, \"Using opt_headers_size (stored) = %zu\\n\", opt_headers_size);\n  }\n\n  if (log) fprintf(log, \"Stage check: stage=%d, add_element_size=%zu\\n\", (int)stage, add_element_size);\n\n  if ((TEST_PROC_RECV_BODY_CHUNKED == stage) &&\n      (TEST_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    if (log) fprintf(log, \"Returning CONTENT_TOO_LARGE (chunked and large add_element)\\n\"); if (log) fclose(log);\n    return HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n\n  if ((TEST_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    const size_t header_host_key_len = sizeof(TEST_HTTP_HEADER_HOST) - 1;\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && (0 == strncasecmp(TEST_HTTP_HEADER_HOST,\n                           add_element,\n                           header_host_key_len));\n    if (log) fprintf(log, \"is_host_header=%d\\n\", (int)is_host_header);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (TEST_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      assert(! is_parsed || (0 == add_element[header_host_key_len]));\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      assert(opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n      if (log) fprintf(log, \"Host header parsed: actual_element_size=%zu, opt_headers_size now=%zu\\n\",\n                       actual_element_size, opt_headers_size);\n    }\n  }\n\n  if (0 == host_field_line_size)\n  {\n    const size_t host_field_name_len = sizeof(TEST_HTTP_HEADER_HOST) - 1;\n    size_t host_field_name_value_len;\n    /* Instead of calling an external lookup, use a field on the connection\n       that indicates the host header's value length (0 if none). */\n    host_field_name_value_len = c->host_value_len;\n    if (host_field_name_value_len != 0)\n    {\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* ':' and LF */\n\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0;\n\n      if (log) fprintf(log, \"Host from lookup: host_field_line_size=%zu, opt_headers_size=%zu\\n\",\n                       host_field_line_size, opt_headers_size);\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (/*MHD_HTTP_MTHD_OTHER !=*/ c->rq.http_mthd /* simplified */)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    assert(NULL != c->rq.method);\n    method_size = strlen(c->rq.method);\n  }\n\n  if ((size_t) TEST_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    if (log) fprintf(log, \"Large opt_headers_size branch: opt_headers_size=%zu, uri_size=%zu, method_size=%zu\\n\",\n                     opt_headers_size, uri_size, method_size);\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n      {\n        if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE\\n\"); if (log) fclose(log);\n        return HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return HTTP_NOT_IMPLEMENTED;\n      }\n    }\n    else\n    {\n      if ((uri_size / 16) > method_size)\n      {\n        if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n        return HTTP_URI_TOO_LONG;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return HTTP_NOT_IMPLEMENTED;\n      }\n    }\n  }\n  if ((size_t) TEST_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    if (log) fprintf(log, \"URI too large branch: uri_size=%zu, method_size=%zu\\n\", uri_size, method_size);\n    if ((uri_size / 16) > method_size)\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n      return HTTP_URI_TOO_LONG;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n      return HTTP_NOT_IMPLEMENTED;\n    }\n  }\n\n  if ((size_t) TEST_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    if (log) fprintf(log, \"Min reasonable headers branch: opt_headers_size=%zu, uri_size=%zu, method_size=%zu\\n\",\n                     opt_headers_size, uri_size, method_size);\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n      {\n        if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE\\n\"); if (log) fclose(log);\n        return HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return HTTP_NOT_IMPLEMENTED;\n      }\n    }\n    else\n    {\n      if (uri_size > method_size * 4)\n      {\n        if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n        return HTTP_URI_TOO_LONG;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return HTTP_NOT_IMPLEMENTED;\n      }\n    }\n  }\n  if ((size_t) TEST_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    if (log) fprintf(log, \"Recommend shorter request target: uri_size=%zu, method_size=%zu\\n\", uri_size, method_size);\n    if (uri_size > method_size * 4)\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n      return HTTP_URI_TOO_LONG;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n      return HTTP_NOT_IMPLEMENTED;\n    }\n  }\n\n  if ((size_t) TEST_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    if (log) fprintf(log, \"Method is very large: returning NOT_IMPLEMENTED\\n\"); if (log) fclose(log);\n    return HTTP_NOT_IMPLEMENTED;\n  }\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n    {\n      if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE (final)\\n\"); if (log) fclose(log);\n      return HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG (final)\\n\"); if (log) fclose(log);\n      return HTTP_URI_TOO_LONG;\n    }\n  }\n\n  if (0 != host_field_line_size)\n  {\n    if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE (no reducible elements)\\n\"); if (log) fclose(log);\n    return HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n  }\n\n  if (log) fprintf(log, \"Returning URI_TOO_LONG (default) and exiting\\n\"); if (log) fclose(log);\n  return HTTP_URI_TOO_LONG;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reviewer inspected get_no_space_err_status_code and confirmed that the function itself does not directly modify the object pointed to by parameter c: it only reads fields of *c and uses those values. Under MISRA C 2023 Rule 8.13 a pointer parameter should be const-qualified when possible. So, on a surface level, the parameter could be declared as const struct MHD_Connection * to better reflect that this function does not mutate the connection.\n\nHowever, the rule contains the important exception that a pointer must not be const-qualified if the pointer is passed to other functions that legitimately modify the pointed-to object or whose prototypes require a non-const pointer. The implementation shown calls other routines (for example MHD_lookup_connection_value_n and various project macros/wrappers). No prototypes for those functions are provided here, and the agent\u2019s test replacement did not demonstrate that those callees accept a const pointer or do not modify the connection. Because the call-chain and prototypes are not shown, it is not possible to conclusively determine whether making c const is feasible without changing or casting when calling those functions. If any callee requires a non-const struct MHD_Connection * or may modify the connection, keeping the parameter non-const is justified and not a MISRA violation.\n\nConclusion: the observation that the function itself does not mutate *c is correct and this function is a candidate for a const-qualified pointer parameter. But the report as stated \u2014 claiming a violation \u2014 is not proven because the necessary verification of the callees\u2019 prototypes/behaviour is missing. Therefore the report cannot be judged correct based on the provided evidence."
}