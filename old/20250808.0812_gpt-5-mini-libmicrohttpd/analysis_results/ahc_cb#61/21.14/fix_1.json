{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nlog_probe (const char *stage, const void *res_ptr, const char *note)\n{\n  FILE *f = fopen (\"/tmp/logs/494.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"stage: %s\\n\", stage);\n  fprintf (f, \"res_ptr: %p\\n\", res_ptr);\n  if (note != NULL)\n    fprintf (f, \"note: %s\\n\", note);\n  fprintf (f, \"----\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"entry\", NULL, \"ahc_cb entered\");\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    log_probe (\"first_req\", NULL, \"initial request class set\");\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws\", NULL, \"not a websocket request, sending chat page\");\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, \"bad method or version\");\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_ws_version\", NULL, \"missing or unsupported websocket version\");\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    log_probe (\"bad_key\", NULL, \"missing or wrong size websocket key\");\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    log_probe (\"ws_get_accept_failed\", NULL, \"ws_get_accept_value failed\");\n    return ret;\n  }\n\n  /* Create the upgrade response as in original logic */\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  log_probe (\"created_response\", res, \"response created for upgrade\");\n\n  /*\n   * Probe scenario that exercises the code path where memcmp is used to\n   * compare a null-terminated header value to the literal \"close\".\n   * We add the \"Connection: close\" header first and then add another\n   * connection header value to force the update path where the existing\n   * header entry is inspected (this triggers the mhd_assert that contains\n   * the memcmp in add_response_header_connection).\n   *\n   * These extra calls are probes only and intended to record the control\n   * flow and state. They preserve the rest of ahc_cb logic as much as\n   * possible.\n   */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"close\");\n  log_probe (\"after_add_connection_close\", res, \"added Connection: close\");\n\n  /* Second addition triggers the update branch in add_response_header_connection */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"keep-alive\");\n  log_probe (\"after_add_connection_keepalive\", res, \"added Connection: keep-alive to trigger update path\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    log_probe (\"add_accept_failed\", res, \"failed to add Sec-WebSocket-Accept header\");\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    log_probe (\"add_upgrade_failed\", res, \"failed to add Upgrade header\");\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  log_probe (\"queued_response\", res, (ret == MHD_YES) ? \"queued ok\" : \"queue failed\");\n  MHD_destroy_response (res);\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpnmlk1e82/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_cb as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed translation unit that preserves ahc_cb logic but provides the\n   minimal type/identifier declarations so this file can be compiled as a\n   standalone translation unit. No mock functions are defined; only\n   external prototypes and constants are declared. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal public types used by the original code (opaque here). */\nstruct MHD_Connection;\nstruct MHD_Response;\n\n/* Result type used by libmicrohttpd (minimal). */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Common header-kind identifier used in the calls below. Use a const\n   pointer rather than a macro to satisfy the constraint. */\nstatic const char *const MHD_HEADER_KIND = \"header\";\n\n/* HTTP header name constants used by the code. */\nstatic const char *const MHD_HTTP_HEADER_UPGRADE = \"Upgrade\";\nstatic const char *const MHD_HTTP_HEADER_CONNECTION = \"Connection\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION = \"Sec-WebSocket-Version\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT = \"Sec-WebSocket-Accept\";\n\n/* HTTP method / version strings referenced in the logic. */\nstatic const char *const MHD_HTTP_METHOD_GET = \"GET\";\nstatic const char *const MHD_HTTP_VERSION_1_1 = \"HTTP/1.1\";\n\n/* WebSocket constants used in the logic. */\nstatic const char *const WS_SEC_WEBSOCKET_VERSION = \"13\"; /* RFC6455 */\nstatic const size_t WS_KEY_LEN = 24; /* Base64 of 16 bytes -> 24 chars */\nstatic const char *const WS_UPGRADE_VALUE = \"websocket\";\n\n/* HTTP status code used when queueing the response. */\nstatic const int MHD_HTTP_SWITCHING_PROTOCOLS = 101;\n\n/* Forward declarations for external functions. These are declared but not\n   defined here (no mock implementations). This allows the TU to compile\n   without pulling in the actual libmicrohttpd implementation. */\nextern const char *MHD_lookup_connection_value(struct MHD_Connection *con,\n                                               const char *kind,\n                                               const char *key);\n\nextern enum MHD_Result MHD_lookup_connection_value_n(struct MHD_Connection *con,\n                                                     const char *kind,\n                                                     const char *key,\n                                                     size_t key_len,\n                                                     const char **value_p,\n                                                     size_t *value_len);\n\nextern enum MHD_Result is_websocket_request(struct MHD_Connection *con,\n                                           const char *upg_header,\n                                           const char *con_header);\n\nextern enum MHD_Result send_chat_page(struct MHD_Connection *con);\nextern enum MHD_Result send_bad_request(struct MHD_Connection *con);\nextern enum MHD_Result send_upgrade_required(struct MHD_Connection *con);\n\nextern enum MHD_Result ws_get_accept_value(const char *key, char **out_accept);\n\n/* The original code passes &uh_cb to MHD_create_response_for_upgrade. We\n   declare uh_cb as an external function so the address-of usage compiles. */\nextern void uh_cb(void);\n\nextern struct MHD_Response *MHD_create_response_for_upgrade(void (*upgrade_cb)(void),\\n                                                            void *cls);\n\nextern enum MHD_Result MHD_add_response_header(struct MHD_Response *res,\n                                               const char *name,\n                                               const char *value);\n\nextern void MHD_destroy_response(struct MHD_Response *res);\n\nextern enum MHD_Result MHD_queue_response(struct MHD_Connection *con,\n                                          int status_code,\n                                          struct MHD_Response *res);\n\n/* Simple logging helper used by the original source. */\nstatic void\nlog_probe (const char *stage, const void *res_ptr, const char *note)\n{\n  FILE *f = fopen (\"/tmp/logs/494.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"stage: %s\\n\", stage);\n  fprintf (f, \"res_ptr: %p\\n\", res_ptr);\n  if (note != NULL)\n    fprintf (f, \"note: %s\\n\", note);\n  fprintf (f, \"----\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"entry\", NULL, \"ahc_cb entered\");\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    log_probe (\"first_req\", NULL, \"initial request class set\");\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws\", NULL, \"not a websocket request, sending chat page\");\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, \"bad method or version\");\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_ws_version\", NULL, \"missing or unsupported websocket version\");\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    log_probe (\"bad_key\", NULL, \"missing or wrong size websocket key\");\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    log_probe (\"ws_get_accept_failed\", NULL, \"ws_get_accept_value failed\");\n    return ret;\n  }\n\n  /* Create the upgrade response as in original logic */\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  log_probe (\"created_response\", res, \"response created for upgrade\");\n\n  /*\n   * Probe scenario that exercises the code path where memcmp is used to\n   * compare a null-terminated header value to the literal \"close\".\n   * We add the \"Connection: close\" header first and then add another\n   * connection header value to force the update path where the existing\n   * header entry is inspected (this triggers the mhd_assert that contains\n   * the memcmp in add_response_header_connection).\n   *\n   * These extra calls are probes only and intended to record the control\n   * flow and state. They preserve the rest of ahc_cb logic as much as\n   * possible.\n   */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"close\");\n  log_probe (\"after_add_connection_close\", res, \"added Connection: close\");\n\n  /* Second addition triggers the update branch in add_response_header_connection */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"keep-alive\");\n  log_probe (\"after_add_connection_keepalive\", res, \"added Connection: keep-alive to trigger update path\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    log_probe (\"add_accept_failed\", res, \"failed to add Sec-WebSocket-Accept header\");\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    log_probe (\"add_upgrade_failed\", res, \"failed to add Upgrade header\");\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  log_probe (\"queued_response\", res, (ret == MHD_YES) ? \"queued ok\" : \"queue failed\");\n  MHD_destroy_response (res);\n  return ret;\n}\n",
  "explanation": "To make this translation unit compile I added minimal opaque type declarations, an enum for MHD_Result, const variables for header and protocol strings (instead of macros), and prototypes for the external libmicrohttpd and helper functions referenced by ahc_cb. I did not provide any mock implementations or a main function \u2014 all external functions remain declared but undefined so the file compiles as a TU while preserving the original ahc_cb logic and call structure."
}