{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs in ws_get_accept_value: the function uses strlen(key) and then calls strncpy(str, key, WS_KEY_LEN + 1). If the header value (key) is not NUL-terminated (pos->value is returned with value_size == WS_KEY_LEN), strlen(key) will read past the buffer and strncpy will copy WS_KEY_LEN+1 bytes, causing a one-byte out-of-bounds read. Thus use of string.h functions can access beyond object bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *stage, const char *ws_key_header, size_t key_size)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  size_t i;\n  if (NULL == f)\n    return;\n  fprintf (f, \"[ahc_cb] stage=%s\\n\", stage);\n  fprintf (f, \"[ahc_cb] ws_key_header_ptr=%p key_size=%zu\\n\",\n           (const void *) ws_key_header, key_size);\n  if ((NULL != ws_key_header) && (key_size > 0))\n  {\n    /* Dump up to key_size bytes in hex. Use key_size (returned separately) to avoid relying on NUL-termination. */\n    fprintf (f, \"[ahc_cb] ws_key_header_bytes=\");\n    for (i = 0; i < key_size; ++i)\n      fprintf (f, \"%02x\", (unsigned char) ws_key_header[i]);\n    fprintf (f, \"\\n\");\n  }\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"enter\", NULL, 0);\n\n  if (NULL == *req_cls)\n  {\n    log_probe (\"first_request\", NULL, 0);\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND, \"Upgrade\");\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND, \"Connection\");\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws_request\", NULL, 0);\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, 0);\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_or_missing_ws_version\", NULL, 0);\n    return send_upgrade_required (con);\n  }\n\n  /* Lookup Sec-WebSocket-Key and obtain its size. */\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  log_probe (\"after_lookup_key\", ws_key_header, key_size);\n\n  if ((MHD_NO == ret) || (key_size != 24))\n  {\n    log_probe (\"invalid_key_size\", ws_key_header, key_size);\n    return send_bad_request (con);\n  }\n\n  /* Log just before calling ws_get_accept_value to capture the state that\n     leads to the string handling calls inside that function. */\n  log_probe (\"before_ws_get_accept_value\", ws_key_header, key_size);\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  log_probe (\"after_ws_get_accept_value\", ws_key_header, key_size);\n\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Sec-WebSocket-Accept\", ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Upgrade\", \"websocket\"))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, 101, res);\n  MHD_destroy_response (res);\n  log_probe (\"exit\", NULL, 0);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls MHD_lookup_connection_value_n to obtain ws_key_header together with an explicit length (key_size) and then calls ws_get_accept_value(ws_key_header, &ws_ac_value) without providing the length. If ws_get_accept_value uses string.h functions such as strlen(key) and strncpy(..., WS_KEY_LEN + 1) as described, those calls can read past the non-NUL-terminated header buffer (strlen will scan past the buffer looking for '\\0', and strncpy copying WS_KEY_LEN+1 bytes will read one byte past a length-only buffer of WS_KEY_LEN). That is exactly the sort of out-of-bounds access forbidden by MISRA C 2023 Rule 21.17. Note: the small number of other uses of string functions in ahc_cb (e.g. strlen on the constant header name, strcmp on method/version) are safe; the problematic path arises from treating a length-delimited header value as a NUL-terminated C string. To fix: ensure the header value is copied into a local buffer that is NUL-terminated (using memcpy and explicitly setting the terminator) or change ws_get_accept_value to accept a pointer+length and avoid strlen/strncpy on non-terminated data."
}