{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert calls in MHD_queue_basic_auth_required_response3 expand to ((void)0) (see mhd_assert macro). These assertion calls are executed statements that have no effect on program state; removing them would not change behavior. Therefore they constitute dead code and violate MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic size_t\nMHD_str_quote (const char *in, size_t in_len, char *out, size_t out_len)\n{\n  size_t in_i, out_i = 0;\n  for (in_i = 0; in_i < in_len && out_i < out_len; ++in_i)\n    {\n      char c = in[in_i];\n      if (c == '\"')\n        {\n          /* Need two characters: backslash + quote */\n          if (out_i + 2 > out_len)\n            break;\n          out[out_i++] = '\\\\';\n          out[out_i++] = '\"';\n        }\n      else\n        {\n          out[out_i++] = c;\n        }\n    }\n  return out_i;\n}\nstatic inline void\nmhd_assert (int /*cond*/)\n{\n  /* no-op */\n}\nstatic enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response, const char *name, const char *value)\n{\n  (void)response; (void)name; (void)value;\n  return MHD_YES;\n}\nstatic enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection, int status_code, struct MHD_Response *response)\n{\n  (void)connection; (void)status_code; (void)response;\n  return MHD_YES;\n}\nstatic void mhd_probe_log_state(const char *tag, size_t pos, size_t suffix_len,\n                                size_t h_maxlen, const char *h_str)\n{\n  FILE *f = fopen(\"/tmp/logs/578.txt\", \"a\");\n  if (f != NULL)\n  {\n    if (h_str != NULL)\n      fprintf(f, \"%s: pos=%zu suffix_len=%zu h_maxlen=%zu h_str=\\\"%s\\\"\\n\",\n              tag, pos, suffix_len, h_maxlen, h_str);\n    else\n      fprintf(f, \"%s: pos=%zu suffix_len=%zu h_maxlen=%zu h_str=(null)\\n\",\n              tag, pos, suffix_len, h_maxlen);\n    fclose(f);\n  }\n}\n\nenum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  const size_t prefix_len = sizeof(prefix) - 1;\n  const size_t suff_simple_len = sizeof(\"\\\"\") - 1; /* just a '\"' */\n  const size_t suff_charset_len = sizeof(suff_charset) - 1;\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n\n  /* Probe: log state before and after the mhd_assert which is a no-op */\n  mhd_probe_log_state(\"before_assert_1\", pos, suffix_len, h_maxlen, h_str);\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  mhd_probe_log_state(\"after_assert_1\", pos, suffix_len, h_maxlen, h_str);\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n\n    /* Probe: show that the assertion does not change observable state */\n    mhd_probe_log_state(\"before_assert_2\", pos, suffix_len, h_maxlen, h_str);\n    mhd_assert (pos <= h_maxlen + 1);\n    mhd_probe_log_state(\"after_assert_2\", pos, suffix_len, h_maxlen, h_str);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_probe_log_state(\"before_assert_3\", pos, suff_charset_len, h_maxlen, h_str);\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_probe_log_state(\"before_assert_4\", pos, suff_charset_len, h_maxlen, h_str);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n    mhd_probe_log_state(\"after_assert_4\", pos, suff_charset_len, h_maxlen, h_str);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 \"WWW-Authenticate\",\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              401,\n                              response);\n  }\n  else\n  {\n    /* Intentionally left empty (original code logged a message here). */\n  }\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to accept the claim as a definite MISRA 2.2 violation. Whether the mhd_assert calls are \u201cdead code\u201d depends on the project-wide definition and configuration of mhd_assert. If, in the actual project and build configuration, mhd_assert is defined everywhere as a no-op (for example expanding to ((void)0) or an empty inline function), then those assertion statements are operations that do not affect program behaviour and their presence would meet the textual definition of dead code and thus would violate Rule 2.2. However, in many projects mhd_assert is a macro that can be enabled in some builds (e.g. debug builds) to perform runtime checks. In that common situation removing the calls would change behaviour in some configurations, so they are not \u201cdead code\u201d for the project as a whole and do not violate Rule 2.2.\n\nAgent A assumed mhd_assert expands to ((void)0) without demonstrating that this is the project-wide, fixed definition. The provided test snippet defines mhd_assert as a no-op locally, but that local test does not prove the real project uses a no-op definition in all builds. The test also failed to compile so it provides no run-time evidence. Therefore the report as stated is not correct unless the reporter can show that mhd_assert is unconditionally a no-op across the entire project and all build configurations.\n\nConclusion: the report is not correct as a general claim; it would only be correct if the project-definitions make mhd_assert permanently a no-op (in which case the specific assertions would be dead code)."
}