{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_sys_cpu_count_special_api_': {'callees': [], 'callers': ['mhd_tool_get_system_cpu_count']}, 'mhd_tool_get_system_cpu_count': {'callees': ['mhd_tool_get_sys_cpu_count_special_api_', 'mhd_tool_get_sys_cpu_count_sysctl_', 'mhd_tool_get_sys_cpu_count_sysconf_', 'mhd_tool_get_proc_cpu_count', 'mhd_tool_get_sys_cpu_count_sysctl_fallback_', 'mhd_tool_get_sys_cpu_count_sysconf_fallback_'], 'callers': ['detect_cpu_core_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_PSTAT_GETDYNAMIC",
    "pstat_getdynamic",
    "struct pst_dynamic",
    "psd_proc_cnt",
    "HAVE_VXCPUENABLEDGET",
    "vxCpuEnabledGet",
    "cpuset_t",
    "_WIN32",
    "__CYGWIN__",
    "LoadLibraryA",
    "GetProcAddress",
    "FreeLibrary",
    "HMODULE",
    "FARPROC",
    "WINAPI",
    "DWORD",
    "WORD",
    "ALL_PROCESSOR_GROUPS",
    "SYSTEM_INFO",
    "GetNativeSystemInfo",
    "GetSystemInfo"
  ],
  "explanation": "To decide whether the target function uses compiler/language extensions (per the MISRA rule), the analyzer must know the definitions and declarations of platform-specific APIs, typedefs and macros used by the code so that any non\u2011standard language constructs (calling\u2011convention attributes, non\u2011standard pointer casts, implementation-defined typedefs, etc.) can be detected. Reason for each symbol:\n\n- HAVE_PSTAT_GETDYNAMIC: controls whether the HP-UX branch is compiled; needed to know if pstat API use is relevant for the compiled translation unit.\n- pstat_getdynamic: HP-UX system API used; its prototype may involve non\u2011standard attributes or calling conventions\u2014must inspect to detect extensions.\n- struct pst_dynamic: the struct layout and member types (psd_proc_cnt) must be known to see whether non\u2011standard type extensions are referenced.\n- psd_proc_cnt: this member is read and cast to int; its exact type/definition is required to assess overflow/implementation-defined behavior.\n- HAVE_VXCPUENABLEDGET: controls whether the VxWorks branch is compiled; required to know if vxCpuEnabledGet usage matters.\n- vxCpuEnabledGet: VxWorks API whose return type and declaration determine whether any compiler-specific attributes or non\u2011standard types are used.\n- cpuset_t: type used for the bitset; its definition (integer width, typedef origin) is needed to check for implementation\u2011defined behavior or extension types.\n- _WIN32 and __CYGWIN__: preprocessor symbols that determine which Windows code is included; must know which branch compiles to examine possible extensions.\n- LoadLibraryA, GetProcAddress, FreeLibrary: Windows API functions used; their prototypes (return types and calling conventions) are necessary to detect use of calling\u2011convention keywords or casts that may be non\u2011portable or extension-based.\n- HMODULE: Windows typedef for the module handle; needed to see if it is an implementation typedef or uses attributes/qualifiers that are extensions.\n- FARPROC: the usual return type of GetProcAddress; relevant because the code casts the result via (void *) to a function-pointer typedef \u2014 this cast pattern can be non\u2011standard (casting between object and function pointers) and must be checked against the actual GetProcAddress signature.\n- WINAPI: macro that typically expands to a calling convention (e.g. __stdcall or __attribute__); this is a common compiler extension\u2014its definition must be checked to determine if an extension is being used.\n- DWORD, WORD: Windows typedefs for integer types; their definitions (signedness/width) and any attached attributes are required to evaluate casts and overflow checks and to detect non\u2011standard definitions.\n- ALL_PROCESSOR_GROUPS: Windows macro/constant passed to GetActiveProcessorCount; knowing its type/value is necessary to determine whether any non\u2011standard constant or sentinel is used.\n- SYSTEM_INFO: Windows struct used to obtain processor count; its definition (member types like dwNumberOfProcessors) must be checked for non\u2011standard annotations or extensions.\n- GetNativeSystemInfo and GetSystemInfo: Windows APIs with potentially different prototypes/calling conventions; must be inspected to detect calling\u2011convention macros or other extensions.\n\nWithout these symbol definitions (and the preprocessor configuration), you cannot reliably determine whether the code relies on compiler-specific calling\u2011convention macros, non\u2011standard pointer casts, or other implementation extensions that would violate the MISRA rule about language extensions."
}