{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When the provided tmp buffer passed into compress_buf is smaller than CHUNK (the function assumes tmp has CHUNK bytes), the memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) can read beyond the bounds of the tmp object. This occurs because 'have' may be up to CHUNK and the function never checks the actual size of the tmp buffer, so memcpy may access beyond tmp's bounds and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const size_t CHUNK_SIZE = 16384u;\nstatic void log_state(const char *stage,\n                      size_t src_size, size_t offset, size_t dest_size,\n                      unsigned int have, int flush,\n                      const void *src, const void *tmp, const void *dest)\n{\n  FILE *f = fopen(\"/tmp/logs/671.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  fprintf(f, \"stage=%s src_size=%zu offset=%zu dest_size=%zu have=%u flush=%d\\n\",\n          stage, src_size, offset, dest_size, have, flush);\n  fprintf(f, \"  src=%p tmp=%p dest=%p\\n\", src, tmp, dest);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    log_state(\"outer_start\", src_size, *offset, *dest_size, 0, 0, src, tmp, *dest);\n    if (src_size > CHUNK_SIZE)\n    {\n      strm->avail_in = (uInt) CHUNK_SIZE;\n      src_size -= CHUNK_SIZE;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = (uInt) CHUNK_SIZE;\n      strm->next_out = (Bytef *) tmp;\n      /* call zlib deflate; unchanged */\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = (unsigned int)(CHUNK_SIZE - strm->avail_out);\n      log_state(\"after_deflate\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        log_state(\"realloc_fail\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      /* Log immediately before the memcpy that can read from \"tmp\" up to 'have' bytes. */\n      log_state(\"before_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n      log_state(\"after_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memcpy(tmp, ..., have) where have is computed as CHUNK - strm->avail_out after calling deflate with avail_out set to CHUNK and next_out set to tmp. Nothing in compress_buf checks or documents the actual size of the object pointed to by tmp, so if the caller supplies a tmp buffer smaller than CHUNK the memcpy can read beyond tmp (and deflate itself may already have written beyond tmp). MISRA C 2023 Rule 21.17 requires that uses of string/memory functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters; this use can do so unless the function guarantees (e.g. by an API contract or an explicit size parameter/check) that tmp is at least CHUNK bytes. Absent such a guarantee or a runtime check, the report of a Rule 21.17 violation is correct. Recommended fixes: add a tmp_size parameter and bound have by tmp_size, allocate tmp inside the function to CHUNK, or document and enforce (assert/check) that tmp is at least CHUNK bytes."
}