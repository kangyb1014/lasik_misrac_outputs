{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "pool->memory",
    "pool->pos",
    "pool->end",
    "pool->size",
    "ROUND_TO_ALIGN(size_t)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t)",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_(const void *p, const uint8_t *base)",
    "mp_ptr_le_(const uint8_t *base, const void *p)",
    "mhd_assert(...)",
    "_MHD_POISON_MEMORY(void *p, size_t n)",
    "_MHD_UNPOISON_MEMORY(void *p, size_t n)",
    "__asan_region_is_poisoned(const void *p, size_t n)  (conditional)"
  ],
  "explanation": "To prove whether the memcpy/memset calls in MHD_pool_reallocate can access out-of-bounds memory you must know how the pool layout, offsets and size calculations are defined and whether the asserted properties are guaranteed at runtime. Each listed symbol is required for that reasoning:\n\n- struct MemoryPool / pool->memory / pool->pos / pool->end / pool->size: the function manipulates and compares these fields (pool->memory + pool->pos, pool->end - pool->pos, pool->size etc.). You must know their types, units (bytes vs. pointers vs. offsets), initial ranges and invariants to determine the actual buffer ranges for new_blc and old.\n\n- ROUND_TO_ALIGN(size_t) and ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t): these macros/functions compute the aligned allocation sizes used to advance pool->pos and to compute new_apos. Their exact semantics (alignment granularity, addition/subtraction of red-zone) determine how many bytes are reserved and therefore the true size available for new_blc and whether overflow/wrap checks are correct.\n\n- _MHD_RED_ZONE_SIZE: this constant is added/subtracted in several checks and in the ROUND_TO_ALIGN_PLUS_RED_ZONE computation. Its value changes the effective safe region and is critical to decide if checks (e.g. (pool->size - _MHD_RED_ZONE_SIZE) >= old_offset + old_size) actually prevent OOB.\n\n- mp_ptr_diff_(const void *p, const uint8_t *base): used to compute old_offset from old and pool->memory. The exact semantics (return type, sign, units) are necessary to know whether old_offset + old_size arithmetic is valid and non-wrapping.\n\n- mp_ptr_le_(const uint8_t *base, const void *p): used to assert old lies at/after pool->memory. You need its definition to confirm that the pointer comparisons in asserts guarantee old is within the pool buffer.\n\n- mhd_assert(...): many safety conditions are expressed only via mhd_assert. You must know whether mhd_assert is compiled to a no-op in production (e.g. NDEBUG) or always enforces checks. If asserts can be disabled, they cannot be relied on to prevent OOB at runtime; if they are guaranteed, they constrain possible inputs.\n\n- _MHD_POISON_MEMORY / _MHD_UNPOISON_MEMORY: these macros wrap sanitizer or bookkeeping calls and could affect assumptions about which bytes are considered valid/accessible (e.g. ASAN poison/unpoison). Knowing their behavior is necessary when code relies on poisoning/unpoisoning to mark memory valid before use (the function calls _MHD_UNPOISON_MEMORY(new_blc, new_size) before memcpy/memset).\n\n- __asan_region_is_poisoned(const void *p, size_t n) (conditional): the code conditionally asserts that the old region is not poisoned. If present in the build, it provides an additional check that old/old_size point to accessible memory; its presence/semantics affect whether memcpy/memset can be assumed safe.\n\nIn short: to decide whether memcpy(new_blc, old, old_size) and the memset calls may access beyond the referenced objects you must know the MemoryPool layout and sizes, the exact alignment/rounding and red-zone arithmetic, the pointer-difference/comparison helpers, and whether the asserted conditions and sanitizer un/poisoning are actually enforced at runtime. Without these symbol definitions you cannot soundly conclude compliance with the MISRA string-handling bounds rule."
}