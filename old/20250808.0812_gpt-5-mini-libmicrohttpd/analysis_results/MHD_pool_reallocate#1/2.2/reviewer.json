{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In a build where debugging/ASAN support is disabled the instrumentation macros used in MHD_pool_reallocate are defined as no-ops (for example _MHD_POISON_MEMORY, _MHD_UNPOISON_MEMORY and mhd_assert are defined as (void)0). Calls to these macros become executed no-op statements whose removal would not change program behaviour. Thus those calls constitute dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const size_t MHD_ALIGNMENT = 8;\nstatic const size_t _MHD_RED_ZONE_SIZE = 16;\nstatic void mhd_assert(int cond)\n{\n  if (!cond) {\n    fprintf(stderr, \"mhd_assert failed\\n\");\n    abort();\n  }\n}\nstatic size_t ROUND_TO_ALIGN(size_t x)\n{\n  const size_t a = MHD_ALIGNMENT;\n  if (a == 0) return x;\n  return ((x + (a - 1)) / a) * a;\n}\nstatic size_t ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t x)\n{\n  return ROUND_TO_ALIGN(x) + _MHD_RED_ZONE_SIZE;\n}\nstatic size_t mp_ptr_diff_(void *ptr, uint8_t *base)\n{\n  return (size_t)((uint8_t *)ptr - base);\n}\nstatic bool mp_ptr_le_(uint8_t *a, void *b)\n{\n  return a <= (uint8_t *)b;\n}\nstatic void _MHD_POISON_MEMORY(void *p, size_t n)\n{\n  (void)p; (void)n;\n}\nstatic void _MHD_UNPOISON_MEMORY(void *p, size_t n)\n{\n  (void)p; (void)n;\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n  FILE *logf = fopen(\"/tmp/logs/10.txt\", \"a\");\n\n  if (logf)\n  {\n    fprintf(logf, \"ENTER MHD_pool_reallocate: pool=%p old=%p old_size=%zu new_size=%zu pos=%zu end=%zu\\n\",\n            (void*)pool, old, old_size, new_size, pool ? pool->pos : 0, pool ? pool->end : 0);\n  }\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    if (logf)\n      fprintf(logf, \"  have old: old_offset=%zu shrinking=%d\\n\", old_offset, (int)shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      if (logf)\n        fprintf(logf, \"  shrinking: zeroing %zu bytes at %p\\n\", (size_t)(old_size - new_size), (void *)((uint8_t*)old + new_size));\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      if (logf)\n        fprintf(logf, \"  called _MHD_POISON_MEMORY (no-op in some builds)\\n\");\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          if (logf)\n            fprintf(logf, \"  grow in-place: insufficient space -> NULL\\n\");\n          if (logf) fclose(logf);\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      if (logf)\n        fprintf(logf, \"  resized in-place: new pos=%zu\\n\", pool->pos);\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      if (logf)\n        fprintf(logf, \"  called _MHD_UNPOISON_MEMORY (no-op in some builds)\\n\");\n      if (logf) fclose(logf);\n      return old;\n    }\n    if (shrinking)\n    {\n      if (logf)\n        fprintf(logf, \"  shrinking but not last block: return old=%p\\n\", old);\n      if (logf) fclose(logf);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    if (logf)\n      fprintf(logf, \"  allocation fail: asize=%zu avail=%zu -> NULL\\n\", asize, pool->end - pool->pos);\n    if (logf) fclose(logf);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  if (logf)\n    fprintf(logf, \"  allocated new block at %p asize=%zu new pos=%zu\\n\", (void*)new_blc, asize, pool->pos);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (logf)\n    fprintf(logf, \"  called _MHD_UNPOISON_MEMORY for new block (no-op in some builds)\\n\");\n\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    if (logf)\n      fprintf(logf, \"  moved %zu bytes from %p to %p and zeroed old block\\n\", old_size, old, (void*)new_blc);\n    _MHD_POISON_MEMORY (old, old_size);\n    if (logf)\n      fprintf(logf, \"  called _MHD_POISON_MEMORY for old block (no-op in some builds)\\n\");\n  }\n  if (logf) fclose(logf);\n  return new_blc;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA Rule 2.2 forbids operations that are executed but whose removal would not affect program behaviour (i.e. true dead code). The calls in MHD_pool_reallocate (mhd_assert, _MHD_POISON_MEMORY, _MHD_UNPOISON_MEMORY) are instrumentation hooks that in some configurations expand to active code (ASAN/diagnostic builds) and in others expand to no-ops. Removing those calls from the source would change behaviour in the builds where they are active, so they are not dead code in the context of the project as a whole. Determination of dead code must consider the intended build configurations; a macro that conditionally expands to a no-op does not by itself make the call dead code. (The supplied test modifications and compile failure do not change this conclusion.)"
}