{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "mhd_assert",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "memcpy",
    "memset",
    "__asan_region_is_poisoned",
    "MHD_ASAN_POISON_ACTIVE",
    "HAVE___ASAN_REGION_IS_POISONED"
  ],
  "explanation": "You must know the definitions/semantics of these symbols to decide whether any operations in MHD_pool_reallocate are truly dead (i.e. removing them would not affect observable program behaviour):\n\n- struct MemoryPool\n  - The layout and exact semantics of fields (memory, pos, end, size) determine whether updates to pos, reads from memory, and pointer/offset comparisons have observable effects. Whether old/new pointers alias memory and whether pool->pos/end are offsets or pointers is essential to decide if branches and writes are meaningful.\n\n- ROUND_TO_ALIGN\n  - Used to compute alignment of pos and offsets. Its definition can change branch outcomes (e.g. whether pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE(...)) and thus whether zeroing/poisoning/moving code is executed or could be removed.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE\n  - Same reason as ROUND_TO_ALIGN; participates in critical control-flow and size arithmetic that determines in-place resize vs new allocation.\n\n- _MHD_RED_ZONE_SIZE\n  - Alters size arithmetic and bounds checks. Removing code that depends on this value might change behaviour if it affects branch decisions or pool->pos updates.\n\n- mp_ptr_diff_\n  - Computes old_offset used in almost every branch/compare; its semantics (units, wrap behavior) directly affect reachability of branches and correctness of subsequent writes\u2014so needed to judge whether related code is dead.\n\n- mp_ptr_le_\n  - Pointer-order predicate used in assertions; if it has side effects or different semantics, assertions may or may not be redundant.\n\n- mhd_assert\n  - Assertions may be compiled out or perform runtime checks with side-effects (log/abort). To decide whether assert calls in this function are dead code you must know if mhd_assert is a no-op in the build under analysis.\n\n- _MHD_POISON_MEMORY and _MHD_UNPOISON_MEMORY\n  - These are invoked to mark memory poisoned/unpoisoned. They may be no-ops in production builds or may write sentinel bytes / call ASAN hooks. Determining whether those calls are removable (dead) requires their definitions.\n\n- memcpy\n  - Standard memory move: removing it would obviously change behaviour if the copied data is later used. You need to confirm whether copied data is actually observed outside the function (depends on MemoryPool semantics and callers).\n\n- memset\n  - Used to zero freed parts and to clear the old block. Whether those zeroings are observable (thus not dead) depends on program accesses and poisoning behavior; include standard semantics.\n\n- __asan_region_is_poisoned\n  - Guarded by compile-time flags; its presence/semantics determine whether the ASAN-related assertion is effective or absent in a given build.\n\n- MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED\n  - Compile-time macros that enable/disable ASAN checks in the function; necessary to know which statements are actually part of the compiled program and therefore whether they are dead.\n\nIn short, these symbols control the function's control flow, in-place vs allocate-new decisions, memory writes (memcpy/memset/poison/unpoison), and whether assertions exist at runtime. Without their definitions/compile-time configuration you cannot reliably decide if any operation in MHD_pool_reallocate is dead code under the MISRA rule."
}