{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (definition; in particular the type/qualifier of its member `memory`)",
    "_MHD_POISON_MEMORY (macro/function prototype)",
    "_MHD_UNPOISON_MEMORY (macro/function prototype)",
    "memcpy (prototype)",
    "memset (prototype)",
    "mp_ptr_diff_ (prototype)",
    "mp_ptr_le_ (prototype)",
    "ROUND_TO_ALIGN (macro)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE (macro)",
    "_MHD_RED_ZONE_SIZE (macro)",
    "__asan_region_is_poisoned (prototype, conditional)"
  ],
  "explanation": "Explain why each symbol is required for checking the MISRA const-pointer rule:\n\n- struct MemoryPool (definition; in particular the type/qualifier of its member `memory`): The function reads/writes via pool->memory (new_blc = pool->memory + pool->pos) and returns pointers into that buffer. If pool->memory is declared with a const-qualified pointer type (e.g. const uint8_t *), that would conflict with writing to the buffer (memcpy into new_blc, _MHD_UNPOISON_MEMORY). Determining whether pool->memory is const or non-const is essential.\n\n- _MHD_POISON_MEMORY (macro/function prototype): The function calls _MHD_POISON_MEMORY(old, size) which is intended to modify or mark memory. Its parameter type (void * vs const void *) is needed to check whether the implementation expects non-const pointers and therefore whether passing potentially const-qualified pointers would violate the rule.\n\n- _MHD_UNPOISON_MEMORY (macro/function prototype): Similar to _MHD_POISON_MEMORY, this is called on both old and new_blc. Its parameter types show whether these pointers must be non-const (since the function calls it to affect the memory), which bears on whether those pointees should have been declared non-const.\n\n- memcpy (prototype): memcpy writes into its first argument (dest) and accepts a const void * for the source. The function calls memcpy(new_blc, old, old_size). Verifying memcpy's signature confirms new_blc must be non-const (dest) and that old may be const as a source \u2014 but because old is also written elsewhere in this function, old must not be declared const.\n\n- memset (prototype): memset is used to zero-out old and parts of old (memset(old,...)). Its prototype shows the destination argument must be a non-const pointer; therefore any declaration that made `old` or pool->memory point to const would be inconsistent with these uses.\n\n- mp_ptr_diff_ (prototype): Called as mp_ptr_diff_(old, pool->memory). Its parameter types may impose constness (e.g. const void *), and implicit casts may occur. Knowing its signature helps ensure pointer-to-const vs non-const conversions are not masking an actual const-qualification mismatch.\n\n- mp_ptr_le_ (prototype): Called as mp_ptr_le_(pool->memory, old). As above, its parameter types matter for diagnosing any const-qualification issues introduced by type-compatible but differently qualified pointer parameters.\n\n- ROUND_TO_ALIGN (macro) and ROUND_TO_ALIGN_PLUS_RED_ZONE (macro): These macros operate on offsets/positions but may include casts in their definitions that affect how pointer offsets are computed or expressed. If they perform casts between pointer types and integer types or introduce const casts, that could be relevant to detecting implicit qualification casts; include them to confirm no hidden const casts are used.\n\n- _MHD_RED_ZONE_SIZE (macro): Used in arithmetic with pool->size/end/pos and offsets; included to be able to inspect any macros that might rely on const-qualified expressions or casts when used with pool->memory offsets.\n\n- __asan_region_is_poisoned (prototype, conditional): Used under ASAN-related asserts with the old pointer. Its prototype may take a const void *; knowing its signature helps confirm whether passing old (non-const) to it would require a qualification cast or hide a const-qualification mismatch.\n\nIn short: the critical symbol is the MemoryPool definition (especially the type/qualifier of memory). The other listed symbols are the memory-manipulation and pointer-helper prototypes/macros used by the function; their parameter types and any internal casts determine whether the code performs or masks const-to-non-const conversions or writes through pointers that were declared const, which is exactly what the MISRA rule forbids."
}