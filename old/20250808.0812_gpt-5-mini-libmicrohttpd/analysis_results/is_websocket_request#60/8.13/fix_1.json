{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_Connection { int dummy; };\nstatic const char WS_UPGRADE_VALUE[] = \"websocket\";\nstatic void log_violation(const struct MHD_Connection *con, const char *upg_header,\n                          const char *con_header, int decision)\n{\n    FILE *fp = fopen(\"/tmp/logs/483.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"is_websocket_request invoked\\n\");\n        fprintf(fp, \"  con pointer: %p\\n\", (void *)con);\n        fprintf(fp, \"  upg_header: %s\\n\", (upg_header != NULL) ? upg_header : \"(null)\");\n        fprintf(fp, \"  con_header: %s\\n\", (con_header != NULL) ? con_header : \"(null)\");\n        fprintf(fp, \"  decision: %s\\n\", (decision == (int)MHD_YES) ? \"MHD_YES\" : \"MHD_NO\");\n        fprintf(fp, \"---\\n\");\n        (void) fclose(fp);\n    }\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  /* The original code used (void) con to silence unused warnings. Here we\n     actually log the pointer value for diagnostics, so we do not cast it away. */\n\n  int decision = ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? (int) MHD_YES\n         : (int) MHD_NO;\n\n  /* Log control path and state information to help demonstrate the violation\n     scenario (that 'con' is not const-qualified though it is not modified). */\n  log_violation(con, upg_header, con_header, decision);\n\n  return (enum MHD_Result)decision;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nwebsocket_threaded_example.c:104:26: error: expected identifier or '(' before string constant\n  104 | #define WS_UPGRADE_VALUE \"websocket\"\n      |                          ^~~~~~~~~~~\nwebsocket_threaded_example.c:429:19: note: in expansion of macro 'WS_UPGRADE_VALUE'\n  429 | static const char WS_UPGRADE_VALUE[] = \"websocket\";\n      |                   ^~~~~~~~~~~~~~~~\nmake[4]: *** [Makefile:1208: websocket_threaded_example-websocket_threaded_example.o] Error 1\nmake[3]: *** [Makefile:1234: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of is_websocket_request as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n\nstruct MHD_Connection { int dummy; };\n\n/* Use a different identifier to avoid colliding with any existing macro named\n   WS_UPGRADE_VALUE in the build environment. */\nstatic const char WS_UPGRADE_STR[] = \"websocket\";\n\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0 };\n\nstatic void log_violation(const struct MHD_Connection *con, const char *upg_header,\n                          const char *con_header, int decision)\n{\n    FILE *fp = fopen(\"/tmp/logs/483.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"is_websocket_request invoked\\n\");\n        fprintf(fp, \"  con pointer: %p\\n\", (void *)con);\n        fprintf(fp, \"  upg_header: %s\\n\", (upg_header != NULL) ? upg_header : \"(null)\");\n        fprintf(fp, \"  con_header: %s\\n\", (con_header != NULL) ? con_header : \"(null)\");\n        fprintf(fp, \"  decision: %s\\n\", (decision == (int)MHD_YES) ? \"MHD_YES\" : \"MHD_NO\");\n        fprintf(fp, \"---\\n\");\n        (void) fclose(fp);\n    }\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  /* The original code used (void) con to silence unused warnings. Here we\n     actually log the pointer value for diagnostics, so we do not cast it away. */\n\n  int decision = ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_STR))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? (int) MHD_YES\n         : (int) MHD_NO;\n\n  /* Log control path and state information to help demonstrate the violation\n     scenario (that 'con' is not const-qualified though it is not modified). */\n  log_violation(con, upg_header, con_header, decision);\n\n  return (enum MHD_Result)decision;\n}\n",
  "explanation": "The build error was caused by a name collision with a macro named WS_UPGRADE_VALUE. I avoided that by renaming the string variable to WS_UPGRADE_STR. I also added the necessary includes (<stdio.h>, <string.h>) and provided a minimal enum MHD_Result with MHD_YES and MHD_NO so the file is self-contained and compiles. The original logic of is_websocket_request is preserved."
}