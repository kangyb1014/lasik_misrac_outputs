{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop count and optionally loop flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with essentially Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The overall code violates MISRA C 2023 Rule 14.2 due to a for loop in mhd_tool_get_proc_cpu_count_w32_. The loop\n  for (count_by_proc_aff_mask = 0; 0 != proc_aff; proc_aff &= proc_aff - 1)\nmodifies proc_aff in the third clause while the second clause uses proc_aff. Clause 2 of Rule 14.2 requires the loop condition to not depend on objects that are modified in the loop body/third clause (other than the loop counter), and clause 3 requires the third clause to modify only the loop counter. Here the third clause modifies proc_aff (not the declared loop counter), and the condition depends on that object, so the for statement is not well-formed.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n  FILE *logf;\n\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"enter mhd_tool_get_proc_cpu_count\\n\");\n    fclose(logf);\n  }\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_sched_getaffinity_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_sched_getaffinity_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"mhd_tool_get_proc_cpu_count_w32_ returned %d\\n\", res);\n    fclose(logf);\n  }\n  if (0 < res)\n    return res;\n\n  logf = fopen(\"/tmp/logs/244.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf(logf, \"no method succeeded, returning -1\\n\");\n    fclose(logf);\n  }\n\n  return -1;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The described for statement (for (count_by_proc_aff_mask = 0; 0 != proc_aff; proc_aff &= proc_aff - 1)) uses count_by_proc_aff_mask as the loop counter (initialized in the first clause) but the loop condition (second clause) depends on proc_aff and the third clause modifies proc_aff. MISRA C 2023 R14.2 requires that the third clause may modify only the loop counter (and the second clause may only use the loop counter and optionally a loop flag). Here proc_aff is neither the declared loop counter nor an allowed loop counter modification in the third clause, so the for statement is not well-formed under R14.2. A compliant fix is to make proc_aff the loop counter or to introduce a separate temporary loop-flag variable (e.g. temp = proc_aff; for (count_by_proc_aff_mask = 0, temp != 0; temp &= temp - 1) ... ), or convert the construct to an equivalent while loop that makes the loop control explicit."
}