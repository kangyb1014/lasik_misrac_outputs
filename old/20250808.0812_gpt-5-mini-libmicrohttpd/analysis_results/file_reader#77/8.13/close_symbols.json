{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "struct MHD_Response::fd",
    "struct MHD_Response::fd_off",
    "pread64 (prototype)",
    "pread (prototype)",
    "read (prototype)",
    "lseek64 (prototype)",
    "lseek (prototype)",
    "ReadFile (prototype)",
    "INVALID_HANDLE_VALUE",
    "_get_osfhandle (prototype)",
    "HANDLE",
    "OVERLAPPED",
    "ULARGE_INTEGER"
  ],
  "explanation": "To decide whether pointers in file_reader should be const-qualified or must remain non-const, the analyzer needs the following symbols and why:\n\n- struct MHD_Response: The function casts cls to this type and accesses members. The full definition is required to know the types and qualifiers of members and whether the function ever modifies the object via those members (so cls can be const-qualified if only read).\n- struct MHD_Response::fd: The fd member is passed to file I/O calls. Knowing its declared type (e.g. int) confirms how it is used and that file_reader does not modify the response object via this member.\n- struct MHD_Response::fd_off: The offset member is read to compute position; knowing its type and qualifiers verifies that file_reader only reads it and therefore cls could be a pointer to const.\n- pread64 (prototype), pread (prototype), read (prototype): These POSIX APIs are used to fill buf. Their function signatures (they take void *buf / non-const buffer pointers and return ssize_t) are needed to prove these calls write into buf, which means buf must NOT be a pointer to const.\n- lseek64 (prototype), lseek (prototype): These prototypes show they operate on file descriptor/offsets and do not write to response or buf; they help confirm that no called function modifies the response object or the buffer indirectly.\n- ReadFile (prototype): Windows API used when building on Windows. Its prototype shows it writes into the buffer (LPVOID) and therefore buf must be non-const on Windows builds as well.\n- INVALID_HANDLE_VALUE: Used to test the handle validity; knowing this constant/its usage is necessary to ensure no write-through of response occurs when validating handles.\n- _get_osfhandle (prototype): This is used to turn response->fd into an OS handle. Its prototype shows it takes an integer descriptor and does not modify the response object; needed to justify const qualification of cls if only read.\n- HANDLE, OVERLAPPED, ULARGE_INTEGER: Types used in the Windows branch (ReadFile + offsets). Their prototypes/definitions help confirm that only the user-supplied buf is written by ReadFile and that no field of the response object is modified by Windows-API calls invoked here.\n\nWith these symbols (structure definition plus the prototypes/types of I/O functions used), an analyzer can determine (a) whether cls is only read and therefore could be a pointer-to-const and (b) whether buf is written by called functions and therefore must remain a non-const pointer, as required by the MISRA rule under analysis."
}