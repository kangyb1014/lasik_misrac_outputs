{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "toxdigitvalue",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "mhd_assert",
    "SSIZE_MAX",
    "ssize_t"
  ],
  "explanation": "For checking MISRA rule \u201cLanguage extensions should not be used\u201d you must inspect any called functions/macros and relevant typedefs/constants that could hide compiler-specific extensions. Why each is required:\n\n- MHD_str_pct_decode_strict_n_: This is the direct callee that does percent-decoding. Its implementation may use compiler builtins, __attribute__ markers, statement-expressions, typeof, inline asm, or other compiler-specific extensions; inspect it to be sure none are used.\n\n- toxdigitvalue: It is a callee of MHD_str_pct_decode_strict_n_. The decoding helper often uses lookup tables or unusual initializers; examine it for designated initializers, GCC extensions, or builtin intrinsics.\n\n- MHD_str_equal_caseless_bin_n_: Used to check prefix equality. Macros or inline implementations may employ compiler extensions (attributes, inline asm, statement expressions, typeof, builtins); its definition must be checked.\n\n- MHD_STATICSTR_LEN_: Macro used to get the static prefix length. Macro definition may rely on nonportable/extension constructs (e.g. typeof, compound literals, statement expressions). Verify it expands to standard C only.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: The prefix token (likely a macro/string literal). Its definition may include implementation tricks or extension usage (compound literal, nonstandard prefixing); check it.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: Constant/minimum length macro. It could be computed using nonstandard constructs or sizeof on flexible/extension types; inspect it.\n\n- mhd_assert: Assertion macro used in the function. Assertion macros commonly expand to compiler-specific constructs (__builtin_unreachable, __attribute__((noreturn)), inline assembly, or other extensions). Verify it does not use extensions.\n\n- SSIZE_MAX: The limit macro tested against uname_ext_len. Though from standard headers, its definition or use may rely on nonstandard typedefs/macros on some platforms; check how it is provided on the target build to ensure no compiler-specific trickery.\n\n- ssize_t: The function return type. ssize_t is POSIX (not standard C); examine how it is provided (typedefs/headers) for platform-provided aliases or extension macros that could be considered language/implementation extensions.\n\nInspecting the above symbols (implementations/definitions) is sufficient to determine whether the target function itself or the immediate helpers it depends on employ compiler-specific language extensions that would violate the cited MISRA requirement."
}