{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN"
  ],
  "explanation": "- MHD_str_pct_decode_strict_n_: The target calls this to decode percent-encoding into buf and passes uname_ext + r as the input. To decide const-correctness we must inspect its prototype/implementation to see whether it accepts its input pointer as const (i.e. const char *in) or as char * and whether it modifies the input buffer. Also its prototype shows whether the destination buf is non-const (it is written to). This is the primary symbol that determines if uname_ext should/should not be const and if buf must be non-const.\n\n- MHD_str_equal_caseless_bin_n_: The function is invoked with uname_ext and a static prefix. We need its prototype to confirm that it takes its string arguments as const char * (i.e. does not modify the buffers). That ensures uname_ext can be const-qualified safely for this use.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: This macro/constant supplies the prefix string passed to the equality check. Its type (string literal/const char[]) confirms that the prefix is const and is relevant for checking whether the equality call expects const parameters.\n\n- MHD_STATICSTR_LEN_: This macro computes lengths of static strings used as size arguments to the equality call. Knowing its expansion/type (size_t) is useful to verify no implicit cast removes constness and to ensure length arguments are consistent with const-qualified string usage.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: The function uses this constant in a length check against uname_ext_len. Although not about pointer mutation directly, including it ensures there is no hidden macro that changes the expected type/semantics of uname_ext (for example if the macro expands to an expression that depends on mutability). It helps complete the context for deciding whether uname_ext can be const and whether any macros implicitly write into buffers.\n\n(Other macros/constants in the function such as SSIZE_MAX or mhd_assert do not affect whether the pointers should be const-qualified for the MISRA rule, so they are not required for this specific const-qualification analysis.)"
}