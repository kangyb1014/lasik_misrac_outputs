{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_PostProcessor;\nstruct MHD_Connection;\nenum MHD_ValueKind { MHD_KIND_PLACEHOLDER };\nstatic void probe_log_state(const char *event,\n                            const struct UploadContext *uc,\n                            const char *key,\n                            const char *filename,\n                            const char *data,\n                            size_t size)\n{\n  FILE *f = fopen(\"/tmp/logs/418.txt\", \"a\");\n  if (f == NULL)\n  {\n    /* If logging fails we silently continue to avoid affecting behaviour. */\n    return;\n  }\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \" key=%s filename=%s size=%zu\\n\",\n          (key != NULL) ? key : \"(null)\",\n          (filename != NULL) ? filename : \"(null)\",\n          size);\n  if (uc != NULL)\n  {\n    fprintf(f, \" uc->fd=%d uc->filename=%s uc->category=%s uc->language=%s\\n\",\n            uc->fd,\n            (uc->filename != NULL) ? uc->filename : \"(null)\",\n            (uc->category != NULL) ? uc->category : \"(null)\",\n            (uc->language != NULL) ? uc->language : \"(null)\");\n  }\n  if (data != NULL)\n  {\n    /* Print a small prefix of data to avoid huge logs. */\n    size_t n = (size > 32U) ? 32U : size;\n    fprintf(f, \" data_prefix=\");\n    fwrite(data, 1, n, f);\n    if (n < size)\n      fprintf(f, \"...\");\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = (struct UploadContext *) cls;\n  size_t i;\n  int res;\n  /* Unused parameters are explicitly cast to void in the original code.\n     These operations are executed but have no effect; removing them would\n     not affect behaviour. They therefore constitute dead code under\n     MISRA C 2023 Rule 2.2. We keep them here to illustrate the\n     violation and immediately log the state for diagnostics. */\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  /* Log entry showing that the function was entered and the unused\n     parameter casts above were executed (they are no-ops). */\n  probe_log_state(\"enter\", uc, key, filename, data, size);\n\n  if (0 == strcmp (key, \"category\"))\n  {\n    probe_log_state(\"append_category\", uc, key, filename, data, size);\n    return do_append (&uc->category, data, size);\n  }\n  if (0 == strcmp (key, \"language\"))\n  {\n    probe_log_state(\"append_language\", uc, key, filename, data, size);\n    return do_append (&uc->language, data, size);\n  }\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    probe_log_state(\"ignore_unexpected\", uc, key, filename, data, size);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    probe_log_state(\"no_filename\", uc, key, filename, data, size);\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    probe_log_state(\"missing_form_data\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"bad_filename_chars\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"path_too_long\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      probe_log_state(\"open_failed\", uc, key, fn, data, size);\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n    probe_log_state(\"file_created\", uc, key, uc->filename, data, size);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    probe_log_state(\"write_failed\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  probe_log_state(\"ok_continue\", uc, key, filename, data, size);\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndemo.c:551:6: error: redeclaration of 'enum MHD_ValueKind'\n  551 | enum MHD_ValueKind { MHD_KIND_PLACEHOLDER };\n      |      ^~~~~~~~~~~~~\nIn file included from demo.c:51:\n../../src/include/microhttpd.h:2244:6: note: originally defined here\n 2244 | enum MHD_ValueKind\n      |      ^~~~~~~~~~~~~\nmake[4]: *** [Makefile:1138: demo-demo.o] Error 1\nmake[3]: *** [Makefile:1234: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_upload_data as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "struct MHD_PostProcessor;\nstruct MHD_Connection;\nstatic void probe_log_state(const char *event,\n                            const struct UploadContext *uc,\n                            const char *key,\n                            const char *filename,\n                            const char *data,\n                            size_t size)\n{\n  FILE *f = fopen(\"/tmp/logs/418.txt\", \"a\");\n  if (f == NULL)\n  {\n    /* If logging fails we silently continue to avoid affecting behaviour. */\n    return;\n  }\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \" key=%s filename=%s size=%zu\\n\",\n          (key != NULL) ? key : \"(null)\",\n          (filename != NULL) ? filename : \"(null)\",\n          size);\n  if (uc != NULL)\n  {\n    fprintf(f, \" uc->fd=%d uc->filename=%s uc->category=%s uc->language=%s\\n\",\n            uc->fd,\n            (uc->filename != NULL) ? uc->filename : \"(null)\",\n            (uc->category != NULL) ? uc->category : \"(null)\",\n            (uc->language != NULL) ? uc->language : \"(null)\");\n  }\n  if (data != NULL)\n  {\n    /* Print a small prefix of data to avoid huge logs. */\n    size_t n = (size > 32U) ? 32U : size;\n    fprintf(f, \" data_prefix=\");\n    fwrite(data, 1, n, f);\n    if (n < size)\n      fprintf(f, \"...\");\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = (struct UploadContext *) cls;\n  size_t i;\n  int res;\n  /* Unused parameters are explicitly cast to void in the original code.\n     These operations are executed but have no effect; removing them would\n     not affect behaviour. They therefore constitute dead code under\n     MISRA C 2023 Rule 2.2. We keep them here to illustrate the\n     violation and immediately log the state for diagnostics. */\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  /* Log entry showing that the function was entered and the unused\n     parameter casts above were executed (they are no-ops). */\n  probe_log_state(\"enter\", uc, key, filename, data, size);\n\n  if (0 == strcmp (key, \"category\"))\n  {\n    probe_log_state(\"append_category\", uc, key, filename, data, size);\n    return do_append (&uc->category, data, size);\n  }\n  if (0 == strcmp (key, \"language\"))\n  {\n    probe_log_state(\"append_language\", uc, key, filename, data, size);\n    return do_append (&uc->language, data, size);\n  }\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    probe_log_state(\"ignore_unexpected\", uc, key, filename, data, size);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    probe_log_state(\"no_filename\", uc, key, filename, data, size);\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    probe_log_state(\"missing_form_data\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"bad_filename_chars\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"path_too_long\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      probe_log_state(\"open_failed\", uc, key, fn, data, size);\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n    probe_log_state(\"file_created\", uc, key, uc->filename, data, size);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    probe_log_state(\"write_failed\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  probe_log_state(\"ok_continue\", uc, key, filename, data, size);\n  return MHD_YES;\n}\n",
  "explanation": "I removed the local redeclaration of enum MHD_ValueKind that conflicted with the definition in the included microhttpd.h. The duplicate enum caused a redeclaration error; removing it lets the code use the enum definition from the library header. No other logic was changed."
}