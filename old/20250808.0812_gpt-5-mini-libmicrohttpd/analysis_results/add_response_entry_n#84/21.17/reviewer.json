{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling add_response_entry_n with header == NULL and header_len > 0 (or content == NULL and content_len > 0) leads to memchr being invoked with a NULL pointer and a non-zero length. That causes access beyond the bounds of the referenced object (NULL), violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind;\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  FILE *log = NULL;\n  /* Attempt to ensure log directory exists (best-effort). */\n  (void) mkdir(\"/tmp/logs\", 0777);\n  log = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"add_response_entry_n ENTRY: response=%p, kind=%d, header=%p, header_len=%zu, content=%p, content_len=%zu\\n\",\n            (void *)response, (int)kind, (void *)header, header_len, (void *)content, content_len);\n    fflush(log);\n  }\n\n  if (NULL == response)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: response == NULL\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (0 == header_len)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: header_len == 0\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (0 == content_len)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: content_len == 0\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  /* Record that we are about to call memchr on header. This is the\n     point where, if header == NULL while header_len > 0, memchr will\n     dereference the pointer and may access beyond the bounds -> violation. */\n  if (NULL != log)\n  {\n    fprintf(log, \"about to memchr on header: header=%p, header_len=%zu\\n\", (void *)header, header_len);\n    fflush(log);\n  }\n  if (NULL != memchr (header, '\\t', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\t'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, ' ', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains ' ' (space)\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, '\\r', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\r'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, '\\n', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\n'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  /* Record that we are about to call memchr on content. If content == NULL\n     while content_len > 0, memchr will dereference it and can access beyond\n     the bounds -> violation. */\n  if (NULL != log)\n  {\n    fprintf(log, \"about to memchr on content: content=%p, content_len=%zu\\n\", (void *)content, content_len);\n    fflush(log);\n  }\n  if (NULL != memchr (content, '\\r', content_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: content contains '\\\\r'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (content, '\\n', content_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: content contains '\\\\n'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (NULL != log)\n  {\n    fprintf(log, \"calling MHD_add_response_entry_no_check_ with header=%p (len=%zu) content=%p (len=%zu)\\n\",\n            (void *)header, header_len, (void *)content, content_len);\n    fclose(log);\n  }\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls memchr(header, ..., header_len) and memchr(content, ..., content_len) without ensuring header and content are non-NULL when the corresponding lengths are non-zero. If a caller passes header == NULL with header_len > 0 (or content == NULL with content_len > 0), memchr will be invoked with a NULL pointer and a non-zero size, which is undefined behavior (access beyond the bounds of the referenced object) and thus violates MISRA C 2023 Rule 21.17. To comply, the code must ensure that whenever a non-zero length is passed the pointer is valid (e.g. add checks header != NULL and content != NULL when header_len/content_len > 0), or establish and enforce a documented precondition that callers never pass NULL with non-zero length and provide the necessary static/proof evidence of that precondition."
}