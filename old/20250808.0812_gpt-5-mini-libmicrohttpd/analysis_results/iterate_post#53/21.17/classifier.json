{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified iterate_post code that contains useful probe functions that print useful logs to a file \"/tmp/logs/431.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of iterate_post as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of iterate_post:\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function iterate_post:\n#define MAXANSWERSIZE 512\n...\n#define MAXNAMESIZE 20\n...\n#define GREETINGPAGE \"<html><body><h1>Welcome, %s!</center></h1></body></html>\"\n</additional code>\nJudge whether the above iterate_post code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Violation occurs when the POST field named \"name\" has 'data' of length 'size' that is not null-terminated. The code checks only that size > 0 and size <= MAXNAMESIZE, then passes 'data' (which may not be '\\0'-terminated) to snprintf with a \"%s\" format specifier. snprintf will read beyond the provided object bounds searching for a terminator, resulting in an out-of-bounds access.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Minimal types to allow compilation of the probe code. */\ntypedef enum MHD_Result { MHD_NO = 0, MHD_YES = 1 } MHD_Result;\nenum MHD_ValueKind { MHD_VAL_KIND = 0 };\n\nstruct connection_info_struct\n{\n  char *answerstring;\n};\n\n/* Preserve original symbolic values as constants (no macros introduced). */\nstatic const size_t MAXANSWERSIZE = 512;\nstatic const size_t MAXNAMESIZE = 20;\nstatic const char GREETINGPAGE[] = \"<html><body><h1>Welcome, %s!</center></h1></body></html>\";\n\n/* Probe logger: append logging information to the required file. */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if (f == NULL)\n  {\n    return; /* Do not abort the original function behavior. */\n  }\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputs(\"\\n\", f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  /* Log entry and pointers/sizes for diagnostics. */\n  probe_log(\"iterate_post: entry key=%p size=%zu data=%p con_info=%p\", (const void *)key, size, (const void *)data, (const void *)con_info);\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    probe_log(\"iterate_post: matched key 'name'\");\n\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      /* Before calling snprintf, probe whether 'data' contains a '\\0' within the provided size. */\n      void *term = memchr(data, '\\0', size);\n      if (term != NULL)\n      {\n        size_t pos = (size_t)((const char *)term - data);\n        probe_log(\"iterate_post: data appears NUL-terminated within size at offset %zu\", pos);\n      }\n      else\n      {\n        probe_log(\"iterate_post: data NOT NUL-terminated within provided size (%zu). Using %%s in snprintf will read beyond bounds.\", size);\n      }\n\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n      {\n        probe_log(\"iterate_post: malloc failed for answerstring (size %zu)\", MAXANSWERSIZE);\n        return MHD_NO;\n      }\n\n      probe_log(\"iterate_post: about to call snprintf(answerstring=%p, MAXANSWERSIZE=%zu, GREETINGPAGE, data=%p)\", (void *)answerstring, MAXANSWERSIZE, (const void *)data);\n      /* Original behavior retained: this snprintf may read beyond 'data' if 'data' is not NUL-terminated. */\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n\n      probe_log(\"iterate_post: snprintf completed; answerstring=%p contents_start='%.64s'\", (void *)answerstring, answerstring);\n      con_info->answerstring = answerstring;\n    }\n    else\n    {\n      probe_log(\"iterate_post: size check failed (size=%zu), setting con_info->answerstring = NULL\", size);\n      con_info->answerstring = NULL;\n    }\n\n    probe_log(\"iterate_post: returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  probe_log(\"iterate_post: key not matched, returning MHD_YES\");\n  return MHD_YES;\n}\n"
}