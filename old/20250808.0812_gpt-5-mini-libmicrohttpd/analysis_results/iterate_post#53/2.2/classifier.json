{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified iterate_post code that contains useful probe functions that print useful logs to a file \"/tmp/logs/426.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of iterate_post as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of iterate_post:\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\nJudge whether the above iterate_post code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The (void) cast statements for unused parameters (e.g. (void) kind; (void) filename; etc.) are executed operations that have no effect on program behaviour; their removal would not change program behaviour, therefore they constitute dead code under MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n\n/* Minimal definitions so this translation unit is self-contained for testing. */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\nenum MHD_ValueKind { MHD_VAL_KIND = 0 };\n\nstatic const size_t MAXNAMESIZE = 64U;\nstatic const size_t MAXANSWERSIZE = 256U;\nstatic const char GREETINGPAGE[] = \"Hello %s\";\n\nstruct connection_info_struct\n{\n  char *answerstring;\n};\n\n/* Probe helper that logs control path and state. */\nstatic void\nprobe_log (const char *stage, const char *key, const char *data, size_t size, uint64_t off, const char *note)\n{\n  FILE *f = fopen (\"/tmp/logs/426.txt\", \"a\");\n  if (f)\n  {\n    /* Print a compact record describing the point and relevant state. */\n    fprintf (f, \"stage=%s key=%s size=%zu off=%\" PRIu64 \" note=%s\\n\",\n             stage, (key != NULL) ? key : \"(null)\", size, off, (note != NULL) ? note : \"\");\n\n    /* If small data, log it safely (may not be null terminated). */\n    if ((data != NULL) && (size > 0) && (size <= 64U))\n    {\n      char buf[65];\n      size_t copy = (size < 64U) ? size : 64U;\n      memcpy (buf, data, copy);\n      buf[copy] = '\\0';\n      fprintf (f, \"  data_preview='%s'\\n\", buf);\n    }\n\n    fclose (f);\n  }\n}\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n\n  /* The following (void) casts are the subject of the violation scenario:\n     they are executed operations with no effect (dead code per Rule 2.2). */\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  /* Log entry and the fact that the (void) statements executed. */\n  probe_log (\"enter\", key, data, size, off, \"(void) casts executed\");\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    probe_log (\"branch\", key, data, size, off, \"matched 'name'\");\n\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n      {\n        probe_log (\"alloc_fail\", key, data, size, off, \"malloc returned NULL\");\n        return MHD_NO;\n      }\n\n      /* Preserve original behaviour: format greeting into the allocated buffer. */\n      (void) snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n\n      probe_log (\"alloc_ok\", key, data, size, off, \"allocated and formatted answerstring\");\n    }\n    else\n    {\n      con_info->answerstring = NULL;\n      probe_log (\"size_invalid\", key, data, size, off, \"size out of range -> answerstring=NULL\");\n    }\n\n    return MHD_NO;\n  }\n\n  probe_log (\"exit\", key, data, size, off, \"no matching key -> continue\");\n  return MHD_YES;\n}\n"
}