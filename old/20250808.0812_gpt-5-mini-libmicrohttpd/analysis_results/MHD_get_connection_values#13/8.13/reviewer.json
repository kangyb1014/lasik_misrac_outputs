{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function takes non-const pointers even though it only reads from the connection and its headers. In particular, the parameter 'struct MHD_Connection *connection' and the local iterator 'struct MHD_HTTP_Req_Header *pos' are non-const although the function does not modify the pointed-to objects. Per MISRA C 2023 Rule 8.13 these should be const-qualified (for example, 'const struct MHD_Connection *connection' and 'const struct MHD_HTTP_Req_Header *pos').\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind {\n  MHD_VALUE_KIND_NONE = 0,\n  MHD_VALUE_KIND_A = 1,\n  MHD_VALUE_KIND_B = 2\n};\ntypedef int (*MHD_KeyValueIterator)(void *cls,\n                                    enum MHD_ValueKind kind,\n                                    const char *key,\n                                    const char *value);\nconst int MHD_NO = 0;\n\nint\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n  FILE *log = fopen(\"/tmp/logs/107.txt\", \"w\");\n\n  if (NULL == connection)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"MHD_get_connection_values: connection == NULL -> return -1\\n\");\n      fclose(log);\n    }\n    return -1;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"MHD_get_connection_values: entering, kind=%d\\n\", (int) kind);\n  }\n\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if (log != NULL)\n      {\n        fprintf(log, \"  matched header #%d: kind=%d, header=%s, value=%s\\n\",\n                ret,\n                (int) pos->kind,\n                (pos->header != NULL) ? pos->header : \"(null)\",\n                (pos->value != NULL) ? pos->value : \"(null)\");\n      }\n      if ( (NULL != iterator) )\n      {\n        int it_res = (int) iterator (iterator_cls,\n                                     pos->kind,\n                                     pos->header,\n                                     pos->value);\n        if (log != NULL)\n        {\n          fprintf(log, \"    iterator returned: %d\\n\", it_res);\n        }\n        if (MHD_NO == it_res)\n        {\n          if (log != NULL)\n          {\n            fprintf(log, \"    iterator requested early exit -> return %d\\n\", ret);\n            fclose(log);\n          }\n          return ret;\n        }\n      }\n    }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"MHD_get_connection_values: finished -> return %d\\n\", ret);\n    fclose(log);\n  }\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 8.13 requires a pointer to be const-qualified when the pointed-to object is not modified by the function. In the posted MHD_get_connection_values implementation the function only inspects the connection and header list fields (reads pos->kind, pos->header, pos->value, pos->next) and does not modify the pointed-to objects. Therefore, from a pure-rule point of view the parameter should be declared as const struct MHD_Connection *connection and the local loop pointer as const struct MHD_HTTP_Req_Header *pos (and any downstream uses that accept non-const should be adjusted to accept const).\n\nThat said, the rule also allows a non-const pointer when the function (or functions it calls) may modify the object. If the public API requires non-const (for backward compatibility) or the iterator callback is declared to take non-const pointers so that callers may legitimately modify the strings, keeping the parameters non-const is justified and not a violation. Absent such a justification in the shown code, the agent A report is correct: the function as written does not qualify the pointers as const and therefore violates Rule 8.13.\n"
}