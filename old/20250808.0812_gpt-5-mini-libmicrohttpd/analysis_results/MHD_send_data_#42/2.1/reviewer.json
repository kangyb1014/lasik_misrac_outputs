{
  "user_message": "An agent A claimed that the following MHD_send_data_ code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_data_.\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When the project is built without HTTPS_SUPPORT (i.e. HTTPS_SUPPORT is not defined), the local constant tls_conn is initialised to false unconditionally. The 'if (tls_conn)' branch of MHD_send_data_ can never be taken, so all code in that branch is unreachable in that build configuration. This violates MISRA C 2023 Rule 2.1 because unreachable code is present in the project.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MHD_USE_TLS = 1;\nstatic const MHD_socket MHD_INVALID_SOCKET = -1;\nstatic const int MHD_CONNECTION_CLOSED = 0;\nstatic const ssize_t MHD_ERR_NOTCONN_   = -1;\nstatic const ssize_t MHD_ERR_AGAIN_     = -2;\nstatic const ssize_t MHD_ERR_TLS_       = -3;\nstatic const ssize_t MHD_ERR_PIPE_      = -4;\nstatic const ssize_t MHD_ERR_CONNRESET_ = -5;\nstatic const ssize_t MHD_ERR_NOMEM_     = -6;\nstatic const ssize_t MHD_ERR_OPNOTSUPP_ = -7;\nstatic const ssize_t MHD_ERR_INVAL_     = -8;\nstatic const ssize_t MHD_ERR_BADF_      = -9;\nstatic const size_t MHD_SCKT_SEND_MAX_SIZE_ = 65536;\nstatic const ssize_t GNUTLS_E_AGAIN = -100;\nstatic const ssize_t GNUTLS_E_INTERRUPTED = -101;\nstatic const ssize_t GNUTLS_E_ENCRYPTION_FAILED = -102;\nstatic const ssize_t GNUTLS_E_INVALID_SESSION = -103;\nstatic const ssize_t GNUTLS_E_COMPRESSION_FAILED = -104;\nstatic const ssize_t GNUTLS_E_EXPIRED = -105;\nstatic const ssize_t GNUTLS_E_HASH_FAILED = -106;\nstatic const ssize_t GNUTLS_E_PUSH_ERROR = -107;\nstatic const ssize_t GNUTLS_E_INTERNAL_ERROR = -108;\nstatic const ssize_t GNUTLS_E_CRYPTODEV_IOCTL_ERROR = -109;\nstatic const ssize_t GNUTLS_E_CRYPTODEV_DEVICE_ERROR = -110;\nstatic const ssize_t GNUTLS_E_MEMORY_ERROR = -111;\nssize_t gnutls_record_send (void *session, const void *data, size_t size);\nssize_t MHD_send4_ (MHD_socket s, const void *buf, size_t len, int flags);\nint MHD_socket_get_error_ (void);\nstatic inline int MHD_SCKT_ERR_IS_EAGAIN_ (int err)     { return (err == EAGAIN) || (err == EWOULDBLOCK); }\nstatic inline int MHD_SCKT_ERR_IS_EINTR_ (int err)      { return (err == EINTR); }\nstatic inline int MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err)\n{ return (err == ECONNRESET) || (err == ECONNABORTED) || (err == ENOTCONN); }\nstatic inline int MHD_SCKT_ERR_IS_ (int err, int code)  { return err == code; }\nstatic inline int MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err)\n{ return (err == ENOMEM) || (err == ENOBUFS); }\nstatic const int MHD_SCKT_EPIPE_ = EPIPE;\nstatic const int MHD_SCKT_EOPNOTSUPP_ = EOPNOTSUPP;\nstatic const int MHD_SCKT_ENOTCONN_ = ENOTCONN;\nstatic const int MHD_SCKT_EINVAL_ = EINVAL;\nstatic const int MHD_SCKT_EBADF_ = EBADF;\n\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n\n  /* If HTTPS support not compiled in, force tls_conn=false. The original\n   * source used preprocessor checks; here we follow the same runtime\n   * behavior by making tls_conn depend on daemon options but keeping\n   * the remainder of TLS-specific code guarded by HTTPS_SUPPORT in\n   * original source. For this test compilation we simply set tls_conn\n   * based on the daemon option. */\n  const bool tls_conn = (connection->daemon && (connection->daemon->options & MHD_USE_TLS)) ? true : false;\n\n  /* Log entry and state for probing unreachable-path scenario */\n  {\n    FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"MHD_send_data_: entry socket=%d state=%d tls_conn=%d\\n\",\n              (int) s,\n              (int) connection->state,\n              (int) tls_conn);\n      fclose(log);\n    }\n  }\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"MHD_send_data_: early return MHD_ERR_NOTCONN_ (invalid socket or closed)\\n\");\n      fclose(log);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > (size_t) SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n    /* In the original build the TLS-specific code was inside #ifdef HTTPS_SUPPORT.\n     * We declared gnutls_record_send above; if a TLS-enabled build calls this\n     * function, the actual gnutls implementation would be linked in externally.\n     * Here we keep the original error handling logic. */\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n\n    if (GNUTLS_E_AGAIN == ret || GNUTLS_E_AGAIN == (ssize_t) ret)\n    {\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: TLS GNUTLS_E_AGAIN -> MHD_ERR_AGAIN_\\n\");\n          fclose(log);\n        }\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n    {\n      FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"MHD_send_data_: TLS GNUTLS_E_INTERRUPTED -> MHD_ERR_AGAIN_\\n\");\n        fclose(log);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n    {\n      FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"MHD_send_data_: TLS specific error -> MHD_ERR_TLS_ ret=%zd\\n\", ret);\n        fclose(log);\n      }\n      return MHD_ERR_TLS_;\n    }\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n    {\n      FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"MHD_send_data_: TLS push/internal/crypto error -> MHD_ERR_PIPE_ ret=%zd\\n\", ret);\n        fclose(log);\n      }\n      return MHD_ERR_PIPE_;\n    }\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n    {\n      FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"MHD_send_data_: TLS memory error -> MHD_ERR_NOMEM_\\n\");\n        fclose(log);\n      }\n      return MHD_ERR_NOMEM_;\n    }\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n      if (log)\n      {\n        fprintf(log, \"MHD_send_data_: TLS other error ret=%zd -> MHD_ERR_NOTCONN_\\n\", ret);\n        fclose(log);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n        {\n          FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n          if (log)\n          {\n            fprintf(log, \"MHD_send_data_: send() EAGAIN -> MHD_ERR_AGAIN_ err=%d\\n\", err);\n            fclose(log);\n          }\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() EINTR -> MHD_ERR_AGAIN_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() remote disconnect -> MHD_ERR_CONNRESET_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_CONNRESET_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() EPIPE -> MHD_ERR_PIPE_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_PIPE_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() EOPNOTSUPP -> MHD_ERR_OPNOTSUPP_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_OPNOTSUPP_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() ENOTCONN -> MHD_ERR_NOTCONN_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_NOTCONN_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() EINVAL -> MHD_ERR_INVAL_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_INVAL_;\n      }\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() low resources -> MHD_ERR_NOMEM_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_NOMEM_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() EBADF -> MHD_ERR_BADF_ err=%d\\n\", err);\n          fclose(log);\n        }\n        return MHD_ERR_BADF_;\n      }\n      /* Treat any other error as a hard error. */\n      {\n        FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n        if (log)\n        {\n          fprintf(log, \"MHD_send_data_: send() other error -> MHD_ERR_NOTCONN_ err=%d\\n\", err);\n          fclose(log);\n        }\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  {\n    FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"MHD_send_data_: exit ret=%zd\\n\", ret);\n      fclose(log);\n    }\n  }\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the configuration where HTTPS_SUPPORT is not defined the code path does make tls_conn a local const initialized to false, and there is no code that can change it. Therefore the test if (tls_conn) can never succeed and every statement in that then-branch is unreachable in that build configuration. MISRA C 2023 Rule 2.1 forbids unreachable code in the project, so the reported violation is valid. Practical fixes include moving the whole TLS branch behind the HTTPS_SUPPORT preprocessor guard (so it is absent when HTTPS_SUPPORT is not defined), or making tls_conn a runtime-evaluated value only in TLS-enabled builds (so the branch is not provably always false)."
}