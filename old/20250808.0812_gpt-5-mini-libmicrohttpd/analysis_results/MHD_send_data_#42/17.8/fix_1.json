{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nenum MHD_State { MHD_CONNECTION_CLOSED = 0 };\nstatic const ssize_t MHD_ERR_NOTCONN_ = -1;\nstatic const ssize_t MHD_ERR_AGAIN_ = -2;\nstatic const ssize_t MHD_ERR_TLS_ = -3;\nstatic const ssize_t MHD_ERR_PIPE_ = -4;\nstatic const ssize_t MHD_ERR_CONNRESET_ = -5;\nstatic const ssize_t MHD_ERR_NOMEM_ = -6;\nstatic const ssize_t MHD_ERR_OPNOTSUPP_ = -7;\nstatic const ssize_t MHD_ERR_INVAL_ = -8;\nstatic const ssize_t MHD_ERR_BADF_ = -9;\nstatic const MHD_socket MHD_INVALID_SOCKET = -1;\nstatic const size_t MHD_SCKT_SEND_MAX_SIZE_ = 65536u;\nssize_t MHD_send4_ (MHD_socket s, const char *buffer, size_t buffer_size, int flags);\nint MHD_socket_get_error_ (void);\nint MHD_SCKT_ERR_IS_EAGAIN_ (int err);\nint MHD_SCKT_ERR_IS_EINTR_ (int err);\nint MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err);\nint MHD_SCKT_ERR_IS_ (int err, int code);\nint MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err);\n\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n\n  /* Log entry state */\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ENTRY: socket=%d state=%d buffer_size=%zu push_data=%d\\n\",\n              (int)s, (int)connection->state, buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"RETURN not connected: socket=%d state=%d\\n\", (int)s, (int)connection->state);\n      fclose(fp);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    /* This is one of the parameter modifications that violates Rule 17.8. */\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"BRANCH: buffer_size(%zu) > SSIZE_MAX(%zu) - modifying parameters\\n\",\n              buffer_size, (size_t)SSIZE_MAX);\n      fclose(fp);\n    }\n\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n\n    /* Log after modification */\n    fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"MODIFIED_PARAMS: new_buffer_size=%zu push_data=%d\\n\",\n              buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"TLS: GNUTLS_E_AGAIN -> return MHD_ERR_AGAIN_\\n\");\n        fclose(fp);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      /* Another parameter modification that demonstrates the violation. */\n      FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"BRANCH: buffer_size(%zu) > MHD_SCKT_SEND_MAX_SIZE_(%u) - modifying parameters\\n\",\n                buffer_size, (unsigned)MHD_SCKT_SEND_MAX_SIZE_);\n        fclose(fp);\n      }\n\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n\n      fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"MODIFIED_PARAMS: new_buffer_size=%zu push_data=%d\\n\",\n                buffer_size, (int)push_data);\n        fclose(fp);\n      }\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n        if (fp)\n        {\n          fprintf(fp, \"SEND: EAGAIN -> return MHD_ERR_AGAIN_ err=%d\\n\", err);\n          fclose(fp);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  /* Log exit state */\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"EXIT: ret=%zd final_buffer_size=%zu final_push_data=%d\\n\",\n              ret, buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_send.c:763:18: error: redeclaration of enumerator 'MHD_CONNECTION_CLOSED'\n  763 | enum MHD_State { MHD_CONNECTION_CLOSED = 0 };\n      |                  ^~~~~~~~~~~~~~~~~~~~~\nIn file included from mhd_send.h:33,\n                 from mhd_send.c:48:\ninternal.h:741:3: note: previous definition of 'MHD_CONNECTION_CLOSED' with type 'enum MHD_CONNECTION_STATE'\n  741 |   MHD_CONNECTION_CLOSED = MHD_CONNECTION_FULL_REPLY_SENT + 1\n      |   ^~~~~~~~~~~~~~~~~~~~~\nIn file included from mhd_send.h:39,\n                 from mhd_send.c:48:\nconnection.h:48:27: error: expected identifier or '(' before '-' token\n   48 | #define MHD_ERR_NOTCONN_ (-3075)\n      |                           ^\nmhd_send.c:764:22: note: in expansion of macro 'MHD_ERR_NOTCONN_'\n  764 | static const ssize_t MHD_ERR_NOTCONN_ = -1;\n      |                      ^~~~~~~~~~~~~~~~\nconnection.h:37:25: error: expected identifier or '(' before '-' token\n   37 | #define MHD_ERR_AGAIN_ (-3073)\n      |                         ^\nmhd_send.c:765:22: note: in expansion of macro 'MHD_ERR_AGAIN_'\n  765 | static const ssize_t MHD_ERR_AGAIN_ = -2;\n      |                      ^~~~~~~~~~~~~~\nconnection.h:78:23: error: expected identifier or '(' before '-' token\n   78 | #define MHD_ERR_TLS_ (-4097)\n      |                       ^\nmhd_send.c:766:22: note: in expansion of macro 'MHD_ERR_TLS_'\n  766 | static const ssize_t MHD_ERR_TLS_ = -3;\n      |                      ^~~~~~~~~~~~\nconnection.h:73:24: error: expected identifier or '(' before '-' token\n   73 | #define MHD_ERR_PIPE_ (-3080)\n      |                        ^\nmhd_send.c:767:22: note: in expansion of macro 'MHD_ERR_PIPE_'\n  767 | static const ssize_t MHD_ERR_PIPE_ = -4;\n      |                      ^~~~~~~~~~~~~\nconnection.h:42:29: error: expected identifier or '(' before '-' token\n   42 | #define MHD_ERR_CONNRESET_ (-3074)\n      |                             ^\nmhd_send.c:768:22: note: in expansion of macro 'MHD_ERR_CONNRESET_'\n  768 | static const ssize_t MHD_ERR_CONNRESET_ = -5;\n      |                      ^~~~~~~~~~~~~~~~~~\nconnection.h:53:25: error: expected identifier or '(' before '-' token\n   53 | #define MHD_ERR_NOMEM_ (-3076)\n      |                         ^\nmhd_send.c:769:22: note: in expansion of macro 'MHD_ERR_NOMEM_'\n  769 | static const ssize_t MHD_ERR_NOMEM_ = -6;\n      |                      ^~~~~~~~~~~~~~\nconnection.h:68:29: error: expected identifier or '(' before '-' token\n   68 | #define MHD_ERR_OPNOTSUPP_ (-3079)\n      |                             ^\nmhd_send.c:770:22: note: in expansion of macro 'MHD_ERR_OPNOTSUPP_'\n  770 | static const ssize_t MHD_ERR_OPNOTSUPP_ = -7;\n      |                      ^~~~~~~~~~~~~~~~~~\nconnection.h:63:25: error: expected identifier or '(' before '-' token\n   63 | #define MHD_ERR_INVAL_ (-3078)\n      |                         ^\nmhd_send.c:771:22: note: in expansion of macro 'MHD_ERR_INVAL_'\n  771 | static const ssize_t MHD_ERR_INVAL_ = -8;\n      |                      ^~~~~~~~~~~~~~\nconnection.h:58:24: error: expected identifier or '(' before '-' token\n   58 | #define MHD_ERR_BADF_ (-3077)\n      |                        ^\nmhd_send.c:772:22: note: in expansion of macro 'MHD_ERR_BADF_'\n  772 | static const ssize_t MHD_ERR_BADF_ = -9;\n      |                      ^~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\n../../src/include/microhttpd.h:202:29: error: expected identifier or '(' before '-' token\n  202 | #define MHD_INVALID_SOCKET (-1)\n      |                             ^\nmhd_send.c:773:25: note: in expansion of macro 'MHD_INVALID_SOCKET'\n  773 | static const MHD_socket MHD_INVALID_SOCKET = -1;\n      |                         ^~~~~~~~~~~~~~~~~~\nmhd_sockets.h:324:35: error: expected identifier or '(' before numeric constant\n  324 | #  define MHD_SCKT_SEND_MAX_SIZE_ SSIZE_MAX\n      |                                   ^~~~~~~~~\nmhd_send.c:774:21: note: in expansion of macro 'MHD_SCKT_SEND_MAX_SIZE_'\n  774 | static const size_t MHD_SCKT_SEND_MAX_SIZE_ = 65536u;\n      |                     ^~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:365:14: error: expected ')' before 'send'\n  365 |   ((ssize_t) send ((s),(const void*) (b),(MHD_SCKT_SEND_SIZE_) (l), \\\n      |              ^~~~\nmhd_send.c:775:9: note: in expansion of macro 'MHD_send4_'\n  775 | ssize_t MHD_send4_ (MHD_socket s, const char *buffer, size_t buffer_size, int flags);\n      |         ^~~~~~~~~~\nmhd_send.c:776:32: error: macro \"MHD_socket_get_error_\" passed 1 arguments, but takes just 0\n  776 | int MHD_socket_get_error_ (void);\n      |                                ^\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:660: note: macro \"MHD_socket_get_error_\" defined here\n  660 | #  define MHD_socket_get_error_() (errno)\n      | \nmhd_sockets.h:501:36: error: expected identifier or '(' before numeric constant\n  501 | #define MHD_SCKT_MISSING_ERR_CODE_ 31450\n      |                                    ^~~~~\nmhd_sockets.h:749:6: note: in expansion of macro 'MHD_SCKT_MISSING_ERR_CODE_'\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:780:40: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  780 | #  define MHD_SCKT_ERR_IS_EAGAIN_(err) MHD_SCKT_ERR_IS_ ((err),MHD_SCKT_EAGAIN_)\n      |                                        ^~~~~~~~~~~~~~~~\nmhd_send.c:777:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_EAGAIN_'\n  777 | int MHD_SCKT_ERR_IS_EAGAIN_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:749:44: error: expected ')' before '&&' token\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |                                            ^~\nmhd_sockets.h:780:40: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  780 | #  define MHD_SCKT_ERR_IS_EAGAIN_(err) MHD_SCKT_ERR_IS_ ((err),MHD_SCKT_EAGAIN_)\n      |                                        ^~~~~~~~~~~~~~~~\nmhd_send.c:777:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_EAGAIN_'\n  777 | int MHD_SCKT_ERR_IS_EAGAIN_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:501:36: error: expected identifier or '(' before numeric constant\n  501 | #define MHD_SCKT_MISSING_ERR_CODE_ 31450\n      |                                    ^~~~~\nmhd_sockets.h:749:6: note: in expansion of macro 'MHD_SCKT_MISSING_ERR_CODE_'\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:771:37: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  771 | #define MHD_SCKT_ERR_IS_EINTR_(err) MHD_SCKT_ERR_IS_ ((err),MHD_SCKT_EINTR_)\n      |                                     ^~~~~~~~~~~~~~~~\nmhd_send.c:778:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_EINTR_'\n  778 | int MHD_SCKT_ERR_IS_EINTR_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:749:44: error: expected ')' before '&&' token\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |                                            ^~\nmhd_sockets.h:771:37: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  771 | #define MHD_SCKT_ERR_IS_EINTR_(err) MHD_SCKT_ERR_IS_ ((err),MHD_SCKT_EINTR_)\n      |                                     ^~~~~~~~~~~~~~~~\nmhd_send.c:778:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_EINTR_'\n  778 | int MHD_SCKT_ERR_IS_EINTR_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:501:36: error: expected identifier or '(' before numeric constant\n  501 | #define MHD_SCKT_MISSING_ERR_CODE_ 31450\n      |                                    ^~~~~\nmhd_sockets.h:749:6: note: in expansion of macro 'MHD_SCKT_MISSING_ERR_CODE_'\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:819:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  819 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_ECONNRESET_) || \\\n      |     ^~~~~~~~~~~~~~~~\nmhd_send.c:779:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_REMOTE_DISCNN_'\n  779 | int MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:749:44: error: expected ')' before '&&' token\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |                                            ^~\nmhd_sockets.h:819:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  819 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_ECONNRESET_) || \\\n      |     ^~~~~~~~~~~~~~~~\nmhd_send.c:779:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_REMOTE_DISCNN_'\n  779 | int MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:819:52: error: expected ')' before '||' token\n  819 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_ECONNRESET_) || \\\n      |                                                    ^~\nmhd_send.c:779:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_REMOTE_DISCNN_'\n  779 | int MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:501:36: error: expected identifier or '(' before numeric constant\n  501 | #define MHD_SCKT_MISSING_ERR_CODE_ 31450\n      |                                    ^~~~~\nmhd_sockets.h:749:6: note: in expansion of macro 'MHD_SCKT_MISSING_ERR_CODE_'\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_send.c:780:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  780 | int MHD_SCKT_ERR_IS_ (int err, int code);\n      |     ^~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:749:44: error: expected ')' before '&&' token\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |                                            ^~\nmhd_send.c:780:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  780 | int MHD_SCKT_ERR_IS_ (int err, int code);\n      |     ^~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:501:36: error: expected identifier or '(' before numeric constant\n  501 | #define MHD_SCKT_MISSING_ERR_CODE_ 31450\n      |                                    ^~~~~\nmhd_sockets.h:749:6: note: in expansion of macro 'MHD_SCKT_MISSING_ERR_CODE_'\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:793:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  793 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_EMFILE_) || \\\n      |     ^~~~~~~~~~~~~~~~\nmhd_send.c:781:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_LOW_RESOURCES_'\n  781 | int MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:63,\n                 from mhd_send.h:33,\n                 from mhd_send.c:48:\nmhd_sockets.h:749:44: error: expected ')' before '&&' token\n  749 |   ( (MHD_SCKT_MISSING_ERR_CODE_ != (code)) && ((code) == (err)) )\n      |                                            ^~\nmhd_sockets.h:793:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_'\n  793 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_EMFILE_) || \\\n      |     ^~~~~~~~~~~~~~~~\nmhd_send.c:781:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_LOW_RESOURCES_'\n  781 | int MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmhd_sockets.h:793:48: error: expected ')' before '||' token\n  793 |   ( MHD_SCKT_ERR_IS_ ((err), MHD_SCKT_EMFILE_) || \\\n      |                                                ^~\nmhd_send.c:781:5: note: in expansion of macro 'MHD_SCKT_ERR_IS_LOW_RESOURCES_'\n  781 | int MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmake[3]: *** [Makefile:2147: libmicrohttpd_la-mhd_send.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_send_data_ as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\n#include <sys/types.h>\n\n/* Minimal local types and constants to allow this translation unit to\n * compile standalone. These are intentionally simple and chosen to\n * avoid conflicting with any external headers. No macros are defined. */\n\ntypedef int MHD_socket;\n\nenum MHD_State { MHD_CONNECTION_CLOSED = 0 };\n\nstruct MHD_Daemon { int options; };\n\nstruct MHD_Connection\n{\n  MHD_socket socket_fd;\n  int state;\n  struct MHD_Daemon *daemon;\n  void *tls_session;\n  int epoll_state;\n};\n\n/* Error/result constants (names preserved to match original code). */\nstatic const ssize_t MHD_ERR_NOTCONN_ = -1;\nstatic const ssize_t MHD_ERR_AGAIN_ = -2;\nstatic const ssize_t MHD_ERR_TLS_ = -3;\nstatic const ssize_t MHD_ERR_PIPE_ = -4;\nstatic const ssize_t MHD_ERR_CONNRESET_ = -5;\nstatic const ssize_t MHD_ERR_NOMEM_ = -6;\nstatic const ssize_t MHD_ERR_OPNOTSUPP_ = -7;\nstatic const ssize_t MHD_ERR_INVAL_ = -8;\nstatic const ssize_t MHD_ERR_BADF_ = -9;\nstatic const MHD_socket MHD_INVALID_SOCKET = -1;\nstatic const size_t MHD_SCKT_SEND_MAX_SIZE_ = 65536u;\n\n/* Minimal socket error-code constants used as arguments to helpers. */\nstatic const int MHD_SCKT_EPIPE_ = 1;\nstatic const int MHD_SCKT_EOPNOTSUPP_ = 2;\nstatic const int MHD_SCKT_ENOTCONN_ = 3;\nstatic const int MHD_SCKT_EINVAL_ = 4;\nstatic const int MHD_SCKT_EBADF_ = 5;\n\n/* External helper function prototypes. These are declared only so this\n * compilation unit can be compiled. Implementations are expected to\n * be provided elsewhere (no mock implementations here). */\nssize_t MHD_send4_ (MHD_socket s, const char *buffer, size_t buffer_size, int flags);\nint MHD_socket_get_error_ (void);\nint MHD_SCKT_ERR_IS_EAGAIN_ (int err);\nint MHD_SCKT_ERR_IS_EINTR_ (int err);\nint MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int err);\nint MHD_SCKT_ERR_IS_ (int err, int code);\nint MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err);\n\nvoid pre_send_setopt (struct MHD_Connection *connection, bool tls, bool push_data);\nvoid post_send_setopt (struct MHD_Connection *connection, bool tls, bool push_data);\n\n/* Option flag used by the code to detect TLS (kept as const to avoid macros). */\nstatic const int MHD_USE_TLS = 1;\n\n/* The function implementation preserved from the original source with as\n * much of the original logic kept as possible. Conditional compilation\n * around HTTPS_SUPPORT and EPOLL_SUPPORT is left intact: when those\n * symbols are not defined, the non-TLS and non-epoll paths are used. */\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n\n  /* Log entry state */\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ENTRY: socket=%d state=%d buffer_size=%zu push_data=%d\\n\",\n              (int)s, (int)connection->state, buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"RETURN not connected: socket=%d state=%d\\n\", (int)s, (int)connection->state);\n      fclose(fp);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    /* This is one of the parameter modifications that violates Rule 17.8. */\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"BRANCH: buffer_size(%zu) > SSIZE_MAX(%zu) - modifying parameters\\n\",\n              buffer_size, (size_t)SSIZE_MAX);\n      fclose(fp);\n    }\n\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n\n    /* Log after modification */\n    fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"MODIFIED_PARAMS: new_buffer_size=%zu push_data=%d\\n\",\n              buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"TLS: GNUTLS_E_AGAIN -> return MHD_ERR_AGAIN_\\n\");\n        fclose(fp);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      /* Another parameter modification that demonstrates the violation. */\n      FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"BRANCH: buffer_size(%zu) > MHD_SCKT_SEND_MAX_SIZE_(%u) - modifying parameters\\n\",\n                buffer_size, (unsigned)MHD_SCKT_SEND_MAX_SIZE_);\n        fclose(fp);\n      }\n\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n\n      fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n      if (fp)\n      {\n        fprintf(fp, \"MODIFIED_PARAMS: new_buffer_size=%zu push_data=%d\\n\",\n                buffer_size, (int)push_data);\n        fclose(fp);\n      }\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n        if (fp)\n        {\n          fprintf(fp, \"SEND: EAGAIN -> return MHD_ERR_AGAIN_ err=%d\\n\", err);\n          fclose(fp);\n        }\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  /* Log exit state */\n  {\n    FILE *fp = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"EXIT: ret=%zd final_buffer_size=%zu final_push_data=%d\\n\",\n              ret, buffer_size, (int)push_data);\n      fclose(fp);\n    }\n  }\n\n  return ret;\n}\n",
  "explanation": "I made the translation unit self-contained to avoid conflicts with external headers and macros that caused the original build errors. Changes made:\n\n- Added standard includes (stdio.h, stdlib.h, stdbool.h, etc.).\n- Declared minimal local types (MHD_socket, struct MHD_Connection, struct MHD_Daemon) and the enum MHD_State to preserve state handling.\n- Recreated the error/result constants and socket-related constants as static const values rather than macros to avoid collisions with external headers.\n- Declared prototypes for external helper functions (MHD_send4_, MHD_socket_get_error_, etc.) and for pre_send_setopt/post_send_setopt so this file compiles; implementations are expected to be provided elsewhere (no mock implementations were added).\n- Kept the original MHD_send_data_ logic and logging intact, preserving conditional compilation blocks (HTTPS_SUPPORT, EPOLL_SUPPORT) so behavior remains consistent when those are defined at link/compile time.\n\nThis resolves the earlier redeclaration/macro expansion problems by not including the conflicting headers and by not defining any macros; the file should now compile as a standalone translation unit and link when the external functions/types are provided elsewhere."
}