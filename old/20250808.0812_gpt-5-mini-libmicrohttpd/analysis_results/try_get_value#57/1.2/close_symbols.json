{
  "user_message": "Target function code is:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_get_value': {'callees': [], 'callers': ['process_multipart_headers']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "NULL",
    "size_t",
    "malloc",
    "strlen",
    "strstr",
    "strchr",
    "memcpy",
    "<stddef.h>",
    "<stdlib.h>",
    "<string.h>"
  ],
  "explanation": "You must inspect the declarations/definitions of the listed symbols to detect any compiler-specific language extensions (e.g. macros that expand to builtins, attributes, inline assembly, GCC/MSC-specific __attribute__/__declspec, nonstandard calling conventions, statement-expressions, typeof, nested functions, etc.).\n\n- NULL: Often a macro; some projects/compilers redefine it in nonstandard ways. Check its definition to ensure it is a standard C macro and not implemented using compiler-specific extensions.\n- size_t: Typedef from <stddef.h>/<stdio.h>; its typedef could be provided via compiler headers or use implementation-specific extensions. Verify it is a standard type and not a vendor extension.\n- malloc: Usually declared in <stdlib.h>. It can be a macro or an inline/wrapper using compiler-specific attributes or builtins. Examine its prototype/definition for attributes or nonstandard linkage.\n- strlen, strstr, strchr, memcpy: Declared in <string.h>. Each can be implemented as macros, inline functions, or map to compiler builtins (__builtin_*) or have nonstandard attributes. Inspect their declarations/definitions for any compiler-specific extensions.\n- <stddef.h>, <stdlib.h>, <string.h>: The header sources themselves must be examined because they supply the above symbols; the headers may contain compiler-specific constructs or macros that would constitute language extensions.\n\nChecking these symbols/headers lets the next analyst determine whether any nonstandard/implementation-specific language extensions are effectively used by try_get_value (via macros, attributes, or header-level constructs)."
}