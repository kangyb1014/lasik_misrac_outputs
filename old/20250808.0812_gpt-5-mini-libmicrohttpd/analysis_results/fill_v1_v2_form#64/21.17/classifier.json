{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified fill_v1_v2_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/519.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of fill_v1_v2_form as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of fill_v1_v2_form:\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function fill_v1_v2_form:\n#define SECOND_PAGE \"<html><head><title>Tell me more</title></head><body><a href=\\\"/\\\">previous</a> <form action=\\\"/S\\\" method=\\\"post\\\">%s, what is your job? <input type=\\\"text\\\" name=\\\"v2\\\" value=\\\"%s\\\" /><input type=\\\"submit\\\" value=\\\"Next\\\" /></form></body></html>\"\n...\nstruct Session\n{\n  /**\n   * We keep all sessions in a linked list.\n   */\n  struct Session *next;\n\n  /**\n   * Unique ID for this session.\n   */\n  char sid[33];\n\n  /**\n   * Reference counter giving the number of connections\n   * currently using this session.\n   */\n  unsigned int rc;\n\n  /**\n   * Time when this session was last active.\n   */\n  time_t start;\n\n  /**\n   * String submitted via form.\n   */\n  char value_1[64];\n\n  /**\n   * Another value submitted via form.\n   */\n  char value_2[64];\n\n}\n</additional code>\nJudge whether the above fill_v1_v2_form code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "strlen is called on session->value_1 and session->value_2 (fixed-size char arrays). If those arrays are not guaranteed to contain a terminating '\\0' within their bounds, strlen can read past the end of the arrays -> out-of-bounds access. Thus Rule 21.17 is violated: use of strlen may access beyond the bounds of the objects referenced by their pointer parameters.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <stddef.h>\n\n/* Minimal supportive declarations so this unit compiles standalone. */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nstruct MHD_Connection;\nstruct MHD_Response;\n\n/* Forward declarations of external functions used by the original code. */\nextern enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection, int code, struct MHD_Response *response);\n\nextern struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t, void *, void (*)(void *));\n\nextern int\nMHD_add_response_header (struct MHD_Response *, const char *, const char *);\n\nextern void\nMHD_destroy_response (struct MHD_Response *);\n\nextern void\nadd_session_cookie (struct Session *, struct MHD_Response *);\n\n/* Define constants that the original code references. Not macros. */\nstatic const char MHD_HTTP_HEADER_CONTENT_ENCODING[] = \"Content-Encoding\";\nstatic const int MHD_HTTP_OK = 200;\n\n/* Replace the macro SECOND_PAGE with a const string (preserve original content). */\nstatic const char SECOND_PAGE[] =\n  \"<html><head><title>Tell me more</title></head><body><a href=\\\"/\\\">previous</a> <form action=\\\"/S\\\" method=\\\"post\\\">%s, what is your job? <input type=\\\"text\\\" name=\\\"v2\\\" value=\\\"%s\\\" /><input type=\\\"submit\\\" value=\\\"Next\\\" /></form></body></html>\";\n\n/* Session definition as provided. */\nstruct Session\n{\n  struct Session *next;\n  char sid[33];\n  unsigned int rc;\n  time_t start;\n  char value_1[64];\n  char value_2[64];\n};\n\n/* The original function, augmented with non-invasive logging probes.\n   The logging inspects the session value buffers for a NUL within bounds\n   (without reading beyond the arrays) and records the computed lengths\n   and control flow to /tmp/logs/519.txt. The original logic is preserved. */\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Probe logging: record whether value_1 and value_2 contain a NUL within bounds. */\n  {\n    FILE *log = fopen(\"/tmp/logs/519.txt\", \"a\");\n    if (log != NULL)\n    {\n      size_t i;\n      int found1 = -1;\n      int found2 = -1;\n      for (i = 0U; i < sizeof(session->value_1); ++i)\n      {\n        if (session->value_1[i] == '\\0')\n        {\n          found1 = (int)i;\n          break;\n        }\n      }\n      for (i = 0U; i < sizeof(session->value_2); ++i)\n      {\n        if (session->value_2[i] == '\\0')\n        {\n          found2 = (int)i;\n          break;\n        }\n      }\n      fprintf(log, \"enter fill_v1_v2_form\\n\");\n      fprintf(log, \"session->value_1 addr=%p, value_2 addr=%p\\n\",\n              (void *)session->value_1, (void *)session->value_2);\n      if (found1 >= 0)\n        fprintf(log, \"value_1 has NUL within bounds at index %d\\n\", found1);\n      else\n        fprintf(log, \"value_1 has NO NUL within first %zu bytes (risk: strlen may read out-of-bounds)\\n\", sizeof(session->value_1));\n      if (found2 >= 0)\n        fprintf(log, \"value_2 has NUL within bounds at index %d\\n\", found2);\n      else\n        fprintf(log, \"value_2 has NO NUL within first %zu bytes (risk: strlen may read out-of-bounds)\\n\", sizeof(session->value_2));\n      /* Also log the first few bytes (up to 8) in hex to help debugging without overrunning */\n      fprintf(log, \"value_1[0..7]:\");\n      for (size_t j = 0U; j < 8U; ++j)\n        fprintf(log, \" %02x\", (unsigned char)session->value_1[j]);\n      fprintf(log, \"\\n\");\n      fprintf(log, \"value_2[0..7]:\");\n      for (size_t j = 0U; j < 8U; ++j)\n        fprintf(log, \" %02x\", (unsigned char)session->value_2[j]);\n      fprintf(log, \"\\n\");\n      fclose(log);\n    }\n  }\n\n  /* Original computation (this call to strlen can read beyond the array bounds\n     if the session->value_* arrays are not NUL-terminated). */\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n"
}