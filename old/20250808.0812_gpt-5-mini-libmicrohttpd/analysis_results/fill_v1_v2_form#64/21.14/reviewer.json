{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code base uses memcmp to compare a header value to the literal \"close\" inside add_response_header_connection: mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); hdr->value is a null-terminated string and \"close\" is a null-terminated literal. Using memcmp for comparing null-terminated strings violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Response { int dummy; };\nstruct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    void (*freefunc) (void *));\nint\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *name,\n                         const char *value);\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    int status_code,\n                    struct MHD_Response *response);\nvoid\nMHD_destroy_response (struct MHD_Response *response);\nconst char *MHD_HTTP_HEADER_CONTENT_ENCODING = \"Content-Encoding\";\nconst int MHD_HTTP_OK = 200;\nconst char SECOND_PAGE[] = \"<html><body>Value1: %s\\nValue2: %s</body></html>\";\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/518.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  probe_log (\"enter fill_v1_v2_form: session=%p, connection=%p, mime=%p\\n\",\n             (void *) session, (void *) connection, (const void *) mime);\n  probe_log (\"session->value_1='%s', session->value_2='%s'\\n\",\n             session ? session->value_1 : \"(null)\",\n             session ? session->value_2 : \"(null)\");\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_log (\"computed slen=%zu\\n\", slen);\n\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n  {\n    probe_log (\"malloc failed for reply (size=%zu)\\n\", slen + 1);\n    return MHD_NO;\n  }\n  probe_log (\"malloc succeeded: reply=%p\\n\", (void *) reply);\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  probe_log (\"snprintf populated reply (first 128 chars): %.128s\\n\", reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    probe_log (\"MHD_create_response_from_buffer_with_free_callback returned NULL\\n\");\n    free (reply);\n    return MHD_NO;\n  }\n  probe_log (\"created response=%p\\n\", (void *) response);\n\n  add_session_cookie (session, response);\n  probe_log (\"add_session_cookie done\\n\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned != MHD_YES (mime='%s')\\n\",\n               mime ? mime : \"(null)\");\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned MHD_YES\\n\");\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log (\"MHD_queue_response returned %d\\n\", (int) ret);\n\n  MHD_destroy_response (response);\n  probe_log (\"destroyed response and leaving fill_v1_v2_form\\n\");\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the provided function. The body of fill_v1_v2_form contains no call to memcmp (it uses strlen, malloc, snprintf, and response helpers). Agent A\u2019s scenario points to a different function (add_response_header_connection) where memcmp(hdr->value, \"close\", 5) was cited \u2014 that would be a concern if hdr->value is a null\u2011terminated string being compared via memcmp to a string literal, because MISRA C 2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings. But that violation, if present, is in a different function, not in fill_v1_v2_form. Also, the test/instrumentation code failed to compile and provides no evidence affecting fill_v1_v2_form. Therefore the specific report that fill_v1_v2_form violates Rule 21.14 is incorrect."
}