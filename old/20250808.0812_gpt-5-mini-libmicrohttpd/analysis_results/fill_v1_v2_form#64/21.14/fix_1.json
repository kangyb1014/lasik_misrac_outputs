{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/518.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  probe_log (\"enter fill_v1_v2_form: session=%p, connection=%p, mime=%p\\n\",\n             (void *) session, (void *) connection, (const void *) mime);\n  probe_log (\"session->value_1='%s', session->value_2='%s'\\n\",\n             session ? session->value_1 : \"(null)\",\n             session ? session->value_2 : \"(null)\");\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_log (\"computed slen=%zu\\n\", slen);\n\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n  {\n    probe_log (\"malloc failed for reply (size=%zu)\\n\", slen + 1);\n    return MHD_NO;\n  }\n  probe_log (\"malloc succeeded: reply=%p\\n\", (void *) reply);\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  probe_log (\"snprintf populated reply (first 128 chars): %.128s\\n\", reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    probe_log (\"MHD_create_response_from_buffer_with_free_callback returned NULL\\n\");\n    free (reply);\n    return MHD_NO;\n  }\n  probe_log (\"created response=%p\\n\", (void *) response);\n\n  add_session_cookie (session, response);\n  probe_log (\"add_session_cookie done\\n\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned != MHD_YES (mime='%s')\\n\",\n               mime ? mime : \"(null)\");\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned MHD_YES\\n\");\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log (\"MHD_queue_response returned %d\\n\", (int) ret);\n\n  MHD_destroy_response (response);\n  probe_log (\"destroyed response and leaving fill_v1_v2_form\\n\");\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpy1zxafww/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of fill_v1_v2_form as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal supportive type and function declarations so this file compiles\n   while preserving the original logic. These are only declarations\n   (no implementations), so they won't conflict with real implementations\n   when linked into the complete program. */\n\n/* Result enum used by libmicrohttpd-like API */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Opaque types used by the API */\nstruct MHD_Connection { int dummy; };\nstruct MHD_Response { int dummy; };\n\n/* Prototype declarations for the microhttpd-like functions used. */\nstruct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    void (*freefunc) (void *));\n\nint\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *name,\n                         const char *value);\n\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    int status_code,\n                    struct MHD_Response *response);\n\nvoid\nMHD_destroy_response (struct MHD_Response *response);\n\n/* A small helper that the original code calls */\nvoid\nadd_session_cookie (struct Session *session, struct MHD_Response *response);\n\n/* Constants used in the function. Not macros per instructions. */\nconst char *MHD_HTTP_HEADER_CONTENT_ENCODING = \"Content-Encoding\";\nconst int MHD_HTTP_OK = 200;\n\n/* A template page similar to the original SECOND_PAGE; it contains two\n   \"%s\" placeholders for value_1 and value_2. */\nconst char SECOND_PAGE[] = \"<html><body>Value1: %s\\nValue2: %s</body></html>\";\n\n/* Minimal Session structure matching usage in the function. */\nstruct Session {\n  char *value_1;\n  char *value_2;\n};\n\n/* The probe_log implementation from the original snippet. */\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/518.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  probe_log (\"enter fill_v1_v2_form: session=%p, connection=%p, mime=%p\\n\",\n             (void *) session, (void *) connection, (const void *) mime);\n  probe_log (\"session->value_1='%s', session->value_2='%s'\\n\",\n             session ? session->value_1 : \"(null)\",\n             session ? session->value_2 : \"(null)\");\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_log (\"computed slen=%zu\\n\", slen);\n\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n  {\n    probe_log (\"malloc failed for reply (size=%zu)\\n\", slen + 1);\n    return MHD_NO;\n  }\n  probe_log (\"malloc succeeded: reply=%p\\n\", (void *) reply);\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  probe_log (\"snprintf populated reply (first 128 chars): %.128s\\n\", reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    probe_log (\"MHD_create_response_from_buffer_with_free_callback returned NULL\\n\");\n    free (reply);\n    return MHD_NO;\n  }\n  probe_log (\"created response=%p\\n\", (void *) response);\n\n  add_session_cookie (session, response);\n  probe_log (\"add_session_cookie done\\n\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned != MHD_YES (mime='%s')\\n\",\n               mime ? mime : \"(null)\");\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    probe_log (\"MHD_add_response_header for Content-Encoding returned MHD_YES\\n\");\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log (\"MHD_queue_response returned %d\\n\", (int) ret);\n\n  MHD_destroy_response (response);\n  probe_log (\"destroyed response and leaving fill_v1_v2_form\\n\");\n  return ret;\n}\n",
  "explanation": "I added minimal type and function declarations (opaque structs, enum MHD_Result, prototypes for microhttpd-like functions, and add_session_cookie) and defined the SECOND_PAGE string and required constants. This preserves the original logic of fill_v1_v2_form while providing the necessary declarations so the file compiles. No functions were implemented (only prototypes were added), no macros were used, and the probe_log and fill_v1_v2_form bodies were left essentially unchanged."
}