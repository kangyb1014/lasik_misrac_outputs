{
  "user_message": "Target function code is:\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'parse_cookie_header': {'callees': ['MHD_lookup_connection_value_n', 'MHD_connection_alloc_memory_', 'parse_cookies_string', 'MHD_DLOG'], 'callers': ['parse_connection_headers']}, 'MHD_lookup_connection_value_n': {'callees': [], 'callers': ['MHD_lookup_connection_value', 'need_100_continue', 'get_no_space_err_status_code', 'parse_cookie_header', 'parse_connection_headers', 'MHD_create_post_processor', 'ahc_cb']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'parse_cookies_string': {'callees': ['MHD_set_connection_value_n_nocheck_'], 'callers': ['parse_cookie_header']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'parse_connection_headers': {'callees': ['parse_cookie_header', 'handle_req_cookie_no_space', 'MHD_lookup_connection_value_n', 'MHD_DLOG', 'transmit_error_response_len', 'MHD_str_equal_caseless_', 'MHD_str_to_uint64_n_'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum _MHD_ParseCookie (and the MHD_PARSE_COOKIE_* enumerators)",
    "struct MHD_Connection (full definition, including rq and daemon members)",
    "struct MHD_HTTP_Req_Header (full definition, including next member)",
    "MHD_lookup_connection_value_n (declaration/definition)",
    "MHD_STATICSTR_LEN_ (macro definition)",
    "MHD_HEADER_KIND (macro/enum)",
    "MHD_HTTP_HEADER_COOKIE (macro/enum)",
    "MHD_NO (constant/macro)",
    "MHD_connection_alloc_memory_ (declaration/definition)",
    "MHD_pool_try_alloc, MHD_pool_reallocate, MHD_pool_allocate (declarations/definitions)",
    "parse_cookies_string (declaration/definition)",
    "MHD_DLOG (macro or function definition)",
    "_ (underscore) macro/function used for strings (e.g. gettext wrapper)",
    "mhd_assert (macro or function definition)",
    "HAVE_MESSAGES (configuration macro)",
    "type of daemon->client_discipline (declaration)",
    "type/definition of rq.headers_received_tail (member type)"
  ],
  "explanation": "For checking whether the target function uses any compiler language extensions you must inspect the declarations/definitions of macros, types and functions used by the function: - enum _MHD_ParseCookie and the MHD_PARSE_COOKIE_* enumerators: to see if the enum uses implementation-specific attributes or extension syntax (e.g. __attribute__, unusual underlying type). - struct MHD_Connection (full definition): to check for compiler extensions in field declarations (bit-fields with non\u2011standard widths, attributes, use of reserved implementation identifiers, anonymous structs/unions or other extensions). The function accesses connection->rq and connection->daemon so you need the full struct. - struct MHD_HTTP_Req_Header (full definition): the code manipulates headers_received_tail and saved_tail->next; inspect the struct for extensions (anonymous members, attributes, packed/aligned pragmas). - MHD_lookup_connection_value_n (declaration/definition): the call site uses this function's return and parameters; its prototype or macro may use non\u2011standard attributes, variadic or GNU-specific constructs. - MHD_STATICSTR_LEN_ (macro): macros are a common place for compiler extensions (statement expressions, typeof, GCC __extension__, token pasting tricks). Inspect its definition to ensure it is standard-compliant. - MHD_HEADER_KIND and MHD_HTTP_HEADER_COOKIE (macros/constants): they may be defined in non-standard ways (macros using sizeof tricks, compound literals, or extension syntax). - MHD_NO (constant): to verify it is a standard constant (enum or macro) and not defined via extensions. - MHD_connection_alloc_memory_ (declaration/definition): allocation helpers sometimes use compiler-specific attributes or builtins; its implementation may call extension-bearing APIs. - MHD_pool_try_alloc, MHD_pool_reallocate, MHD_pool_allocate (declarations/definitions): these are transitive callees of the alloc function; inspect for gcc/clang-specific intrinsics or extensions. - parse_cookies_string (declaration/definition): its signature or implementation might use language extensions (compound literals, nested functions, statement expressions, typeof, attributes). - MHD_DLOG (macro or function): logging macros often use variadic macros, token pasting, or GCC extensions (##__VA_ARGS__, statement expressions). Confirm whether its implementation relies on compiler extensions. - _ (underscore) macro/function (gettext wrapper): check its definition to ensure it does not expand to an extension (e.g. uses GCC attributes or nonstandard constructs). - mhd_assert (macro/function): assertions often use do { ... } while (0) idiom (standard) but may use extensions (statement expressions, __builtin_trap). - HAVE_MESSAGES (configuration macro): needed to understand conditional compilation; some branches may hide extension use. - type of daemon->client_discipline: the code compares this value numerically; if it is a bit-field, enum, or uses implementation-specific width, that could involve extensions. - type/definition of rq.headers_received_tail: although covered by the header struct, explicitly ensure the member type (pointer, intrusive list) does not rely on extensions. Each listed symbol must be inspected because macros, typedefs, struct/enum definitions and function declarations are the places where compiler-specific extensions (GNU statement expressions, typeof, __attribute__, inline assembly, nested functions, reserved identifier misuse, compiler builtins, nonstandard linkage or storage-class specifiers, or nonstandard macro tricks) typically appear. Only by examining these definitions can you determine whether the target function uses any banned language extensions."
}