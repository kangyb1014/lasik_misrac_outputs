{
  "user_message": "An agent A claimed that the following thread_main_handle_connection code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of thread_main_handle_connection.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The project contains executed operations that have no effect on program behaviour: the \"if (1) { /* pseudo-branch for local variables scope */ ... }\" construct inside call_handlers is a constant-true conditional used only to scope local variables. The evaluation of that constant condition is executed yet it does not affect program behaviour; removing the constant conditional (the \"if (1)\" itself) would not change the program semantics. A concrete path that exercises this is when a connection reaches MHD_CONNECTION_CHUNKED_BODY_UNREADY (so call_handlers runs the branch that contains the pseudo-branch). The provided test code logs entry, each select/poll + call_handlers invocation, the connection state, and exit to /tmp/logs/122.txt so you can observe the control path that leads into the area where the constant-true pseudo-branch is executed.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <sys/select.h>\n#include <unistd.h>\n#include <string.h>\n\n/* Minimal types and constants to allow this translation unit to compile.\n   These are kept as simple declarations so the original logic of\n   thread_main_handle_connection can remain largely unchanged. */\n\ntypedef int MHD_socket;\n\nenum {\n  MHD_CONNECTION_CLOSED = 0,\n  MHD_CONNECTION_UPGRADE = 2\n};\n\nenum {\n  MHD_EVENT_LOOP_INFO_READ = 1,\n  MHD_EVENT_LOOP_INFO_PROCESS_READ = 2,\n  MHD_EVENT_LOOP_INFO_WRITE = 3,\n  MHD_EVENT_LOOP_INFO_PROCESS = 4,\n  MHD_EVENT_LOOP_INFO_CLEANUP = 5,\n  MHD_EVENT_LOOP_INFO_PROCESS = 4,\n  MHD_EVENT_LOOP_INFO_PROCESS_READ = 2\n};\n\nconst int MHD_INVALID_SOCKET = -1;\nconst int MHD_NO = 0;\n\nstruct MHD_UpgradeResponseHandle { bool clean_ready; bool was_closed; };\n\nstruct MHD_RequestQueue {\n  bool client_aware;\n  void *client_context;\n};\n\nstruct MHD_ResponsePlaceholder { void *response; };\n\nstruct MHD_Daemon {\n  bool shutdown;\n  void *itc; /* inter-thread communication handle (opaque) */\n  void (*notify_completed)(void *, void *, void **, int);\n  void *notify_completed_cls;\n};\n\nstruct MHD_Connection {\n  void *tid;\n  int state;\n  unsigned int event_loop_info;\n  MHD_socket socket_fd;\n  bool suspended;\n  int connection_timeout_ms;\n  struct MHD_Daemon *daemon;\n  struct MHD_RequestQueue rq;\n  struct MHD_ResponsePlaceholder rp;\n  struct MHD_UpgradeResponseHandle *urh;\n  bool tls_read_ready;\n};\n\n/* Declarations of external functions used by the original function. */\nextern uint64_t connection_get_wait(struct MHD_Connection *con);\nextern int call_handlers(struct MHD_Connection *con, int r, int w, int e);\nextern void MHD_thread_handle_ID_set_current_thread_ID_(void **tidptr);\nextern int MHD_add_to_fd_set_(int fd, fd_set *set, MHD_socket *maxsock, int maxfds);\nextern int MHD_itc_r_fd_(void *itc);\nextern void MHD_itc_clear_(void *itc);\nextern int MHD_SYS_select_(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *tv);\nextern int MHD_socket_get_error_(void);\nextern int MHD_SCKT_ERR_IS_EINTR_(int err);\nextern void MHD_update_last_activity_(struct MHD_Connection *con);\nextern void MHD_connection_handle_idle(struct MHD_Connection *con);\nextern void MHD_connection_close_(struct MHD_Connection *con, int reason);\nextern void MHD_destroy_response(void *response);\nextern void MHD_resume_connection(struct MHD_Connection *con);\nextern void thread_main_connection_upgrade(struct MHD_Connection *con);\nextern int shutdown(int sockfd, int how);\nextern int MHD_itc_activate_(void *itc, const char *t);\n\n/* Simple probe logger that appends a single line to a log file. */\nstatic void probe_log(struct MHD_Connection *con, const char *tag)\n{\n  FILE *f = fopen(\"/tmp/logs/122.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s: tid=%p state=%d event_loop_info=0x%08x socket_fd=%d\\n\",\n            tag,\n            (void *) (con ? con->tid : NULL),\n            (con ? con->state : -1),\n            (unsigned int) (con ? con->event_loop_info : 0),\n            (int) (con ? con->socket_fd : -1));\n    fclose(f);\n  }\n}\n\n/* A compact translation of the original thread_main_handle_connection\n   function. It keeps the control-flow and logging points while avoiding\n   conditional compilation. The function returns a pointer as a thread\n   entry would normally do (void*). */\nstatic void *\nthread_main_handle_connection(void *data)\n{\n  struct MHD_Connection *con = (struct MHD_Connection *) data;\n  struct MHD_Daemon *daemon = con ? con->daemon : NULL;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  const bool use_poll = false; /* poll path omitted in this translation */\n  bool was_suspended = false;\n\n  MHD_thread_handle_ID_set_current_thread_ID_(&con->tid);\n\n  probe_log(con, \"ENTER thread_main_handle_connection\");\n\n  while ((daemon ? (! daemon->shutdown) : true) &&\n         (MHD_CONNECTION_CLOSED != con->state))\n  {\n    bool use_zero_timeout = false;\n    const void *const urh = NULL; /* upgrade handling omitted */\n\n    if ((con->suspended) && (NULL == urh))\n    {\n      was_suspended = true;\n      /* Wait for resume using select on the inter-thread communication fd. */\n      FD_ZERO(&rs);\n      if (! MHD_add_to_fd_set_(MHD_itc_r_fd_(daemon->itc), &rs, NULL, FD_SETSIZE))\n      {\n        goto exit;\n      }\n      if (0 > MHD_SYS_select_(MHD_itc_r_fd_(daemon->itc) + 1, &rs, NULL, NULL, NULL))\n      {\n        const int err = MHD_socket_get_error_();\n        if (MHD_SCKT_ERR_IS_EINTR_(err))\n          continue;\n        break;\n      }\n      MHD_itc_clear_(daemon->itc);\n      continue; /* Check again for resume. */\n    }\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_(con);\n      MHD_connection_handle_idle(con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout = (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info));\n\n    /* Use select path only in this simplified translation. */\n    {\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait(con);\n        tv.tv_sec = (time_t)(mseconds_left / 1000);\n        tv.tv_usec = (suseconds_t)((mseconds_left % 1000) * 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO(&rs);\n      FD_ZERO(&ws);\n      FD_ZERO(&es);\n      maxsock = MHD_INVALID_SOCKET;\n\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_(con->socket_fd, &rs, &maxsock, FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_(con->socket_fd, &ws, &maxsock, FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_(con->socket_fd, &es, &maxsock, FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        goto exit;\n      }\n\n      if (err_state)\n        goto exit;\n\n      probe_log(con, \"BEFORE select + call_handlers (select path)\");\n\n      num_ready = MHD_SYS_select_(maxsock + 1, &rs, &ws, &es, tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_();\n        if (MHD_SCKT_ERR_IS_EINTR_(err))\n          continue;\n        break;\n      }\n\n      if (MHD_NO == call_handlers(con,\n                                  FD_ISSET(con->socket_fd, &rs),\n                                  FD_ISSET(con->socket_fd, &ws),\n                                  FD_ISSET(con->socket_fd, &es)))\n      {\n        probe_log(con, \"call_handlers returned MHD_NO -> exit\");\n        goto exit;\n      }\n\n      probe_log(con, \"AFTER call_handlers (select path)\");\n    }\n\n    /* Upgrade support and poll path removed in this simplified compilation unit. */\n  }\n\n#if 0\n  /* Keep original debug-close logging branch commented out to avoid\n     reliance on logging macros not present in this translation unit. */\n#endif\n\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_(con, (daemon && daemon->shutdown) ? 1 : 2);\n  MHD_connection_handle_idle(con);\n\nexit:\n  probe_log(con, \"EXIT thread_main_handle_connection\");\n\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response(con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown(con->socket_fd, 1);\n  }\n  if ((daemon && daemon->itc) && (! MHD_itc_activate_(daemon->itc, \"t\")))\n  {\n    /* signaling failure \u2014 left silent in this translation unit */\n  }\n\n  return NULL;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The supplied thread_main_handle_connection implementation does not contain any constant-true \"if (1) { ... }\" pseudo-branch; the agent A's claim locates that construct inside call_handlers, which is not part of the provided function or translation unit. Rule 2.2 forbids executed operations whose removal would not affect program behaviour, but no such executed, redundant conditional appears in the shown thread_main_handle_connection code. The test harness the agent provided is a simplified translation that omits the body of call_handlers (and thus cannot demonstrate the alleged if(1) being executed), and the test output was not produced. Therefore there is no evidence that thread_main_handle_connection itself contains dead code violating MISRA C 2023 Rule 2.2. (If call_handlers in another translation unit actually contains an if(1) used solely for scoping, that should be inspected in its own right; removal could change variable lifetimes and implementation-defined side-effects, so a careful analysis would be needed before declaring a Rule 2.2 violation.)"
}