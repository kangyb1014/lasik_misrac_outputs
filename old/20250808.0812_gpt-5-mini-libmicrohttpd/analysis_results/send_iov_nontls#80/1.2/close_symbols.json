{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MSG_NOSIGNAL_OR_ZERO",
    "MSG_MORE",
    "_MHD_IOV_MAX",
    "struct MHD_iovec_track_ (definition)",
    "MHD_iov_size_ (typedef)",
    "pre_send_setopt (declaration/definition)",
    "post_send_setopt (declaration/definition)",
    "MHD_DLOG (definition)",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_* macros (e.g. MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_, MHD_SCKT_ERR_IS_LOW_RESOURCES_)",
    "MHD_SCKT_* error constants (e.g. MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_EBADF_)",
    "sendmsg (prototype/definition)",
    "writev (prototype/definition)",
    "WSASend (prototype/definition)",
    "DWORD, LPWSABUF, UINT32_MAX, and any WINAPI/WSAAPI calling-convention macros",
    "struct msghdr and struct iovec (definitions)"
  ],
  "explanation": "For checking the MISRA rule banning compiler/language extensions we must inspect any macros, typedefs, library declarations or data-structure definitions that could hide use of compiler-specific extensions. The listed symbols are the relevant items from the function whose definitions can contain such extensions:\n\n- mhd_assert: often a macro; its implementation may use GCC statement-expressions, typeof, __extension__, pragmas or other compiler-specific constructs. Inspecting it is required to decide if an extension is used.\n\n- MSG_NOSIGNAL_OR_ZERO and MSG_MORE: these are preprocessor macros used in the sendmsg call. Their definitions may expand to platform-specific or compiler-specific constructs (or wrap nonstandard flags). They must be checked for extensions.\n\n- _MHD_IOV_MAX: a build-time macro that may be defined using compiler-specific expressions or rely on nonstandard features; also affects control flow (changing push_data) so its definition is required.\n\n- struct MHD_iovec_track_ (definition) and MHD_iov_size_ (typedef): the function manipulates fields and does pointer arithmetic into the iovec array. The struct's definition may use flexible-array members, zero-length arrays (a GNU extension), or other nonstandard constructs; the typedef for MHD_iov_size_ could be an alias to a nonstandard integer type.\n\n- pre_send_setopt and post_send_setopt (declarations/definitions): these are called from the target function. Their prototypes/definitions may include function attributes (e.g. GCC __attribute__), calling-convention specifiers, inline/extension usages, or other nonstandard constructs that would violate the rule.\n\n- MHD_DLOG: called by post_send_setopt; its implementation often uses complex macros or attributes\u2014must inspect for extensions.\n\n- MHD_socket_get_error_ and the MHD_SCKT_ERR_IS_* macros (and MHD_SCKT_* error constants): these macros are heavily used in the error-path checks. They may be implemented as macros that use statement-expressions, typeof, or other compiler extensions. Their definitions are needed to determine whether any nonstandard macro features are present.\n\n- sendmsg and writev (prototypes/definitions): system call/library declarations sometimes include attribute annotations or calling-convention macros that are compiler-specific. Check their declarations for __attribute__ qualifiers or nonstandard linkage specifiers.\n\n- WSASend plus DWORD, LPWSABUF, UINT32_MAX and any WINAPI/WSAAPI calling-convention macros: Windows socket APIs and related typedefs/macros often expand to calling-convention qualifiers (e.g. WINAPI -> __stdcall) or other compiler-specific keywords. These are precisely the kinds of compiler extensions MISRA forbids, so their definitions must be inspected when the Windows path is enabled.\n\n- struct msghdr and struct iovec definitions: the layout or use of flexible/zero-length arrays or nonstandard attributes in these structure definitions could indicate use of extensions; inspect their definitions.\n\nIn short: any macro, typedef, function prototype or struct definition referenced by the target function that might be implemented using compiler-specific keywords, attributes or nonstandard language features must be examined. The list above is the minimal set of symbols whose definitions can hide such extensions and therefore are required for a proper MISRA language-extension analysis."
}