{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The project defines mhd_assert as ((void)0). The call mhd_assert(0 == (connection->daemon->options & MHD_USE_TLS)); is therefore an executed no-op expression statement whose presence or removal would not affect program behaviour. This qualifies as dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MHD_INVALID_SOCKET = -1;\nstatic const int MHD_CONNECTION_CLOSED = 1;\nstatic const unsigned MHD_USE_TLS = 1u;\nstatic const ssize_t MHD_ERR_NOTCONN_ = -100;\nstatic const ssize_t MHD_ERR_AGAIN_ = -101;\nstatic const ssize_t MHD_ERR_CONNRESET_ = -102;\nstatic const ssize_t MHD_ERR_PIPE_ = -103;\nstatic const ssize_t MHD_ERR_OPNOTSUPP_ = -104;\nstatic const ssize_t MHD_ERR_INVAL_ = -105;\nstatic const ssize_t MHD_ERR_NOMEM_ = -106;\nstatic const ssize_t MHD_ERR_BADF_ = -107;\nstatic inline void mhd_assert (int /*cond*/) { /* no-op for this build */ }\nstatic inline int MHD_socket_get_error_ (void) { return errno; }\nstatic inline int MHD_SCKT_ERR_IS_EAGAIN_ (int err) { return err == EAGAIN || err == EWOULDBLOCK; }\nstatic inline int MHD_SCKT_ERR_IS_EINTR_ (int err) { return err == EINTR; }\nstatic inline int MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (int /*err*/) { return 0; }\nstatic inline int MHD_SCKT_ERR_IS_ (int err, int which) { return err == which; }\nstatic inline int MHD_SCKT_ERR_IS_LOW_RESOURCES_ (int err) { return err == ENOMEM; }\nstatic const int MHD_SCKT_EPIPE_ = EPIPE;\nstatic const int MHD_SCKT_EOPNOTSUPP_ = EOPNOTSUPP;\nstatic const int MHD_SCKT_ENOTCONN_ = ENOTCONN;\nstatic const int MHD_SCKT_EINVAL_ = EINVAL;\nstatic const int MHD_SCKT_EBADF_ = EBADF;\nstatic void\nprobe_log_state (const char *stage,\n                 const struct MHD_Connection *connection,\n                 const struct MHD_iovec_track_ *r_iov,\n                 size_t items_to_send,\n                 ssize_t res)\n{\n  FILE *f = fopen(\"/tmp/logs/642.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"Stage: %s\\n\", stage);\n  if (NULL != connection)\n  {\n    fprintf (f, \"  socket_fd=%d\\n\", (int) connection->socket_fd);\n    fprintf (f, \"  state=%d\\n\", (int) connection->state);\n    if (connection->daemon)\n      fprintf (f, \"  daemon_options=0x%08x\\n\", (unsigned) connection->daemon->options);\n  }\n  if (NULL != r_iov)\n    fprintf (f, \"  iov.cnt=%zu iov.sent=%zu\\n\", r_iov->cnt, r_iov->sent);\n  fprintf (f, \"  items_to_send=%zu res=%zd\\n\", items_to_send, res);\n  fprintf (f, \"----------------------------------------\\n\");\n  fclose (f);\n}\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 int push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n\n  /* Record entry state */\n  probe_log_state (\"entry\", connection, r_iov, 0u, 0);\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n  /* Probe immediately after the assert to show it has no observable effect */\n  probe_log_state (\"after_mhd_assert\", connection, r_iov, 0u, 0);\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    probe_log_state (\"early_return_notconn\", connection, r_iov, 0u, (ssize_t) MHD_ERR_NOTCONN_);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  probe_log_state (\"after_items_to_send_calc\", connection, r_iov, items_to_send, 0);\n\n  /* Use writev as a portable vector write. */\n  pre_send_setopt (connection, 1, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent, (int) items_to_send);\n\n  probe_log_state (\"after_send\", connection, r_iov, items_to_send, res);\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((int) 0); /* placeholder */\n#endif /* EPOLL_SUPPORT */\n      probe_log_state (\"eagain\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      probe_log_state (\"eintr\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      probe_log_state (\"remote_disc\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      probe_log_state (\"epipe\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      probe_log_state (\"eopnotsupp\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      probe_log_state (\"enotconn\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      probe_log_state (\"einval\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      probe_log_state (\"low_resources\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      probe_log_state (\"ebadf\", connection, r_iov, items_to_send, res);\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    probe_log_state (\"other_error\", connection, r_iov, items_to_send, res);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, 1, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((int) 0); /* placeholder */\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  probe_log_state (\"return_success\", connection, r_iov, items_to_send, res);\n  return res;\n}\n\nstatic inline void pre_send_setopt (struct MHD_Connection *connection, int unused, int push) { (void)connection; (void)unused; (void)push; }\nstatic inline void post_send_setopt (struct MHD_Connection *connection, int unused, int push) { (void)connection; (void)unused; (void)push; }\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct for the scenario Agent A described. If mhd_assert is defined as a macro that expands to ((void)0) (i.e. the assertion and its operand are removed by the preprocessor), the statement\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\nbecomes an executed no-op expression statement whose presence or removal will not change program behaviour. Under MISRA C 2023 Rule 2.2 (\u201cA project shall not contain dead code\u201d), that is dead code and therefore a violation.\n\nCaveats/nuances:\n- If mhd_assert is an actual function (even an empty inline function) the argument expression is still evaluated at the call site. In that case the call is not a pure no-op because the read/evaluation of connection->daemon->options occurs; removal could still change timing or observable behaviour on some embedded platforms (see Note 1 of Rule 2.2). Whether that is \u201cdead code\u201d then depends on whether removal can be proven to have no effect, so the violation is not automatic in that configuration.\n- In short: given Agent A\u2019s explicit assumption that mhd_assert is ((void)0), their claim of a Rule 2.2 violation is correct. If mhd_assert is implemented differently (so the assertion\u2019s operand is evaluated), the conclusion may differ and requires further analysis."
}