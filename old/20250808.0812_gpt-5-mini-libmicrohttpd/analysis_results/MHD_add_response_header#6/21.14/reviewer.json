{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When handling the \"Connection\" header and the response already contains a Connection header, the code uses memcmp(hdr->value, \"close\", 5) to compare hdr->value (a null-terminated string) with the literal \"close\". Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_connection_state(const char *stage,\n                                      const struct MHD_Response *response,\n                                      const struct MHD_HTTP_Res_Header *hdr)\n{\n  FILE *f = fopen(\"/tmp/logs/54.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"Stage: %s\\n\", stage);\n  if (NULL != response)\n    fprintf(f, \" response->flags_auto=0x%08x, response->flags=0x%08x\\n\",\n            response->flags_auto, response->flags);\n  if (NULL != hdr)\n  {\n    fprintf(f, \" hdr present: header_size=%zu, value_size=%zu\\n\",\n            hdr->header_size, hdr->value_size);\n    /* Print up to a limited number of characters of hdr->value */\n    if (NULL != hdr->value)\n    {\n      size_t to_print = hdr->value_size;\n      if (to_print > 128u)\n        to_print = 128u;\n      fprintf(f, \" hdr->value (prefix): '%.*s'\\n\", (int) to_print, hdr->value);\n      /* Use strncmp (not memcmp) here to avoid introducing a second memcmp\n         violation in the probe itself. */\n      int cmp_first5 = 0;\n      if (hdr->value_size >= 5u)\n        cmp_first5 = strncmp(hdr->value, \"close\", 5);\n      else\n        cmp_first5 = 1; /* different if shorter */\n      fprintf(f, \" strncmp first5 vs 'close' => %d\\n\", cmp_first5);\n    }\n  }\n  else\n    fprintf(f, \" hdr not present\\n\");\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\nstatic bool charsequalcaseless (const char c1, const char c2)\n{\n  return ( (c1 == c2) ||\n           (isascii((unsigned char)c1) && isupper((unsigned char)c1) ?\n            ((char)(c1 - 'A' + 'a') == c2) :\n            (c1 == (char)(c2 - 'A' + 'a') && isascii((unsigned char)c2) && isupper((unsigned char)c2))) );\n}\n\nstruct MHD_HTTP_Res_Header * MHD_get_response_element_n_ (struct MHD_Response *response,\n                                                         enum MHD_ValueKind kind,\n                                                         const char *key,\n                                                         size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  if (NULL == response)\n    return NULL;\n  for (pos = response->first_header; NULL != pos; pos = pos->next)\n  {\n    if ((pos->header_size == key_len) && (kind == pos->kind))\n    {\n      /* Compare header name case-insensitively for key_len bytes */\n      size_t i;\n      int equal = 1;\n      for (i = 0u; i < key_len; ++i)\n      {\n        if (!charsequalcaseless(pos->header[i], key[i]))\n        {\n          equal = 0; break;\n        }\n      }\n      if (equal)\n        return pos;\n    }\n  }\n  return NULL;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, \"Connection\"))\n    return add_response_header_connection (response, content);\n\n  /* The rest of the original branches are omitted in detail for brevity but\n     would call the same helper functions in the real project. For test\n     compilation we simply fall through to a default stub. */\n\n  return add_response_header_connection(response, content);\n}\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = \"Connection\";\n  const size_t key_len = 10u; /* length of \"Connection\" */\n  size_t value_len; /* length of the @a value */\n  size_t old_value_len;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n\n  if ((NULL != strchr (value, '\\r')) || (NULL != strchr (value, '\\n')))\n    return MHD_NO;\n\n  if (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n\n    /* Probe log before the original mhd_assert that contains the memcmp */\n    probe_log_connection_state(\"before_assert\", response, hdr);\n\n    /* ORIGINAL ASSERT PRESENT IN SOURCE (kept to demonstrate the violation):\n       mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n       This is the memcmp use that violates MISRA C 2023 Rule 21.14 because it\n       compares null-terminated strings using memcmp. We keep it exactly as in\n       the original to produce the violation scenario. */\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n\n  /* Continue with a minimal preservation of the original flow. For brevity\n     we will not implement the full token-normalisation logic here; the\n     important point is that the memcmp call above is present in the same\n     control path and the probe has logged the state. */\n\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2u;\n  else\n    old_value_len = 0u;\n\n  value_len = strlen(value);\n  if (value_len >= (size_t)SSIZE_MAX)\n    return MHD_NO;\n\n  /* Minimal behaviour: if hdr exists, update its value to a copy of value; */\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr = (struct MHD_HTTP_Res_Header *)calloc(1, sizeof(*new_hdr));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = (char *)malloc(key_len + 1u);\n      if (NULL != new_hdr->header)\n      {\n        memcpy(new_hdr->header, key, key_len);\n        new_hdr->header[key_len] = '\\0';\n        new_hdr->header_size = key_len;\n        new_hdr->value = (char *)malloc(value_len + 1u);\n        if (NULL != new_hdr->value)\n        {\n          memcpy(new_hdr->value, value, value_len + 1u);\n          new_hdr->value_size = value_len;\n          new_hdr->kind = MHD_HEADER_KIND;\n          if (strcmp(value, \"close\") == 0)\n            response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE);\n          else\n            response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n          /* insert at head */\n          new_hdr->next = response->first_header;\n          response->first_header = new_hdr;\n          probe_log_connection_state(\"inserted_new_hdr\", response, new_hdr);\n          return MHD_YES;\n        }\n        free(new_hdr->header);\n      }\n      free(new_hdr);\n    }\n    return MHD_NO;\n  }\n\n  /* Update existing header entry (simplified) */\n  free (hdr->value);\n  hdr->value = (char *)malloc(value_len + 1u);\n  if (NULL == hdr->value)\n    return MHD_NO;\n  memcpy(hdr->value, value, value_len + 1u);\n  hdr->value_size = value_len;\n  if ((strcmp(value, \"close\") == 0) && !already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n\n  probe_log_connection_state(\"updated_existing_hdr\", response, hdr);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The scenario (and the provided test code) shows a memcmp(hdr->value, \"close\", 5) call where hdr->value is a null-terminated string and the second operand is the null-terminated string literal \"close\". MISRA C 2023 Rule 21.14 states that memcmp shall not be used to compare null-terminated strings; using memcmp here to test string equality therefore violates that rule. (Note: the MHD_add_response_header excerpt did not include the Connection-handler body, but the agent's scenario/test_code demonstrates the memcmp usage in the connection handling path.)"
}