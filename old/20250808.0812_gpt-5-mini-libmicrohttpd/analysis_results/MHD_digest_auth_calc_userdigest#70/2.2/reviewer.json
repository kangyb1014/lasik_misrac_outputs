{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to digest_deinit(&da) is dead code. In the provided project digest_deinit is defined as a no-op macro (#define digest_deinit(da) (void)0). The digest_deinit(&da) statement is executed but has no effect; removing it would not change program behaviour, so Rule 2.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_DigestAuthAlgo3 { MHD_ALGO3_DEFAULT = 0 };\nbool digest_init_one_time(struct DigestAlgorithm *da, int base_algo)\n{\n  if (!da)\n    return false;\n  da->algo = base_algo;\n  da->ext_error = 0;\n  return true;\n}\nint digest_ext_error(const struct DigestAlgorithm *da)\n{\n  if (!da)\n    return 1;\n  return da->ext_error;\n}\nvoid digest_deinit(struct DigestAlgorithm *da)\n{\n  (void)da; /* No-op for this minimal implementation. */\n}\n\nint get_base_digest_algo(enum MHD_DigestAuthAlgo3 algo3)\n{\n  return (int)algo3;\n}\nsize_t digest_get_size(const struct DigestAlgorithm *da)\n{\n  (void)da;\n  /* Return a fixed size; the caller compares this to the provided buffer\n     size to decide whether the operation can proceed. */\n  return 64;\n}\nvoid calc_userdigest(struct DigestAlgorithm *da,\n                     const char *username, size_t ulen,\n                     const char *realm, size_t rlen,\n                     const char *password,\n                     void *userdigest_bin)\n{\n  (void)da; (void)username; (void)ulen; (void)realm; (void)rlen; (void)password;\n  if (userdigest_bin)\n  {\n    /* Fill with a deterministic pattern to simulate a digest result. */\n    memset(userdigest_bin, 0xAA, 16);\n  }\n}\nenum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  FILE *log = fopen(\"/tmp/logs/562.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"enter: algo3=%u username=%p realm=%p password=%p bin_buf_size=%zu\\n\",\n            (unsigned) algo3, (const void *) username, (const void *) realm,\n            (const void *) password, bin_buf_size);\n    fflush(log);\n  }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (log)\n    {\n      fprintf(log, \"digest_init_one_time: FAILED\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  if (log)\n    fprintf(log, \"digest_init_one_time: OK, da.algo=%d\\n\", (int) da.algo);\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    if (log)\n    {\n      size_t ulen = username ? strlen (username) : 0;\n      size_t rlen = realm ? strlen (realm) : 0;\n      fprintf(log, \"calc_userdigest: username_len=%zu realm_len=%zu\\n\", ulen, rlen);\n      fflush(log);\n    }\n    calc_userdigest (&da,\n                     username,\n                     username ? strlen (username) : 0,\n                     realm,\n                     realm ? strlen (realm) : 0,\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n    /* Perform the extended error check as in the original code. */\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n    if (log)\n      fprintf(log, \"digest_ext_error check performed, ret=%d\\n\", (int) ret);\n  }\n\n  if (log)\n  {\n    fprintf(log, \"about to call digest_deinit(&da)\\n\");\n    fflush(log);\n  }\n  digest_deinit (&da);\n  if (log)\n  {\n    fprintf(log, \"called digest_deinit(&da) - may be a no-op; final ret=%d\\n\", (int) ret);\n    fclose(log);\n  }\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A\u2019s report is correct under the conditions they stated. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not change program behaviour. If, for the given project configuration, digest_deinit is indeed defined as a no-op macro (e.g. #define digest_deinit(da) (void)0), then the statement digest_deinit(&da); is executed but has no observable effect and could be removed without changing behaviour\u2014therefore it is dead code and violates Rule 2.2.\n\nNotes and caveats:\n- Dead-code determination is project-specific. If in some build configurations digest_deinit is a real function with side effects (or the macro expands to code that has observable effects or timing consequences), then the call would not be dead in that build and would not violate Rule 2.2 in that configuration. MISRA analysis must use the actual project (build-config) definitions.\n- The test harness failing to compile does not change the semantic conclusion: given the claimed project-wide no-op definition, the call is dead.\n\nRecommended remedies: remove the call when the deinit is a known no-op, or guard it with conditional compilation (only emit the call when a non\u2011no\u2011op deinit is present), or ensure the deinit macro produces an observable effect if it must remain in source for API symmetry."
}