{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_calc_userdigest': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userdigest'], 'callers': ['add_new_user_entry']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'get_base_digest_algo': {'callees': [], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calc_userdigest': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userdigest', 'digest_auth_check_all_inner']}, 'add_new_user_entry': {'callees': ['MHD_digest_auth_calc_userhash', 'MHD_digest_auth_calc_userdigest'], 'callers': ['add_new_users']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "calc_userdigest (declaration/definition or macro expansion)",
    "digest_init_one_time (declaration/definition or macro expansion)",
    "get_base_digest_algo (declaration/definition or macro expansion)",
    "digest_deinit (declaration/definition or macro expansion)",
    "digest_ext_error (declaration/definition or macro expansion)",
    "MHD_DIGEST_HAS_EXT_ERROR (preprocessor macro definition)",
    "struct DigestAlgorithm (type definition)",
    "strlen (declaration from <string.h> or any macro that replaces it)",
    "digest_get_size (declaration/definition or macro expansion)"
  ],
  "explanation": "For checking the MISRA rule that a function parameter shall not be modified, you must know whether any identifier used in the target function is a macro or a callee whose expansion/signature could perform assignments to the target function's parameters (e.g. algo3, username, realm, password, userdigest_bin, bin_buf_size). Brief reasons for each symbol:\n\n- calc_userdigest: The call passes userdigest_bin and the string parameters. If calc_userdigest is a macro it could expand into code that assigns to the caller's parameter identifiers (macros operate in caller scope). If it's a function, the prototype confirms the last parameter is a void* (not a void**) so the callee cannot rebind the caller's pointer parameter. You need the definition/prototype or macro expansion to decide.\n\n- digest_init_one_time: Called with &da and get_base_digest_algo(algo3). If this is a macro it might contain assignments that could target the token algo3 (or other parameter names); if a function you must check its prototype to ensure it doesn't take pointer-to-parameter that could rebind caller variables. Include its definition/prototype or macro body.\n\n- get_base_digest_algo: This is passed algo3. If it is a macro, it could perform an assignment to algo3 (thus modifying the parameter). If it's a function, its prototype shows it takes the enum by value so it cannot modify the caller's parameter. You must examine its definition or macro expansion.\n\n- digest_deinit: Called after possible modifications; if this is a macro it might reference or assign to parameter names (unlikely but possible); include to rule out macro side-effects that modify parameters.\n\n- digest_ext_error: Used in an #ifdef block; if defined as a macro it could modify parameters when expanded. If it's a function, prototype shows no way to rebind caller parameters. Include its definition/prototype and whether it is a macro.\n\n- MHD_DIGEST_HAS_EXT_ERROR: The preprocessor guard controls whether digest_ext_error is invoked. You must know whether this macro is defined to know if that potentially modifying call is present.\n\n- struct DigestAlgorithm: The local variable da is of this type and is passed by address to callees. Knowing the structure definition helps ensure no hidden macro or inline function manipulates parameter names via unusual constructs (and helps reason about what the callees could do to objects pointed at).\n\n- strlen: The code calls strlen(username) and strlen(realm). If strlen is redefined as a macro in this build, it might expand into code that assigns to username/realm. Include the declaration or any macro definition to confirm it cannot modify the parameter variables.\n\n- digest_get_size: Although it is called with &da, if digest_get_size is a macro it could expand into code that references identifiers in the caller scope and\u2014if poorly written\u2014could modify parameter names. Include its definition/prototype to verify no such side-effect.\n\nIn short: obtain the declarations/definitions or macro bodies for all callees and any macros used in the function so you can determine whether any of them (via macro expansion or function signature using pointer-to-pointer) could rebind or assign to the target function's parameters. These symbols suffice to decide whether the target function itself (including inline/macro expansions from callees) modifies any of its parameters."
}