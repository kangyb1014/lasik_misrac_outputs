{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "struct MHD_UpgradeResponseHandle",
    "MUTEX",
    "MAX_CLIENTS",
    "CLIENT_SOCKS",
    "MHD_INVALID_SOCKET",
    "make_blocking",
    "ws_receive_frame",
    "ws_send_frame",
    "MHD_upgrade_action",
    "MHD_UPGRADE_ACTION_CLOSE",
    "malloc",
    "free",
    "snprintf",
    "recv",
    "pthread_mutex_lock",
    "pthread_mutex_unlock",
    "abort"
  ],
  "explanation": "For verifying whether the function parameter (void *cls) is modified, the next analyzer needs the following symbols and why:\n\n- struct WsData: to see the layout of the object pointed to by cls (members used: urh, sock) and confirm that run_usock only reads/uses or frees the pointed object rather than assigning to the parameter itself.\n\n- struct MHD_UpgradeResponseHandle: to understand the urh type and ensure MHD_upgrade_action usage does not imply modification of the parameter variable.\n\n- MUTEX, pthread_mutex_lock, pthread_mutex_unlock: to check the mutex operations and ensure no macro or inline replacement could modify the parameter variable; also to inspect locking/unlocking semantics around CLIENT_SOCKS modification.\n\n- MAX_CLIENTS, CLIENT_SOCKS, MHD_INVALID_SOCKET: to inspect the client-socket array modification logic (CLIENT_SOCKS[i] = MHD_INVALID_SOCKET) and confirm that only the object pointed to by ws (ws->sock) is used for comparison, not the parameter variable itself.\n\n- make_blocking: to confirm its declaration/definition (or macro) does not expand to code that alters the local parameter variable cls.\n\n- ws_receive_frame: to verify its prototype/definition does not take cls or otherwise alter the caller's parameter variable (e.g., via macros or weird calling conventions).\n\n- ws_send_frame: similarly, to check it does not modify the run_usock parameter variable (or expand to code that does).\n\n- MHD_upgrade_action, MHD_UPGRADE_ACTION_CLOSE: to ensure the upgrade-close call on urh has no side-effect that would modify the local parameter variable cls.\n\n- malloc, free: to confirm the semantics of allocating and freeing ws (free(ws)) \u2014 freeing the pointed-to object is permitted by the MISRA rule (object may be modified/freed) but the analyzer must see free is the standard free and not a macro that alters the parameter variable.\n\n- snprintf: to check it is a normal library function (not a macro) and that no unexpected macro expansion modifies cls.\n\n- recv: to confirm call semantics and that it does not modify cls.\n\n- abort: to verify abort usage (no effect on parameter variable) and detect any macro redefinition.\n\nIn short, include the struct/type definitions, the global objects modified, and the prototypes/definitions of called functions (or macros) that could \u2014 if implemented as macros or unusual inlines \u2014 modify the local parameter variable. These symbols let the analyst determine whether the parameter variable 'cls' itself is ever assigned/modified (a MISRA violation) versus only the object it points to being used/modified (allowed)."
}