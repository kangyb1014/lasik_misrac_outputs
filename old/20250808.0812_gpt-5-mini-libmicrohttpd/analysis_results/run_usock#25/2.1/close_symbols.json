{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "make_blocking",
    "MHD_upgrade_action",
    "MHD_upgraded_connection_mark_app_closed_",
    "struct WsData",
    "MAX_CLIENTS",
    "CLIENT_SOCKS",
    "MHD_INVALID_SOCKET",
    "MUTEX",
    "pthread_mutex_lock",
    "pthread_mutex_unlock"
  ],
  "explanation": "WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: the compile-time values or enum definitions determine which branches in the big if/else are ever true; if these values make a branch impossible it would be statically unreachable. ws_receive_frame: it assigns/returns the 'type' and 'msg' used by branching; its possible return/type combinations are needed to know which branches can be reached. ws_send_frame: its behavior (return values, side effects, or non-return attributes) affects reachability of subsequent code (e.g. the break on sent == -1). send_all and make_blocking: send_all is called by ws_send_frame (and appears in the call graph) and make_blocking may alter control flow or have non-return behaviour; both must be inspected for non-return/always-fail semantics that could render later code unreachable. MHD_upgrade_action: if this function is annotated as non-return (noreturn) or otherwise terminates the thread/process, the final 'return NULL' or any following code could be unreachable; its internals (and its callee MHD_upgraded_connection_mark_app_closed_) are therefore required. MHD_upgraded_connection_mark_app_closed_: called by MHD_upgrade_action; its behaviour could influence whether control returns. struct WsData: layout and types (especially ws->sock and ws->urh) are needed to understand comparisons, indexing, and interactions with CLIENT_SOCKS. MAX_CLIENTS, CLIENT_SOCKS, MHD_INVALID_SOCKET: these macros/globals determine the for-loop bounds and whether the loop body can ever execute; e.g. MAX_CLIENTS <= 0 or CLIENT_SOCKS having special values can make the loop (or its body) unreachable. MUTEX, pthread_mutex_lock, pthread_mutex_unlock: the mutex object and the pthread lock/unlock functions (and their return semantics) are needed to see whether the abort() calls are reachable or whether locking can be proven to always succeed/fail, affecting reachability of abort paths."
}