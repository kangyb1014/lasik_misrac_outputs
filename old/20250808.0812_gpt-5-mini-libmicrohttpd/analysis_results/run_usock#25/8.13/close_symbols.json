{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ws_receive_frame (function prototype and documentation)",
    "ws_send_frame (function prototype and documentation)",
    "send_all (function prototype and documentation)",
    "struct WsData (type definition)",
    "MHD_UpgradeResponseHandle (type definition) and MHD_upgrade_action (prototype)",
    "recv (prototype)",
    "snprintf (prototype)"
  ],
  "explanation": "For checking the MISRA rule about const-qualified pointer types we must know which functions modify the objects pointed to (so pointers must be non-const) and which merely read them (so pointers could/should be const). Each listed symbol is required for that determination:\n\n- ws_receive_frame (function prototype and documentation): run_usock receives msg from ws_receive_frame and later frees it and never modifies its contents. We need ws_receive_frame's declared return type (unsigned char * vs const unsigned char *) and documentation whether it returns ownership of a newly-allocated, modifiable buffer or a pointer to internal/const storage. That decides whether msg should be const-qualified.\n\n- ws_send_frame (function prototype and documentation): run_usock passes text (and previously msg content) to ws_send_frame. We must know whether ws_send_frame modifies the buffer passed (in-place edits) or only reads it; its parameter const-qualification determines whether the argument in run_usock should be const.\n\n- send_all (function prototype and documentation): ws_send_frame calls send_all (per the call graph). If send_all modifies the buffer passed (or expects non-const), that propagates to ws_send_frame's signature and affects whether run_usock's pointers must be non-const.\n\n- struct WsData (type definition): run_usock casts cls to struct WsData * and accesses members (urh, sock). We need the exact member types and const qualifiers (e.g., whether urh or other members are declared const) to determine whether the pointer-to-struct and its member pointer types comply with the const rule.\n\n- MHD_UpgradeResponseHandle (type definition) and MHD_upgrade_action (prototype): run_usock calls MHD_upgrade_action(urh,...). We need MHD_upgrade_action's parameter const-qualification (does it take a const handle pointer or a non-const pointer / modify the handle?) to know whether ws->urh should be const-qualified.\n\n- recv (prototype): run_usock passes a local buffer (buf) to recv. To show that buf must be non-const (recv writes into it) we include recv's signature (void *buf) so the analyzer can confirm that this pointer must be non-const.\n\n- snprintf (prototype): run_usock calls snprintf with msg/text as arguments. Knowing snprintf's parameter expectations (format is const char *, %s expects a char * argument to a read-only string) helps determine whether passing unsigned char */char * should be treated as const in this context; it also clarifies that snprintf only reads the pointed-to data and thus those pointers could be const if other operations allow it.\n\nProviding these prototypes/definitions lets the next analyst determine for every pointer used in run_usock whether the pointed-to object is ever modified (directly or via called functions). That is the information required to decide whether pointers should or should not be const-qualified per the MISRA rule."
}