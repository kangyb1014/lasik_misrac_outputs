{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs in add_response_header_connection where memcmp is used to compare hdr->value (a null-terminated header value) with the literal \"close\" using memcmp(hdr->value, \"close\", 5). This uses memcmp to compare null-terminated string data and therefore violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Response;\nstatic const char FORM_V1[] =\n  \"<html>\\n  <body>\\n    <p>Value: %s</p>\\n  </body>\\n</html>\\n\";\nstatic const char MHD_HTTP_HEADER_CONTENT_TYPE[] = \"Content-Type\";\nstruct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback(size_t size,\n                                                   void *buffer,\n                                                   void (*free_callback)(void *));\nenum MHD_Result\nMHD_add_response_header(struct MHD_Response *response, const char *name, const char *value);\nenum MHD_Result\nMHD_queue_response(struct MHD_Connection *connection, int status_code, struct MHD_Response *response);\nvoid MHD_destroy_response(struct MHD_Response *response);\nstatic void\nlog_state(const char *tag,\n          const struct Session *session,\n          int reply_len,\n          const char *reply,\n          struct MHD_Response *response,\n          enum MHD_Result ret,\n          const char *note)\n{\n  FILE *f = fopen(\"/tmp/logs/222.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"TAG: %s\\n\", tag);\n    if (session != NULL)\n      fprintf(f, \"session->value_1: %s\\n\", session->value_1 ? session->value_1 : \"(null)\");\n    fprintf(f, \"reply_len: %d\\n\", reply_len);\n    fprintf(f, \"reply_ptr: %p\\n\", (void *) reply);\n    if (reply != NULL)\n      fprintf(f, \"reply_preview: %.64s\\n\", reply);\n    fprintf(f, \"response_ptr: %p\\n\", (void *) response);\n    fprintf(f, \"ret_value: %d\\n\", (int) ret);\n    if (note != NULL)\n      fprintf(f, \"note: %s\\n\", note);\n    fprintf(f, \"----\\n\");\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry */\n  log_state(\"enter\", session, -1, NULL, NULL, (enum MHD_Result) -1, \"entered fill_v1_form\");\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  log_state(\"after_snprintf_len\", session, reply_len, NULL, NULL, (enum MHD_Result) -1, NULL);\n  if (0 > reply_len)\n  {\n    log_state(\"error_snprintf_len_negative\", session, reply_len, NULL, NULL, MHD_NO, \"snprintf returned negative length\");\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n  {\n    log_state(\"error_malloc\", session, reply_len, NULL, NULL, MHD_NO, \"malloc failed\");\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    log_state(\"error_snprintf_write_mismatch\", session, reply_len, reply, NULL, MHD_NO, \"snprintf wrote unexpected size\");\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* Log constructed reply */\n  log_state(\"reply_constructed\", session, reply_len, reply, NULL, (enum MHD_Result) -1, NULL);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      log_state(\"warning_content_type_header_failed\", session, reply_len, reply, response, (enum MHD_Result) -1, \"content type header set failed\");\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    log_state(\"after_queue_response\", session, reply_len, reply, response, ret, NULL);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    log_state(\"error_create_response\", session, reply_len, reply, NULL, MHD_NO, \"MHD_create_response returned NULL\");\n    free (reply);\n    ret = MHD_NO;\n  }\n  log_state(\"exit\", session, reply_len, NULL, NULL, ret, NULL);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct for the provided fill_v1_form code. The source shown contains no use of memcmp (or any string comparison at all), so it cannot violate MISRA C 2023 Rule 21.14. The scenario offered by agent A points to a different routine (add_response_header_connection) where memcmp(hdr->value, \"close\", 5) might occur \u2014 that would be a potential violation if it indeed uses memcmp to compare null-terminated strings \u2014 but that function is not part of the submitted fill_v1_form code. The supplied test/logging code also contains no memcmp and failed to compile, so it does not demonstrate a violation in fill_v1_form. Therefore the report that fill_v1_form violates Rule 21.14 is incorrect."
}