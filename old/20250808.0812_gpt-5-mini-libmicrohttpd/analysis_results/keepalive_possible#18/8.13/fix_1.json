{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_Rq { int http_ver; };\nstruct MHD_Rp { struct MHD_Response *response; };\nconst char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nconst unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x1u;\nconst unsigned int MHD_RAF_HAS_CONNECTION_CLOSE = 0x2u;\nconst unsigned int MHD_RF_HTTP_1_0_SERVER = 0x4u;\nconst int MHD_HTTP_VER_1_0 = 10;\nextern void mhd_assert (int expr);\nextern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n                                         const char *header,\n                                         const char *token);\nextern int MHD_IS_HTTP_VER_SUPPORTED (int http_ver);\nextern int MHD_IS_HTTP_VER_1_1_COMPAT (int http_ver);\nstatic void log_state (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  log_state (\"enter: connection=%p keepalive=%d read_closed=%d discard_request=%d stop_with_error=%d rq.http_ver=%d rp.response=%p\",\n             (void *)connection,\n             c->keepalive,\n             c->read_closed,\n             c->discard_request,\n             c->stop_with_error,\n             c->rq.http_ver,\n             (void *)c->rp.response);\n\n  mhd_assert (NULL != r);\n  log_state (\"response: %p upgrade_handler=%p flags_auto=0x%X flags=0x%X\",\n             (void *)r,\n             r->upgrade_handler,\n             r->flags_auto,\n             r->flags);\n\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (keepalive enforcement)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    log_state (\"decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (read_closed || discard_request)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP 1.0 compatible strict)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (flags_auto has connection: 0x%X)\", r->flags_auto);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP version not supported: %d)\", c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (Connection: close header present)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.0 + Keep-Alive header)\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP/1.0 without Keep-Alive)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.1 compatible)\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  log_state (\"decision: MHD_CONN_MUST_CLOSE (default)\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from internal.h:34,\n                 from connection.c:36:\n../../src/include/microhttpd.h:584:38: error: expected identifier or '(' before string constant\n  584 | #define MHD_HTTP_HEADER_CONNECTION   \"Connection\"\n      |                                      ^~~~~~~~~~~~\nconnection.c:1700:12: note: in expansion of macro 'MHD_HTTP_HEADER_CONNECTION'\n 1700 | const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1701:20: error: 'MHD_RF_HTTP_1_0_COMPATIBLE_STRICT' redeclared as different kind of symbol\n 1701 | const unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x1u;\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from connection.c:36:\n../../src/include/microhttpd.h:3827:3: note: previous definition of 'MHD_RF_HTTP_1_0_COMPATIBLE_STRICT' with type 'enum MHD_ResponseFlags'\n 3827 |   MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 1 << 0,\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1702:20: error: 'MHD_RAF_HAS_CONNECTION_CLOSE' redeclared as different kind of symbol\n 1702 | const unsigned int MHD_RAF_HAS_CONNECTION_CLOSE = 0x2u;\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from connection.c:36:\ninternal.h:408:3: note: previous definition of 'MHD_RAF_HAS_CONNECTION_CLOSE' with type 'enum MHD_ResponseAutoFlags'\n  408 |   MHD_RAF_HAS_CONNECTION_CLOSE = 1 << 1,  /**< Has \"Connection: close\" */\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1703:20: error: 'MHD_RF_HTTP_1_0_SERVER' redeclared as different kind of symbol\n 1703 | const unsigned int MHD_RF_HTTP_1_0_SERVER = 0x4u;\n      |                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from connection.c:36:\n../../src/include/microhttpd.h:3848:3: note: previous definition of 'MHD_RF_HTTP_1_0_SERVER' with type 'enum MHD_ResponseFlags'\n 3848 |   MHD_RF_HTTP_1_0_SERVER = 1 << 1,\n      |   ^~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1704:11: error: 'MHD_HTTP_VER_1_0' redeclared as different kind of symbol\n 1704 | const int MHD_HTTP_VER_1_0 = 10;\n      |           ^~~~~~~~~~~~~~~~\nIn file included from connection.c:36:\ninternal.h:860:3: note: previous definition of 'MHD_HTTP_VER_1_0' with type 'enum MHD_HTTP_Version'\n  860 |   MHD_HTTP_VER_1_0 = 2,\n      |   ^~~~~~~~~~~~~~~~\nIn file included from internal.h:35,\n                 from connection.c:36:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\nconnection.c:1705:13: note: in expansion of macro 'mhd_assert'\n 1705 | extern void mhd_assert (int expr);\n      |             ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nconnection.c:1705:13: note: in expansion of macro 'mhd_assert'\n 1705 | extern void mhd_assert (int expr);\n      |             ^~~~~~~~~~\nconnection.c:1169:31: error: expected declaration specifiers or '...' before '(' token\n 1169 |   MHD_lookup_header_token_ci ((c),(h),MHD_STATICSTR_LEN_ (h), \\\n      |                               ^\nconnection.c:1706:12: note: in expansion of macro 'MHD_lookup_header_s_token_ci'\n 1706 | extern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1169:35: error: expected declaration specifiers or '...' before '(' token\n 1169 |   MHD_lookup_header_token_ci ((c),(h),MHD_STATICSTR_LEN_ (h), \\\n      |                                   ^\nconnection.c:1706:12: note: in expansion of macro 'MHD_lookup_header_s_token_ci'\n 1706 | extern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:65,\n                 from connection.c:36:\nmhd_str_types.h:33:35: error: expected declaration specifiers or '...' before '(' token\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                   ^\nconnection.c:1169:39: note: in expansion of macro 'MHD_STATICSTR_LEN_'\n 1169 |   MHD_lookup_header_token_ci ((c),(h),MHD_STATICSTR_LEN_ (h), \\\n      |                                       ^~~~~~~~~~~~~~~~~~\nconnection.c:1706:12: note: in expansion of macro 'MHD_lookup_header_s_token_ci'\n 1706 | extern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconnection.c:1170:31: error: expected declaration specifiers or '...' before '(' token\n 1170 |                               (tkn),MHD_STATICSTR_LEN_ (tkn))\n      |                               ^\nconnection.c:1706:12: note: in expansion of macro 'MHD_lookup_header_s_token_ci'\n 1706 | extern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:65,\n                 from connection.c:36:\nmhd_str_types.h:33:35: error: expected declaration specifiers or '...' before '(' token\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                   ^\nconnection.c:1170:37: note: in expansion of macro 'MHD_STATICSTR_LEN_'\n 1170 |                               (tkn),MHD_STATICSTR_LEN_ (tkn))\n      |                                     ^~~~~~~~~~~~~~~~~~\nconnection.c:1706:12: note: in expansion of macro 'MHD_lookup_header_s_token_ci'\n 1706 | extern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from connection.c:36:\ninternal.h:881:58: error: expected ')' before '<=' token\n  881 | #define MHD_IS_HTTP_VER_SUPPORTED(ver) (MHD_HTTP_VER_1_0 <= (ver) && \\\n      |                                                          ^~\nconnection.c:1709:12: note: in expansion of macro 'MHD_IS_HTTP_VER_SUPPORTED'\n 1709 | extern int MHD_IS_HTTP_VER_SUPPORTED (int http_ver);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\ninternal.h:890:59: error: expected ')' before '==' token\n  890 | #define MHD_IS_HTTP_VER_1_1_COMPAT(ver) (MHD_HTTP_VER_1_1 == (ver) || \\\n      |                                                           ^~\nconnection.c:1710:12: note: in expansion of macro 'MHD_IS_HTTP_VER_1_1_COMPAT'\n 1710 | extern int MHD_IS_HTTP_VER_1_1_COMPAT (int http_ver);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\nmake[3]: *** [Makefile:2098: libmicrohttpd_la-connection.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of keepalive_possible as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n\nstruct MHD_Rq { int http_ver; };\nstruct MHD_Response {\n  void *upgrade_handler;\n  unsigned int flags_auto;\n  unsigned int flags;\n};\nstruct MHD_Rp { struct MHD_Response *response; };\n\nconst char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nconst unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x1u;\nconst unsigned int MHD_RAF_HAS_CONNECTION_CLOSE = 0x2u;\nconst unsigned int MHD_RF_HTTP_1_0_SERVER = 0x4u;\nconst int MHD_HTTP_VER_1_0 = 10;\n\nenum MHD_ConnKeepAlive { MHD_CONN_MUST_CLOSE = 0, MHD_CONN_USE_KEEPALIVE = 1, MHD_CONN_MUST_UPGRADE = 2 };\n\nstruct MHD_Connection {\n  struct MHD_Rp rp;\n  struct MHD_Rq rq;\n  enum MHD_ConnKeepAlive keepalive;\n  int read_closed;\n  int discard_request;\n  int stop_with_error;\n};\n\nextern void mhd_assert (int expr);\nextern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n                                         const char *header,\n                                         const char *token);\nextern int MHD_IS_HTTP_VER_SUPPORTED (int http_ver);\nextern int MHD_IS_HTTP_VER_1_1_COMPAT (int http_ver);\n\nstatic void log_state (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  log_state (\"enter: connection=%p keepalive=%d read_closed=%d discard_request=%d stop_with_error=%d rq.http_ver=%d rp.response=%p\",\n             (void *)connection,\n             c->keepalive,\n             c->read_closed,\n             c->discard_request,\n             c->stop_with_error,\n             c->rq.http_ver,\n             (void *)c->rp.response);\n\n  mhd_assert (NULL != r);\n  log_state (\"response: %p upgrade_handler=%p flags_auto=0x%X flags=0x%X\",\n             (void *)r,\n             r->upgrade_handler,\n             r->flags_auto,\n             r->flags);\n\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (keepalive enforcement)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    log_state (\"decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (read_closed || discard_request)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP 1.0 compatible strict)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (flags_auto has connection: 0x%X)\", r->flags_auto);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP version not supported: %d)\", c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (Connection: close header present)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.0 + Keep-Alive header)\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP/1.0 without Keep-Alive)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.1 compatible)\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  log_state (\"decision: MHD_CONN_MUST_CLOSE (default)\");\n  return MHD_CONN_MUST_CLOSE;\n}\n",
  "explanation": "I made this a self-contained translation unit that does not rely on external headers which previously defined conflicting macros/enums. I declared minimal struct and enum types (MHD_Connection, MHD_Response, MHD_Rp, MHD_Rq, enum MHD_ConnKeepAlive) and the needed constants as const variables. Functions such as mhd_assert and the lookup/version checks are left as extern declarations (no mock implementations), preserving the original logic of keepalive_possible. I included stdio.h and stdarg.h for log_state. No macros were defined and the original function logic was kept intact."
}