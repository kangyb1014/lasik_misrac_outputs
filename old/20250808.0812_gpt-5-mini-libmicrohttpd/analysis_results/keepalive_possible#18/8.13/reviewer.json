{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'connection' is declared as a pointer to a non-const struct MHD_Connection even though keepalive_possible only reads the object pointed to and does not modify it. According to MISRA C:2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. The function therefore violates Rule 8.13 because 'connection' could be 'const struct MHD_Connection *' (no in-function writes are performed).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Rq { int http_ver; };\nstruct MHD_Rp { struct MHD_Response *response; };\nconst char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nconst unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x1u;\nconst unsigned int MHD_RAF_HAS_CONNECTION_CLOSE = 0x2u;\nconst unsigned int MHD_RF_HTTP_1_0_SERVER = 0x4u;\nconst int MHD_HTTP_VER_1_0 = 10;\nextern void mhd_assert (int expr);\nextern int MHD_lookup_header_s_token_ci (struct MHD_Connection *connection,\n                                         const char *header,\n                                         const char *token);\nextern int MHD_IS_HTTP_VER_SUPPORTED (int http_ver);\nextern int MHD_IS_HTTP_VER_1_1_COMPAT (int http_ver);\nstatic void log_state (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  log_state (\"enter: connection=%p keepalive=%d read_closed=%d discard_request=%d stop_with_error=%d rq.http_ver=%d rp.response=%p\",\n             (void *)connection,\n             c->keepalive,\n             c->read_closed,\n             c->discard_request,\n             c->stop_with_error,\n             c->rq.http_ver,\n             (void *)c->rp.response);\n\n  mhd_assert (NULL != r);\n  log_state (\"response: %p upgrade_handler=%p flags_auto=0x%X flags=0x%X\",\n             (void *)r,\n             r->upgrade_handler,\n             r->flags_auto,\n             r->flags);\n\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (keepalive enforcement)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    log_state (\"decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (read_closed || discard_request)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP 1.0 compatible strict)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (flags_auto has connection: 0x%X)\", r->flags_auto);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP version not supported: %d)\", c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (Connection: close header present)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.0 + Keep-Alive header)\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    log_state (\"decision: MHD_CONN_MUST_CLOSE (HTTP/1.0 without Keep-Alive)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    log_state (\"decision: MHD_CONN_USE_KEEPALIVE (HTTP/1.1 compatible)\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  log_state (\"decision: MHD_CONN_MUST_CLOSE (default)\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim is not correct. While keepalive_possible only reads the connection and response objects inside the function, you cannot unconditionally change the parameter to a pointer-to-const if the pointer is subsequently used where a non-const pointer is required. In this function the connection (alias c) is passed to MHD_lookup_header_s_token_ci which is declared to take a struct MHD_Connection * (non-const) in the provided test scaffolding (and is likely so in the real code because the lookup helper may modify internal state). That prevents changing the parameter type to const without cascaded API changes or casts. Also note that the local declaration struct MHD_Connection *const c makes the pointer itself const (you cannot reseat c), it does not make the pointed-to object const \u2014 which is what Rule 8.13 concerns. The test code failed to compile because the test scaffolding did not provide compatible/complete definitions for the connection/response types and their usage, so its failure does not demonstrate a Rule 8.13 violation. Therefore the report is incorrect."
}