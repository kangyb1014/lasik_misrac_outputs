{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}, 'SHA1Reset': {'callees': [], 'callers': ['ws_get_accept_value']}, 'SHA1Input': {'callees': ['SHA1ProcessMessageBlock'], 'callers': ['ws_get_accept_value']}, 'SHA1Result': {'callees': ['SHA1PadMessage'], 'callers': ['ws_get_accept_value']}, 'BASE64Encode': {'callees': [], 'callers': ['ws_get_accept_value']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ssize_t",
    "SHA1HashSize",
    "WS_KEY_LEN",
    "WS_GUID_LEN",
    "WS_GUID",
    "WS_KEY_GUID_LEN",
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "malloc",
    "free",
    "strlen",
    "strncpy",
    "NULL",
    "BASE64Encode (prototype)"
  ],
  "explanation": "For checking whether the target function relies on any compiler language extensions you must know which identifiers are ordinary standard/C-library constructs and which might be non\u2011standard or defined via extensions. Each listed symbol is required for that determination:\n\n- ssize_t: Not a standard C type (it's POSIX). Need its typedef/definition to see whether the code depends on a nonstandard type (an extension).\n- SHA1HashSize: Used as the size of a fixed array (unsigned char hash[SHA1HashSize]). You must know whether this is a compile\u2011time constant (macro/enum) or a variable; if it is not a constant this would be a variable\u2011length array (VLA) which may be a language extension depending on targeted C standard.\n- WS_KEY_LEN: Used in comparisons, buffer sizing, strncpy; must know whether it is a compile\u2011time constant or computed/extern symbol (affects VLA/constantness and potential extension usage).\n- WS_GUID_LEN: Used in malloc and strncpy lengths; same reason as WS_KEY_LEN (need to determine if a constant or extension/variable).\n- WS_GUID: Used as a string concatenated via strncpy; need its declaration to check whether any nonstandard string literal extension or special attributes are used.\n- WS_KEY_GUID_LEN: Passed to SHA1Input as the message length; need to know its definition/constness to ensure no VLA/extension assumptions.\n- enum MHD_Result: The function returns this type. The enum definition must be checked to ensure no compiler-specific enum extensions (underlying type attributes, unusual storage specifiers) are used.\n- MHD_YES / MHD_NO: Enumerators/values returned by the function. Their definitions must be confirmed to be standard enum constants (not compiler-specific macros or attributes).\n- malloc: Allocation function prototype is needed to confirm standard signature is used and to detect any nonstandard attribute/extension (e.g., nonstandard allocator macros).\n- free: As above for deallocation.\n- strlen: Standard library function; prototype presence verifies standard usage (or reveals replacement/extension if nonstandard declaration used).\n- strncpy: Same as strlen \u2014 ensure standard behavior and that no nonstandard overloaded/attribute version is used.\n- NULL: Macro used for pointer checks; must confirm it is the standard NULL definition and not a compiler extension.\n- BASE64Encode (prototype): Although BASE64Encode appears in the call graph, its prototype (return type and parameter types) is required to verify that ssize_t is indeed used as its return type/argument types and to confirm no compiler-specific attributes or unusual calling conventions are present.\n\nWith these symbol definitions/prototypes you can determine whether the function relies on nonstandard types, VLAs, or any compiler\u2011specific attributes/extensions, and thus whether it violates the MISRA rule forbidding language extensions."
}