{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_sec_counter_init': {'callees': [], 'callers': ['MHD_init']}, 'MHD_init': {'callees': ['MHD_set_panic_func', 'MHD_monotonic_sec_counter_init', 'MHD_send_init_static_vars_', 'MHD_init_mem_pools_'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "clock_gettime",
    "host_get_clock_service",
    "mach_host_self",
    "clock_get_time",
    "mach_port_deallocate",
    "mach_task_self",
    "GetTickCount64",
    "QueryPerformanceFrequency",
    "QueryPerformanceCounter",
    "gethrtime",
    "timespec_get",
    "gettimeofday",
    "time",
    "mono_clock_id",
    "mono_clock_start",
    "mono_clock_service",
    "tick_start",
    "perf_freq",
    "perf_start",
    "hrtime_start",
    "gettime_start",
    "sys_clock_start",
    "enum _MHD_mono_clock_source",
    "_MHD_CLOCK_NO_SOURCE",
    "_MHD_UNWANTED_CLOCK",
    "_MHD_INVALID_CLOCK_SERV",
    "_MHD_CLOCK_GETTIME",
    "_MHD_CLOCK_GET_TIME",
    "_MHD_CLOCK_GETTICKCOUNT64",
    "_MHD_CLOCK_PERFCOUNTER",
    "_MHD_CLOCK_GETHRTIME",
    "mach_timespec_t",
    "struct timespec",
    "struct timeval",
    "LARGE_INTEGER",
    "uint64_t",
    "KERN_SUCCESS",
    "SYSTEM_CLOCK",
    "TIME_UTC",
    "memcpy",
    "memmove",
    "memset",
    "memcmp",
    "strcpy",
    "strncpy",
    "strcat",
    "strncat",
    "strlen",
    "strspn"
  ],
  "explanation": "For a MISRA C check focused on use of <string.h> functions (avoid out\u2011of\u2011bounds accesses), the next analyzer needs: \n\n- The standard string functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn): to confirm whether any of these are called (directly or via macros/inline wrappers) in this function or in any symbol it writes to. If none are present, the rule cannot be violated here by direct use. \n\n- All external functions called or potentially selected by preprocessor conditionals (clock_gettime, host_get_clock_service, mach_host_self, clock_get_time, mach_port_deallocate, mach_task_self, GetTickCount64, QueryPerformanceFrequency, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time): to verify they do not expand (via macros or inline wrappers) into or call string.h functions that could produce out\u2011of\u2011bounds memory accesses visible in this translation unit. Also to check their prototypes (argument/return types) for pointer/size use that might interact with string functions.\n\n- All global variables written or tested by the function (mono_clock_id, mono_clock_start, mono_clock_service, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start): to verify their types and memory layouts (e.g. whether any are arrays or structures that could be subject to string operations elsewhere) and ensure the assignments here do not rely on hidden buffer writes.\n\n- The enum and constants controlling flow and assignments (enum _MHD_mono_clock_source and the _MHD_* constants): to understand reachable branches (which code executes) and whether any conditional compilation / assignments could enable code paths that use string functions.\n\n- All relevant types and platform constants used in the function (mach_timespec_t, struct timespec, struct timeval, LARGE_INTEGER, uint64_t, KERN_SUCCESS, SYSTEM_CLOCK, TIME_UTC): to validate that assignments (e.g. ts.tv_sec, cur_time.tv_sec, freq/perf counter members) are type-correct and do not imply hidden buffer/pointer operations involving string functions.\n\nRationale: MISRA rule in question concerns use of string.h functions causing out\u2011of\u2011bounds accesses. This function contains no obvious string calls, but preprocessor configuration, macro wrappers, inline functions, or external symbols could hide such calls. The listed symbols are exactly those that determine control flow, data targets, and external calls in this function; inspecting them is sufficient to conclude whether any string.h function is invoked here or whether any writes performed could be tied to string operations that might violate the rule."
}