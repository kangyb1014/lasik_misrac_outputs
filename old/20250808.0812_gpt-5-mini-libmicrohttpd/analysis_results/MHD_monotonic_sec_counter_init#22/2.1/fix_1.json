{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void log_msg(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/177.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    /* This branch is intentionally never taken in normal builds. */\n    /* We keep a log call here to make the absence of this log entry a clear\n       indication (in /tmp/logs/177.txt) that this code is unreachable. */\n    log_msg(\"ENTER: unreachable if(0) branch\");\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_COARSE id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_FAST id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_RAW_APPROX id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_RAW id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_BOOTTIME id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_UPTIME id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n    log_msg(\"TAKEN: HAVE_CLOCK_GET_TIME start=%ld source=%d\",\n            (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n    log_msg(\"TAKEN: Windows GetTickCount64 tick_start=%llu source=%d\",\n            (unsigned long long)tick_start, (int)mono_clock_source);\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n    log_msg(\"TAKEN: Windows QPC perf_freq=%llu perf_start=%llu source=%d\",\n            (unsigned long long)perf_freq, (unsigned long long)perf_start,\n            (int)mono_clock_source);\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_HIGHRES id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n    log_msg(\"TAKEN: gethrtime hrtime_start=%llu source=%d\",\n            (unsigned long long)hrtime_start, (int)mono_clock_source);\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    log_msg(\"TAKEN: fallback NO_SOURCE source=%d\", (int)mono_clock_source);\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    log_msg(\"CLEANUP: deallocated mono_clock_service after failure\");\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n    {\n      gettime_start = tsg.tv_sec;\n      log_msg(\"TAKEN: timespec_get gettime_start=%ld\", (long)gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      log_msg(\"TAKEN: timespec_get failed, gettime_start=0\");\n    }\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n    {\n      gettime_start = tv.tv_sec;\n      log_msg(\"TAKEN: gettimeofday gettime_start=%ld\", (long)gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      log_msg(\"TAKEN: gettimeofday failed, gettime_start=0\");\n    }\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n  log_msg(\"EXIT: sys_clock_start=%ld mono_clock_start=%ld mono_clock_source=%d\",\n          (long)sys_clock_start, (long)mono_clock_start, (int)mono_clock_source);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp0e32vi0o/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_monotonic_sec_counter_init as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed test code: added necessary includes and declarations so the file compiles\n * without changing the original logic guarded by conditional compilation. */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <time.h>\n\n/* Minimal declarations to satisfy references in the function when\n * the various HAVE_* macros are not defined (so most platform-specific\n * branches are skipped). We keep the original logic intact and avoid\n * changing any of the conditional compilation. */\n\nenum _MHD_mono_clock_source {\n    _MHD_CLOCK_NO_SOURCE = 0,\n    _MHD_CLOCK_GETTIME = 1,\n    _MHD_CLOCK_GET_TIME = 2,\n    _MHD_CLOCK_GETTICKCOUNT64 = 3,\n    _MHD_CLOCK_PERFCOUNTER = 4,\n    _MHD_CLOCK_GETHRTIME = 5\n};\n\n/* Global variables referenced by the function. Types chosen to match\n * typical uses in original code. They are initialized to safe defaults. */\nstatic enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\nstatic time_t mono_clock_start = 0;\nstatic uint64_t hrtime_start = 0;\nstatic uint64_t tick_start = 0;\nstatic uint64_t perf_freq = 0;\nstatic uint64_t perf_start = 0;\nstatic time_t gettime_start = 0;\nstatic time_t sys_clock_start = 0;\n/* mono_clock_service and mono_clock_id are only used in branches\n * guarded by HAVE_CLOCK_GET_TIME / HAVE_CLOCK_GETTIME; declare them\n * to avoid potential compiler warnings in some configurations. */\nstatic int mono_clock_service = -1;\nstatic int mono_clock_id = -1;\n\nstatic void log_msg(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/177.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    /* This branch is intentionally never taken in normal builds. */\n    /* We keep a log call here to make the absence of this log entry a clear\n       indication (in /tmp/logs/177.txt) that this code is unreachable. */\n    log_msg(\"ENTER: unreachable if(0) branch\");\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_COARSE id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_FAST id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_RAW_APPROX id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC_RAW id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_BOOTTIME id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_MONOTONIC id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_UPTIME id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n    log_msg(\"TAKEN: HAVE_CLOCK_GET_TIME start=%ld source=%d\",\n            (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n    log_msg(\"TAKEN: Windows GetTickCount64 tick_start=%llu source=%d\",\n            (unsigned long long)tick_start, (int)mono_clock_source);\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n    log_msg(\"TAKEN: Windows QPC perf_freq=%llu perf_start=%llu source=%d\",\n            (unsigned long long)perf_freq, (unsigned long long)perf_start,\n            (int)mono_clock_source);\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    log_msg(\"TAKEN: CLOCK_HIGHRES id=%d start=%ld source=%d\",\n            (int)mono_clock_id, (long)mono_clock_start, (int)mono_clock_source);\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n    log_msg(\"TAKEN: gethrtime hrtime_start=%llu source=%d\",\n            (unsigned long long)hrtime_start, (int)mono_clock_source);\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    log_msg(\"TAKEN: fallback NO_SOURCE source=%d\", (int)mono_clock_source);\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    log_msg(\"CLEANUP: deallocated mono_clock_service after failure\");\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n    {\n      gettime_start = tsg.tv_sec;\n      log_msg(\"TAKEN: timespec_get gettime_start=%ld\", (long)gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      log_msg(\"TAKEN: timespec_get failed, gettime_start=0\");\n    }\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n    {\n      gettime_start = tv.tv_sec;\n      log_msg(\"TAKEN: gettimeofday gettime_start=%ld\", (long)gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      log_msg(\"TAKEN: gettimeofday failed, gettime_start=0\");\n    }\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n  log_msg(\"EXIT: sys_clock_start=%ld mono_clock_start=%ld mono_clock_source=%d\",\n          (long)sys_clock_start, (long)mono_clock_start, (int)mono_clock_source);\n}\n",
  "explanation": "I made the code self-contained by adding the required standard headers and declaring minimal global variables and an enum that the function expects. This allows the original MHD_monotonic_sec_counter_init implementation to remain unchanged and preserves its conditional compilation behavior: platform-specific branches are still controlled by the original #ifdefs and will be compiled only when the respective macros are defined. No macros were added, no main function or mock functions were introduced."
}