{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function uses memcmp to compare the nul-terminated username and password buffers returned by MHD_basic_auth_get_username_password3 against string literals (\"root\" and \"pa$$w0rd\"). The MHD_basic_auth_get_username_password3 function explicitly NUL-terminates the decoded username/password, so memcmp is being used to compare null-terminated strings, which violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstruct MHD_BasicAuthInfo {\n  const char *username;\n  size_t username_len;\n  const char *password; /* may be NULL */\n  size_t password_len;\n};\nstruct MHD_BasicAuthInfo *MHD_basic_auth_get_username_password3(struct MHD_Connection *);\nstruct MHD_Response *MHD_create_response_from_buffer_static(size_t, const char *);\nenum MHD_Result MHD_queue_basic_auth_required_response3(struct MHD_Connection *, const char *, int, struct MHD_Response *);\nenum MHD_Result MHD_queue_response(struct MHD_Connection *, int, struct MHD_Response *);\nvoid MHD_free(void *);\nvoid MHD_destroy_response(struct MHD_Response *);\nstatic void log_to_file(const char *msg)\n{\n  FILE *fp = fopen(\"/tmp/logs/614.txt\", \"a\");\n  if (fp != NULL)\n  {\n    fprintf(fp, \"%s\\n\", msg);\n    fclose(fp);\n  }\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info = NULL;\n  enum MHD_Result ret = MHD_NO;\n  struct MHD_Response *response = NULL;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and method */\n  log_to_file(\"answer_to_connection: entered\");\n  if (method != NULL)\n  {\n    char buf[128];\n    /* safe formatting for log */\n    (void) snprintf(buf, sizeof(buf), \"method=%s\", method);\n    log_to_file(buf);\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    log_to_file(\"answer_to_connection: method != GET -> MHD_NO\");\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    log_to_file(\"answer_to_connection: first request, storing req_cls\");\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    log_to_file(\"answer_to_connection: auth_info == NULL (no auth provided)\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    /* Log the exact state that leads to rejection for the violation scenario */\n    {\n      char buf[256];\n      (void) snprintf(buf, sizeof(buf),\n                      \"answer_to_connection: auth provided: username_len=%zu, password_len=%zu\",\n                      auth_info->username_len, auth_info->password_len);\n      log_to_file(buf);\n      if (auth_info->username != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"username='%s'\", auth_info->username);\n        log_to_file(buf);\n      }\n      if (auth_info->password != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"password='%s'\", auth_info->password);\n        log_to_file(buf);\n      }\n      /* Log results of the comparisons used in the condition */\n      {\n        int cmp_user = memcmp(auth_info->username, \"root\",\n                              auth_info->username_len);\n        int cmp_pass = (auth_info->password != NULL) ?\n                       memcmp(auth_info->password, \"pa$$w0rd\",\n                              auth_info->password_len) : 1;\n        (void) snprintf(buf, sizeof(buf), \"strcmp_len_root=%zu vs username_len=%zu, memcmp_user=%d, memcmp_pass=%d\",\n                        strlen(\"root\"), auth_info->username_len, cmp_user, cmp_pass);\n        log_to_file(buf);\n      }\n    }\n\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    log_to_file(\"answer_to_connection: auth succeeded\");\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  if (NULL != response)\n    MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings. In the code memcmp(auth_info->username, \"root\", auth_info->username_len) and memcmp(auth_info->password, \"pa$$w0rd\", auth_info->password_len) are used where both operands are C strings (the library call documents that the decoded username/password are NUL\u2011terminated). Even though the code first checks the lengths and only compares the exact character bytes (excluding the terminating NUL), it is still using memcmp to compare null\u2011terminated strings, so the report is valid. (If the library did not NUL\u2011terminate the buffers, memcmp could be appropriate; given the stated behavior, this is a violation.)"
}