{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void log_to_file(const char *msg)\n{\n  FILE *fp = fopen(\"/tmp/logs/614.txt\", \"a\");\n  if (fp != NULL)\n  {\n    fprintf(fp, \"%s\\n\", msg);\n    fclose(fp);\n  }\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and method */\n  log_to_file(\"answer_to_connection: entered\");\n  if (method != NULL)\n  {\n    char buf[128];\n    /* safe formatting for log */\n    (void) snprintf(buf, sizeof(buf), \"method=%s\", method);\n    log_to_file(buf);\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    log_to_file(\"answer_to_connection: method != GET -> MHD_NO\");\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    log_to_file(\"answer_to_connection: first request, storing req_cls\");\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    log_to_file(\"answer_to_connection: auth_info == NULL (no auth provided)\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    /* Log the exact state that leads to rejection for the violation scenario */\n    {\n      char buf[256];\n      (void) snprintf(buf, sizeof(buf),\n                      \"answer_to_connection: auth provided: username_len=%zu, password_len=%zu\",\n                      auth_info->username_len, auth_info->password_len);\n      log_to_file(buf);\n      if (auth_info->username != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"username='%s'\", auth_info->username);\n        log_to_file(buf);\n      }\n      if (auth_info->password != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"password='%s'\", auth_info->password);\n        log_to_file(buf);\n      }\n      /* Log results of the comparisons used in the condition */\n      {\n        int cmp_user = memcmp(auth_info->username, \"root\",\n                              auth_info->username_len);\n        int cmp_pass = (auth_info->password != NULL) ?\n                       memcmp(auth_info->password, \"pa$$w0rd\",\n                              auth_info->password_len) : 1;\n        (void) snprintf(buf, sizeof(buf), \"strcmp_len_root=%zu vs username_len=%zu, memcmp_user=%d, memcmp_pass=%d\",\n                        strlen(\"root\"), auth_info->username_len, cmp_user, cmp_pass);\n        log_to_file(buf);\n      }\n    }\n\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    log_to_file(\"answer_to_connection: auth succeeded\");\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp6m68ms_m/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of answer_to_connection as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Minimal declarations so this translation unit compiles on its own.\n   These are NOT implementations or mocks, only type and function\n   declarations to satisfy the compiler. */\n\n/* Result type used by libmicrohttpd-like API */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nstruct MHD_Connection;   /* opaque */\nstruct MHD_Response;     /* opaque */\n\nstruct MHD_BasicAuthInfo {\n  const char *username;\n  size_t username_len;\n  const char *password; /* may be NULL */\n  size_t password_len;\n};\n\n/* Function prototypes (no definitions here). These are declared so the\n   file compiles; actual implementations are expected to be linked in by\n   the full program/build that uses libmicrohttpd. */\nstruct MHD_BasicAuthInfo *MHD_basic_auth_get_username_password3(struct MHD_Connection *);\nstruct MHD_Response *MHD_create_response_from_buffer_static(size_t, const char *);\nenum MHD_Result MHD_queue_basic_auth_required_response3(struct MHD_Connection *, const char *, int, struct MHD_Response *);\nenum MHD_Result MHD_queue_response(struct MHD_Connection *, int, struct MHD_Response *);\nvoid MHD_free(void *);\nvoid MHD_destroy_response(struct MHD_Response *);\n\n/* HTTP status code constant */\nenum { MHD_HTTP_OK = 200 };\n\nstatic void log_to_file(const char *msg)\n{\n  FILE *fp = fopen(\"/tmp/logs/614.txt\", \"a\");\n  if (fp != NULL)\n  {\n    fprintf(fp, \"%s\\n\", msg);\n    fclose(fp);\n  }\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info = NULL;\n  enum MHD_Result ret = MHD_NO;\n  struct MHD_Response *response = NULL;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and method */\n  log_to_file(\"answer_to_connection: entered\");\n  if (method != NULL)\n  {\n    char buf[128];\n    /* safe formatting for log */\n    (void) snprintf(buf, sizeof(buf), \"method=%s\", method);\n    log_to_file(buf);\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    log_to_file(\"answer_to_connection: method != GET -> MHD_NO\");\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    log_to_file(\"answer_to_connection: first request, storing req_cls\");\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    log_to_file(\"answer_to_connection: auth_info == NULL (no auth provided)\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    /* Log the exact state that leads to rejection for the violation scenario */\n    {\n      char buf[256];\n      (void) snprintf(buf, sizeof(buf),\n                      \"answer_to_connection: auth provided: username_len=%zu, password_len=%zu\",\n                      auth_info->username_len, auth_info->password_len);\n      log_to_file(buf);\n      if (auth_info->username != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"username='%s'\", auth_info->username);\n        log_to_file(buf);\n      }\n      if (auth_info->password != NULL)\n      {\n        (void) snprintf(buf, sizeof(buf), \"password='%s'\", auth_info->password);\n        log_to_file(buf);\n      }\n      /* Log results of the comparisons used in the condition */\n      {\n        int cmp_user = memcmp(auth_info->username, \"root\",\n                              auth_info->username_len);\n        int cmp_pass = (auth_info->password != NULL) ?\n                       memcmp(auth_info->password, \"pa$$w0rd\",\n                              auth_info->password_len) : 1;\n        (void) snprintf(buf, sizeof(buf), \"strcmp_len_root=%zu vs username_len=%zu, memcmp_user=%d, memcmp_pass=%d\",\n                        strlen(\"root\"), auth_info->username_len, cmp_user, cmp_pass);\n        log_to_file(buf);\n      }\n    }\n\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    log_to_file(\"answer_to_connection: auth succeeded\");\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  if (NULL != response)\n    MHD_destroy_response (response);\n  return ret;\n}\n",
  "explanation": "Added required standard headers and minimal forward declarations for the libmicrohttpd-like types and functions so the file compiles as a translation unit. I declared the struct MHD_BasicAuthInfo, opaque structs for connection/response, an enum for MHD_Result and an HTTP OK constant, and prototypes for the external functions used (no implementations were added). Also initialized local pointers to NULL and guarded MHD_destroy_response call to avoid using a possibly uninitialized response pointer. These changes preserve the original logic while ensuring compilation succeeds."
}