{
  "user_message": "An agent A claimed that the following MHD_poll_listen_socket code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_poll_listen_socket.\n```c\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_YES;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignments p[poll_count].revents = 0 (in both places where a pollfd slot is prepared) are dead code. The p array is zeroed by the initial memset(&p, 0, sizeof(p)); therefore explicitly setting revents to 0 immediately afterwards is an operation that is executed but whose removal would not affect program behaviour (the field is already zero). Removing those statements would not change the function's behaviour, so Rule 2.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Thread_Handle_ID { int ID; int valid; };\nstruct MHD_Itc { int r_fd; int valid; };\nstatic const MHD_socket MHD_INVALID_SOCKET = (MHD_socket)-1;\nstatic const int MHD_TEST_ALLOW_SUSPEND_RESUME = 0x1;\nstatic void probe_log (const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/226.txt\", \"a\");\n  if (f)\n  {\n    fputs(msg, f);\n    fputc('\\n', f);\n    fclose(f);\n  }\n}\nstatic void mhd_assert (int x) { (void)x; }\nstatic int MHD_thread_handle_ID_is_valid_ID_ (struct MHD_Thread_Handle_ID h) { return h.valid; }\nstatic int MHD_thread_handle_ID_is_current_thread_ (struct MHD_Thread_Handle_ID h) { (void)h; return 1; }\nstatic int MHD_ITC_IS_VALID_ (struct MHD_Itc *itc) { return (itc != NULL) && itc->valid; }\nstatic int MHD_itc_r_fd_ (struct MHD_Itc *itc) { return itc ? itc->r_fd : -1; }\nstatic void MHD_itc_clear_ (struct MHD_Itc *itc) { if (itc) itc->valid = 0; }\nstatic int MHD_sys_poll_ (struct pollfd *p, unsigned int cnt, int timeout)\n{\n  /* Forward to the system poll() function. */\n  return poll (p, (nfds_t) cnt, timeout);\n}\nstatic int MHD_socket_get_error_ (void) { return errno; }\nstatic int MHD_SCKT_ERR_IS_EINTR_ (int e) { return (e == EINTR); }\nstatic const char *MHD_socket_strerr_ (int e) { return strerror (e); }\nstatic void MHD_DLOG (const struct MHD_Daemon *d, const char *fmt, ...)\n{\n  (void)d;\n  va_list ap; va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n}\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  probe_log(\"enter: memset p to zero\");\n\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    /* The following assignment is redundant because p[] was zeroed by memset above.\n       This is the dead-code instance for MISRA C 2023 Rule 2.2: removing the\n       assignment would not change program behaviour. We log it so the problem\n       can be observed at runtime. */\n    p[poll_count].revents = 0;\n    probe_log(\"assigned p[poll_count].revents = 0 (listen slot)\");\n\n    poll_listen = (int) poll_count;\n    probe_log(\"set poll_listen\");\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    /* Another redundant assignment that is executed but not required due to\n       the earlier memset \u2014 also constitutes dead code as per Rule 2.2. */\n    p[poll_count].revents = 0;\n    probe_log(\"assigned p[poll_count].revents = 0 (itc slot)\");\n\n    poll_itc_idx = (int) poll_count;\n    probe_log(\"set poll_itc_idx\");\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n  {\n    probe_log(\"calling resume_suspended_connections\");\n    (void) resume_suspended_connections (daemon);\n  }\n\n  if (0 == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  probe_log(\"computed timeout\");\n\n  if (0 == poll_count)\n  {\n    probe_log(\"no fds to poll: returning MHD_YES\");\n    return MHD_YES;\n  }\n\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      probe_log(\"poll interrupted by EINTR: returning MHD_YES\");\n      return MHD_YES;\n    }\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    probe_log(\"poll failed: returning MHD_NO\");\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n  {\n    probe_log(\"itc has data: clearing itc\");\n    MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n  {\n    probe_log(\"daemon shutdown: returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n  {\n    probe_log(\"processing externally added connections\");\n    new_connections_list_process_ (daemon);\n  }\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n  {\n    probe_log(\"listen socket ready: accepting connection\");\n    (void) MHD_accept_connection (daemon);\n  }\n  probe_log(\"exit: returning MHD_YES\");\n  return MHD_YES;\n}\n\nstatic enum MHD_Result resume_suspended_connections (struct MHD_Daemon *d)\n{\n  /* In a full implementation this would try to resume suspended\n     connections and return MHD_NO on fatal error. Here return MHD_YES\n     to indicate success (no fatal error) so callers that compare the\n     return value behave correctly. */\n  (void)d;\n  return MHD_YES;\n}\nstatic void new_connections_list_process_ (struct MHD_Daemon *d) { (void)d; }\nstatic int MHD_accept_connection (struct MHD_Daemon *d) { (void)d; return 0; }\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The two assignments p[poll_count].revents = 0 are redundant given the unconditional memset(&p, 0, sizeof(p)) performed earlier. They are executed in normal control flow and removing them would not change observable behaviour of the function (the revents fields are already zero). Under MISRA C 2023 Rule 2.2 (an executed operation whose removal would not affect program behaviour is dead code) these statements qualify as dead code.\n\nCaveats: a definitive determination of a Rule 2.2 violation is a project\u2011level judgment, but for the provided function the assignments are redundant. Only if some external, atypical effects applied (for example p being volatile or memory\u2011mapped, or the prior memset being removed by other project code) would the conclusion change. Otherwise the agent A report is correct \u2014 these assignments are dead code and should be removed or formally justified/deviated from per the project\u2019s MISRA process."
}