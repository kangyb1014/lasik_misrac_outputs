{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts away const from response->data when calling the CRC callback: (char *) response->data. If response->data is (or should be) a const-qualified pointer (e.g. const char *), the cast removes const and passes a non-const char * to response->crc. That defeats the requirement that pointers should point to const-qualified types whenever possible and is a specific violation of MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct resp_iov_t { void *iov; size_t cnt; size_t sent; };\nstruct rp_t {\n    struct MHD_Response *response; /* back-reference for example */\n    int send_reply_body;\n    uint64_t rsp_write_position;\n    struct resp_iov_t resp_iov;\n    int resp_sender;\n};\nstatic void probe_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/707.txt\", \"a\");\n    if (NULL != f)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\nstatic void my_mutex_unlock_chk(void * /*mutex*/) { /* no-op */ }\nstatic void my_connection_close_error(struct MHD_Connection * /*c*/, const char * /*s*/) { /* no-op */ }\nstatic void my_connection_close(struct MHD_Connection * /*c*/, int /*code*/) { /* no-op */ }\nstatic void *my_connection_alloc_memory(struct MHD_Connection * /*connection*/, size_t size)\n{\n    return malloc(size);\n}\nstatic ssize_t sample_crc(void *cls, uint64_t pos, char *buf, size_t bufsz)\n{\n    (void) cls;\n    (void) pos;\n    /* Do not modify buf in this implementation. */\n    /* Simulate some available bytes: return min(bufsz, 16). */\n    return (ssize_t)((bufsz > 16u) ? 16u : bufsz);\n}\n\nstatic enum MHD_Result\ntry_ready_normal_body(struct MHD_Connection *connection)\n{\n    ssize_t ret;\n    struct MHD_Response *response;\n\n    response = connection->rp.response;\n\n    probe_log(\"enter: try_ready_normal_body\");\n\n    if ((0 == response->total_size) ||\n        (connection->rp.rsp_write_position == response->total_size))\n    {\n        probe_log(\"0-byte response or already complete: ready\");\n        return MHD_YES; /* 0-byte response is always ready */\n    }\n\n    if (NULL != response->data_iov)\n    {\n        size_t copy_size;\n\n        if (NULL != connection->rp.resp_iov.iov)\n        {\n            probe_log(\"response iov already present: ready\");\n            return MHD_YES;\n        }\n\n        copy_size = response->data_iovcnt * sizeof(void *);\n        connection->rp.resp_iov.iov = my_connection_alloc_memory(connection, copy_size);\n        if (NULL == connection->rp.resp_iov.iov)\n        {\n            my_mutex_unlock_chk(&response->mutex);\n            my_connection_close_error(connection, \"Closing connection (out of memory).\");\n            probe_log(\"alloc failed: closing connection\");\n            return MHD_NO;\n        }\n\n        memcpy(connection->rp.resp_iov.iov, response->data_iov, copy_size);\n        connection->rp.resp_iov.cnt = response->data_iovcnt;\n        connection->rp.resp_iov.sent = 0;\n        probe_log(\"prepared resp_iov: ready\");\n        return MHD_YES;\n    }\n\n    if (NULL == response->crc)\n    {\n        probe_log(\"no crc callback: ready\");\n        return MHD_YES;\n    }\n\n    if ((response->data_start <= connection->rp.rsp_write_position) &&\n        (response->data_size + response->data_start > connection->rp.rsp_write_position))\n    {\n        probe_log(\"response data already available: ready\");\n        return MHD_YES; /* response already ready */\n    }\n\n    /* --- Violation point: casting away const from response->data --- */\n    {\n        char logbuf[256];\n        snprintf(logbuf, sizeof(logbuf), \"about to call crc: rsp_write_position=%llu, data_buffer_size=%zu\",\n                 (unsigned long long)connection->rp.rsp_write_position,\n                 response->data_buffer_size);\n        probe_log(logbuf);\n\n        /* The original code does: (char *) response->data\n           response->data is const char *; casting to char * removes const\n           and is the specific MISRA 8.13 violation scenario. */\n        ret = response->crc(response->crc_cls,\n                            connection->rp.rsp_write_position,\n                            (char *) response->data, /* cast-away-const */\n                            (size_t) ((response->data_buffer_size < (response->total_size - connection->rp.rsp_write_position))\n                                      ? response->data_buffer_size\n                                      : (size_t)(response->total_size - connection->rp.rsp_write_position)));\n\n        probe_log(\"crc callback returned\");\n    }\n\n    if (0 > ret)\n    {\n        response->total_size = connection->rp.rsp_write_position;\n        my_mutex_unlock_chk(&response->mutex);\n        if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n        {\n            my_connection_close(connection, 0);\n            probe_log(\"crc end of stream: closing connection\");\n        }\n        else\n        {\n            my_connection_close_error(connection, \"Closing connection (application reported error generating data).\");\n            probe_log(\"crc error: closing connection with error\");\n        }\n        return MHD_NO;\n    }\n\n    response->data_start = connection->rp.rsp_write_position;\n    response->data_size = (size_t) ret;\n    if (0 == ret)\n    {\n        /* set state to UNREADY in original; here we log and return NO */\n        probe_log(\"crc returned 0: response not ready (unready)\");\n        my_mutex_unlock_chk(&response->mutex);\n        return MHD_NO;\n    }\n\n    probe_log(\"response ready after crc: returning YES\");\n    return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct under the normal interpretation of the code. The code performs (char *) response->data when calling response->crc. If response->data is declared as const char * (as the cast indicates), casting away the const qualifier to call a function that takes a char * discards const and thus defeats the intent of making the pointer point to const-qualified data. MISRA C:2023 Rule 8.13 requires that pointers point to const-qualified types whenever possible (and conversely a pointer should not be made const-qualified if the pointed object is legitimately modified by the callee). The correct fixes are to either: (a) change the crc callback prototype to accept a const char * (if it does not modify the buffer), or (b) make response->data non-const only if the callback is allowed to modify the buffer. As written, the explicit cast-away-const is a violation of the rule. Note: if in some build of the project response->data is not const-qualified (i.e. declared as char *), then there is no violation \u2014 the assertion of a violation depends on the actual declarations. Given the presence of the cast in the code, the agent's scenario is valid and the report is correct in the likely/typical case."
}