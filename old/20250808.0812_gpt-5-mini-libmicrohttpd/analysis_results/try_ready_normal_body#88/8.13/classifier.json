{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_ready_normal_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/707.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_ready_normal_body as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_ready_normal_body:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_normal_body:\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n</additional code>\nJudge whether the above try_ready_normal_body code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The code casts away const from response->data when calling the CRC callback: (char *) response->data. If response->data is (or should be) a const-qualified pointer (e.g. const char *), the cast removes const and passes a non-const char * to response->crc. That defeats the requirement that pointers should point to const-qualified types whenever possible and is a specific violation of MISRA C 2023 Rule 8.13.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n/* Minimal definitions to allow compilation and to demonstrate the\n   violation scenario: response->data is const-qualified but is cast\n   to (char *) when passed to the crc callback. */\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Simple probe logger that appends control path and state info. */\nstatic void probe_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/707.txt\", \"a\");\n    if (NULL != f)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\n\n/* Stub functions/values used by the original function; keep them\n   minimal and side-effect free for the test harness. */\nstatic void MHD_mutex_unlock_chk_(void * /*mutex*/) { /* no-op */ }\nstatic void CONNECTION_CLOSE_ERROR(void * /*c*/, const char * /*s*/) { /* no-op */ }\nstatic void MHD_connection_close_(void * /*c*/, int /*code*/) { /* no-op */ }\nstatic void *MHD_connection_alloc_memory_(void * /*connection*/, size_t size)\n{\n    return malloc(size);\n}\n\n#define MHD_CONTENT_READER_END_OF_STREAM (-2)\n\n/* Response structure: note data is const-qualified here to show the\n   scenario where a const pointer is present in the response. */\nstruct MHD_Response\n{\n    uint64_t total_size;\n    const char *data; /* const-qualified pointer */\n    size_t data_buffer_size;\n    uint64_t data_start;\n    size_t data_size;\n    const void *data_iov;\n    size_t data_iovcnt;\n    void *crc_cls;\n    /* crc takes a non-const char * in the original code; that leads to\n       the cast away of const below. */\n    ssize_t (*crc)(void *cls, uint64_t pos, char *buf, size_t bufsz);\n    void *mutex;\n};\n\nstruct resp_iov_t { void *iov; size_t cnt; size_t sent; };\nstruct rp_t {\n    struct MHD_Response *response;\n    int send_reply_body;\n    uint64_t rsp_write_position;\n    struct resp_iov_t resp_iov;\n    int resp_sender;\n};\n\nstruct MHD_Connection {\n    struct rp_t rp;\n    /* pool, buffers, etc. omitted for brevity */\n};\n\n/* A simple crc implementation that does NOT modify the buffer. It\n   returns the number of bytes available (simulated) or an error code. */\nstatic ssize_t sample_crc(void *cls, uint64_t pos, char *buf, size_t bufsz)\n{\n    (void) cls;\n    (void) pos;\n    /* Do not modify buf in this implementation. */\n    /* Simulate some available bytes: return min(bufsz, 16). */\n    return (ssize_t)((bufsz > 16u) ? 16u : bufsz);\n}\n\n/* The function under test. Preserves the original logic as much as\n   possible but adds logging to /tmp/logs/707.txt to demonstrate the\n   control path and the cast-away-const violation. */\nstatic enum MHD_Result\ntry_ready_normal_body(struct MHD_Connection *connection)\n{\n    ssize_t ret;\n    struct MHD_Response *response;\n\n    response = connection->rp.response;\n\n    probe_log(\"enter: try_ready_normal_body\");\n\n    if ((0 == response->total_size) ||\n        (connection->rp.rsp_write_position == response->total_size))\n    {\n        probe_log(\"0-byte response or already complete: ready\");\n        return MHD_YES; /* 0-byte response is always ready */\n    }\n\n    if (NULL != response->data_iov)\n    {\n        size_t copy_size;\n\n        if (NULL != connection->rp.resp_iov.iov)\n        {\n            probe_log(\"response iov already present: ready\");\n            return MHD_YES;\n        }\n\n        copy_size = response->data_iovcnt * sizeof(void *);\n        connection->rp.resp_iov.iov = MHD_connection_alloc_memory_(connection, copy_size);\n        if (NULL == connection->rp.resp_iov.iov)\n        {\n            MHD_mutex_unlock_chk_(&response->mutex);\n            CONNECTION_CLOSE_ERROR(connection, \"Closing connection (out of memory).\");\n            probe_log(\"alloc failed: closing connection\");\n            return MHD_NO;\n        }\n\n        memcpy(connection->rp.resp_iov.iov, response->data_iov, copy_size);\n        connection->rp.resp_iov.cnt = response->data_iovcnt;\n        connection->rp.resp_iov.sent = 0;\n        probe_log(\"prepared resp_iov: ready\");\n        return MHD_YES;\n    }\n\n    if (NULL == response->crc)\n    {\n        probe_log(\"no crc callback: ready\");\n        return MHD_YES;\n    }\n\n    if ((response->data_start <= connection->rp.rsp_write_position) &&\n        (response->data_size + response->data_start > connection->rp.rsp_write_position))\n    {\n        probe_log(\"response data already available: ready\");\n        return MHD_YES; /* response already ready */\n    }\n\n    /* --- Violation point: casting away const from response->data --- */\n    {\n        char logbuf[256];\n        snprintf(logbuf, sizeof(logbuf), \"about to call crc: rsp_write_position=%llu, data_buffer_size=%zu\",\n                 (unsigned long long)connection->rp.rsp_write_position,\n                 response->data_buffer_size);\n        probe_log(logbuf);\n\n        /* The original code does: (char *) response->data\n           response->data is const char *; casting to char * removes const\n           and is the specific MISRA 8.13 violation scenario. */\n        ret = response->crc(response->crc_cls,\n                            connection->rp.rsp_write_position,\n                            (char *) response->data, /* cast-away-const */\n                            (size_t) ((response->data_buffer_size < (response->total_size - connection->rp.rsp_write_position))\n                                      ? response->data_buffer_size\n                                      : (size_t)(response->total_size - connection->rp.rsp_write_position)));\n\n        probe_log(\"crc callback returned\");\n    }\n\n    if (0 > ret)\n    {\n        response->total_size = connection->rp.rsp_write_position;\n        MHD_mutex_unlock_chk_(&response->mutex);\n        if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n        {\n            MHD_connection_close_(connection, 0);\n            probe_log(\"crc end of stream: closing connection\");\n        }\n        else\n        {\n            CONNECTION_CLOSE_ERROR(connection, \"Closing connection (application reported error generating data).\");\n            probe_log(\"crc error: closing connection with error\");\n        }\n        return MHD_NO;\n    }\n\n    response->data_start = connection->rp.rsp_write_position;\n    response->data_size = (size_t) ret;\n    if (0 == ret)\n    {\n        /* set state to UNREADY in original; here we log and return NO */\n        probe_log(\"crc returned 0: response not ready (unready)\");\n        MHD_mutex_unlock_chk_(&response->mutex);\n        return MHD_NO;\n    }\n\n    probe_log(\"response ready after crc: returning YES\");\n    return MHD_YES;\n}\n\n/* Note: no main() is provided as per the constraints. To exercise this\n   test code, the larger test harness should create an instance of\n   struct MHD_Connection, populate connection->rp.response with a\n   response whose data is const-qualified, set response->crc to\n   sample_crc and call try_ready_normal_body(). The file\n   /tmp/logs/707.txt will contain the logged control path and state. */\n"
}