{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_ready_normal_body': {'callees': ['MHD_connection_alloc_memory_', '__builtin_unreachable', 'connection_close_error', 'MHD_connection_close_'], 'callers': ['MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'connection_close_error': {'callees': ['MHD_DLOG', 'MHD_connection_close_'], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'transmit_error_response_len', 'handle_recv_no_space', 'call_connection_handler', 'process_request_body', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "struct MHD_Connection",
    "mhd_assert",
    "CONNECTION_CLOSE_ERROR",
    "connection_close_error",
    "MHD_MIN",
    "MHD_connection_alloc_memory_",
    "MHD_mutex_unlock_chk_",
    "MHD_connection_close_",
    "__builtin_unreachable",
    "MHD_iovec_",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "MHD_Result / MHD_YES / MHD_NO",
    "MHD_resp_sender_sendfile"
  ],
  "explanation": "For each symbol: \n\n- struct MHD_Response: the function reads many fields (total_size, data_iov, data_iovcnt, crc, crc_cls, data, data_buffer_size, data_start, data_size, mutex). The struct definition may itself use compiler extensions (attributes, packed, flexible-array, bitfields, nonstandard qualifiers) or provide crc as a function pointer with non\u2011standard calling convention \u2014 necessary to decide if an extension is used. \n\n- struct MHD_Connection: the code accesses connection->rp.* and connection->state; the connection/rp sub-structure and types (resp_iov, resp_sender, rsp_write_position, allocation helpers) could hide extensions (e.g. anonymous structs/unions, attributes) that would violate the MISRA rule. \n\n- mhd_assert: this macro/function is called near the top. Many assert-style macros use compiler builtins (e.g. __builtin_unreachable) or GCC attributes; its expansion must be inspected to detect compiler-specific extensions. \n\n- CONNECTION_CLOSE_ERROR: this symbol is invoked in the function and is likely a macro wrapper for logging/close; macros frequently use variadic/statement-expression/##__VA_ARGS__ or compiler builtins \u2014 its definition must be checked. \n\n- connection_close_error: the call-graph shows a related function; whether CONNECTION_CLOSE_ERROR maps to this helper or expands to constructs using compiler extensions (e.g. attributes, inline asm) needs verification. \n\n- MHD_MIN: used in a cast-expression. MHD_MIN is likely a macro; some min/max macros use typeof, statement expressions or other compiler extensions \u2014 its definition is required to determine if an extension is used. \n\n- MHD_connection_alloc_memory_: allocation helper is called and its implementation or macro wrapper could use non\u2011standard constructs (inline assembly, attributes, statement expressions). Inspect it to be sure. \n\n- MHD_mutex_unlock_chk_: called in the error/unlock paths; it may be a macro wrapping mutex operations and could use compiler-specific constructs (e.g. builtin intrinsics or attributes). \n\n- MHD_connection_close_: closing helper may be implemented with extensions (attributes, inline asm, builtin intrinsics) \u2014 include to inspect for extensions used by this path. \n\n- __builtin_unreachable: appears in the call graph as a callee of this function (likely via macros such as assert or other helpers). This is an explicit compiler builtin/extension; its presence (direct or via macro expansion) is exactly the kind of language extension the MISRA check targets. \n\n- MHD_iovec_: type used for resp_iov.iov. The iovec/type definitions might use flexible array members, nonstandard alignment attributes or other extensions \u2014 inspect its definition. \n\n- MHD_CONTENT_READER_END_OF_STREAM: sentinel return value from response->crc is tested; it may be a macro constant (possibly negative) and could be defined using compiler-specific constructs \u2014 include to check. \n\n- MHD_Result / MHD_YES / MHD_NO: the return enum/type and its constants (MHD_YES/MHD_NO) are used; their definitions may include attributes or compiler extensions (e.g. bitfield-packed enums, nonstandard typedefs). \n\n- MHD_resp_sender_sendfile: compared against connection->rp.resp_sender. That constant/identifier may be an enum or macro whose definition could use extensions (e.g. designated initializers or attributes) \u2014 include to inspect.\n\nIn short: collect the definitions of the macros, involved helper functions and the involved struct/type definitions referenced by try_ready_normal_body, because language/compiler extensions are most likely to be hidden in macro expansions, attributes on types/functions, builtin calls (e.g. __builtin_unreachable) or nonstandard type declarations."
}