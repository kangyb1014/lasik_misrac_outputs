{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When building for Windows (_WIN32) the code that handles mapping failures by comparing pool->memory to MAP_FAILED becomes effectively unreachable: VirtualAlloc() returns NULL on failure (not MAP_FAILED), so the 'if (MAP_FAILED == pool->memory)' branch that performs the fallback allocation will never be taken for Windows mappings. As a result the intended fallback path is not reachable in that build configuration and the code relies on a POSIX-specific sentinel (MAP_FAILED), violating MISRA C 2023 Rule 2.1 (no unreachable code).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_logf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/625.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  mhd_logf(\"MHD_pool_create: entered, max=%zu\", max);\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_logf(\"allocated pool=%p (malloc returned)\", (void *)pool);\n  if (NULL == pool)\n  {\n    mhd_logf(\"pool allocation failed, returning NULL\");\n    return NULL;\n  }\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  mhd_logf(\"COMPILE-TIME: MAP_ANONYMOUS=%d _WIN32=%d\",\n#if defined(MAP_ANONYMOUS)\n           1,\n#else\n           0,\n#endif\n#if defined(_WIN32)\n           1\n#else\n           0\n#endif\n           );\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_logf(\"Decision: small allocation -> set pool->memory = MAP_FAILED\");\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_logf(\"Attempting system mapping, alloc_size=%zu, page_size=%zu\", alloc_size, MHD_sys_page_size_);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_logf(\"mmap() returned %p\", pool->memory);\n#elif defined(_WIN32)\n    /* VirtualAlloc returns NULL on failure (Windows), not MAP_FAILED like mmap. */\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_logf(\"VirtualAlloc() returned %p (NOTE: VirtualAlloc returns NULL on failure, not MAP_FAILED)\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_logf(\"COMPILE-TIME: no mapping support; set pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  /* Detect mapping failure by comparing to MAP_FAILED (POSIX). On Windows, VirtualAlloc returns NULL on failure,\n     so this comparison will be false even when allocation failed. This makes the MAP_FAILED-handling branch\n     effectively unreachable in the Windows build when VirtualAlloc is used. */\n  if (MAP_FAILED == pool->memory)\n  {\n    mhd_logf(\"Detected MAP_FAILED, falling back to malloc with ROUND_TO_ALIGN(max)\");\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    mhd_logf(\"Fallback malloc returned %p, alloc_size=%zu\", pool->memory, alloc_size);\n    if (NULL == pool->memory)\n    {\n      mhd_logf(\"Fallback malloc failed, freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_logf(\"Using fallback malloc (is_mmap=false)\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_logf(\"Mapping succeeded (or treated as succeeded): is_mmap=true, pool->memory=%p\", pool->memory);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n\n  mhd_logf(\"Asserting alignment of pool->memory: %p modulo ALIGN_SIZE\", pool->memory);\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_logf(\"pool state at exit: pos=%zu end=%zu size=%zu is_mmap=%d\", pool->pos, pool->end, pool->size, pool->is_mmap ? 1 : 0);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_logf(\"Returning pool=%p\", (void *)pool);\n  return pool;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 2.1 forbids code that can never be executed in any build/runtime configuration of the project. The fallback branch (if (MAP_FAILED == pool->memory)) is not inherently unreachable in the Windows build: pool->memory is explicitly set to MAP_FAILED for the \u201csmall allocation\u201d path earlier in the function, so that branch can be taken on Windows for those inputs. In other words, the MAP_FAILED test can be true on Windows (for the small-allocation case), so the code is potentially executable and therefore not unreachable per MISRA 2.1. \n\nAgent A\u2019s observation points out a real portability/logic bug \u2014 VirtualAlloc returns NULL on failure, so a failed Windows mapping won\u2019t be detected by comparing to MAP_FAILED \u2014 but that is a correctness/portability defect, not an instance of unreachable code under MISRA 2.1. To address the underlying bug, the code should use platform-appropriate failure checks (e.g. test for NULL on Windows) or conditionalize the failure test on the platform, but that is a different MISRA rule/concern than 2.1."
}