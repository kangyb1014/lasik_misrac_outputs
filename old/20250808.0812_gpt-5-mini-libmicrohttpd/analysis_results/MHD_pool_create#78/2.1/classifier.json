{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_pool_create code that contains useful probe functions that print useful logs to a file \"/tmp/logs/625.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_pool_create as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_pool_create:\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_create:\nstatic size_t MHD_sys_page_size_ = (size_t)\n#if defined(MHD_USE_PAGESIZE_MACRO_STATIC)\n                                   PAGESIZE;\n#elif defined(MHD_USE_PAGE_SIZE_MACRO_STATIC)\n                                   PAGE_SIZE;\n#else  /* ! MHD_USE_PAGE_SIZE_MACRO_STATIC */\n                                   _MHD_FALLBACK_PAGE_SIZE\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n...\n#define ALIGN_SIZE (2*sizeof(void*))\n...\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n</additional code>\nJudge whether the above MHD_pool_create code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "When building for Windows (_WIN32) the code that handles mapping failures by comparing pool->memory to MAP_FAILED becomes effectively unreachable: VirtualAlloc() returns NULL on failure (not MAP_FAILED), so the 'if (MAP_FAILED == pool->memory)' branch that performs the fallback allocation will never be taken for Windows mappings. As a result the intended fallback path is not reachable in that build configuration and the code relies on a POSIX-specific sentinel (MAP_FAILED), violating MISRA C 2023 Rule 2.1 (no unreachable code).",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Minimal local definitions to allow this test function to compile in a typical project. */\nstruct MemoryPool\n{\n  void *memory;\n  bool is_mmap;\n  size_t pos;\n  size_t end;\n  size_t size;\n};\n\n/* The project provides these macros and helpers; declared here as extern to avoid redefining macros. */\nextern size_t MHD_sys_page_size_;\nextern void _MHD_POISON_MEMORY (void *pointer, size_t size);\nextern void mhd_assert (int);\nextern size_t ROUND_TO_ALIGN (size_t n);\n\n/* Simple logger that appends textual diagnostics to the required file. */\nstatic void mhd_logf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/625.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n/* The instrumented function: preserves original logic but logs control decisions and state. */\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  mhd_logf(\"MHD_pool_create: entered, max=%zu\", max);\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_logf(\"allocated pool=%p (malloc returned)\", (void *)pool);\n  if (NULL == pool)\n  {\n    mhd_logf(\"pool allocation failed, returning NULL\");\n    return NULL;\n  }\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  mhd_logf(\"COMPILE-TIME: MAP_ANONYMOUS=%d _WIN32=%d\",\n#if defined(MAP_ANONYMOUS)\n           1,\n#else\n           0,\n#endif\n#if defined(_WIN32)\n           1\n#else\n           0\n#endif\n           );\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_logf(\"Decision: small allocation -> set pool->memory = MAP_FAILED\");\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_logf(\"Attempting system mapping, alloc_size=%zu, page_size=%zu\", alloc_size, MHD_sys_page_size_);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_logf(\"mmap() returned %p\", pool->memory);\n#elif defined(_WIN32)\n    /* VirtualAlloc returns NULL on failure (Windows), not MAP_FAILED like mmap. */\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_logf(\"VirtualAlloc() returned %p (NOTE: VirtualAlloc returns NULL on failure, not MAP_FAILED)\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_logf(\"COMPILE-TIME: no mapping support; set pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  /* Detect mapping failure by comparing to MAP_FAILED (POSIX). On Windows, VirtualAlloc returns NULL on failure,\n     so this comparison will be false even when allocation failed. This makes the MAP_FAILED-handling branch\n     effectively unreachable in the Windows build when VirtualAlloc is used. */\n  if (MAP_FAILED == pool->memory)\n  {\n    mhd_logf(\"Detected MAP_FAILED, falling back to malloc with ROUND_TO_ALIGN(max)\");\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    mhd_logf(\"Fallback malloc returned %p, alloc_size=%zu\", pool->memory, alloc_size);\n    if (NULL == pool->memory)\n    {\n      mhd_logf(\"Fallback malloc failed, freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_logf(\"Using fallback malloc (is_mmap=false)\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_logf(\"Mapping succeeded (or treated as succeeded): is_mmap=true, pool->memory=%p\", pool->memory);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n\n  mhd_logf(\"Asserting alignment of pool->memory: %p modulo ALIGN_SIZE\", pool->memory);\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_logf(\"pool state at exit: pos=%zu end=%zu size=%zu is_mmap=%d\", pool->pos, pool->end, pool->size, pool->is_mmap ? 1 : 0);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_logf(\"Returning pool=%p\", (void *)pool);\n  return pool;\n}\n"
}