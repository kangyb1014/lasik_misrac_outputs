{
  "user_message": "Target function code is:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}, 'update_cached_response': {'callees': ['MHD_destroy_response'], 'callers': ['update_directory', 'main']}, 'list_directory': {'callees': [], 'callers': ['update_directory']}, 'MHD_create_response_from_buffer_with_free_callback': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['ahc_echo', 'fill_v1_form', 'fill_v1_v2_form', 'update_directory']}, 'mark_as_html': {'callees': ['MHD_add_response_header'], 'callers': ['update_directory', 'main']}, 'generate_page': {'callees': ['MHD_queue_response', 'MHD_create_response_from_fd', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_post_processor', 'MHD_post_process', 'MHD_destroy_post_processor', 'update_directory', 'return_directory_response'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct ResponseDataContext",
    "struct MHD_Response",
    "struct Language",
    "languages",
    "categories",
    "INDEX_PAGE_HEADER",
    "INDEX_PAGE_FOOTER",
    "FORCE_CLOSE",
    "MHD_NO",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_add_response_header",
    "MHD_create_response_from_buffer_with_free_callback",
    "update_cached_response",
    "list_directory",
    "mark_as_html",
    "malloc",
    "free",
    "strlen",
    "memcpy",
    "snprintf",
    "stat",
    "struct stat"
  ],
  "explanation": "For each symbol below we must see its declaration/definition to determine whether the target function uses any compiler/language extensions (for example via macros expanding to GCC/Clang-specific constructs, attributes, inline assembly, statement-expressions, typeof, zero-length arrays, flexible array members implemented as extensions, non-standard pragmas, or other extension tokens):\n\n- struct ResponseDataContext: needed to verify its fields (buf, buf_len, off) and whether its definition uses any extensions (flexible arrays, attributes, non-standard storage-class specifiers).\n- struct MHD_Response: required to check whether the response type is a typedef/struct that involves extension annotations or macros.\n- struct Language: required to inspect fields (dirname, longname) and check for non-standard declarations or attributes.\n- languages: array object definition may be a macro or use designated initializers or compiler extensions; need to examine its declaration/initialization.\n- categories: similarly can be a macro/initializer using extensions; must inspect its definition.\n- INDEX_PAGE_HEADER: macro/constant \u2014 could be defined via complex macro tricks or non-standard tokens; must inspect expansion to ensure no extensions used.\n- INDEX_PAGE_FOOTER: same rationale as INDEX_PAGE_HEADER.\n- FORCE_CLOSE: preprocessor macro controlling conditional compilation; its presence/definition could enable code that uses extensions, so its definition must be known.\n- MHD_NO: macro/constant used as sentinel; could be defined via enum or macro that hides extension usage.\n- MHD_HTTP_HEADER_CONNECTION: macro/constant passed to MHD_add_response_header; inspect definition for extensions.\n- MHD_add_response_header: function or macro \u2014 if a macro it may expand to extension constructs; need prototype/definition to check for extensions in its implementation or attributes.\n- MHD_create_response_from_buffer_with_free_callback: prototype/macro \u2014 must inspect whether it is a macro invoking compiler extensions or has non-standard attributes or parameter types (function pointer type for the free-callback could be a macro/type using extension).\n- update_cached_response: declaration/definition inspected to ensure it is a normal function and not a macro using extensions (and to see if its semantics rely on extensions visible here).\n- list_directory: declaration/definition \u2014 could be a macro or inline function using extensions; also its return-type macro (MHD_NO) must be checked.\n- mark_as_html: declaration/definition \u2014 may be a macro or wrapper that uses extension features; check prototype.\n- malloc, free, strlen, memcpy, snprintf, stat, struct stat: standard library functions/types \u2014 include these to confirm they are the standard declarations and not overridden by project headers with extension-bearing macros/attributes (some projects re-define wrappers or macros that expand to non-standard code).\n\nIn short: any identifier that might be a macro, typedef, or a definition located outside the shown function can hide language extensions. The listed symbols are the ones referenced in the function whose definitions must be inspected to determine whether any language/compiler-specific extensions are used."
}