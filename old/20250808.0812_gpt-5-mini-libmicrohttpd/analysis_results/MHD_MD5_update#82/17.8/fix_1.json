{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nvoid mhd_assert (int cond);\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /* Number of bytes in the context buffer */\n  FILE *log = fopen(\"/tmp/logs/661.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER: ctx=%p data=%p length=%zu\\n\", (void *)ctx, (const void *)data, length);\n    fflush(log);\n  }\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"SHORTCUT: length == 0 -> return\\n\");\n      fclose(log);\n    }\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"AFTER_COUNT_UPDATE: bytes_have=%u new_count=%zu\\n\", bytes_have, ctx->count);\n    fflush(log);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (log != NULL)\n    {\n      fprintf(log, \"BRANCH: bytes_have!=0, bytes_left=%u, length=%zu\\n\", bytes_left, length);\n      fflush(log);\n    }\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      if (log != NULL)\n      {\n        fprintf(log, \"ACTION: copying %u bytes from data (%p) into ctx->buffer+%u\\n\",\n                bytes_left, (const void *)data, bytes_have);\n        fflush(log);\n      }\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n\n      /* Log pointer and length state just before modification */\n      if (log != NULL)\n      {\n        fprintf(log, \"BEFORE_MODIFY: data=%p length=%zu\\n\", (const void *)data, length);\n        fflush(log);\n      }\n\n      /* ---- Violation occurs here: modification of parameter 'data' ---- */\n      data += bytes_left;\n      length -= bytes_left;\n      /* ---------------------------------------------------------------- */\n\n      if (log != NULL)\n      {\n        fprintf(log, \"AFTER_MODIFY: data=%p length=%zu\\n\", (const void *)data, length);\n        fflush(log);\n      }\n\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n\n      if (log != NULL)\n      {\n        fprintf(log, \"POST_TRANSFORM: bytes_have reset to %u\\n\", bytes_have);\n        fflush(log);\n      }\n    }\n    else\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"NOT_ENOUGH_TO_FILL: length < bytes_left -> copy only and return\\n\");\n        fflush(log);\n      }\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    if (log != NULL)\n    {\n      fprintf(log, \"WHILE_LOOP: processing full block at data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n\n    md5_transform (ctx->H, data);\n\n    /* Log pointer and length state just before modification */\n    if (log != NULL)\n    {\n      fprintf(log, \"BEFORE_MODIFY_LOOP: data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n\n    /* ---- Violation occurs here as well: modification of parameter 'data' ---- */\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n    /* -------------------------------------------------------------------- */\n\n    if (log != NULL)\n    {\n      fprintf(log, \"AFTER_MODIFY_LOOP: data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    if (log != NULL)\n    {\n      fprintf(log, \"TAIL_COPY: copying %zu bytes from data=%p into ctx->buffer+%u\\n\",\n              length, (const void *)data, bytes_have);\n      fprintf(log, \"EXIT: final data=%p final_length=%zu\\n\", (const void *)data, length);\n      fclose(log);\n    }\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n  else\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"EXIT: no tail to copy, final data=%p final_length=%zu\\n\", (const void *)data, length);\n      fclose(log);\n    }\n  }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from md5.c:42:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\nmd5.c:401:6: note: in expansion of macro 'mhd_assert'\n  401 | void mhd_assert (int cond);\n      |      ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nmd5.c:401:6: note: in expansion of macro 'mhd_assert'\n  401 | void mhd_assert (int cond);\n      |      ^~~~~~~~~~\nmake[3]: *** [Makefile:2231: libmicrohttpd_la-md5.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_MD5_update as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n/*\n * Minimal supporting definitions so this translation unit compiles by itself.\n * The real project provides its own definitions; we keep these compatible\n * with the original MD5 semantics (block size = 64).\n */\nconst size_t MD5_BLOCK_SIZE = 64;\n\nstruct Md5Ctx {\n    size_t count;\n    uint8_t buffer[64];\n    uint32_t H[4];\n};\n\n/* md5_transform is provided elsewhere in the project. Declare it so this\n * unit compiles. */\nvoid md5_transform(uint32_t H[4], const uint8_t *block);\n\n/* NOTE: Do NOT declare/define mhd_assert here. In the project build it may be\n * a macro. Declaring it as a function prototype collides with that macro and\n * causes the compile error shown. The code below uses mhd_assert(...) as in\n * the original source; if mhd_assert is a macro it will expand, otherwise the\n * project's function will be used. */\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /* Number of bytes in the context buffer */\n  FILE *log = fopen(\"/tmp/logs/661.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER: ctx=%p data=%p length=%zu\\n\", (void *)ctx, (const void *)data, length);\n    fflush(log);\n  }\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"SHORTCUT: length == 0 -> return\\n\");\n      fclose(log);\n    }\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"AFTER_COUNT_UPDATE: bytes_have=%u new_count=%zu\\n\", bytes_have, ctx->count);\n    fflush(log);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (log != NULL)\n    {\n      fprintf(log, \"BRANCH: bytes_have!=0, bytes_left=%u, length=%zu\\n\", bytes_left, length);\n      fflush(log);\n    }\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      if (log != NULL)\n      {\n        fprintf(log, \"ACTION: copying %u bytes from data (%p) into ctx->buffer+%u\\n\",\n                bytes_left, (const void *)data, bytes_have);\n        fflush(log);\n      }\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n\n      /* Log pointer and length state just before modification */\n      if (log != NULL)\n      {\n        fprintf(log, \"BEFORE_MODIFY: data=%p length=%zu\\n\", (const void *)data, length);\n        fflush(log);\n      }\n\n      /* Move the data pointer forward locally (it's a local parameter variable)\n         to reflect the consumed bytes. This matches the original logic. */\n      data += bytes_left;\n      length -= bytes_left;\n\n      if (log != NULL)\n      {\n        fprintf(log, \"AFTER_MODIFY: data=%p length=%zu\\n\", (const void *)data, length);\n        fflush(log);\n      }\n\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n\n      if (log != NULL)\n      {\n        fprintf(log, \"POST_TRANSFORM: bytes_have reset to %u\\n\", bytes_have);\n        fflush(log);\n      }\n    }\n    else\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"NOT_ENOUGH_TO_FILL: length < bytes_left -> copy only and return\\n\");\n        fflush(log);\n      }\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    if (log != NULL)\n    {\n      fprintf(log, \"WHILE_LOOP: processing full block at data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n\n    md5_transform (ctx->H, data);\n\n    /* Log pointer and length state just before modification */\n    if (log != NULL)\n    {\n      fprintf(log, \"BEFORE_MODIFY_LOOP: data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n\n    if (log != NULL)\n    {\n      fprintf(log, \"AFTER_MODIFY_LOOP: data=%p length=%zu\\n\", (const void *)data, length);\n      fflush(log);\n    }\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    if (log != NULL)\n    {\n      fprintf(log, \"TAIL_COPY: copying %zu bytes from data=%p into ctx->buffer+%u\\n\",\n              length, (const void *)data, bytes_have);\n      fprintf(log, \"EXIT: final data=%p final_length=%zu\\n\", (const void *)data, length);\n      fclose(log);\n    }\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n  else\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"EXIT: no tail to copy, final data=%p final_length=%zu\\n\", (const void *)data, length);\n      fclose(log);\n    }\n  }\n}\n",
  "explanation": "The compile error was caused by a conflict between a macro named mhd_assert (defined in a header) and a function prototype \"void mhd_assert (int cond);\" in the original file. The macro expansion made the prototype invalid. I removed the prototype declaration for mhd_assert so that the code uses whatever mhd_assert the project provides (macro or function) without collision. To make this translation unit self-contained and compilable, I added minimal supporting declarations (struct Md5Ctx, MD5_BLOCK_SIZE as a const, and an extern-like declaration for md5_transform) and included necessary headers. The core logic of MHD_MD5_update is preserved unchanged."
}