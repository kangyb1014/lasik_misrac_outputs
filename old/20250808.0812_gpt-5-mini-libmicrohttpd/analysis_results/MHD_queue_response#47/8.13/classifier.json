{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_queue_response code that contains useful probe functions that print useful logs to a file \"/tmp/logs/379.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_queue_response as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_queue_response:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n```\n</target_code>\nJudge whether the above MHD_queue_response code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The function declares a local pointer 'daemon' as 'struct MHD_Daemon *daemon' but only reads from the daemon object (checks options, shutdown, sigpipe_blocked, etc.) and does not modify it. According to MISRA C 2023 Rule 8.13, such a pointer should point to a const-qualified type whenever possible (i.e. 'const struct MHD_Daemon *daemon'). Thus the code violates Rule 8.13 because a pointer that could be to a const-qualified type is not const-qualified.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* Minimal, self-contained definitions to allow compilation and to preserve\n   the original MHD_queue_response control flow for demonstration. No main\n   is defined as required. */\n\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0 };\n\nstruct MHD_Response {\n    unsigned int flags_auto;\n    unsigned int flags;\n    int fd;\n    int is_pipe;\n    unsigned long total_size;\n    void *upgrade_handler;\n    void *first_header;\n    unsigned int ref_count;\n};\n\nstruct MHD_Daemon {\n    unsigned int options;\n    bool shutdown;\n    bool sigpipe_blocked;\n};\n\nstruct rp_s {\n    struct MHD_Response *response;\n    unsigned int responseCode;\n    bool responseIcy;\n    unsigned long rsp_write_position;\n    void (*resp_sender)(void);\n};\n\nstruct rq_s {\n    int http_ver;\n    int http_mthd;\n    unsigned long remaining_upload_size;\n};\n\nstruct MHD_Connection {\n    struct MHD_Daemon *daemon; /* This pointer is read-only in the function */\n    bool in_access_handler;\n    bool suspended;\n    int state;\n    bool in_idle;\n    bool sk_spipe_suppress;\n    struct rp_s rp;\n    struct rq_s rq;\n    int tid;\n};\n\n/* Constants to emulate original checks */\nenum {\n    MHD_CONNECTION_HEADERS_PROCESSED = 1,\n    MHD_CONNECTION_FULL_REQ_RECEIVED = 2,\n    MHD_CONNECTION_START_REPLY = 3,\n\n    MHD_ICY_FLAG = 0x80000000u,\n    MHD_HTTP_SWITCHING_PROTOCOLS = 101,\n    MHD_HTTP_VER_1_0 = 10,\n    MHD_HTTP_MTHD_CONNECT = 2,\n    MHD_HTTP_MTHD_HEAD = 3,\n    MHD_HTTP_OK = 200,\n    MHD_HTTP_NO_CONTENT = 204,\n    MHD_HTTP_NOT_MODIFIED = 304,\n\n    MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x1,\n    MHD_RF_HTTP_1_0_SERVER = 0x2,\n    MHD_RF_HEAD_ONLY_RESPONSE = 0x4,\n    MHD_RAF_HAS_CONTENT_LENGTH = 0x8,\n    MHD_RF_INSANITY_HEADER_CONTENT_LENGTH = 0x10,\n    MHD_RAF_HAS_CONNECTION_HDR = 0x20,\n    MHD_ALLOW_UPGRADE = 0x40\n};\n\n/* Simple stubs that preserve control flow but don't change semantics. */\nstatic int is_reply_body_needed(const struct MHD_Connection *connection, unsigned int status_code)\n{\n    (void) connection;\n    (void) status_code;\n    /* Return a value indicating body is needed */\n    return 2; /* RP_BODY_HEADERS_ONLY < 2 */\n}\n\nstatic void MHD_increment_response_rc(struct MHD_Response *response)\n{\n    if (NULL != response) {\n        response->ref_count++;\n    }\n}\n\nstatic void MHD_connection_handle_idle(struct MHD_Connection *connection)\n{\n    (void) connection;\n    /* No-op for demonstration */\n}\n\nstatic void MHD_update_last_activity_(struct MHD_Connection *connection)\n{\n    (void) connection;\n}\n\nstatic bool MHD_D_IS_USING_THREADS_(const struct MHD_Daemon *daemon)\n{\n    /* for demonstration, treat 'options' bit 1 as using threads */\n    (void) daemon;\n    return false;\n}\n\nstatic bool MHD_thread_handle_ID_is_current_thread_(int tid)\n{\n    (void) tid;\n    return true;\n}\n\n/* Probe logger: appends control flow and key state to the file */\nstatic void mhd_probe_log(const char *stage,\n                          const struct MHD_Connection *connection,\n                          const struct MHD_Response *response,\n                          unsigned int status_code,\n                          const struct MHD_Daemon *daemon)\n{\n    FILE *f = fopen(\"/tmp/logs/379.txt\", \"a\");\n    if (NULL == f)\n        return;\n    fprintf(f, \"Stage: %s\\n\", stage);\n    fprintf(f, \" connection=%p response=%p status_code=%u\\n\",\n            (const void *)connection, (const void *)response, status_code);\n    if (connection != NULL) {\n        fprintf(f, \" connection->state=%d in_access_handler=%d suspended=%d in_idle=%d tid=%d\\n\",\n                connection->state,\n                (int)connection->in_access_handler,\n                (int)connection->suspended,\n                (int)connection->in_idle,\n                connection->tid);\n        fprintf(f, \" rp.response=%p rp.responseCode=%u rp.rsp_write_position=%lu\\n\",\n                (const void *)connection->rp.response,\n                connection->rp.responseCode,\n                connection->rp.rsp_write_position);\n    }\n    if (response != NULL) {\n        fprintf(f, \" response->flags=%u flags_auto=%u fd=%d is_pipe=%d total_size=%lu ref_count=%u\\n\",\n                response->flags, response->flags_auto, response->fd,\n                response->is_pipe, response->total_size, response->ref_count);\n    }\n    if (daemon != NULL) {\n        fprintf(f, \" daemon=%p shutdown=%d options=0x%x sigpipe_blocked=%d\\n\",\n                (const void *)daemon, (int)daemon->shutdown, daemon->options,\n                (int)daemon->sigpipe_blocked);\n    }\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\n/* The instrumented MHD_queue_response preserving original logic as much as\n   possible for the demonstration. Note: the local 'daemon' pointer is a\n   non-const pointer even though this function only reads from it; this is\n   the point of the demonstrated Rule 8.13 violation. */\n\nenum MHD_Result MHD_queue_response(struct MHD_Connection *connection,\n                                   unsigned int status_code,\n                                   struct MHD_Response *response)\n{\n    struct MHD_Daemon *daemon;\n    bool reply_icy;\n\n    mhd_probe_log(\"entry\", connection, response, status_code, NULL);\n\n    if ((NULL == connection) || (NULL == response)) {\n        mhd_probe_log(\"null-check-failed\", connection, response, status_code, NULL);\n        return MHD_NO;\n    }\n\n    daemon = connection->daemon; /* <--- This pointer is read-only in this function */\n    mhd_probe_log(\"after-daemon-assign\", connection, response, status_code, daemon);\n\n    if ((! connection->in_access_handler) && (! connection->suspended) &&\n        MHD_D_IS_USING_THREADS_(daemon))\n    {\n        mhd_probe_log(\"thread-usage-refuse\", connection, response, status_code, daemon);\n        return MHD_NO;\n    }\n\n    reply_icy = (0u != (status_code & MHD_ICY_FLAG));\n    status_code &= ~MHD_ICY_FLAG;\n    mhd_probe_log(\"after-icy\", connection, response, status_code, daemon);\n\n    if (NULL != connection->rp.response) {\n        mhd_probe_log(\"response-already-set\", connection, response, status_code, daemon);\n        return MHD_NO; /* The response was already set */\n    }\n\n    if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    {\n        mhd_probe_log(\"wrong-connection-state\", connection, response, status_code, daemon);\n        return MHD_NO; /* Wrong connection state */\n    }\n\n    if (daemon->shutdown) {\n        mhd_probe_log(\"daemon-shutdown\", connection, response, status_code, daemon);\n        return MHD_NO;\n    }\n\n    /* Simplified and conservative checks for status-code ranges and method */\n    if ((100u > status_code) || (999u < status_code)) {\n        mhd_probe_log(\"wrong-status-range\", connection, response, status_code, daemon);\n        return MHD_NO;\n    }\n\n    if (200u > status_code) {\n        if (MHD_HTTP_VER_1_0 == connection->rq.http_ver) {\n            mhd_probe_log(\"http1.0-no-1xx\", connection, response, status_code, daemon);\n            return MHD_NO;\n        }\n    }\n\n    if ((MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) && (2 == status_code / 100)) {\n        mhd_probe_log(\"connect-with-success-status\", connection, response, status_code, daemon);\n        return MHD_NO;\n    }\n\n    if ((0u != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n        (1 < is_reply_body_needed(connection, status_code)))\n    {\n        mhd_probe_log(\"head-only-conflict\", connection, response, status_code, daemon);\n        return MHD_NO;\n    }\n\n    /* Log that we are about to increment response refcount */\n    mhd_probe_log(\"before-increment-rc\", connection, response, status_code, daemon);\n    MHD_increment_response_rc(response);\n\n    /* Assign the response into the connection (modifies connection) */\n    connection->rp.response = response;\n    connection->rp.responseCode = status_code;\n    connection->rp.responseIcy = reply_icy;\n\n    /* Choose a sender stub; emulate sendfile choice logic simplistically */\n    if ((response->fd == -1) || (response->is_pipe))\n        connection->rp.resp_sender = NULL;\n    else\n        connection->rp.resp_sender = NULL;\n\n    if ((MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n        (MHD_HTTP_OK > status_code) ||\n        (MHD_HTTP_NO_CONTENT == status_code) ||\n        (MHD_HTTP_NOT_MODIFIED == status_code))\n    {\n        connection->rp.rsp_write_position = response->total_size;\n    }\n\n    if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state) {\n        connection->rp.rsp_write_position = response->total_size;\n        connection->rp.response = response;\n        connection->state = MHD_CONNECTION_START_REPLY;\n        connection->rq.remaining_upload_size = 0;\n        connection->in_idle = false;\n        connection->rp.responseCode = status_code;\n        connection->rp.responseIcy = reply_icy;\n        connection->rp.rsp_write_position = response->total_size;\n    }\n\n    if (! connection->in_idle)\n        (void) MHD_connection_handle_idle(connection);\n\n    MHD_update_last_activity_(connection);\n\n    mhd_probe_log(\"success\", connection, response, status_code, daemon);\n    return MHD_YES;\n}\n"
}