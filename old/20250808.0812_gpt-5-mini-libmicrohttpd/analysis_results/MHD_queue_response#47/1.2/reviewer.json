{
  "user_message": "An agent A claimed that the following MHD_queue_response code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_response.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a compiler-specific language extension: the macro _MHD_EXTERN is defined as __attribute__((visibility(\"default\"))) extern, which employs GCC/Clang __attribute__ syntax \u2014 an explicit compiler extension (non-standard C).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_RP {\n  struct MHD_Response *response;\n  unsigned int responseCode;\n  bool responseIcy;\n  void (*resp_sender)(void);\n  unsigned long long rsp_write_position;\n};\nstatic const unsigned int MHD_ICY_FLAG = 0x80000000u;\nstatic const unsigned int MHD_USE_THREADS = 0x00000001u;\nstatic const unsigned int MHD_ALLOW_UPGRADE = 0x00000002u;\nstatic const unsigned int MHD_USE_TLS = 0x00000004u;\nstatic const unsigned int MHD_RF_HEAD_ONLY_RESPONSE = 0x00000001u;\nstatic const unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x00000002u;\nstatic const unsigned int MHD_RF_HTTP_1_0_SERVER = 0x00000004u;\nstatic const unsigned int MHD_RF_INSANITY_HEADER_CONTENT_LENGTH = 0x00000008u;\nstatic const unsigned int MHD_RAF_HAS_CONTENT_LENGTH = 0x00000001u;\nstatic const unsigned int MHD_RAF_HAS_CONNECTION_HDR = 0x00000002u;\nstatic const int MHD_CONNECTION_HEADERS_PROCESSED = 1;\nstatic const int MHD_CONNECTION_FULL_REQ_RECEIVED = 2;\nstatic const int MHD_CONNECTION_START_REPLY = 3;\nstatic const int MHD_HTTP_SWITCHING_PROTOCOLS = 101;\nstatic const int MHD_HTTP_VER_1_0 = 0;\nstatic const int MHD_HTTP_MTHD_CONNECT = 1;\nstatic const int MHD_HTTP_MTHD_HEAD = 2;\nstatic const int MHD_HTTP_OK = 200;\nstatic const int MHD_HTTP_NO_CONTENT = 204;\nstatic const int MHD_HTTP_NOT_MODIFIED = 304;\nstatic const int RP_BODY_HEADERS_ONLY = 0;\nstatic void mhd_assert(int cond) { if (!cond) abort(); }\nstatic bool MHD_str_has_s_token_caseless_(const char *value, const char *token)\n{\n  if (value == NULL || token == NULL) return false;\n  size_t tlen = strlen(token);\n  const char *p = value;\n  while (*p) {\n    /* Skip separators */\n    while (*p == ' ' || *p == '\\t' || *p == ',' ) ++p;\n    if (strncasecmp(p, token, tlen) == 0) {\n      /* token followed by space, tab, comma or end -> treat as separate token */\n      const char *q = p + tlen;\n      if (*q == '\\0' || *q == ' ' || *q == '\\t' || *q == ',') return true;\n    }\n    /* Move to next separator */\n    while (*p && *p != ',') ++p;\n    if (*p == ',') ++p;\n  }\n  return false;\n}\nstatic int MHD_IS_HTTP_VER_1_1_COMPAT(int ver) { return ver >= 1; }\nstatic int MHD_thread_handle_ID_is_current_thread_(intptr_t id)\n{\n  /* For simplicity assume it's always the current thread. */\n  (void) id;\n  return 1;\n}\nstatic void MHD_resp_sender_std(void) { }\nstatic void MHD_resp_sender_sendfile(void) { }\nstatic int MHD_D_IS_USING_THREADS_(struct MHD_Daemon *d)\n{\n  if (d == NULL) return 0;\n  return 0 != (d->options & MHD_USE_THREADS);\n}\n\nstatic int is_reply_body_needed(struct MHD_Connection *connection, unsigned int status_code)\n{\n  (void) status_code;\n  /* HEAD method: headers only (0). Otherwise assume body needed (2). */\n  if (connection->rq.http_mthd == MHD_HTTP_MTHD_HEAD) return 0;\n  return 2;\n}\nstatic void MHD_connection_handle_idle(struct MHD_Connection *c)\n{\n  (void) c;\n}\nstatic void MHD_update_last_activity_(struct MHD_Connection *c)\n{\n  (void) c;\n}\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  FILE *log = fopen(\"/tmp/logs/376.txt\", \"a\");\n  if (log)\n    fprintf(log, \"ENTER MHD_queue_response: connection=%p response=%p status=%u\\n\",\n            (void *) connection, (void *) response, status_code);\n\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n  {\n    if (log)\n      fprintf(log, \"EXIT: NULL parameter (connection=%p response=%p)\\n\",\n              (void *) connection, (void *) response);\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    if (log)\n      fprintf(log, \"EXIT: not in access handler and not suspended while using threads\\n\"\n                  \"       in_access_handler=%d suspended=%d daemon->options=0x%08x\\n\",\n              (int) connection->in_access_handler,\n              (int) connection->suspended,\n              (unsigned) (daemon ? daemon->options : 0));\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n    if (log)\n      fprintf(log, \"EXIT: attempted to queue response on wrong thread (suspended=%d)\\n\",\n              (int) connection->suspended);\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (NULL != connection->rp.response)\n  {\n    if (log)\n      fprintf(log, \"EXIT: response already set on connection\\n\");\n    if (log) fclose(log);\n    return MHD_NO; /* The response was already set */\n  }\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n  {\n    if (log)\n      fprintf(log, \"EXIT: wrong connection state (%d)\\n\", (int) connection->state);\n    if (log) fclose(log);\n    return MHD_NO; /* Wrong connection state */\n  }\n\n  if (daemon && daemon->shutdown)\n  {\n    if (log)\n      fprintf(log, \"EXIT: daemon is shutting down\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (daemon == NULL || 0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n      if (log) fprintf(log, \"EXIT: upgrade handler present but daemon disallows upgrade\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != (int) status_code)\n    {\n      if (log) fprintf(log, \"EXIT: upgrade handler but status code != 101 (%u)\\n\", status_code);\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n      if (log) fprintf(log, \"EXIT: upgrade handler but missing Connection header flag\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         \"Connection\"));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n      if (log) fprintf(log, \"EXIT: Connection header does not contain 'upgrade' token\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n      if (log) fprintf(log, \"EXIT: Upgrade only allowed for HTTP/1.1 compat versions (ver=%d)\\n\",\n                      (int) connection->rq.http_ver);\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n  }\n\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == (int) status_code)\n  {\n    if (NULL == response->upgrade_handler)\n    {\n      if (log) fprintf(log, \"EXIT: status code 101 but no upgrade handler in response\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n  }\n\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n    if (log) fprintf(log, \"EXIT: invalid status code %u (not three digits)\\n\", status_code);\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n      if (log) fprintf(log, \"EXIT: 1xx code refused for HTTP/1.0 client (ver=0x%x)\\n\", (unsigned) connection->rq.http_ver);\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n      if (log) fprintf(log, \"EXIT: 1xx code refused in HTTP/1.0 reply mode (response flags=0x%x)\\n\",\n                      (unsigned) response->flags);\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n    if (log) fprintf(log, \"EXIT: CONNECT request cannot be answered with 2xx (%u)\\n\", status_code);\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n    if (log) fprintf(log, \"EXIT: HEAD-only response cannot be used; body required by request\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    if (log) fprintf(log, \"WARN: application-defined Content-Length header present\\n\");\n  }\n\n  MHD_increment_response_rc (response);\n  if (log) fprintf(log, \"info: incremented response reference count, now maybe >0\\n\");\n\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS)) ||\n       (! connection->daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > (int) status_code) ||\n       (MHD_HTTP_NO_CONTENT == (int) status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == (int) status_code) )\n  {\n    connection->rp.rsp_write_position = response->total_size;\n    if (log) fprintf(log, \"info: treated as HEAD/no-body response; rsp_write_position=%llu\\n\",\n                    (unsigned long long) response->total_size);\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n    if (log) fprintf(log, \"info: queued early (headers processed) -> discard_request set, new state START_REPLY\\n\");\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n\n  if (log)\n    fprintf(log, \"EXIT: success; queued response (response=%p) code=%u reply_icy=%d state=%d\\n\",\n            (void *) connection->rp.response, connection->rp.responseCode,\n            (int) connection->rp.responseIcy, (int) connection->state);\n  if (log) fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is plausible but not verifiable from the supplied source fragment alone. MISRA C 2023 Rule 1.2 forbids use of compiler language extensions. The GCC/Clang form __attribute__((...)) is a compiler-specific extension; therefore if the project header defines _MHD_EXTERN as something like __attribute__((visibility(\"default\"))) extern (as Agent A asserts), then the code does use a non\u2011standard language extension and the reported violation would be correct.\n\nHowever, the posted target_code only shows use of the macro _MHD_EXTERN \u2014 it does not show its definition. Without the macro's definition (or the preprocessed output), one cannot determine from the snippet whether a compiler extension is actually being used. The failure of the supplied test code to compile does not prove the presence of the __attribute__ usage; it only shows the test harness was incomplete.\n\nConclusion: the report by Agent A may be correct if _MHD_EXTERN expands to a GCC/Clang __attribute__ form, but that fact is not established by the provided code. To confirm the violation, the macro definition or the preprocessed source must be provided. Recommended actions: inspect the header that defines _MHD_EXTERN or run the preprocessor (e.g. gcc -E) to see its expansion. If it expands to __attribute__((...)) then this is a violation of MISRA Rule 1.2."
}