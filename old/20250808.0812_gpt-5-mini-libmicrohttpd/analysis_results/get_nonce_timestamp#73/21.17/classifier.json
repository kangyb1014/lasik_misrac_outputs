{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_nonce_timestamp code that contains useful probe functions that print useful logs to a file \"/tmp/logs/591.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_nonce_timestamp as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_nonce_timestamp:\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\nJudge whether the above get_nonce_timestamp code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Violation occurs when noncelen is zero and nonce points to a buffer that is not NUL-terminated (for example a fixed-size binary digest). The call to strlen(nonce) will read past the end of that buffer searching for a '\\0', resulting in an out-of-bounds access.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Minimal constant used by the function (kept as a runtime constant to avoid macros). */\nstatic const size_t TIMESTAMP_CHARS_LEN = 10u;\n\n/* External function used by the original code. Declared only (no mock/definition). */\nextern size_t MHD_strx_to_uint64_n_(const char *str, size_t n, uint64_t *out);\n\n/*\n * get_nonce_timestamp with added logging to /tmp/logs/591.txt that records\n * control path and key state information relevant to the violation scenario.\n * The original logic is preserved as closely as possible.\n */\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  FILE *log = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER get_nonce_timestamp: nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n            (const void *)nonce, noncelen, (void *)ptimestamp);\n  }\n\n  if (0 == noncelen)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"noncelen == 0: calling strlen(nonce)\\n\");\n    }\n\n    /*\n     * This strlen can read beyond the bounds of the nonce object if nonce\n     * is not NUL-terminated; this is the scenario that violates MISRA C 2023\n     * Rule 21.17.\n     */\n    noncelen = strlen (nonce);\n\n    if (log != NULL)\n    {\n      fprintf(log, \"strlen returned noncelen=%zu\\n\", noncelen);\n    }\n  }\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"length check failed: noncelen=%zu -> return false\\n\", noncelen);\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"calling MHD_strx_to_uint64_n_ at offset %zu for %zu chars\\n\",\n            (noncelen >= TIMESTAMP_CHARS_LEN) ? (noncelen - TIMESTAMP_CHARS_LEN) : 0u,\n            (size_t)TIMESTAMP_CHARS_LEN);\n  }\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"timestamp parse failed -> return false\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"success -> return true, timestamp=%\" PRIu64 \"\\n\", *ptimestamp);\n    fclose(log);\n  }\n\n  return true;\n}\n"
}