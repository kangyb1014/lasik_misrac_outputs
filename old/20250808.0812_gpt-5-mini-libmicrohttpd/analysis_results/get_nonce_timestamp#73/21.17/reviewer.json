{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs when noncelen is zero and nonce points to a buffer that is not NUL-terminated (for example a fixed-size binary digest). The call to strlen(nonce) will read past the end of that buffer searching for a '\\0', resulting in an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const size_t TIMESTAMP_CHARS_LEN_LOCAL = 10u;\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  FILE *log = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER get_nonce_timestamp: nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n            (const void *)nonce, noncelen, (void *)ptimestamp);\n  }\n\n  if (0 == noncelen)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"noncelen == 0: calling strlen(nonce)\\n\");\n    }\n\n    /*\n     * This strlen can read beyond the bounds of the nonce object if nonce\n     * is not NUL-terminated; this is the scenario that violates MISRA C 2023\n     * Rule 21.17.\n     */\n    noncelen = strlen (nonce);\n\n    if (log != NULL)\n    {\n      fprintf(log, \"strlen returned noncelen=%zu\\n\", noncelen);\n    }\n  }\n\n  if (true\n  #ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n  #endif /* MHD_MD5_SUPPORT */\n  #if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n  #endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"length check failed: noncelen=%zu -> return false\\n\", noncelen);\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"calling MHD_strx_to_uint64_n_ at offset %zu for %zu chars\\n\",\n            (noncelen >= TIMESTAMP_CHARS_LEN_LOCAL) ? (noncelen - TIMESTAMP_CHARS_LEN_LOCAL) : 0u,\n            (size_t)TIMESTAMP_CHARS_LEN_LOCAL);\n  }\n\n  if (TIMESTAMP_CHARS_LEN_LOCAL !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN_LOCAL,\n                             TIMESTAMP_CHARS_LEN_LOCAL,\n                             ptimestamp))\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"timestamp parse failed -> return false\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"success -> return true, timestamp=%\" PRIu64 \"\\n\", *ptimestamp);\n    fclose(log);\n  }\n\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls strlen(nonce) when noncelen == 0. If the caller supplied nonce as a fixed-size binary buffer that is not NUL-terminated (and noncelen was passed as 0), strlen will scan past the end looking for '\\0' and can perform out\u2011of\u2011bounds reads. That behaviour is exactly what MISRA C 2023 Rule 21.17 forbids (string.h functions must not result in accesses beyond the bounds of the objects referenced). Note: if there is a documented or enforced precondition that nonce is a NUL\u2011terminated C string whenever noncelen==0 then the call would be safe, but the code as written does not enforce or check that precondition, so the potential out\u2011of\u2011bounds access makes the report valid. A safe fix is to require an explicit length (do not call strlen), or ensure/validate NUL termination within known bounds (e.g. use memchr with a known maximum length), or document and enforce the precondition."
}