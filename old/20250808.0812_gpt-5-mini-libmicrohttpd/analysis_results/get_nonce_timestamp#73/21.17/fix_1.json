{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic const size_t TIMESTAMP_CHARS_LEN = 10u;\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  FILE *log = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER get_nonce_timestamp: nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n            (const void *)nonce, noncelen, (void *)ptimestamp);\n  }\n\n  if (0 == noncelen)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"noncelen == 0: calling strlen(nonce)\\n\");\n    }\n\n    /*\n     * This strlen can read beyond the bounds of the nonce object if nonce\n     * is not NUL-terminated; this is the scenario that violates MISRA C 2023\n     * Rule 21.17.\n     */\n    noncelen = strlen (nonce);\n\n    if (log != NULL)\n    {\n      fprintf(log, \"strlen returned noncelen=%zu\\n\", noncelen);\n    }\n  }\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"length check failed: noncelen=%zu -> return false\\n\", noncelen);\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"calling MHD_strx_to_uint64_n_ at offset %zu for %zu chars\\n\",\n            (noncelen >= TIMESTAMP_CHARS_LEN) ? (noncelen - TIMESTAMP_CHARS_LEN) : 0u,\n            (size_t)TIMESTAMP_CHARS_LEN);\n  }\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"timestamp parse failed -> return false\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"success -> return true, timestamp=%\" PRIu64 \"\\n\", *ptimestamp);\n    fclose(log);\n  }\n\n  return true;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:81:29: error: expected identifier or '(' before numeric constant\n   81 | #define TIMESTAMP_BIN_SIZE (48 / 8)\n      |                             ^~\ndigestauth.c:94:30: note: in expansion of macro 'TIMESTAMP_BIN_SIZE'\n   94 | #define TIMESTAMP_CHARS_LEN (TIMESTAMP_BIN_SIZE * 2)\n      |                              ^~~~~~~~~~~~~~~~~~\ndigestauth.c:750:21: note: in expansion of macro 'TIMESTAMP_CHARS_LEN'\n  750 | static const size_t TIMESTAMP_CHARS_LEN = 10u;\n      |                     ^~~~~~~~~~~~~~~~~~~\ndigestauth.c:94:49: error: expected ')' before '*' token\n   94 | #define TIMESTAMP_CHARS_LEN (TIMESTAMP_BIN_SIZE * 2)\n      |                                                 ^\ndigestauth.c:750:21: note: in expansion of macro 'TIMESTAMP_CHARS_LEN'\n  750 | static const size_t TIMESTAMP_CHARS_LEN = 10u;\n      |                     ^~~~~~~~~~~~~~~~~~~\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_nonce_timestamp as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stddef.h>\n\n/*\n * Use a different identifier than TIMESTAMP_CHARS_LEN because that name\n * may be defined as a macro elsewhere in the build. Keeping the value and\n * logic the same while avoiding macro expansion.\n */\nstatic const size_t TIMESTAMP_CHARS_LEN_LOCAL = 10u;\n\n/*\n * Prototype for external helper used by the original code. We declare it\n * here to avoid implicit declaration errors during compilation. This is\n * not a mock implementation.\n */\nextern size_t MHD_strx_to_uint64_n_(const char *str, size_t len, uint64_t *out);\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  FILE *log = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER get_nonce_timestamp: nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n            (const void *)nonce, noncelen, (void *)ptimestamp);\n  }\n\n  if (0 == noncelen)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"noncelen == 0: calling strlen(nonce)\\n\");\n    }\n\n    /*\n     * This strlen can read beyond the bounds of the nonce object if nonce\n     * is not NUL-terminated; this is the scenario that violates MISRA C 2023\n     * Rule 21.17.\n     */\n    noncelen = strlen (nonce);\n\n    if (log != NULL)\n    {\n      fprintf(log, \"strlen returned noncelen=%zu\\n\", noncelen);\n    }\n  }\n\n  if (true\n  #ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n  #endif /* MHD_MD5_SUPPORT */\n  #if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n  #endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"length check failed: noncelen=%zu -> return false\\n\", noncelen);\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"calling MHD_strx_to_uint64_n_ at offset %zu for %zu chars\\n\",\n            (noncelen >= TIMESTAMP_CHARS_LEN_LOCAL) ? (noncelen - TIMESTAMP_CHARS_LEN_LOCAL) : 0u,\n            (size_t)TIMESTAMP_CHARS_LEN_LOCAL);\n  }\n\n  if (TIMESTAMP_CHARS_LEN_LOCAL !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN_LOCAL,\n                             TIMESTAMP_CHARS_LEN_LOCAL,\n                             ptimestamp))\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"timestamp parse failed -> return false\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"success -> return true, timestamp=%\" PRIu64 \"\\n\", *ptimestamp);\n    fclose(log);\n  }\n\n  return true;\n}\n",
  "explanation": "The compile error was caused by a macro named TIMESTAMP_CHARS_LEN defined elsewhere; the macro was being expanded inside the file and broke the declaration. I renamed the local constant to TIMESTAMP_CHARS_LEN_LOCAL to avoid macro collision while preserving the original logic and value. I also added the necessary standard headers and declared the external function MHD_strx_to_uint64_n_ to avoid implicit-declaration errors. No macros or mock functions were introduced and the function logic remains unchanged aside from the identifier rename."
}