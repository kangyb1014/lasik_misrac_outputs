{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nlog_nonce_state(const char *stage, const char *nonce, size_t noncelen, const uint64_t *ptimestamp)\n{\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s: nonce=%s noncelen=%zu ptimestamp_ptr=%p\",\n                stage, (nonce != NULL) ? nonce : \"(null)\", noncelen, (const void *)ptimestamp);\n        if (ptimestamp != NULL)\n        {\n            /* print as unsigned long long to avoid needing PRIu64 */\n            fprintf(f, \" ptimestamp_val=%llu\", (unsigned long long)(*ptimestamp));\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  log_nonce_state(\"entry\", nonce, noncelen, ptimestamp);\n\n  if (0 == noncelen)\n  {\n    /* Violation scenario: the function assigns to the parameter 'noncelen' */\n    noncelen = strlen (nonce);\n    log_nonce_state(\"after_len_assigned\", nonce, noncelen, ptimestamp);\n  }\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    log_nonce_state(\"length_mismatch\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n  {\n    log_nonce_state(\"timestamp_parse_failed\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  log_nonce_state(\"success\", nonce, noncelen, ptimestamp);\n  return true;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmprr4sm55g/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_nonce_timestamp as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n\n/* Helper constants replacing external macros (kept as const variables, not macros) */\nstatic const size_t TIMESTAMP_CHARS_LEN = 10; /* e.g. 10-digit UNIX timestamp */\nstatic const size_t MD5_DIGEST_SIZE = 16;\nstatic const size_t SHA256_SHA512_256_DIGEST_SIZE = 32;\n\nstatic inline size_t\nnonce_std_len(size_t digest_size)\n{\n    /* typical representation: hex digest (2 chars per byte) + timestamp */\n    return (digest_size * 2) + TIMESTAMP_CHARS_LEN;\n}\n\n/* A simple parser that converts up to 'len' decimal digits from 's' into *out.\n   Returns the number of characters parsed. */\nstatic size_t\nMHD_strx_to_uint64_n_(const char *s, size_t len, uint64_t *out)\n{\n    size_t i = 0;\n    uint64_t val = 0;\n\n    if (s == NULL || len == 0 || out == NULL)\n        return 0;\n\n    for (; i < len; ++i)\n    {\n        if (!isdigit((unsigned char)s[i]))\n            break;\n        val = val * 10 + (uint64_t)(s[i] - '0');\n    }\n\n    *out = val;\n    return i;\n}\n\nstatic void\nlog_nonce_state(const char *stage, const char *nonce, size_t noncelen, const uint64_t *ptimestamp)\n{\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s: nonce=%s noncelen=%zu ptimestamp_ptr=%p\",\n                stage, (nonce != NULL) ? nonce : \"(null)\", noncelen, (const void *)ptimestamp);\n        if (ptimestamp != NULL)\n        {\n            /* print as unsigned long long to avoid needing PRIu64 */\n            fprintf(f, \" ptimestamp_val=%llu\", (unsigned long long)(*ptimestamp));\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  log_nonce_state(\"entry\", nonce, noncelen, ptimestamp);\n\n  if (0 == noncelen)\n  {\n    /* Preserve original intent: assign length when caller passed 0.\n       Avoid calling strlen on NULL to prevent UB. */\n    if (nonce != NULL)\n    {\n      noncelen = strlen (nonce);\n      log_nonce_state(\"after_len_assigned\", nonce, noncelen, ptimestamp);\n    }\n  }\n\n  if (true\n      && (nonce_std_len(MD5_DIGEST_SIZE) != noncelen)\n      && (nonce_std_len(SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n      )\n  {\n    log_nonce_state(\"length_mismatch\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_(nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n  {\n    log_nonce_state(\"timestamp_parse_failed\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  log_nonce_state(\"success\", nonce, noncelen, ptimestamp);\n  return true;\n}\n",
  "explanation": "Fixed compilation issues by adding required headers and replacing external macros with internal const variables and an inline helper (nonce_std_len) instead of macros. Implemented a small, real parser MHD_strx_to_uint64_n_ to convert the timestamp substring to uint64_t. Added a null check before calling strlen to avoid undefined behavior if nonce is NULL. Preserved the original logic and function signatures while keeping the code self-contained and compilable (no macros, no main, no mock functions)."
}