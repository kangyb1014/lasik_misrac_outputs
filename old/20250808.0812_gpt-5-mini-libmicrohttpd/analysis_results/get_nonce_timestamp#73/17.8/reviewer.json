{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs when the incoming noncelen parameter is zero. The function assigns to the parameter (noncelen = strlen(nonce);), i.e. it modifies a function parameter passed by value. This breaks MISRA C 2023 Rule 17.8 (a function parameter should not be modified). The specific control path is: entry -> noncelen == 0 -> assignment to noncelen -> subsequent processing uses the modified noncelen to compute the timestamp substring and parse it.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const size_t TIMESTAMP_CHARS_LEN = 10;\nstatic const size_t MD5_DIGEST_SIZE = 16;\nstatic const size_t SHA256_SHA512_256_DIGEST_SIZE = 32;\nstatic inline size_t\nnonce_std_len(size_t digest_size)\n{\n    /* typical representation: hex digest (2 chars per byte) + timestamp */\n    return (digest_size * 2) + TIMESTAMP_CHARS_LEN;\n}\nstatic void\nlog_nonce_state(const char *stage, const char *nonce, size_t noncelen, const uint64_t *ptimestamp)\n{\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s: nonce=%s noncelen=%zu ptimestamp_ptr=%p\",\n                stage, (nonce != NULL) ? nonce : \"(null)\", noncelen, (const void *)ptimestamp);\n        if (ptimestamp != NULL)\n        {\n            /* print as unsigned long long to avoid needing PRIu64 */\n            fprintf(f, \" ptimestamp_val=%llu\", (unsigned long long)(*ptimestamp));\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  log_nonce_state(\"entry\", nonce, noncelen, ptimestamp);\n\n  if (0 == noncelen)\n  {\n    /* Preserve original intent: assign length when caller passed 0.\n       Avoid calling strlen on NULL to prevent UB. */\n    if (nonce != NULL)\n    {\n      noncelen = strlen (nonce);\n      log_nonce_state(\"after_len_assigned\", nonce, noncelen, ptimestamp);\n    }\n  }\n\n  if (true\n      && (nonce_std_len(MD5_DIGEST_SIZE) != noncelen)\n      && (nonce_std_len(SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n      )\n  {\n    log_nonce_state(\"length_mismatch\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_(nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n  {\n    log_nonce_state(\"timestamp_parse_failed\", nonce, noncelen, ptimestamp);\n    return false;\n  }\n\n  log_nonce_state(\"success\", nonce, noncelen, ptimestamp);\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; this includes scalar (by-value) parameters. In the provided get_nonce_timestamp implementation, when noncelen == 0 the code assigns to the parameter noncelen (noncelen = strlen(nonce);), which is a direct modification of a function parameter and thus violates Rule 17.8. (Modifying the object pointed to by a pointer parameter would be allowed, but that exception does not apply to plain by-value parameters like noncelen.)\n\nA compliant fix is to use a local variable (for example, size_t len = noncelen;) and modify that local copy instead of the parameter, e.g. if (len == 0) len = strlen(nonce); then use len in the rest of the function."
}