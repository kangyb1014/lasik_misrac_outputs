{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n                     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd = MHD_INVALID_SOCKET;\n  const struct sockaddr *pservaddr = NULL;\n  socklen_t addrlen;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n  struct MHD_InterimParams_ *interim_params;\n\n  MHD_check_global_init_ ();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n\n  if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n    *pflags |= MHD_USE_INTERNAL_POLLING_THREAD; /* Force enable, log warning later if needed */\n\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n  {\n#ifdef UPGRADE_SUPPORT\n    *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n    return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n#ifdef MHD_USE_THREADS\n  if ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD) ==\n      ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD)\n       & *pflags))\n    return NULL; /* Cannot be thread-unsafe with multiple threads */\n#else  /* ! MHD_USE_THREADS */\n  if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    return NULL;\n#endif /* ! MHD_USE_THREADS */\n\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_EPOLL)) &&\n      (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_POLL)) &&\n      (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD\n                        | MHD_USE_THREAD_PER_CONNECTION))))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_AUTO)) &&\n      (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))))\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n  {\n#if defined(EPOLL_SUPPORT) && defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_POLL;\n    else\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#elif defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n      *pflags |= MHD_USE_POLL; /* Including thread-per-connection */\n#elif defined(EPOLL_SUPPORT)\n    if (0 == (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#else\n    /* No choice: use select() for any mode - do not modify flags */\n#endif\n  }\n\n  if (0 != (*pflags & MHD_USE_NO_THREAD_SAFETY))\n    *pflags = (*pflags & ~((enum MHD_FLAG) MHD_USE_ITC)); /* useless in single-threaded environment */\n  else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n  {\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n    *pflags |= MHD_USE_ITC;       /* yes, must use ITC to signal thread */\n  }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n  interim_params = (struct MHD_InterimParams_ *) \\\n                   MHD_calloc_ (1, sizeof (struct MHD_InterimParams_));\n  if (NULL == interim_params)\n  {\n    int err_num = errno;\n    free (daemon);\n    errno = err_num;\n    return NULL;\n  }\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listen_is_unix = _MHD_NO;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->client_discipline = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ?\n                              1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout_ms = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&daemon->tid);\n#endif /* MHD_USE_THREADS */\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = &MHD_default_logger_;\n  daemon->custom_error_log_cls = stderr;\n#endif\n#ifndef MHD_WINSOCK_SOCKETS\n  daemon->sigpipe_blocked = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  /* There is no SIGPIPE on W32, nothing to block. */\n  daemon->sigpipe_blocked = true;\n#endif /* _WIN32 && ! __CYGWIN__ */\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  daemon->avoid_accept4 = false;\n#endif /* _DEBUG */\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  daemon->fdset_size = (int) FD_SETSIZE;\n  daemon->fdset_size_set_by_app = false;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n  daemon->dauth_def_nonce_timeout = MHD_DAUTH_DEF_TIMEOUT_;\n  daemon->dauth_def_max_nc = MHD_DAUTH_DEF_MAX_NC_;\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n  }\n#endif /* HTTPS_SUPPORT */\n\n  interim_params->num_opts = 0;\n  interim_params->fdset_size_set = false;\n  interim_params->fdset_size = 0;\n  interim_params->listen_fd_set = false;\n  interim_params->listen_fd = MHD_INVALID_SOCKET;\n  interim_params->pserver_addr_set = false;\n  interim_params->pserver_addr = NULL;\n  interim_params->server_addr_len_set = false;\n  interim_params->server_addr_len = 0;\n\n  if (MHD_NO == parse_options_va (daemon,\n                                  interim_params,\n                                  ap))\n  {\n#ifdef HTTPS_SUPPORT\n    if ( (0 != (*pflags & MHD_USE_TLS)) &&\n         (NULL != daemon->priority_cache) )\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  if (! process_interim_params (daemon,\n                                &pservaddr,\n                                &addrlen,\n                                interim_params))\n  {\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  free (interim_params);\n  interim_params = NULL;\n#ifdef HTTPS_SUPPORT\n  if ((0 != (*pflags & MHD_USE_TLS))\n      && (NULL == daemon->priority_cache)\n      && ! daemon_tls_priorities_init_default (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialise GnuTLS priorities.\\n\"));\n#endif /* HAVE_MESSAGES */\n    free (daemon);\n    return NULL;\n  }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (flags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used \" \\\n                 \"only with MHD_USE_INTERNAL_POLLING_THREAD. \" \\\n                 \"Flag MHD_USE_INTERNAL_POLLING_THREAD was added. \" \\\n                 \"Consider setting MHD_USE_INTERNAL_POLLING_THREAD \" \\\n                 \"explicitly.\\n\"));\n  }\n#endif\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)\n      && ((NULL != daemon->notify_completed)\n          || (NULL != daemon->notify_connection)) )\n    *pflags |= MHD_USE_ITC; /* requires ITC */\n\n#ifdef _DEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            _ (\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* _DEBUG */\n\n  if ( (0 != (*pflags & MHD_USE_ITC))\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n       && (0 == daemon->worker_pool_size)\n#endif\n       )\n  {\n    if (! MHD_itc_init_ (daemon->itc))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create inter-thread communication channel: %s\\n\"),\n                MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (daemon->itc), daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"file descriptor for inter-thread communication \" \\\n                   \"channel exceeds maximum value.\\n\"));\n#endif\n      MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#ifdef DAUTH_SUPPORT\n  if (NULL != daemon->digest_auth_random_copy)\n  {\n    mhd_assert (daemon == daemon->digest_auth_random_copy);\n    daemon->digest_auth_random_copy = malloc (daemon->digest_auth_rand_size);\n    if (NULL == daemon->digest_auth_random_copy)\n    {\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    memcpy (daemon->digest_auth_random_copy,\n            daemon->digest_auth_random,\n            daemon->digest_auth_rand_size);\n    daemon->digest_auth_random = daemon->digest_auth_random_copy;\n  }\n  if (daemon->nonce_nc_size > 0)\n  {\n    if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc)))\n         / sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Specified value for NC_SIZE too large.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n    daemon->nnc = MHD_calloc_ (daemon->nonce_nc_size,\n                               sizeof (struct MHD_NonceNc));\n    if (NULL == daemon->nnc)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize nonce-nc mutex.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n    if (0 != (*pflags & MHD_USE_TLS))\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n    free (daemon);\n    return NULL;\n  }\n#endif\n#endif\n\n  /* Thread polling currently works only with internal select thread mode */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! MHD_D_IS_USING_THREADS_ (daemon)) &&\n       (daemon->worker_pool_size > 0) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD thread polling only works with \" \\\n                 \"MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif\n    goto free_and_fail;\n  }\n#endif\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n  {\n    /* try to open listen socket */\n    struct sockaddr_in servaddr4;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 servaddr6;\n    const bool use_ipv6 = (0 != (*pflags & MHD_USE_IPv6));\n#else  /* ! HAVE_INET6 */\n    const bool use_ipv6 = false;\n#endif /* ! HAVE_INET6 */\n    int domain;\n\n    if (NULL != pservaddr)\n    {\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      const socklen_t sa_len = pservaddr->sa_len;\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#ifdef HAVE_INET6\n      if (use_ipv6 && (AF_INET6 != pservaddr->sa_family))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_USE_IPv6 is enabled, but 'struct sockaddr *' \" \\\n                     \"specified for MHD_OPTION_SOCK_ADDR_LEN or \" \\\n                     \"MHD_OPTION_SOCK_ADDR is not IPv6 address.\\n\"));\n#endif /* HAVE_MESSAGES */\n        goto free_and_fail;\n      }\n#endif /* HAVE_INET6 */\n      switch (pservaddr->sa_family)\n      {\n      case AF_INET:\n        if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;\n#ifdef HAVE_INET6\n      case AF_INET6:\n        if (1)\n        {\n          struct sockaddr_in6 sa6;\n          uint16_t sa6_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa6)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa6)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa6);\n          memcpy (&sa6, pservaddr, sizeof(sa6));  /* Required due to stronger alignment */\n          sa6_port = (uint16_t) ntohs (sa6.sin6_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa6_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa6_port;\n          domain = PF_INET6;\n          *pflags |= ((enum MHD_FLAG) MHD_USE_IPv6);\n        }\n        break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n#endif /* AF_UNIX */\n      default:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n        if (0 == addrlen)\n          addrlen = sa_len;\n        else if ((0 != sa_len) && (sa_len < addrlen))\n          addrlen = sa_len; /* Use smaller value for safety */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n        if (0 >= addrlen)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"The 'sa_family' of the 'struct sockaddr' provided \" \\\n                       \"via MHD_OPTION_SOCK_ADDR option is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n          goto free_and_fail;\n        }\n#ifdef AF_UNIX\n        if (AF_UNIX == pservaddr->sa_family)\n        {\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n#ifdef PF_UNIX\n          domain = PF_UNIX;\n#else /* ! PF_UNIX */\n          domain = AF_UNIX;\n#endif /* ! PF_UNIX */\n        }\n        else /* combined with the next 'if' */\n#endif /* AF_UNIX */\n        if (1)\n        {\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          /* Assumed the same values for AF_* and PF_* */\n          domain = pservaddr->sa_family;\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (! use_ipv6)\n      {\n        memset (&servaddr4,\n                0,\n                sizeof (struct sockaddr_in));\n        servaddr4.sin_family = AF_INET;\n        servaddr4.sin_port = htons (port);\n        if (0 != INADDR_ANY)\n          servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n        servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr4;\n        addrlen = (socklen_t) sizeof(servaddr4);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET;\n      }\n#ifdef HAVE_INET6\n      else\n      {\n#ifdef IN6ADDR_ANY_INIT\n        static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n        memset (&servaddr6,\n                0,\n                sizeof (struct sockaddr_in6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n        servaddr6.sin6_addr = static_in6any;\n#endif\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n        servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr6;\n        addrlen = (socklen_t) sizeof (servaddr6);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET6;\n      }\n#endif /* HAVE_INET6 */\n    }\n\n    listen_fd = MHD_socket_create_listen_ (domain);\n    if (MHD_INVALID_SOCKET == listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create socket for listening: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n\n    /* Apply the socket options according to listening_address_reuse. */\n    if (0 == daemon->listening_address_reuse)\n    {\n#ifndef MHD_WINSOCK_SOCKETS\n      /* No user requirement, use \"traditional\" default SO_REUSEADDR\n       * on non-W32 platforms, and do not fail if it doesn't work.\n       * Don't use it on W32, because on W32 it will allow multiple\n       * bind to the same address:port, like SO_REUSEPORT on others. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n    }\n    else if (daemon->listening_address_reuse > 0)\n    {\n      /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n      /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n       * it doesn't work. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n      /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n       * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n       */\n      /* SO_REUSEADDR on W32 has the same semantics\n         as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                          SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                          SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n      /* we're supposed to allow address:port re-use, but\n         on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot allow listening address reuse: \" \\\n                   \"SO_REUSEPORT not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n    }\n    else   /* if (daemon->listening_address_reuse < 0) */\n    {\n      /* User requested to disallow reusing listening address:port.\n       * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n       * is used and Solaris with SO_EXCLBIND.\n       * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n       * or setsockopt fails.\n       */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n      (defined(__sun) && defined(SO_EXCLBIND))\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                          SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                          SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot disallow listening address reuse: \" \\\n                   \"SO_EXCLUSIVEADDRUSE not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n\n    /* check for user supplied sockaddr */\n    daemon->listen_fd = listen_fd;\n\n    if (0 != (*pflags & MHD_USE_IPv6))\n    {\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n      /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n         (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n         and may also be missing on older POSIX systems; good luck if you have any of those,\n         your IPv6 socket may then also bind against IPv4 anyway... */\n      const MHD_SCKT_OPT_BOOL_ v6_only =\n        (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n      if (0 > setsockopt (listen_fd,\n                          IPPROTO_IPV6, IPV6_V6ONLY,\n                          (const void *) &v6_only,\n                          sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n    }\n    if (0 != bind (listen_fd, pservaddr, addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to bind to port %u: %s\\n\"),\n                (unsigned int) port,\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n#ifdef TCP_FASTOPEN\n    if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    {\n      if (0 == daemon->fastopen_queue_size)\n        daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n      if (0 != setsockopt (listen_fd,\n                           IPPROTO_TCP,\n                           TCP_FASTOPEN,\n                           (const void *) &daemon->fastopen_queue_size,\n                           sizeof (daemon->fastopen_queue_size)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n    }\n#endif\n    if (0 != listen (listen_fd,\n                     (int) daemon->listen_backlog_size))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to listen for connections: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n  }\n  else\n  {\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) daemon->listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      goto free_and_fail;\n    }\n    else\n    {\n#if defined(SOL_SOCKET) && (defined(SO_DOMAIN) || defined(SO_PROTOCOL_INFOW))\n      int af;\n      int opt_name;\n      void *poptval;\n      socklen_t optval_size;\n#ifdef SO_DOMAIN\n      opt_name = SO_DOMAIN;\n      poptval = &af;\n      optval_size = (socklen_t) sizeof (af);\n#else  /* SO_PROTOCOL_INFOW */\n      WSAPROTOCOL_INFOW prot_info;\n      opt_name = SO_PROTOCOL_INFOW;\n      poptval = &prot_info;\n      optval_size = (socklen_t) sizeof (prot_info);\n#endif /* SO_PROTOCOL_INFOW */\n\n      if (0 == getsockopt (daemon->listen_fd,\n                           SOL_SOCKET,\n                           opt_name,\n                           poptval,\n                           &optval_size))\n      {\n#ifndef SO_DOMAIN\n        af = prot_info.iAddressFamily;\n#endif /* SO_DOMAIN */\n        switch (af)\n        {\n        case AF_INET:\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#ifdef HAVE_INET6\n        case AF_INET6:\n          *pflags |= MHD_USE_IPv6;\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n        case AF_UNIX:\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n          break;\n#endif /* AF_UNIX */\n        default:\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          break;\n        }\n      }\n      else\n#endif /* SOL_SOCKET && (SO_DOMAIN || SO_PROTOCOL_INFOW)) */\n      daemon->listen_is_unix = _MHD_UNKNOWN;\n    }\n\n    listen_fd = daemon->listen_fd;\n#ifdef MHD_USE_GETSOCKNAME\n    daemon->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n  }\n\n#ifdef MHD_USE_GETSOCKNAME\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) &&\n       (_MHD_YES != daemon->listen_is_unix) )\n  {   /* Get port number. */\n    struct sockaddr_storage bindaddr;\n\n    memset (&bindaddr,\n            0,\n            sizeof (struct sockaddr_storage));\n    addrlen = sizeof (struct sockaddr_storage);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n    bindaddr.ss_len = (socklen_t) addrlen;\n#endif\n    if (0 != getsockname (listen_fd,\n                          (struct sockaddr *) &bindaddr,\n                          &addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef MHD_POSIX_SOCKETS\n    else if (sizeof (bindaddr) < addrlen)\n    {\n      /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number \" \\\n                   \"(`struct sockaddr_storage` too small!?).\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifndef __linux__\n    else if (0 == addrlen)\n    {\n      /* Many non-Linux-based platforms return zero addrlen\n       * for AF_UNIX sockets */\n      daemon->port = 0;     /* special value for UNIX domain sockets */\n      if (_MHD_UNKNOWN == daemon->listen_is_unix)\n        daemon->listen_is_unix = _MHD_YES;\n    }\n#endif /* __linux__ */\n#endif /* MHD_POSIX_SOCKETS */\n    else\n    {\n      switch (bindaddr.ss_family)\n      {\n      case AF_INET:\n        {\n          struct sockaddr_in *s4 = (struct sockaddr_in *) &bindaddr;\n\n          daemon->port = ntohs (s4->sin_port);\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n        }\n#ifdef HAVE_INET6\n      case AF_INET6:\n        {\n          struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &bindaddr;\n\n          daemon->port = ntohs (s6->sin6_port);\n          daemon->listen_is_unix = _MHD_NO;\n          mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n          break;\n        }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n        daemon->port = 0;     /* special value for UNIX domain sockets */\n        daemon->listen_is_unix = _MHD_YES;\n        break;\n#endif\n      default:\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Listen socket has unknown address family!\\n\"));\n#endif\n        daemon->port = 0;     /* ugh */\n        daemon->listen_is_unix = _MHD_UNKNOWN;\n        break;\n      }\n    }\n  }\n#endif /* MHD_USE_GETSOCKNAME */\n\n  if (MHD_INVALID_SOCKET != listen_fd)\n  {\n    mhd_assert (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    if (! MHD_socket_nonblocking_ (listen_fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          || (daemon->worker_pool_size > 0)\n#endif\n          )\n      {\n        /* Accept must be non-blocking. Multiple children may wake up\n         * to handle a new connection, but only one will win the race.\n         * The others must immediately return. */\n        MHD_socket_close_chk_ (listen_fd);\n        listen_fd = MHD_INVALID_SOCKET;\n        goto free_and_fail;\n      }\n      daemon->listen_nonblk = false;\n    }\n    else\n      daemon->listen_nonblk = true;\n  }\n  else\n  {\n    mhd_assert (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    daemon->listen_nonblk = false; /* Actually listen socket does not exist */\n  }\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      && (0 == daemon->worker_pool_size)\n#endif\n      )\n  {\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Combining MHD_USE_THREAD_PER_CONNECTION and \" \\\n                   \"MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_NO == setup_epoll_to_listen (daemon))\n      goto free_and_fail;\n  }\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize IP connection limit mutex.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    goto free_and_fail;\n  }\n#endif\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialize TLS support.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    goto free_and_fail;\n  }\n#endif /* HTTPS_SUPPORT */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Start threads if requested by parameters */\n  if (MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    /* Internal thread (or threads) is used.\n     * Make sure that MHD will be able to communicate with threads. */\n    /* If using a thread pool ITC will be initialised later\n     * for each individual worker thread. */\n#ifdef HAVE_LISTEN_SHUTDOWN\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)) || \\\n                (MHD_INVALID_SOCKET != daemon->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n    if (0 == daemon->worker_pool_size)\n    {\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_create_named_thread_ (&daemon->tid,\n                                      MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) ?\n                                      \"MHD-listen\" : \"MHD-single\",\n                                      daemon->thread_stack_size,\n                                      &MHD_polling_thread,\n                                      daemon) )\n      {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n        if (EAGAIN == errno)\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a new thread because it would have \" \\\n                       \"exceeded the system limit on the number of threads or \" \\\n                       \"no system resources available.\\n\"));\n        else\n#endif /* EAGAIN */\n        MHD_DLOG (daemon,\n                  _ (\"Failed to create listen thread: %s\\n\"),\n                  MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n        MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n    }\n    else   /* 0 < daemon->worker_pool_size */\n    {\n      /* Coarse-grained count of connections per thread (note error\n       * due to integer division). Also keep track of how many\n       * connections are leftover after an equal split. */\n      unsigned int conns_per_thread = daemon->connection_limit\n                                      / daemon->worker_pool_size;\n      unsigned int leftover_conns = daemon->connection_limit\n                                    % daemon->worker_pool_size;\n\n      mhd_assert (2 <= daemon->worker_pool_size);\n      i = 0;     /* we need this in case fcntl or malloc fails */\n\n      /* Allocate memory for pooled objects */\n      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                    * daemon->worker_pool_size);\n      if (NULL == daemon->worker_pool)\n        goto thread_failed;\n\n      /* Start the workers in the pool */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n      {\n        /* Create copy of the Daemon object for each worker */\n        struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n        memcpy (d, daemon, sizeof (struct MHD_Daemon));\n        /* Adjust polling params for worker daemons; note that memcpy()\n           has already copied MHD_USE_INTERNAL_POLLING_THREAD thread mode into\n           the worker threads. */\n        d->master = daemon;\n        d->worker_pool_size = 0;\n        d->worker_pool = NULL;\n        if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n          goto thread_failed;\n        }\n        if (! MHD_mutex_init_ (&d->new_connections_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise mutex.\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n        if (0 != (*pflags & MHD_USE_ITC))\n        {\n          if (! MHD_itc_init_ (d->itc))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create worker inter-thread \" \\\n                         \"communication channel: %s\\n\"),\n                      MHD_itc_last_strerror_ () );\n#endif\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n          if (MHD_D_IS_USING_SELECT_ (d) &&\n              (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (d->itc), daemon)) )\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"File descriptor for worker inter-thread \" \\\n                         \"communication channel exceeds maximum value.\\n\"));\n#endif\n            MHD_itc_destroy_chk_ (d->itc);\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n        }\n        else\n          MHD_itc_set_invalid_ (d->itc);\n\n#ifdef HAVE_LISTEN_SHUTDOWN\n        mhd_assert ((MHD_ITC_IS_VALID_ (d->itc)) || \\\n                    (MHD_INVALID_SOCKET != d->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (MHD_ITC_IS_VALID_ (d->itc));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n\n        /* Divide available connections evenly amongst the threads.\n         * Thread indexes in [0, leftover_conns) each get one of the\n         * leftover connections. */\n        d->connection_limit = conns_per_thread;\n        if (i < leftover_conns)\n          ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (d) &&\n            (MHD_NO == setup_epoll_to_listen (d)) )\n        {\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n#endif\n        /* Some members must be used only in master daemon */\n#if defined(MHD_USE_THREADS)\n        memset (&d->per_ip_connection_mutex, 0x7F,\n                sizeof(d->per_ip_connection_mutex));\n#endif /* MHD_USE_THREADS */\n#ifdef DAUTH_SUPPORT\n        d->nnc = NULL;\n        d->nonce_nc_size = 0;\n        d->digest_auth_random_copy = NULL;\n#if defined(MHD_USE_THREADS)\n        memset (&d->nnc_lock, 0x7F, sizeof(d->nnc_lock));\n#endif /* MHD_USE_THREADS */\n#endif /* DAUTH_SUPPORT */\n\n        /* Spawn the worker thread */\n        if (! MHD_create_named_thread_ (&d->tid,\n                                        \"MHD-worker\",\n                                        daemon->thread_stack_size,\n                                        &MHD_polling_thread,\n                                        d))\n        {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == errno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new pool thread because it would \" \\\n                         \"have exceeded the system limit on the number of \" \\\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create pool thread: %s\\n\"),\n                    MHD_strerror_ (errno));\n#endif\n          /* Free memory for this worker; cleanup below handles\n           * all previously-created workers. */\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n      }\n    }\n  }\n  else\n  { /* Daemon without internal threads */\n    if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n    if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  }\n#endif\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif\n\nfree_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}, 'parse_options_va': {'callees': ['MHD_DLOG', 'parse_options'], 'callers': ['parse_options', 'MHD_start_daemon_va']}, 'process_interim_params': {'callees': ['MHD_DLOG'], 'callers': ['MHD_start_daemon_va']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}, 'MHD_socket_nonblocking_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_start_daemon_va']}, 'setup_epoll_to_listen': {'callees': ['setup_epoll_fd', 'MHD_DLOG'], 'callers': ['MHD_start_daemon_va']}, 'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}, 'MHD_stop_daemon': {'callees': ['__builtin_unreachable', 'MHD_stop_daemon', 'close_all_connections'], 'callers': ['MHD_start_daemon_va', 'MHD_stop_daemon', 'main', 'run_mhd']}, 'MHD_start_daemon': {'callees': ['MHD_start_daemon_va'], 'callers': ['main', 'run_mhd']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "parse_options_va",
    "parse_options",
    "va_list (stdarg.h representation / ABI details such as whether va_list is a pointer or an array type)",
    "prototype/signature of parse_options_va (to see whether it takes va_list by value or by pointer)"
  ],
  "explanation": "1) parse_options_va: MHD_start_daemon_va forwards the parameter 'ap' (va_list ap) directly to parse_options_va. To determine whether the caller's parameter 'ap' is modified (which would violate the MISRA rule for non-pointer parameters), we must inspect parse_options_va's implementation/behavior. If parse_options_va manipulates the passed va_list in-place (and va_list is effectively an alias to caller state on the target ABI), that could mean the caller's parameter is modified.  \n\n2) parse_options: call graph shows parse_options_va delegates to parse_options. parse_options may itself consume/alter the va_list or perform operations that end up modifying the effective caller state. We need parse_options implementation to establish whether any modification of the caller's 'ap' parameter occurs.  \n\n3) va_list (stdarg.h representation / ABI details): Whether passing a va_list to a callee modifies the caller's va_list depends on the platform/ABI representation of va_list (it may be an array type, a pointer, or a struct). To decide if the call to parse_options_va can modify the caller's 'ap' parameter (i.e., the parameter object in MHD_start_daemon_va), we must know the concrete representation/semantics of va_list on the target build (and whether parse_options_va uses va_arg/va_copy without copying).  \n\n4) prototype/signature of parse_options_va: The exact prototype (e.g., whether the third parameter is 'va_list' or 'va_list *' or some macro-expanded variant) is required to know whether parse_options_va receives ap by value or by address. If it expects a pointer to va_list, the caller would have to take &ap (not present), so signature mismatch would be revealing; if it receives va_list by value but then uses it without va_copy, platform semantics still decide whether caller ap is affected. \n\nThese symbols/definitions are sufficient to determine whether MHD_start_daemon_va itself (through direct assignments) modifies any of its parameters, and to decide if passing 'ap' to callees leads to modification of the caller's parameter object under the target ABI (the only parameter potentially affected here)."
}