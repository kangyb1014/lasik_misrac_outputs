{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp to compare authentication username and password to string literals (\"Aladdin\" and \"open sesame\"). Even though it first checks lengths, memcmp is still used to compare C strings; this violates MISRA C 2023 Rule 21.14 which forbids using memcmp to compare null-terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstruct MHD_BasicAuthInfo {\n  char *username;\n  size_t username_len;\n  char *password;\n  size_t password_len;\n};\nextern struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection);\nextern void MHD_free (struct MHD_BasicAuthInfo *info);\nextern struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size, const void *buffer);\nextern enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         enum MHD_Result need_auth,\n                                         struct MHD_Response *response);\nextern enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection, int status_code,\n                    struct MHD_Response *response);\nextern void MHD_destroy_response (struct MHD_Response *response);\nstatic const char DENIED[] = \"Denied\";\nstatic const char PAGE[] = \"OK\";\nstatic void log_probe(const char *stage,\n                      const char *method,\n                      const char *username, size_t username_len,\n                      const char *password, size_t password_len,\n                      int cmp_user_res, int cmp_pass_res,\n                      int fail)\n{\n  FILE *f = fopen(\"/tmp/logs/534.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  fprintf(f, \"stage=%s\\n\", stage ? stage : \"(null)\");\n  fprintf(f, \"method=%s\\n\", method ? method : \"(null)\");\n  fprintf(f, \"username_ptr=%p, username_len=%zu\\n\", (const void *) username, username_len);\n  if (NULL != username)\n  {\n    size_t i;\n    fprintf(f, \"username_hex=\");\n    for (i = 0U; i < username_len && i < 32U; ++i)\n    {\n      fprintf(f, \"%02x\", (unsigned int) (unsigned char) username[i]);\n    }\n    if (username_len > 32U)\n    {\n      fprintf(f, \"..(truncated)\");\n    }\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"memcmp_username_result=%d\\n\", cmp_user_res);\n\n  fprintf(f, \"password_ptr=%p, password_len=%zu\\n\", (const void *) password, password_len);\n  if (NULL != password)\n  {\n    size_t i;\n    fprintf(f, \"password_hex=\");\n    for (i = 0U; i < password_len && i < 32U; ++i)\n    {\n      fprintf(f, \"%02x\", (unsigned int) (unsigned char) password[i]);\n    }\n    if (password_len > 32U)\n    {\n      fprintf(f, \"..(truncated)\");\n    }\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"memcmp_password_result=%d\\n\", cmp_pass_res);\n  fprintf(f, \"final_fail=%d\\n\", fail);\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  int cmp_user_res = 0;\n  int cmp_pass_res = 0;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  /* Evaluate comparisons in steps to allow logging of intermediate results */\n  if (NULL == auth_info)\n  {\n    /* log attempt with no auth info */\n    log_probe(\"no_auth_info\", method, NULL, 0U, NULL, 0U, 0, 0, 1);\n    fail = 1; /* true */\n  }\n  else\n  {\n    /* Check username length first */\n    if (strlen (\"Aladdin\") != auth_info->username_len)\n    {\n      cmp_user_res = 1; /* non-zero to indicate mismatch */\n    }\n    else\n    {\n      cmp_user_res = memcmp (auth_info->username, \"Aladdin\",\n                              auth_info->username_len);\n    }\n\n    /* Check password length first (note: password may be NULL) */\n    if (NULL == auth_info->password)\n    {\n      cmp_pass_res = 1; /* indicate mismatch (password missing) */\n    }\n    else if (strlen (\"open sesame\") != auth_info->password_len)\n    {\n      cmp_pass_res = 1; /* mismatch */\n    }\n    else\n    {\n      cmp_pass_res = memcmp (auth_info->password, \"open sesame\",\n                              auth_info->password_len);\n    }\n\n    fail = ( (0 != cmp_user_res) || (0 != cmp_pass_res) );\n\n    /* Log the authentication check state and decisions */\n    log_probe(\"auth_check\", method,\n              auth_info->username, auth_info->username_len,\n              auth_info->password, auth_info->password_len,\n              cmp_user_res, cmp_pass_res, fail);\n  }\n\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct. Rule 21.14 forbids using memcmp to compare null\u2011terminated C strings (i.e. using memcmp where the intent/semantics are string comparison relying on '\\0'). In this code the comparisons are guarded by explicit length checks and memcmp is invoked with an explicit byte count derived from those lengths: username_len is compared to strlen(\"Aladdin\") and password_len to strlen(\"open sesame\") (and password is checked for NULL). Therefore memcmp is being used to compare fixed byte sequences of known length (excluding the terminating '\\0' from the literal since strlen() does not include it), not to perform an unbounded null\u2011terminated string comparison. In other words the code treats the credential fields as length\u2011specified buffers (which may not be null\u2011terminated) and only then compares the exact number of bytes \u2014 this is not what MISRA Rule 21.14 forbids. (If the intent were to compare C null\u2011terminated strings, then using strcmp/strncmp would be appropriate; but given the length checks and possible non\u2011NULL\u2011terminated auth_info fields, memcmp here is appropriate and does not violate 21.14.)"
}