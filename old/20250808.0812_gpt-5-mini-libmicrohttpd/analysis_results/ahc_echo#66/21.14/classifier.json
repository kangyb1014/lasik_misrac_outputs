{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified ahc_echo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/534.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\nJudge whether the above ahc_echo code violates the rule 21.14 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses memcmp to compare authentication username and password to string literals (\"Aladdin\" and \"open sesame\"). Even though it first checks lengths, memcmp is still used to compare C strings; this violates MISRA C 2023 Rule 21.14 which forbids using memcmp to compare null-terminated strings.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe helper: log control path and state to /tmp/logs/534.txt */\nstatic void log_probe(const char *stage,\n                      const char *method,\n                      const char *username, size_t username_len,\n                      const char *password, size_t password_len,\n                      int cmp_user_res, int cmp_pass_res,\n                      int fail)\n{\n  FILE *f = fopen(\"/tmp/logs/534.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  fprintf(f, \"stage=%s\\n\", stage ? stage : \"(null)\");\n  fprintf(f, \"method=%s\\n\", method ? method : \"(null)\");\n  fprintf(f, \"username_ptr=%p, username_len=%zu\\n\", (const void *) username, username_len);\n  if (NULL != username)\n  {\n    size_t i;\n    fprintf(f, \"username_hex=\");\n    for (i = 0U; i < username_len && i < 32U; ++i)\n    {\n      fprintf(f, \"%02x\", (unsigned int) (unsigned char) username[i]);\n    }\n    if (username_len > 32U)\n    {\n      fprintf(f, \"..(truncated)\");\n    }\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"memcmp_username_result=%d\\n\", cmp_user_res);\n\n  fprintf(f, \"password_ptr=%p, password_len=%zu\\n\", (const void *) password, password_len);\n  if (NULL != password)\n  {\n    size_t i;\n    fprintf(f, \"password_hex=\");\n    for (i = 0U; i < password_len && i < 32U; ++i)\n    {\n      fprintf(f, \"%02x\", (unsigned int) (unsigned char) password[i]);\n    }\n    if (password_len > 32U)\n    {\n      fprintf(f, \"..(truncated)\");\n    }\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"memcmp_password_result=%d\\n\", cmp_pass_res);\n  fprintf(f, \"final_fail=%d\\n\", fail);\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  int cmp_user_res = 0;\n  int cmp_pass_res = 0;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  /* Evaluate comparisons in steps to allow logging of intermediate results */\n  if (NULL == auth_info)\n  {\n    /* log attempt with no auth info */\n    log_probe(\"no_auth_info\", method, NULL, 0U, NULL, 0U, 0, 0, 1);\n    fail = 1; /* true */\n  }\n  else\n  {\n    /* Check username length first */\n    if (strlen (\"Aladdin\") != auth_info->username_len)\n    {\n      cmp_user_res = 1; /* non-zero to indicate mismatch */\n    }\n    else\n    {\n      cmp_user_res = memcmp (auth_info->username, \"Aladdin\",\n                              auth_info->username_len);\n    }\n\n    /* Check password length first (note: password may be NULL) */\n    if (NULL == auth_info->password)\n    {\n      cmp_pass_res = 1; /* indicate mismatch (password missing) */\n    }\n    else if (strlen (\"open sesame\") != auth_info->password_len)\n    {\n      cmp_pass_res = 1; /* mismatch */\n    }\n    else\n    {\n      cmp_pass_res = memcmp (auth_info->password, \"open sesame\",\n                              auth_info->password_len);\n    }\n\n    fail = ( (0 != cmp_user_res) || (0 != cmp_pass_res) );\n\n    /* Log the authentication check state and decisions */\n    log_probe(\"auth_check\", method,\n              auth_info->username, auth_info->username_len,\n              auth_info->password, auth_info->password_len,\n              cmp_user_res, cmp_pass_res, fail);\n  }\n\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}"
}