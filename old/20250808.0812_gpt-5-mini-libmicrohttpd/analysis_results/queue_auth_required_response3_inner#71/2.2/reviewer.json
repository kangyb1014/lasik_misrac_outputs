{
  "user_message": "An agent A claimed that the following queue_auth_required_response3_inner code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of queue_auth_required_response3_inner.\n```c\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo; /**< Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  if (0 == (((unsigned int) malgo3) & MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Only non-'session' algorithms are supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  malgo3 =\n    (enum MHD_DigestAuthMultiAlgo3)\n    (malgo3\n     & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    if (0 == (((unsigned int) malgo3)\n              & (MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_BASE_ALGO_SHA512_256\n                 | MHD_DIGEST_BASE_ALGO_SHA512_256)))\n      MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n    else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"No requested algorithm is supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC (_ (\"Wrong 'mqop' value, API violation\"));\n\n  mqop = (enum MHD_DigestAuthMultiQOP)\n         (mqop\n          & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n#ifdef HAVE_MESSAGES\n    if ((0 != userhash_support) || (0 != prefer_utf8))\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'userhash' and 'charset' ('prefer_utf8') parameters \" \\\n                   \"are not compatible with RFC2069 and ignored.\\n\"));\n    if (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n      MHD_DLOG (connection->daemon,\n                _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                   \"non-standard extension.\\n\"));\n#endif\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The nonce array size is zero.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_realm) + 3; /* 3 for '\", ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < realm_len)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'realm' is too large.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) ||\n      (NULL != memchr (realm, '\\n', realm_len)))\n    return MHD_NO;\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_qop) + 3; /* 3 for '\", ' */\n    buf_size += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_algo) + 2; /* 2 for ', ' */\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_nonce) + 3; /* 3 for '\", ' */\n  buf_size += NONCE_STD_LEN (digest_get_size (da)); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_opaque) + 3; /* 3 for '\", ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) ||\n        (NULL != memchr (opaque, '\\n', opaque_len)))\n      return MHD_NO;\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_domain) + 3; /* 3 for '\", ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) ||\n        (NULL != memchr (domain, '\\n', domain_len)))\n      return MHD_NO;\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += MHD_STATICSTR_LEN_ (str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += MHD_STATICSTR_LEN_ (str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += MHD_STATICSTR_LEN_ (str_stale) + 2; /* 2 for ', ' */\n\n  /* The calculated length is for string ended with \", \". One character will\n   * be used for zero-termination, the last one will not be used. */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE,\n          MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE));\n  p += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm,\n          MHD_STATICSTR_LEN_ (prefix_realm));\n  p += MHD_STATICSTR_LEN_ (prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  if (1)\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < quoted_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'realm' is too large after 'quoting'.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop,\n            MHD_STATICSTR_LEN_ (prefix_qop));\n    p += MHD_STATICSTR_LEN_ (prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_,\n            MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_));\n    p += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    }\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce,\n          MHD_STATICSTR_LEN_ (prefix_nonce));\n  p += MHD_STATICSTR_LEN_ (prefix_nonce);\n  mhd_assert ((buf_size - p) >= (NONCE_STD_LEN (digest_get_size (da))));\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"TLS library reported hash calculation error, nonce could \"\n                   \"not be generated.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Could not register nonce. Client's requests with this \"\n                 \"nonce will be always 'stale'. Probably clients' requests \"\n                 \"are too intensive.\\n\"));\n#endif /* HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning for builds without messages */\n  }\n  p += NONCE_STD_LEN (digest_get_size (da));\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque,\n            MHD_STATICSTR_LEN_ (prefix_opaque));\n    p += MHD_STATICSTR_LEN_ (prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain,\n            MHD_STATICSTR_LEN_ (prefix_domain));\n    p += MHD_STATICSTR_LEN_ (prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset,\n            MHD_STATICSTR_LEN_ (str_charset));\n    p += MHD_STATICSTR_LEN_ (str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash,\n            MHD_STATICSTR_LEN_ (str_userhash));\n    p += MHD_STATICSTR_LEN_ (str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale,\n            MHD_STATICSTR_LEN_ (str_stale));\n    p += MHD_STATICSTR_LEN_ (str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n            MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          MHD_STATICSTR_LEN_ ( \\\n                                            MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to add Digest auth header.\\n\"));\n    }\n#endif /* HAVE_MESSAGES */\n    free (hdr_name);\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement \"(void) 0;\" used to mute compiler warnings in the branch where calculate_add_nonce_with_retry() fails is executed but has no effect on program behaviour. In addition, invocations of mhd_assert(...) expand to ((void)0) (no-op). These executed no-op operations are dead code according to MISRA C 2023 Rule 2.2: their removal would not affect program behaviour.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_DigestAuthMultiQOP { MHD_DIGEST_AUTH_MULT_QOP_NONE = 0, MHD_DIGEST_AUTH_MULT_QOP_AUTH = 1, MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT = 2 };\nenum MHD_DigestAuthMultiAlgo3 { MHD_DIGEST_AUTH_ALGO3_NON_SESSION = 0x100u };\nenum MHD_DigestAuthAlgo3 { MHD_DIGEST_AUTH_ALGO3_MD5 = 1, MHD_DIGEST_AUTH_ALGO3_SHA256 = 2, MHD_DIGEST_AUTH_ALGO3_SHA512_256 = 4 };\nconst unsigned int MHD_DIGEST_BASE_ALGO_MD5 = 1u;\nconst unsigned int MHD_DIGEST_BASE_ALGO_SHA256 = 2u;\nconst unsigned int MHD_DIGEST_BASE_ALGO_SHA512_256 = 4u;\nconst char MHD_TOKEN_AUTH_[] = \"auth\";\nconst char _MHD_AUTH_DIGEST_BASE[] = \"Digest\";\nconst char _MHD_MD5_TOKEN[] = \"MD5\";\nconst char _MHD_SHA256_TOKEN[] = \"SHA-256\";\nconst char _MHD_SHA512_256_TOKEN[] = \"SHA-512/256\";\nconst char MHD_HTTP_HEADER_WWW_AUTHENTICATE[] = \"WWW-Authenticate\";\nconst char MHD_HTTP_HEADER_CONTENT_LENGTH[] = \"Content-Length\";\nconst int MHD_HEADER_KIND = 0;\nconst int MHD_HTTP_UNAUTHORIZED = 401;\nstatic inline void mhd_assert(int cond) { assert(cond); }\nstatic struct MHD_Daemon master_daemon = { .nonce_nc_size = 16 };\nstatic int digest_ext_error(struct DigestAlgorithm *da) { (void)da; return 0; }\nstatic int digest_init_one_time(struct DigestAlgorithm *da, int base_algo) { (void)da; (void)base_algo; return 1; }\nstatic int calculate_add_nonce_with_retry(struct MHD_Connection *c,\n                                          const char *realm,\n                                          struct DigestAlgorithm *da,\n                                          char *buf)\n{\n    (void)c; (void)realm;\n    unsigned int n = digest_get_size(da);\n    for (unsigned int i = 0; i < n; ++i) buf[i] = 'A' + (i % 26);\n    return 1; /* success */\n}\nstatic enum MHD_Result MHD_queue_response(struct MHD_Connection *connection,\n                                          int status_code,\n                                          struct MHD_Response *response)\n{\n    (void)connection; (void)status_code; (void)response;\n    /* For test purposes, return success. */\n    return MHD_YES;\n}\nstatic size_t MHD_str_quote(const char *in, size_t in_len, char *out, size_t out_size)\n{\n    size_t w = 0;\n    for (size_t i = 0; i < in_len; ++i)\n    {\n        char c = in[i];\n        if ((c == '\"' || c == '\\\\'))\n        {\n            if (w + 2 > out_size) break;\n            out[w++] = '\\\\';\n            out[w++] = c;\n        }\n        else\n        {\n            if (w + 1 > out_size) break;\n            out[w++] = c;\n        }\n    }\n    return w;\n}\nstatic void MHD_PANIC(const char *msg) { fprintf(stderr, \"PANIC: %s\\n\", msg); abort(); }\nstatic void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  /* Ensure directory exists; ignore errors */\n  (void) mkdir(\"/tmp/logs\", 0777);\n  FILE *f = fopen(\"/tmp/logs/570.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  (void) vfprintf(f, fmt, ap);\n  va_end(ap);\n  (void) fclose(f);\n}\n\nstatic unsigned int digest_get_size(struct DigestAlgorithm *da) { (void)da; return 16u; }\nstatic int get_base_digest_algo(enum MHD_DigestAuthAlgo3 a) { (void)a; return 0; }\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo = MHD_DIGEST_AUTH_ALGO3_MD5; /* Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  /* Probe log: entry and some key parameter values */\n  probe_log(\"enter: malgo3=0x%u, mqop=0x%u, userhash=%d, prefer_utf8=%d\\n\",\n            (unsigned int) malgo3, (unsigned int) mqop,\n            userhash_support, prefer_utf8);\n\n  if (0 == (((unsigned int) malgo3) & (unsigned int)MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n    probe_log(\"exit: malgo3 indicates session algorithm -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n  malgo3 = (enum MHD_DigestAuthMultiAlgo3)(malgo3 & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n\n  /* Choose supported algorithm in a stable order */\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n  {\n    /* No supported algorithm */\n    probe_log(\"exit: no supported algorithm -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC(\"Wrong 'mqop' value, API violation\");\n\n  mqop = (enum MHD_DigestAuthMultiQOP)(mqop & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC(\"Wrong 'algo' value, API violation\");\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n    probe_log(\"exit: nonce_nc_size == 0 -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += strlen(_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += strlen(prefix_realm) + 3; /* 3 for '\\\"', ' ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (1024 < realm_len) /* use a large limit instead of original macro */\n  {\n    probe_log(\"exit: realm too large -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) || (NULL != memchr (realm, '\\n', realm_len)))\n  {\n    probe_log(\"exit: realm contains CR/LF -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += strlen(prefix_qop) + 3; /* 3 for '\"', ' ' */\n    buf_size += strlen(MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) || (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += strlen(prefix_algo) + 2; /* 2 for ', ' */\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += strlen(_MHD_MD5_TOKEN);\n    else if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += strlen(_MHD_SHA256_TOKEN);\n    else if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += strlen(_MHD_SHA512_256_TOKEN);\n    else mhd_assert(0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += strlen(prefix_nonce) + 3; /* 3 for '\"', ' ' */\n  buf_size += (size_t)digest_get_size (da); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += strlen(prefix_opaque) + 3; /* 3 for '\"', ' ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) || (NULL != memchr (opaque, '\\n', opaque_len)))\n    {\n      probe_log(\"exit: opaque contains CR/LF -> MHD_NO\\n\");\n      return MHD_NO;\n    }\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += strlen(prefix_domain) + 3; /* 3 for '\"', ' ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) || (NULL != memchr (domain, '\\n', domain_len)))\n    {\n      probe_log(\"exit: domain contains CR/LF -> MHD_NO\\n\");\n      return MHD_NO;\n    }\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += strlen(str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += strlen(str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += strlen(str_stale) + 2; /* 2 for ', ' */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size + 1);\n  if (NULL == buf)\n  {\n    probe_log(\"exit: malloc failed -> MHD_NO\\n\");\n    return MHD_NO;\n  }\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE, strlen(_MHD_AUTH_DIGEST_BASE));\n  p += strlen(_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm, strlen(prefix_realm));\n  p += strlen(prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (1024 < quoted_size) /* same artificial limit */\n    {\n      probe_log(\"exit: realm too large after quoting -> MHD_NO\\n\");\n      free(buf);\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop, strlen(prefix_qop));\n    p += strlen(prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_, strlen(MHD_TOKEN_AUTH_));\n    p += strlen(MHD_TOKEN_AUTH_);\n    buf[p++] = '\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) || (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo, strlen(prefix_algo));\n    p += strlen(prefix_algo);\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN, strlen(_MHD_MD5_TOKEN));\n      p += strlen(_MHD_MD5_TOKEN);\n    }\n    else if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN, strlen(_MHD_SHA256_TOKEN));\n      p += strlen(_MHD_SHA256_TOKEN);\n    }\n    else if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN, strlen(_MHD_SHA512_256_TOKEN));\n      p += strlen(_MHD_SHA512_256_TOKEN);\n    }\n    else\n      mhd_assert(0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce, strlen(prefix_nonce));\n  p += strlen(prefix_nonce);\n  mhd_assert ((buf_size - p) >= (size_t)digest_get_size (da));\n  probe_log(\"calling calculate_add_nonce_with_retry (realm='%s')\\n\", realm);\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n    if (digest_ext_error (da))\n    {\n      probe_log(\"calculate_add_nonce_with_retry: digest_ext_error -> MHD_NO\\n\");\n      free(buf);\n      return MHD_NO;\n    }\n    probe_log(\"calculate_add_nonce_with_retry failed: digest_ext_error=%d; about to execute no-op (void)0\\n\", (int) digest_ext_error(da));\n    (void) 0;\n  }\n  p += (size_t)digest_get_size (da);\n  buf[p++] = '\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque, strlen(prefix_opaque));\n    p += strlen(prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain, strlen(prefix_domain));\n    p += strlen(prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset, strlen(str_charset));\n    p += strlen(str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash, strlen(str_userhash));\n    p += strlen(str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale, strlen(str_stale));\n    p += strlen(str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (strlen(MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE, strlen(MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          strlen(MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      probe_log(\"added header and queuing response -> MHD_queue_response\\n\");\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n    free (hdr_name);\n  }\n  probe_log(\"exit: falling through -> MHD_NO\\n\");\n  free(buf);\n  return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a MISRA 2.2 violation. The agent\u2019s argument rests on two assumptions: (a) mhd_assert expands to a no-op ((void)0), and (b) HAVE_MESSAGES (and any other related macros) are not defined in the project build so that the only thing executed in the failing branch is the literal \"(void)0;\". MISRA Rule 2.2 is evaluated for the project build configuration. If, in the actual project configuration, assertions are enabled or HAVE_MESSAGES is defined (or other conditional code produces side effects), the calls are not no-ops and therefore not dead. Conversely, only when the whole project is built such that every mhd_assert and any logging macros expand to ((void)0) and the branch in question is exercised at run-time would those executed no-op statements meet the literal definition of dead code. Because the code as presented uses conditional compilation and build-dependent macros, you cannot reliably claim a Rule 2.2 violation without examining the project\u2019s active configuration. The provided test did not produce runtime evidence (it failed to build), so it does not prove the violation. Therefore the report is not correct as a definitive MISRA 2.2 violation; it might be correct for a specific build configuration, but that was not demonstrated."
}