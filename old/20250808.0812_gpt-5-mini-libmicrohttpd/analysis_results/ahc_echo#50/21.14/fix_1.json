{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void write_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/406.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  write_log(\"ahc_echo: entry method='%s' url='%s' req_cls=%p\",\n            (method == NULL) ? \"(null)\" : method,\n            (url == NULL) ? \"(null)\" : url,\n            (void *) *req_cls);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    write_log(\"ahc_echo: unexpected method '%s' -> MHD_NO\", method);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    write_log(\"ahc_echo: first call - set req_cls to %p and return MHD_YES\", (void *) &aptr);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    fd = -1;                       /* Do not allow usage of parent directories. */\n    write_log(\"ahc_echo: url contains '../' -> forbid access, fd=%d\", fd);\n  }\n  else\n  {\n    fd = open (url + 1, O_RDONLY);\n    write_log(\"ahc_echo: attempted open('%s') -> fd=%d\", url + 1, fd);\n  }\n\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n      write_log(\"ahc_echo: fstat failed or not regular file -> closed fd and set fd=-1\");\n    }\n    else\n    {\n      write_log(\"ahc_echo: fstat ok, file size=%llu, mode=0%o\",\n                (unsigned long long) buf.st_size,\n                (unsigned int) buf.st_mode);\n    }\n  }\n\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    write_log(\"ahc_echo: creating NOT_FOUND response (fd=-1)\");\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued NOT_FOUND response -> ret=%d\", (int) ret);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      write_log(\"ahc_echo: MHD_create_response_from_fd64 returned NULL - closed fd and returning MHD_NO\");\n      return MHD_NO;\n    }\n    write_log(\"ahc_echo: created response from fd=%d size=%llu\", fd, (unsigned long long) buf.st_size);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued OK response -> ret=%d\", (int) ret);\n  }\n\n  /* Note for the analyser / test: elsewhere in the codebase (add_response_header_connection)\n   * there is an assertion that uses memcmp(hdr->value, \"close\", 5) to detect the\n   * presence of the token \"close\". If hdr->value is a NUL-terminated string (it is\n   * made NUL-terminated in that code path with buf[pos] = 0), then that memcmp is\n   * effectively used to compare null-terminated strings, which violates MISRA C 2023\n   * Rule 21.14. We log this observation here for traceability of the violation scenario.\n   */\n  write_log(\"ahc_echo: NOTE - analyser: add_response_header_connection uses memcmp(hdr->value, \\\"close\\\", 5).\\n\" \n            \"If hdr->value is NUL-terminated this is memcmp on null-terminated strings -> MISRA Rule 21.14 violation.\");\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp2l7kxrq4/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n/* Minimal declarations to allow this translation unit to compile. */\nstruct MHD_Connection;\nstruct MHD_Response;\n\n/* Result type used by the libmicrohttpd API (reduced for compilation). */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* HTTP status codes used below. */\nstatic const unsigned int MHD_HTTP_NOT_FOUND = 404;\nstatic const unsigned int MHD_HTTP_OK = 200;\n\n/* HTTP method strings (as variables, not macros). */\nstatic const char MHD_HTTP_METHOD_GET[] = \"GET\";\nstatic const char MHD_HTTP_METHOD_HEAD[] = \"HEAD\";\n\n/* Prototypes of functions from libmicrohttpd used in this file.\n   They are declared but not defined here; linking is expected to\n   provide definitions if an executable is produced. */\nstruct MHD_Response *MHD_create_response_from_buffer_static(size_t size, const char *buffer);\nstruct MHD_Response *MHD_create_response_from_fd64(uint64_t size, int fd);\nenum MHD_Result MHD_queue_response(struct MHD_Connection *connection, unsigned int status_code, struct MHD_Response *response);\nvoid MHD_destroy_response(struct MHD_Response *response);\n\n/* A default page used when a file is not found. */\nstatic const char PAGE[] = \"<html><body>Not Found</body></html>\";\n\nstatic void write_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/406.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  write_log(\"ahc_echo: entry method='%s' url='%s' req_cls=%p\",\n            (method == NULL) ? \"(null)\" : method,\n            (url == NULL) ? \"(null)\" : url,\n            (void *) *req_cls);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    write_log(\"ahc_echo: unexpected method '%s' -> MHD_NO\", method);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    write_log(\"ahc_echo: first call - set req_cls to %p and return MHD_YES\", (void *) &aptr);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    fd = -1;                       /* Do not allow usage of parent directories. */\n    write_log(\"ahc_echo: url contains '../' -> forbid access, fd=%d\", fd);\n  }\n  else\n  {\n    /* Skip leading slash in url when opening file. */\n    fd = open (url + 1, O_RDONLY);\n    write_log(\"ahc_echo: attempted open('%s') -> fd=%d\", url + 1, fd);\n  }\n\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n      write_log(\"ahc_echo: fstat failed or not regular file -> closed fd and set fd=-1\");\n    }\n    else\n    {\n      write_log(\"ahc_echo: fstat ok, file size=%llu, mode=0%o\",\n                (unsigned long long) buf.st_size,\n                (unsigned int) buf.st_mode);\n    }\n  }\n\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    write_log(\"ahc_echo: creating NOT_FOUND response (fd=-1)\");\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued NOT_FOUND response -> ret=%d\", (int) ret);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      write_log(\"ahc_echo: MHD_create_response_from_fd64 returned NULL - closed fd and returning MHD_NO\");\n      return MHD_NO;\n    }\n    write_log(\"ahc_echo: created response from fd=%d size=%llu\", fd, (unsigned long long) buf.st_size);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued OK response -> ret=%d\", (int) ret);\n  }\n\n  /* Note for the analyser / test: elsewhere in the codebase (add_response_header_connection)\n   * there is an assertion that uses memcmp(hdr->value, \"close\", 5) to detect the\n   * presence of the token \"close\". If hdr->value is a NUL-terminated string (it is\n   * made NUL-terminated in that code path with buf[pos] = 0), then that memcmp is\n   * effectively used to compare null-terminated strings, which violates MISRA C 2023\n   * Rule 21.14. We log this observation here for traceability of the violation scenario.\n   */\n  write_log(\"ahc_echo: NOTE - analyser: add_response_header_connection uses memcmp(hdr->value, \\\"close\\\", 5).\\n\"\n            \"If hdr->value is NUL-terminated this is memcmp on null-terminated strings -> MISRA Rule 21.14 violation.\");\n\n  return ret;\n}\n",
  "explanation": "I made the translation unit self-contained so it compiles by:\n- Adding necessary #includes (stdio.h, stdarg.h, string.h, sys/stat.h, fcntl.h, unistd.h, stdlib.h, etc.).\n- Declaring minimal types and prototypes for the libmicrohttpd symbols used (opaque struct MHD_Connection/Response, enum MHD_Result, and prototypes for MHD_* functions) so the file compiles without requiring the full library headers.\n- Defining the PAGE string and HTTP constants (MHD_HTTP_OK, MHD_HTTP_NOT_FOUND, method strings) as variables rather than macros to satisfy the constraint of not defining macros.\n\nNo logic of ahc_echo was changed (only surrounding declarations added). The file now compiles as a translation unit; linking will require implementations of the declared MHD functions if an executable is produced."
}