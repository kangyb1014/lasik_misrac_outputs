{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When a response already contains a \"Connection\" header and its value equals the token \"close\" (stored as a null-terminated string), add_response_header_connection uses memcmp(hdr->value, \"close\", 5) to test equality. That call uses memcmp to compare a null-terminated string (hdr->value) against a literal, which violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null terminated strings).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstatic const unsigned int MHD_HTTP_NOT_FOUND = 404;\nstatic const unsigned int MHD_HTTP_OK = 200;\nstatic const char MHD_HTTP_METHOD_GET[] = \"GET\";\nstatic const char MHD_HTTP_METHOD_HEAD[] = \"HEAD\";\nstruct MHD_Response *MHD_create_response_from_buffer_static(size_t size, const char *buffer);\nstruct MHD_Response *MHD_create_response_from_fd64(uint64_t size, int fd);\nenum MHD_Result MHD_queue_response(struct MHD_Connection *connection, unsigned int status_code, struct MHD_Response *response);\nvoid MHD_destroy_response(struct MHD_Response *response);\nstatic const char PAGE[] = \"<html><body>Not Found</body></html>\";\nstatic void write_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/406.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  write_log(\"ahc_echo: entry method='%s' url='%s' req_cls=%p\",\n            (method == NULL) ? \"(null)\" : method,\n            (url == NULL) ? \"(null)\" : url,\n            (void *) *req_cls);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    write_log(\"ahc_echo: unexpected method '%s' -> MHD_NO\", method);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    write_log(\"ahc_echo: first call - set req_cls to %p and return MHD_YES\", (void *) &aptr);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    fd = -1;                       /* Do not allow usage of parent directories. */\n    write_log(\"ahc_echo: url contains '../' -> forbid access, fd=%d\", fd);\n  }\n  else\n  {\n    /* Skip leading slash in url when opening file. */\n    fd = open (url + 1, O_RDONLY);\n    write_log(\"ahc_echo: attempted open('%s') -> fd=%d\", url + 1, fd);\n  }\n\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n      write_log(\"ahc_echo: fstat failed or not regular file -> closed fd and set fd=-1\");\n    }\n    else\n    {\n      write_log(\"ahc_echo: fstat ok, file size=%llu, mode=0%o\",\n                (unsigned long long) buf.st_size,\n                (unsigned int) buf.st_mode);\n    }\n  }\n\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    write_log(\"ahc_echo: creating NOT_FOUND response (fd=-1)\");\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued NOT_FOUND response -> ret=%d\", (int) ret);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      write_log(\"ahc_echo: MHD_create_response_from_fd64 returned NULL - closed fd and returning MHD_NO\");\n      return MHD_NO;\n    }\n    write_log(\"ahc_echo: created response from fd=%d size=%llu\", fd, (unsigned long long) buf.st_size);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n    write_log(\"ahc_echo: queued OK response -> ret=%d\", (int) ret);\n  }\n\n  /* Note for the analyser / test: elsewhere in the codebase (add_response_header_connection)\n   * there is an assertion that uses memcmp(hdr->value, \"close\", 5) to detect the\n   * presence of the token \"close\". If hdr->value is a NUL-terminated string (it is\n   * made NUL-terminated in that code path with buf[pos] = 0), then that memcmp is\n   * effectively used to compare null-terminated strings, which violates MISRA C 2023\n   * Rule 21.14. We log this observation here for traceability of the violation scenario.\n   */\n  write_log(\"ahc_echo: NOTE - analyser: add_response_header_connection uses memcmp(hdr->value, \\\"close\\\", 5).\\n\"\n            \"If hdr->value is NUL-terminated this is memcmp on null-terminated strings -> MISRA Rule 21.14 violation.\");\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in substance. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings. If, as the scenario states, add_response_header_connection calls memcmp(hdr->value, \"close\", 5) while hdr->value is a NUL\u2011terminated C string (buf[pos] = 0 makes it so), that use of memcmp is a MISRA 21.14 violation. Note that the ahc_echo code shown does not itself contain memcmp; the alleged violation lies in the other function (add_response_header_connection). If hdr->value were non\u2011NUL terminated binary data then memcmp would be appropriate, but given the scenario (hdr->value made NUL\u2011terminated) the report is correct and the code should use a string comparison function (e.g. strcmp/strncmp with proper length checks or otherwise ensure the comparison is not performed on null\u2011terminated strings)."
}