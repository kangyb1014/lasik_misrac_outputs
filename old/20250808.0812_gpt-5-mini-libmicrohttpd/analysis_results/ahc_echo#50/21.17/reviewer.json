{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A caller provides a url pointer that is not a valid NUL-terminated C string (for example a buffer that does not contain a terminating '\\0' within its allocated bounds). The call to strstr(url, \"../\") scans the url buffer until a NUL byte is found; if the url buffer is not NUL-terminated within its bounds this will read beyond the end of the object referenced by 'url' and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstruct MHD_Response {\n  size_t size;\n  int fd;           /* -1 for in-memory buffer */\n  const char *buf;  /* pointer to static buffer when fd == -1 */\n};\nstatic struct MHD_Response *\nMHD_create_response_from_buffer_static(size_t len, const char *buf)\n{\n  struct MHD_Response *r = (struct MHD_Response *) malloc(sizeof(*r));\n  if (NULL == r) return NULL;\n  r->size = len;\n  r->fd = -1;\n  r->buf = buf;\n  return r;\n}\nstatic struct MHD_Response *\nMHD_create_response_from_fd64(uint64_t size, int fd)\n{\n  struct MHD_Response *r = (struct MHD_Response *) malloc(sizeof(*r));\n  if (NULL == r) return NULL;\n  r->size = (size_t) size;\n  r->fd = fd;\n  r->buf = NULL;\n  return r;\n}\nstatic enum MHD_Result\nMHD_queue_response(struct MHD_Connection *connection, int code, struct MHD_Response *response)\n{\n  /* For this test stub we don't actually send anything. Return success. */\n  (void) connection;\n  (void) code;\n  (void) response;\n  return MHD_YES;\n}\nstatic void\nMHD_destroy_response(struct MHD_Response *response)\n{\n  if (NULL == response) return;\n  free(response);\n}\nstatic void probe_log(const char *tag, const char *url, const char *method,\n                      const void *req_cls, size_t url_len, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/407.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  /* Print pointer values and a few inspected bytes safely. */\n  (void) fprintf(f, \"[%s] tag=%s method_ptr=%p url_ptr=%p url_len=%zu req_cls=%p extra=%s\\n\",\n                 tag, tag, (const void *) method, (const void *) url, url_len, req_cls,\n                 (NULL != extra) ? extra : \"\");\n  if (NULL != url)\n  {\n    /* Print up to first 8 characters safely without reading beyond the single object\n       by checking characters individually (we still assume url is accessible). */\n    size_t i;\n    (void) fprintf(f, \"[%s] url_bytes=\\\"\", tag);\n    for (i = 0U; i < 8U; ++i)\n    {\n      char c = url[i];\n      if (c == '\\0')\n      {\n        break;\n      }\n      /* print printable characters; non-printable as hex */\n      if ((c >= 0x20) && (c < 0x7F))\n      {\n        (void) fputc((int) c, f);\n      }\n      else\n      {\n        (void) fprintf(f, \"\\\\x%02X\", (unsigned char) c);\n      }\n    }\n    (void) fprintf(f, \"\\\"\\n\");\n  }\n  (void) fclose(f);\n}\nstatic size_t safe_strlen(const char *s)\n{\n  if (NULL == s)\n  {\n    return 0U;\n  }\n  return strlen(s);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and basic inspected state. */\n  probe_log(\"enter\", url, method, (NULL == req_cls) ? NULL : *req_cls,\n            safe_strlen(url), \"start\");\n\n  if ( (0 != strcmp (method, \"GET\")) &&\n       (0 != strcmp (method, \"HEAD\")) )\n    return MHD_NO;              /* unexpected method */\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    probe_log(\"first_call\", url, method, *req_cls, safe_strlen(url), \"registered req_cls\");\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  probe_log(\"before_strstr\", url, method, *req_cls, safe_strlen(url), \"about to call strstr\");\n\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    probe_log(\"strstr_found\", url, method, *req_cls, safe_strlen(url), \"parent traversal detected\");\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  }\n  else\n  {\n    /* Log computed filename pointer (url+1). This is the location that may\n       point past the end of the url object if url is not a proper C string\n       or does not contain a leading '/'. */\n    probe_log(\"before_open\", url, method, *req_cls, safe_strlen(url), \"opening url+1\");\n    fd = open (url + 1, O_RDONLY);\n  }\n\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (\"PAGE\"),\n                                                       \"PAGE\");\n    ret = MHD_queue_response (connection, /* MHD_HTTP_NOT_FOUND */ 404, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, /* MHD_HTTP_OK */ 200, response);\n    MHD_destroy_response (response);\n  }\n\n  probe_log(\"exit\", url, method, *req_cls, safe_strlen(url), \"returning\");\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in the sense that the code as written can cause a <string.h> routine to read past the bounds of the object referenced by its pointer parameters unless a caller-side guarantee exists that the parameters are valid NUL-terminated strings. Specifically:\n\n- strstr(url, \"../\") requires that url points to a NUL-terminated character array. The function does not check url for NULL nor otherwise validate that it is NUL-terminated within its allocated bounds. If a caller passes a buffer that is not NUL-terminated within its object bounds, strstr will scan beyond the object and thus can violate MISRA C 2023 Rule 21.17.\n- Similarly, strcmp(method, \"GET\")/strcmp(method, \"HEAD\") assume method is a NUL-terminated string and are unchecked.\n- The later use open(url + 1, ...) also assumes url is at least one byte long and NUL-terminated; if url points at an empty string or not NUL-terminated this can produce out-of-bounds reads when the open implementation reads the pathname.\n\nIf the surrounding API (the code that calls ahc_echo) provides a documented, enforced contract that url and method are non-NULL and NUL-terminated within their object bounds, then the call sites comply with Rule 21.17 because the preconditions are satisfied by the caller. However, the ahc_echo implementation itself does not validate those preconditions, so in the absence of a guaranteed caller contract the code is potentially non-compliant. MISRA expects either that such preconditions are established by the calling context (and that this is documented/assured) or that the function checks/limits accesses (for example by using bounded string functions or by checking lengths) to ensure no out-of-bounds access can occur.\n\nTherefore Agent A\u2019s scenario is a valid demonstration of a potential Rule 21.17 violation unless a caller-side guarantee is present; the report is correct as a potential violation."
}