{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "enum MHD_Result",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_NO",
    "MHD_YES",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "daemon->shutdown",
    "daemon->options",
    "daemon->itc",
    "daemon->listen_fd",
    "daemon->was_quiesced",
    "daemon->connections",
    "daemon->connection_limit",
    "daemon->at_limit",
    "resume_suspended_connections",
    "internal_get_fdset2",
    "MHD_add_to_fd_set_",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_DLOG",
    "HAVE_MESSAGES",
    "FD_ZERO",
    "FD_SETSIZE",
    "TIMEVAL_TV_SEC_MAX",
    "SIZEOF_UINT64_T",
    "SIZEOF_STRUCT_TIMEVAL_TV_SEC",
    "_MHD_TIMEVAL_TV_SEC_TYPE",
    "MHD_get_timeout64",
    "MHD_SYS_select_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "internal_run_from_select"
  ],
  "explanation": "To determine whether MHD_select uses any compiler/language extensions, the verifier must inspect all macros, types and callees referenced by the function because extensions can be hidden in their definitions. For each listed symbol, the verifier should check its definition/implementation for use of language extensions (GCC/Clang builtins like __builtin_*, compiler-specific attributes, inline assembly, nonstandard keywords, variadic or nonstandard macros, nonstandard typedefs, or other documented compiler extensions).\n\nReason for each symbol:\n- struct MHD_Daemon: the function accesses many fields (shutdown, options, itc, listen_fd, was_quiesced, connections, connection_limit, at_limit). The struct definition might use bitfields, compiler attributes, or nonstandard layout/type aliases.\n- enum MHD_Result: check whether the enum uses compiler-specific extension (e.g., explicit underlying type via extension).\n- MHD_socket: platform/socket typedef may be an alias to a compiler-specific type or use attributes.\n- MHD_INVALID_SOCKET, MHD_NO, MHD_YES, MHD_TEST_ALLOW_SUSPEND_RESUME: macros/constants used in control flow; their definitions could use extensions (e.g., compound literals, statement expressions, __extension__ tokens).\n- MHD_D_IS_USING_THREAD_PER_CONN_: macro used in conditionals; macros can hide extensions or GCC-specific constructs.\n- daemon->shutdown, daemon->options, daemon->itc, daemon->listen_fd, daemon->was_quiesced, daemon->connections, daemon->connection_limit, daemon->at_limit: the accessed members \u2014 need the member declarations to ensure no compiler-specific attributes/bitfields or packed/unaligned attributes are used.\n- resume_suspended_connections: callee used in a conditional expression; its implementation (call graph shows it may call __builtin_unreachable) must be inspected for use of builtins or other extensions that affect correctness or violate MISRA rule.\n- internal_get_fdset2: implementation may use macros or inline functions with extensions; it also calls MHD_add_to_fd_set_.\n- MHD_add_to_fd_set_: likely a wrapper/macro for FD handling and may use nonstandard constructs or inline assembly.\n- MHD_ITC_IS_VALID_, MHD_itc_r_fd_: ITC-related macros/functions \u2014 inspect for extension usage.\n- MHD_DLOG: commonly a macro for logging; often implemented as a variadic macro or using compiler attributes (format) or statement-expression extensions \u2014 must be checked.\n- HAVE_MESSAGES: conditional compilation macro that enables MHD_DLOG usage \u2014 check how logging is defined when enabled.\n- FD_ZERO, FD_SETSIZE: macros from system headers; implementations vary and could be implemented as inline macros or functions \u2014 verify they are standard-conforming in the build environment.\n- TIMEVAL_TV_SEC_MAX, SIZEOF_UINT64_T, SIZEOF_STRUCT_TIMEVAL_TV_SEC: build-time macros used in #if and arithmetic; definitions may come from configure-generated headers using compiler-specific sizeof tricks or extensions.\n- _MHD_TIMEVAL_TV_SEC_TYPE: typedef/macro for timeval.tv_sec type used in an explicit cast \u2014 must ensure it is a standard type and not a compiler extension.\n- MHD_get_timeout64: callee used for timeout selection; its implementation might use extensions or nonstandard types (uint64_t uses stdint but wrapper may use extensions).\n- MHD_SYS_select_: wrapper around select; definition might map to platform-specific syscalls or use inline assembly or compiler-specific wrappers.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: socket error helpers \u2014 check for usage of builtins or nonstandard constructs.\n- internal_run_from_select: final callee that consumes fd_sets \u2014 its implementation could use extensions affecting behavior.\n\nInspecting the above symbols (their typedefs, macros and function bodies) is necessary and sufficient to determine whether MHD_select or any invoked macro/function uses language extensions disallowed by the MISRA rule."
}