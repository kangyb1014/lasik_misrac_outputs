{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe struct metal_sg fields are raw pointers but there is no indication they must be used to modify the pointed-to objects. According to MISRA C 2023 Rule 8.13 these pointer targets should be const-qualified where possible. For example, if metal_sg is used only to describe buffer addresses/regions for DMA operations and code does not modify the memory or the metal_io_region through these pointers, the declaration should be:\n\nstruct metal_sg {\n    const void *virt;                 /* CPU virtual address (read-only) */\n    const struct metal_io_region *io; /* IO region (read-only) */\n    int len;\n};\n\nAs written (void *virt; struct metal_io_region *io;) the code violates Rule 8.13. If, however, callers write through virt or modify the pointed metal_io_region object, then const would be inappropriate and the current declaration would not violate the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_uio_dev_dma_unmap code that contains useful probe functions that print useful logs to a file \"/tmp/logs/403.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_uio_dev_dma_unmap as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_dma_unmap:\n```c\nstatic void metal_uio_dev_dma_unmap(struct linux_bus *lbus,\n\t\t\t\t    struct linux_device *ldev,\n\t\t\t\t    uint32_t dir,\n\t\t\t\t    struct metal_sg *sg,\n\t\t\t\t    int nents)\n{\n\t(void) lbus;\n\t(void) ldev;\n\t(void) dir;\n\t(void) sg;\n\t(void) nents;\n}\n```\n</target_code>\nPlease provide the modified metal_uio_dev_dma_unmap code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe helpers to log control flow and state to /tmp/logs/403.txt. */\nstatic void metal_uio_log_open_and_header(FILE **out)\n{\n    *out = fopen(\"/tmp/logs/403.txt\", \"a\");\n    if (*out == NULL)\n    {\n        /* If the file cannot be opened, silently return so we do not change\n         * the original behavior of the function. */\n        return;\n    }\n    fprintf(*out, \"--- metal_uio_dev_dma_unmap probe ---\\n\");\n}\n\nstatic void metal_uio_log_entry(FILE *out,\n                                const char *prefix,\n                                struct linux_bus *lbus,\n                                struct linux_device *ldev,\n                                uint32_t dir,\n                                struct metal_sg *sg,\n                                int nents)\n{\n    if (out == NULL)\n    {\n        return;\n    }\n\n    fprintf(out, \"%s\\n\", prefix);\n    fprintf(out, \"  lbus=%p, ldev=%p, dir=0x%08x, sg=%p, nents=%d\\n\",\n            (void *)lbus, (void *)ldev, (unsigned)dir, (void *)sg, nents);\n\n    if (sg == NULL)\n    {\n        fprintf(out, \"  sg: NULL\\n\");\n        fflush(out);\n        return;\n    }\n\n    /* Log each scatter-gather entry if available. We only read pointer fields\n     * and lengths; we do not write through them. This preserves original\n     * semantics while producing evidence about the pointer targets. */\n    for (int i = 0; i < nents; ++i)\n    {\n        struct metal_sg *entry = &sg[i];\n        /* Protect against malformed nents values by checking pointer validity\n         * of the entry; we assume the caller's memory layout matches the\n         * expected struct metal_sg. These prints are informational only. */\n        fprintf(out, \"  sg[%d] = { virt=%p, io=%p, len=%d }\\n\",\n                i, (void *)entry->virt, (void *)entry->io, entry->len);\n    }\n\n    fflush(out);\n}\n\nstatic void metal_uio_log_close(FILE *out)\n{\n    if (out != NULL)\n    {\n        fprintf(out, \"--- end probe ---\\n\");\n        fclose(out);\n    }\n}\n\n/* The original function with logging probes inserted. The original logic is\n * preserved: the function performs no operations that change program state\n * other than creating diagnostic logs. */\nstatic void metal_uio_dev_dma_unmap(struct linux_bus *lbus,\n                                    struct linux_device *ldev,\n                                    uint32_t dir,\n                                    struct metal_sg *sg,\n                                    int nents)\n{\n    FILE *out = NULL;\n\n    /* Open log and write header */\n    metal_uio_log_open_and_header(&out);\n\n    /* Primary probe: top-level call info */\n    metal_uio_log_entry(out, \"Called metal_uio_dev_dma_unmap\", lbus, ldev, dir, sg, nents);\n\n    /* Additional probe: if there are no entries, note that explicitly. */\n    if (nents <= 0)\n    {\n        if (out != NULL)\n        {\n            fprintf(out, \"  Note: nents <= 0 (nents=%d)\\n\", nents);\n            fflush(out);\n        }\n    }\n\n    /* Keep original no-op behavior (function returns without performing\n     * device/DMA modifications). The probes above only read pointer fields\n     * and do not write through them, so they do not change constness\n     * requirements of the original code. */\n\n    metal_uio_log_close(out);\n\n    /* Explicitly cast to void for original unused-parameter intent to match\n     * the original code's intent (no functional changes). */\n    (void) lbus;\n    (void) ldev;\n    (void) dir;\n    (void) sg;\n    (void) nents;\n}\n"
}