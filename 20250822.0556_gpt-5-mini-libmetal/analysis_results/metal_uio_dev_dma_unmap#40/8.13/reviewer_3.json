{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_unmap code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_unmap.\n```c\nstatic void metal_uio_dev_dma_unmap(struct linux_bus *lbus,\n\t\t\t\t    struct linux_device *ldev,\n\t\t\t\t    uint32_t dir,\n\t\t\t\t    struct metal_sg *sg,\n\t\t\t\t    int nents)\n{\n\t(void) lbus;\n\t(void) ldev;\n\t(void) dir;\n\t(void) sg;\n\t(void) nents;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes pointer parameters that are not const-qualified although they are not modified or used (they are explicitly cast to void). Specifically, the parameters struct linux_bus *lbus, struct linux_device *ldev and struct metal_sg *sg could be const-qualified. This violates MISRA C 2023 R8.13. A compliant prototype would be, for example: static void metal_uio_dev_dma_unmap(const struct linux_bus *lbus, const struct linux_device *ldev, uint32_t dir, const struct metal_sg *sg, int nents).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_dma_unmap:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_device {\n\tstruct metal_device\t\tdevice;\n\tchar\t\t\t\tdev_name[PATH_MAX];\n\tchar\t\t\t\tdev_path[PATH_MAX];\n\tchar\t\t\t\tcls_path[PATH_MAX];\n\tmetal_phys_addr_t\t\tregion_phys[METAL_MAX_DEVICE_REGIONS];\n\tstruct linux_driver\t\t*ldrv;\n\tstruct sysfs_device\t\t*sdev;\n\tstruct sysfs_attribute\t\t*override;\n\tint\t\t\t\tfd;\n}\n...\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the posted definition metal_uio_dev_dma_unmap the pointer parameters (struct linux_bus *lbus, struct linux_device *ldev, struct metal_sg *sg) are not used or modified (they are cast to void), so they can and should be declared to point to const-qualified types in order to comply with MISRA C 2023 R8.13. A compliant signature like static void metal_uio_dev_dma_unmap(const struct linux_bus *lbus, const struct linux_device *ldev, uint32_t dir, const struct metal_sg *sg, int nents) would address the rule.\n\nNote the usual caveat: this change is only possible when the function does not need to match a non-const external prototype or be used where a specific (non-const) function-pointer type is required. Because the function is static (file scope) the risk of breaking an external interface is low, but if it is intended to match an API callback with non-const parameter types, the non-const signature may be required and the deviation should be justified."
}