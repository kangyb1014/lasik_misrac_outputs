{
  "user_message": "An agent A claimed that the following metal_run_noblock code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of metal_run_noblock.\n```c\nint metal_run_noblock(int threads, metal_thread_t child,\n\t\t     void *arg, void *tids, int *threads_out)\n{\n\tint error, i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\terror = -pthread_create(&tid_p[i], NULL, child, arg);\n\t\tif (error) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"failed to create thread - %s\\n\",\n\t\t\t\t  strerror(error));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*threads_out = i;\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to metal_run_noblock writes the number of created threads into the caller variable ts_created via the threads_out parameter, but in this caller (condition) ts_created is never read/used afterwards (metal_finish_threads is always called with THREADS, not ts_created). The write performed by metal_run_noblock (*threads_out = i) is therefore a dead store in this call path \u2014 an executed operation whose removal would not affect program behaviour \u2014 which violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[metal_run_noblock] start: time=1755843062, threads=10, tids=0x7fffaee23ef0, threads_out=0x7fffaee23f60\n[metal_run_noblock] creating thread index=0 at tid_p[0]=0x7fffaee23ef0\n[metal_run_noblock] pthread_create returned (negated)=0 for index=0\n[metal_run_noblock] creating thread index=1 at tid_p[1]=0x7fffaee23ef8\n[metal_run_noblock] pthread_create returned (negated)=0 for index=1\n[metal_run_noblock] creating thread index=2 at tid_p[2]=0x7fffaee23f00\n[metal_run_noblock] pthread_create returned (negated)=0 for index=2\n[metal_run_noblock] creating thread index=3 at tid_p[3]=0x7fffaee23f08\n[metal_run_noblock] pthread_create returned (negated)=0 for index=3\n[metal_run_noblock] creating thread index=4 at tid_p[4]=0x7fffaee23f10\n[metal_run_noblock] pthread_create returned (negated)=0 for index=4\n[metal_run_noblock] creating thread index=5 at tid_p[5]=0x7fffaee23f18\n[metal_run_noblock] pthread_create returned (negated)=0 for index=5\n[metal_run_noblock] creating thread index=6 at tid_p[6]=0x7fffaee23f20\n[metal_run_noblock] pthread_create returned (negated)=0 for index=6\n[metal_run_noblock] creating thread index=7 at tid_p[7]=0x7fffaee23f28\n[metal_run_noblock] pthread_create returned (negated)=0 for index=7\n[metal_run_noblock] creating thread index=8 at tid_p[8]=0x7fffaee23f30\n[metal_run_noblock] pthread_create returned (negated)=0 for index=8\n[metal_run_noblock] creating thread index=9 at tid_p[9]=0x7fffaee23f38\n[metal_run_noblock] pthread_create returned (negated)=0 for index=9\n[metal_run_noblock] assigned *threads_out = 10 (address=0x7fffaee23f60)\n[metal_run_noblock] final return error=0\n[metal_run_noblock] start: time=1755843062, threads=10, tids=0x7fffaee23f00, threads_out=0x7fffaee23f70\n[metal_run_noblock] creating thread index=0 at tid_p[0]=0x7fffaee23f00\n[metal_run_noblock] pthread_create returned (negated)=0 for index=0\n[metal_run_noblock] creating thread index=1 at tid_p[1]=0x7fffaee23f08\n[metal_run_noblock] pthread_create returned (negated)=0 for index=1\n[metal_run_noblock] creating thread index=2 at tid_p[2]=0x7fffaee23f10\n[metal_run_noblock] pthread_create returned (negated)=0 for index=2\n[metal_run_noblock] creating thread index=3 at tid_p[3]=0x7fffaee23f18\n[metal_run_noblock] pthread_create returned (negated)=0 for index=3\n[metal_run_noblock] creating thread index=4 at tid_p[4]=0x7fffaee23f20\n[metal_run_noblock] pthread_create returned (negated)=0 for index=4\n[metal_run_noblock] creating thread index=5 at tid_p[5]=0x7fffaee23f28\n[metal_run_noblock] pthread_create returned (negated)=0 for index=5\n[metal_run_noblock] creating thread index=6 at tid_p[6]=0x7fffaee23f30\n[metal_run_noblock] pthread_create returned (negated)=0 for index=6\n[metal_run_noblock] creating thread index=7 at tid_p[7]=0x7fffaee23f38\n[metal_run_noblock] pthread_create returned (negated)=0 for index=7\n[metal_run_noblock] creating thread index=8 at tid_p[8]=0x7fffaee23f40\n[metal_run_noblock] pthread_create returned (negated)=0 for index=8\n[metal_run_noblock] creating thread index=9 at tid_p[9]=0x7fffaee23f48\n[metal_run_noblock] pthread_create returned (negated)=0 for index=9\n[metal_run_noblock] assigned *threads_out = 10 (address=0x7fffaee23f70)\n[metal_run_noblock] final return error=0\n[metal_run_noblock] start: time=1755843062, threads=10, tids=0x7fffaee23f00, threads_out=0x7fffaee23f70\n[metal_run_noblock] creating thread index=0 at tid_p[0]=0x7fffaee23f00\n[metal_run_noblock] pthread_create returned (negated)=0 for index=0\n[metal_run_noblock] creating thread index=1 at tid_p[1]=0x7fffaee23f08\n[metal_run_noblock] pthread_create returned (negated)=0 for index=1\n[metal_run_noblock] creating thread index=2 at tid_p[2]=0x7fffaee23f10\n[metal_run_noblock] pthread_create returned (negated)=0 for index=2\n[metal_run_noblock] creating thread index=3 at tid_p[3]=0x7fffaee23f18\n[metal_run_noblock] pthread_create returned (negated)=0 for index=3\n[metal_run_noblock] creating thread index=4 at tid_p[4]=0x7fffaee23f20\n[metal_run_noblock] pthread_create returned (negated)=0 for index=4\n[metal_run_noblock] creating thread index=5 at tid_p[5]=0x7fffaee23f28\n[metal_run_n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_run_noblock:\nstatic int condition(void)\n{\n\tint ret;\n\tint ts_created;\n\tpthread_t tids[THREADS];\n\n\t/** TC1 consumer threads go first */\n\t/** create 10 consumer threads first */\n\tret = metal_run_noblock(THREADS, consumer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 producer threads next */\n\tret = metal_run(THREADS, producer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** wait for consumer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\n\t/** TC2 producer threads go first */\n\t/** create 10 producer threads first */\n\tret = metal_run_noblock(THREADS, producer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 consumer threads next */\n\tret = metal_run(THREADS, consumer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/** wait for producer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\treturn ret;\n}\n...\nint metal_run(int threads, metal_thread_t child, void *arg)\n{\n\tpthread_t tids[threads];\n\tint error, ts_created;\n\n\terror = metal_run_noblock(threads, child, arg, tids, &ts_created);\n\n\tmetal_finish_threads(ts_created, (void *)tids);\n\n\treturn error;\n}\n...\nvoid metal_finish_threads(int threads, void *tids)\n{\n\tint i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < threads; i++)\n\t\t(void)pthread_join(tid_p[i], NULL);\n}\n...\nstatic int atomic(void)\n{\n\tconst int threads = 10;\n\tatomic_int counter = ATOMIC_VAR_INIT(0);\n\tint value, error;\n\n\terror = metal_run(threads, atomic_thread, &counter);\n\tif (!error) {\n\t\tvalue = atomic_load(&counter);\n\t\tvalue -= atomic_test_count * threads;\n\t\tif (value) {\n\t\t\tmetal_log(METAL_LOG_DEBUG, \"counter mismatch, delta = %d\\n\",\n\t\t\t\t  value);\n\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\n\treturn error;\n}\n...\nmetal_mutex_t *mutex\n...\nstruct metal_generic_shmem *shmem\n...\nstatic int spinlock(void)\n{\n\tstruct metal_spinlock lock = METAL_SPINLOCK_INIT;\n\tconst int threads = 10;\n\tint value, error;\n\n\terror = metal_run(threads, spinlock_thread, &lock);\n\tif (!error) {\n\t\tvalue = total;\n\t\tvalue -= spinlock_test_count * threads;\n\t\tif (value) {\n\t\t\tmetal_log(METAL_LOG_DEBUG, \"counter mismatch, delta = %d\\n\",\n\t\t\t\t  value);\n\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\n\treturn error;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\ntypedef void *(*metal_thread_t)(void *)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the provided call path (condition()), metal_run_noblock is passed &ts_created but the caller never reads ts_created \u2014 subsequent joins use the constant THREADS. The assignment *threads_out = i is therefore an executed write whose removal (or omission) would not change program behaviour in that call path, which meets the definition of dead code in MISRA C 2023 Rule 2.2. Note that metal_run_noblock is also used by other callers (e.g. metal_run) that do use the threads_out result, so the write is meaningful in some contexts; however, the project contains executions (the condition() calls) where the write is dead, so the rule is violated. Recommended fixes: either make threads_out optional (have metal_run_noblock check if threads_out != NULL before writing) or make the callers use the returned ts_created value (or pass NULL when they do not need it)."
}