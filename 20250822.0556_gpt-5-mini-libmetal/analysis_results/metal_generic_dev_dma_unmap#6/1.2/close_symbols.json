{
  "user_message": "Target function code is:\n```c\nvoid metal_generic_dev_dma_unmap(struct metal_bus *bus,\n\t\t\t\t struct metal_device *device,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg,\n\t\t\t\t int nents)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\t(void)dir;\n\n\tfor (i = 0; i < nents; i++) {\n\t\tmetal_cache_invalidate(sg[i].virt, sg[i].len);\n\t}\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_unmap': {'callees': ['metal_cache_invalidate'], 'callers': []}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_cache_invalidate (declaration/definition and any macro expansion)",
    "struct metal_sg (full definition including types of fields 'virt' and 'len')",
    "struct metal_bus (definition)",
    "struct metal_device (definition)",
    "uint32_t typedef (definition / header that provides it, e.g. stdint.h)"
  ],
  "explanation": "metal_cache_invalidate: The target calls this symbol; it might be a function-like macro, inline function, or wrapper that uses compiler-specific extensions (inline asm, __attribute__, builtin functions, nonstandard calling conventions). You must inspect its declaration/definition and any macros that expand to it to detect language extensions. struct metal_sg: The code indexes sg[] and accesses fields 'virt' and 'len'. The field types or their declarations could use nonstandard extensions (bit-fields, packed/aligned attributes, GCC/clang-specific type attributes, flexible array members with extensions). struct metal_bus and struct metal_device: Even though they are only cast to void here, their definitions may contain compiler extensions (attributes on the types, nonstandard keywords) that affect whether the translation unit uses extensions. uint32_t typedef: Confirm that uint32_t comes from a standard header/type and is not a project-provided macro or typedef that uses compiler extensions (e.g., nonstandard integer types or typedefs with attributes). Checking these symbols is sufficient to determine whether this function's implementation depends on or uses any compiler language extensions."
}