{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe parameter sg_in is used only as an input (checked for NULL and forwarded to dev->bus->ops.dev_dma_map) and is not modified in metal_dma_map. According to MISRA C 2023 Rule 8.13, such pointers should be const-qualified (e.g. const struct metal_sg *sg_in). Leaving it as struct metal_sg *sg_in therefore violates the rule. (If the forwarded dev_dma_map actually needs to modify the buffer, then const cannot be applied; otherwise the dev_dma_map prototype should be changed to accept a const pointer as well.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_dma_map as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_dma_map:\n```c\nint metal_dma_map(struct metal_device *dev,\n\t\t  uint32_t dir,\n\t\t  struct metal_sg *sg_in,\n\t\t  int nents_in,\n\t\t  struct metal_sg *sg_out)\n{\n\tint nents_out;\n\n\tif (!dev || !sg_in || !sg_out)\n\t\treturn -EINVAL;\n\tif (!dev->bus->ops.dev_dma_map)\n\t\treturn -ENODEV;\n\n\t/* memory barrier */\n\tif (dir == METAL_DMA_DEV_R)\n\t\t/* If it is device read, apply memory write fence. */\n\t\tatomic_thread_fence(memory_order_release);\n\telse\n\t\t/* If it is device write or r/w, apply memory r/w fence. */\n\t\tatomic_thread_fence(memory_order_acq_rel);\n\tnents_out = dev->bus->ops.dev_dma_map(dev->bus,\n\t\t\tdev, dir, sg_in, nents_in, sg_out);\n\treturn nents_out;\n}\n```\n</target_code>\nPlease provide the modified metal_dma_map code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <errno.h>\n#include <stdatomic.h>\n#include <time.h>\n\n/* Minimal type declarations so this test snippet is self-contained.\n   In the real codebase these are provided elsewhere; they are duplicated\n   here only so this file can compile for testing the probes. */\nstruct metal_sg {\n    void *addr;\n    int len;\n    struct metal_sg *next;\n};\nstruct metal_device;\nstruct metal_bus_ops {\n    int (*dev_dma_map)(struct metal_device *bus_dev, struct metal_device *dev,\n                       uint32_t dir, struct metal_sg *sg_in, int nents_in,\n                       struct metal_sg *sg_out);\n};\nstruct metal_bus {\n    struct metal_bus_ops *ops;\n};\nstruct metal_device {\n    struct metal_bus *bus;\n};\n\n/* Define the device-read constant as an enum (not a macro) so this\n   snippet compiles standalone while not introducing a preprocessor macro. */\nenum { METAL_DMA_DEV_R = 0 };\n\n/* Logging helper: append an entry to /tmp/logs/3.txt. Keep logging minimal\n   and resilient; do not change program control flow. */\nstatic void metal_dma_map_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/3.txt\", \"a\");\n    if (!f)\n        return;\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] %s\\n\", (long)t, msg);\n    fclose(f);\n}\n\nint metal_dma_map(struct metal_device *dev,\n          uint32_t dir,\n          struct metal_sg *sg_in,\n          int nents_in,\n          struct metal_sg *sg_out)\n{\n    int nents_out;\n    /* Log entry with key pointer and parameter values. */\n    {\n        char buf[512];\n        snprintf(buf, sizeof(buf),\n            \"enter metal_dma_map: dev=%p dir=%u sg_in=%p nents_in=%d sg_out=%p\",\n            (void *)dev, (unsigned)dir, (void *)sg_in, nents_in, (void *)sg_out);\n        metal_dma_map_log(buf);\n    }\n\n    if (!dev || !sg_in || !sg_out) {\n        char buf[256];\n        snprintf(buf, sizeof(buf),\n            \"null-check failed: dev=%p sg_in=%p sg_out=%p -> return -EINVAL\",\n            (void *)dev, (void *)sg_in, (void *)sg_out);\n        metal_dma_map_log(buf);\n        return -EINVAL;\n    }\n\n    /* Preserve original check and control flow: inspect the bus ops pointer\n       exactly as in the original code and log the result. */\n    if (!dev->bus->ops.dev_dma_map) {\n        char buf[256];\n        /* Note: dev->bus and dev->bus->ops are dereferenced here exactly as\n           in the original function; this mirrors original behavior. */\n        snprintf(buf, sizeof(buf),\n            \"dev->bus->ops.dev_dma_map is NULL: bus=%p ops=%p -> return -ENODEV\",\n            (void *)dev->bus, (void *)dev->bus->ops);\n        metal_dma_map_log(buf);\n        return -ENODEV;\n    }\n\n    /* Log which memory fence will be applied. */\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"apply memory fence, dir=%u (%s)\",\n                 (unsigned)dir, (dir == METAL_DMA_DEV_R) ? \"METAL_DMA_DEV_R\" : \"OTHER\");\n        metal_dma_map_log(buf);\n    }\n\n    /* memory barrier (original logic preserved) */\n    if (dir == METAL_DMA_DEV_R)\n        /* If it is device read, apply memory write fence. */\n        atomic_thread_fence(memory_order_release);\n    else\n        /* If it is device write or r/w, apply memory r/w fence. */\n        atomic_thread_fence(memory_order_acq_rel);\n\n    /* Log the call to the underlying bus dev_dma_map with the parameters. */\n    {\n        char buf[512];\n        snprintf(buf, sizeof(buf),\n            \"calling dev_dma_map: bus=%p dev=%p dir=%u sg_in=%p nents_in=%d sg_out=%p\",\n            (void *)dev->bus, (void *)dev, (unsigned)dir, (void *)sg_in, nents_in, (void *)sg_out);\n        metal_dma_map_log(buf);\n    }\n\n    nents_out = dev->bus->ops.dev_dma_map(dev->bus,\n            dev, dir, sg_in, nents_in, sg_out);\n\n    /* Log the return value from the bus dev_dma_map. */\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"dev_dma_map returned %d\", nents_out);\n        metal_dma_map_log(buf);\n    }\n\n    return nents_out;\n}\n"
}