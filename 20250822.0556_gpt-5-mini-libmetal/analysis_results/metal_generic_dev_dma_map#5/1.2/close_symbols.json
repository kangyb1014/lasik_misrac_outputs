{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "memcpy",
    "<string.h> (memcpy macro/decl)",
    "uint32_t",
    "<stdint.h> (uint32_t decl)",
    "struct metal_sg (definition)",
    "METAL_DMA_DEV_W (macro/enum)",
    "metal_cache_flush (prototype/definition)",
    "metal_cache_invalidate (prototype/definition)",
    "struct metal_bus (definition)",
    "struct metal_device (definition)"
  ],
  "explanation": "For checking MISRA C violations that state language extensions must not be used, the analyzer needs the exact declarations/definitions that could introduce compiler-specific extensions or map to compiler intrinsics. Briefly:\n\n- memcpy and <string.h> (memcpy macro/decl): memcpy can be a library function, a macro, or be implemented/expanded as a compiler builtin (e.g. __builtin_memcpy). The header or declaration is required to see if a nonstandard macro, builtin alias, or compiler-specific attribute is used.\n\n- uint32_t and <stdint.h>: the explicit typedef origin should be confirmed as the standard stdint typedef rather than a compiler extension or nonstandard typedef.\n\n- struct metal_sg (definition): the layout or members could use nonstandard features (flexible-array members, typeof, bit-field extensions, packed/attribute annotations, inline assembly, or other GCC/MSVC extensions). The analyzer must inspect the struct to detect any extension tokens or attributes.\n\n- METAL_DMA_DEV_W (macro/enum): macros or enum values can be defined using compiler-specific constructs or macros that expand to builtin/extension tokens; the definition is needed to verify it is standard C.\n\n- metal_cache_flush and metal_cache_invalidate (prototypes/definitions): these callees may be declared with compiler-specific attributes (e.g., __attribute__, __asm__, inline assembly, builtin wrappers, or as macros to builtins). Their declarations/definitions are needed to detect any use of extensions that affect the target function.\n\n- struct metal_bus and struct metal_device (definitions): although only cast to void in the function, their definitions could contain extension usage (attributes on the types, nonstandard qualifiers) that might propagate into the translation unit or influence diagnostics.\n\nCollecting these symbols (and the headers that provide them) lets the next analyzer determine whether any identifiers used by the target function resolve to or expand into compiler-specific language extensions (builtins, attributes, asm, nonstandard keywords), which is what the MISRA rule requires checking."
}