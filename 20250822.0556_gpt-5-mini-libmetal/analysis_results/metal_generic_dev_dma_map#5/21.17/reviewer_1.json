{
  "user_message": "An agent A claimed that the following metal_generic_dev_dma_map code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_generic_dev_dma_map.\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen sg_out != sg_in and nents_in is greater than the number of elements actually allocated/available in the sg_out array: the memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) will copy past the bounds of sg_out, causing out\u2011of\u2011bounds accesses. The subsequent loop accessing sg_out[i].virt and sg_out[i].len can then read/write beyond the object bounds. This use of memcpy can therefore result in accesses beyond object bounds and violates MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function metal_generic_dev_dma_map:\nlong sizes[max_sizes]\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The memcpy call uses nents_in * sizeof(struct metal_sg) without any check that sg_out actually points to an array with at least nents_in elements. If a caller passes an nents_in larger than the number of allocated/available elements in sg_out, memcpy will copy beyond the bounds of sg_out (and the subsequent loop will access out\u2011of\u2011bounds elements), which directly contradicts MISRA C 2023 Rule 21.17. The code would be compliant only if an external, formally guaranteed precondition ensures sg_out has at least nents_in elements; absent such a guarantee or an in\u2011function check, the use of memcpy is unsafe and the report is correct."
}