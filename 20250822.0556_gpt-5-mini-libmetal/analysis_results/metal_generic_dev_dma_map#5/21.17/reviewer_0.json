{
  "user_message": "An agent A claimed that the following metal_generic_dev_dma_map code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_generic_dev_dma_map.\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The call memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) performs an unguarded copy whose size is computed solely from nents_in. There are no checks that sg_in and sg_out point to objects containing at least nents_in elements (nor checks for NULL), so if either buffer is smaller than nents_in elements the memcpy will read or write beyond the object bounds. Example: if sg_out was allocated for 2 struct metal_sg but nents_in == 3, memcpy copies 3*sizeof(struct metal_sg) and overruns sg_out \u2014 violating Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function metal_generic_dev_dma_map:\nlong sizes[max_sizes]\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The call memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) can result in out\u2011of\u2011bounds accesses because the function does not check that sg_in and sg_out actually reference objects large enough for nents_in elements (nor that they are non\u2011NULL). MISRA C 2023 Rule 21.17 requires that use of <string.h> functions must not result in accesses beyond the bounds of the referenced objects. Unless there is an external, documented and verifiable precondition (API contract or prior validation) that guarantees both buffers contain at least nents_in elements, this use of memcpy violates Rule 21.17."
}