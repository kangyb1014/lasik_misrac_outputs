{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) performs an unguarded copy whose size is computed solely from nents_in. There are no checks that sg_in and sg_out point to objects containing at least nents_in elements (nor checks for NULL), so if either buffer is smaller than nents_in elements the memcpy will read or write beyond the object bounds. Example: if sg_out was allocated for 2 struct metal_sg but nents_in == 3, memcpy copies 3*sizeof(struct metal_sg) and overruns sg_out \u2014 violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_generic_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/59.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_generic_dev_dma_map as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_generic_dev_dma_map:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\nPlease provide the modified metal_generic_dev_dma_map code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <inttypes.h>\n#include <unistd.h>\n\n/* Minimal type definitions to make this translation unit self-contained. */\nstruct metal_bus { int dummy; };\nstruct metal_device { int dummy; };\n\nstruct metal_sg {\n    void *virt;\n    size_t len;\n};\n\n/* Use a global const (not a macro) for the direction constant. */\nconst uint32_t METAL_DMA_DEV_W = 1U;\n\n/* Stub implementations for the cache operations so this file can be linked.\n   They preserve behavior (no-ops) but are provided so this unit is compilable. */\nvoid metal_cache_flush(void *addr, size_t len) { (void)addr; (void)len; }\nvoid metal_cache_invalidate(void *addr, size_t len) { (void)addr; (void)len; }\n\n/* Probe/logging helper: appends informative logs to /tmp/logs/59.txt. */\nstatic void __attribute__((unused)) log_dma_state(const char *tag,\n                                                  struct metal_sg *sg_in,\n                                                  struct metal_sg *sg_out,\n                                                  int nents_in,\n                                                  size_t copy_size,\n                                                  uint32_t dir)\n{\n    FILE *f = fopen(\"/tmp/logs/59.txt\", \"a\");\n    if (!f) return;\n    pid_t pid = getpid();\n    fprintf(f, \"[pid=%d] %s: sg_in=%p, sg_out=%p, nents_in=%d, copy_size=%zu, dir=%u\\n\",\n            (int)pid, tag, (void *)sg_in, (void *)sg_out, nents_in, copy_size, (unsigned)dir);\n    fclose(f);\n}\n\n/* Per-iteration logging: logs each SG entry as it is processed (addresses and fields). */\nstatic void __attribute__((unused)) log_sg_entry(int idx, struct metal_sg *sg)\n{\n    FILE *f = fopen(\"/tmp/logs/59.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"  entry[%d]: sg_ptr=%p, virt=%p, len=%zu\\n\",\n            idx, (void *)(sg + idx), (void)sg[idx].virt, sg[idx].len);\n    fclose(f);\n}\n\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n                             struct metal_device *device,\n                             uint32_t dir,\n                             struct metal_sg *sg_in,\n                             int nents_in,\n                             struct metal_sg *sg_out)\n{\n    int i;\n    (void)bus;\n    (void)device;\n\n    /* Log entry state. Do not dereference SG array contents here to avoid\n       introducing additional accesses earlier than the original code. */\n    size_t copy_size = (size_t)nents_in * sizeof(struct metal_sg);\n    log_dma_state(\"entry\", sg_in, sg_out, nents_in, copy_size, dir);\n\n    if (sg_out != sg_in) {\n        /* Log just before memcpy. We only log pointer values and sizes here. */\n        log_dma_state(\"before_memcpy\", sg_in, sg_out, nents_in, copy_size, dir);\n\n        memcpy(sg_out, sg_in, copy_size);\n\n        /* Log right after memcpy. */\n        log_dma_state(\"after_memcpy\", sg_in, sg_out, nents_in, copy_size, dir);\n    } else {\n        FILE *f = fopen(\"/tmp/logs/59.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"sg_out == sg_in: skip memcpy (sg_in=%p)\\n\", (void *)sg_in);\n            fclose(f);\n        }\n    }\n\n    for (i = 0; i < nents_in; i++) {\n        /* Log the SG entry as it is about to be processed. This mirrors the\n           original code's access pattern (sg_out[i] is accessed below), so\n           it does not introduce earlier or additional out-of-bounds accesses. */\n        log_sg_entry(i, sg_out);\n\n        if (dir == METAL_DMA_DEV_W) {\n            metal_cache_flush(sg_out[i].virt, sg_out[i].len);\n        }\n        metal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n    }\n\n    /* Final state log. */\n    log_dma_state(\"exit\", sg_in, sg_out, nents_in, copy_size, dir);\n\n    return nents_in;\n}\n"
}