{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg",
    "memcpy",
    "metal_cache_flush",
    "metal_cache_invalidate",
    "METAL_DMA_DEV_W"
  ],
  "explanation": "struct metal_sg: needed to know the layout and types of the fields (virt, len) so indexing sg_out[i] is understood as accessing/modifying the object pointed-to (allowed) rather than reassigning the pointer parameter itself (disallowed). memcpy: needed to confirm its semantics (writes to the memory pointed to by its destination argument) so the call memcpy(sg_out, sg_in, ...) modifies the objects pointed-to by sg_out/sg_in and does not reassign the sg_out or sg_in parameter variables. metal_cache_flush and metal_cache_invalidate: prototypes/signatures are required to verify they accept a pointer and length and operate on the memory referenced (i.e., they may modify pointees) and do not modify the sg_out or sg_in pointer parameters themselves. METAL_DMA_DEV_W: the constant/enum value is required to determine the branch condition (dir == METAL_DMA_DEV_W) and thus whether metal_cache_flush is invoked; this affects which operations on pointees occur but does not imply modification of the parameter variables themselves."
}