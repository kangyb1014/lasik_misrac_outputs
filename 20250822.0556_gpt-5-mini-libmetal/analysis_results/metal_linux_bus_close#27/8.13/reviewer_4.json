{
  "user_message": "An agent A claimed that the following metal_linux_bus_close code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_bus_close.\n```c\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter named sg_in is an input scatter\u2011gather list and is not const\u2011qualified. It should be declared as const struct metal_sg *sg_in if the function does not modify the pointee; as written the pointer to a non\u2011const type violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-22 06:04:52 - enter: metal_linux_bus_close(bus=0x7f61bbc11b80, lbus=0x7f61bbc11b80)\n2025-08-22 06:04:52 - loop: ldrv=0x7f61bbc11be0, ldrv->sdrv=0x5652541bca20\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5652541bca20\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5652541bca20\n2025-08-22 06:04:52 - after: ldrv=0x7f61bbc11be0, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - loop: ldrv=0x7f61bbc11c28, ldrv->sdrv=0x5652541bcbc0\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5652541bcbc0\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5652541bcbc0\n2025-08-22 06:04:52 - after: ldrv=0x7f61bbc11c28, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - before sysfs_close_bus: lbus->sbus=0x5652541bc8c0\n2025-08-22 06:04:52 - after sysfs_close_bus: lbus->sbus set to NULL\n2025-08-22 06:04:52 - exit: metal_linux_bus_close(bus=0x7f61bbc11b80)\n2025-08-22 06:04:52 - enter: metal_linux_bus_close(bus=0x7f61bbc12de8, lbus=0x7f61bbc12de8)\n2025-08-22 06:04:52 - loop: ldrv=0x7f61bbc12e48, ldrv->sdrv=0x5652541bcec0\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5652541bcec0\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5652541bcec0\n2025-08-22 06:04:52 - after: ldrv=0x7f61bbc12e48, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - loop: ldrv=0x7f61bbc12e90, ldrv->sdrv=0x5652541bd060\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5652541bd060\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5652541bd060\n2025-08-22 06:04:52 - after: ldrv=0x7f61bbc12e90, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - before sysfs_close_bus: lbus->sbus=0x5652541bcd60\n2025-08-22 06:04:52 - after sysfs_close_bus: lbus->sbus set to NULL\n2025-08-22 06:04:52 - exit: metal_linux_bus_close(bus=0x7f61bbc12de8)\n2025-08-22 06:04:52 - enter: metal_linux_bus_close(bus=0x5639b4864260, lbus=0x5639b4864260)\n2025-08-22 06:04:52 - loop: ldrv=0x5639b48642c0, ldrv->sdrv=0x5639c39dca20\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5639c39dca20\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5639c39dca20\n2025-08-22 06:04:52 - after: ldrv=0x5639b48642c0, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - loop: ldrv=0x5639b4864308, ldrv->sdrv=0x5639c39dcbc0\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5639c39dcbc0\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5639c39dcbc0\n2025-08-22 06:04:52 - after: ldrv=0x5639b4864308, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - before sysfs_close_bus: lbus->sbus=0x5639c39dc8c0\n2025-08-22 06:04:52 - after sysfs_close_bus: lbus->sbus set to NULL\n2025-08-22 06:04:52 - exit: metal_linux_bus_close(bus=0x5639b4864260)\n2025-08-22 06:04:52 - enter: metal_linux_bus_close(bus=0x5639b48654c8, lbus=0x5639b48654c8)\n2025-08-22 06:04:52 - loop: ldrv=0x5639b4865528, ldrv->sdrv=0x5639c39dcec0\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5639c39dcec0\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5639c39dcec0\n2025-08-22 06:04:52 - after: ldrv=0x5639b4865528, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - loop: ldrv=0x5639b4865570, ldrv->sdrv=0x5639c39dd060\n2025-08-22 06:04:52 - calling sysfs_close_driver on sdrv=0x5639c39dd060\n2025-08-22 06:04:52 - returned from sysfs_close_driver for sdrv (original pointer)=0x5639c39dd060\n2025-08-22 06:04:52 - after: ldrv=0x5639b4865570, ldrv->sdrv set to NULL\n2025-08-22 06:04:52 - before sysfs_close_bus: lbus->sbus=0x5639c39dcd60\n2025-08-22 06:04:52 - after sysfs_close_bus: lbus->sbus set to NULL\n2025-08-22 06:04:52 - exit: metal_linux_bus_close(bus=0x5639b48654c8)\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_bus_close:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The target function metal_linux_bus_close has no sg_in parameter \u2014 the agent confused a different symbol (dev_dma_map's sg_in) with the code under review. In metal_linux_bus_close the code obtains a non-const linux_driver pointer and explicitly modifies its sdrv member (sets it to NULL) and also sets lbus->sbus to NULL. Because the function modifies those pointees, they must not be const-qualified, so Rule 8.13 is not violated here. (Separately, the dev_dma_map prototype does use a non-const sg_in; whether that could/should be const depends on whether the implementation mutates the scatter\u2011gather entries and would need a separate analysis \u2014 it is not part of metal_linux_bus_close.)"
}