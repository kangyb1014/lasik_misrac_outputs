{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function-pointer type dev_dma_unmap uses non-const pointers (struct linux_bus *lbus, struct linux_device *ldev, struct metal_sg *sg). If the implementation of callbacks assigned to dev_dma_unmap does not modify the objects pointed to (for example it only reads the sg descriptors and consults lbus/ldev), then the parameters should be const-qualified and the current declaration violates MISRA C 2023 Rule 8.13. Example violation: an implementation that walks sg and only reads fields but the prototype lacks const; remedy: change the prototype to use const (e.g. const struct linux_bus *lbus, const struct linux_device *ldev, const struct metal_sg *sg) when mutation is not required.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_linux_bus_close code that contains useful probe functions that print useful logs to a file \"/tmp/logs/273.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_linux_bus_close as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_linux_bus_close:\n```c\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n```\n</target_code>\nPlease provide the modified metal_linux_bus_close code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n\n/* Probe logger: write control flow and state to /tmp/logs/273.txt */\nstatic void metal_probe_log(const char *note,\n                            const struct metal_bus *bus,\n                            const struct linux_bus *lbus,\n                            const struct linux_driver *ldrv,\n                            void *sdrv_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/273.txt\", \"a\");\n    if (!f)\n        return;\n\n    long long ts = (long long)time(NULL);\n    fprintf(f, \"%lld: %s: metal_bus=%p linux_bus=%p linux_driver=%p sdrv=%p\\n\",\n            ts, note, (const void *)bus, (const void *)lbus,\n            (const void *)ldrv, sdrv_ptr);\n    fclose(f);\n}\n\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n    struct linux_bus *lbus = to_linux_bus(bus);\n    struct linux_driver *ldrv;\n\n    /* Log entry and initial state */\n    metal_probe_log(\"enter metal_linux_bus_close\", bus, lbus, NULL, NULL);\n\n    for_each_linux_driver(lbus, ldrv) {\n        /* Log each iteration and the current sdrv pointer value */\n        void *sdrv_ptr = ldrv ? (void *)ldrv->sdrv : NULL;\n        metal_probe_log(\"iter start\", bus, lbus, ldrv, sdrv_ptr);\n\n        if (ldrv->sdrv) {\n            metal_probe_log(\"calling sysfs_close_driver\", bus, lbus, ldrv, sdrv_ptr);\n            sysfs_close_driver(ldrv->sdrv);\n            metal_probe_log(\"returned from sysfs_close_driver\", bus, lbus, ldrv, (void *)ldrv->sdrv);\n        }\n\n        ldrv->sdrv = NULL;\n        metal_probe_log(\"sdrv set to NULL\", bus, lbus, ldrv, NULL);\n    }\n\n    metal_probe_log(\"calling sysfs_close_bus\", bus, lbus, NULL, (void *)lbus->sbus);\n    sysfs_close_bus(lbus->sbus);\n    lbus->sbus = NULL;\n    metal_probe_log(\"bus closed and sbus set to NULL\", bus, lbus, NULL, NULL);\n\n    metal_probe_log(\"exit metal_linux_bus_close\", bus, lbus, NULL, NULL);\n}\n"
}