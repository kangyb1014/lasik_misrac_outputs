{
  "user_message": "An agent A claimed that the following metal_linux_bus_close code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_bus_close.\n```c\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function-pointer type dev_dma_unmap uses non-const pointers (struct linux_bus *lbus, struct linux_device *ldev, struct metal_sg *sg). If the implementation of callbacks assigned to dev_dma_unmap does not modify the objects pointed to (for example it only reads the sg descriptors and consults lbus/ldev), then the parameters should be const-qualified and the current declaration violates MISRA C 2023 Rule 8.13. Example violation: an implementation that walks sg and only reads fields but the prototype lacks const; remedy: change the prototype to use const (e.g. const struct linux_bus *lbus, const struct linux_device *ldev, const struct metal_sg *sg) when mutation is not required.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n1755842762: enter metal_linux_bus_close: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=(nil) sdrv=(nil)\n1755842762: iter start: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26bc0 sdrv=0x560c700c2a20\n1755842762: calling sysfs_close_driver: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26bc0 sdrv=0x560c700c2a20\n1755842762: returned from sysfs_close_driver: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26bc0 sdrv=0x560c700c2a20\n1755842762: sdrv set to NULL: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26bc0 sdrv=(nil)\n1755842762: iter start: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26c08 sdrv=0x560c700c2bc0\n1755842762: calling sysfs_close_driver: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26c08 sdrv=0x560c700c2bc0\n1755842762: returned from sysfs_close_driver: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26c08 sdrv=0x560c700c2bc0\n1755842762: sdrv set to NULL: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=0x7f1173c26c08 sdrv=(nil)\n1755842762: calling sysfs_close_bus: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=(nil) sdrv=0x560c700c28c0\n1755842762: bus closed and sbus set to NULL: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=(nil) sdrv=(nil)\n1755842762: exit metal_linux_bus_close: metal_bus=0x7f1173c26b60 linux_bus=0x7f1173c26b60 linux_driver=(nil) sdrv=(nil)\n1755842762: enter metal_linux_bus_close: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=(nil) sdrv=(nil)\n1755842762: iter start: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e28 sdrv=0x560c700c2ec0\n1755842762: calling sysfs_close_driver: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e28 sdrv=0x560c700c2ec0\n1755842762: returned from sysfs_close_driver: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e28 sdrv=0x560c700c2ec0\n1755842762: sdrv set to NULL: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e28 sdrv=(nil)\n1755842762: iter start: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e70 sdrv=0x560c700c3060\n1755842762: calling sysfs_close_driver: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e70 sdrv=0x560c700c3060\n1755842762: returned from sysfs_close_driver: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e70 sdrv=0x560c700c3060\n1755842762: sdrv set to NULL: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=0x7f1173c27e70 sdrv=(nil)\n1755842762: calling sysfs_close_bus: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=(nil) sdrv=0x560c700c2d60\n1755842762: bus closed and sbus set to NULL: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=(nil) sdrv=(nil)\n1755842762: exit metal_linux_bus_close: metal_bus=0x7f1173c27dc8 linux_bus=0x7f1173c27dc8 linux_driver=(nil) sdrv=(nil)\n1755842763: enter metal_linux_bus_close: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=(nil) sdrv=(nil)\n1755842763: iter start: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce82c0 sdrv=0x55eea2bf3a20\n1755842763: calling sysfs_close_driver: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce82c0 sdrv=0x55eea2bf3a20\n1755842763: returned from sysfs_close_driver: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce82c0 sdrv=0x55eea2bf3a20\n1755842763: sdrv set to NULL: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce82c0 sdrv=(nil)\n1755842763: iter start: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce8308 sdrv=0x55eea2bf3bc0\n1755842763: calling sysfs_close_driver: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee83ce8308 sdrv=0x55eea2bf3bc0\n1755842763: returned from sysfs_close_driver: metal_bus=0x55ee83ce8260 linux_bus=0x55ee83ce8260 linux_driver=0x55ee8\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_bus_close:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for metal_linux_bus_close. MISRA C 2023 Rule 8.13 recommends using pointers to const-qualified types when the pointed-to object is not modified. In metal_linux_bus_close the function explicitly modifies the pointed-to objects: it sets ldrv->sdrv = NULL inside the driver iteration and later sets lbus->sbus = NULL. Because the code intentionally updates members of the linux_driver/linux_bus objects, the pointers must be non-const and there is no Rule 8.13 violation here. The agent's scenario about dev_dma_unmap is about a different API: if those callbacks truly never modify their parameters, then changing their prototypes to use const could be considered, but that is a separate API-level decision and not evidence that metal_linux_bus_close violates Rule 8.13."
}