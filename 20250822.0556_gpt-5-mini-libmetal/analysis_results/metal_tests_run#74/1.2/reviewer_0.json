{
  "user_message": "An agent A claimed that the following metal_tests_run code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_tests_run.\n```c\nint metal_tests_run(struct metal_init_params *params)\n{\n\tstruct metal_init_params dparams = METAL_INIT_DEFAULTS;\n\tstruct metal_test_case *test_case;\n\tstruct metal_list *node;\n\tint error, errors = 0;\n\tconst char *dots = \"..................................\";\n\tconst char *pad;\n\n\tif (!params)\n\t\tparams = &dparams;\n\n\tparams->log_level = METAL_LOG_DEBUG;\n\terror = metal_init(params);\n\tif (error)\n\t\treturn error;\n\n\tmetal_list_for_each(&test_cases, node) {\n\t\ttest_case = metal_container_of(node, struct metal_test_case,\n\t\t\t\t\t       node);\n\t\tpad = dots + strlen(test_case->name);\n\t\tmetal_log(METAL_LOG_INFO,\"running [%s]\\n\", test_case->name);\n\t\terror = test_case->test();\n\t\tmetal_log(METAL_LOG_INFO,\"result [%s]%s %s%s%s\\n\",\n\t\t       test_case->name, pad,\n\t\t       error ? \"fail\" : \"pass\",\n\t\t       error ? \" - error: \" : \"\",\n\t\t       error ? strerror(-error) : \"\");\n\t\tif (error)\n\t\t\terrors++;\n\t}\n\n\tmetal_finish();\n\n\treturn errors;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses compiler extensions: the use of GCC statement-expressions '({ ... })' is a non-standard language extension, and the token-pasting form '##__VA_ARGS__' to swallow a trailing comma is a GNU CPP extension. Both are documented compiler extensions, so Rule 1.2 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_tests_run(params=(nil))\nparams is NULL, switching to dparams (0x7ffc5354e420)\nsetting params->log_level = METAL_LOG_DEBUG\ncalling metal_init(params=0x7ffc5354e420)\nmetal_init returned 0\nLOOP: test_case=0x5627e5bc90e0 name=\"atomic\" name_len=6 pad=0x5627e5bc55ee test_fn=0x5627e5bbf861\ncalling test function for [atomic] (fn=0x5627e5bbf861)\ntest function for [atomic] returned 0\nabout to call metal_log for result of [atomic]\nLOOP: test_case=0x5627e5bc9260 name=\"mutex\" name_len=5 pad=0x5627e5bc55ed test_fn=0x5627e5bbfe6e\ncalling test function for [mutex] (fn=0x5627e5bbfe6e)\ntest function for [mutex] returned 0\nabout to call metal_log for result of [mutex]\nLOOP: test_case=0x5627e5bc9620 name=\"shmem\" name_len=5 pad=0x5627e5bc55ed test_fn=0x5627e5bc0725\ncalling test function for [shmem] (fn=0x5627e5bc0725)\ntest function for [shmem] returned 0\nabout to call metal_log for result of [shmem]\nLOOP: test_case=0x5627e5bc99a0 name=\"condition\" name_len=9 pad=0x5627e5bc55f1 test_fn=0x5627e5bc0dbf\ncalling test function for [condition] (fn=0x5627e5bc0dbf)\ntest function for [condition] returned 0\nabout to call metal_log for result of [condition]\nLOOP: test_case=0x5627e5bc9e40 name=\"spinlock\" name_len=8 pad=0x5627e5bc55f0 test_fn=0x5627e5bc17b2\ncalling test function for [spinlock] (fn=0x5627e5bc17b2)\ntest function for [spinlock] returned 0\nabout to call metal_log for result of [spinlock]\nLOOP: test_case=0x5627e5bca0a0 name=\"alloc\" name_len=5 pad=0x5627e5bc55ed test_fn=0x5627e5bc1a29\ncalling test function for [alloc] (fn=0x5627e5bc1a29)\ntest function for [alloc] returned 0\nabout to call metal_log for result of [alloc]\nLOOP: test_case=0x5627e5bca300 name=\"irq\" name_len=3 pad=0x5627e5bc55eb test_fn=0x5627e5bc1bef\ncalling test function for [irq] (fn=0x5627e5bc1bef)\ntest function for [irq] returned 0\nabout to call metal_log for result of [irq]\nLOOP: test_case=0x5627e5bca4c0 name=\"version\" name_len=7 pad=0x5627e5bc55ef test_fn=0x5627e5bc203a\ncalling test function for [version] (fn=0x5627e5bc203a)\ntest function for [version] returned 0\nabout to call metal_log for result of [version]\ncalling metal_finish()\nEXIT: metal_tests_run returning errors=0\nENTER: metal_tests_run(params=(nil))\nparams is NULL, switching to dparams (0x7ffe07e8d940)\nsetting params->log_level = METAL_LOG_DEBUG\ncalling metal_init(params=0x7ffe07e8d940)\nmetal_init returned 0\nLOOP: test_case=0x55bb198220e0 name=\"atomic\" name_len=6 pad=0x55bb1981c5ee test_fn=0x55bb1980dc41\ncalling test function for [atomic] (fn=0x55bb1980dc41)\ntest function for [atomic] returned 0\nabout to call metal_log for result of [atomic]\nLOOP: test_case=0x55bb19822260 name=\"mutex\" name_len=5 pad=0x55bb1981c5ed test_fn=0x55bb1980e24e\ncalling test function for [mutex] (fn=0x55bb1980e24e)\ntest function for [mutex] returned 0\nabout to call metal_log for result of [mutex]\nLOOP: test_case=0x55bb19822620 name=\"shmem\" name_len=5 pad=0x55bb1981c5ed test_fn=0x55bb1980eb05\ncalling test function for [shmem] (fn=0x55bb1980eb05)\ntest function for [shmem] returned 0\nabout to call metal_log for result of [shmem]\nLOOP: test_case=0x55bb198229a0 name=\"condition\" name_len=9 pad=0x55bb1981c5f1 test_fn=0x55bb1980f19f\ncalling test function for [condition] (fn=0x55bb1980f19f)\ntest function for [condition] returned 0\nabout to call metal_log for result of [condition]\nLOOP: test_case=0x55bb19822e40 name=\"spinlock\" name_len=8 pad=0x55bb1981c5f0 test_fn=0x55bb1980fb92\ncalling test function for [spinlock] (fn=0x55bb1980fb92)\ntest function for [spinlock] returned 0\nabout to call metal_log for result of [spinlock]\nLOOP: test_case=0x55bb198230a0 name=\"alloc\" name_len=5 pad=0x55bb1981c5ed test_fn=0x55bb1980fe09\ncalling test function for [alloc] (fn=0x55bb1980fe09)\ntest function for [alloc] returned 0\nabout to call metal_log for result of [alloc]\nLOOP: test_case=0x55bb19823300 name=\"irq\" name_len=3 pad=0x55bb1981c5eb test_fn=0x55bb1980ffcf\ncalling test function for [irq] (fn=0x55bb1980ffcf)\ntest function for [irq] returned 0\nabout to call metal_log for result of [irq]\nLOOP: test_case=0x55bb198234c0 name=\"version\" name_len=7 pad=0x55bb1\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_tests_run:\n#define METAL_INIT_DEFAULTS \\\n{.log_handler=metal_default_log_handler,.log_level=METAL_LOG_INFO,\\\n}\n...\nstruct metal_init_params {\n\n\t/** log message handler (defaults to stderr). */\n\tmetal_log_handler\t\tlog_handler;\n\n\t/** default log message level (defaults to emergency). */\n\tenum metal_log_level\t\tlog_level;\n}\n...\n#define metal_list_for_each(list, node) for((node)=(list)->next;(node)!=(list);(node)=(node)->next)\n...\n#define metal_container_of(ptr, structure, member) (void*)((uintptr_t)(ptr)-metal_offset_of(structure,member))\n...\nstruct metal_test_case {\n\tstruct metal_list node;\n\tconst char *name;\n\ttest_func_t test;\n}\n...\nstruct metal_list {\n\tstruct metal_list *next, *prev;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nint metal_init(const struct metal_init_params *params)\n{\n\tint error = 0;\n\n\tif (_metal.common.ref_count++ != 0)\n\t\treturn 0;\n\n\tmemset(&_metal, 0, sizeof(_metal));\n\n\t_metal.common.log_handler   = params->log_handler;\n\t_metal.common.log_level     = params->log_level;\n\n\tmetal_list_init(&_metal.common.bus_list);\n\tmetal_list_init(&_metal.common.generic_shmem_list);\n\tmetal_list_init(&_metal.common.generic_device_list);\n\n\terror = metal_sys_init(params);\n\tif (error)\n\t\treturn error;\n\n\t++_metal.common.ref_count;\n\treturn error;\n}\n...\nvoid metal_finish(void)\n{\n\tif (--_metal.common.ref_count != 0)\n\t\treturn;\n\n\tmetal_sys_finish();\n\tmemset(&_metal, 0, sizeof(_metal));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The metal_tests_run function uses the metal_log macro, and the provided definition of metal_log employs GNU C extensions: a GCC statement-expression ({ ... }) and the GCC/CPP comma-swallowing form using ##__VA_ARGS__. Both constructs are documented compiler extensions and therefore violate MISRA C 2023 Rule 1.2 (language extensions should not be used). Note that the violation comes from the macro expansion (in the same translation unit), so even though the function body itself has no explicit ({ ... }) or ##__VA_ARGS__ tokens, the code as compiled uses those extensions and thus breaches Rule 1.2."
}