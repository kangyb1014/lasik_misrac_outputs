{
  "user_message": "An agent A claimed that the following metal_tests_run code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_tests_run.\n```c\nint metal_tests_run(struct metal_init_params *params)\n{\n\tstruct metal_init_params dparams = METAL_INIT_DEFAULTS;\n\tstruct metal_test_case *test_case;\n\tstruct metal_list *node;\n\tint error, errors = 0;\n\tconst char *dots = \"..................................\";\n\tconst char *pad;\n\n\tif (!params)\n\t\tparams = &dparams;\n\n\tparams->log_level = METAL_LOG_DEBUG;\n\terror = metal_init(params);\n\tif (error)\n\t\treturn error;\n\n\tmetal_list_for_each(&test_cases, node) {\n\t\ttest_case = metal_container_of(node, struct metal_test_case,\n\t\t\t\t\t       node);\n\t\tpad = dots + strlen(test_case->name);\n\t\tmetal_log(METAL_LOG_INFO,\"running [%s]\\n\", test_case->name);\n\t\terror = test_case->test();\n\t\tmetal_log(METAL_LOG_INFO,\"result [%s]%s %s%s%s\\n\",\n\t\t       test_case->name, pad,\n\t\t       error ? \"fail\" : \"pass\",\n\t\t       error ? \" - error: \" : \"\",\n\t\t       error ? strerror(-error) : \"\");\n\t\tif (error)\n\t\t\terrors++;\n\t}\n\n\tmetal_finish();\n\n\treturn errors;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable test_case is declared as 'struct metal_test_case *test_case' but is only used for read-only access (calling the test function and reading test_case->name). It could be declared as 'const struct metal_test_case *test_case' so the pointer points to a const-qualified type. Therefore the code as shown violates MISRA C 2023 Rule 8.13. (Fix: declare test_case as 'const struct metal_test_case *test_case' and ensure the iterator/container APIs support const-correct access.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_tests_run: started. params=0x7ffc7cb5f520, log_level=7\niter: node=0x55c40b2fd0e0, test_case=0x55c40b2fd0e0, name_ptr=0x55c40b2f9082, name=\"atomic\"\ncomputed pad offset=6 (name_len=6)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fd260, test_case=0x55c40b2fd260, name_ptr=0x55c40b2f90ec, name=\"mutex\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fd620, test_case=0x55c40b2fd620, name_ptr=0x55c40b2f919d, name=\"shmem\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fd9a0, test_case=0x55c40b2fd9a0, name_ptr=0x55c40b2f924f, name=\"condition\"\ncomputed pad offset=9 (name_len=9)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fde40, test_case=0x55c40b2fde40, name_ptr=0x55c40b2f9382, name=\"spinlock\"\ncomputed pad offset=8 (name_len=8)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fe0a0, test_case=0x55c40b2fe0a0, name_ptr=0x55c40b2f940b, name=\"alloc\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fe300, test_case=0x55c40b2fe300, name_ptr=0x55c40b2f950a, name=\"irq\"\ncomputed pad offset=3 (name_len=3)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55c40b2fe4c0, test_case=0x55c40b2fe4c0, name_ptr=0x55c40b2f9577, name=\"version\"\ncomputed pad offset=7 (name_len=7)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\nmetal_tests_run: finished, total_errors=0\nmetal_tests_run: started. params=0x7fff4b3f5a30, log_level=7\niter: node=0x55fb98b160e0, test_case=0x55fb98b160e0, name_ptr=0x55fb98b10082, name=\"atomic\"\ncomputed pad offset=6 (name_len=6)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b16260, test_case=0x55fb98b16260, name_ptr=0x55fb98b100ec, name=\"mutex\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b16620, test_case=0x55fb98b16620, name_ptr=0x55fb98b1019d, name=\"shmem\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b169a0, test_case=0x55fb98b169a0, name_ptr=0x55fb98b1024f, name=\"condition\"\ncomputed pad offset=9 (name_len=9)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b16e40, test_case=0x55fb98b16e40, name_ptr=0x55fb98b10382, name=\"spinlock\"\ncomputed pad offset=8 (name_len=8)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b170a0, test_case=0x55fb98b170a0, name_ptr=0x55fb98b1040b, name=\"alloc\"\ncomputed pad offset=5 (name_len=5)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b17300, test_case=0x55fb98b17300, name_ptr=0x55fb98b1050a, name=\"irq\"\ncomputed pad offset=3 (name_len=3)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, cumulative_errors=0\niter: node=0x55fb98b174c0, test_case=0x55fb98b174c0, name_ptr=0x55fb98b10577, name=\"version\"\ncomputed pad offset=7 (name_len=7)\nabout to invoke test_case->test (exists=yes)\nreturned from test(): error=0, strerror=0\ntest passed, \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In metal_tests_run the local variable test_case is only used for read-only accesses: reading the name field and reading/calling the stored function pointer. There is no write-through of the pointed-to struct, so the pointer can (and per MISRA 8.13 should) be declared to point to a const-qualified type (e.g. const struct metal_test_case *test_case). Assigning the non-const result of the container_of macro to a const pointer is allowed (adding const), and calling a function pointer obtained from a const-qualified object is also permitted. The only caveat is if any of the test functions or other code actually rely on modifying the test_case object via that pointer; in the presented code and execution log there is no evidence of such modification. Therefore the claim of a Rule 8.13 violation is valid (fix: change declaration to const struct metal_test_case *test_case and verify related APIs/macros are const-correct)."
}