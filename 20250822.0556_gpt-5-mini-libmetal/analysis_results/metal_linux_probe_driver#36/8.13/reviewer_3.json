{
  "user_message": "An agent A claimed that the following metal_linux_probe_driver code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_driver.\n```c\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes 'struct linux_bus *lbus' but does not modify the pointed-to linux_bus (only reads lbus->bus_name). According to MISRA C 2023 Rule 8.13, this parameter should be declared as 'const struct linux_bus *lbus' to indicate it is not modified. The 'struct linux_driver *ldrv' is modified (ldrv->sdrv is assigned), so it must remain non-const.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_linux_probe_driver: lbus=0x7fdf55480b60 ldrv=0x7fdf55480bc0\nstate before: lbus->bus_name='platform' ldrv->drv_name='uio_pdrv_genirq' ldrv->mod_name='uio_pdrv_genirq' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55633fe3ba20\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55633fe3ba20 return=0\nENTER metal_linux_probe_driver: lbus=0x7fdf55480b60 ldrv=0x7fdf55480c08\nstate before: lbus->bus_name='platform' ldrv->drv_name='uio_dmem_genirq' ldrv->mod_name='uio_dmem_genirq' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55633fe3bbc0\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55633fe3bbc0 return=0\nENTER metal_linux_probe_driver: lbus=0x7fdf55481dc8 ldrv=0x7fdf55481e28\nstate before: lbus->bus_name='pci' ldrv->drv_name='vfio-pci' ldrv->mod_name='vfio-pci' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55633fe3bec0\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55633fe3bec0 return=0\nENTER metal_linux_probe_driver: lbus=0x7fdf55481dc8 ldrv=0x7fdf55481e70\nstate before: lbus->bus_name='pci' ldrv->drv_name='uio_pci_generic' ldrv->mod_name='uio_pci_generic' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55633fe3c060\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55633fe3c060 return=0\nENTER metal_linux_probe_driver: lbus=0x55e5e4d0e260 ldrv=0x55e5e4d0e2c0\nstate before: lbus->bus_name='platform' ldrv->drv_name='uio_pdrv_genirq' ldrv->mod_name='uio_pdrv_genirq' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55e5e8438a20\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55e5e8438a20 return=0\nENTER metal_linux_probe_driver: lbus=0x55e5e4d0e260 ldrv=0x55e5e4d0e308\nstate before: lbus->bus_name='platform' ldrv->drv_name='uio_dmem_genirq' ldrv->mod_name='uio_dmem_genirq' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55e5e8438bc0\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55e5e8438bc0 return=0\nENTER metal_linux_probe_driver: lbus=0x55e5e4d0f4c8 ldrv=0x55e5e4d0f528\nstate before: lbus->bus_name='pci' ldrv->drv_name='vfio-pci' ldrv->mod_name='vfio-pci' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55e5e8438ec0\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55e5e8438ec0 return=0\nENTER metal_linux_probe_driver: lbus=0x55e5e4d0f4c8 ldrv=0x55e5e4d0f570\nstate before: lbus->bus_name='pci' ldrv->drv_name='uio_pci_generic' ldrv->mod_name='uio_pci_generic' ldrv->sdrv=(nil)\nafter sysfs_open_driver (initial): ldrv->sdrv=0x55e5e8439060\nEXIT metal_linux_probe_driver: ldrv->sdrv=0x55e5e8439060 return=0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_probe_driver:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In metal_linux_probe_driver the parameter lbus is only read (lbus->bus_name is used) and the function does not modify the object pointed to by lbus. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible, so the parameter should be declared as const struct linux_bus *lbus. The second parameter ldrv is written (ldrv->sdrv is assigned) and therefore must remain non-const. The only plausible reasons not to change lbus to const would be external interface constraints (e.g. matching a non-const function pointer type) or other calls expecting a non-const struct linux_bus *; none of those are evident here (the function is static and the shown usage does not mutate lbus), so the agent A report is valid."
}