{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 1.2.\nHere is the comment from the agent.\n<violation scenario>\nThe macro body uses GCC/Clang statement-expressions and the GNU variadic macro comma-elision extension: the construct '({ ... })' is a GNU statement-expression extension and the token pasting '##__VA_ARGS__' is the GNU extension to remove the preceding comma when no variadic arguments are present. Both are compiler-specific language extensions and thus violate MISRA C 2023 Rule 1.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified alloc code that contains useful probe functions that print useful logs to a file \"/tmp/logs/710.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of alloc as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of alloc:\n```c\nstatic int alloc(void)\n{\n\tvoid *ptr;\n\n\tptr = metal_allocate_memory(1000);\n\tif (!ptr) {\n\t\tmetal_log(METAL_LOG_DEBUG, \"failed to allocate memory\\n\");\n\t\treturn errno;\n\t}\n\n\tmetal_free_memory(ptr);\n\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified alloc code.\n",
  "test_code": "#include <stdio.h>\n#include <errno.h>\n#include <time.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n/*\n * Probe function: append a log entry describing control flow and state\n * to \"/tmp/logs/710.txt\". This captures allocation attempts, results,\n * errno at points of interest, pointer values, requested size and\n * compiler identification macros (to help reproduce the environment\n * where GNU extensions may be present).\n *\n * This helper preserves the original behavior of alloc; it only\n * appends diagnostic information and does not alter allocation logic.\n */\nstatic void log_compiler_info(FILE *f)\n{\n#ifdef __clang__\n    fprintf(f, \"compiler=clang %d.%d\\n\", __clang_major__, __clang_minor__);\n#elif defined(__GNUC__)\n    fprintf(f, \"compiler=gcc %d.%d\\n\", __GNUC__, __GNUC_MINOR__);\n#else\n    fprintf(f, \"compiler=unknown\\n\");\n#endif\n#ifdef __GNUC__\n#ifdef __GNUC_PATCHLEVEL__\n    fprintf(f, \"gcc_patchlevel=%d\\n\", __GNUC_PATCHLEVEL__);\n#endif\n#endif\n#ifdef __STDC_VERSION__\n    fprintf(f, \"stdc_version=%ld\\n\", (long)__STDC_VERSION__);\n#endif\n}\n\nstatic void log_probe_stage(const char *stage, void *ptr, size_t size, int err)\n{\n    FILE *f = fopen(\"/tmp/logs/710.txt\", \"a\");\n    if (f == NULL) {\n        /* If logging fails we do not change program behavior. */\n        return;\n    }\n\n    time_t t = time(NULL);\n    struct tm *tm_info = localtime(&t);\n    if (tm_info != NULL) {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm_info) > 0) {\n            fprintf(f, \"[%s] \", buf);\n        }\n    }\n\n    fprintf(f, \"stage=%s size=%zu ptr=%p errno=%d (%s)\\n\",\n            stage, size, ptr, err, (err != 0) ? strerror(err) : \"no-error\");\n\n    /* Add compiler identification to each entry to assist reproduction */\n    log_compiler_info(f);\n\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\n/*\n * The original alloc function with inserted probes. Logic is preserved: it\n * attempts to allocate memory, logs failures via metal_log as originally,\n * frees memory when allocated, and returns errno on failure or 0 on success.\n *\n * Do not define or change external symbols such as metal_allocate_memory,\n * metal_free_memory or METAL_LOG_DEBUG here; they are assumed to be\n * provided by the surrounding project (as in the original code).\n */\nstatic int alloc(void)\n{\n    void *ptr;\n\n    /* Entering alloc */\n    log_probe_stage(\"enter_alloc\", NULL, 1000, 0);\n\n    ptr = metal_allocate_memory(1000);\n\n    /* After allocation attempt: record pointer and errno at that moment */\n    log_probe_stage(\"after_allocate\", ptr, 1000, errno);\n\n    if (!ptr) {\n        /* Preserve original logging behavior */\n        metal_log(METAL_LOG_DEBUG, \"failed to allocate memory\\n\");\n\n        /* Log failure and return the current errno as before */\n        log_probe_stage(\"allocation_failed\", ptr, 1000, errno);\n        return errno;\n    }\n\n    /* Free the allocated memory as in original code */\n    metal_free_memory(ptr);\n\n    /* Log that we freed the memory and are about to return success */\n    log_probe_stage(\"after_free\", ptr, 1000, errno);\n\n    return 0;\n}\n"
}