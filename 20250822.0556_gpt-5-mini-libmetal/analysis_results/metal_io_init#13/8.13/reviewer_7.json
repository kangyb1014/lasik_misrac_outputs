{
  "user_message": "An agent A claimed that the following metal_io_init code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_io_init.\n```c\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function pointer parameter 'struct metal_io_region *io' is a pointer to a non-const type. Per MISRA C 2023 Rule 8.13, if the function does not modify the region it should be declared as 'const struct metal_io_region *io' (e.g. unsigned long (*phys_to_offset)(const struct metal_io_region *io, metal_phys_addr_t phys);). The other parameter (metal_phys_addr_t phys) is not a pointer and is not relevant. Because the pointer parameter is not const-qualified where it could be, this violates Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_io_init: entry: io=0x7f01c4001380 virt=0x7f01dc5f9000 physmap=0x7f01c4000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: entry: io=0x7f01cc001380 virt=0x7f01e40e5000 physmap=0x7f01cc000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01c4001380 virt=0x7f01dc5f9000 physmap=0x7f01c4000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: after assignments: io=0x7f01cc001380 virt=0x7f01e40e5000 physmap=0x7f01cc000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01c4001380\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01cc001380\nmetal_io_init: entry: io=0x7f01d8001380 virt=0x7f01e4de6000 physmap=0x7f01d8000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01d8001380 virt=0x7f01e4de6000 physmap=0x7f01d8000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01d8001380\nmetal_io_init: entry: io=0x7f01b0001380 virt=0x7f01dc3f9000 physmap=0x7f01b0000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01b0001380 virt=0x7f01dc3f9000 physmap=0x7f01b0000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01b0001380\nmetal_io_init: entry: io=0x7f01c8001380 virt=0x7f01e42e5000 physmap=0x7f01c8000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01c8001380 virt=0x7f01e42e5000 physmap=0x7f01c8000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01c8001380\nmetal_io_init: entry: io=0x7f01c0001380 virt=0x7f01e41e5000 physmap=0x7f01c0000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01c0001380 virt=0x7f01e41e5000 physmap=0x7f01c0000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01c0001380\nmetal_io_init: entry: io=0x7f01b8001380 virt=0x7f01dc6f9000 physmap=0x7f01b8000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01b8001380 virt=0x7f01dc6f9000 physmap=0x7f01b8000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01b8001380\nmetal_io_init: entry: io=0x7f01d0001380 virt=0x7f01e43e5000 physmap=0x7f01d0000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01d0001380 virt=0x7f01e43e5000 physmap=0x7f01d0000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit after metal_sys_io_mem_map: io=0x7f01d0001380\nmetal_io_init: entry: io=0x7f01d4001380 virt=0x7f01e4ce6000 physmap=0x7f01d4000b70 size=1048576 page_shift=12 mem_flags=0 ops=0x7f01e5967d80\nmetal_io_init: page_mask computed: page_shift=12 page_mask=0xfff\nmetal_io_init: after assignments: io=0x7f01d4001380 virt=0x7f01e4ce6000 physmap=0x7f01d4000b70 size=1048576 page_shift=12 page_mask=0xfff mem_flags=0 ops_ptr=0x7f01e5967d80 ops_was_null=0\nmetal_io_init: exit af\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_io_init:\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nstruct metal_io_ops {\n\tuint64_t\t(*read)(struct metal_io_region *io,\n\t\t\t\tunsigned long offset,\n\t\t\t\tmemory_order order,\n\t\t\t\tint width);\n\tvoid\t\t(*write)(struct metal_io_region *io,\n\t\t\t\t unsigned long offset,\n\t\t\t\t uint64_t value,\n\t\t\t\t memory_order order,\n\t\t\t\t int width);\n\tint\t\t(*block_read)(struct metal_io_region *io,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      void *restrict dst,\n\t\t\t\t      memory_order order,\n\t\t\t\t      int len);\n\tint\t\t(*block_write)(struct metal_io_region *io,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       const void *restrict src,\n\t\t\t\t       memory_order order,\n\t\t\t\t       int len);\n\tvoid\t\t(*block_set)(struct metal_io_region *io,\n\t\t\t\t     unsigned long offset,\n\t\t\t\t     unsigned char value,\n\t\t\t\t     memory_order order,\n\t\t\t\t     int len);\n\tvoid\t\t(*close)(struct metal_io_region *io);\n\tmetal_phys_addr_t (*offset_to_phys)(struct metal_io_region *io,\n\t\t\t\t\t    unsigned long offset);\n\tunsigned long\t(*phys_to_offset)(struct metal_io_region *io,\n\t\t\t\t\t  metal_phys_addr_t phys);\n}\n...\n#define metal_sys_io_mem_map(__VA_ARGS__) \n...\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's report is not correct. MISRA C 2023 Rule 8.13 recommends using a pointer to const when the pointed-to object is not modified. In metal_io_init the function clearly modifies the object pointed to by io (assigns io->virt, io->physmap, io->size, io->page_shift, io->page_mask, io->mem_flags and io->ops, and calls metal_sys_io_mem_map(io)). Because the function writes to members of *io, the parameter cannot be const-qualified. Likewise the io parameter in the function pointer types in struct metal_io_ops is non-const because those operations may modify the region. Therefore there is no violation of Rule 8.13 in this code."
}