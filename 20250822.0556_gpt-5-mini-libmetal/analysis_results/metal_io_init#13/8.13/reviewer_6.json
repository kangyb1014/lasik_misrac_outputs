{
  "user_message": "An agent A claimed that the following metal_io_init code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_io_init.\n```c\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function pointer offset_to_phys is declared to take a non-const pointer parameter: 'struct metal_io_region *io'. If implementations do not modify the pointed-to metal_io_region (which is likely for an offset->phys mapping operation), the parameter should be 'const struct metal_io_region *io'. Because the pointer target is not const-qualified where it could be, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[entry] io=7f7db4001380, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7db4001380, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7db4001380, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7dac001380, virt=7f7dc8a09000, physmap=7f7dac000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7dac001380, virt=7f7dc8a09000, physmap=7f7dac000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7dac001380, virt=7f7dc8a09000, physmap=7f7dac000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7db4001400, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7db4001400, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7db4001400, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7db4001480, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7db4001480, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7db4001480, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7dbc001380, virt=7f7dc960a000, physmap=7f7dbc000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7dbc001380, virt=7f7dc960a000, physmap=7f7dbc000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7dbc001380, virt=7f7dc960a000, physmap=7f7dbc000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7db4001500, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7db4001500, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7db4001500, virt=7f7dc940a000, physmap=7f7db4000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7db0001380, virt=7f7dc8b09000, physmap=7f7db0000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7db0001380, virt=7f7dc8b09000, physmap=7f7db0000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] io=7f7db0001380, virt=7f7dc8b09000, physmap=7f7db0000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[entry] io=7f7dac001400, virt=7f7dc8a09000, physmap=7f7dac000b70, size=1048576, page_shift=12, page_mask=0x00000000, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[pre-map] io=7f7dac001400, virt=7f7dc8a09000, physmap=7f7dac000b70, size=1048576, page_shift=12, page_mask=0x00000fff, mem_flags=0x00000000, ops=7f7dca18bd80, used_default_ops=0\n[post-map] \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_io_init:\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nstruct metal_io_ops {\n\tuint64_t\t(*read)(struct metal_io_region *io,\n\t\t\t\tunsigned long offset,\n\t\t\t\tmemory_order order,\n\t\t\t\tint width);\n\tvoid\t\t(*write)(struct metal_io_region *io,\n\t\t\t\t unsigned long offset,\n\t\t\t\t uint64_t value,\n\t\t\t\t memory_order order,\n\t\t\t\t int width);\n\tint\t\t(*block_read)(struct metal_io_region *io,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      void *restrict dst,\n\t\t\t\t      memory_order order,\n\t\t\t\t      int len);\n\tint\t\t(*block_write)(struct metal_io_region *io,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       const void *restrict src,\n\t\t\t\t       memory_order order,\n\t\t\t\t       int len);\n\tvoid\t\t(*block_set)(struct metal_io_region *io,\n\t\t\t\t     unsigned long offset,\n\t\t\t\t     unsigned char value,\n\t\t\t\t     memory_order order,\n\t\t\t\t     int len);\n\tvoid\t\t(*close)(struct metal_io_region *io);\n\tmetal_phys_addr_t (*offset_to_phys)(struct metal_io_region *io,\n\t\t\t\t\t    unsigned long offset);\n\tunsigned long\t(*phys_to_offset)(struct metal_io_region *io,\n\t\t\t\t\t  metal_phys_addr_t phys);\n}\n...\n#define metal_sys_io_mem_map(__VA_ARGS__) \n...\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 encourages declaring pointers to const when the pointed-to object will not be modified, but you must judge this in the context of the API and its semantics. The complained-about prototype (metal_phys_addr_t (*offset_to_phys)(struct metal_io_region *io, ...)) is a member of the metal_io_ops API, not a local pointer in metal_io_init. Many other operations in that same API (write, block_write, close, etc.) reasonably require a modifiable struct metal_io_region * parameter, so the API uses a non-const pointer consistently. It is therefore not generally possible to change the prototype of one op to take a const pointer without breaking API consistency or preventing implementations that do modify the region (for example to update cached state). metal_io_init itself initializes/modifies the struct metal_io_region object, so it must take a non-const io parameter. Given the API requirements and the lack of evidence that offset_to_phys implementations never modify the region, there is no definite MISRA 8.13 violation here."
}