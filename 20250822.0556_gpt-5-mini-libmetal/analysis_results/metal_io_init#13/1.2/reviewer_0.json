{
  "user_message": "An agent A claimed that the following metal_io_init code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_io_init.\n```c\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro definition uses a non\u2011standard variadic-parameter form: #define metal_sys_io_mem_map(__VA_ARGS__) and the call metal_sys_io_mem_map(io); relies on that macro. Using __VA_ARGS__ as the macro parameter name (instead of the standard C99 form using '...') is a compiler/preprocessor extension (GCC/Clang document named-variadic/alternate forms as extensions).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[metal_io_init] stage=entry\n  io=0x7f1d50001380\n  virt=0x7f1d61c23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=before_sys_map_call\n  io=0x7f1d50001380\n  virt=0x7f1d61c23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=invoke_metal_sys_io_mem_map\n  io=0x7f1d50001380\n  virt=0x7f1d61c23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=after_sys_map_call\n  io=0x7f1d50001380\n  virt=0x7f1d61c23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=entry\n  io=0x7f1d44001380\n  virt=0x7f1d61a23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=before_sys_map_call\n  io=0x7f1d44001380\n  virt=0x7f1d61a23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=invoke_metal_sys_io_mem_map\n  io=0x7f1d44001380\n  virt=0x7f1d61a23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=after_sys_map_call\n  io=0x7f1d44001380\n  virt=0x7f1d61a23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=entry\n  io=0x7f1d50001400\n  virt=0x7f1d61a23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=before_sys_map_call\n  io=0x7f1d50001400\n  virt=0x7f1d61a23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=invoke_metal_sys_io_mem_map\n  io=0x7f1d50001400\n  virt=0x7f1d61a23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=after_sys_map_call\n  io=0x7f1d50001400\n  virt=0x7f1d61a23000\n  physmap=0x7f1d50000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=entry\n  io=0x7f1d54001380\n  virt=0x7f1d62624000\n  physmap=0x7f1d54000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=entry\n  io=0x7f1d44001400\n  virt=0x7f1d61c23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=before_sys_map_call\n  io=0x7f1d54001380\n  virt=0x7f1d62624000\n  physmap=0x7f1d54000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=before_sys_map_call\n  io=0x7f1d44001400\n  virt=0x7f1d61c23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=invoke_metal_sys_io_mem_map\n  io=0x7f1d54001380\n  virt=0x7f1d62624000\n  physmap=0x7f1d54000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=invoke_metal_sys_io_mem_map\n  io=0x7f1d44001400\n  virt=0x7f1d61c23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=after_sys_map_call\n  io=0x7f1d54001380\n  virt=0x7f1d62624000\n  physmap=0x7f1d54000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=after_sys_map_call\n  io=0x7f1d44001400\n  virt=0x7f1d61c23000\n  physmap=0x7f1d44000b70\n  size=1048576\n  page_shift=12\n  page_mask=0xfff\n  mem_flags=0x0\n  ops=0x7f1d631a6d80\n----\n[metal_io_init] stage=entry\n  io=0x7f1d3c001380\n  virt=0x7f1d61823000\n  physmap=0x7f1d3c000b70\n  size=1048576\n  page_shift=12\n  page_mask=0x0\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_io_init:\ntypedef unsigned long metal_phys_addr_t\n...\n#define metal_sys_io_mem_map(__VA_ARGS__) \n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 1.2 forbids the use of compiler language extensions that are explicitly documented as extensions. The macro shown, #define metal_sys_io_mem_map(__VA_ARGS__), simply defines a macro with a single parameter whose name happens to be \u201c__VA_ARGS__\u201d. That is ordinary preprocessor parameter syntax (an identifier as the parameter name) and is not the GCC/Clang named\u2011variadic extension (which uses constructs like name... or the pre\u2011C99 args... style). The problematic GCC/Clang extension would be using an alternate variadic parameter syntax (e.g. args...), or other non\u2011standard features; those are not being used here. (Note: using an identifier beginning with double underscore is potentially a different concern because such identifiers are reserved to the implementation, but that is a separate rule, not MISRA 1.2.)"
}