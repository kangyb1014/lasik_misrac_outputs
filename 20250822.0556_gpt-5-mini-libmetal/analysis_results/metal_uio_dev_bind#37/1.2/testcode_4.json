{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 1.2.\nHere is the comment from the agent.\n<violation scenario>\nThe metal_log macro (shown in additional code) is defined using a GCC statement-expression ({ ... }) and uses the GNU variadic-macro token-pasting trick (##__VA_ARGS__). Both are compiler-specific language extensions (GCC extensions). Therefore the call metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\", ldev->dev_name, ldrv->drv_name); expands to code that relies on these extensions and violates MISRA C 2023 Rule 1.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_uio_dev_bind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/370.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_uio_dev_bind as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_bind:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified metal_uio_dev_bind code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <stddef.h>\n\n/* Minimal forward declarations so this snippet compiles when linked into\n   the larger project. Do NOT change existing program logic in\n   metal_uio_dev_bind; these are only to allow compilation of this test\n   fragment. */\nstruct sysfs_attribute;\nstruct sdev { char *driver_name; };\nstruct sdrv_type;\nstruct linux_device { struct sdev *sdev; char *dev_name; struct sysfs_attribute *override; };\nstruct linux_driver { char *drv_name; struct sdrv_type *sdrv; };\n\nextern struct sysfs_attribute *sysfs_get_device_attr(struct sdev *, const char *);\nextern struct sysfs_attribute *sysfs_get_driver_attr(struct sdrv_type *, const char *);\nextern int sysfs_write_attribute(struct sysfs_attribute *, const char *, size_t);\nextern void metal_log(int level, const char *fmt, ...);\n\n/* Provide a string constant for SYSFS_UNKNOWN so this fragment compiles\n   without introducing a macro. The original code used SYSFS_UNKNOWN as\n   an identifier; we keep the same name as a const object. */\nstatic const char SYSFS_UNKNOWN[] = \"unknown\";\n\n/* Probe logger: append human-readable control-flow/state information to\n   /tmp/logs/370.txt. This function is intentionally simple and avoids\n   any compiler-specific extensions. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/370.txt\", \"a\");\n    if (!f)\n        return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n                              struct linux_driver *ldrv)\n{\n    struct sysfs_attribute *attr;\n    int result;\n\n    /* Entry probe: record input pointers and names (NULL-safe guards for\n       sdev and its driver_name to avoid crashing the probe logger). */\n    probe_log(\"ENTER metal_uio_dev_bind: ldev=%p ldrv=%p dev_name=%s drv_name=%s sdev_driver=%s\",\n              (void *)ldev,\n              (void *)ldrv,\n              (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\",\n              (ldrv && ldrv->drv_name) ? ldrv->drv_name : \"(null)\",\n              (ldev && ldev->sdev && ldev->sdev->driver_name) ? ldev->sdev->driver_name : \"(null)\");\n\n    if (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0) {\n        probe_log(\"PATH: driver names match; no action needed for device %s (driver %s). Returning 0.\",\n                  ldev->dev_name, ldrv->drv_name);\n        return 0;\n    }\n\n    if (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n        probe_log(\"PATH: device %s already in use by driver %s; returning -EBUSY.\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        metal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        return -EBUSY;\n    }\n\n    probe_log(\"ACTION: attempting to get driver_override attribute for device %s.\", ldev->dev_name);\n    attr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n    if (!attr) {\n        probe_log(\"ERROR: device %s has no override; errno=%d. Returning -errno.\", ldev->dev_name, errno);\n        metal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n\n    probe_log(\"ACTION: writing override '%s' to device %s.\", ldrv->drv_name, ldev->dev_name);\n    result = sysfs_write_attribute(attr, ldrv->drv_name,\n                                   strlen(ldrv->drv_name));\n    if (result) {\n        probe_log(\"ERROR: failed to set override on %s; sysfs_write_attribute returned %d errno=%d. Returning -errno.\",\n                  ldev->dev_name, result, errno);\n        metal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n    ldev->override = attr;\n\n    probe_log(\"ACTION: attempting to get driver bind attribute for driver %s.\", ldrv->drv_name);\n    attr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n    if (!attr) {\n        probe_log(\"ERROR: driver %s has no bind attribute; returning -ENOTSUP.\", ldrv->drv_name);\n        metal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n        return -ENOTSUP;\n    }\n\n    probe_log(\"ACTION: writing device name '%s' into driver's bind attribute.\", ldev->dev_name);\n    result = sysfs_write_attribute(attr, ldev->dev_name,\n                                   strlen(ldev->dev_name));\n    if (result) {\n        probe_log(\"ERROR: failed to bind %s to %s; sysfs_write_attribute returned %d errno=%d. Returning -errno.\",\n                  ldev->dev_name, ldrv->drv_name, result, errno);\n        metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n                  ldev->dev_name, ldrv->drv_name);\n        return -errno;\n    }\n\n    probe_log(\"SUCCESS: bound device %s to driver %s; returning 0.\", ldev->dev_name, ldrv->drv_name);\n    metal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n              ldev->dev_name, ldrv->drv_name);\n\n    return 0;\n}\n"
}