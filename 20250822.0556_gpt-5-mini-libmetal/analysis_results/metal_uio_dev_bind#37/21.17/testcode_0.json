{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nstrcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) can invoke out-of-bounds access if ldev->sdev or ldev->sdev->driver_name is NULL or if driver_name does not point to a valid NUL-terminated character array. SYSFS_UNKNOWN (a string literal) is safe, but there is no check that driver_name is non-NULL and NUL-terminated; if driver_name is a fixed-size buffer filled without a terminating '\\0' (or otherwise corrupted), strcmp will keep reading past the bounds until a NUL is found, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_uio_dev_bind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/379.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_uio_dev_bind as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_bind:\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified metal_uio_dev_bind code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n\n/* Probe helper: append a log line to /tmp/logs/379.txt with timestamp. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/379.txt\", \"a\");\n    if (!f)\n        return;\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    localtime_r(&t, &tm_buf);\n    char timestr[64];\n    strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf);\n\n    fprintf(f, \"%s - \", timestr);\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n                  struct linux_driver *ldrv)\n{\n    struct sysfs_attribute *attr;\n    int result;\n\n    /* Capture pointer addresses and NULLness without dereferencing unsafe memory. */\n    const void *ldev_ptr = (const void *)ldev;\n    const void *sdev_ptr = NULL;\n    const void *sdev_driver_name_ptr = NULL;\n    const void *ldrv_ptr = (const void *)ldrv;\n    const void *ldrv_drv_name_ptr = NULL;\n    const void *ldev_dev_name_ptr = NULL;\n\n    if (ldev)\n        sdev_ptr = (const void *)ldev->sdev; /* safe to read pointer value ldev->sdev */\n\n    if (ldev && ldev->sdev)\n        sdev_driver_name_ptr = (const void *)ldev->sdev->driver_name;\n\n    if (ldrv)\n        ldrv_drv_name_ptr = (const void *)ldrv->drv_name;\n\n    if (ldev)\n        ldev_dev_name_ptr = (const void *)ldev->dev_name;\n\n    probe_log(\"ENTER metal_uio_dev_bind: ldev=%p, ldev->sdev=%p, ldev->sdev->driver_name=%p, ldrv=%p, ldrv->drv_name=%p, ldev->dev_name=%p\",\n              ldev_ptr, sdev_ptr, sdev_driver_name_ptr, ldrv_ptr, ldrv_drv_name_ptr, ldev_dev_name_ptr);\n\n    /* Log just before the first strcmp (this call can read memory beyond bounds if data is malformed).\n     * We do NOT attempt to prevent or short-circuit the strcmp to preserve original control flow. */\n    probe_log(\"ABOUT_TO_STRCPM_1: comparing driver pointers: sdev->driver_name=%p vs ldrv->drv_name=%p\",\n              sdev_driver_name_ptr, ldrv_drv_name_ptr);\n\n    if (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0) {\n        probe_log(\"STRCMP_1_EQ: device %p already bound to driver %p; returning 0\",\n                  ldev_ptr, ldrv_ptr);\n        return 0;\n    }\n\n    /* Log result of first compare (non-equal path) */\n    probe_log(\"STRCMP_1_NE: device %p not equal to driver %p; proceeding\",\n              ldev_ptr, ldrv_ptr);\n\n    /* Log just before the second strcmp */\n    probe_log(\"ABOUT_TO_STRCPM_2: checking if device driver is SYSFS_UNKNOWN: sdev->driver_name=%p\",\n              sdev_driver_name_ptr);\n\n    if (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n        probe_log(\"STRCMP_2_NE_SYSFS_UNKNOWN: device %p in use by driver %p (non-unknown); returning -EBUSY\",\n                  ldev_ptr, sdev_driver_name_ptr);\n        metal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        return -EBUSY;\n    }\n\n    probe_log(\"STRCMP_2_EQ_SYSFS_UNKNOWN: device %p driver is SYSFS_UNKNOWN; attempting override\",\n              ldev_ptr);\n\n    attr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n    probe_log(\"sysfs_get_device_attr returned attr=%p for device %p\",\n              (const void *)attr, ldev_ptr);\n    if (!attr) {\n        probe_log(\"NO_OVERRIDE_ATTR: device %p has no override; errno=%d; returning -errno\",\n                  ldev_ptr, errno);\n        metal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n\n    probe_log(\"ABOUT_TO_WRITE_ATTR_1: writing override '%p' to attr=%p for device=%p\",\n              ldrv_drv_name_ptr, (const void *)attr, ldev_ptr);\n    result = sysfs_write_attribute(attr, ldrv->drv_name,\n                       strlen(ldrv->drv_name));\n    probe_log(\"sysfs_write_attribute(attr=%p, drv_name=%p) returned %d\",\n              (const void *)attr, ldrv_drv_name_ptr, result);\n    if (result) {\n        probe_log(\"WRITE_ATTR_1_FAIL: failed to set override on device %p; errno=%d; returning -errno\",\n                  ldev_ptr, errno);\n        metal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n                  ldev->dev_name);\n        return -errno;\n    }\n    ldev->override = attr;\n    probe_log(\"OVERRIDE_SET: device %p override attr=%p stored\",\n              ldev_ptr, (const void *)attr);\n\n    attr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n    probe_log(\"sysfs_get_driver_attr returned attr=%p for driver %p\",\n              (const void *)attr, ldrv_ptr);\n    if (!attr) {\n        probe_log(\"NO_DRIVER_BIND_ATTR: driver %p has no bind; returning -ENOTSUP\",\n                  ldrv_ptr);\n        metal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n        return -ENOTSUP;\n    }\n\n    probe_log(\"ABOUT_TO_WRITE_ATTR_2: writing device name %p to driver attr=%p\",\n              ldev_dev_name_ptr, (const void *)attr);\n    result = sysfs_write_attribute(attr, ldev->dev_name,\n                       strlen(ldev->dev_name));\n    probe_log(\"sysfs_write_attribute(attr=%p, dev_name=%p) returned %d\",\n              (const void *)attr, ldev_dev_name_ptr, result);\n    if (result) {\n        probe_log(\"WRITE_ATTR_2_FAIL: failed to bind device %p to driver %p; errno=%d; returning -errno\",\n                  ldev_ptr, ldrv_ptr, errno);\n        metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n                  ldev->dev_name, ldrv->drv_name);\n        return -errno;\n    }\n\n    metal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n          ldev->dev_name, ldrv->drv_name);\n    probe_log(\"SUCCESS: bound device %p to driver %p; returning 0\",\n              ldev_ptr, ldrv_ptr);\n\n    return 0;\n}\n"
}