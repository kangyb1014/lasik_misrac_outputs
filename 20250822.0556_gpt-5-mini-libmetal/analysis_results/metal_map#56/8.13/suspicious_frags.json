{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of metal_map:\n```c\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function metal_map:\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "static int metal_virt2phys(void *addr, unsigned long *phys)\n{\n    off_t offset;\n    uint64_t entry;\n    int error;\n\n    if (_metal.pagemap_fd < 0)\n        return -EINVAL;\n\n    offset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n    error = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n    if (error < 0) {\n        metal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n              (unsigned long long)offset, strerror(errno));\n        return -errno;\n    }\n\n    /* Check page present and not swapped. */\n    if ((entry >> 62) != 2) {\n        metal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n              (unsigned long long)offset, (unsigned long long)entry);\n        return -ENOENT;\n    }\n\n    *phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n    return 0;\n}\n",
    "int metal_unmap(void *mem, size_t size)\n{\n    return munmap(mem, size) < 0 ? -errno : 0;\n}\n",
    "int metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n    int prot = PROT_READ | PROT_WRITE, error;\n    void *mem;\n\n    flags |= MAP_SHARED;\n\n    if (fd < 0) {\n        fd = -1;\n        flags = MAP_PRIVATE | MAP_ANONYMOUS;\n    } else if (expand) {\n        off_t reqsize = offset + size;\n        struct stat stat;\n\n        error = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n        if (!error)\n            error = fstat(fd, &stat);\n        if (!error && stat.st_size < reqsize)\n            error = ftruncate(fd, reqsize);\n        if (!error)\n            flock(fd, LOCK_UN);\n        if (error)\n            return -errno;\n    }\n\n    mem = mmap(NULL, size, prot, flags, fd, offset);\n    if (mem == MAP_FAILED)\n        return -errno;\n    *result = mem;\n    return 0;\n}\n",
    "static int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n    size_t pages, page, phys_size;\n    struct metal_io_region *io;\n    metal_phys_addr_t *phys;\n    uint8_t *virt;\n    void *mem;\n    int error;\n\n    size = metal_align_up(size, ps->page_size);\n    pages = size / ps->page_size;\n\n    error = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n    if (error) {\n        metal_log(METAL_LOG_WARNING,\n              \"failed to mmap shmem %ld,0x%x - %s\\n\",\n              size, ps->mmap_flags, strerror(-error));\n        return error;\n    }\n    ...\n}\n",
    "dlist_for_each_data(dlist, instance, char) {\n    result = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n              \"%s/%s\", path, instance);\n    if (result >= (int)sizeof(ldev->cls_path))\n        return -EOVERFLOW;\n    result = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n              \"/dev/%s\", instance);\n    if (result >= (int)sizeof(ldev->dev_path))\n        return -EOVERFLOW;\n    break;\n}\n"
  ],
  "explanation": "I identified fragments where pointer parameters or local pointer variables are used in a read-only fashion or otherwise could reasonably be const-qualified, and thus should be investigated for compliance with MISRA C 2023 Rule 8.13. Specifically:\n\n- metal_shmem_try_map: the parameter 'struct metal_page_size *ps' is only read (ps->page_size, ps->mmap_flags, ps->page_shift). It could be a pointer to const-qualified data (const struct metal_page_size *ps) unless other callers rely on a non-const signature.\n\n- metal_virt2phys: the parameter 'void *addr' is not modified; it is used only for address calculations and could be declared as 'const void *addr'. This should be checked to ensure changing to const does not conflict with callers or system APIs.\n\n- The dlist_for_each_data loop: 'instance' is used as a read-only string when formatting paths. It is declared as 'char *instance' by the iterator; it may be more appropriate as 'const char *instance' depending on the dlist API contract.\n\n- metal_map: the function takes 'void **result' and returns an allocated/mapped address via *result. The pointer-to-pointer usage should be reviewed to ensure the pointed-to type is correctly const-qualified where appropriate. Also local use of 'void *mem' is returned to callers as writable memory (mmap with write prot), so the const qualification decision needs review in context of intended mutability.\n\n- metal_unmap: the parameter 'void *mem' is not modified by this wrapper (it forwards to munmap). Consider whether a 'const void *' would be appropriate; note that the underlying munmap API takes a void * address, so any change must account for compatibility.\n\nI did not include other fragments (such as struct linux_bus *lbus, struct linux_device *ldev, ldrv, ldev->fd, phys arrays, io pointers, etc.) because those pointers are used for modification of the referenced objects (fields are assigned, memory is written, regions initialized, or pointers are passed to APIs that expect writable pointers). Therefore they are not candidates for adding const qualification without changing intended behavior. Additionally, some pointers (e.g., buffers like 'path' and 'ldev->cls_path') are local writable arrays used as targets for snprintf and other operations; they must remain non-const. Finally, system-call-related pointers that must match existing API signatures (e.g., munmap/mmap) were only flagged where a const qualification might still be feasible; other system-call parameters that clearly require non-const were not flagged."
}