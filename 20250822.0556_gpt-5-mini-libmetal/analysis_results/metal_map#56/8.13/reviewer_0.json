{
  "user_message": "An agent A claimed that the following metal_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_map.\n```c\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'void *addr' is not const-qualified even though the function does not modify the object pointed to; it is only inspected (cast to uintptr_t) to compute an offset. According to MISRA C 2023 Rule 8.13 this should be declared as 'const void *addr'. (The output parameter 'unsigned long *phys' is correctly non-const because it is written.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_map: fd=6 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d4e94d58\nENTER metal_map: fd=8 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d5e96d58\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nENTER metal_map: fd=10 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d6697d58\nflock(LOCK_EX) returned 0 (errno=0)\nENTER metal_map: fd=7 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d5695d58\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nafter fstat: error=0\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nno truncate needed: st_size=1048576 reqsize=1048576\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nreleased lock, final error=0\nflock(LOCK_EX) returned 0 (errno=0)\nENTER metal_map: fd=13 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d7699d58\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nmmap called: mem=0x7ff5d4595000 size=1048576 prot=0x3 flags=0x1 fd=6 offset=0 errno=0\nreleased lock, final error=0\nmapping success: result=0x7ff5d4595000 returning 0\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nmmap called: mem=0x7ff5d4495000 size=1048576 prot=0x3 flags=0x1 fd=10 offset=0 errno=0\nno truncate needed: st_size=1048576 reqsize=1048576\nmapping success: result=0x7ff5d4495000 returning 0\nreleased lock, final error=0\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final error=0\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final error=0\nmmap called: mem=0x7ff5d4395000 size=1048576 prot=0x3 flags=0x1 fd=8 offset=0 errno=0\nENTER metal_map: fd=9 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5bbffed58\nmapping success: result=0x7ff5d4395000 returning 0\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final error=0\nmmap called: mem=0x7ff5d4295000 size=1048576 prot=0x3 flags=0x1 fd=9 offset=0 errno=0\nmmap called: mem=0x7ff5d4195000 size=1048576 prot=0x3 flags=0x1 fd=7 offset=0 errno=0\nmapping success: result=0x7ff5d4295000 returning 0\nmapping success: result=0x7ff5d4195000 returning 0\nmmap called: mem=0x7ff5d4095000 size=1048576 prot=0x3 flags=0x1 fd=13 offset=0 errno=0\nENTER metal_map: fd=14 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5d6e98d58\nmapping success: result=0x7ff5d4095000 returning 0\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final error=0\nmmap called: mem=0x7ff5d4095000 size=1048576 prot=0x3 flags=0x1 fd=14 offset=0 errno=0\nENTER metal_map: fd=15 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5b37fdd58\nmapping success: result=0x7ff5d4095000 returning 0\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final error=0\nmmap called: mem=0x7ff5d4295000 size=1048576 prot=0x3 flags=0x1 fd=15 offset=0 errno=0\nmapping success: result=0x7ff5d4295000 returning 0\nENTER metal_map: fd=11 offset=0 size=1048576 expand=1 flags=0x0 result_ptr=0x7ff5bb7fdd58\nafter OR MAP_SHARED: flags=0x1 prot=0x3\nexpand branch: computed reqsize=1048576 (offset=0 + size=1048576)\nflock(LOCK_EX) returned 0 (errno=0)\nafter fstat: error=0\nno truncate needed: st_size=1048576 reqsize=1048576\nreleased lock, final er\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_map:\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the function metal_map as shown. metal_map's pointer parameter is void **result, which is used as an output parameter (the function stores the mapped address into *result), so it must not be a pointer-to-const. None of metal_map's other parameters are object pointers that should be const-qualified, so metal_map does not violate MISRA C 2023 Rule 8.13.\n\nThe scenario described by agent A actually matches a different function in the additional code: static int metal_virt2phys(void *addr, unsigned long *phys). In metal_virt2phys the addr parameter is only inspected (cast to uintptr_t) and not used to modify the pointed-to object, so per Rule 8.13 it would be appropriate to declare it as const void *addr. Changing metal_virt2phys to accept const void *addr is safe (callers pass uint8_t * or void * values and these can convert to const void * without casts). Recommendation: change metal_virt2phys(void *addr, ...) to metal_virt2phys(const void *addr, ...).\n\nIn summary: the claimed violation against metal_map is incorrect; the real potential 8.13 issue is in metal_virt2phys, not metal_map."
}