{
  "user_message": "An agent A claimed that the following metal_init_page_sizes code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_init_page_sizes.\n```c\nstatic int metal_init_page_sizes(void)\n{\n\tconst int max_sizes = MAX_PAGE_SIZES - 1;\n\tlong sizes[max_sizes];\n\n\t/* Determine system page size. */\n\tsizes[0] = getpagesize();\n\tif (sizes[0] <= 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to get page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_metal.page_size  = sizes[0];\n\t_metal.page_shift = metal_log2(sizes[0]);\n\tmetal_add_page_size(_metal.tmp_path, _metal.page_shift, 0);\n\n#ifdef HAVE_HUGETLBFS_H\n#ifndef MAP_HUGE_SHIFT\n\t/* System does not support multiple huge page sizes. */\n\tsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n#else\n\tif (gethugepagesize() >= 0) {\n\t\tint i, count;\n\n\t\t/* System supports multiple huge page sizes. */\n\t\tcount = gethugepagesizes(sizes, max_sizes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint shift = metal_log2(sizes[i]);\n\n\t\t\tif ((shift & MAP_HUGE_MASK) != shift)\n\t\t\t\tcontinue;\n\t\t\tmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\t\t}\n\t}\n#endif\n#endif\n\n\t/* Finally sort the resulting array by size. */\n\tqsort(_metal.page_sizes, _metal.num_page_sizes,\n\t      sizeof(struct metal_page_size), metal_pagesize_compare);\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nmetal_add_page_size calls strncpy(_metal.page_sizes[index].path, path, PATH_MAX). In the fragment metal_add_page_size(hugetlbfs_find_path(), metal_log2(sizes[0]), MAP_HUGETLB); the 'path' argument comes from hugetlbfs_find_path(). If hugetlbfs_find_path() returns a pointer to a source buffer whose accessible size is less than PATH_MAX (for example a buffer of size 64 while PATH_MAX is much larger), strncpy may attempt to read up to PATH_MAX bytes from 'path' and thus read beyond the bounds of the source object. That would violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter metal_init_page_sizes: MAX_PAGE_SIZES=32 max_sizes=31\ngetpagesize() -> 4096\n_metal.tmp_path pointer=0x7f5a4ba48be1 page_size=4096 page_shift=12\ncalling metal_add_page_size(temp_path, 12, 0)\ngethugepagesizes() -> count=2\niteration i=0 sizes[0]=2097152 shift=21\nhugetlbfs_find_path_for_size(2097152) returned (nil)\ncalling metal_add_page_size(hp, 21, MAP_HUGETLB | (shift << MAP_HUGE_SHIFT))\niteration i=1 sizes[1]=1073741824 shift=30\nhugetlbfs_find_path_for_size(1073741824) returned (nil)\ncalling metal_add_page_size(hp, 30, MAP_HUGETLB | (shift << MAP_HUGE_SHIFT))\nabout to qsort: num_page_sizes=1\nqsort completed\nenter metal_init_page_sizes: MAX_PAGE_SIZES=32 max_sizes=31\ngetpagesize() -> 4096\n_metal.tmp_path pointer=0x55d86119aba9 page_size=4096 page_shift=12\ncalling metal_add_page_size(temp_path, 12, 0)\ngethugepagesizes() -> count=2\niteration i=0 sizes[0]=2097152 shift=21\nhugetlbfs_find_path_for_size(2097152) returned (nil)\ncalling metal_add_page_size(hp, 21, MAP_HUGETLB | (shift << MAP_HUGE_SHIFT))\niteration i=1 sizes[1]=1073741824 shift=30\nhugetlbfs_find_path_for_size(1073741824) returned (nil)\ncalling metal_add_page_size(hp, 30, MAP_HUGETLB | (shift << MAP_HUGE_SHIFT))\nabout to qsort: num_page_sizes=1\nqsort completed\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_init_page_sizes:\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n...\n#define MAX_PAGE_SIZES 32\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strncpy(dest, path, PATH_MAX) can read up to PATH_MAX bytes from the source pointer 'path'. MISRA C 2023 Rule 21.17 requires that uses of <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the shown code metal_add_page_size there is no guarantee that the incoming 'path' points to an object with at least PATH_MAX accessible bytes or that it is NUL-terminated within PATH_MAX bytes. If hugetlbfs_find_path() (or any caller) returns a pointer to a shorter buffer (or a non-NUL-terminated buffer), strncpy may attempt to read beyond the source object and thus violate Rule 21.17. The execution log does not prove any safety property of the source buffer sizes. Therefore, absent an API contract guaranteeing the source object size/NUL-termination within PATH_MAX, the reported violation is valid."
}