{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_init_page_sizes:\n```c\nstatic int metal_init_page_sizes(void)\n{\n\tconst int max_sizes = MAX_PAGE_SIZES - 1;\n\tlong sizes[max_sizes];\n\n\t/* Determine system page size. */\n\tsizes[0] = getpagesize();\n\tif (sizes[0] <= 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to get page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_metal.page_size  = sizes[0];\n\t_metal.page_shift = metal_log2(sizes[0]);\n\tmetal_add_page_size(_metal.tmp_path, _metal.page_shift, 0);\n\n#ifdef HAVE_HUGETLBFS_H\n#ifndef MAP_HUGE_SHIFT\n\t/* System does not support multiple huge page sizes. */\n\tsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n#else\n\tif (gethugepagesize() >= 0) {\n\t\tint i, count;\n\n\t\t/* System supports multiple huge page sizes. */\n\t\tcount = gethugepagesizes(sizes, max_sizes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint shift = metal_log2(sizes[i]);\n\n\t\t\tif ((shift & MAP_HUGE_MASK) != shift)\n\t\t\t\tcontinue;\n\t\t\tmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\t\t}\n\t}\n#endif\n#endif\n\n\t/* Finally sort the resulting array by size. */\n\tqsort(_metal.page_sizes, _metal.num_page_sizes,\n\t      sizeof(struct metal_page_size), metal_pagesize_compare);\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_init_page_sizes:\n#define MAX_PAGE_SIZES 32\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n...\nstatic int metal_pagesize_compare(const void *_a, const void *_b)\n{\n\tconst struct metal_page_size *a = _a, *b = _b;\n\tlong diff = a->page_size - b->page_size;\n\n\treturn metal_sign(diff);\n}\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#ifdef HAVE_HUGETLBFS_H\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The #ifdef/HAVE_HUGETLBFS_H block is a conditional compilation guard for platform-specific hugepage support. When HAVE_HUGETLBFS_H is not defined the code is excluded at compile time (not \"dead\" in the sense of Rule 2.2 \u2014 it is simply not compiled). When the macro is defined the code performs side effects (calls to metal_add_page_size, setting page sizes) that affect program behaviour and therefore cannot be removed without changing behaviour. There is no evidence here that the code is executed yet redundant (i.e. executed but removable without effect), so Rule 2.2 is not violated."
}