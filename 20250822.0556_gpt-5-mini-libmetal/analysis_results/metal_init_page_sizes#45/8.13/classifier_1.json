{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_init_page_sizes:\n```c\nstatic int metal_init_page_sizes(void)\n{\n\tconst int max_sizes = MAX_PAGE_SIZES - 1;\n\tlong sizes[max_sizes];\n\n\t/* Determine system page size. */\n\tsizes[0] = getpagesize();\n\tif (sizes[0] <= 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to get page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_metal.page_size  = sizes[0];\n\t_metal.page_shift = metal_log2(sizes[0]);\n\tmetal_add_page_size(_metal.tmp_path, _metal.page_shift, 0);\n\n#ifdef HAVE_HUGETLBFS_H\n#ifndef MAP_HUGE_SHIFT\n\t/* System does not support multiple huge page sizes. */\n\tsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n#else\n\tif (gethugepagesize() >= 0) {\n\t\tint i, count;\n\n\t\t/* System supports multiple huge page sizes. */\n\t\tcount = gethugepagesizes(sizes, max_sizes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint shift = metal_log2(sizes[i]);\n\n\t\t\tif ((shift & MAP_HUGE_MASK) != shift)\n\t\t\t\tcontinue;\n\t\t\tmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\t\t}\n\t}\n#endif\n#endif\n\n\t/* Finally sort the resulting array by size. */\n\tqsort(_metal.page_sizes, _metal.num_page_sizes,\n\t      sizeof(struct metal_page_size), metal_pagesize_compare);\n\n\treturn 0;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment itself only shows a call passing the return of hugetlbfs_find_path_for_size(sizes[i]) into metal_add_page_size(...). There is no pointer declaration in this fragment, so from this code alone you cannot prove a Rule 8.13 violation. However a violation would occur in the following concrete scenario: metal_add_page_size is declared to take a non-const char * (e.g. int metal_add_page_size(char *path, ...)) while it only reads the string (does not modify it). In that case the parameter should be const char * and the current non-const pointer parameter would violate MISRA C 2023 Rule 8.13. To fix: change the metal_add_page_size prototype to accept const char * (and, if appropriate, ensure hugetlbfs_find_path_for_size returns const char * when it yields immutable data)."
}