{
  "user_message": "Target function code is:\n```c\nstatic void metal_linux_irq_set_enable(struct metal_irq_controller *irq_cntr,\n\t\t\t\t       int irq, unsigned int state)\n{\n\tint offset, ret;\n\n\tif (irq < irq_cntr->irq_base ||\n\t    irq >= irq_cntr->irq_base + irq_cntr->irq_num) {\n\t\tmetal_log(METAL_LOG_ERROR, \"%s: invalid irq %d\\n\",\n\t\t\t  __func__, irq);\n\t\treturn;\n\t}\n\toffset = irq - linux_irq_cntr.irq_base;\n\tmetal_mutex_acquire(&irq_lock);\n\tif (state == METAL_IRQ_ENABLE)\n\t\tmetal_bitmap_set_bit(irqs_enabled, offset);\n\telse\n\t\tmetal_bitmap_clear_bit(irqs_enabled, offset);\n\tmetal_mutex_release(&irq_lock);\n\t/* Notify IRQ thread that IRQ state has changed */\n\tret = metal_linux_irq_notify();\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to notify set %d enable\\n\",\n\t\t\t  __func__, irq);\n\t}\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_linux_irq_set_enable': {'callees': ['metal_mutex_acquire', 'metal_bitmap_set_bit', 'metal_bitmap_clear_bit', 'metal_mutex_release', 'metal_linux_irq_notify'], 'callers': []}, 'metal_mutex_acquire': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_save_disable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_bitmap_set_bit': {'callees': [], 'callers': ['metal_linux_irq_set_enable']}, 'metal_bitmap_clear_bit': {'callees': [], 'callers': ['metal_linux_irq_set_enable']}, 'metal_mutex_release': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_restore_enable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_linux_irq_notify': {'callees': [], 'callers': ['metal_linux_irq_set_enable', 'metal_linux_irq_shutdown']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "__func__",
    "linux_irq_cntr",
    "struct metal_irq_controller",
    "irq_lock",
    "irqs_enabled",
    "metal_log",
    "METAL_LOG_ERROR",
    "METAL_IRQ_ENABLE",
    "metal_bitmap_set_bit",
    "metal_bitmap_clear_bit",
    "metal_mutex_acquire",
    "metal_mutex_release",
    "metal_linux_irq_notify",
    "headers/defines that introduce the above macros/types (e.g. metal/log.h, metal/irq.h, metal/mutex.h, metal/bitmap.h)"
  ],
  "explanation": "To decide whether metal_linux_irq_set_enable uses any compiler language extensions you must examine the declarations/definitions and macros it relies on (not just the call graph). For each symbol: \n\n- __func__: This is a predefined identifier in C99/C11 but some compilers expose it as an extension or provide alternative predefined identifiers. Check its definition/semantics in the used headers/compilation mode to ensure it is standard and not a compiler-specific extension. \n\n- linux_irq_cntr: The global IRQ controller object must be inspected to see if its definition uses non\u2011standard features (anonymous/embedded structs/unions, compiler attributes, or other extensions). You must also confirm the type of its fields irq_base/irq_num. \n\n- struct metal_irq_controller: The struct layout (field types, bit\u2011fields, flexible array members, attributes like __attribute__((packed)), or compiler-specific keywords) must be checked for extensions. \n\n- irq_lock: The lock variable\u2019s type and its declaration may use typedefs, attributes, or inline assembly or be an alias to a compiler\u2011specific type; inspect its declaration to detect extensions. \n\n- irqs_enabled: The bitmap storage declaration could use compiler extensions (packed bitfields, typeof, __attribute__, unusual typedefs); check its type/definition. \n\n- metal_log: Often a macro or inline function; its implementation may use variadic macros, GCC statement expressions, typeof, __attribute__ annotations, or builtins. Verify whether metal_log is a standard function or implemented with compiler extensions. \n\n- METAL_LOG_ERROR and METAL_IRQ_ENABLE: These macros/constants may be defined via non\u2011standard constructs or rely on other macros that use extensions; inspect their definitions. \n\n- metal_bitmap_set_bit and metal_bitmap_clear_bit: These may be macros or inline functions that use GCC extensions (statement expressions, typeof, __builtin_*, attributes). Examine their definitions. \n\n- metal_mutex_acquire and metal_mutex_release: Their prototypes/implementations could use attributes, inline assembly, or other compiler-specific extensions; check declarations/definitions. \n\n- metal_linux_irq_notify: Its prototype/definition must be checked for attributes or extension usage that could affect how it is called/compiled. \n\n- headers/defines (e.g. metal/log.h, metal/irq.h, metal/mutex.h, metal/bitmap.h): You must inspect the header files that define the above macros, types and functions because compiler extensions are often introduced in headers via macros, attributes or compiler builtins.\n\nIn short: inspect the definitions/declarations of the listed symbols and their header files to detect any use of compiler\u2011specific language extensions (e.g., __attribute__, statement expressions, typeof, inline asm, nonstandard predefined identifiers, anonymous/unnamed struct/union extensions) that would violate the MISRA prohibition on language extensions."
}