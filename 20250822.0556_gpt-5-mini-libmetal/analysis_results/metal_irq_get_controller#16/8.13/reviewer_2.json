{
  "user_message": "An agent A claimed that the following metal_irq_get_controller code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_irq_get_controller.\n```c\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n\tstruct metal_list *node;\n\tstruct metal_irq_controller *cntr;\n\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tint irq_base, irq_end;\n\n\t\tcntr = (struct metal_irq_controller *)\n\t\t       metal_container_of(node, struct metal_irq_controller,\n\t\t\t\t\t  node);\n\t\tirq_base = cntr->irq_base;\n\t\tirq_end = irq_base + cntr->irq_num;\n\t\tif (irq >= irq_base && irq < irq_end) {\n\t\t\treturn cntr;\n\t\t}\n\t}\n\treturn NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro returns an unqualified void* and does not preserve const-qualification of the input pointer. For example, with a const member pointer: const struct metal_list *cnode = ...; struct metal_irq_controller *cntr = (struct metal_irq_controller *)metal_container_of(cnode, struct metal_irq_controller, node); this produces a non-const pointer to an object originally referenced via a const-qualified pointer, allowing modification and thus breaking the requirement that pointers should point to const-qualified types whenever possible.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=6, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=7, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=7, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=7\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=6, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=6, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=6, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=7, about to compute container_of for node=0x7f0bf52f7d60\nmetal_irq_get_controller: irq=7, node=0x7f0bf52f7d60, cntr=0x7f0bf52f7d40, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x7f0bf52f7d40 (irq_base=0, irq_num=1023) for irq=7\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=6, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=7, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=7, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=7\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=6, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=6, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=6, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=6, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=6\nmetal_irq_get_controller: irq=7, about to compute container_of for node=0x55d2dbc5c580\nmetal_irq_get_controller: irq=7, node=0x55d2dbc5c580, cntr=0x55d2dbc5c560, irq_base=0, irq_end=1023\nmetal_irq_get_controller: returning cntr=0x55d2dbc5c560 (irq_base=0, irq_num=1023) for irq=7\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_irq_get_controller:\nstruct metal_irq_controller {\n\tint irq_base; /**< Start of IRQ number of the range managed by\n\t\t \t* the IRQ controller\n\t\t \t*/\n\tint irq_num; /**< Number of IRQs managed by the IRQ controller */\n\tvoid *arg; /**< Argument to pass to interrupt controller function */\n\tmetal_irq_set_enable irq_set_enable; /**< function to set IRQ enable */\n\tmetal_cntr_irq_register irq_register; /**< function to register IRQ\n\t\t\t\t\t\t* handler\n\t\t\t\t\t\t*/\n\tstruct metal_list node; /**< list node */\n\tstruct metal_irq *irqs; /**< Array of IRQs managed by the controller */\n}\n...\nstruct metal_list {\n\tstruct metal_list *next, *prev;\n}\n...\nstatic METAL_DECLARE_LIST(irq_cntrs)\n...\n#define metal_list_for_each(list, node) for((node)=(list)->next;(node)!=(list);(node)=(node)->next)\n...\n#define metal_container_of(ptr, structure, member) (void*)((uintptr_t)(ptr)-metal_offset_of(structure,member))\n...\nstatic void _metal_irq_set_enable(int irq, unsigned int state)\n{\n\tstruct metal_irq_controller *cntr;\n\n\tcntr = metal_irq_get_controller(irq);\n\tif (cntr == NULL) {\n\t\treturn;\n\t}\n\tcntr->irq_set_enable(cntr, irq, state);\n}\n...\nint metal_irq_register(int irq,\n\t\t       metal_irq_handler irq_handler,\n\t\t       void *arg)\n{\n\tstruct metal_irq_controller *cntr;\n\tstruct metal_irq *irq_data;\n\n\tcntr = metal_irq_get_controller(irq);\n\tif (cntr == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (cntr->irq_register != NULL) {\n\t\treturn cntr->irq_register(cntr, irq, irq_handler, arg);\n\t}\n\tif (cntr->irqs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tirq_data = &cntr->irqs[irq - cntr->irq_base];\n\tirq_data->hd = irq_handler;\n\tirq_data->arg = arg;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for this function. MISRA C 2023 Rule 8.13 recommends that pointers should be const-qualified when they do not allow modification of the pointed object. In metal_irq_get_controller the list traversal variable node is declared as a non-const struct metal_list * and the function intentionally returns a non-const struct metal_irq_controller * (the callers use that pointer to call controller methods and to modify controller state). Thus there is no lost constness in this function: the pointers are non-const throughout and the function returns a modifiable controller pointer as intended.\n\nThe scenario raised by agent A (calling metal_container_of with a const struct metal_list * and getting back a non-const pointer) points out a separate concern about the metal_container_of macro design: because it produces an unqualified void * it can indeed strip const qualification if misused, and that could lead to a const-qualification violation at the call site. However, that potential problem is with the macro usage in contexts where callers pass const pointers (or with the macro definition itself), not with the shown metal_irq_get_controller function, which does not pass const pointers and where returning a non-const controller pointer is appropriate.\n\nTherefore the claim that metal_irq_get_controller violates MISRA C 2023 Rule 8.13 is incorrect. If desired, the macro could be redesigned to preserve const-qualification to avoid future misuse, but that is a separate issue."
}