{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe macro returns an unqualified void* and does not preserve const-qualification of the input pointer. For example, with a const member pointer: const struct metal_list *cnode = ...; struct metal_irq_controller *cntr = (struct metal_irq_controller *)metal_container_of(cnode, struct metal_irq_controller, node); this produces a non-const pointer to an object originally referenced via a const-qualified pointer, allowing modification and thus breaking the requirement that pointers should point to const-qualified types whenever possible.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_irq_get_controller code that contains useful probe functions that print useful logs to a file \"/tmp/logs/163.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_irq_get_controller as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_irq_get_controller:\n```c\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n\tstruct metal_list *node;\n\tstruct metal_irq_controller *cntr;\n\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tint irq_base, irq_end;\n\n\t\tcntr = (struct metal_irq_controller *)\n\t\t       metal_container_of(node, struct metal_irq_controller,\n\t\t\t\t\t  node);\n\t\tirq_base = cntr->irq_base;\n\t\tirq_end = irq_base + cntr->irq_num;\n\t\tif (irq >= irq_base && irq < irq_end) {\n\t\t\treturn cntr;\n\t\t}\n\t}\n\treturn NULL;\n}\n```\n</target_code>\nPlease provide the modified metal_irq_get_controller code.\n",
  "test_code": "#include <stdio.h>\n\n/* Probe helper: append a log line with formatted controller state */\nstatic void metal_irq_probe_log_iteration(int irq,\n                                         struct metal_list *node,\n                                         struct metal_irq_controller *cntr,\n                                         int irq_base,\n                                         int irq_end)\n{\n    FILE *f = fopen(\"/tmp/logs/163.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"metal_irq_get_controller: irq=%d, node=%p, cntr=%p, irq_base=%d, irq_end=%d\\n\",\n                irq, (void *)node, (void *)cntr, irq_base, irq_end);\n        fclose(f);\n    }\n}\n\n/* Probe helper: log when container_of cast is about to be performed */\nstatic void metal_irq_probe_before_container_of(int irq, struct metal_list *node)\n{\n    FILE *f = fopen(\"/tmp/logs/163.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"metal_irq_get_controller: irq=%d, about to compute container_of for node=%p\\n\",\n                irq, (void *)node);\n        fclose(f);\n    }\n}\n\n/* Probe helper: log the return value (either pointer or NULL) */\nstatic void metal_irq_probe_return(int irq, struct metal_irq_controller *cntr)\n{\n    FILE *f = fopen(\"/tmp/logs/163.txt\", \"a\");\n    if (f) {\n        if (cntr) {\n            fprintf(f, \"metal_irq_get_controller: returning cntr=%p (irq_base=%d, irq_num=%d) for irq=%d\\n\",\n                    (void *)cntr, cntr->irq_base, cntr->irq_num, irq);\n        } else {\n            fprintf(f, \"metal_irq_get_controller: returning NULL for irq=%d\\n\", irq);\n        }\n        fclose(f);\n    }\n}\n\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n    struct metal_list *node;\n    struct metal_irq_controller *cntr;\n\n    metal_list_for_each(&irq_cntrs, node) {\n        int irq_base, irq_end;\n\n        /* Log the node before performing the container_of cast. This captures\n         * the pointer used as input to the macro that may drop const-qualification.\n         */\n        metal_irq_probe_before_container_of(irq, node);\n\n        cntr = (struct metal_irq_controller *)\n               metal_container_of(node, struct metal_irq_controller,\n                                  node);\n\n        irq_base = cntr->irq_base;\n        irq_end = irq_base + cntr->irq_num;\n\n        /* Log the computed state for this iteration. */\n        metal_irq_probe_log_iteration(irq, node, cntr, irq_base, irq_end);\n\n        if (irq >= irq_base && irq < irq_end) {\n            /* Log the return value (non-NULL) and return the controller. */\n            metal_irq_probe_return(irq, cntr);\n            return cntr;\n        }\n    }\n\n    /* Log the return of NULL when no controller matched. */\n    metal_irq_probe_return(irq, NULL);\n    return NULL;\n}\n"
}