{
  "user_message": "Target function code is:\n```c\nstatic void metal_softirq_set_enable(struct metal_irq_controller *cntr,\n\t\t\t\t     int irq, unsigned int enable)\n{\n\tif (irq < cntr->irq_base ||\n\t    irq >= (cntr->irq_base + cntr->irq_num)) {\n\t\treturn;\n\t}\n\n\tirq -= cntr->irq_base;\n\tif (enable ==  METAL_IRQ_ENABLE) {\n\t\tatomic_store(&metal_softirq_enabled[irq], 1);\n\t} else {\n\t\tatomic_store(&metal_softirq_enabled[irq], 0);\n\t}\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_softirq_enabled",
    "METAL_IRQ_ENABLE",
    "struct metal_irq_controller",
    "atomic_store",
    "stdatomic.h",
    "__atomic_store_n",
    "atomic_int / atomic_uint / _Atomic (the actual atomic element type used for metal_softirq_enabled)"
  ],
  "explanation": "To decide whether the target function uses a compiler language extension (MISRA rule check) you must inspect the declarations/definitions that determine whether any non-standard/compiler-specific constructs are used:\n\n- metal_softirq_enabled: the array declaration (and linkage) is required so you can see the element type and how atomic operations are applied. If the elements are declared with compiler builtins or nonstandard types, that would be a language extension.\n\n- METAL_IRQ_ENABLE: the macro definition is needed to determine whether it is a plain integer macro (standard) or something created with compiler-specific attributes/macros (possible extension).\n\n- struct metal_irq_controller: the struct definition (types of irq_base and irq_num and any attributes or bitfields) is required to check for use of compiler-specific struct features (anonymous members, extended bitfield widths, attributes, packed/alignas extensions).\n\n- atomic_store: you must see the declaration/definition or macro that provides atomic_store in this build unit. atomic_store itself can be the standard C11 facility from <stdatomic.h>, or it can be a project wrapper or a macro that expands to compiler builtins \u2014 only by inspecting its definition can you tell whether a language extension is used.\n\n- stdatomic.h: presence or absence of the standard header (and whether it is the standard implementation) matters. If atomic_store comes from the C11 <stdatomic.h> facility, that is a standard language/library feature; if not present and project maps atomics to compiler builtins, that indicates use of extensions.\n\n- __atomic_store_n: common GCC/Clang builtin used by many projects as a replacement for C11 atomics. You need to see if atomic_store ultimately expands/calls this builtin (or other __atomic/__sync builtins). Those builtins are documented compiler extensions and would violate the MISRA constraint being checked.\n\n- atomic_int / atomic_uint / _Atomic (the actual atomic element type used for metal_softirq_enabled): the exact atomic type keyword or typedef used (e.g., atomic_int, _Atomic int, or some project typedef) determines whether only standard C11 atomics are used or whether compiler-specific typedefs/keywords are present.\n\nCollecting these symbols/definitions lets the next analyzer determine if atomic operations and related types are implemented via standard C11 facilities or via compiler-specific builtins/macros (the latter being language extensions that must be reported)."
}