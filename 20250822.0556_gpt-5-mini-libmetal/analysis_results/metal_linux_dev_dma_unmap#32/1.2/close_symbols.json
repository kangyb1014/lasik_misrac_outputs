{
  "user_message": "Target function code is:\n```c\nstatic void metal_linux_dev_dma_unmap(struct metal_bus *bus,\n\t\t\t\t      struct metal_device *device,\n\t\t\t\t      uint32_t dir,\n\t\t\t\t      struct metal_sg *sg,\n\t\t\t\t      int nents)\n{\n\tstruct linux_device *ldev = to_linux_device(device);\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\n\tldev->ldrv->dev_dma_unmap(lbus, ldev, dir, sg,\n\t\t\t\t       nents);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_linux_dev_dma_unmap': {'callees': ['to_linux_device', 'to_linux_bus'], 'callers': []}, 'to_linux_device': {'callees': [], 'callers': ['metal_linux_dev_close', 'metal_linux_dev_irq_ack', 'metal_linux_dev_dma_map', 'metal_linux_dev_dma_unmap', 'metal_linux_get_device_property']}, 'to_linux_bus': {'callees': [], 'callers': ['metal_linux_dev_open', 'metal_linux_dev_close', 'metal_linux_bus_close', 'metal_linux_dev_irq_ack', 'metal_linux_dev_dma_map', 'metal_linux_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "to_linux_device (definition)",
    "to_linux_bus (definition)",
    "container_of (macro) / any macros used by to_linux_device/to_linux_bus",
    "offsetof (definition) if used by the above macros",
    "struct linux_device (definition)",
    "struct linux_bus (definition)",
    "type of ldev->ldrv (e.g. struct linux_driver) (definition)",
    "dev_dma_unmap member prototype / function-pointer declaration",
    "struct metal_bus (definition)",
    "struct metal_device (definition)",
    "struct metal_sg (definition)",
    "uint32_t typedef / stdint.h inclusion"
  ],
  "explanation": "You must inspect the definitions listed above because the MISRA check asks whether any compiler language extensions are used anywhere required to understand the target call. Concretely:\n\n- to_linux_device (definition): this helper may be a macro or inline function that hides extensions (e.g. GCC __typeof__, statement-expressions, __extension__, cast tricks). Examining its definition shows whether such extensions are used.\n- to_linux_bus (definition): same reason as to_linux_device.\n- container_of (macro) / any macros used by to_linux_device/to_linux_bus: common implementations use GCC-only extensions (typeof, statement-expression). If to_linux_* expands to container_of, you must check that macro for extensions.\n- offsetof (definition) if used: some nonstandard implementations or uses can involve compiler-specific behavior; check its definition if referenced.\n- struct linux_device (definition): the target dereferences ldev->ldrv; the struct definition may include attributes (e.g. __attribute__((packed/aligned))), anonymous structs/unions, or other nonstandard constructs.\n- struct linux_bus (definition): passed to ldrv->dev_dma_unmap; inspect for attributes or extensions in its declaration.\n- type of ldev->ldrv (e.g. struct linux_driver) (definition): its type must be inspected because the member dev_dma_unmap could be declared using compiler extensions or have nonstandard storage-class/attributes.\n- dev_dma_unmap member prototype / function-pointer declaration: the call uses this member; its declaration may include GCC attributes, calling convention annotations, or other extensions \u2014 these must be checked.\n- struct metal_bus, struct metal_device, struct metal_sg (definitions): the parameter types and any macros used in their definitions may contain extensions (anonymous/packed fields, attributes). Even if not dereferenced here, their declarations are part of the visible interface and must be checked for extensions.\n- uint32_t typedef / stdint.h inclusion: confirm that uint32_t is a standard typedef and not a compiler-specific alias or extension.\n\nCollecting and inspecting these symbols lets the next agent determine whether any language/compiler extensions are used in the code paths and types the target function depends on."
}