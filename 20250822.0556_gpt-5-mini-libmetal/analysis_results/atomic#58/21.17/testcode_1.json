{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 pthread_create returns 0 on success or a positive error number on failure, but the code stores error = -pthread_create(...). On failure error is negative and the code calls strerror(error). Passing a negative errnum to strerror can cause the strerror implementation to index its internal message table out-of-bounds (or otherwise exhibit undefined/implementation-defined behaviour), so this use can result in accesses beyond the bounds of objects inside the string routine. Example: pthread_create returns EAGAIN (e.g. 11), code sets error = -11 and then calls strerror(-11). This may lead to out-of-range access in strerror. The correct behaviour would be to call strerror(-error) or avoid negating the pthread_create return value before passing it to strerror (or use strerror_r).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified atomic code that contains useful probe functions that print useful logs to a file \"/tmp/logs/589.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of atomic as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of atomic:\n```c\nstatic int atomic(void)\n{\n\tconst int threads = 10;\n\tatomic_int counter = ATOMIC_VAR_INIT(0);\n\tint value, error;\n\n\terror = metal_run(threads, atomic_thread, &counter);\n\tif (!error) {\n\t\tvalue = atomic_load(&counter);\n\t\tvalue -= atomic_test_count * threads;\n\t\tif (value) {\n\t\t\tmetal_log(METAL_LOG_DEBUG, \"counter mismatch, delta = %d\\n\",\n\t\t\t\t  value);\n\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\n\treturn error;\n}\n```\n</target_code>\nPlease provide the modified atomic code.\n",
  "test_code": "static void probe_log_state(const char *stage, int threads, int metal_run_ret, int counter_val, int delta, int error_val)\n{\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (!f)\n        return;\n    /* Log key state values so the control flow and numeric state are recorded. */\n    fprintf(f, \"%s: threads=%d metal_run_ret=%d counter_val=%d delta=%d error=%d\\n\",\n            stage, threads, metal_run_ret, counter_val, delta, error_val);\n    fclose(f);\n}\n\nstatic int atomic(void)\n{\n\tconst int threads = 10;\n\tatomic_int counter = ATOMIC_VAR_INIT(0);\n\tint value, error;\n\n\t/* Log entry state */\n\tprobe_log_state(\"enter_atomic\", threads, 0, 0, 0, 0);\n\n\terror = metal_run(threads, atomic_thread, &counter);\n\t/* Log result from metal_run immediately */\n\tprobe_log_state(\"after_metal_run\", threads, error, 0, 0, error);\n\n\tif (!error) {\n\t\tvalue = atomic_load(&counter);\n\t\t/* compute delta in same way as original code */\n\t\tint delta = value - atomic_test_count * threads;\n\t\tvalue = delta; /* preserve original logic: value -= atomic_test_count * threads */\n\n\t\t/* Log after computing delta */\n\t\tprobe_log_state(\"after_atomic_load_and_delta\", threads, error, atomic_load(&counter), delta, error);\n\n\t\tif (value) {\n\t\t\tmetal_log(METAL_LOG_DEBUG, \"counter mismatch, delta = %d\\n\",\n\t\t\t\t  value);\n\t\t\t/* Log occurrence of mismatch and the error we will set */\n\t\t\tprobe_log_state(\"counter_mismatch\", threads, error, value, delta, -EINVAL);\n\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\n\t/* Final log before return */\n\tprobe_log_state(\"return_atomic\", threads, error, atomic_load(&counter), atomic_test_count * threads, error);\n\n\treturn error;\n}\n"
}