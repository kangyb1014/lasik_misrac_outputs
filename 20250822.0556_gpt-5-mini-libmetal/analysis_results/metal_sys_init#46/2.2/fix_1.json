{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern void metal_log(int level, const char *fmt, ...);\nstatic void metal_probe_log(const char *msg)\n{\n    FILE *f;\n    /* Ensure the directory exists (best-effort). */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/462.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n}\nstatic void metal_probe_log_params(const struct metal_init_params *params, const char *label)\n{\n    FILE *f;\n    (void)mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/462.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"[%s] params pointer=%p\\n\", label, (const void *)params);\n    /* We do not dereference params because its contents are unknown here. */\n    fclose(f);\n}\n\nint metal_sys_init(const struct metal_init_params *params)\n{\n    const char *tmp_path;\n    unsigned int seed;\n    FILE *urandom;\n    int result;\n\n    /* Entry probe */\n    metal_probe_log(\"enter: metal_sys_init\");\n    metal_probe_log_params(params, \"entry\");\n\n    /* Find the temporary directory location. */\n    tmp_path = getenv(\"TMPDIR\");\n    if (!tmp_path)\n        tmp_path = \"/tmp\";\n    _metal.tmp_path = tmp_path;\n\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"tmp_path set to %s\", _metal.tmp_path);\n        metal_probe_log(buf);\n    }\n\n    /* Initialize the pseudo-random number generator. */\n    urandom = fopen(\"/dev/urandom\", \"r\");\n    if (!urandom) {\n        metal_log( /* METAL_LOG_ERROR */ 3, \"failed to open /dev/urandom (%s)\\n\",\n                  strerror(errno));\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"failed to open /dev/urandom: errno=%d (%s)\", errno, strerror(errno));\n            metal_probe_log(buf);\n        }\n        return -errno;\n    }\n\n    metal_probe_log(\"/dev/urandom opened\");\n\n    if (fread(&seed, 1, sizeof(seed), urandom) <= 0) {\n        metal_log( /* METAL_LOG_DEBUG */ 7, \"Failed fread /dev/urandom\\n\");\n        metal_probe_log(\"fread on /dev/urandom returned <= 0\");\n    } else {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"seed read from /dev/urandom = %u\", seed);\n        metal_probe_log(buf);\n    }\n    fclose(urandom);\n    metal_probe_log(\"/dev/urandom closed\");\n\n    srand(seed);\n    metal_probe_log(\"srand(seed) called\");\n\n    result = metal_init_page_sizes();\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"metal_init_page_sizes returned %d\", result);\n        metal_probe_log(buf);\n    }\n    if (result < 0)\n        return result;\n\n    result = metal_linux_bus_init();\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"metal_linux_bus_init returned %d\", result);\n        metal_probe_log(buf);\n    }\n    if (result < 0)\n        return result;\n\n    result = open(\"/proc/self/pagemap\", O_RDONLY | O_CLOEXEC);\n    if (result < 0) {\n        metal_log( /* METAL_LOG_DEBUG */ 7, \"Failed pagemap open - %s\\n\",\n                  strerror(errno));\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"Failed pagemap open: errno=%d (%s)\", errno, strerror(errno));\n            metal_probe_log(buf);\n        }\n    }\n    _metal.pagemap_fd = result;\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"pagemap_fd=%d\", _metal.pagemap_fd);\n        metal_probe_log(buf);\n    }\n\n    /* Probe params immediately before the potentially dead self-assignment */\n    metal_probe_log_params(params, \"before_metal_unused\");\n\n    /* The original code called metal_unused(params); keep it to preserve logic. */\n    metal_unused(params);\n\n    /* Probe params immediately after the call to capture any observable change\n       (the reported issue states this is a no-op). */\n    metal_probe_log_params(params, \"after_metal_unused\");\n\n    /* Initialize IRQ handling */\n    metal_probe_log(\"calling metal_linux_irq_init\");\n    metal_linux_irq_init();\n    metal_probe_log(\"exit: metal_sys_init (success)\");\n    return 0;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\nIn file included from /tmp/tmpzjow7zgu/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmpzjow7zgu/src/lib/system/linux/init.c:26:\n/tmp/tmpzjow7zgu/build/lib/include/metal/log.h:98:37: error: expected identifier or '(' before '{' token\n   98 | #define metal_log(level, fmt, ...) ({                              \\\n      |                                     ^\n/tmp/tmpzjow7zgu/src/lib/system/linux/init.c:122:13: note: in expansion of macro 'metal_log'\n  122 | extern void metal_log(int level, const char *fmt, ...);\n      |             ^~~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:230: lib/CMakeFiles/metal-shared.dir/system/linux/init.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_sys_init as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void metal_probe_log(const char *msg)\n{\n    FILE *f;\n    /* Ensure the directory exists (best-effort). */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/462.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n}\nstatic void metal_probe_log_params(const struct metal_init_params *params, const char *label)\n{\n    FILE *f;\n    (void)mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/462.txt\", \"a\");\n    if (!f)\n        return;\n    fprintf(f, \"[%s] params pointer=%p\\n\", label, (const void *)params);\n    /* We do not dereference params because its contents are unknown here. */\n    fclose(f);\n}\n\nint metal_sys_init(const struct metal_init_params *params)\n{\n    const char *tmp_path;\n    unsigned int seed;\n    FILE *urandom;\n    int result;\n\n    /* Entry probe */\n    metal_probe_log(\"enter: metal_sys_init\");\n    metal_probe_log_params(params, \"entry\");\n\n    /* Find the temporary directory location. */\n    tmp_path = getenv(\"TMPDIR\");\n    if (!tmp_path)\n        tmp_path = \"/tmp\";\n    _metal.tmp_path = tmp_path;\n\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"tmp_path set to %s\", _metal.tmp_path);\n        metal_probe_log(buf);\n    }\n\n    /* Initialize the pseudo-random number generator. */\n    urandom = fopen(\"/dev/urandom\", \"r\");\n    if (!urandom) {\n        metal_log( /* METAL_LOG_ERROR */ 3, \"failed to open /dev/urandom (%s)\\n\",\n                  strerror(errno));\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"failed to open /dev/urandom: errno=%d (%s)\", errno, strerror(errno));\n            metal_probe_log(buf);\n        }\n        return -errno;\n    }\n\n    metal_probe_log(\"/dev/urandom opened\");\n\n    if (fread(&seed, 1, sizeof(seed), urandom) <= 0) {\n        metal_log( /* METAL_LOG_DEBUG */ 7, \"Failed fread /dev/urandom\\n\");\n        metal_probe_log(\"fread on /dev/urandom returned <= 0\");\n    } else {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"seed read from /dev/urandom = %u\", seed);\n        metal_probe_log(buf);\n    }\n    fclose(urandom);\n    metal_probe_log(\"/dev/urandom closed\");\n\n    srand(seed);\n    metal_probe_log(\"srand(seed) called\");\n\n    result = metal_init_page_sizes();\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"metal_init_page_sizes returned %d\", result);\n        metal_probe_log(buf);\n    }\n    if (result < 0)\n        return result;\n\n    result = metal_linux_bus_init();\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"metal_linux_bus_init returned %d\", result);\n        metal_probe_log(buf);\n    }\n    if (result < 0)\n        return result;\n\n    result = open(\"/proc/self/pagemap\", O_RDONLY | O_CLOEXEC);\n    if (result < 0) {\n        metal_log( /* METAL_LOG_DEBUG */ 7, \"Failed pagemap open - %s\\n\",\n                  strerror(errno));\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"Failed pagemap open: errno=%d (%s)\", errno, strerror(errno));\n            metal_probe_log(buf);\n        }\n    }\n    _metal.pagemap_fd = result;\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"pagemap_fd=%d\", _metal.pagemap_fd);\n        metal_probe_log(buf);\n    }\n\n    /* Probe params immediately before the potentially dead self-assignment */\n    metal_probe_log_params(params, \"before_metal_unused\");\n\n    /* The original code called metal_unused(params); keep it to preserve logic. */\n    metal_unused(params);\n\n    /* Probe params immediately after the call to capture any observable change\n       (the reported issue states this is a no-op). */\n    metal_probe_log_params(params, \"after_metal_unused\");\n\n    /* Initialize IRQ handling */\n    metal_probe_log(\"calling metal_linux_irq_init\");\n    metal_linux_irq_init();\n    metal_probe_log(\"exit: metal_sys_init (success)\");\n    return 0;\n}\n",
  "explanation": "The compilation error was caused by the file redeclaring metal_log while a macro named metal_log (using a statement-expression) is already defined in an included header. Redeclaring a function with the same name as a macro is invalid. I fixed the code by removing the conflicting extern declaration for metal_log. No other logic was changed; the rest of metal_sys_init and the helper probe functions remain intact."
}