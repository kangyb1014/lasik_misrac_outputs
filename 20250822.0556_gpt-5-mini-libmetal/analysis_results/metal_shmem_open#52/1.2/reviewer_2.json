{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to metal_log expands a macro that uses GNU compiler extensions: the macro is defined with a statement-expression ({ ... }) and uses the token-pasting trick '##__VA_ARGS__' to swallow a trailing comma. Both are documented compiler extensions (GNU C/CPP), so invoking metal_log uses language extensions.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f70196ade20\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f7018eace20\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f7013ffee20\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f7019eaee20\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f701aeb0e20\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->0x7f701b7737d0\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->0x7f701b7737d0\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->0x7f701b7737d0\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->0x7f701b7737d0\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f701a6afe20\n2025-08-22 06:09:39 - after metal_open: return=6\n2025-08-22 06:09:39 - after metal_open: return=9\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f70137fde20\n2025-08-22 06:09:39 - after metal_open: return=7\n2025-08-22 06:09:39 - after metal_open: return=10\n2025-08-22 06:09:39 - after metal_open: return=15\n2025-08-22 06:09:39 - open succeeded, fd=6\n2025-08-22 06:09:39 - open succeeded, fd=7\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - open succeeded, fd=9\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - open succeeded, fd=10\n2025-08-22 06:09:39 - open succeeded, fd=15\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - after metal_open: return=18\n2025-08-22 06:09:39 - after metal_open: return=11\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f7012ffce20\n2025-08-22 06:09:39 - open succeeded, fd=18\n2025-08-22 06:09:39 - open succeeded, fd=11\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - after metal_open: return=8\n2025-08-22 06:09:39 - open succeeded, fd=8\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - metal_shmem_try_map returned 0 for page_size=4096, result->0x7f7008001780\n2025-08-22 06:09:39 - mapping succeeded with page_size=4096\n2025-08-22 06:09:39 - closing fd=7, final error=0\n2025-08-22 06:09:39 - exit metal_shmem_open: returning 0\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f70127fbe20\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - after metal_open: return=7\n2025-08-22 06:09:39 - open succeeded, fd=7\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - enter metal_shmem_open: name=/foo size=1048576 result_ptr=0x7f7011ffae20\n2025-08-22 06:09:39 - after metal_shmem_open_generic: error=-2 result->(nil)\n2025-08-22 06:09:39 - after metal_open: return=12\n2025-08-22 06:09:39 - open succeeded, fd=12\n2025-08-22 06:09:39 - page size iter: ps=0x558189a73800 page_size=4096\n2025-08-22 06:09:39 - metal_shmem_try_map returned 0 for page_size=4096, result->0x7f700c001560\n2025-08-22 06:09:39 - mapping succeeded with page_size=4096\n2025-08-22 06:09:39 - closing fd=9, final error=0\n2025-08-22 06:09:39 - exit metal_shmem_open: returning 0\n2025-08-22 06:09:39 - metal_shmem_try_map returned 0 for page_size=4096, result->0x7f6fe4001560\n2025-08-22 06:09:39 - metal_shmem_try_map returned 0 for page_size=4096, resul\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\n#define metal_for_each_page_size_down(ps) for((ps)=&_metal.page_sizes[_metal.num_page_sizes-1];(ps)>=&_metal.page_sizes[0];(ps)--)\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The metal_log macro in the additional code uses two documented compiler extensions: the GCC statement-expression construct ({ ... }) and the token-pasting trick '##__VA_ARGS__' to swallow a trailing comma. Both are not standard ISO C constructs (they are documented as extensions in compiler docs) and the target function calls that macro. Under MISRA C 2023 Rule 1.2 (language extensions should not be used), this constitutes a violation."
}