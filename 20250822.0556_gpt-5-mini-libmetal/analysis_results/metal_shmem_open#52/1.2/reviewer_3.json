{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe metal_log macro is defined using GCC-specific extensions: a statement-expression ({ ... }) and the GNU/clang comma-swallowing token pasting (##__VA_ARGS__). The call metal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\", strerror(errno)); thus relies on these compiler extensions and violates MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_shmem_open_generic returned -2\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_open('/foo', 1) returned 6\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_shmem_open_generic returned -2\nmetal_open('/foo', 1) returned 9\ngot fd=6\nmetal_open('/foo', 1) returned 8\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\ngot fd=9\nmetal_open('/foo', 1) returned 16\nloop: page_size=4096, threshold=2*size=2097152\ngot fd=8\nmetal_open('/foo', 1) returned 18\nmetal_open('/foo', 1) returned 20\nmetal_open('/foo', 1) returned 12\nmetal_open('/foo', 1) returned 21\nloop: page_size=4096, threshold=2*size=2097152\nmetal_open('/foo', 1) returned 15\ngot fd=16\nmetal_open('/foo', 1) returned 7\ntrying metal_shmem_try_map with page_size=4096, fd=6, size=1048576\ngot fd=15\nloop: page_size=4096, threshold=2*size=2097152\ngot fd=18\ngot fd=20\ngot fd=12\ngot fd=21\ntrying metal_shmem_try_map with page_size=4096, fd=9, size=1048576\nloop: page_size=4096, threshold=2*size=2097152\ngot fd=7\nloop: page_size=4096, threshold=2*size=2097152\ntrying metal_shmem_try_map with page_size=4096, fd=8, size=1048576\nloop: page_size=4096, threshold=2*size=2097152\nloop: page_size=4096, threshold=2*size=2097152\ntrying metal_shmem_try_map with page_size=4096, fd=15, size=1048576\nloop: page_size=4096, threshold=2*size=2097152\nloop: page_size=4096, threshold=2*size=2097152\ntrying metal_shmem_try_map with page_size=4096, fd=16, size=1048576\nloop: page_size=4096, threshold=2*size=2097152\ntrying metal_shmem_try_map with page_size=4096, fd=18, size=1048576\ntrying metal_shmem_try_map with page_size=4096, fd=20, size=1048576\ntrying metal_shmem_try_map with page_size=4096, fd=12, size=1048576\ntrying metal_shmem_try_map with page_size=4096, fd=21, size=1048576\ntrying metal_shmem_try_map with page_size=4096, fd=7, size=1048576\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=16, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=12, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=8, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=7, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=21, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=6, returning error=0\nclosed fd=18, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=15, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=20, returning error=0\nmetal_shmem_try_map returned 0\nmetal_shmem_try_map succeeded for page_size=4096\nclosed fd=9, returning error=0\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nmetal_shmem_open_generic returned -2\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_open('/foo', 1) returned 6\nmetal_open('/foo', 1) returned 8\nmetal_open('/foo', 1) returned 7\nENTER metal_shmem_open: name='/foo', size=1048576\nmetal_shmem_open_generic returned -2\ngot fd=6\ngot fd=8\ngot fd=7\nmetal_sh\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\n#define metal_for_each_page_size_down(ps) for((ps)=&_metal.page_sizes[_metal.num_page_sizes-1];(ps)>=&_metal.page_sizes[0];(ps)--)\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The macro metal_log is defined using GCC/Clang language extensions: it uses a statement-expression ({ ... }) and the GNU extension to swallow the comma via '##__VA_ARGS__' (and the macro parameter form used is nonstandard). These constructs are documented compiler extensions and therefore violate MISRA C 2023 Rule 1.2 (which forbids use of language extensions unless they are explicitly allowed). Note: the rest of the metal_shmem_open function source is standard C, but the call sites (metal_log(...)) rely on the non\u2011standard macro definition, so that usage should be reported."
}