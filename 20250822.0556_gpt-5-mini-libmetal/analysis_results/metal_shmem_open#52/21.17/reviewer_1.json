{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling metal_shmem_open_generic with name == NULL (no validation before strcmp) causes strcmp(shmem->name, name) to dereference a NULL pointer leading to out-of-bounds access. Similarly, if either shmem->name or the caller-provided name is not NUL-terminated, strcmp may read past the object bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067e9e4e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067e1e3e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067d9e2e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067f1e5e20\n  name: pointer non-NULL\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f06801e7e20\n  name: pointer non-NULL\nmetal_open OK: fd=6, name=0x559559977198\nmetal_open OK: fd=9, name=0x559559977198\nmetal_open OK: fd=7, name=0x559559977198\nmetal_open OK: fd=10, name=0x559559977198\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067f9e6e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067d1e1e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f067c9e0e20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f065fffee20\n  name: pointer non-NULL\nENTER metal_shmem_open: name=0x559559977198, size=1048576, result=0x7f065f7fde20\n  name: pointer non-NULL\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nAFTER metal_shmem_open_generic: ret=-2, name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nCALL metal_open with name=0x559559977198\nmetal_open OK: fd=8, name=0x559559977198\nmetal_open OK: fd=16, name=0x559559977198\nmetal_open OK: fd=11, name=0x559559977198\nmetal_open OK: fd=13, name=0x559559977198\nmetal_open OK: fd=19, name=0x559559977198\nmetal_open OK: fd=15, name=0x559559977198\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=7, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=13, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=19, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=16, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=10, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=6, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=11, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=9, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=15, requested_size=1048576, ret=0\nTRY MAP: ps=0x55955997c800, page_size=4096, fd=8, requested_size=1048576, ret=0\nENTER metal_shmem_open: name=0x55a3f933e198, size=1048576, result=0x7efee27fbe20\n  name: pointer non-NULL\nAFTER metal_shmem_open_generic: ret=-2, name=0x55a3f933e198\nENTER metal_shmem_open: name=0x55a3f933e198, size=1048576, result=0x7efee2ffce20\n  name: pointer non-NULL\nCALL metal_open with name=0x55a3f933e198\nAFTER metal_shmem_open_generic: ret=-2, name=0x55a3f933e198\nENTER metal_shmem_open: name=0x55a3f933e198, size=1048576, result=0x7efee37fde20\n  name: pointer non-NULL\nmetal_open OK: fd=6, name=0x55a3f933e198\nCALL metal_open with name=0x55a3f933e198\nAFTER metal_shmem_open_generic: ret=-2, name=0x55a3f933e198\nENTER metal_shmem_open: name=0x55a3f933e198, size=1048576, result=0x7efee3ffee20\n  name: pointer non-NULL\nmetal_open OK: fd=7, name=0x55a3f933e198\nCALL metal_open with name=0x55a3f933\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n...\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. metal_shmem_open calls metal_shmem_open_generic(name, ...), and metal_shmem_open_generic uses strcmp(shmem->name, name) without validating the caller-supplied pointer 'name' (or verifying NUL-termination). If a caller passes name == NULL, strcmp will dereference the NULL pointer and produce out-of-bounds access/undefined behavior. Likewise, if either operand is not NUL-terminated, strcmp may read past the object bounds. The later check in metal_open (!path || !strlen(path)) does not prevent the earlier strcmp call in metal_shmem_open_generic, so the code as written can lead to a violation of MISRA C:2023 Rule 21.17. To comply, the code should validate the incoming 'name' (non-NULL and a bounded/NUL-terminated string) before calling strcmp (or use a bounded comparison API and documented preconditions)."
}