{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.2.\nHere is the comment from the agent.\n<violation scenario>\nViolation: the for-statement first clause uses the comma expression 'virt = mem, page = 0' which assigns to virt in addition to initializing the loop counter (page). Clause 1 requires the first clause to be empty or an expression that sets or defines/initializes the loop counter; having an extra side\u2011effect on another object (virt) in the first clause violates Rule 14.2. (Fix: initialize virt before the loop or use a separate declaration/initialization for the loop counter, e.g. 'virt = mem; for (page = 0; page < pages; ++page) {...}')\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_shmem_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/524.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_shmem_open as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_shmem_open:\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\nPlease provide the modified metal_shmem_open code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <sys/types.h>\n\n/* Forward declarations for external functions used by the original code. */\nint metal_shmem_open_generic(const char *name, size_t size,\n                             struct metal_io_region **result);\nint metal_open(const char *name, int flags);\nvoid metal_log(int level, const char *fmt, ...);\nint metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n                        struct metal_io_region **result);\n\n/* Minimal type definitions to allow compilation. The real project will\n   provide the complete definitions. */\nstruct metal_io_region { /* opaque for test compilation */ };\nstruct metal_page_size {\n    size_t page_size;\n    struct metal_page_size *next; /* allow simple iteration in test code */\n};\n\n/* Head of the page-size list. The real program supplies this. */\nextern struct metal_page_size *metal_page_sizes_head;\n\n/* Probe helper: append a log entry to the file. Keep it minimal and\n   robust: do nothing if the file cannot be opened. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/524.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nint metal_shmem_open(const char *name, size_t size,\n                     struct metal_io_region **result)\n{\n    struct metal_page_size *ps;\n    int fd, error;\n\n    probe_log(\"metal_shmem_open: enter name='%s' size=%zu\", name ? name : \"(null)\", size);\n\n    error = metal_shmem_open_generic(name, size, result);\n    probe_log(\"metal_shmem_open: metal_shmem_open_generic returned %d\", error);\n    if (!error) {\n        probe_log(\"metal_shmem_open: generic open succeeded -> returning %d\", error);\n        return error;\n    }\n\n    error = metal_open(name, 1);\n    probe_log(\"metal_shmem_open: metal_open returned %d\", error);\n    if (error < 0) {\n        probe_log(\"metal_shmem_open: Failed to open shmem file '%s' (error=%d)\", name ? name : \"(null)\", error);\n        metal_log(0 /* METAL_LOG_ERROR placeholder */, \"Failed to open shmem file :%s\\n\", name);\n        return error;\n    }\n    fd = error;\n    probe_log(\"metal_shmem_open: using fd=%d\", fd);\n\n    /* Iterate through page sizes in decreasing order.\n       The original code used a macro 'metal_for_each_page_size_down(ps)'.\n       For test instrumentation we iterate the linked list starting at\n       metal_page_sizes_head. This preserves the original loop body while\n       making the control flow explicit for logging. */\n    for (ps = metal_page_sizes_head; ps != NULL; ps = ps->next) {\n        probe_log(\"metal_shmem_open: checking page_size=%zu against size=%zu\", ps->page_size, size);\n        if (ps->page_size > 2 * size) {\n            probe_log(\"metal_shmem_open: skipping page_size=%zu (too large)\", ps->page_size);\n            continue;\n        }\n        probe_log(\"metal_shmem_open: attempting try_map with page_size=%zu\", ps->page_size);\n        error = metal_shmem_try_map(ps, fd, size, result);\n        probe_log(\"metal_shmem_open: metal_shmem_try_map returned %d for page_size=%zu\", error, ps->page_size);\n        if (!error) {\n            probe_log(\"metal_shmem_open: mapping succeeded with page_size=%zu -> breaking loop\", ps->page_size);\n            break;\n        }\n    }\n\n    probe_log(\"metal_shmem_open: closing fd=%d and returning %d\", fd, error);\n    close(fd);\n    return error;\n}\n"
}