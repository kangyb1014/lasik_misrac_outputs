{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: the for-statement first clause uses the comma expression 'virt = mem, page = 0' which assigns to virt in addition to initializing the loop counter (page). Clause 1 requires the first clause to be empty or an expression that sets or defines/initializes the loop counter; having an extra side\u2011effect on another object (virt) in the first clause violates Rule 14.2. (Fix: initialize virt before the loop or use a separate declaration/initialization for the loop counter, e.g. 'virt = mem; for (page = 0; page < pages; ++page) {...}')\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: enter name='/foo' size=1048576\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_open returned 9\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_open returned 15\nmetal_shmem_open: using fd=9\nmetal_shmem_open: metal_open returned 11\nmetal_shmem_open: metal_open returned 17\nmetal_shmem_open: metal_open returned 10\nmetal_shmem_open: metal_open returned 18\nmetal_shmem_open: metal_open returned 21\nmetal_shmem_open: using fd=15\nmetal_shmem_open: metal_open returned 13\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: using fd=11\nmetal_shmem_open: metal_open returned 7\nmetal_shmem_open: using fd=17\nmetal_shmem_open: using fd=10\nmetal_shmem_open: using fd=18\nmetal_shmem_open: using fd=21\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: using fd=7\nmetal_shmem_open: using fd=13\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: metal_shmem_open_generic returned -2\nmetal_shmem_open: metal_open returned 6\nmetal_shmem_open: using fd=6\nmetal_shmem_open: checking page_size=4096 against size=1048576\nmetal_shmem_open: attempting try_map with page_size=4096\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\nmetal_shmem_open: closing fd=13 and returning 0\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\nmetal_shmem_open: closing fd=10 and returning 0\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\nmetal_shmem_open: closing fd=21 and returning 0\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\nmetal_shmem_open: closing fd=15 and returning 0\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\nmetal_shmem_open: closing fd=6 and returning 0\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: metal_shmem_try_map returned 0 for page_size=4096\nmetal_shmem_open: mapping succeeded with page_size=4096 -> breaking loop\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's diagnosis is correct: the code violates MISRA C 2023 Rule 14.2. The offending for-statement is in metal_shmem_try_map (called by metal_shmem_open) and uses the first clause expression 'virt = mem, page = 0'. Clause 1 of Rule 14.2 requires the first clause to be empty or solely to set/define/initialize the loop counter. The comma expression also assigns to virt (a separate object), which is an additional side-effect and therefore not permitted. \n\nNote: the report attributes the violation to metal_shmem_open, but the actual problematic loop appears in metal_shmem_try_map (shown in the additional code). The problem and the suggested fix given by Agent A are appropriate: initialize virt before the loop or declare/initialize the loop counter in the for statement, for example:\n- virt = mem; for (page = 0; page < pages; ++page) { ... }\nor\n- for (page = 0; page < pages; ++page) { size_t offset = page * ps->page_size; ... } with virt set beforehand.\nThese changes remove the extra side-effect from the first clause and make the for loop compliant with Rule 14.2."
}