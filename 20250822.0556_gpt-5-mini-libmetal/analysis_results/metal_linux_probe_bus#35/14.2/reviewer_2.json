{
  "user_message": "An agent A claimed that the following metal_linux_probe_bus code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_bus.\n```c\nstatic int metal_linux_probe_bus(struct linux_bus *lbus)\n{\n\tstruct linux_driver *ldrv;\n\tint ret, error = -ENODEV;\n\n\tlbus->sbus = sysfs_open_bus(lbus->bus_name);\n\tif (!lbus->sbus)\n\t\treturn -ENODEV;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tret = metal_linux_probe_driver(lbus, ldrv);\n\t\t/* Clear the error if any driver is available */\n\t\tif (!ret)\n\t\t\terror = ret;\n\t}\n\n\tif (error) {\n\t\tmetal_linux_bus_close(&lbus->bus);\n\t\treturn error;\n\t}\n\n\terror = metal_linux_register_bus(lbus);\n\tif (error)\n\t\tmetal_linux_bus_close(&lbus->bus);\n\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro for_each_linux_driver(lbus, ldrv) hides the for-statement clauses. If it expands to a single-counter loop that uses only ldrv in the test and the iteration expressions (for example: for (ldrv = first_driver(lbus); ldrv != NULL; ldrv = ldrv->next)), then Rule 14.2 is satisfied. However, if the expansion uses lbus (or any other object) in the second or third clause and that object is modified (directly or via called functions) in the loop body, or if it employs more than one loop counter, the rule is violated. Example violating expansion: for (ldrv = first_driver(lbus); ldrv != NULL && bus_active(lbus); ldrv = next_driver(lbus, ldrv)) where bus_active(lbus) or next_driver(lbus,\u2026) depend on lbus which is modified in the loop body \u2014 this breaches clauses 2/3 and the single-counter requirement. Without the macro definition compliance cannot be proven; check the macro expansion. \n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_linux_probe_bus: lbus=0x7f1842f35b60, bus_name=platform\nsysfs_open_bus returned sbus=0x5595089368c0 for bus_name=platform\nBEGIN for_each_linux_driver loop for lbus=0x7f1842f35b60\n  LOOP ITERATION: ldrv=0x7f1842f35bc0, lbus->sbus=0x5595089368c0\n    metal_linux_probe_driver returned ret=0 for ldrv=0x7f1842f35bc0\n    driver probe succeeded, clearing error (was -19)\n  LOOP ITERATION: ldrv=0x7f1842f35c08, lbus->sbus=0x5595089368c0\n    metal_linux_probe_driver returned ret=0 for ldrv=0x7f1842f35c08\n    driver probe succeeded, clearing error (was 0)\nEND for_each_linux_driver loop for lbus=0x7f1842f35b60, error=0\nmetal_linux_register_bus returned 0 for lbus=0x7f1842f35b60\nRegistration succeeded for lbus=0x7f1842f35b60\nEXIT metal_linux_probe_bus: lbus=0x7f1842f35b60, returning 0\nENTER metal_linux_probe_bus: lbus=0x7f1842f36dc8, bus_name=pci\nsysfs_open_bus returned sbus=0x559508936d60 for bus_name=pci\nBEGIN for_each_linux_driver loop for lbus=0x7f1842f36dc8\n  LOOP ITERATION: ldrv=0x7f1842f36e28, lbus->sbus=0x559508936d60\n    metal_linux_probe_driver returned ret=0 for ldrv=0x7f1842f36e28\n    driver probe succeeded, clearing error (was -19)\n  LOOP ITERATION: ldrv=0x7f1842f36e70, lbus->sbus=0x559508936d60\n    metal_linux_probe_driver returned ret=0 for ldrv=0x7f1842f36e70\n    driver probe succeeded, clearing error (was 0)\nEND for_each_linux_driver loop for lbus=0x7f1842f36dc8, error=0\nmetal_linux_register_bus returned 0 for lbus=0x7f1842f36dc8\nRegistration succeeded for lbus=0x7f1842f36dc8\nEXIT metal_linux_probe_bus: lbus=0x7f1842f36dc8, returning 0\nENTER metal_linux_probe_bus: lbus=0x55de87484260, bus_name=platform\nsysfs_open_bus returned sbus=0x55de9e1af8c0 for bus_name=platform\nBEGIN for_each_linux_driver loop for lbus=0x55de87484260\n  LOOP ITERATION: ldrv=0x55de874842c0, lbus->sbus=0x55de9e1af8c0\n    metal_linux_probe_driver returned ret=0 for ldrv=0x55de874842c0\n    driver probe succeeded, clearing error (was -19)\n  LOOP ITERATION: ldrv=0x55de87484308, lbus->sbus=0x55de9e1af8c0\n    metal_linux_probe_driver returned ret=0 for ldrv=0x55de87484308\n    driver probe succeeded, clearing error (was 0)\nEND for_each_linux_driver loop for lbus=0x55de87484260, error=0\nmetal_linux_register_bus returned 0 for lbus=0x55de87484260\nRegistration succeeded for lbus=0x55de87484260\nEXIT metal_linux_probe_bus: lbus=0x55de87484260, returning 0\nENTER metal_linux_probe_bus: lbus=0x55de874854c8, bus_name=pci\nsysfs_open_bus returned sbus=0x55de9e1afd60 for bus_name=pci\nBEGIN for_each_linux_driver loop for lbus=0x55de874854c8\n  LOOP ITERATION: ldrv=0x55de87485528, lbus->sbus=0x55de9e1afd60\n    metal_linux_probe_driver returned ret=0 for ldrv=0x55de87485528\n    driver probe succeeded, clearing error (was -19)\n  LOOP ITERATION: ldrv=0x55de87485570, lbus->sbus=0x55de9e1afd60\n    metal_linux_probe_driver returned ret=0 for ldrv=0x55de87485570\n    driver probe succeeded, clearing error (was 0)\nEND for_each_linux_driver loop for lbus=0x55de874854c8, error=0\nmetal_linux_register_bus returned 0 for lbus=0x55de874854c8\nRegistration succeeded for lbus=0x55de874854c8\nEXIT metal_linux_probe_bus: lbus=0x55de874854c8, returning 0\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The for loop is provided via the macro for_each_linux_driver(lbus, ldrv), so the actual three clauses of the for statement are hidden. MISRA C 2023 Rule 14.2 requires properties of those clauses (single loop counter, test clause must have no persistent side effects and only use the loop counter/optional boolean flag, increment clause must only modify the loop counter, and the loop counter must not be modified in the loop body \u2014 including via called functions). Without the macro expansion you cannot prove those requirements hold. The execution log shows in these runs that lbus->sbus was unchanged and iterations used ldrv only, which is evidence that a compliant expansion is likely, but it is not a formal proof. If the macro expands to a single-counter loop that uses only ldrv in the test and iteration expressions (e.g. for (ldrv = first_driver(lbus); ldrv != NULL; ldrv = ldrv->next)) then Rule 14.2 is satisfied; if it includes lbus (or other objects) in the test or increment and those objects are modified (directly or by functions called in the body), or if it uses more than one loop counter, then Rule 14.2 is violated. To resolve definitively, inspect the macro expansion and any functions used in the loop clauses and body."
}