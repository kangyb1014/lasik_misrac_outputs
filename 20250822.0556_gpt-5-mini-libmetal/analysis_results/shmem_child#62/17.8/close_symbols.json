{
  "user_message": "Target function code is:\n```c\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'shmem_child': {'callees': ['metal_shmem_open', 'metal_io_virt', 'metal_io_phys', 'metal_io_phys_to_virt', 'metal_io_virt_to_phys', 'metal_io_finish'], 'callers': []}, 'metal_shmem_open': {'callees': ['metal_shmem_open_generic', 'metal_open', 'metal_shmem_try_map'], 'callers': ['shmem_child']}, 'metal_io_virt': {'callees': [], 'callers': ['metal_io_block_read', 'metal_io_block_write', 'metal_io_block_set', 'shmem_child']}, 'metal_io_phys': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_phys_to_virt': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_virt_to_phys': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_finish': {'callees': [], 'callers': ['shmem_child']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_shmem_open",
    "metal_io_virt",
    "metal_io_phys",
    "metal_io_phys_to_virt",
    "metal_io_virt_to_phys",
    "metal_io_finish",
    "atomic_fetch_add",
    "nb_err",
    "metal_log",
    "METAL_LOG_ERROR",
    "METAL_BAD_OFFSET"
  ],
  "explanation": "To decide if shmem_child modifies its function parameter (void *arg) we must be sure no called routine or macro can change the caller's parameter variable or otherwise perform unexpected assignments to it. For that we need:\n\n- metal_shmem_open: its prototype/definition to confirm it does not expect a pointer-to-pointer or a reference that could modify the caller's parameter (and to check whether it is a macro/inline that could expand to code touching 'arg'/'name').\n\n- metal_io_virt, metal_io_phys, metal_io_phys_to_virt, metal_io_virt_to_phys, metal_io_finish: prototypes/definitions to ensure none of these take or derive the address of the local parameter/alias (or are macros that expand into code that assigns to the parameter variable). They are the direct callees in the function and could contain side effects; we must confirm they cannot modify the value of shmem_child's parameter.\n\n- atomic_fetch_add and nb_err: the call atomic_fetch_add(&nb_err, 1) appears in the function. We need the declaration/type of atomic_fetch_add and the definition/type of nb_err to confirm this is an operation on a global atomic object (not something that would alias or mutate the local parameter variable via macro expansion or unexpected signature).\n\n- metal_log and METAL_LOG_ERROR: metal_log might be a macro or inline helper that could expand to complex code; we need its definition (and the logging constant) to rule out any side-effects that alter the parameter variable.\n\n- METAL_BAD_OFFSET: its value/definition is needed only insofar as any comparison or macro logic around it could be involved in macros that change program state; including it keeps the analysis complete.\n\nIn short, these symbols let the analyzer verify whether any callee or macro used inside shmem_child can modify the pointer parameter itself (which would violate the MISRA rule). If all these symbols show normal by-value parameter usage and no macro expansions that assign to caller-local variables, shmem_child does not modify its parameter."
}