{
  "user_message": "An agent A claimed that the following metal_virt2phys code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_virt2phys.\n```c\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'virt' is only used for address arithmetic and passed (without being dereferenced for modification) to metal_virt2phys. The code never writes through 'virt', so it could be declared as 'const uint8_t *virt'. Because it is declared as a non-const pointer even though the pointee is not modified, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=enter addr=0x7feec26fd000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec26fd000 offset=0x3ff76137e8 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec1cfc000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec25fd000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec1cfc000 offset=0x3ff760e7e0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec26fd000 offset=0x3ff76137e8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=before_pread addr=0x7feec25fd000 offset=0x3ff7612fe8 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec1bfc000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=success addr=0x7feec26fd000 offset=0x3ff76137e8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=enter addr=0x7feec26fe000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec1bfc000 offset=0x3ff760dfe0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec26fe000 offset=0x3ff76137f0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec25fd000 offset=0x3ff7612fe8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=after_pread addr=0x7feec1bfc000 offset=0x3ff760dfe0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec25fd000 offset=0x3ff7612fe8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec1bfc000 offset=0x3ff760dfe0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=after_pread addr=0x7feec26fe000 offset=0x3ff76137f0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=after_pread addr=0x7feec1cfc000 offset=0x3ff760e7e0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=enter addr=0x7feec25fe000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec1bfd000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=success addr=0x7feec26fe000 offset=0x3ff76137f0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec1cfc000 offset=0x3ff760e7e0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=before_pread addr=0x7feec25fe000 offset=0x3ff7612ff0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec1bfd000 offset=0x3ff760dfe8 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec26ff000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec1cfd000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec26ff000 offset=0x3ff76137f8 pread_ret=0 entry=0x0 ret=0\nstage=before_pread addr=0x7feec1cfd000 offset=0x3ff760e7e8 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec19fc000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=enter addr=0x7feec1afc000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec25fe000 offset=0x3ff7612ff0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=after_pread addr=0x7feec1bfd000 offset=0x3ff760dfe8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=after_pread addr=0x7feec1cfd000 offset=0x3ff760e7e8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=before_pread addr=0x7feec19fc000 offset=0x3ff760cfe0 pread_ret=0 entry=0x0 ret=0\nstage=success addr=0x7feec25fe000 offset=0x3ff7612ff0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=before_pread addr=0x7feec1afc000 offset=0x3ff760d7e0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec26ff000 offset=0x3ff76137f8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec1bfd000 offset=0x3ff760dfe8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec1cfd000 offset=0x3ff760e7e8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=enter addr=0x7feec25ff000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec19fc000 offset=0x3ff760cfe0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=enter addr=0x7feec1cfe000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=after_pread addr=0x7feec1afc000 offset=0x3ff760d7e0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=enter addr=0x7feec1bfe000 offset=0x0 pread_ret=0 entry=0x0 ret=0\nstage=success addr=0x7feec26ff000 offset=0x3ff76137f8 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=success addr=0x7feec19fc000 offset=0x3ff760cfe0 pread_ret=8 entry=0xa080000000000000 ret=0\nstage=before_pread addr=0x7feec1cfe000 offset=0x3ff760e7f0 pread\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_virt2phys:\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. metal_virt2phys takes a void *addr but never uses it to modify the pointee \u2014 it only converts it to an integer (uintptr_t) for address arithmetic. According to MISRA C 2023 Rule 8.13, a pointer should be to a const-qualified type whenever possible, so the parameter should be declared const void *addr. Likewise, in metal_shmem_try_map the local variable virt is only used for address arithmetic and passed to metal_virt2phys; it could be declared const uint8_t *virt. Changing the function signature to static int metal_virt2phys(const void *addr, unsigned long *phys) (and adjusting call sites as needed) would resolve the violation. If there is an overriding API compatibility reason or other justification for leaving it non-const, that should be documented as a deviation; otherwise the code violates Rule 8.13."
}