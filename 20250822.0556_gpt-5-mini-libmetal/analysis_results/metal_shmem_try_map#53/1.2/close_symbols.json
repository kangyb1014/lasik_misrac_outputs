{
  "user_message": "Target function code is:\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_shmem_try_map': {'callees': ['metal_map', 'metal_unmap', 'metal_io_init', 'metal_virt2phys'], 'callers': ['metal_shmem_open']}, 'metal_map': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_unmap': {'callees': [], 'callers': ['metal_uio_dev_close', 'metal_shmem_io_close', 'metal_shmem_try_map']}, 'metal_io_init': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_virt2phys': {'callees': [], 'callers': ['metal_shmem_try_map']}, 'metal_shmem_open': {'callees': ['metal_shmem_open_generic', 'metal_open', 'metal_shmem_try_map'], 'callers': ['shmem_child']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_phys_addr_t",
    "struct metal_page_size",
    "struct metal_io_region",
    "_metal (global)",
    "metal_shmem_io_ops",
    "metal_align_up",
    "metal_map",
    "metal_unmap",
    "metal_io_init",
    "metal_virt2phys",
    "metal_log",
    "METAL_LOG_WARNING",
    "METAL_BAD_OFFSET"
  ],
  "explanation": "For determining whether the target function uses any compiler language extensions you must inspect any referenced types, macros, globals and functions for implementation-defined or compiler-specific constructs (e.g. __attribute__, typeof, statement-expressions ({ ... }), nested functions, inline asm, nonstandard integer types like __int128, compiler-specific macro tricks). Each listed symbol is required for the following reasons:\n\n- metal_phys_addr_t: this is the element type used for the phys[] array and METAL_BAD_OFFSET \u2014 its typedef may use compiler-specific integer types or attributes (e.g. __int128, __attribute__, or compiler-specific width specifiers).\n- struct metal_page_size: the function accesses ps->page_size, ps->mmap_flags and ps->page_shift. The struct definition could contain compiler extensions (attributes, bit-fields with nonstandard widths, packed/aligned, etc.).\n- struct metal_io_region: the object allocated and initialized by metal_io_init; the struct layout could use extensions (flexible array members vs GCC extension, attributes) that affect legality under MISRA rule.\n- _metal (global): the code reads _metal.pagemap_fd; the global's type or initializer could be created using extensions or attributes (visibility, section, constructor attributes) that must be checked.\n- metal_shmem_io_ops: passed by address to metal_io_init \u2014 the ops object may be defined using compiler-specific attributes, inline functions, or GCC extension constructs.\n- metal_align_up: used to round size \u2014 may be a macro or inline that uses compiler extensions (typeof, statement-expression, GNU container_of-like tricks). Inspect to ensure no extensions are used.\n- metal_map: the function/macro used to map memory. Its declaration/definition may be a macro using extensions, or have nonstandard attributes or ABI-influencing keywords.\n- metal_unmap: same rationale as metal_map \u2014 could be macro/inline using extensions.\n- metal_io_init: initializer for io region; its implementation or prototype could use compiler-specific extensions (attributes, inline asm, nonstandard calling conventions).\n- metal_virt2phys: used in a loop \u2014 its prototype/definition may use extensions (attribute, builtin usage) or be implemented as a nested function/macro using extensions.\n- metal_log: logging helper used with format strings; often implemented as a macro or inline that can contain GCC extensions (variadic macros, format attribute is OK but must be checked for nonstandard extensions like statement-expressions).\n- METAL_LOG_WARNING: logging level macro/enum \u2014 check its definition in case it is produced by macros using extensions.\n- METAL_BAD_OFFSET: special constant assigned to phys[] when virt2phys fails; its definition may use casts or compiler constants that rely on extensions.\n\nInspecting these symbols (their typedefs, macros, declarations and definitions) is necessary to conclude whether the target function or its immediate dependencies use any compiler-specific language extensions that would violate the stated MISRA rule."
}