{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIndirect recursion: metal_shmem_try_map calls metal_io_init(io, ..., &metal_shmem_io_ops). metal_io_init calls metal_sys_io_mem_map(io). If metal_shmem_io_ops contains a callback (e.g. mem_map) that is implemented by metal_shmem_try_map and metal_sys_io_mem_map invokes that callback during initialization, the call chain becomes metal_shmem_try_map -> metal_io_init -> metal_sys_io_mem_map -> ops->mem_map (metal_shmem_try_map), producing indirect recursion and violating MISRA C 2023 Rule 17.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=6, size=1048576, result=0x7f61737fde20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=7, size=1048576, result=0x7f6173ffee20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=11, size=1048576, result=0x7f61795e8e20)\naligned size -> 1048576 (page_size=4096)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=10, size=1048576, result=0x7f6178de7e20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=14, size=1048576, result=0x7f617a5eae20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=15, size=1048576, result=0x7f6179de9e20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=18, size=1048576, result=0x7f6172ffce20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=19, size=1048576, result=0x7f61727fbe20)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=20, size=1048576, result=0x7f6171ffae20)\naligned size -> 1048576 (page_size=4096)\naligned size -> 1048576 (page_size=4096)\npages computed -> 256\naligned size -> 1048576 (page_size=4096)\naligned size -> 1048576 (page_size=4096)\naligned size -> 1048576 (page_size=4096)\nENTRY: metal_shmem_try_map(ps=0x55dc8f9ad800, page_size=4096, fd=13, size=1048576, result=0x7f61717f9e20)\naligned size -> 1048576 (page_size=4096)\naligned size -> 1048576 (page_size=4096)\nmetal_map returned error=0, mem=0x7f61784e8000\naligned size -> 1048576 (page_size=4096)\npages computed -> 256\npages computed -> 256\npages computed -> 256\npages computed -> 256\npages computed -> 256\naligned size -> 1048576 (page_size=4096)\npages computed -> 256\npages computed -> 256\npages computed -> 256\npages computed -> 256\nmlock returned 0 (errno=0: Success)\nmetal_map returned error=0, mem=0x7f61783e8000\nmalloc phys: requested 2048 bytes -> phys=0x7f616c000d50\nmalloc io: requested 112 bytes -> io=0x7f616c001560\n_metal.pagemap_fd = 4\nmlock returned 0 (errno=0: Success)\nmetal_map returned error=0, mem=0x7f61782e8000\nmetal_map returned error=0, mem=0x7f61781e8000\nmetal_map returned error=0, mem=0x7f61780e8000\nmetal_map returned error=0, mem=0x7f6170efa000\nmetal_map returned error=0, mem=0x7f6170dfa000\nmlock returned 0 (errno=0: Success)\nmetal_map returned error=0, mem=0x7f6170cfa000\nmalloc phys: requested 2048 bytes -> phys=0x7f6160000d50\nmetal_map returned error=0, mem=0x7f6170bfa000\nmalloc io: requested 112 bytes -> io=0x7f6160001560\n_metal.pagemap_fd = 4\nmlock returned 0 (errno=0: Success)\nmetal_map returned error=0, mem=0x7f6170afa000\nmalloc phys: requested 2048 bytes -> phys=0x7f6164000d50\nmetal_virt2phys page=0 addr=0x7f61784e8000 -> error=0 phys[0]=0\nmalloc io: requested 112 bytes -> io=0x7f6164001560\n_metal.pagemap_fd = 4\nmetal_virt2phys page=0 addr=0x7f61780e8000 -> error=0 phys[0]=0\nmlock returned 0 (errno=0: Success)\nmlock returned 0 (errno=0: Success)\nmlock returned 0 (errno=0: Success)\nmlock returned 0 (errno=0: Success)\nmalloc phys: requested 2048 bytes -> phys=0x7f6148000d50\nmalloc phys: requested 2048 bytes -> phys=0x7f6154000d50\nmetal_virt2phys page=0 addr=0x7f61783e8000 -> error=0 phys[0]=0\nmalloc io: requested 112 bytes -> io=0x7f6148001560\nmalloc io: requested 112 bytes -> io=0x7f6154001560\nmetal_virt2phys page=1 addr=0x7f61784e9000 -> error=0 phys[1]=0\nmalloc phys: requested 2048 bytes -> phys=0x7f6168000d50\nmalloc phys: requested 2048 bytes -> phys=0x7f6158000d50\n_metal.pagemap_fd = 4\n_metal.pagemap_fd = 4\nmalloc io: requested 112 bytes -> io=0x7f6158001560\nmalloc io: requested 112 bytes -> io=0x7f6168001560\nmetal_virt2phys page=1 addr=0x7f61780e9000 -> error=0 phys[1]=0\nmetal_virt2phys page=0 addr=0x7f6170cfa000 -> error=0 phys[0]=0\n_metal.pagemap_fd = 4\n_metal.pagemap_fd = 4\nmalloc phys: requested 2048 bytes -> phys=0x7f614c000d50\nmetal_virt2phys page=1 addr=0x7f61783e9000 -> error=0 phys[1]=0\nmetal_virt2phys page=2 addr=0x7f61784ea000 -> error=0 phys[2]=0\nmetal_virt2phys page=0 addr=0x7f6170efa000 -> error=0 phys[0]=0\nmetal_virt2phys page=2 addr=0x7f61780ea000 -> error=0 phys[2]=0\nmetal_virt2phys page=1 addr=0x7f6170\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the provided code and evidence. metal_shmem_try_map calls metal_io_init(..., &metal_shmem_io_ops). metal_io_init copies the ops struct into io->ops and then calls metal_sys_io_mem_map(io). For the reported indirect recursion to occur, three conditions must hold simultaneously: (1) metal_sys_io_mem_map must invoke an operation in io->ops during initialization (plausible), (2) the particular operation invoked (for example a mem_map callback) must be the function metal_shmem_try_map, and (3) that operation's signature must be compatible with metal_shmem_try_map so that it was actually assigned. None of those conditions are demonstrated in the supplied code. In particular: (a) metal_shmem_try_map\u2019s signature (struct metal_page_size *, int, size_t, struct metal_io_region **) does not match the usual io ops callback signatures (which normally take an io region and different parameters), so it is very unlikely that metal_shmem_try_map is placed into the io ops table as a callback without an explicit, unsafe cast (not shown). (b) There is no definition of metal_shmem_io_ops in the materials; nothing shows that any op in that table points back to metal_shmem_try_map. (c) The execution log shows many top-level entries of metal_shmem_try_map but provides no evidence of a call chain returning into metal_shmem_try_map from metal_sys_io_mem_map \u2014 i.e. no recursion observed. Therefore the hypothetical call chain metal_shmem_try_map -> metal_io_init -> metal_sys_io_mem_map -> ops->mem_map (metal_shmem_try_map) is speculative and not supported by the code shown. Conclusion: the report of a MISRA 17.2 violation is not correct for the provided code as given."
}