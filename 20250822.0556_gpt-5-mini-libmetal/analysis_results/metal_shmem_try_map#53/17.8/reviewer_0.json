{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe value parameter 'size' is overwritten by the assignment `size = metal_align_up(size, ps->page_size);` in metal_shmem_try_map. Modifying a function parameter (even a value parameter) violates MISRA C 2023 Rule 17.8. Recommended fix: do not assign to the parameter\u2014use a local variable, e.g. `size_t aligned_size = metal_align_up(size, ps->page_size);` and use aligned_size thereafter.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=7 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=8 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=6 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=11 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] original size before align: 1048576\n[pid:1954770] original size before align: 1048576\n[pid:1954770] original size before align: 1048576\n[pid:1954770] original size before align: 1048576\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=14 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] original size before align: 1048576\n[pid:1954770] metal_map succeeded: mem=0x7f87745b7000 size=1048576\n[pid:1954770] metal_map succeeded: mem=0x7f87744b7000 size=1048576\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=13 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] metal_map succeeded: mem=0x7f87743b7000 size=1048576\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] original size before align: 1048576\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] mlock succeeded: mem=0x7f87745b7000 size=1048576\n[pid:1954770] metal_map succeeded: mem=0x7f87742b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] mlock succeeded: mem=0x7f87744b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] phys allocated: 0x7f8760000d50\n[pid:1954770] phys allocated: 0x7f8768000d50\n[pid:1954770] io allocated: 0x7f8760001560\n[pid:1954770] _metal.pagemap_fd >= 0: attempting virt2phys for each page (pages=256)\n[pid:1954770] io allocated: 0x7f8768001560\n[pid:1954770] _metal.pagemap_fd >= 0: attempting virt2phys for each page (pages=256)\n[pid:1954770] mlock succeeded: mem=0x7f87743b7000 size=1048576\n[pid:1954770] metal_map succeeded: mem=0x7f87741b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] metal_map succeeded: mem=0x7f87740b7000 size=1048576\n[pid:1954770] enter metal_shmem_try_map: ps=0x55f01f3f3800 fd=10 size=1048576 page_size=4096 mmap_flags=0x0\n[pid:1954770] virt2phys succeeded for page 0 offset=0 phys[0]=0\n[pid:1954770] virt2phys succeeded for page 0 offset=0 phys[0]=0\n[pid:1954770] phys allocated: 0x7f8758000d50\n[pid:1954770] original size before align: 1048576\n[pid:1954770] io allocated: 0x7f8758001560\n[pid:1954770] size after metal_align_up: 1048576 (page_size=4096)\n[pid:1954770] _metal.pagemap_fd >= 0: attempting virt2phys for each page (pages=256)\n[pid:1954770] computed pages: 256 (size=1048576 page_size=4096)\n[pid:1954770] mlock succeeded: mem=0x7f87742b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] mlock succeeded: mem=0x7f87741b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] mlock succeeded: mem=0x7f87740b7000 size=1048576\n[pid:1954770] allocating phys array: phys_size=2048 pages=256 sizeof(*phys)=8\n[pid:1954770] phys allocated: 0x7f875c000d50\n[pid:1954770] phys allocated: 0x7f8750000d50\n[pid:1954770] virt2phys succeeded for page 0 offset=0 phys[0]=0\n[pid:1954770] io allocated: 0x7f87\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\n#define metal_align_up(size, align) metal_align_down((size)+(align)-1,align)\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function assigns to the value parameter `size` on this line:\n\n    size = metal_align_up(size, ps->page_size);\n\nMISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; the exception in the rule only permits modifying the object referred to by a pointer parameter, not value parameters themselves. Thus overwriting the parameter `size` is a violation. The suggested fix (use a local variable, e.g. `size_t aligned_size = metal_align_up(size, ps->page_size);` and use that variable thereafter) is appropriate."
}