{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer variable 'virt' is declared as uint8_t * but is only used for read-only address computation and passed to metal_virt2phys; it could/should be declared as const uint8_t * (or the called function should take a pointer-to-const) so the pointer points to a const-qualified type. Thus the code fragment violates Rule 8.13 unless metal_virt2phys requires a non-const pointer (in which case the violation would be in that API).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter metal_shmem_try_map: ps->page_size=4096 fd=8 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=7 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=6 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=9 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=13 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=16 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=17 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=19 requested_size=1048576\nenter metal_shmem_try_map: ps->page_size=4096 fd=22 requested_size=1048576\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\nenter metal_shmem_try_map: ps->page_size=4096 fd=24 requested_size=1048576\naligned size=1048576 pages=256\naligned size=1048576 pages=256\nmetal_map succeeded: mem=0x7f0e0469d000\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\nmetal_map succeeded: mem=0x7f0e0459d000\nallocated phys array=0x7f0dfc001d60 phys_size=2048\nallocated io=0x7f0dfc002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0469d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0469d000 virt_plus_offset=0x7f0e0469d000\nmetal_map succeeded: mem=0x7f0e0449d000\nallocated phys array=0x7f0de4001d60 phys_size=2048\nallocated io=0x7f0de4002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0449d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0449d000 virt_plus_offset=0x7f0e0449d000\nmetal_map succeeded: mem=0x7f0e0439d000\nallocated phys array=0x7f0dd8001d60 phys_size=2048\nallocated io=0x7f0dd8002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0439d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0439d000 virt_plus_offset=0x7f0e0439d000\nmetal_map succeeded: mem=0x7f0e0429d000\nallocated phys array=0x7f0df4001d60 phys_size=2048\nallocated io=0x7f0df4002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0429d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0429d000 virt_plus_offset=0x7f0e0429d000\nallocated phys array=0x7f0df8001d60 phys_size=2048\nmetal_map succeeded: mem=0x7f0e0419d000\nallocated io=0x7f0df8002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0459d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0459d000 virt_plus_offset=0x7f0e0459d000\nallocated phys array=0x7f0dec001d60 phys_size=2048\nallocated io=0x7f0dec002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0419d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0419d000 virt_plus_offset=0x7f0e0419d000\nmetal_virt2phys returned error=0 phys[0]=0x0\npage=1 offset=4096 virt_base=0x7f0e0419d000 virt_plus_offset=0x7f0e0419e000\nmetal_map succeeded: mem=0x7f0e0409d000\nmetal_map succeeded: mem=0x7f0de36ff000\nallocated phys array=0x7f0de8001d60 phys_size=2048\nallocated io=0x7f0de8002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0e0409d000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0e0409d000 virt_plus_offset=0x7f0e0409d000\nmetal_map succeeded: mem=0x7f0de35ff000\nallocated phys array=0x7f0ddc001d60 phys_size=2048\nallocated io=0x7f0ddc002570\n_metal.pagemap_fd >= 0: computing phys per page\nmem=0x7f0de35ff000 pages=256 page_size=4096\npage=0 offset=0 virt_base=0x7f0de35ff000 virt_plus_offset=0x7f0de35ff000\nmetal_map succeeded: mem=0x7f0de34ff000\nmetal_virt2phys returned error=0 phys[0]=0x0\nmetal_virt2phys returned error=0 phys[1]=0x0\npage=1 offset=4096 virt_base=0x7f0de35ff000 virt_plus_offset=0x7f0de3600000\npage=2 offset=8192 virt_base=0x7f0e0419d000 virt_plus_offset=0x7f0e0419f000\nmetal_virt2phys returned error=0 phys[0]=0x0\nmetal_virt2phys returned error=0 phys[0]=0x0\npage=1 offset=4096 virt_base=0x7f0e0409d000 virt_plus_offset=0x7f0e0409e000\npage=1 offset=4096 virt_base=0x7f0e0469d000 virt_plus_offset=0x7f0e0469e000\nmetal_virt2phys returned error=0 phys[0]=0x0\nmetal_virt2phys returned error=0 phys[\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in principle. In metal_shmem_try_map the local variable virt is only used for address arithmetic and read-only queries (virt + offset passed to metal_virt2phys); the function never uses virt to modify the pointed-to bytes. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible, so virt should be declared as const uint8_t * (or const void *) to reflect read-only usage.\n\nOne caveat: if the called API metal_virt2phys is declared to take a non-const pointer (i.e. it requires uint8_t * or void *), then the API itself prevents the caller from using a const-qualified pointer and the MISRA violation would be on the API declaration rather than this caller. If metal_virt2phys already accepts a pointer-to-const (or could be changed to), then changing virt to const uint8_t * (and passing it to the const parameter) resolves the violation. Other local pointers (e.g. phys) are written to, so they must remain non-const.\n\nTherefore the agent A\u2019s claim that this code violates Rule 8.13 is correct unless the prototype of metal_virt2phys legitimately forces a non-const parameter (in which case the problem is with that API)."
}