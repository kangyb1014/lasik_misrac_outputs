{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'virt' is only used to compute addresses and passed to metal_virt2phys for address translation; it is never used to modify the pointed-to memory. Therefore it should be declared as pointing to a const-qualified type (e.g. 'const uint8_t *virt') but is declared as 'uint8_t *virt', violating MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_shmem_try_map: fd=8 requested_size=1048576 aligned_size=1048576 pages=256\nENTER metal_shmem_try_map: fd=6 requested_size=1048576 aligned_size=1048576 pages=256\nENTER metal_shmem_try_map: fd=7 requested_size=1048576 aligned_size=1048576 pages=256\nENTER metal_shmem_try_map: fd=10 requested_size=1048576 aligned_size=1048576 pages=256\nprobe: mem=0x7f311ff00000 size=1048576 pages=256 page_size=4096\nprobe: mem=0x7f311fe00000 size=1048576 pages=256 page_size=4096\nprobe: mem=0x7f311fd00000 size=1048576 pages=256 page_size=4096\nENTER metal_shmem_try_map: fd=13 requested_size=1048576 aligned_size=1048576 pages=256\nmlock OK\nprobe: mem=0x7f31173ff000 size=1048576 pages=256 page_size=4096\nmlock OK\nmlock OK\nprobe: mem=0x7f311f3ff000 size=1048576 pages=256 page_size=4096\npagemap_fd=4\npagemap_fd=4\nENTER metal_shmem_try_map: fd=14 requested_size=1048576 aligned_size=1048576 pages=256\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=0 addr=0x7f311fe00000 page=0\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=0 addr=0x7f311ff00000 page=0\npagemap_fd=4\ncalling metal_virt2phys: virt=0x7f311fd00000 offset=0 addr=0x7f311fd00000 page=0\nmetal_virt2phys returned: error=0 page=0 phys=0x0\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=4096 addr=0x7f311ff01000 page=1\nmetal_virt2phys returned: error=0 page=0 phys=0x0\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=4096 addr=0x7f311fe01000 page=1\nmlock OK\nprobe: mem=0x7f311eafe000 size=1048576 pages=256 page_size=4096\nmetal_virt2phys returned: error=0 page=1 phys=0x0\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=8192 addr=0x7f311ff02000 page=2\nmetal_virt2phys returned: error=0 page=1 phys=0x0\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=8192 addr=0x7f311fe02000 page=2\nmetal_virt2phys returned: error=0 page=0 phys=0x0\ncalling metal_virt2phys: virt=0x7f311fd00000 offset=4096 addr=0x7f311fd01000 page=1\nmlock OK\npagemap_fd=4\npagemap_fd=4\ncalling metal_virt2phys: virt=0x7f31173ff000 offset=0 addr=0x7f31173ff000 page=0\ncalling metal_virt2phys: virt=0x7f311f3ff000 offset=0 addr=0x7f311f3ff000 page=0\nmetal_virt2phys returned: error=0 page=2 phys=0x0\nENTER metal_shmem_try_map: fd=9 requested_size=1048576 aligned_size=1048576 pages=256\nmetal_virt2phys returned: error=0 page=2 phys=0x0\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=12288 addr=0x7f311ff03000 page=3\nmetal_virt2phys returned: error=0 page=1 phys=0x0\nmetal_virt2phys returned: error=0 page=0 phys=0x0\nmetal_virt2phys returned: error=0 page=0 phys=0x0\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=12288 addr=0x7f311fe03000 page=3\ncalling metal_virt2phys: virt=0x7f311fd00000 offset=8192 addr=0x7f311fd02000 page=2\ncalling metal_virt2phys: virt=0x7f311f3ff000 offset=4096 addr=0x7f311f400000 page=1\nmetal_virt2phys returned: error=0 page=3 phys=0x0\nprobe: mem=0x7f311e1fd000 size=1048576 pages=256 page_size=4096\ncalling metal_virt2phys: virt=0x7f31173ff000 offset=4096 addr=0x7f3117400000 page=1\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=16384 addr=0x7f311ff04000 page=4\nmetal_virt2phys returned: error=0 page=3 phys=0x0\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=16384 addr=0x7f311fe04000 page=4\nmlock OK\npagemap_fd=4\ncalling metal_virt2phys: virt=0x7f311e1fd000 offset=0 addr=0x7f311e1fd000 page=0\nmetal_virt2phys returned: error=0 page=4 phys=0x0\nmetal_virt2phys returned: error=0 page=1 phys=0x0\nmetal_virt2phys returned: error=0 page=2 phys=0x0\nmetal_virt2phys returned: error=0 page=1 phys=0x0\nmetal_virt2phys returned: error=0 page=4 phys=0x0\ncalling metal_virt2phys: virt=0x7f311f3ff000 offset=8192 addr=0x7f311f401000 page=2\ncalling metal_virt2phys: virt=0x7f311ff00000 offset=20480 addr=0x7f311ff05000 page=5\ncalling metal_virt2phys: virt=0x7f311fd00000 offset=12288 addr=0x7f311fd03000 page=3\ncalling metal_virt2phys: virt=0x7f31173ff000 offset=8192 addr=0x7f3117401000 page=2\ncalling metal_virt2phys: virt=0x7f311fe00000 offset=20480 addr=0x7f311fe05000 page=5\nmlock OK\npagemap_fd=4\nENTER metal_shmem_try_map: fd=15 requested_size=1048576 aligned_size=1048576 pages=256\ncalling metal_virt2phys: virt=0\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The local variable 'virt' is only assigned from mem and used to compute addresses (virt + offset) that are passed to metal_virt2phys; there is no write-through virt anywhere in the function. Per MISRA C 2023 Rule 8.13 a pointer that is not used to modify the pointed-to object should be const-qualified. Therefore, declaring virt as const uint8_t *virt would better satisfy the rule.\n\nCaveat: if the prototype of metal_virt2phys accepts a non-const pointer (e.g. void *), making virt const would force either a cast at the call site or a change to metal_virt2phys' signature. If that change is not feasible, then changing virt is not \"possible\" without introducing other violations. However, given only the code shown, there is no evidence virt is used to modify memory, so the agent A report (that this is a Rule 8.13 violation) is correct."
}