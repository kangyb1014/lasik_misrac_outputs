{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'virt' is declared as uint8_t *virt and assigned from mem, but in the loop it is only used to compute addresses and passed to metal_virt2phys (no writes through virt). Since the pointer is not used to modify pointed-to bytes, it should be declared const (e.g. const uint8_t *virt) to reflect non-modifying access. Therefore Rule 8.13 is violated unless there is a specific reason why virt must be a mutable pointer (or metal_virt2phys requires a non-const parameter).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_shmem_try_map fd=7 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nENTER: metal_shmem_try_map fd=8 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nENTER: metal_shmem_try_map fd=6 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nENTER: metal_shmem_try_map fd=9 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nmmap OK: mem=0x7f08beefe000 size=1048576 mmap_flags=0x0\nENTER: metal_shmem_try_map fd=14 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nmmap OK: mem=0x7f08bedfe000 size=1048576 mmap_flags=0x0\nENTER: metal_shmem_try_map fd=12 requested_size=1048576 aligned_size=1048576 page_size=4096 pages=256\nmmap OK: mem=0x7f08becfe000 size=1048576 mmap_flags=0x0\nmlock OK: mem=0x7f08beefe000 size=1048576\nmmap OK: mem=0x7f08bebfe000 size=1048576 mmap_flags=0x0\nmlock OK: mem=0x7f08bedfe000 size=1048576\nmmap OK: mem=0x7f08beafe000 size=1048576 mmap_flags=0x0\nmalloc phys OK: phys=0x7f08b0000d50 phys_size=2048 pages=256\nmalloc io OK: io=0x7f08b0001560\npagemap_fd OK: pagemap_fd=4 starting loop pages=256 page_size=4096 mem=0x7f08beefe000\nLOOP start: page=0 offset=0 virt=0x7f08beefe000 addr_passed=0x7f08beefe000\nmlock OK: mem=0x7f08beafe000 size=1048576\nmlock OK: mem=0x7f08becfe000 size=1048576\nmmap OK: mem=0x7f08be1fd000 size=1048576 mmap_flags=0x0\nmalloc phys OK: phys=0x7f08b4000d50 phys_size=2048 pages=256\nmalloc phys OK: phys=0x7f08a4000d50 phys_size=2048 pages=256\nmalloc io OK: io=0x7f08b4001560\nmalloc io OK: io=0x7f08a4001560\nmetal_virt2phys OK: page=0 addr=0x7f08beefe000 error=0 phys=0\npagemap_fd OK: pagemap_fd=4 starting loop pages=256 page_size=4096 mem=0x7f08bedfe000\npagemap_fd OK: pagemap_fd=4 starting loop pages=256 page_size=4096 mem=0x7f08beafe000\nLOOP start: page=1 offset=4096 virt=0x7f08beefe000 addr_passed=0x7f08beeff000\nLOOP start: page=0 offset=0 virt=0x7f08bedfe000 addr_passed=0x7f08bedfe000\nLOOP start: page=0 offset=0 virt=0x7f08beafe000 addr_passed=0x7f08beafe000\nmlock OK: mem=0x7f08be1fd000 size=1048576\nmalloc phys OK: phys=0x7f08b8000d50 phys_size=2048 pages=256\nmetal_virt2phys OK: page=0 addr=0x7f08bedfe000 error=0 phys=0\nmalloc io OK: io=0x7f08b8001560\nmetal_virt2phys OK: page=1 addr=0x7f08beeff000 error=0 phys=0\nLOOP start: page=1 offset=4096 virt=0x7f08bedfe000 addr_passed=0x7f08bedff000\nmetal_virt2phys OK: page=0 addr=0x7f08beafe000 error=0 phys=0\npagemap_fd OK: pagemap_fd=4 starting loop pages=256 page_size=4096 mem=0x7f08becfe000\nLOOP start: page=2 offset=8192 virt=0x7f08beefe000 addr_passed=0x7f08bef00000\nLOOP start: page=1 offset=4096 virt=0x7f08beafe000 addr_passed=0x7f08beaff000\nLOOP start: page=0 offset=0 virt=0x7f08becfe000 addr_passed=0x7f08becfe000\nmlock OK: mem=0x7f08bebfe000 size=1048576\nmalloc phys OK: phys=0x7f08a8000d50 phys_size=2048 pages=256\nmetal_virt2phys OK: page=1 addr=0x7f08bedff000 error=0 phys=0\nmalloc io OK: io=0x7f08a8001560\nLOOP start: page=2 offset=8192 virt=0x7f08bedfe000 addr_passed=0x7f08bee00000\npagemap_fd OK: pagemap_fd=4 starting loop pages=256 page_size=4096 mem=0x7f08be1fd000\nmetal_virt2phys OK: page=1 addr=0x7f08beaff000 error=0 phys=0\nmetal_virt2phys OK: page=2 addr=0x7f08bef00000 error=0 phys=0\nLOOP start: page=0 offset=0 virt=0x7f08be1fd000 addr_passed=0x7f08be1fd000\nLOOP start: page=2 offset=8192 virt=0x7f08beafe000 addr_passed=0x7f08beb00000\nLOOP start: page=3 offset=12288 virt=0x7f08beefe000 addr_passed=0x7f08bef01000\nmetal_virt2phys OK: page=0 addr=0x7f08becfe000 error=0 phys=0\nmetal_virt2phys OK: page=2 addr=0x7f08bee00000 error=0 phys=0\nmalloc phys OK: phys=0x7f08ac000d50 phys_size=2048 pages=256\nLOOP start: page=3 offset=12288 virt=0x7f08bedfe000 addr_passed=0x7f08bee01000\nmetal_virt2phys OK: page=0 addr=0x7f08be1fd000 error=0 phys=0\nLOOP start: page=1 offset=4096 virt=0x7f08becfe000 addr_passed=0x7f08becff000\nLOOP start: page=1 offset=4096 virt=0x7f08be1fd000 addr_passed=0x7f08be1fe000\nmalloc io OK: io=0x7f08ac001560\nmetal_virt2phys OK: page=1 addr=0x7f08be1fe000 error=0 phys=0\nmetal_virt2phys OK: page=3 addr=0x7f08bee01000 error=0 phys=0\npagemap_fd \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The concern is reasonable: within metal_shmem_try_map the local pointer virt is only used for address arithmetic and passed to metal_virt2phys; there are no writes through virt, so\u2014if nothing it is passed to requires a mutable pointer\u2014virt could be declared const uint8_t *virt to satisfy MISRA C 2023 Rule 8.13. However, the code excerpt does not include the prototype for metal_virt2phys. If metal_virt2phys is declared to take a non-const pointer (e.g. void *), then virt cannot be made const without a cast and the current declaration is necessary. Because the provided code lacks the metal_virt2phys signature, a definite MISRA 8.13 violation cannot be established from the snippet alone. Recommend checking the metal_virt2phys prototype and making virt (and related parameters) const-qualified if the API permits."
}