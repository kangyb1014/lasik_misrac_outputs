{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strcmp(dev->name, dev_name) can read beyond the bounds of the objects pointed to because neither operand is checked for being a valid NUL-terminated string. Example violation: if struct metal_device defines char name[16] and the name buffer is filled with 16 non-NUL characters (no terminating '\\0'), strcmp will continue reading past the 16-byte array searching for a NUL and thus access out-of-bounds. Similarly, if the caller passes dev_name that is not NUL-terminated or points to a shorter buffer, strcmp(dev->name, dev_name) may read beyond dev_name's bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_generic_dev_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/79.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_generic_dev_open as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_generic_dev_open:\n```c\nint metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,\n\t\t\t   struct metal_device **device)\n{\n\tstruct metal_list *node;\n\tstruct metal_device *dev;\n\n\t(void)bus;\n\n\tmetal_list_for_each(&_metal.common.generic_device_list, node) {\n\t\tdev = metal_container_of(node, struct metal_device, node);\n\t\tif (strcmp(dev->name, dev_name) == 0) {\n\t\t\t*device = dev;\n\t\t\treturn metal_generic_dev_sys_open(dev);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n```\n</target_code>\nPlease provide the modified metal_generic_dev_open code.\n",
  "test_code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\n/* Probe helper: append logs about pointers and the first byte of each string.\n * Writes to /tmp/logs/79.txt. Keeps probes minimal to avoid additional out-of-bounds\n * accesses: only the pointer values and the first byte (if pointer is non-NULL)\n * are read. This preserves the original control flow while providing evidence\n * about the strings and the comparison result.\n */\nstatic void probe_log(const struct metal_list *node, struct metal_device *dev, const char *dev_name, int cmp_available, int cmp_result)\n{\n    FILE *f = fopen(\"/tmp/logs/79.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"probe: node=%p dev=%p dev->name_ptr=%p dev_name_ptr=%p\\n\",\n            (const void *)node, (const void *)dev, (dev ? (const void *)dev->name : NULL), (const void *)dev_name);\n\n    if (dev && dev->name) {\n        /* Read only the first byte to avoid scanning past allocation bounds. */\n        unsigned char c = (unsigned char)dev->name[0];\n        fprintf(f, \"probe: dev->name[0]=0x%02x %c\\n\", c, (c >= 32 && c < 127) ? (char)c : '.');\n    } else {\n        fprintf(f, \"probe: dev->name is NULL\\n\");\n    }\n\n    if (dev_name) {\n        unsigned char c = (unsigned char)dev_name[0];\n        fprintf(f, \"probe: dev_name[0]=0x%02x %c\\n\", c, (c >= 32 && c < 127) ? (char)c : '.');\n    } else {\n        fprintf(f, \"probe: dev_name is NULL\\n\");\n    }\n\n    if (cmp_available) {\n        fprintf(f, \"probe: strcmp returned %d\\n\", cmp_result);\n    }\n\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\nint metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,\n               struct metal_device **device)\n{\n    struct metal_list *node;\n    struct metal_device *dev;\n\n    (void)bus;\n\n    metal_list_for_each(&_metal.common.generic_device_list, node) {\n        dev = metal_container_of(node, struct metal_device, node);\n\n        /* Log pointers and first-byte heuristics before comparison. */\n        probe_log(node, dev, dev_name, 0, 0);\n\n        /* Keep original logic but capture the strcmp result for logging. */\n        int cmp = strcmp(dev->name, dev_name);\n        probe_log(node, dev, dev_name, 1, cmp);\n\n        if (cmp == 0) {\n            *device = dev;\n            return metal_generic_dev_sys_open(dev);\n        }\n    }\n\n    return -ENODEV;\n}\n"
}