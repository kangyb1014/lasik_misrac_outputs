{
  "user_message": "An agent A claimed that the following metal_linux_irq_handling code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_irq_handling.\n```c\nstatic void *metal_linux_irq_handling(void *args)\n{\n\tstruct sched_param param;\n\tuint64_t val;\n\tint ret;\n\tint i, j, pfds_total;\n\tstruct pollfd *pfds;\n\n\t(void)args;\n\n\tpfds = (struct pollfd *)malloc(FD_SETSIZE * sizeof(struct pollfd));\n\tif (!pfds) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to allocate irq fds mem.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tparam.sched_priority = sched_get_priority_max(SCHED_FIFO);\n\t/* Ignore the set scheduler error */\n\tret = sched_setscheduler(0, SCHED_FIFO, &param);\n\tif (ret) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s: Failed to set scheduler: %s.\\n\", __func__,\n\t\t\t  strerror(ret));\n\t}\n\n\twhile (1) {\n\t\tmetal_mutex_acquire(&irq_lock);\n\t\tif (irq_handling_stop) {\n\t\t\t/* Killing this IRQ handling thread */\n\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get the fdset */\n\t\tmemset(pfds, 0, MAX_IRQS * sizeof(struct pollfd));\n\t\tpfds[0].fd = irq_notify_fd;\n\t\tpfds[0].events = POLLIN;\n\t\tj = 1;\n\t\tmetal_bitmap_for_each_set_bit(irqs_enabled, i,\n\t\t\t\t\t      linux_irq_cntr.irq_num) {\n\t\t\tpfds[j].fd = i;\n\t\t\tpfds[j].events = POLLIN;\n\t\t\tj++;\n\t\t}\n\t\tmetal_mutex_release(&irq_lock);\n\t\t/* Wait for interrupt */\n\t\tret = poll(pfds, j, -1);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"%s: poll() failed: %s.\\n\",\n\t\t\t\t  __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\t/* Waken up from interrupt */\n\t\tpfds_total = j;\n\t\tfor (i = 0; i < pfds_total; i++) {\n\t\t\tif ((pfds[i].fd == irq_notify_fd) &&\n\t\t\t    (pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\t/* IRQ registration change notification */\n\t\t\t\tif (read(pfds[i].fd,\n\t\t\t\t\t (void *)&val, sizeof(uint64_t)) < 0)\n\t\t\t\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t\t\t\t  \"%s, read irq fd %d failed\\n\",\n\t\t\t\t\t\t  __func__, pfds[i].fd);\n\t\t\t} else if ((pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\tstruct metal_device *dev = NULL;\n\t\t\t\tint irq_handled = 0;\n\t\t\t\tint fd;\n\n\t\t\t\tfd = pfds[i].fd;\n\t\t\t\tdev = irqs_devs[fd];\n\t\t\t\tmetal_mutex_acquire(&irq_lock);\n\t\t\t\tif (metal_irq_handle(&irqs[fd], fd)\n\t\t\t\t    == METAL_IRQ_HANDLED)\n\t\t\t\t\tirq_handled = 1;\n\t\t\t\tif (irq_handled) {\n\t\t\t\t\tif (dev && dev->bus->ops.dev_irq_ack)\n\t\t\t\t\t\tdev->bus->ops.dev_irq_ack(\n\t\t\t\t\t\t\tdev->bus, dev, fd);\n\t\t\t\t}\n\t\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\t} else if (pfds[i].revents) {\n\t\t\t\tmetal_log(METAL_LOG_DEBUG,\n\t\t\t\t\t  \"%s: poll unexpected. fd %d: %d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  pfds[i].fd, pfds[i].revents);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfds);\n\treturn NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro definition uses compiler-specific extensions: the GCC statement-expression construct '({ ... })' and the GNU token-pasting trick '##__VA_ARGS__' to allow an optional comma for empty variadic arguments. Both are documented GCC extensions (non\u2011standard C) so Rule 1.2 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[2025-08-22 06:06:04] Entered metal_linux_irq_handling\n[2025-08-22 06:06:04] Allocated pfds at 0x7fe5d8001f80\n[2025-08-22 06:06:04] sched_setscheduler returned -1: Unknown error -1\n[2025-08-22 06:06:04] Loop top: acquiring irq_lock\n[2025-08-22 06:06:04] Acquired irq_lock\n[2025-08-22 06:06:04] Building pfds: start with irq_notify_fd=5\n[2025-08-22 06:06:04] Finished building pfds; total fds=1\n[2025-08-22 06:06:04] Released irq_lock before poll\n[2025-08-22 06:06:05] poll returned 1 (errno=1:Operation not permitted)\n[2025-08-22 06:06:05] Inspecting pfds[0]: fd=5 events=0x1 revents=0x1\n[2025-08-22 06:06:05] irq_notify_fd signaled on fd=5\n[2025-08-22 06:06:05] read value from irq_notify_fd 5: 0x1\n[2025-08-22 06:06:05] Loop top: acquiring irq_lock\n[2025-08-22 06:06:05] Acquired irq_lock\n[2025-08-22 06:06:05] irq_handling_stop is set; preparing to exit thread\n[2025-08-22 06:06:05] Released irq_lock and breaking loop\n[2025-08-22 06:06:05] Exiting irq handling thread; freeing pfds 0x7fe5d8001f80\n[2025-08-22 06:06:05] Freed pfds and returning NULL\n[2025-08-22 06:06:05] Entered metal_linux_irq_handling\n[2025-08-22 06:06:05] Allocated pfds at 0x7f986c001f80\n[2025-08-22 06:06:05] sched_setscheduler returned -1: Unknown error -1\n[2025-08-22 06:06:05] Loop top: acquiring irq_lock\n[2025-08-22 06:06:05] Acquired irq_lock\n[2025-08-22 06:06:05] Building pfds: start with irq_notify_fd=5\n[2025-08-22 06:06:05] Finished building pfds; total fds=1\n[2025-08-22 06:06:05] Released irq_lock before poll\n[2025-08-22 06:06:05] poll returned 1 (errno=1:Operation not permitted)\n[2025-08-22 06:06:05] Inspecting pfds[0]: fd=5 events=0x1 revents=0x1\n[2025-08-22 06:06:05] irq_notify_fd signaled on fd=5\n[2025-08-22 06:06:05] read value from irq_notify_fd 5: 0x1\n[2025-08-22 06:06:05] Loop top: acquiring irq_lock\n[2025-08-22 06:06:05] Acquired irq_lock\n[2025-08-22 06:06:05] irq_handling_stop is set; preparing to exit thread\n[2025-08-22 06:06:05] Released irq_lock and breaking loop\n[2025-08-22 06:06:05] Exiting irq handling thread; freeing pfds 0x7f986c001f80\n[2025-08-22 06:06:05] Freed pfds and returning NULL\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_irq_handling:\n#define metal_bitmap_for_each_set_bit(bitmap, bit, max) for((bit)=metal_bitmap_next_set_bit((bitmap),0,(max));(bit)<(max);(bit)=metal_bitmap_next_set_bit((bitmap),(bit+1),(max)))\n...\nstatic unsigned long\nirqs_enabled[metal_div_round_up(MAX_IRQS, METAL_BITS_PER_ULONG)]\n...\nstatic METAL_IRQ_CONTROLLER_DECLARE(linux_irq_cntr,\n\t\t\t\t    0, MAX_IRQS,\n\t\t\t\t    NULL,\n\t\t\t\t    metal_linux_irq_set_enable, NULL,\n\t\t\t\t    irqs)\n...\nstatic int irq_notify_fd\n...\nstatic struct metal_device *irqs_devs[MAX_IRQS]\n...\nstruct metal_device {\n\tconst char             *name;       /**< Device name */\n\tstruct metal_bus       *bus;        /**< Bus that contains device */\n\tunsigned int           num_regions; /**< Number of I/O regions in\n\t\t\t\t\t\t device */\n\tstruct metal_io_region regions[METAL_MAX_DEVICE_REGIONS]; /**< Array of\n\t\t\t\t\t\t\tI/O regions in device*/\n\tstruct metal_list      node;       /**< Node on bus' list of devices */\n\tint                    irq_num;    /**< Number of IRQs per device */\n\tvoid                   *irq_info;  /**< IRQ ID */\n}\n...\nstruct metal_bus_ops {\n\tvoid\t\t(*bus_close)(struct metal_bus *bus);\n\tint\t\t(*dev_open)(struct metal_bus *bus,\n\t\t\t\t    const char *dev_name,\n\t\t\t\t    struct metal_device **device);\n\tvoid\t\t(*dev_close)(struct metal_bus *bus,\n\t\t\t\t     struct metal_device *device);\n\tvoid\t\t(*dev_irq_ack)(struct metal_bus *bus,\n\t\t\t\t       struct metal_device *device,\n\t\t\t\t       int irq);\n\tint\t\t(*dev_dma_map)(struct metal_bus *bus,\n\t\t\t\t       struct metal_device *device,\n\t\t\t\t       uint32_t dir,\n\t\t\t\t       struct metal_sg *sg_in,\n\t\t\t\t       int nents_in,\n\t\t\t\t       struct metal_sg *sg_out);\n\tvoid\t\t(*dev_dma_unmap)(struct metal_bus *bus,\n\t\t\t\t\t struct metal_device *device,\n\t\t\t\t\t uint32_t dir,\n\t\t\t\t\t struct metal_sg *sg,\n\t\t\t\t\t int nents);\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic metal_mutex_t irq_lock\n...\nstatic bool irq_handling_stop\n...\nstatic struct metal_irq irqs[MAX_IRQS]\n...\n#define METAL_IRQ_HANDLED 1\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The provided additional code shows the macro definition:\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__;\\)\nThis macro uses two GNU/C compiler extensions: the statement-expression construct ({ ... }) and the token-pasting '##__VA_ARGS__' idiom to swallow an optional comma. Both are documented GCC extensions (non\u2011standard C). Because metal_linux_irq_handling invokes metal_log, the translation unit relies on those compiler extensions, which violates MISRA C 2023 Rule 1.2 (language extensions should not be used)."
}