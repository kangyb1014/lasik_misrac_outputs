{
  "user_message": "Target function code is:\n```c\nstatic void *metal_linux_irq_handling(void *args)\n{\n\tstruct sched_param param;\n\tuint64_t val;\n\tint ret;\n\tint i, j, pfds_total;\n\tstruct pollfd *pfds;\n\n\t(void)args;\n\n\tpfds = (struct pollfd *)malloc(FD_SETSIZE * sizeof(struct pollfd));\n\tif (!pfds) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to allocate irq fds mem.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tparam.sched_priority = sched_get_priority_max(SCHED_FIFO);\n\t/* Ignore the set scheduler error */\n\tret = sched_setscheduler(0, SCHED_FIFO, &param);\n\tif (ret) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s: Failed to set scheduler: %s.\\n\", __func__,\n\t\t\t  strerror(ret));\n\t}\n\n\twhile (1) {\n\t\tmetal_mutex_acquire(&irq_lock);\n\t\tif (irq_handling_stop) {\n\t\t\t/* Killing this IRQ handling thread */\n\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get the fdset */\n\t\tmemset(pfds, 0, MAX_IRQS * sizeof(struct pollfd));\n\t\tpfds[0].fd = irq_notify_fd;\n\t\tpfds[0].events = POLLIN;\n\t\tj = 1;\n\t\tmetal_bitmap_for_each_set_bit(irqs_enabled, i,\n\t\t\t\t\t      linux_irq_cntr.irq_num) {\n\t\t\tpfds[j].fd = i;\n\t\t\tpfds[j].events = POLLIN;\n\t\t\tj++;\n\t\t}\n\t\tmetal_mutex_release(&irq_lock);\n\t\t/* Wait for interrupt */\n\t\tret = poll(pfds, j, -1);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"%s: poll() failed: %s.\\n\",\n\t\t\t\t  __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\t/* Waken up from interrupt */\n\t\tpfds_total = j;\n\t\tfor (i = 0; i < pfds_total; i++) {\n\t\t\tif ((pfds[i].fd == irq_notify_fd) &&\n\t\t\t    (pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\t/* IRQ registration change notification */\n\t\t\t\tif (read(pfds[i].fd,\n\t\t\t\t\t (void *)&val, sizeof(uint64_t)) < 0)\n\t\t\t\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t\t\t\t  \"%s, read irq fd %d failed\\n\",\n\t\t\t\t\t\t  __func__, pfds[i].fd);\n\t\t\t} else if ((pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\tstruct metal_device *dev = NULL;\n\t\t\t\tint irq_handled = 0;\n\t\t\t\tint fd;\n\n\t\t\t\tfd = pfds[i].fd;\n\t\t\t\tdev = irqs_devs[fd];\n\t\t\t\tmetal_mutex_acquire(&irq_lock);\n\t\t\t\tif (metal_irq_handle(&irqs[fd], fd)\n\t\t\t\t    == METAL_IRQ_HANDLED)\n\t\t\t\t\tirq_handled = 1;\n\t\t\t\tif (irq_handled) {\n\t\t\t\t\tif (dev && dev->bus->ops.dev_irq_ack)\n\t\t\t\t\t\tdev->bus->ops.dev_irq_ack(\n\t\t\t\t\t\t\tdev->bus, dev, fd);\n\t\t\t\t}\n\t\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\t} else if (pfds[i].revents) {\n\t\t\t\tmetal_log(METAL_LOG_DEBUG,\n\t\t\t\t\t  \"%s: poll unexpected. fd %d: %d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  pfds[i].fd, pfds[i].revents);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfds);\n\treturn NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_linux_irq_handling': {'callees': ['metal_mutex_acquire', 'metal_mutex_release', 'metal_bitmap_next_set_bit', 'metal_irq_handle'], 'callers': []}, 'metal_mutex_acquire': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_save_disable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_mutex_release': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_restore_enable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_bitmap_next_set_bit': {'callees': [], 'callers': ['metal_linux_irq_handling']}, 'metal_irq_handle': {'callees': [], 'callers': ['metal_softirq_dispatch', 'metal_linux_irq_handling']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_bitmap_for_each_set_bit",
    "metal_bitmap_next_set_bit",
    "irqs_enabled",
    "linux_irq_cntr",
    "irq_notify_fd",
    "irqs_devs",
    "struct metal_device",
    "struct metal_bus_ops",
    "dev_irq_ack (member of metal_bus_ops)",
    "metal_log",
    "metal_mutex_acquire",
    "metal_mutex_release",
    "irq_lock",
    "irq_handling_stop",
    "irqs",
    "metal_irq_handle",
    "METAL_IRQ_HANDLED"
  ],
  "explanation": "To determine whether the target function uses compiler language extensions (and thus violates the MISRA rule), the next analyzer needs the definitions of project-specific macros, types, globals and functions that the function relies on. These are the minimal symbols whose definitions may hide compiler extensions (e.g. GCC statement-expressions, typeof, __attribute__, inline asm, non-standard storage-class/inline semantics, or other vendor-specific extensions):\n\n- metal_bitmap_for_each_set_bit: This is a macro used as a loop construct in the function. Macros of this form often expand to complex code (for/while plus helper calls) and may use GCC extensions such as statement-expressions (\"({ ... })\"), typeof, or nested declarations. The macro body must be inspected to detect such extensions.\n\n- metal_bitmap_next_set_bit: Often used by the bitmap-iteration macro; its implementation may use compiler extensions (builtin bit-scan intrinsics, asm, __attribute__ annotations). The call graph lists this symbol; its definition is needed to check for extensions.\n\n- irqs_enabled: The type/definition of the bitmap being iterated. If it is a typedef or structure that uses compiler-specific extensions (bit-field layouts with attributes, packed attributes, flexible-array with non-standard alignment, etc.), that would be relevant.\n\n- linux_irq_cntr: Its type (structure/union) and member irq_num are read by the macro. The struct definition could contain compiler-specific attributes or nonstandard extensions.\n\n- irq_notify_fd: The declaration/type of this global (fd) - ensures the iteration and comparison are standard. If it is defined via odd macros or attributes, that matters.\n\n- irqs_devs: The array used to map fds to struct metal_device pointers. The array declaration or its initializer could use nonstandard compound literals, section attributes, or other extensions.\n\n- struct metal_device: The device structure definition must be checked. The code dereferences dev->bus->ops.dev_irq_ack; struct/field definitions may include nonstandard attributes, packed/section/alias attributes or use GCC extensions.\n\n- struct metal_bus_ops and dev_irq_ack (member): The ops structure and its dev_irq_ack function-pointer type must be inspected for attributes (e.g. __attribute__((nonnull)) or calling-convention attributes), or extension in the function-pointer declaration syntax.\n\n- metal_log: Project logging helper \u2014 could be a macro or function that uses variadic GNU macros, statement-expressions, format attribute annotations, or other extensions. Its definition must be inspected.\n\n- metal_mutex_acquire and metal_mutex_release: Although present in the call graph, their definitions (macro or inline function) may use compiler extensions (inline semantics, attributes, asm), so they must be checked to ensure the target function's calls are not relying on language extensions.\n\n- irq_lock and irq_handling_stop: Global variables whose declarations may use volatile, atomic types or extension attributes; the latter could introduce nonstandard constructs affecting MISRA check.\n\n- irqs: The array passed to metal_irq_handle; its type/definition (possibly a struct array) should be examined for extensions.\n\n- metal_irq_handle and METAL_IRQ_HANDLED: The function prototype and the constant/enum used must be inspected for attributes or nonstandard enum/constant definitions (e.g. compiler-specific enum size directives or attributes).\n\nNote: Standard library and POSIX symbols used in the function (malloc, free, memset, poll, struct pollfd, POLLIN, POLLRDNORM, read, strerror, errno, sched_get_priority_max, sched_setscheduler, SCHED_FIFO, uint64_t, FD_SETSIZE, MAX_IRQS) are not included here because they come from standard C/POSIX headers; unless the project provides replacement headers that use extensions, their standard definitions are not typical sources of compiler language extensions. The listed project-specific macros/types/functions are the likely places where compiler extensions could be introduced and therefore must be examined to decide MISRA compliance."
}