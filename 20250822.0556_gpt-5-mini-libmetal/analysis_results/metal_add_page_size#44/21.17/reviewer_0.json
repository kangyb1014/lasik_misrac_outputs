{
  "user_message": "An agent A claimed that the following metal_add_page_size code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_add_page_size.\n```c\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strncpy(_metal.page_sizes[index].path, path, PATH_MAX) can access memory beyond the bounds of the objects passed: e.g. if _metal.page_sizes[index].path has a smaller storage (for example char path[128]) while PATH_MAX == 256, strncpy will write up to 256 bytes and overflow the destination. Also, if the source 'path' is not NUL-terminated within PATH_MAX bytes, strncpy may read beyond the source object\u2019s bounds while copying, which is another out-of-bounds access. Unless the code can statically guarantee that the destination buffer size >= PATH_MAX and that 'path' contains a NUL within PATH_MAX bytes, this violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER metal_add_page_size: path=0x7f07ce9e2bb2 shift=12 mmap_flags=0 index=0 size=4096 PATH_MAX=4096\nBEFORE COPY: index=0 dest_buf_size=4096 PATH_MAX=4096 path_ptr=0x7f07ce9e2bb2\nCALL strncpy: dest=&_metal.page_sizes[0].path src=0x7f07ce9e2bb2 n=4096\nAFTER COPY: index=0 found_nul_in_dest=1 dest_buf_size=4096 new_num_page_sizes=1\nRETURN 0: added page size 4096 at index=0\nENTER metal_add_page_size: path=(nil) shift=21 mmap_flags=1409548288 index=1 size=2097152 PATH_MAX=4096\nBRANCH: invalid args (path=(nil) shift=21) - returning -EINVAL\nENTER metal_add_page_size: path=(nil) shift=30 mmap_flags=2013528064 index=1 size=1073741824 PATH_MAX=4096\nBRANCH: invalid args (path=(nil) shift=30) - returning -EINVAL\nENTER metal_add_page_size: path=0x5618fc414b7a shift=12 mmap_flags=0 index=0 size=4096 PATH_MAX=4096\nBEFORE COPY: index=0 dest_buf_size=4096 PATH_MAX=4096 path_ptr=0x5618fc414b7a\nCALL strncpy: dest=&_metal.page_sizes[0].path src=0x5618fc414b7a n=4096\nAFTER COPY: index=0 found_nul_in_dest=1 dest_buf_size=4096 new_num_page_sizes=1\nRETURN 0: added page size 4096 at index=0\nENTER metal_add_page_size: path=(nil) shift=21 mmap_flags=1409548288 index=1 size=2097152 PATH_MAX=4096\nBRANCH: invalid args (path=(nil) shift=21) - returning -EINVAL\nENTER metal_add_page_size: path=(nil) shift=30 mmap_flags=2013528064 index=1 size=1073741824 PATH_MAX=4096\nBRANCH: invalid args (path=(nil) shift=30) - returning -EINVAL\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 21.17 prohibits uses of string.h functions that can access beyond the bounds of the objects pointed to by their parameters. In this code strncpy(_metal.page_sizes[index].path, path, PATH_MAX) can violate that rule for two reasons: (1) strncpy writes up to n bytes (padding with NULs) \u2014 if _metal.page_sizes[index].path has a storage size smaller than PATH_MAX this call can overflow the destination; (2) strncpy may read up to n bytes from the source even if no NUL is encountered \u2014 if the object pointed to by path is smaller than PATH_MAX (or not NUL-terminated within PATH_MAX bytes) the call can read beyond the source object. The provided execution log shows particular runs where dest size == PATH_MAX and a NUL was found at runtime, but MISRA requires that out-of-bounds accesses be prevented/guaranteed not to occur, not merely observed to be safe at runtime. Unless the program can statically guarantee that the destination array size >= PATH_MAX and that the source contains a NUL within PATH_MAX bytes, this use of strncpy is non\u2011conforming to Rule 21.17."
}