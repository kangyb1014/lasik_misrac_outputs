{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_add_page_size:\n```c\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_add_page_size:\nstruct metal_state _metal\n...\n#define MAX_PAGE_SIZES 32\n...\nstatic int metal_init_page_sizes(void)\n{\n\tconst int max_sizes = MAX_PAGE_SIZES - 1;\n\tlong sizes[max_sizes];\n\n\t/* Determine system page size. */\n\tsizes[0] = getpagesize();\n\tif (sizes[0] <= 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to get page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_metal.page_size  = sizes[0];\n\t_metal.page_shift = metal_log2(sizes[0]);\n\tmetal_add_page_size(_metal.tmp_path, _metal.page_shift, 0);\n\n#ifdef HAVE_HUGETLBFS_H\n#ifndef MAP_HUGE_SHIFT\n\t/* System does not support multiple huge page sizes. */\n\tsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n#else\n\tif (gethugepagesize() >= 0) {\n\t\tint i, count;\n\n\t\t/* System supports multiple huge page sizes. */\n\t\tcount = gethugepagesizes(sizes, max_sizes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint shift = metal_log2(sizes[i]);\n\n\t\t\tif ((shift & MAP_HUGE_MASK) != shift)\n\t\t\t\tcontinue;\n\t\t\tmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\t\t}\n\t}\n#endif\n#endif\n\n\t/* Finally sort the resulting array by size. */\n\tqsort(_metal.page_sizes, _metal.num_page_sizes,\n\t      sizeof(struct metal_page_size), metal_pagesize_compare);\n\n\treturn 0;\n}\n...\nint metal_sys_init(const struct metal_init_params *params)\n{\n\tconst char *tmp_path;\n\tunsigned int seed;\n\tFILE *urandom;\n\tint result;\n\n\t/* Find the temporary directory location. */\n\ttmp_path = getenv(\"TMPDIR\");\n\tif (!tmp_path)\n\t\ttmp_path = \"/tmp\";\n\t_metal.tmp_path = tmp_path;\n\n\t/* Initialize the pseudo-random number generator. */\n\turandom = fopen(\"/dev/urandom\", \"r\");\n\tif (!urandom) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open /dev/urandom (%s)\\n\",\n\t\t\t  strerror(errno));\n\t\treturn -errno;\n\t}\n\tif (fread(&seed, 1, sizeof(seed), urandom) <= 0) {\n\t\tmetal_log(METAL_LOG_DEBUG, \"Failed fread /dev/urandom\\n\");\n\t}\n\tfclose(urandom);\n\tsrand(seed);\n\n\tresult = metal_init_page_sizes();\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = metal_linux_bus_init();\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = open(\"/proc/self/pagemap\", O_RDONLY | O_CLOEXEC);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_DEBUG, \"Failed pagemap open - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\t_metal.pagemap_fd = result;\n\n\tmetal_unused(params);\n\n\t/* Initialize IRQ handling */\n\tmetal_linux_irq_init();\n\treturn 0;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment is reachable when the code is compiled with HAVE_HUGETLBFS_H defined and MAP_HUGE_SHIFT not defined, and at runtime gethugepagesize() returns a value > 0. In that case the call to metal_add_page_size(...) can execute. The fragment is therefore not intrinsically unreachable; any early returns inside metal_add_page_size (e.g. for NULL path or non-positive shift) are runtime checks, not compile-time unreachable code."
}