{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf shmem->name points to a char buffer that is not NUL-terminated (for example: char name[4] = {'A','B','C','D'}), calling strlen(shmem->name) may read past the buffer end. The short-circuit 'shmem->name &&' prevents a NULL dereference but does not guarantee the object contains a terminating '\\0' within its bounds, so strlen can access beyond the object.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_shmem_register_generic code that contains useful probe functions that print useful logs to a file \"/tmp/logs/219.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_shmem_register_generic as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_shmem_register_generic:\n```c\nint metal_shmem_register_generic(struct metal_generic_shmem *shmem)\n{\n\t/* Make sure that we can be found. */\n\tmetal_assert(shmem->name && strlen(shmem->name) != 0);\n\n\t/* Statically registered shmem regions cannot have a destructor. */\n\tmetal_assert(!shmem->io.ops.close);\n\n\tmetal_list_add_tail(&_metal.common.generic_shmem_list,\n\t\t\t    &shmem->node);\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified metal_shmem_register_generic code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n\nint metal_shmem_register_generic(struct metal_generic_shmem *shmem)\n{\n    FILE *log = fopen(\"/tmp/logs/219.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"ENTER: metal_shmem_register_generic\\n\");\n        fprintf(log, \"  shmem ptr: %p\\n\", (void *)shmem);\n        if (shmem) {\n            fprintf(log, \"  shmem->name ptr: %p\\n\", (void *)shmem->name);\n        } else {\n            fprintf(log, \"  shmem is NULL\\n\");\n        }\n        fflush(log);\n    }\n\n    /*\n     * Preserve original evaluation order semantics: only call strlen if\n     * shmem->name is non-NULL (the original used && which short-circuits).\n     * We log the attempt/result so that if strlen reads past the buffer and\n     * causes a failure, the logs show that the code attempted strlen and the\n     * pointer value that was used.\n     */\n    size_t name_len = 0;\n    if (shmem && shmem->name) {\n        if (log) {\n            fprintf(log, \"  About to call strlen(shmem->name) on pointer %p\\n\", (void *)shmem->name);\n            fflush(log);\n        }\n\n        /* This is the same potential-risk call as in the original code. */\n        name_len = strlen(shmem->name);\n\n        if (log) {\n            fprintf(log, \"  strlen returned: %zu\\n\", name_len);\n            fflush(log);\n        }\n    } else {\n        if (log) {\n            fprintf(log, \"  Skipped strlen: shmem or shmem->name is NULL\\n\");\n            fflush(log);\n        }\n    }\n\n    /* Make sure that we can be found. */\n    metal_assert(shmem->name && name_len != 0);\n\n    if (log) {\n        fprintf(log, \"  name assertion passed\\n\");\n        fflush(log);\n    }\n\n    /* Statically registered shmem regions cannot have a destructor. */\n    if (log) {\n        /* Try to log the close pointer value so callers can see its state. */\n        fprintf(log, \"  shmem->io.ops.close ptr: %p\\n\", (void *)shmem->io.ops.close);\n        fflush(log);\n    }\n\n    metal_assert(!shmem->io.ops.close);\n\n    if (log) {\n        fprintf(log, \"  close assertion passed\\n\");\n        fflush(log);\n    }\n\n    metal_list_add_tail(&_metal.common.generic_shmem_list,\n                        &shmem->node);\n\n    if (log) {\n        fprintf(log, \"EXIT: metal_shmem_register_generic -> returning 0\\n\\n\");\n        fclose(log);\n    }\n\n    return 0;\n}\n"
}