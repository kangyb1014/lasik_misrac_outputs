{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function parameter 'io' is declared as a non-const pointer (struct metal_io_region *io) but the function does not modify the pointed-to object; it only reads members (io->size, io->ops) and calls metal_io_virt. Per MISRA C 2023 Rule 8.13, 'io' should be declared as a pointer to const (const struct metal_io_region *io) when possible. Note: 'src' and the local 'source' are const-qualified and the write-target 'ptr' must remain non-const because the function writes through it.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_io_block_write code that contains useful probe functions that print useful logs to a file \"/tmp/logs/123.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_io_block_write as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_io_block_write:\n```c\nint metal_io_block_write(struct metal_io_region *io, unsigned long offset,\n\t       const void *restrict src, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tconst unsigned char *source = src;\n\tint retlen;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_write) {\n\t\tretlen = (*io->ops.block_write)(\n\t\t\tio, offset, src, memory_order_seq_cst, len);\n\t} else {\n\t\twhile ( len && (\n\t\t\t((uintptr_t)ptr % sizeof(int)) ||\n\t\t\t((uintptr_t)source % sizeof(int)))) {\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\t\tptr++;\n\t\t\tsource++;\n\t\t\tlen--;\n\t\t}\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\tsource += sizeof(int),\n\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = *(const unsigned int *)source;\n\t\tfor (; len != 0; ptr++, source++, len--)\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n```\n</target_code>\nPlease provide the modified metal_io_block_write code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdatomic.h>\n\n/* Probe logging helper: append messages to /tmp/logs/123.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint metal_io_block_write(struct metal_io_region *io, unsigned long offset,\n           const void *restrict src, int len)\n{\n    unsigned char *ptr = metal_io_virt(io, offset);\n    const unsigned char *source = src;\n    int retlen;\n\n    probe_log(\"enter metal_io_block_write: io=%p offset=%lu len=%d src=%p\",\n              (void *)io, offset, len, src);\n    probe_log(\"io->size=%lu io->ops=%p io->ops.block_write=%p\",\n              (unsigned long)io->size,\n              (void *)&io->ops,\n              (void *)(uintptr_t)io->ops.block_write);\n    probe_log(\"metal_io_virt returned ptr=%p\", (void *)ptr);\n\n    if (!ptr) {\n        probe_log(\"ptr is NULL -> return -ERANGE\");\n        return -ERANGE;\n    }\n    if ((offset + len) > io->size) {\n        probe_log(\"offset+len (%lu) > io->size (%lu): adjust len %d -> %ld\",\n                  (unsigned long)(offset + (unsigned long)len),\n                  (unsigned long)io->size,\n                  len,\n                  (long)(io->size - offset));\n        len = io->size - offset;\n    }\n    retlen = len;\n    if (io->ops.block_write) {\n        probe_log(\"using io->ops.block_write at %p\", (void *)(uintptr_t)io->ops.block_write);\n        retlen = (*io->ops.block_write)(\n            io, offset, src, memory_order_seq_cst, len);\n        probe_log(\"io->ops.block_write returned %d\", retlen);\n    } else {\n        probe_log(\"enter software-copy path: ptr=%p source=%p len=%d\",\n                  (void *)ptr, (void *)source, len);\n\n        /* Count how many single-byte copies are done before word-aligned copies */\n        int count_initial_bytes = 0;\n        while (len && (((uintptr_t)ptr % sizeof(int)) ||\n                       ((uintptr_t)source % sizeof(int)))) {\n            *(unsigned char *)ptr = *(const unsigned char *)source;\n            ptr++;\n            source++;\n            len--;\n            count_initial_bytes++;\n        }\n        probe_log(\"completed initial unaligned byte copies: %d, remaining len=%d\",\n                  count_initial_bytes, len);\n\n        int count_words = 0;\n        for (; len >= (int)sizeof(int); ptr += sizeof(int),\n                     source += sizeof(int),\n                     len -= sizeof(int)) {\n            *(unsigned int *)ptr = *(const unsigned int *)source;\n            count_words++;\n        }\n        probe_log(\"completed word copies: %d, remaining len=%d\",\n                  count_words, len);\n\n        int count_tail_bytes = 0;\n        for (; len != 0; ptr++, source++, len--) {\n            *(unsigned char *)ptr = *(const unsigned char *)source;\n            count_tail_bytes++;\n        }\n        probe_log(\"completed tail byte copies: %d\", count_tail_bytes);\n\n        atomic_thread_fence(memory_order_seq_cst);\n        probe_log(\"atomic_thread_fence(memory_order_seq_cst) called\");\n    }\n    probe_log(\"exit metal_io_block_write -> retlen=%d\", retlen);\n    return retlen;\n}\n"
}