{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern void metal_log(enum metal_log_level lvl, const char *fmt, ...);\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/722.txt\", \"a\");\n    if (f == NULL) {\n        /* If logging cannot be performed, do not change behaviour. */\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int irq(void)\n{\n    int rc = 0;\n    char *err_msg = \"\";\n    enum metal_log_level mll = metal_get_log_level();\n    int i, tst_irq[2];\n\n    probe_log(\"irq(): entry, previous_log_level=%d\", (int)mll);\n\n    /* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n    metal_set_log_level(METAL_LOG_CRITICAL);\n    probe_log(\"irq(): set log level to METAL_LOG_CRITICAL\");\n\n    for (i = 0; i < 2; i++) {\n        /* we only want to test the lib API, so create 'virtual' IRQs */\n        tst_irq[i] = eventfd(0, 0);\n        probe_log(\"irq(): created virtual irq index=%d fd=%d\", i, tst_irq[i]);\n        metal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n                  __func__, i, tst_irq[i]);\n    }\n\n    rc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 0 returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 0 fail drv_id 1\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n    rc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 1 returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 1 fail drv_id 1\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n\n    metal_irq_unregister(tst_irq[0]);\n    probe_log(\"irq(): unregistered irq 0 (fd=%d)\", tst_irq[0]);\n    rc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 0 after unregister returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 0 after unregistering failed\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n    metal_irq_unregister(tst_irq[0]);\n    probe_log(\"irq(): unregistered irq 0 (fd=%d) second time\", tst_irq[0]);\n    metal_irq_unregister(tst_irq[1]);\n    probe_log(\"irq(): unregistered irq 1 (fd=%d)\", tst_irq[1]);\n\nout:\n    probe_log(\"irq(): cleanup start\");\n    for (i = 0; i < 2; i++) {\n        probe_log(\"irq(): closing fd index=%d fd=%d\", i, tst_irq[i]);\n        close(tst_irq[i]);\n    }\n    metal_set_log_level(mll);\n    probe_log(\"irq(): restored previous_log_level=%d\", (int)mll);\n    if ((err_msg[0] != '\\0') && (!rc))\n        rc = -EINVAL;\n    if (rc) {\n        metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n        probe_log(\"irq(): final rc=%d err_msg=%s\", rc, err_msg);\n    } else {\n        probe_log(\"irq(): final rc=%d no error\", rc);\n    }\n    probe_log(\"irq(): exit\");\n    return rc;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\nIn file included from /tmp/tmps2r531rp/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmps2r531rp/src/test/metal-test.h:19,\n                 from /tmp/tmps2r531rp/src/test/system/linux/irq.c:27:\n/tmp/tmps2r531rp/build/lib/include/metal/log.h:98:37: error: expected identifier or '(' before '{' token\n   98 | #define metal_log(level, fmt, ...) ({                              \\\n      |                                     ^\n/tmp/tmps2r531rp/src/test/system/linux/irq.c:43:13: note: in expansion of macro 'metal_log'\n   43 | extern void metal_log(enum metal_log_level lvl, const char *fmt, ...);\n      |             ^~~~~~~~~\ngmake[2]: *** [test/CMakeFiles/test-metal-shared.dir/build.make:188: test/CMakeFiles/test-metal-shared.dir/system/linux/irq.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:343: test/CMakeFiles/test-metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of irq as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/eventfd.h>\n#include <errno.h>\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/722.txt\", \"a\");\n    if (f == NULL) {\n        /* If logging cannot be performed, do not change behaviour. */\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int irq(void)\n{\n    int rc = 0;\n    char *err_msg = \"\";\n    enum metal_log_level mll = metal_get_log_level();\n    int i, tst_irq[2];\n\n    probe_log(\"irq(): entry, previous_log_level=%d\", (int)mll);\n\n    /* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n    metal_set_log_level(METAL_LOG_CRITICAL);\n    probe_log(\"irq(): set log level to METAL_LOG_CRITICAL\");\n\n    for (i = 0; i < 2; i++) {\n        /* we only want to test the lib API, so create 'virtual' IRQs */\n        tst_irq[i] = eventfd(0, 0);\n        probe_log(\"irq(): created virtual irq index=%d fd=%d\", i, tst_irq[i]);\n        metal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n                  __func__, i, tst_irq[i]);\n    }\n\n    rc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 0 returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 0 fail drv_id 1\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n    rc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 1 returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 1 fail drv_id 1\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n\n    metal_irq_unregister(tst_irq[0]);\n    probe_log(\"irq(): unregistered irq 0 (fd=%d)\", tst_irq[0]);\n    rc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n    probe_log(\"irq(): register irq 0 after unregister returned rc=%d\", rc);\n    if (rc) {\n        err_msg = \"register irq 0 after unregistering failed\\n\";\n        probe_log(\"irq(): error -> %s\", err_msg);\n        goto out;\n    }\n    metal_irq_unregister(tst_irq[0]);\n    probe_log(\"irq(): unregistered irq 0 (fd=%d) second time\", tst_irq[0]);\n    metal_irq_unregister(tst_irq[1]);\n    probe_log(\"irq(): unregistered irq 1 (fd=%d)\", tst_irq[1]);\n\nout:\n    probe_log(\"irq(): cleanup start\");\n    for (i = 0; i < 2; i++) {\n        probe_log(\"irq(): closing fd index=%d fd=%d\", i, tst_irq[i]);\n        close(tst_irq[i]);\n    }\n    metal_set_log_level(mll);\n    probe_log(\"irq(): restored previous_log_level=%d\", (int)mll);\n    if ((err_msg[0] != '\\0') && (!rc))\n        rc = -EINVAL;\n    if (rc) {\n        metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n        probe_log(\"irq(): final rc=%d err_msg=%s\", rc, err_msg);\n    } else {\n        probe_log(\"irq(): final rc=%d no error\", rc);\n    }\n    probe_log(\"irq(): exit\");\n    return rc;\n}\n",
  "explanation": "The compilation error was caused by declaring \"extern void metal_log(...)\" while a macro named metal_log is defined in the included headers. That extern line expands incorrectly against the macro and breaks compilation. I removed the conflicting extern declaration and added the necessary standard includes (stdio.h, stdarg.h, unistd.h, sys/eventfd.h, errno.h) so probe_log, eventfd and close are resolved. The irq logic is unchanged otherwise; calls to metal_log use the existing macro/function from the Metal headers."
}