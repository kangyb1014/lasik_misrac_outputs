{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of irq:\n```c\nstatic int irq(void)\n{\n\tint rc = 0;\n\tchar *err_msg=\"\";\n\tenum metal_log_level mll= metal_get_log_level();\n\tint i, tst_irq[2];\n\n\t/* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n\tmetal_set_log_level(METAL_LOG_CRITICAL);\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* we only want to test the lib API, so create 'virtual' IRQs */\n\t\ttst_irq[i] = eventfd(0,0);\n\t\tmetal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n\t\t\t  __func__, i, tst_irq[i]);\n\t}\n\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\trc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 1 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\n\tmetal_irq_unregister(tst_irq[0]);\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 after unregistering failed\\n\";\n\t\tgoto out;\n\t}\n\tmetal_irq_unregister(tst_irq[0]);\n\tmetal_irq_unregister(tst_irq[1]);\n\nout:\n\tfor (i = 0; i < 2; i++) {\n\t\tclose(tst_irq[i]);\n\t}\n\tmetal_set_log_level(mll);\n\tif ((err_msg[0] != '\\0') && (!rc))\n\t\trc = -EINVAL;\n\tif (rc) metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n\treturn rc;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function irq:\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n\tstruct metal_list *node;\n\tstruct metal_irq_controller *cntr;\n\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tint irq_base, irq_end;\n\n\t\tcntr = (struct metal_irq_controller *)\n\t\t       metal_container_of(node, struct metal_irq_controller,\n\t\t\t\t\t  node);\n\t\tirq_base = cntr->irq_base;\n\t\tirq_end = irq_base + cntr->irq_num;\n\t\tif (irq >= irq_base && irq < irq_end) {\n\t\t\treturn cntr;\n\t\t}\n\t}\n\treturn NULL;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic int irq_handler(int irq, void *priv)\n{\n\t(void)irq;\n\t(void)priv;\n\n\treturn 0;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nchar *err_msg=\"\";\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The initialization char *err_msg = \"\" is not dead code: it provides a defined, empty string so the later check (err_msg[0] != '\\0') is well-defined. Removing this initialization would change program behaviour (introduce undefined behaviour if an error path does not set err_msg), so the operation is necessary. (Also note MISRA\u2019s comment that initialization is not considered a candidate for dead code.)"
}