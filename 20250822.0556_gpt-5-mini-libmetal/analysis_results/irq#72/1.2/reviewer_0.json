{
  "user_message": "An agent A claimed that the following irq code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of irq.\n```c\nstatic int irq(void)\n{\n\tint rc = 0;\n\tchar *err_msg=\"\";\n\tenum metal_log_level mll= metal_get_log_level();\n\tint i, tst_irq[2];\n\n\t/* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n\tmetal_set_log_level(METAL_LOG_CRITICAL);\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* we only want to test the lib API, so create 'virtual' IRQs */\n\t\ttst_irq[i] = eventfd(0,0);\n\t\tmetal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n\t\t\t  __func__, i, tst_irq[i]);\n\t}\n\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\trc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 1 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\n\tmetal_irq_unregister(tst_irq[0]);\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 after unregistering failed\\n\";\n\t\tgoto out;\n\t}\n\tmetal_irq_unregister(tst_irq[0]);\n\tmetal_irq_unregister(tst_irq[1]);\n\nout:\n\tfor (i = 0; i < 2; i++) {\n\t\tclose(tst_irq[i]);\n\t}\n\tmetal_set_log_level(mll);\n\tif ((err_msg[0] != '\\0') && (!rc))\n\t\trc = -EINVAL;\n\tif (rc) metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n\treturn rc;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_log uses GCC/Clang language extensions: the statement-expression construct ({ ... }) and the GNU comma-elision token pasting '##__VA_ARGS__'. These are compiler-specific extensions and therefore violate MISRA C 2023 Rule 1.2 (language extensions should not be used).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: irq() start\nSTATE: saved log level mll=7\nACTION: metal_set_log_level(METAL_LOG_CRITICAL) called\nEVENTFD: eventfd() -> tst_irq[0]=6 (errno=0, strerror=Success)\nCALL: about to call metal_log(METAL_LOG_DEBUG, \"irq: irq 0 associated with fd 6\\n\", __func__, 0, 6)\nCALL_RET: metal_log returned (no rc available) for debug message\nEVENTFD: eventfd() -> tst_irq[1]=7 (errno=0, strerror=Success)\nCALL: about to call metal_log(METAL_LOG_DEBUG, \"irq: irq 1 associated with fd 7\\n\", __func__, 1, 7)\nCALL_RET: metal_log returned (no rc available) for debug message\nACTION: registering irq 0 (fd=6)\nRESULT: metal_irq_register(fd=6) rc=0\nACTION: registering irq 1 (fd=7)\nRESULT: metal_irq_register(fd=7) rc=0\nACTION: unregistering irq 0 (fd=6)\nACTION: registering irq 0 again (fd=6)\nRESULT: metal_irq_register(after unregister) fd=6 rc=0\nACTION: unregistering irq 0 and irq 1 (fd=6, 7)\nCLOSE: closing tst_irq[0]=6\nCLOSE: closing tst_irq[1]=7\nSTATE: restored log level to mll=7\nFINAL: err_msg= rc=0\nEXIT: irq() returning rc=0\nENTER: irq() start\nSTATE: saved log level mll=7\nACTION: metal_set_log_level(METAL_LOG_CRITICAL) called\nEVENTFD: eventfd() -> tst_irq[0]=6 (errno=0, strerror=Success)\nCALL: about to call metal_log(METAL_LOG_DEBUG, \"irq: irq 0 associated with fd 6\\n\", __func__, 0, 6)\nCALL_RET: metal_log returned (no rc available) for debug message\nEVENTFD: eventfd() -> tst_irq[1]=7 (errno=0, strerror=Success)\nCALL: about to call metal_log(METAL_LOG_DEBUG, \"irq: irq 1 associated with fd 7\\n\", __func__, 1, 7)\nCALL_RET: metal_log returned (no rc available) for debug message\nACTION: registering irq 0 (fd=6)\nRESULT: metal_irq_register(fd=6) rc=0\nACTION: registering irq 1 (fd=7)\nRESULT: metal_irq_register(fd=7) rc=0\nACTION: unregistering irq 0 (fd=6)\nACTION: registering irq 0 again (fd=6)\nRESULT: metal_irq_register(after unregister) fd=6 rc=0\nACTION: unregistering irq 0 and irq 1 (fd=6, 7)\nCLOSE: closing tst_irq[0]=6\nCLOSE: closing tst_irq[1]=7\nSTATE: restored log level to mll=7\nFINAL: err_msg= rc=0\nEXIT: irq() returning rc=0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function irq:\nstatic int irq_handler(int irq, void *priv)\n{\n\t(void)irq;\n\t(void)priv;\n\n\treturn 0;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nenum metal_log_level {\n\tMETAL_LOG_EMERGENCY,\t/**< system is unusable.               */\n\tMETAL_LOG_ALERT,\t/**< action must be taken immediately. */\n\tMETAL_LOG_CRITICAL,\t/**< critical conditions.              */\n\tMETAL_LOG_ERROR,\t/**< error conditions.                 */\n\tMETAL_LOG_WARNING,\t/**< warning conditions.               */\n\tMETAL_LOG_NOTICE,\t/**< normal but significant condition. */\n\tMETAL_LOG_INFO,\t\t/**< informational messages.           */\n\tMETAL_LOG_DEBUG,\t/**< debug-level messages.             */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The macro metal_log shown in the additional code uses two compiler-specific GNU extensions: the statement-expression construct ({ ... }) and the GNU variadic-macro comma elision trick using '##__VA_ARGS__'. Both constructs are documented as GCC/Clang extensions (not standard C), so their use constitutes language extensions and therefore violates MISRA C:2023 Rule 1.2 unless the project explicitly permits those compiler extensions. Because irq() calls metal_log, the target code is affected by that non\u2011conforming macro, so the report of a Rule 1.2 violation is correct."
}