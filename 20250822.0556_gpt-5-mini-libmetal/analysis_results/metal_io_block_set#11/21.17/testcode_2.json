{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The expression (offset + len) mixes unsigned long (offset) with signed int (len) so len is converted to unsigned before the addition. This can produce incorrect results in two ways: (1) a negative len is converted to a large unsigned value, or (2) the addition can wrap (unsigned overflow), making the comparison with io->size give the wrong outcome. In either case the subsequent code may fail to clamp len to (io->size - offset) and therefore may perform writes past the region boundary (out-of-bounds access). This is a violation of MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_io_block_set code that contains useful probe functions that print useful logs to a file \"/tmp/logs/119.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_io_block_set as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_io_block_set:\n```c\nint metal_io_block_set(struct metal_io_region *io, unsigned long offset,\n\t       unsigned char value, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tint retlen = len;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_set) {\n\t\t(*io->ops.block_set)(\n\t\t\tio, offset, value, memory_order_seq_cst, len);\n\t} else {\n\t\tunsigned int cint = value;\n\t\tunsigned int i;\n\n\t\tfor (i = 1; i < sizeof(int); i++)\n\t\t\tcint |= ((unsigned int)value << (CHAR_BIT * i));\n\n\t\tfor (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = cint;\n\t\tfor (; len != 0; ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n```\n</target_code>\nPlease provide the modified metal_io_block_set code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdatomic.h>\n\n/* Minimal stubs to allow this translation unit to compile and be linked into tests.\n   These mirror just the pieces used by metal_io_block_set so the function remains\n   executable for testing the logging probes. */\n\nstruct metal_io_region;\n\nstruct metal_io_ops {\n    /* signature mirrors usage in code: (io, offset, value, memory_order, len) */\n    void (*block_set)(struct metal_io_region *, unsigned long, unsigned char, int, int);\n};\n\nstruct metal_io_region {\n    unsigned long size;\n    struct metal_io_ops ops;\n    unsigned char *virt; /* pointer to backing storage for testing */\n};\n\n/* Simple metal_io_virt implementation for testing: returns io->virt + offset if in range, else NULL. */\nstatic unsigned char *metal_io_virt(struct metal_io_region *io, unsigned long offset)\n{\n    if (!io || offset >= io->size)\n        return NULL;\n    return io->virt + offset;\n}\n\n/* Simple logging helper that appends to /tmp/logs/119.txt. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/119.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\n/* Modified metal_io_block_set with probes inserted to record control flow and state. */\nint metal_io_block_set(struct metal_io_region *io, unsigned long offset,\n           unsigned char value, int len)\n{\n    unsigned char *ptr = metal_io_virt(io, offset);\n    int retlen = len;\n\n    /* Log entry state: pointers and numeric values (decimal and hex where useful). */\n    probe_log(\"ENTER: metal_io_block_set: io=%p, offset=%llu (0x%llx), value=%u, len=%d\\n\",\n              (void *)io, (unsigned long long)offset, (unsigned long long)offset,\n              (unsigned int)value, len);\n\n    if (io) {\n        probe_log(\"io->size=%llu (0x%llx)\\n\",\n                  (unsigned long long)io->size, (unsigned long long)io->size);\n    } else {\n        probe_log(\"io is NULL\\n\");\n    }\n\n    if (!ptr) {\n        probe_log(\"NULL pointer from metal_io_virt: returning -ERANGE\\n\");\n        return -ERANGE;\n    }\n\n    /* Compute the addition as it will happen in C (len is promoted to unsigned long). */\n    unsigned long sum_as_unsigned = offset + (unsigned long)len;\n    long long sum_as_signed = (long long)offset + (long long)len;\n\n    probe_log(\"Computed sums: (unsigned)offset + (unsigned)len -> %llu (0x%llx)\\n\",\n              (unsigned long long)sum_as_unsigned, (unsigned long long)sum_as_unsigned);\n    probe_log(\"Computed sums: (signed)offset + (signed)len -> %lld\\n\", sum_as_signed);\n\n    if (len < 0)\n        probe_log(\"Note: len is negative (%d) -> will be converted to unsigned for the addition\\n\", len);\n\n    if (sum_as_unsigned < offset)\n        probe_log(\"Unsigned wrap detected: sum_as_unsigned (%llu) < offset (%llu)\\n\",\n                  (unsigned long long)sum_as_unsigned, (unsigned long long)offset);\n\n    /* Preserve original logic: perform the same check and possible clamp. */\n    if ((offset + len) > io->size)\n        len = io->size - offset;\n\n    probe_log(\"After clamp check: adjusted len=%d, retlen will be set to this value\\n\", len);\n\n    retlen = len;\n\n    if (io->ops.block_set) {\n        probe_log(\"Using io->ops.block_set path: calling block_set(io, offset, value, memory_order_seq_cst, len=%d)\\n\", len);\n        (*io->ops.block_set)(\n            io, offset, value, (int)memory_order_seq_cst, len);\n    } else {\n        unsigned int cint = value;\n        unsigned int i;\n\n        probe_log(\"Using fallback byte/word fill path: initial ptr=%p, initial len=%d\\n\", (void *)ptr, len);\n\n        for (i = 1; i < sizeof(int); i++)\n            cint |= ((unsigned int)value << (CHAR_BIT * i));\n\n        probe_log(\"Constructed fill pattern cint=0x%08x\\n\", cint);\n\n        for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--) {\n            *(unsigned char *)ptr = (unsigned char) value;\n        }\n        probe_log(\"After aligning to int: ptr=%p, remaining len=%d\\n\", (void *)ptr, len);\n\n        for (; len >= (int)sizeof(int); ptr += sizeof(int),\n                        len -= sizeof(int))\n            *(unsigned int *)ptr = cint;\n\n        probe_log(\"After bulk int writes: ptr=%p, remaining len=%d\\n\", (void *)ptr, len);\n\n        for (; len != 0; ptr++, len--)\n            *(unsigned char *)ptr = (unsigned char) value;\n\n        probe_log(\"After tail byte writes: ptr=%p, remaining len=%d\\n\", (void *)ptr, len);\n\n        atomic_thread_fence(memory_order_seq_cst);\n    }\n\n    probe_log(\"EXIT: metal_io_block_set returning retlen=%d\\n\", retlen);\n    return retlen;\n}\n"
}