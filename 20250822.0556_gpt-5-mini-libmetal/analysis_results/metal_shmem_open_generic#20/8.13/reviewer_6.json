{
  "user_message": "An agent A claimed that the following metal_shmem_open_generic code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open_generic.\n```c\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local iterator is declared as a non-const pointer: 'struct metal_list *node;'. In metal_shmem_open_generic the list is only traversed/read (used by metal_list_for_each and metal_container_of) and not modified, so the pointer could be 'const struct metal_list *node' (and shmem could be a pointer to a const container). Therefore the current declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f791affce20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f791a7fbe20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f791b7fde20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f791bffee20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f792156de20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f7920d6ce20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f79197f9e20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f7919ffae20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f7918ff8e20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7f78fbffee20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1c0d2be20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1c152ce20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1bbffee20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1c1d2de20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1c252ee20\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1c2d2fe20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1bb7fde20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1baffce20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1ba7fbe20\nno matching shmem found for name=\"/foo\", returning -ENOENT\nmetal_shmem_open_generic called: name=\"/foo\", size=1048576, result=0x7fe1b9efae20\nno matching shmem found for name=\"/foo\", returning -ENOENT\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open_generic:\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nstruct metal_generic_shmem {\n\tconst char\t\t*name;\n\tstruct metal_io_region\tio;\n\tstruct metal_list\tnode;\n}\n...\nstruct metal_list {\n\tstruct metal_list *next, *prev;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The local iterator 'node' could in principle be declared 'const struct metal_list *node' if all helper macros (metal_list_for_each, metal_container_of) are const-correct, but the critical pointer that prevents marking things const is 'shmem'. If you change 'shmem' to 'const struct metal_generic_shmem *' then 'shmem->io' becomes 'const struct metal_io_region' and '&shmem->io' has type 'const struct metal_io_region *', which cannot be assigned to the non-const 'struct metal_io_region *' expected by the 'result' out-parameter without a cast or changing the API. In other words, making the container pointer const is not possible here without changing the function signature (or casting away const), so Rule 8.13 is not violated in this code as written. Additionally, many list/container macros are not const-aware, so simply changing 'node' to const may not be possible without adjusting those macros. To satisfy 8.13 you would need const-correct macros and an API that returns a pointer-to-const (or otherwise reconcile the const qualifiers)."
}