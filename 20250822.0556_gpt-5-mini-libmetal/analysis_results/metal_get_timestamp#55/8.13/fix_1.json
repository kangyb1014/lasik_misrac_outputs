{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern void metal_log(int level, char *msg);\nstatic const unsigned long long NS_PER_S = 1000000000ULL;\nstatic const int METAL_LOG_ERROR = 3;\nstatic void probe_record(const char *phase,\n                         int clock_ret,\n                         int saved_errno,\n                         const void *msg_addr)\n{\n    FILE *f = NULL;\n    /* Ensure directory exists. If mkdir fails because dir exists, ignore. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n\n    f = fopen(\"/tmp/logs/553.txt\", \"a\");\n    if (f == NULL) {\n        /* If logging cannot be performed, do not change behavior. */\n        return;\n    }\n\n    /* Record a compact, parseable log entry with relevant state. */\n    (void)fprintf(f,\n                  \"phase=%s clock_ret=%d errno=%d msg_addr=%p pid=%d\\n\",\n                  phase,\n                  clock_ret,\n                  saved_errno,\n                  msg_addr,\n                  (int)getpid());\n\n    (void)fflush(f);\n    (void)fclose(f);\n}\n\nunsigned long long metal_get_timestamp(void)\n{\n    unsigned long long t = 0;\n    struct timespec tp;\n    int r;\n\n    r = clock_gettime(CLOCK_MONOTONIC, &tp);\n    if (r == -1) {\n        /* Capture state before calling metal_log so that another agent\n         * can observe the pointer being passed (address of the string\n         * literal) and other contextual information.\n         */\n        /* Save errno immediately for logging (clock_gettime may have set it). */\n        int saved_errno = errno;\n        const char *msg_literal = \"clock_gettime failed!\\n\";\n\n        /* Log probe entry showing we are about to call metal_log with a\n         * string literal. This records the pointer address of the literal\n         * so other agents can inspect that a string literal is being\n         * passed to a non-const char * parameter (the violation scenario).\n         */\n        probe_record(\"before_metal_log\", r, saved_errno, (const void *)msg_literal);\n\n        /* Original call preserved (passing a string literal to a non-const char*).\n         * The prototype of metal_log is intentionally non-const char * here\n         * to reproduce the MISRA Rule 8.13 violation scenario.\n         */\n        metal_log(METAL_LOG_ERROR, (char *)msg_literal);\n\n        /* Record that the call was performed; do not rely on metal_log's\n         * behavior, just note that we made the call.\n         */\n        probe_record(\"after_metal_log\", r, saved_errno, (const void *)msg_literal);\n\n        return t;\n    }\n    t = tp.tv_sec * (NS_PER_S);\n    t += tp.tv_nsec;\n\n    /* Log a successful timestamp retrieval for control flow tracing. */\n    probe_record(\"success\", r, 0, NULL);\n\n    return t;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\nIn file included from /tmp/tmpkz7np81c/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmpkz7np81c/build/lib/include/metal/time.h:16,\n                 from /tmp/tmpkz7np81c/src/lib/system/linux/time.c:26:\n/tmp/tmpkz7np81c/build/lib/include/metal/log.h:98:37: error: expected identifier or '(' before '{' token\n   98 | #define metal_log(level, fmt, ...) ({                              \\\n      |                                     ^\n/tmp/tmpkz7np81c/src/lib/system/linux/time.c:30:13: note: in expansion of macro 'metal_log'\n   30 | extern void metal_log(int level, char *msg);\n      |             ^~~~~~~~~\n/tmp/tmpkz7np81c/src/lib/system/linux/time.c:28:26: error: expected identifier or '(' before numeric constant\n   28 | #define NS_PER_S        (1000 * 1000 * 1000)\n      |                          ^~~~\n/tmp/tmpkz7np81c/src/lib/system/linux/time.c:31:33: note: in expansion of macro 'NS_PER_S'\n   31 | static const unsigned long long NS_PER_S = 1000000000ULL;\n      |                                 ^~~~~~~~\n/tmp/tmpkz7np81c/src/lib/system/linux/time.c:32:18: error: 'METAL_LOG_ERROR' redeclared as different kind of symbol\n   32 | static const int METAL_LOG_ERROR = 3;\n      |                  ^~~~~~~~~~~~~~~\nIn file included from /tmp/tmpkz7np81c/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmpkz7np81c/build/lib/include/metal/time.h:16,\n                 from /tmp/tmpkz7np81c/src/lib/system/linux/time.c:26:\n/tmp/tmpkz7np81c/build/lib/include/metal/log.h:28:9: note: previous definition of 'METAL_LOG_ERROR' with type 'enum metal_log_level'\n   28 |         METAL_LOG_ERROR,        /**< error conditions.                 */\n      |         ^~~~~~~~~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:272: lib/CMakeFiles/metal-shared.dir/system/linux/time.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_get_timestamp as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* If a macro named metal_log was pulled in from a header, it conflicts\n * with declaring the real function prototype. Undefine the macro so we\n * can declare the function and call it as intended.\n */\n#ifdef metal_log\n#undef metal_log\n#endif\n\nextern void metal_log(int level, char *msg);\n\nstatic void probe_record(const char *phase,\n                         int clock_ret,\n                         int saved_errno,\n                         const void *msg_addr)\n{\n    FILE *f = NULL;\n    /* Ensure directory exists. If mkdir fails because dir exists, ignore. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n\n    f = fopen(\"/tmp/logs/553.txt\", \"a\");\n    if (f == NULL) {\n        /* If logging cannot be performed, do not change behavior. */\n        return;\n    }\n\n    /* Record a compact, parseable log entry with relevant state. */\n    (void)fprintf(f,\n                  \"phase=%s clock_ret=%d errno=%d msg_addr=%p pid=%d\\n\",\n                  phase,\n                  clock_ret,\n                  saved_errno,\n                  msg_addr,\n                  (int)getpid());\n\n    (void)fflush(f);\n    (void)fclose(f);\n}\n\nunsigned long long metal_get_timestamp(void)\n{\n    unsigned long long t = 0;\n    struct timespec tp;\n    int r;\n\n    r = clock_gettime(CLOCK_MONOTONIC, &tp);\n    if (r == -1) {\n        /* Capture state before calling metal_log so that another agent\n         * can observe the pointer being passed (address of the string\n         * literal) and other contextual information.\n         */\n        /* Save errno immediately for logging (clock_gettime may have set it). */\n        int saved_errno = errno;\n        const char *msg_literal = \"clock_gettime failed!\\n\";\n\n        /* Log probe entry showing we are about to call metal_log with a\n         * string literal. This records the pointer address of the literal\n         * so other agents can inspect that a string literal is being\n         * passed to a non-const char * parameter (the violation scenario).\n         */\n        probe_record(\"before_metal_log\", r, saved_errno, (const void *)msg_literal);\n\n        /* Original call preserved (passing a string literal to a non-const char*).\n         * The prototype of metal_log is intentionally non-const char * here\n         * to reproduce the MISRA Rule 8.13 violation scenario.\n         */\n        metal_log(/* level */ 3, (char *)msg_literal);\n\n        /* Record that the call was performed; do not rely on metal_log's\n         * behavior, just note that we made the call.\n         */\n        probe_record(\"after_metal_log\", r, saved_errno, (const void *)msg_literal);\n\n        return t;\n    }\n    /* Use an explicit 1e9 constant to avoid colliding with any NS_PER_S macro. */\n    t = (unsigned long long)tp.tv_sec * 1000000000ULL;\n    t += tp.tv_nsec;\n\n    /* Log a successful timestamp retrieval for control flow tracing. */\n    probe_record(\"success\", r, 0, NULL);\n\n    return t;\n}\n",
  "explanation": "Fixed macro/name collisions with project headers:\n\n- Removed the conflicting static constants for NS_PER_S and METAL_LOG_ERROR and instead use an explicit 1000000000ULL and the literal log level (3) where needed. This avoids redeclaring names that the included project headers already define.\n- Undefined any existing metal_log macro (using #undef) before declaring the extern prototype for the real metal_log function so the prototype doesn't get corrupted by macro expansion.\n- Kept the original metal_get_timestamp logic intact (including the probe_record calls and passing the string literal cast to (char *) to metal_log) while ensuring the code compiles without macro redefinition errors.\n\nNo macros were defined; only an #undef was used to prevent header-provided macros from interfering with the function prototype. The code preserves the original behavior as much as possible and should compile in the original build environment."
}