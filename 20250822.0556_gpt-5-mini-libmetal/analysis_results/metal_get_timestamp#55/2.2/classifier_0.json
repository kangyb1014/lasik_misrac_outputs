{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_get_timestamp:\n```c\nunsigned long long metal_get_timestamp(void)\n{\n\tunsigned long long t = 0;\n\tstruct timespec tp;\n\tint r;\n\n\tr = clock_gettime(CLOCK_MONOTONIC, &tp);\n\tif (r == -1) {\n\t\tmetal_log(METAL_LOG_ERROR, \"clock_gettime failed!\\n\");\n\t\treturn t;\n\t}\n\tt = tp.tv_sec * (NS_PER_S);\n\tt += tp.tv_nsec;\n\n\treturn t;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_get_timestamp:\n#define NS_PER_S (1000*1000*1000)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No. The macro expands to a conditional call to the logging handler: the log call is executed only when _metal.common.log_handler is non-NULL and the level check passes. Removing the macro call would change program behaviour when logging is enabled (loss of log output) and can also change timing (note 1 of the rule), so the code is not dead. Even when the condition is false the check is an executed operation (and not unreachable code) but it is not removable without potentially affecting behaviour, therefore Rule 2.2 is not violated."
}