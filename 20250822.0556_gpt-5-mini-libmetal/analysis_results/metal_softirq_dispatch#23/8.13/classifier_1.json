{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_softirq_dispatch:\n```c\nvoid metal_softirq_dispatch(void)\n{\n\tint i;\n\n\tfor (i = 0; i < metal_softirq_num; i++) {\n\t\tstruct metal_irq *irq;\n\t\tchar is_pending = 1;\n\n\t\tif (atomic_load(&metal_softirq_enabled[i]) != 0 &&\n\t\t    atomic_compare_exchange_strong(&metal_softirq_pending[i],\n\t\t\t\t\t\t   &is_pending, 0)) {\n\t\t\tirq = &metal_softirqs[i];\n\t\t\t(void)metal_irq_handle(irq,\n\t\t\t\t\t       i + metal_softirq_cntr.irq_base);\n\t\t}\n\t}\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_softirq_dispatch:\nstruct metal_irq {\n\tmetal_irq_handler hd; /**< Interrupt handler */\n\tvoid *arg; /**< Argument to pass to the interrupt handler */\n}\n...\n\n...\n\n...\n\n...\n\n...\nstatic METAL_IRQ_CONTROLLER_DECLARE(metal_softirq_cntr,\n\t\t\t\t    METAL_IRQ_ANY, METAL_SOFTIRQ_NUM,\n\t\t\t\t    NULL,\n\t\t\t\t    metal_softirq_set_enable, NULL,\n\t\t\t\t    metal_softirqs)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic METAL_IRQ_CONTROLLER_DECLARE(metal_softirq_cntr,\n                                    METAL_IRQ_ANY, METAL_SOFTIRQ_NUM,\n                                    NULL,\n                                    metal_softirq_set_enable, NULL,\n                                    metal_softirqs)\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "From the fragment alone there is no evidence that a non-const pointer type is required or used; whether Rule 8.13 is violated depends on the definition of the macro METAL_IRQ_CONTROLLER_DECLARE. If that macro stores the address of metal_softirqs into a non-const pointer (e.g. struct metal_irq *controller_irqs = metal_softirqs) even though the controller never modifies the array, then Rule 8.13 would be violated \u2014 the pointer should be to a const-qualified type (e.g. const struct metal_irq *). Conversely, if the controller legitimately modifies the metal_softirqs elements (or the macro already uses a const-qualified pointer), then there is no violation. Because the macro definition is not shown, a violation cannot be asserted from the fragment alone; a violation scenario is as described above."
}