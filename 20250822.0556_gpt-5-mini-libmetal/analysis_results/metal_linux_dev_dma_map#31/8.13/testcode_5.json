{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function to_linux_device takes a non-const pointer (struct metal_device *device) even though it does not modify the object; therefore the parameter (and correspondingly the returned pointer) could and should be const-qualified. As written, constness cannot be preserved (calls that have a const struct metal_device * would need a cast), which violates MISRA C 2023 Rule 8.13. A compliant signature would be, for example, 'static const struct linux_device *to_linux_device(const struct metal_device *device)' (or provide both const and non-const variants), so the current code violates the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_linux_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/313.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_linux_dev_dma_map as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_linux_dev_dma_map:\n```c\nstatic int metal_linux_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tstruct linux_device *ldev = to_linux_device(device);\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\n\treturn ldev->ldrv->dev_dma_map(lbus, ldev, dir, sg_in,\n\t\t\t\t       nents_in, sg_out);\n}\n```\n</target_code>\nPlease provide the modified metal_linux_dev_dma_map code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Minimal placeholder types so this translation unit compiles. */\nstruct metal_bus { int placeholder_bus; };\nstruct metal_device { int placeholder_dev; };\nstruct metal_sg { int placeholder_sg; };\n\nstruct linux_bus { int placeholder_lbus; };\n\nstruct linux_device;\n\nstruct linux_driver {\n    int (*dev_dma_map)(struct linux_bus *lbus,\n                       struct linux_device *ldev,\n                       uint32_t dir,\n                       struct metal_sg *sg_in,\n                       int nents_in,\n                       struct metal_sg *sg_out);\n};\n\nstruct linux_device {\n    struct linux_driver *ldrv;\n};\n\n/* Forward declarations of conversion helpers used by the original code. */\nstatic struct linux_device *to_linux_device(struct metal_device *device);\nstatic struct linux_bus *to_linux_bus(struct metal_bus *bus);\n\n/* A simple stub implementation of dev_dma_map used by to_linux_device()'s\n * returned linux_device, allowing this translation unit to compile and be\n * testable. This preserves the original control flow: metal_linux_dev_dma_map\n * calls the driver's dev_dma_map and returns its result. */\nstatic int stub_dev_dma_map(struct linux_bus *lbus,\n                            struct linux_device *ldev,\n                            uint32_t dir,\n                            struct metal_sg *sg_in,\n                            int nents_in,\n                            struct metal_sg *sg_out)\n{\n    /* Keep behavior minimal; return 0 to indicate success in the stub. */\n    (void)lbus;\n    (void)ldev;\n    (void)dir;\n    (void)sg_in;\n    (void)nents_in;\n    (void)sg_out;\n    return 0;\n}\n\n/* Provide simple conversion helpers that return static objects. These\n * implementations are only for enabling compilation and for producing logs\n * that show the control flow and pointer values relevant to the scenario. */\nstatic struct linux_device *to_linux_device(struct metal_device *device)\n{\n    static struct linux_driver drv = { .dev_dma_map = stub_dev_dma_map };\n    static struct linux_device ldev = { .ldrv = &drv };\n\n    (void)device; /* Preserve original signature semantics: input not modified. */\n    return &ldev;\n}\n\nstatic struct linux_bus *to_linux_bus(struct metal_bus *bus)\n{\n    static struct linux_bus lbus = { .placeholder_lbus = 0 };\n    (void)bus; /* Preserve original signature semantics: input not modified. */\n    return &lbus;\n}\n\n/* Modified function with logging probes that record control flow and state to\n * /tmp/logs/313.txt. The original logic is preserved: the function returns\n * the result of ldrv->dev_dma_map(...). */\nstatic int metal_linux_dev_dma_map(struct metal_bus *bus,\n                     struct metal_device *device,\n                     uint32_t dir,\n                     struct metal_sg *sg_in,\n                     int nents_in,\n                     struct metal_sg *sg_out)\n{\n    int result = -1;\n    FILE *log = NULL;\n\n    /* Ensure the log directory exists. Ignore errors other than non-existent\n     * parent creation failure. */\n    if (mkdir(\"/tmp/logs\", 0777) != 0) {\n        if (errno != EEXIST) {\n            /* If directory creation failed for another reason, proceed but\n             * note the errno in the log (if opening log succeeds). */\n        }\n    }\n\n    log = fopen(\"/tmp/logs/313.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"ENTER: metal_linux_dev_dma_map\\n\");\n        fprintf(log, \"  incoming bus ptr = %p\\n\", (const void *)bus);\n        fprintf(log, \"  incoming device ptr = %p\\n\", (const void *)device);\n        fflush(log);\n    }\n\n    /* Original control flow: obtain linux wrappers and call driver map. */\n    struct linux_device *ldev = to_linux_device(device);\n    struct linux_bus *lbus = to_linux_bus(bus);\n\n    if (log != NULL) {\n        fprintf(log, \"  to_linux_device returned ldev = %p\\n\", (const void *)ldev);\n        fprintf(log, \"  to_linux_bus returned lbus = %p\\n\", (const void *)lbus);\n        if (ldev != NULL && ldev->ldrv != NULL) {\n            fprintf(log, \"  ldev->ldrv = %p\\n\", (const void *)ldev->ldrv);\n        } else {\n            fprintf(log, \"  ldev->ldrv = NULL\\n\");\n        }\n        fflush(log);\n    }\n\n    /* Call the underlying driver function (preserving original logic). */\n    if (ldev != NULL && ldev->ldrv != NULL && ldev->ldrv->dev_dma_map != NULL) {\n        if (log != NULL) {\n            fprintf(log, \"  calling ldev->ldrv->dev_dma_map(...)\\n\");\n            fprintf(log, \"    dir = %u, nents_in = %d\\n\", (unsigned)dir, nents_in);\n            fflush(log);\n        }\n\n        result = ldev->ldrv->dev_dma_map(lbus, ldev, dir, sg_in, nents_in, sg_out);\n\n        if (log != NULL) {\n            fprintf(log, \"  dev_dma_map returned %d\\n\", result);\n            fflush(log);\n        }\n    } else {\n        if (log != NULL) {\n            fprintf(log, \"  dev_dma_map not called: driver or function pointer NULL\\n\");\n            fflush(log);\n        }\n        /* Keep result as -1 to indicate failure when driver not available. */\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"EXIT: metal_linux_dev_dma_map -> %d\\n\\n\", result);\n        fclose(log);\n    }\n\n    return result;\n}\n"
}