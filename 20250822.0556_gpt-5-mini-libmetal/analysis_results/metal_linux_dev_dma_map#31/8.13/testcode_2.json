{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe struct metal_sg contains non-const pointers where at least one can (and should) be const-qualified. In particular, the member 'struct metal_io_region *io' points to metadata (an I/O region descriptor) that is typically not modified through an SG entry and therefore should be declared 'const struct metal_io_region *io'. As written it permits modification of the region descriptor via the SG, which violates the MISRA C 2023 Rule 8.13 requirement that pointers point to a const-qualified type whenever possible. (Note: 'void *virt' cannot be made const unilaterally because the same structure is used for both input and output SG lists; if a read-only-only SG type is needed, a separate const-qualified variant should be used.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_linux_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/313.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_linux_dev_dma_map as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_linux_dev_dma_map:\n```c\nstatic int metal_linux_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tstruct linux_device *ldev = to_linux_device(device);\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\n\treturn ldev->ldrv->dev_dma_map(lbus, ldev, dir, sg_in,\n\t\t\t\t       nents_in, sg_out);\n}\n```\n</target_code>\nPlease provide the modified metal_linux_dev_dma_map code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n\n/* Helper probe: write a compact trace into /tmp/logs/313.txt.  This does not\n * change the control flow or semantics of the original function; it only\n * records addresses and basic parameters so other agents can reproduce the\n * call sites and inspect the SG pointers at runtime.\n *\n * NOTE: Keep this helper minimal and defensive so it can be compiled into the\n * same translation unit as the original code without introducing new\n * violations. */\nstatic void metal_log_sg_probe(const char *phase,\n                               struct linux_bus *lbus,\n                               struct linux_device *ldev,\n                               uint32_t dir,\n                               struct metal_sg *sg_in,\n                               int nents_in,\n                               struct metal_sg *sg_out,\n                               void *dev_dma_map_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/313.txt\", \"a\");\n    if (f == NULL) {\n        return; /* best-effort logging only */\n    }\n\n    /* timestamp and basic call-site/state information */\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] phase=%s lbus=%p ldev=%p dev_dma_map=%p dir=%u sg_in=%p nents_in=%d sg_out=%p\\n\",\n            (long)t, phase, (void *)lbus, (void *)ldev, dev_dma_map_ptr,\n            (unsigned)dir, (void *)sg_in, nents_in, (void *)sg_out);\n\n    /* If we have an input SG pointer, print a small raw snapshot: the pointer\n     * value and the first several bytes of the SG structure (if readable).\n     * We do not attempt to interpret the structure here to avoid depending on\n     * internal layout; this just provides evidence that an SG was passed and\n     * lets an investigator inspect the memory image later if needed. */\n    if (sg_in != NULL && nents_in > 0) {\n        /* Write the pointer to the first SG entry. This helps show whether\n         * the SG entry points into a region that looks like metadata. */\n        fprintf(f, \"  sg_in_first_entry_ptr=%p\\n\", (void *)sg_in);\n\n        /* Attempt to dump up to 64 bytes of the SG structure for offline\n         * inspection. Use unsigned char to avoid signedness issues. */\n        unsigned char *bytes = (unsigned char *)sg_in;\n        size_t dump_len = 0U;\n        /* Safe upper bound for the dump to keep logs reasonable */\n        dump_len = 64U;\n\n        fprintf(f, \"  sg_in_bytes=\");\n        for (size_t i = 0U; i < dump_len; ++i) {\n            /* Print in hex so that addresses/values can be inspected later. */\n            fprintf(f, \"%02x\", (unsigned)bytes[i]);\n            if (i + 1U < dump_len) {\n                fputc(' ', f);\n            }\n        }\n        fputc('\\n', f);\n    }\n\n    /* If an output SG pointer is present, emit its pointer value as well. */\n    if (sg_out != NULL) {\n        fprintf(f, \"  sg_out_first_entry_ptr=%p\\n\", (void *)sg_out);\n    }\n\n    fclose(f);\n}\n\n/* Original function with probes added before and after the real mapping\n * call. The function's logic and signature are preserved; the only\n * observable change is logging to /tmp/logs/313.txt. */\nstatic int metal_linux_dev_dma_map(struct metal_bus *bus,\n                                   struct metal_device *device,\n                                   uint32_t dir,\n                                   struct metal_sg *sg_in,\n                                   int nents_in,\n                                   struct metal_sg *sg_out)\n{\n    struct linux_device *ldev = to_linux_device(device);\n    struct linux_bus *lbus = to_linux_bus(bus);\n\n    /* Probe before invoking the driver mapping routine. */\n    if (ldev != NULL && ldev->ldrv != NULL) {\n        metal_log_sg_probe(\"entry\", lbus, ldev, dir, sg_in, nents_in, sg_out,\n                           (void *)ldev->ldrv->dev_dma_map);\n    } else {\n        metal_log_sg_probe(\"entry\", lbus, ldev, dir, sg_in, nents_in, sg_out, NULL);\n    }\n\n    /* Preserve original behavior: call the driver's dev_dma_map and return\n     * its result. */\n    int ret = ldev->ldrv->dev_dma_map(lbus, ldev, dir, sg_in, nents_in, sg_out);\n\n    /* Probe after the mapping call to capture post-call state. */\n    if (ldev != NULL && ldev->ldrv != NULL) {\n        metal_log_sg_probe(\"exit\", lbus, ldev, dir, sg_in, nents_in, sg_out,\n                           (void *)ldev->ldrv->dev_dma_map);\n    } else {\n        metal_log_sg_probe(\"exit\", lbus, ldev, dir, sg_in, nents_in, sg_out, NULL);\n    }\n\n    return ret;\n}\n"
}