{
  "user_message": "An agent A claimed that the following thread_main_handle_connection code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of thread_main_handle_connection.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The 'if (1)' conditional is a constant-true branch used only to introduce a scope for the local variable 'finished'. The evaluation of the if-condition (and the branch decision) is executed every time but has no effect on program behaviour \u2014 removing the if and leaving the block would not change semantics. This constitutes dead code under MISRA C 2023 Rule 2.2. Replace the 'if (1) { ... }' with a plain block '{ ... }' (or remove the redundant conditional) to eliminate the dead operation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nvoid MHD_thread_handle_ID_set_current_thread_ID_(void *);\nint MHD_itc_r_fd_(void *itc);\nint MHD_SYS_select_(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\nint MHD_socket_get_error_(void);\nbool MHD_SCKT_ERR_IS_EINTR_(int err);\nconst char *MHD_socket_strerr_(int err);\nvoid MHD_itc_clear_(void *itc);\nbool MHD_itc_activate_(void *itc, const char *msg);\nbool MHD_ITC_IS_VALID_(void *itc);\n\nstatic void\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  const bool use_poll = 0; /* HAVE_POLL undefined in this build */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  /* Log entry to help reproduce control flow for Rule 2.2 investigation. */\n  {\n    FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n    if (log)\n    {\n      fprintf (log, \"thread_main_handle_connection ENTER: con=%p daemon=%p state=%d shutdown=%d socket_fd=%d use_poll=%d\\n\",\n               (void *) con, (void *) daemon, (int) con->state, (int) daemon->shutdown, (int) con->socket_fd, (int) use_poll);\n      fclose (log);\n    }\n  }\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n\n    /* Log loop iteration start */\n    {\n      FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n      if (log)\n      {\n        fprintf (log, \"LOOP START: con=%p state=%d suspended=%d urh=%p was_suspended=%d event_loop_info=0x%08x connection_timeout_ms=%d\\n\",\n                 (void *) con, (int) con->state, (int) con->suspended, (void *) urh, (int) was_suspended, (unsigned) con->event_loop_info, (int) con->connection_timeout_ms);\n        fclose (log);\n      }\n    }\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"ENTER SUSPENDED BRANCH: con=%p\\n\", (void *) con);\n          fclose (log);\n        }\n      }\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n          break;\n        }\n      }\n      MHD_itc_clear_ (daemon->itc);\n\n      /* Log that we are continuing to wait for resume */\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"SUSPENDED WAIT COMPLETE: con=%p continue;\\n\", (void *) con);\n          fclose (log);\n        }\n      }\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"RESUMED FROM SUSPEND: con=%p\\n\", (void *) con);\n          fclose (log);\n        }\n      }\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n      );\n\n    {\n      FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n      if (log)\n      {\n        fprintf (log, \"TIMEOUT/IO CHECK: con=%p use_zero_timeout=%d event_loop_info=0x%08x tls_read_ready=%d\\n\",\n                 (void *) con, (int) use_zero_timeout, (unsigned) con->event_loop_info, (int) con->tls_read_ready);\n        fclose (log);\n      }\n    }\n\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      /* Log timeout values */\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          if (tvp)\n            fprintf (log, \"SELECT PREPARE: con=%p tv_sec=%ld tv_usec=%ld\\n\", (void *) con, (long) tv.tv_sec, (long) tv.tv_usec);\n          else\n            fprintf (log, \"SELECT PREPARE: con=%p tvp=NULL (blocking)\\n\", (void *) con);\n          fclose (log);\n        }\n      }\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n\n      if (err_state)\n      {\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n\n      /* Log result of select */\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"SELECT RETURN: con=%p num_ready=%d maxsock=%d FD_ISSET_socket_read=%d FD_ISSET_socket_write=%d FD_ISSET_socket_err=%d\\n\",\n                   (void *) con, num_ready, (int) maxsock,\n                   (int) FD_ISSET (con->socket_fd, &rs),\n                   (int) FD_ISSET (con->socket_fd, &ws),\n                   (int) FD_ISSET (con->socket_fd, &es));\n          fclose (log);\n        }\n      }\n\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n        break;\n      }\n\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n      {\n        /* Log call_handlers negative result */\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"call_handlers returned MHD_NO: con=%p - exiting loop\\n\", (void *) con);\n          fclose (log);\n        }\n        goto exit;\n      }\n    }\n\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished, notify application. */\n      if ( (NULL != daemon->notify_completed) && (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  0);\n      con->rq.client_aware = false;\n\n      /* Log upgrade path */\n      {\n        FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n        if (log)\n        {\n          fprintf (log, \"CONNECTION UPGRADE: con=%p - invoking thread_main_connection_upgrade\\n\", (void *) con);\n          fclose (log);\n        }\n      }\n\n      thread_main_connection_upgrade (con);\n\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      if (con->urh)\n        con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be moved immediately to cleanup list. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return;\n    }\n  }\n\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           0 :\n                           0);\n  MHD_connection_handle_idle (con);\nexit:\n  /* Log entry to exit/cleanup to capture state when leaving function */\n  {\n    FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n    if (log)\n    {\n      fprintf (log, \"EXIT LABEL: con=%p state=%d rp_response=%p socket_fd=%d daemon_itc_valid=%d\\n\",\n               (void *) con, (int) con->state, (void *) (con->rp.response), (int) con->socket_fd, (int) MHD_ITC_IS_VALID_ (daemon->itc));\n      fclose (log);\n    }\n  }\n\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n\n    {\n      FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n      if (log)\n      {\n        fprintf (log, \"DESTROYED RESPONSE: con=%p\\n\", (void *) con);\n        fclose (log);\n      }\n    }\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n\n    {\n      FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n      if (log)\n      {\n        fprintf (log, \"SHUT_WR on socket: con=%p socket_fd=%d\\n\", (void *) con, (int) con->socket_fd);\n        fclose (log);\n      }\n    }\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n    /* Ignored logging for brevity */\n  }\n\n  /* Final log before returning */\n  {\n    FILE *log = fopen(\"/tmp/logs/122.txt\", \"a\");\n    if (log)\n    {\n      fprintf (log, \"thread_main_handle_connection EXIT: con=%p final_state=%d\\n\", (void *) con, (int) con->state);\n      fclose (log);\n    }\n  }\n  return;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The scenario described by agent A (an if (1) used solely to introduce a scope for a local variable 'finished', whose evaluation is an executed no-op and therefore dead code) does not match the supplied target_code. A careful review of the provided thread_main_handle_connection implementation finds no if (1) or any other constant-true conditional that exists only to introduce a scope. All conditionals in the function depend on run-time state (daemon->shutdown, con->state, con->suspended, use_poll, con->event_loop_info, etc.) and are not constant expressions that could be removed without changing behaviour.\n\nBecause the reported pattern is absent, the report is not correct. (Additionally, the supplied test_code failed to compile so it provided no runtime evidence; even if an if (1) had been present, one would need to show the executed operation is removable without affecting behaviour to justify a Rule 2.2 violation.)"
}