{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_send4_",
    "gnutls_record_send",
    "MHD_DLOG",
    "struct MHD_Connection",
    "MHD_socket (typedef)",
    "SSIZE_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MSG_MORE / MHD_USE_MSG_MORE (compile-time)",
    "HTTPS_SUPPORT (compile-time)"
  ],
  "explanation": "For checking MISRA C rule about <string.h> functions (no out-of-bounds accesses) you must inspect any code that receives the buffer pointer/size or could itself call string.h routines. The following symbols are required and why:\n\n- pre_send_setopt\n  - Called before sending. Inspect its implementation to confirm it does not access the provided buffer pointer (or call memcpy/strlen/str* on unrelated buffers) or otherwise rely on buffer_size. Even if it does not accept the buffer as parameter, it might log or copy data indirectly.\n\n- post_send_setopt\n  - Called after a full send. Must be checked for any use of string functions or buffer-related operations that could exceed bounds.\n\n- MHD_send4_\n  - This is the plaintext send wrapper that receives (buffer, buffer_size). It is the primary callee that may perform copying/formatting. You must inspect its implementation to see whether it treats the buffer as a byte array (using length) or as a NUL-terminated string, or uses memcpy/strlen/str* in a way that could read/write out of bounds.\n\n- gnutls_record_send\n  - TLS-path send function called with (tls_session, buffer, buffer_size). Although it is an external library function, you must confirm its documented behavior: it should send exactly buffer_size bytes and not call string.h functions that assume NUL-termination. If the library source or prototype is available, inspect it for any unsafe string.h use that could read beyond buffer_size.\n\n- MHD_DLOG\n  - post_send_setopt calls MHD_DLOG (per the call graph). Logging helpers sometimes format strings or copy buffers; check it to ensure it doesn't call strlen/strcpy on data passed or otherwise access the buffer out-of-bounds.\n\n- struct MHD_Connection\n  - Full definition is required to verify fields used here (socket_fd, state, daemon->options, tls_session, epoll_state). In particular, tls_session value/type is needed to reason about gnutls_record_send usage; epoll_state and daemon->options influence code paths (TLS vs non-TLS). Also to ensure no implicit casts or container aliasing could cause hidden buffer accesses.\n\n- MHD_socket (typedef)\n  - Definition of the socket type and MHD_INVALID_SOCKET sentinel to ensure socket checks do not influence buffer handling and to confirm MHD_send4_ prototype signature.\n\n- SSIZE_MAX\n  - Used to clamp buffer_size to a maximum ssize_t return. You must confirm the numeric value and that truncation logic cannot cause downstream code to assume larger sizes (and thereby use string.h unsafely).\n\n- MHD_SCKT_SEND_MAX_SIZE_\n  - Send-size clamp for plaintext path. Its value determines the maximum length passed to MHD_send4_. Verify its definition to ensure correct truncation and to reason about whether callees may be passed sizes that exceed internal buffers or cause string functions to read too far.\n\n- MSG_MORE / MHD_USE_MSG_MORE (compile-time)\n  - Affects the flags passed to MHD_send4_. Some send wrappers vary behavior based on flags (e.g., using sendfile vs memcpy into internal buffers). The compile-time presence/absence can change which code path is compiled in MHD_send4_ or related helpers; include to ensure you analyze the actual code path.\n\n- HTTPS_SUPPORT (compile-time)\n  - Controls whether the TLS code (gnutls_record_send and TLS-related error handling) is compiled in. The presence/absence directs analysis to the TLS or non-TLS path, so include it to analyze the relevant callees.\n\nNotes:\n- The MISRA rule focuses on any use of standard string.h functions that could access beyond the provided object bounds. The target function itself does not call string.h functions directly, but it forwards buffer and buffer_size to other functions. Therefore the implementations/prototypes of those callees (MHD_send4_, gnutls_record_send, pre_send_setopt, post_send_setopt, and any logging helpers they call, e.g., MHD_DLOG) are essential to determine whether any string.h functions are invoked unsafely using buffer or buffer_size. \n- The numeric limits/macros (SSIZE_MAX, MHD_SCKT_SEND_MAX_SIZE_) and compile-time flags (MSG_MORE/MHD_USE_MSG_MORE, HTTPS_SUPPORT) are required to know the exact sizes and code paths used when those callees execute, which affects whether their internal string.h usage is safe."
}