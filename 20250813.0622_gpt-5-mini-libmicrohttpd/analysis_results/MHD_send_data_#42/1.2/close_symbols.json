{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ssize_t",
    "size_t",
    "bool",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "struct MHD_Connection",
    "struct MHD_Daemon",
    "daemon->options / MHD_USE_TLS",
    "SSIZE_MAX",
    "HTTPS_SUPPORT",
    "pre_send_setopt",
    "post_send_setopt",
    "gnutls_record_send",
    "GNUTLS_E_* (GNUTLS_E_AGAIN, GNUTLS_E_INTERRUPTED, GNUTLS_E_ENCRYPTION_FAILED, GNUTLS_E_INVALID_SESSION, GNUTLS_E_COMPRESSION_FAILED, GNUTLS_E_EXPIRED, GNUTLS_E_HASH_FAILED, GNUTLS_E_PUSH_ERROR, GNUTLS_E_INTERNAL_ERROR, GNUTLS_E_CRYPTODEV_IOCTL_ERROR, GNUTLS_E_CRYPTODEV_DEVICE_ERROR, GNUTLS_E_PREMATURE_TERMINATION, GNUTLS_E_UNEXPECTED_PACKET_LENGTH, GNUTLS_E_MEMORY_ERROR)",
    "connection->tls_session",
    "EPOLL_SUPPORT",
    "enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MHD_send4_",
    "MHD_USE_MSG_MORE / MSG_MORE",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_ / MHD_SCKT_EPIPE_ / MHD_SCKT_EOPNOTSUPP_ / MHD_SCKT_ENOTCONN_ / MHD_SCKT_EINVAL_ / MHD_SCKT_EBADF_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_ERR_* return codes (MHD_ERR_NOTCONN_, MHD_ERR_AGAIN_, MHD_ERR_TLS_, MHD_ERR_PIPE_, MHD_ERR_CONNRESET_, MHD_ERR_NOMEM_, MHD_ERR_OPNOTSUPP_, MHD_ERR_INVAL_, MHD_ERR_BADF_)",
    "connection->epoll_state"
  ],
  "explanation": "For checking violations of the MISRA rule prohibiting language extensions we must inspect the definitions (macros, typedefs, inline wrappers, attributes, platform shims) used by the function to ensure none of them use compiler-specific extensions (for example: __attribute__, __builtin_*, statement-expression ({ ... }), inline asm, typeof, nested functions, anonymous struct/union extensions, etc.). Each listed symbol is needed for that inspection:\n\n- ssize_t, size_t, bool\n  Need the typedefs/headers to verify these are standard types (C99/POSIX types) and not introduced via compiler-specific typedefs or non-standard headers.\n\n- MHD_socket, MHD_INVALID_SOCKET\n  MHD_socket is a typedef (platform socket type). Inspecting its definition and MHD_INVALID_SOCKET macro checks for platform-specific hacks or compiler extensions.\n\n- MHD_CONNECTION_CLOSED\n  Enumerator or macro used as a state; its definition must be checked for non-standard extension usage.\n\n- struct MHD_Connection, struct MHD_Daemon and fields (connection->daemon->options, connection->tls_session, connection->epoll_state)\n  The structure definitions must be examined to detect anonymous unions/structs, bit-field uses or other non-standard constructs that could be compiler extensions.\n\n- MHD_USE_TLS and HTTPS_SUPPORT\n  These conditional macros determine compile-time branches. Their definitions (or how they are provided via build flags) must be checked for compiler-specific means of provision.\n\n- SSIZE_MAX\n  Macro constant; verify it comes from standard headers and is not defined using an extension.\n\n- pre_send_setopt, post_send_setopt\n  These appear as functions or macros. If implemented as macros or inline functions they might use GCC extensions (statement-expressions, attributes). Need to see their definitions.\n\n- gnutls_record_send and GNUTLS_E_* constants\n  External library functions/macros may be declared with compiler-specific attributes or macros (e.g., visibility attributes, calling-convention pragmas). Inspect their headers for __attribute__ or other extensions.\n\n- EPOLL_SUPPORT, enum MHD_EpollState, MHD_EPOLL_STATE_WRITE_READY\n  Conditional compilation and enum definitions must be checked; enums or macros could use compiler extensions (explicit sized enums, attributes) or anonymous enums.\n\n- MHD_SCKT_SEND_MAX_SIZE_\n  Macro controlling truncation; inspect definition for extensions.\n\n- MHD_send4_\n  This wrapper may be a macro, inline function or use platform syscalls; its definition could contain compiler extensions (inline asm, builtins) and must be inspected.\n\n- MHD_USE_MSG_MORE / MSG_MORE\n  MSG_MORE is a socket flag from system headers; confirm it\u2019s the standard macro. MHD_USE_MSG_MORE is project macro controlling use; check its definition for extensions.\n\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_*, MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_EBADF_, MHD_SCKT_ERR_IS_LOW_RESOURCES_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_\n  These error-test helpers and constants are likely macros or inline functions. Their implementations must be inspected because macros can embed compiler extensions (statement-expressions, typeof) or use compiler builtins to access errno (e.g., __errno_location()).\n\n- MHD_ERR_* return codes (MHD_ERR_NOTCONN_, MHD_ERR_AGAIN_, MHD_ERR_TLS_, MHD_ERR_PIPE_, MHD_ERR_CONNRESET_, MHD_ERR_NOMEM_, MHD_ERR_OPNOTSUPP_, MHD_ERR_INVAL_, MHD_ERR_BADF_)\n  These are macros or enums used as return values. Their definitions should be checked for non-standard constructs.\n\n- connection->epoll_state manipulation\n  The code casts/uses (enum MHD_EpollState) and bitwise ops. The enum/bitfield definitions must be checked for any non-standard features (e.g., fixed underlying width using compiler extension).\n\nIn short: any macro, typedef, enum, inline function, or external API used by MHD_send_data_ must be inspected. The symbols above are the minimal set referenced directly by the function whose definitions could hide language/compiler extensions; the next agent should fetch their definitions (headers/source) and check for use of compiler-specific extensions (attributes, builtins, asm, statement-expressions, typeof, anonymous struct/union, nested functions, nonstandard pragmas, etc.)."
}