{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTPS_SUPPORT (preprocessor macro)",
    "MHD_USE_TLS (daemon option bitmask flag)",
    "struct MHD_Daemon::options (the options field accessed via connection->daemon)",
    "struct MHD_Connection (definition: members socket_fd, state, daemon, tls_session, epoll_state)",
    "MHD_INVALID_SOCKET (constant)",
    "MHD_CONNECTION_CLOSED (constant/state value)",
    "GNUTLS_E_PREMATURE_TERMINATION (macro)",
    "GNUTLS_E_UNEXPECTED_PACKET_LENGTH (macro)",
    "EPOLL_SUPPORT (preprocessor macro)",
    "MHD_USE_MSG_MORE (preprocessor macro) and MSG_MORE (socket flag)",
    "SSIZE_MAX (constant)",
    "MHD_SCKT_SEND_MAX_SIZE_ (macro)",
    "gnutls_record_send return codes referenced (GNUTLS_E_AGAIN, GNUTLS_E_INTERRUPTED, GNUTLS_E_* listed in TLS error checks)",
    "MHD_send4_ / MHD_socket_get_error_ and the socket-error predicates and codes (MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_ (..), MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_ERR_IS_LOW_RESOURCES_, MHD_SCKT_EBADF_)",
    "enum MHD_EpollState and MHD_EPOLL_STATE_WRITE_READY"
  ],
  "explanation": "To decide if any portion of MHD_send_data_ is truly unreachable (violating MISRA's rule forbidding unreachable code) we must know which code is compiled and which conditional branches can ever evaluate to true at compile- or run-time. The items above are required for that analysis for these reasons:\n\n- HTTPS_SUPPORT (preprocessor macro): controls compilation of the entire TLS-related region and the initialization of tls_conn. If HTTPS_SUPPORT is undefined the TLS branch may be compile-time dead (tls_conn set to false). Determining whether TLS code is present/absent is primary to finding compile-time unreachable source lines.\n\n- MHD_USE_TLS and struct MHD_Daemon::options: when HTTPS_SUPPORT is defined tls_conn is derived from (connection->daemon->options & MHD_USE_TLS). You need the MHD_USE_TLS flag value and the daemon->options member semantics to know whether tls_conn can ever be true at runtime (so the if (tls_conn) branch may be reachable).\n\n- struct MHD_Connection and the listed members: the code reads connection->socket_fd, connection->state, connection->daemon, connection->tls_session, and connection->epoll_state. Their types/definitions are necessary to judge whether certain comparisons/assignments are constant or can vary at runtime (affecting reachability of early returns and later blocks).\n\n- MHD_INVALID_SOCKET and MHD_CONNECTION_CLOSED: these constants are used in the early return condition. Knowing their definitions is necessary to see whether that early return can be statically determined true or false (which would make subsequent code unreachable).\n\n- GNUTLS_E_PREMATURE_TERMINATION and GNUTLS_E_UNEXPECTED_PACKET_LENGTH: these macros select mutually exclusive error checks via #if/#elif inside the TLS error handling. Knowing which of these is defined decides whether the associated return path is present in the compiled source (affects unreachable-source detection).\n\n- EPOLL_SUPPORT: controls compilation of blocks that clear EPOLL_STATE_WRITE_READY in both TLS and non-TLS paths. Presence/absence changes which statements exist and whether neighboring code can be unreachable.\n\n- MHD_USE_MSG_MORE and MSG_MORE: affect which MHD_send4_ invocation is compiled (different arguments). This is a compile-time conditional that can make one call form unreachable in source when the other is selected.\n\n- SSIZE_MAX and MHD_SCKT_SEND_MAX_SIZE_: these limits are used to truncate buffer_size and flip push_data; constant values may make some branches (the truncation branches) impossible to reach in some build configurations or with known limits \u2014 include them so the analyzer can decide if those checks are dead.\n\n- gnutls_record_send return codes referenced (GNUTLS_E_AGAIN, GNUTLS_E_INTERRUPTED, GNUTLS_E_ENCRYPTION_FAILED, GNUTLS_E_INVALID_SESSION, GNUTLS_E_COMPRESSION_FAILED, GNUTLS_E_EXPIRED, GNUTLS_E_HASH_FAILED, GNUTLS_E_PUSH_ERROR, GNUTLS_E_INTERNAL_ERROR, GNUTLS_E_CRYPTODEV_IOCTL_ERROR, GNUTLS_E_CRYPTODEV_DEVICE_ERROR, GNUTLS_E_MEMORY_ERROR, etc.): the TLS branch contains many if (ret == GNUTLS_...) tests. To decide if any of those branches are unreachable you must know the possible return values and whether some of those constants are defined or applicable in the compiled GnuTLS version.\n\n- MHD_send4_, MHD_socket_get_error_, the MHD_SCKT_ERR_IS_* predicates and the specific MHD_SCKT_* error codes referenced: the non-TLS branch checks many socket-error predicates after a negative return. To decide whether some of those individual error-handling branches are impossible (and therefore unreachable) you need the semantics/definitions of these predicates and codes (and whether MHD_send4_ can return values that make those predicates true).\n\n- enum MHD_EpollState and MHD_EPOLL_STATE_WRITE_READY: used in bitwise clears of connection->epoll_state; knowing the enum/constant definitions is needed to determine whether those statements are meaningful or syntactically compiled (and whether surrounding code could be considered unreachable).\n\nIn short: include the listed compile-time macros, the daemon/connection option/field definitions, and the referenced GNUTLS/socket error codes/predicates so an analyzer can determine which source regions are never compiled or can never be reached at runtime (the two forms of unreachable code relevant to MISRA C)."
}