{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strcmp(method, MHD_HTTP_METHOD_GET) and strcmp(version, MHD_HTTP_VERSION_1_1) without validating that method and version are non-NULL and point to NUL-terminated buffers. If either pointer is NULL (or not a valid NUL-terminated string), strcmp will dereference/access out-of-bounds memory, violating MISRA C 2023 Rule 21.17. Example: if the caller passes method == NULL, the first strcmp will access beyond the object referenced by the pointer parameter and cause undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  /* Probe logging: capture entry state. Use only pointer/null checks to avoid\n     invoking undefined behaviour if any string pointers are NULL or\n     non-NUL-terminated. Logs go to /tmp/logs/495.txt. */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb ENTRY: cls=%p con=%p url=%p method=%p version=%p upload_data=%p upload_data_size=%p req_cls=%p\\n\",\n              cls, con, url, (const void *) method, (const void *) version,\n              (const void *) upload_data, (const void *) upload_data_size,\n              (const void *) req_cls);\n      if (req_cls != NULL)\n      {\n        fprintf(fp, \"  *req_cls (before) = %p\\n\", *req_cls);\n      }\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    /* Log branch taken for initial request-class */\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: initial *req_cls == NULL -> set to 1 and return MHD_YES\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n\n  /* Log header pointer statuses */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: upg_header=%p con_header=%p\\n\",\n              (const void *) upg_header, (const void *) con_header);\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    /* Log that request is not a websocket request and the chosen action */\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: is_websocket_request == MHD_NO -> send_chat_page\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return send_chat_page (con);\n  }\n\n  /* Before calling strcmp on method/version, log their pointer values and\n     whether they are NULL. Do NOT attempt to print their contents here to\n     avoid dereferencing possibly non-terminated buffers. This allows\n     reproducing the violation scenario where method or version is NULL. */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: About to check method/version with strcmp: method=%p (%s), version=%p (%s)\\n\",\n              (const void *) method, (method == NULL) ? \"NULL\" : \"non-NULL\",\n              (const void *) version, (version == NULL) ? \"NULL\" : \"non-NULL\");\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    /* Log that bad request is returned due to method/version mismatch. Note:\n       if method or version is NULL, the strcmp above will cause the\n       undefined behaviour reported by the other agent; we logged the NULL\n       pointer status above so the evidence is available in /tmp/logs/495.txt. */\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: strcmp check failed -> send_bad_request\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return send_bad_request (con);\n  }\n\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n\n  /* Log ws_version_header pointer and null-ness */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: ws_version_header=%p\\n\", (const void *) ws_version_header);\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: websocket version missing or mismatch -> send_upgrade_required\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return send_upgrade_required (con);\n  }\n\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n\n  /* Log the result and values from lookup of websocket key header */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: MHD_lookup_connection_value_n ret=%d ws_key_header=%p key_size=%zu\\n\",\n              (int) ret, (const void *) ws_key_header, key_size);\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: websocket key missing or wrong size -> send_bad_request\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return send_bad_request (con);\n  }\n\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n\n  /* Log ws_get_accept_value outcome and pointer */\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: ws_get_accept_value ret=%d ws_ac_value=%p\\n\", (int) ret, (void *) ws_ac_value);\n      fflush(fp);\n      fclose(fp);\n    }\n  }\n\n  if (MHD_NO == ret)\n  {\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: ws_get_accept_value returned MHD_NO -> returning ret\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return ret;\n  }\n\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: failed to add Sec-WebSocket-Accept header -> MHD_NO\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n\n    FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n    if (fp)\n    {\n      fprintf(fp, \"ahc_cb: failed to add Upgrade header -> MHD_NO\\n\");\n      fflush(fp);\n      fclose(fp);\n    }\n\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n\n  FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n  if (fp)\n  {\n    fprintf(fp, \"ahc_cb: queuing response -> ret=%d\\n\", (int) ret);\n    fflush(fp);\n    fclose(fp);\n  }\n\n  MHD_destroy_response (res);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_cb. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 21.17 forbids using the <string.h> routines in a way that can access beyond the bounds of the objects referenced by their pointer parameters. The agent\u2019s scenario is only a problem if the pointers passed to strcmp (method and version) can be NULL or not NUL\u2011terminated. In this code these parameters are the HTTP method and version provided by libmicrohttpd via the access handler callback. The libmicrohttpd API supplies method and version as NUL\u2011terminated strings (i.e. valid, non\u2011NULL C strings) so calling strcmp on them does not, in normal operation, cause out\u2011of\u2011bounds accesses and therefore does not violate 21.17. If you cannot rely on the caller/API contract, then the concern is valid and defensive NULL/NUL checks should be added; but given the documented MHD callback contract the reported violation is not correct."
}