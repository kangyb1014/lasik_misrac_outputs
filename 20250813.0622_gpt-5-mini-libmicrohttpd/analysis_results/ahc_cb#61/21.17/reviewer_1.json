{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The expression (NULL == key) ? 0 : strlen(key) calls strlen on key whenever key != NULL. If a caller supplies a pointer to a character buffer that is not NUL-terminated (for example a header name stored in a fixed-length array or a slice of a network buffer that lacks a terminating '\\0'), strlen will scan past the end of the object and cause an out-of-bounds access. Thus this use of strlen can lead to accesses beyond the bounds of the object referenced by its pointer parameter.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_printf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  if (NULL == f)\n    return;\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] \", (long)t);\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void log_hex_sample(const char *label, const void *buf, size_t len)\n{\n  if (buf == NULL)\n  {\n    log_printf(\"%s: buf=NULL, len=%zu\", label, len);\n    return;\n  }\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  if (NULL == f)\n    return;\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] %s: addr=%p len=%zu data=\", (long)t, label, buf, len);\n  const unsigned char *b = (const unsigned char *) buf;\n  size_t max = len < 64 ? len : 64; /* limit amount logged */\n  for (size_t i = 0; i < max; ++i)\n    fprintf(f, \"%02x\", b[i]);\n  if (len > max)\n    fprintf(f, \"...\");\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void log_check_nul_within(const char *label, const void *buf, size_t len)\n{\n  if (buf == NULL)\n  {\n    log_printf(\"%s: buf=NULL (no data to scan)\", label);\n    return;\n  }\n  const unsigned char *b = (const unsigned char *) buf;\n  size_t found = 0;\n  for (size_t i = 0; i < len; ++i)\n  {\n    if (b[i] == 0)\n    {\n      found = i + 1; /* position of first NUL within bounds */\n      break;\n    }\n  }\n  if (found)\n    log_printf(\"%s: NUL found within length at position %zu (within %zu bytes)\", label, found - 1, len);\n  else\n    log_printf(\"%s: no NUL within first %zu bytes\", label, len);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and some pointer state (avoid printing arbitrary strings\n     unsafely; we log pointer values and later safe byte samples). */\n  log_printf(\"ahc_cb entry: con=%p method=%p version=%p req_cls=%p *req_cls=%p\",\n             (void *)con, (void *)method, (void *)version, (void *)req_cls,\n             (void *)(req_cls ? *req_cls : NULL));\n\n  if (NULL == *req_cls)\n  {\n    log_printf(\"ahc_cb: initial request phase, setting req_cls to marker and returning MHD_YES\");\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n\n  log_printf(\"ahc_cb: upgrade header ptr=%p connection header ptr=%p\",\n             (void *)upg_header, (void *)con_header);\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_printf(\"ahc_cb: not a websocket request, sending chat page\");\n    return send_chat_page (con);\n  }\n\n  /* Method/version checks. Log decision points without duplicating logic. */\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_printf(\"ahc_cb: method/version mismatch: method=%p version=%p -> bad request\",\n               (void *)method, (void *)version);\n    return send_bad_request (con);\n  }\n\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  log_printf(\"ahc_cb: ws_version_header ptr=%p\", (void *)ws_version_header);\n\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_printf(\"ahc_cb: websocket version missing or mismatched -> upgrade required\");\n    return send_upgrade_required (con);\n  }\n\n  /* Log the header name length used in the lookup. This strlen is on a\n     compile-time constant (the header name macro), so it is safe. */\n  size_t header_name_len = strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY);\n  log_printf(\"ahc_cb: looking up header '%s' length=%zu (safe, constant)\",\n             MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY, header_name_len);\n\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       header_name_len,\n                                       &ws_key_header, &key_size);\n\n  log_printf(\"ahc_cb: MHD_lookup_connection_value_n returned %d ws_key_header=%p key_size=%zu\",\n             (int)ret, (void *)ws_key_header, key_size);\n\n  /* Safely log a hex sample of the header value within the bounds that the\n     API returned (key_size). We do not attempt to access bytes beyond\n     key_size. This helps diagnose cases where the header is not NUL-terminated\n     and a future strlen on the pointer would scan out of bounds. */\n  if (ws_key_header != NULL)\n  {\n    log_hex_sample(\"ws_key_header (sample)\", ws_key_header, key_size);\n    log_check_nul_within(\"ws_key_header (NUL check within bounds)\", ws_key_header, key_size);\n  }\n\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    log_printf(\"ahc_cb: bad websocket key: ret=%d key_size=%zu expected=%d -> bad request\",\n               (int)ret, key_size, (int)WS_KEY_LEN);\n    return send_bad_request (con);\n  }\n\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  log_printf(\"ahc_cb: ws_get_accept_value returned %d ws_ac_value=%p\", (int)ret, (void *)ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    log_printf(\"ahc_cb: failed to add Sec-WebSocket-Accept header, cleaning up\");\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    log_printf(\"ahc_cb: failed to add Upgrade header, cleaning up\");\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  log_printf(\"ahc_cb: finishing, returning %d\", (int)ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_cb. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The only explicit call to strlen in the shown ahc_cb is strlen(MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY) where the argument is a compile\u2011time constant string (a header-name macro). That use cannot scan past a caller-provided buffer. The other string.h uses in the function are strcmp on method, version and ws_version_header; those pointers come from the HTTP API (library-supplied strings) and ws_version_header is compared to a string literal. The code does not call strlen on a caller-supplied header value (ws_key_header) \u2014 the lookup returns ws_key_header plus an explicit key_size and the code uses key_size to bound logging and validation. Therefore there is no strlen usage that can obviously scan beyond the bounds of the object referenced by its pointer parameter in the shown code. (If ws_get_accept_value internally requires a NUL-terminated input, that would be a separate API contract to check, but it is not a strlen-on-unknown-buffer in ahc_cb itself.)"
}