{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'connection' is declared as 'struct MHD_Connection *connection' but the function does not modify the object (it only passes it to MHD_lookup_connection_value_n and uses it read-only). Therefore 'connection' could be 'const struct MHD_Connection *connection'. The non-const pointer parameter violates Rule 8.13 (a pointer should point to a const-qualified type whenever possible).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/491.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry point and initial state */\n  probe_log(\"ahc_cb ENTRY: con=%p, method=%p('%s'), version=%p('%s'), req_cls=%p, *req_cls=%p\",\n            (void *) con,\n            (const void *) method, (method ? method : \"(null)\"),\n            (const void *) version, (version ? version : \"(null)\"),\n            (void *) req_cls,\n            (void *) ((req_cls) ? *req_cls : NULL));\n\n  if (NULL == *req_cls)\n  {\n    probe_log(\"ahc_cb: first call for request, setting *req_cls and returning MHD_YES: con=%p\", (void *) con);\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  probe_log(\"ahc_cb: second call for request, clearing *req_cls and continuing: con=%p\", (void *) con);\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  probe_log(\"ahc_cb: MHD_HTTP_HEADER_UPGRADE -> upg_header=%p('%s')\", (const void *) upg_header, (upg_header ? upg_header : \"(null)\"));\n\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  probe_log(\"ahc_cb: MHD_HTTP_HEADER_CONNECTION -> con_header=%p('%s')\", (const void *) con_header, (con_header ? con_header : \"(null)\"));\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    probe_log(\"ahc_cb: not a websocket request (is_websocket_request == MHD_NO), calling send_chat_page: con=%p\", (void *) con);\n    return send_chat_page (con);\n  }\n  probe_log(\"ahc_cb: is_websocket_request == MHD_YES, proceeding with websocket handshake: con=%p\", (void *) con);\n\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    probe_log(\"ahc_cb: method/version check failed: method='%s', version='%s', calling send_bad_request: con=%p\",\n              (method ? method : \"(null)\"), (version ? version : \"(null)\"), (void *) con);\n    return send_bad_request (con);\n  }\n  probe_log(\"ahc_cb: method/version OK: method='%s', version='%s'\", (method ? method : \"(null)\"), (version ? version : \"(null)\"));\n\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  probe_log(\"ahc_cb: MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION -> ws_version_header=%p('%s')\",\n            (const void *) ws_version_header, (ws_version_header ? ws_version_header : \"(null)\"));\n\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    probe_log(\"ahc_cb: websocket version missing or mismatched (required='%s'), calling send_upgrade_required: con=%p\",\n              WS_SEC_WEBSOCKET_VERSION, (void *) con);\n    return send_upgrade_required (con);\n  }\n  probe_log(\"ahc_cb: websocket version OK: %s\", ws_version_header);\n\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  probe_log(\"ahc_cb: MHD_lookup_connection_value_n returned %d, ws_key_header=%p, key_size=%zu\",\n            (int) ret, (const void *) ws_key_header, key_size);\n\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    probe_log(\"ahc_cb: websocket key missing or wrong size (expected %d), calling send_bad_request: con=%p\",\n              WS_KEY_LEN, (void *) con);\n    return send_bad_request (con);\n  }\n\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  probe_log(\"ahc_cb: ws_get_accept_value returned %d, ws_ac_value=%p\", (int) ret, (void *) ws_ac_value);\n\n  if (MHD_NO == ret)\n  {\n    probe_log(\"ahc_cb: ws_get_accept_value failed, returning ret=%d: con=%p\", (int) ret, (void *) con);\n    return ret;\n  }\n\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  probe_log(\"ahc_cb: created upgrade response res=%p\", (void *) res);\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    probe_log(\"ahc_cb: failed to add Sec-WebSocket-Accept header, cleaning up and returning MHD_NO: con=%p\", (void *) con);\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  probe_log(\"ahc_cb: added Sec-WebSocket-Accept header with value at %p\", (void *) ws_ac_value);\n\n  free (ws_ac_value);\n  probe_log(\"ahc_cb: freed ws_ac_value and continuing\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    probe_log(\"ahc_cb: failed to add Upgrade header, destroying response and returning MHD_NO: con=%p\", (void *) con);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  probe_log(\"ahc_cb: added Upgrade header ('%s')\", WS_UPGRADE_VALUE);\n\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  probe_log(\"ahc_cb: MHD_queue_response returned %d, about to destroy response and return: con=%p\", (int) ret, (void *) con);\n\n  MHD_destroy_response (res);\n  probe_log(\"ahc_cb EXIT: returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_cb. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 8.13 recommends const-qualifying pointers when the pointed-to object is not modified, but you cannot blindly make a parameter const when it is passed to other APIs that take a non-const pointer (or that may modify the connection). In ahc_cb the 'con' parameter is passed to many libmicrohttpd functions (MHD_lookup_connection_value[_n], is_websocket_request, MHD_create_response_for_upgrade, MHD_add_response_header, MHD_queue_response, etc.) which have non-const prototypes and may modify internal connection state. Changing the parameter to 'const struct MHD_Connection *' would either require changes to those API prototypes or casts that defeat the intent of the rule. Thus, given the use of 'con' with external APIs that expect a non-const pointer, this does not constitute a MISRA 8.13 violation in this code."
}