{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function increments the pointer parameters str1 and str2 (str1++ and str2++ inside the loop), which modifies the pointer parameters themselves. This violates MISRA C 2023 Rule 17.8 (the pointer object referred to may be modified, but the pointer parameter shall not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *event,\n                          struct MHD_Response *response,\n                          const char *header,\n                          const char *content,\n                          const void *addr_header_var,\n                          const void *addr_content_var)\n{\n  FILE *f = fopen(\"/tmp/logs/53.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf(f, \"EVENT: %s\\n\", event ?: \"(null)\");\n  fprintf(f, \"  header_ptr=%p header_addr_on_stack=%p header_str=%s\\n\",\n          (const void *)header,\n          addr_header_var,\n          header ? header : \"(null)\");\n  fprintf(f, \"  content_ptr=%p content_addr_on_stack=%p content_str=%s\\n\",\n          (const void *)content,\n          addr_content_var,\n          content ? content : \"(null)\");\n  if (response)\n  {\n    fprintf(f, \"  response_ptr=%p flags_auto=0x%lx flags=0x%lx\\n\",\n            (void *)response,\n            (unsigned long)response->flags_auto,\n            (unsigned long)response->flags);\n  }\n  else\n  {\n    fprintf(f, \"  response_ptr=(null)\\n\");\n  }\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  /* Log entry and initial parameter state (addresses of the parameter\n     variables are captured to help detect unexpected pointer modification) */\n  mhd_log_probe(\"ENTRY\",\n                response,\n                header,\n                content,\n                (const void *)&header,\n                (const void *)&content);\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    mhd_log_probe(\"BRANCH: CONNECTION\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    enum MHD_Result res = add_response_header_connection (response, content);\n    mhd_log_probe(\"RETURN from CONNECTION branch\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    return res;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    mhd_log_probe(\"BRANCH: TRANSFER_ENCODING (enter)\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      mhd_log_probe(\"RETURN: TRANSFER_ENCODING not chunked\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      mhd_log_probe(\"RETURN: already has chunked flag\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      mhd_log_probe(\"RETURN: has content-length and no insanity flag\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n\n    /* Call add_response_entry once and capture its result for logging */\n    {\n      enum MHD_Result tmp_res = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n      mhd_log_probe(\"AFTER add_response_entry (TRANSFER_ENCODING)\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      if (MHD_NO != tmp_res)\n      {\n        response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n        mhd_log_probe(\"RETURN: TRANSFER_ENCODING added (YES)\",\n                      response,\n                      header,\n                      content,\n                      (const void *)&header,\n                      (const void *)&content);\n        return MHD_YES;\n      }\n      mhd_log_probe(\"RETURN: TRANSFER_ENCODING add failed (NO)\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      return MHD_NO;\n    }\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    mhd_log_probe(\"BRANCH: DATE (enter)\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_log_probe(\"DATE: found existing header\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n\n    {\n      enum MHD_Result tmp_res = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n      mhd_log_probe(\"AFTER add_response_entry (DATE)\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      if (MHD_NO != tmp_res)\n      {\n        response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n        mhd_log_probe(\"RETURN: DATE added (YES)\",\n                      response,\n                      header,\n                      content,\n                      (const void *)&header,\n                      (const void *)&content);\n        return MHD_YES;\n      }\n      mhd_log_probe(\"RETURN: DATE add failed (NO)\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      return MHD_NO;\n    }\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    mhd_log_probe(\"BRANCH: CONTENT_LENGTH (enter)\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      enum MHD_Result tmp_res = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n      mhd_log_probe(\"AFTER add_response_entry (CONTENT_LENGTH)\",\n                    response,\n                    header,\n                    content,\n                    (const void *)&header,\n                    (const void *)&content);\n      if (MHD_NO != tmp_res)\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        mhd_log_probe(\"RETURN: CONTENT_LENGTH added (YES)\",\n                      response,\n                      header,\n                      content,\n                      (const void *)&header,\n                      (const void *)&content);\n        return MHD_YES;\n      }\n    }\n    mhd_log_probe(\"RETURN: CONTENT_LENGTH branch exit (NO)\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    return MHD_NO;\n  }\n\n  mhd_log_probe(\"FALLTHROUGH: generic add_response_entry\",\n                response,\n                header,\n                content,\n                (const void *)&header,\n                (const void *)&content);\n\n  /* Final generic path: call add_response_entry and return its result. */\n  {\n    enum MHD_Result tmp_res = add_response_entry (response,\n                                                  MHD_HEADER_KIND,\n                                                  header,\n                                                  content);\n    mhd_log_probe(\"AFTER add_response_entry (generic)\",\n                  response,\n                  header,\n                  content,\n                  (const void *)&header,\n                  (const void *)&content);\n    return tmp_res;\n  }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0b0 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a1\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: FALLTHROUGH: generic add_response_entry\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0b0 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a1\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: AFTER add_response_entry (generic)\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0b0 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a1\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0de content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a2\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: FALLTHROUGH: generic add_response_entry\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0de content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a2\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: AFTER add_response_entry (generic)\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab0de content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a2\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab118 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a3\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: FALLTHROUGH: generic add_response_entry\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab118 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a3\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: AFTER add_response_entry (generic)\n  header_ptr=0x55b23b7ab0b9 header_addr_on_stack=0x7ffd62c8b100 header_str=Header-Type-A\n  content_ptr=0x55b23b7ab118 content_addr_on_stack=0x7ffd62c8b0f8 content_str=value-a3\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab18c content_addr_on_stack=0x7ffd62c8b0f8 content_str=a,b,c,d,e\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: BRANCH: CONNECTION\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab18c content_addr_on_stack=0x7ffd62c8b0f8 content_str=a,b,c,d,e\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: RETURN from CONNECTION branch\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab18c content_addr_on_stack=0x7ffd62c8b0f8 content_str=a,b,c,d,e\n  response_ptr=0x55b2715b02a0 flags_auto=0x1 flags=0x0\n----\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab22f content_addr_on_stack=0x7ffd62c8b0f8 content_str=i,k,l,m,n,o,p,close\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: BRANCH: CONNECTION\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab22f content_addr_on_stack=0x7ffd62c8b0f8 content_str=i,k,l,m,n,o,p,close\n  response_ptr=0x55b2715b02a0 flags_auto=0x0 flags=0x0\n----\nEVENT: RETURN from CONNECTION branch\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 header_str=Connection\n  content_ptr=0x55b23b7ab22f content_addr_on_stack=0x7ffd62c8b0f8 content_str=i,k,l,m,n,o,p,close\n  response_ptr=0x55b2715b02a0 flags_auto=0x3 flags=0x0\n----\nEVENT: ENTRY\n  header_ptr=0x55b23b7ab196 header_addr_on_stack=0x7ffd62c8b100 hea\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 17.8 forbids modifying the pointer parameter itself (e.g. doing header++ or content++). The reviewed MHD_add_response_header implementation contains no assignments or increments to the parameter variables header or content. The supplied instrumentation logs both the pointer values (header_ptr/content_ptr) and the addresses of the parameter variables on the stack. In every single function invocation shown, the pointer values passed in remain the same across ENTRY \u2192 branch \u2192 after-call \u2192 RETURN events; the stack addresses are also constant (as expected). The only changes of pointer values visible in the log occur between distinct calls (different invocations receive different argument pointers), not within a single invocation. Therefore the function does not modify its pointer parameters and does not violate Rule 17.8. Agent A\u2019s claim is incorrect."
}