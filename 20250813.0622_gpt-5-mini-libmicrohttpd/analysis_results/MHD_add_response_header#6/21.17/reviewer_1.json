{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When MHD_add_response_header is called with header equal to MHD_HTTP_HEADER_CONNECTION and content is NULL or not NUL-terminated, add_response_header_connection invokes strlen(value) (and earlier strchr(value,...)) without checking for NULL or ensuring termination. This can read beyond the bounds of the object referenced by value (e.g. content == NULL or missing terminating '\\0'), violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fflush(f);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  /* Log entry with pointers to help reproduce cases where content is NULL\n     or otherwise suspicious. Do NOT dereference 'content' here to avoid\n     introducing any new undefined behaviour. */\n  mhd_log_probe(\"MHD_add_response_header ENTRY: response=%p header=%p content=%p\\n\",\n                (void *)response, (const void *)header, (const void *)content);\n\n  /* Check \"Connection\" header path first (preserve original logic). */\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION)) {\n    mhd_log_probe(\"MHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\\n\");\n    if (NULL == content)\n      mhd_log_probe(\"MHD_add_response_header: content == NULL -> will call add_response_header_connection with NULL value\\n\");\n    else\n      mhd_log_probe(\"MHD_add_response_header: content != NULL -> content pointer=%p (not dereferenced here)\\n\",\n                    (const void *)content);\n\n    enum MHD_Result res = add_response_header_connection (response, content);\n    mhd_log_probe(\"MHD_add_response_header: add_response_header_connection returned %d\\n\", (int)res);\n    return res;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    mhd_log_probe(\"MHD_add_response_header: header matches TRANSFER-ENCODING; content=%p\\n\",\n                  (const void *)content);\n    if (! MHD_str_equal_caseless_ (content, \"chunked\")) {\n      mhd_log_probe(\"MHD_add_response_header: TRANSFER-ENCODING content is not 'chunked' -> return MHD_NO\\n\");\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    mhd_log_probe(\"MHD_add_response_header: header matches DATE; content=%p\\n\",\n                  (const void *)content);\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    mhd_log_probe(\"MHD_add_response_header: header matches CONTENT-LENGTH; content=%p\\n\",\n                  (const void *)content);\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  mhd_log_probe(\"MHD_add_response_header: falling through to add_response_entry; header=%p content=%p\\n\",\n                (const void *)header, (const void *)content);\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c0b9 content=0x56362d66c0b0\nMHD_add_response_header: falling through to add_response_entry; header=0x56362d66c0b9 content=0x56362d66c0b0\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c0b9 content=0x56362d66c0de\nMHD_add_response_header: falling through to add_response_entry; header=0x56362d66c0b9 content=0x56362d66c0de\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c0b9 content=0x56362d66c118\nMHD_add_response_header: falling through to add_response_entry; header=0x56362d66c0b9 content=0x56362d66c118\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c18c\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c18c (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c22f\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c22f (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c2eb\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c2eb (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c31a\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c31a (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c3f1\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c3f1 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c4b3\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c4b3 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c4b3\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c4b3 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c4b3\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c4b3 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c4b3\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c4b3 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c649\nMHD_add_response_header: header matches MHD_HTTP_HEADER_CONNECTION\nMHD_add_response_header: content != NULL -> content pointer=0x56362d66c649 (not dereferenced here)\nMHD_add_response_header: add_response_header_connection returned 1\nMHD_add_response_header ENTRY: response=0x5636507912a0 header=0x56362d66c196 content=0x56362d66c66e\nMHD_add_response_header: header matches\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the provided code and logs. MHD_add_response_header itself does not call any of the <string.h> functions (strlen/strchr/etc.); it only calls helper functions such as add_response_header_connection and MHD_str_equal_caseless_. MISRA C:2023 Rule 21.17 concerns the use of the Standard Library string functions where those functions can access beyond object bounds. Any violation would occur at the site where strlen/strchr are actually invoked (e.g. inside add_response_header_connection), not in MHD_add_response_header unless that function itself used those string functions or otherwise dereferenced/relied on an invalid pointer. The supplied runtime logs show that, in the tested cases, content pointers passed to the connection-handling branch were non-NULL and MHD_add_response_header did not dereference them. Therefore the claim that MHD_add_response_header violates Rule 21.17 is not correct; a potential violation would need to be demonstrated in the implementation of add_response_header_connection (which is not shown)."
}