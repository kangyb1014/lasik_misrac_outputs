{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The code calls memcmp(hdr->value, \"close\", 5) without verifying that hdr->value actually points to at least 5 bytes. If hdr->value is shorter than 5 bytes (for example a header value of \"clo\" or any 0..4 length), memcmp will read past the object\u2019s bounds and cause undefined behaviour. Although the code relies on an invariant (the MHD_RAF_HAS_CONNECTION_CLOSE flag should only be set when a \"close\" token was present in a previously validated/created value), this invariant is not enforced at the point of the call (no check of hdr->value_size >= 5), so the memcmp can potentially access out-of-bounds memory and thus violates MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_add_response_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/55.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_add_response_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_add_response_header:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\nPlease provide the modified MHD_add_response_header code.\n",
  "test_code": "static void mhd_probe_log_conn(struct MHD_Response *response,\n                                    const char *header,\n                                    const char *content)\n{\n  FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Log basic call information */\n  fprintf(f, \"MHD_add_response_header: response=%p header=\\\"%s\\\" content=\\\"%s\\\" flags_auto=0x%08x\\n\",\n          (void *) response,\n          (NULL != header) ? header : \"(null)\",\n          (NULL != content) ? content : \"(null)\",\n          (unsigned) response->flags_auto);\n\n  /* If this is the Connection header, try to find the existing header entry\n   * and log its stored value pointer and size (if present). This helps to\n   * reproduce cases where an existing header value is shorter than expected\n   * and may lead to out-of-bounds reads elsewhere. */\n  if (NULL != header && MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    struct MHD_HTTP_Res_Header *hdr;\n\n    hdr = MHD_get_response_element_n_(response,\n                                      MHD_HEADER_KIND,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION));\n\n    fprintf(f, \"  existing Connection header element: hdr=%p\\n\",\n            (void *) hdr);\n\n    if (NULL != hdr)\n    {\n      /* Log pointers and (if available) value size. value_size is used in\n       * other places of the code base to validate buffer sizes; logging it\n       * helps to confirm whether a subsequent memcmp() could read beyond the\n       * stored value. */\n      fprintf(f, \"    hdr->header=%p hdr->value=%p\\n\",\n              (void *) hdr->header,\n              (void *) hdr->value);\n\n      /* Attempt to print value_size if the struct provides it. Many parts of\n       * the codebase refer to hdr->value_size; if present this will help\n       * determine the length that was allocated/stored for the header value. */\n      /* Use a volatile pointer access to avoid optimizer removing the read. */\n      /* Note: This projection assumes the struct has member value_size of\n       * type size_t as used elsewhere in the project; if not present, this\n       * code will fail to compile in that build (which is acceptable because\n       * it indicates a different code layout). */\n      {\n        /* Cast through void* to avoid warnings if the member is present. */\n        size_t vlen = 0u;\n        /* Try to read hdr->value_size in a guarded fashion. */\n        /* Suppress unused-result warnings by assigning. */\n        /* The following access is intentional to capture runtime state. */\n        vlen = hdr->value_size;\n        fprintf(f, \"    hdr->value_size=%zu\\n\", vlen);\n\n        if (NULL != hdr->value && vlen > 0u)\n        {\n          /* Log up to the first 64 bytes of the stored value (binary-safe). */\n          size_t to_log = (vlen < 64u) ? vlen : 64u;\n          fprintf(f, \"    hdr->value (first %zu bytes): \", to_log);\n          fwrite(hdr->value, 1, to_log, f);\n          fprintf(f, \"\\n\");\n        }\n      }\n    }\n  }\n\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  /* Probe log at function entry to capture the control path and state that\n   * might lead to the reported violation. The probe preserves the original\n   * logic and only appends diagnostic information to /tmp/logs/55.txt. */\n  mhd_probe_log_conn(response, header, content);\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n"
}