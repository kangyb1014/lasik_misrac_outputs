{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The block of code between #if 0 and #endif (a set of switch case labels and a return -1) is permanently excluded from compilation and therefore cannot be executed. This disabled code is unreachable and thus violates MISRA C 2023 Rule 2.1. Remove or properly justify/replace the #if 0 code so that no unreachable source remains.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/73.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"[get_rq_extended_uname_copy_z] \");\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  mhd_log_probe (\"entry: uname_ext=%p uname_ext_len=%zu buf=%p buf_size=%zu\",\n                 (void *) uname_ext, uname_ext_len, (void *) buf, buf_size);\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    mhd_log_probe (\"fail: input too long: uname_ext_len=%zu SSIZE_MAX=%zu\",\n                   uname_ext_len, (size_t) SSIZE_MAX);\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    mhd_log_probe (\"fail: missing required prefix: uname_ext_len=%zu MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\",\n                   uname_ext_len, (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN);\n    return -1; /* Required prefix is missing */\n  }\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    mhd_log_probe (\"fail: prefix check failed: uname_ext startswith prefix?=false prefix=%s\",\n                   MHD_DAUTH_EXT_PARAM_PREFIX);\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n  }\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  mhd_log_probe (\"after prefix: r=%zu (prefix_len=%zu)\", r,\n                 (size_t) MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX));\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      mhd_log_probe (\"fail: wrong char in language tag: char='%c' (0x%02x) pos=%zu\",\n                     (chr >= 32 && chr < 127) ? chr : '?', (unsigned char) chr, r);\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n  }\n  if (r >= uname_ext_len)\n  {\n    mhd_log_probe (\"fail: end of language tag not found: r=%zu uname_ext_len=%zu\",\n                   r, uname_ext_len);\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n  mhd_log_probe (\"after lang tag: r=%zu remaining=%zu\", r, uname_ext_len - r);\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  mhd_log_probe (\"percent decode result: w=%zu\", w);\n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    mhd_log_probe (\"fail: broken percent encoding: r=%zu remaining=%zu w=%zu\",\n                   r, uname_ext_len - r, w);\n    return -1; /* Broken percent encoding */\n  }\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_log_probe (\"success: decoded_len=%zu buf_address=%p\", w, (void *) buf);\n  /* Optionally log a short preview of the buffer; avoid huge prints */\n  if (w > 0)\n  {\n    /* Print up to 256 bytes of the decoded buffer for inspection */\n    size_t to_print = (w < 256U) ? w : 256U;\n    /* Ensure we have a null-terminated sample */\n    char sample[257];\n    size_t i;\n    for (i = 0; i < to_print; ++i)\n      sample[i] = buf[i];\n    sample[to_print] = '\\0';\n    mhd_log_probe (\"decoded_sample: '%s' (len=%zu, sample_len=%zu)\", sample, w, to_print);\n  }\n\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_extended_uname_copy_z. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not supported by the supplied source. The get_rq_extended_uname_copy_z implementation shown contains no #if 0 / #endif-disabled block, no permanently excluded switch labels, and no obviously unreachable statements \u2014 all return points and the loop can be reached depending on run-time inputs. The provided test harness merely shows the function compiled but not executed (empty log), which does not indicate the presence of unreachable source. If there really were code between #if 0 and #endif, that code would be removed by the preprocessor and would not be part of the translation unit; many MISRA checkers either ignore preprocessor-excluded text or report it separately as \u201cdead/disabled\u201d code, but the function as presented does not contain such disabled code. Therefore the reported violation for this function is incorrect. (Recommendation: if you believe there is disabled code elsewhere, show the exact source fragment with #if 0/#endif or the preprocessed file so it can be evaluated.)"
}