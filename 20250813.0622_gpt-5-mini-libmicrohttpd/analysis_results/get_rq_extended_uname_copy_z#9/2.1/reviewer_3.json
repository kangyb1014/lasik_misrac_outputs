{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In toxdigitvalue (when MHD_FAVOR_SMALL_CODE is not defined) the switch is written over (unsigned char) c and explicitly lists case labels covering 0x00 through 0xFF; therefore the default: branch can never be taken. The statement mhd_assert(0); inside that default branch is unreachable code (the comment even says \"Should be unreachable\"). This constitutes a violation of MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/73.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\nstatic void mhd_log_hex_snip(const char *tag, const char *data, size_t len, size_t max_print)\n{\n    FILE *f = fopen(\"/tmp/logs/73.txt\", \"a\");\n    if (NULL == f)\n        return;\n    fprintf(f, \"%s: len=%zu, data=\", tag, len);\n    size_t to_print = (len < max_print) ? len : max_print;\n    for (size_t i = 0; i < to_print; ++i)\n        fprintf(f, \"%02X\", (unsigned char) data[i]);\n    if (to_print < len)\n        fprintf(f, \"..(+%zu bytes)\", len - to_print);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  /* Entry probe */\n  mhd_log(\"ENTER get_rq_extended_uname_copy_z: uname_ext=%p uname_ext_len=%zu buf=%p buf_size=%zu\",\n          (const void *) uname_ext, uname_ext_len, (void *) buf, buf_size);\n  mhd_log_hex_snip(\"uname_ext_prefix_bytes\", uname_ext, uname_ext_len, 64);\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    mhd_log(\"RETURN Too long input string: uname_ext_len=%zu > SSIZE_MAX=%d\", uname_ext_len, SSIZE_MAX);\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    mhd_log(\"RETURN Required prefix missing: uname_ext_len=%zu < MHD_DAUTH_EXT_PARAM_MIN_LEN=%d\",\n            uname_ext_len, MHD_DAUTH_EXT_PARAM_MIN_LEN);\n    return -1; /* Required prefix is missing */\n  }\n\n  /* Log intent to call prefix equality check */\n  mhd_log(\"CALL MHD_str_equal_caseless_bin_n_: uname_ext_len=%zu prefix_len=%zu\",\n          uname_ext_len,\n          (size_t) MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX));\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    mhd_log(\"RETURN Prefix mismatch: uname_ext does not start with required prefix\");\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n  }\n\n  mhd_log(\"PREFIX_OK: required prefix present\");\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n\n  size_t loop_count = 0;\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n\n    if (loop_count < 256)\n      mhd_log(\"LANG_TAG_CHAR idx=%zu chr=0x%02X (%c)\", r, (unsigned char) chr,\n              ((' ' <= chr && chr <= '~') ? chr : '.'));\n    else if (loop_count == 256)\n      mhd_log(\"LANG_TAG: more than 256 iterations - stopping detailed logs\");\n\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      mhd_log(\"RETURN Wrong char in language tag at idx=%zu chr=0x%02X\", r, (unsigned char) chr);\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n    loop_count++;\n  }\n  if (r >= uname_ext_len)\n  {\n    mhd_log(\"RETURN The end of the language tag was not found: r=%zu uname_ext_len=%zu\", r, uname_ext_len);\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n\n  mhd_log(\"CALL MHD_str_pct_decode_strict_n_: r=%zu remaining=%zu buf_size=%zu\",\n          r, (uname_ext_len - r), buf_size);\n  mhd_log_hex_snip(\"pct-encoded-input\", uname_ext + r, (uname_ext_len - r), 128);\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n\n  mhd_log(\"RETURN FROM pct_decode: w=%zu (0 meaning failure), buf[0]=0x%02X\", w, (unsigned char) buf[0]);\n\n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    mhd_log(\"RETURN Broken percent encoding detected: w=0 remaining=%zu\", uname_ext_len - r);\n    return -1; /* Broken percent encoding */\n  }\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n\n  mhd_log(\"EXIT OK: decoded_length=%zu final_buf=%p\", w, (void *) buf);\n  return (ssize_t) w;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_extended_uname_copy_z. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The get_rq_extended_uname_copy_z function shown does not itself contain unreachable code. However Agent A\u2019s report refers to a different helper (toxdigitvalue) and the scenario is plausible and convincing: if toxdigitvalue switches on (unsigned char)c and explicitly provides case labels for every possible unsigned\u2011char value (0x00..0xFF), the default: branch can never be taken and any statement inside it (mhd_assert(0);) is unreachable. MISRA C 2023 Rule 2.1 forbids unreachable code in the project, so the presence of such an unreachable default branch would be a violation. The absence of runtime logs for get_rq_extended_uname_copy_z does not contradict this. Note: the claim is correct only if the toxdigitvalue variant actually present in the project indeed enumerates every (unsigned char) value; if a build configuration (e.g. MHD_FAVOR_SMALL_CODE) produces a different implementation, the verdict depends on the active variant."
}