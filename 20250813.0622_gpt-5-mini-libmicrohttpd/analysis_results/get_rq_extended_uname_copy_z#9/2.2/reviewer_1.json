{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as ((void)0). Therefore the statement `mhd_assert (! da->hashing);` expands to a no-op expression statement that is executed but has no effect; removing it would not change program behaviour. This constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/74.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  mhd_probe_log (\"enter get_rq_extended_uname_copy_z: uname_ext=%p uname_ext_len=%zu buf=%p buf_size=%zu\",\n                 (const void *) uname_ext, uname_ext_len, (const void *) buf, buf_size);\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    mhd_probe_log (\"return -1: Too long input string: uname_ext_len=%zu SSIZE_MAX=%zu\",\n                   uname_ext_len, (size_t) SSIZE_MAX);\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    mhd_probe_log (\"return -1: Required prefix is missing: uname_ext_len=%zu MHD_DAUTH_EXT_PARAM_MIN_LEN=%zu\",\n                   uname_ext_len, (size_t) MHD_DAUTH_EXT_PARAM_MIN_LEN);\n    return -1; /* Required prefix is missing */\n  }\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    mhd_probe_log (\"return -1: Prefix mismatch / encoding issue (only UTF-8 supported). uname_ext_len=%zu\",\n                   uname_ext_len);\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n  }\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  mhd_probe_log (\"after prefix r=%zu\", r);\n\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      mhd_probe_log (\"return -1: Wrong char in language tag at index %zu: char=0x%02x ('%c')\",\n                     r, (unsigned char) chr, (chr >= ' ' && chr <= '~') ? chr : '?');\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n    /* Probe each step to trace scan progress */\n    mhd_probe_log (\"language tag scan continue r=%zu\", r);\n  }\n  if (r >= uname_ext_len)\n  {\n    mhd_probe_log (\"return -1: The end of the language tag was not found: r=%zu uname_ext_len=%zu\",\n                   r, uname_ext_len);\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n  mhd_probe_log (\"after language tag r=%zu remaining=%zu\", r, uname_ext_len - r);\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  mhd_probe_log (\"pct-decode returned w=%zu (remaining input=%zu)\", w, uname_ext_len - r);\n\n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    mhd_probe_log (\"return -1: Broken percent encoding: w=%zu remaining=%zu\", w, uname_ext_len - r);\n    return -1; /* Broken percent encoding */\n  }\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_probe_log (\"zero-terminated buffer at index w=%zu buf[0]=0x%02x\", w, (unsigned char) buf[0]);\n\n  /* Log the condition that the subsequent mhd_assert checks. This reproduces the\n     runtime state used by the original assertion; note that if mhd_assert is a\n     no-op macro this log will still capture the condition value for auditing. */\n  mhd_probe_log (\"about to mhd_assert(SSIZE_MAX > w): SSIZE_MAX=%zu w=%zu condition=%s\",\n                 (size_t) SSIZE_MAX, w, (SSIZE_MAX > (ssize_t) w) ? \"true\" : \"false\");\n\n  mhd_assert (SSIZE_MAX > w);\n  mhd_probe_log (\"returning (ssize_t) w=%zu\", w);\n  return (ssize_t) w;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_extended_uname_copy_z. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The mhd_assert macro expanding to ((void)0) produces a no-op expression statement in the preprocessed source, but this pattern is an intentional, conditional debugging/assertion hook rather than accidental \u2018\u2018dead code\u2019\u2019 in the sense MISRA Rule 2.2 aims to eliminate.\n\nReasons:\n- MISRA R2.2 targets unreachable or redundant operations whose presence in all builds is accidental and removable without changing intended behaviour. An assertion macro is a deliberate abstraction that may expand to an active check in other build configurations (or be redefined to a diagnostic), so the presence of the macro invocation is part of the project\u2019s design and cannot be judged as an accidental dead operation just from one build\u2019s definition.\n- Removing the assertion invocation from the source (not just redefining the macro) would change the source-level interface and might change behaviour in builds where mhd_assert is defined to perform checking (or where it has side effects). MISRA analysis must consider all intended build configurations, not only the current macro definition.\n- Practically, tools and MISRA guidance treat assertion macros that are compiled out via macro definition as acceptable. If an analysis tool reports dead code because an assertion macro expands to (void)0 in a particular translation unit, that is a false positive against the intent of R2.2; the correct remediation is to review the assertion macro policy (and if necessary, use conditional compilation so that calls are absent when intended), not to flag every compiled-out assertion as dead code.\n\nAlso, the provided test code produced no log because the function was not exercised in the test run; that is unrelated to whether the assertion invocation constitutes a Rule 2.2 violation.\n\nTherefore Agent A\u2019s claim that the shown assertion use constitutes a MISRA C:2023 Rule 2.2 violation is incorrect."
}