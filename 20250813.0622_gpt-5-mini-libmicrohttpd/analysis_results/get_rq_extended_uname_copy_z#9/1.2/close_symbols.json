{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "SSIZE_MAX",
    "ssize_t",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_str_pct_decode_strict_n_",
    "toxdigitvalue",
    "mhd_assert"
  ],
  "explanation": "For each symbol below: we need its definition/implementation to determine whether the target function or any macros/functions it uses employ compiler-specific language extensions (statement expressions, typeof, __attribute__, __builtin_*, inline asm, non\u2011standard keywords, or other documented compiler extensions). 1) SSIZE_MAX \u2014 macro/type value. Verify whether SSIZE_MAX is provided via a non\u2011standard header or defined using compiler extensions; also needed to check the cast (size_t) SSIZE_MAX arithmetic for portability/implementation\u2011defined behaviour. 2) ssize_t \u2014 non\u2011standard POSIX type; confirm whether this type is a compiler/library extension in the build environment (misuse would be a language/library extension concern). 3) MHD_DAUTH_EXT_PARAM_MIN_LEN \u2014 macro controlling logic; its definition may use extensions or non\u2011portable constructs. 4) MHD_DAUTH_EXT_PARAM_PREFIX \u2014 macro/string used with MHD_STATICSTR_LEN_; its definition could be an expression or use extensions. 5) MHD_STATICSTR_LEN_ \u2014 macro used to compute string length; such macros sometimes use sizeof tricks, GCC extensions (e.g. typeof, statement expressions, __builtin_constant_p). We must inspect it to rule out extensions. 6) MHD_str_equal_caseless_bin_n_ \u2014 called function/macro used in the initial check; it may be a macro or inline function that uses compiler extensions (attributes, inline semantics, statement expressions). 7) MHD_str_pct_decode_strict_n_ \u2014 callee that decodes percent-encoding and returns w; its prototype/definition is required to check for extension usage (return type, inline/attribute, macros used inside). 8) toxdigitvalue \u2014 transitive callee (shown in the static graph) used by MHD_str_pct_decode_strict_n_; its implementation may contain compiler extensions that would be relevant to whether the decoding logic relies on extensions. 9) mhd_assert \u2014 assertion macro; assert macros often expand to compiler builtins or use __attribute__ or statement expressions \u2014 check its definition to ensure it does not use extensions.\n\nInspecting these symbols (macros and function definitions/prototypes) is sufficient to determine whether the target function or any inline/expanded constructs it relies upon use language/compiler extensions forbidden by the MISRA rule."
}