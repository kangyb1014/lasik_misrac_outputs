{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as '#define mhd_assert(ignore) ((void)0)'. Thus the statement 'mhd_assert (pos + suffix_len <= h_maxlen);' expands to the no-op '((void)0);' \u2014 an executed operation with no effect whose removal would not change program behaviour. In this project/configuration that invocation is dead code and therefore violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nvoid mhd_assert (int condition);\nconst char MHD_HTTP_HEADER_WWW_AUTHENTICATE[] = \"WWW-Authenticate\";\nconst int MHD_HTTP_UNAUTHORIZED = 401;\nstatic void mhd_probe_log(const char *location,\n                          struct MHD_Connection *connection,\n                          const char *realm,\n                          size_t pos,\n                          size_t suffix_len,\n                          size_t h_maxlen,\n                          size_t realm_len,\n                          size_t realm_quoted_len,\n                          const char *note)\n{\n  FILE *f = fopen(\"/tmp/logs/578.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"[MHD_PROBE] %s\\n\", location);\n  if (connection != NULL)\n    fprintf(f, \"  connection=%p daemon=%p\\n\", (void *)connection, (void *)connection->daemon);\n  fprintf(f, \"  realm=\\\"%s\\\"\\n\", realm ? realm : \"(null)\");\n  fprintf(f, \"  pos=%zu suffix_len=%zu h_maxlen=%zu realm_len=%zu realm_quoted_len=%zu\\n\",\n          pos, suffix_len, h_maxlen, realm_len, realm_quoted_len);\n  if (note)\n    fprintf(f, \"  note=%s\\n\", note);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nenum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = sizeof(prefix) - 1;\n  static const size_t suff_simple_len = sizeof(\"\\\"\") - 1; /* length of \"\\\"\" is 1 */\n  static const size_t suff_charset_len = sizeof(suff_charset) - 1;\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"alloc_failed\", connection, realm, 0u, suffix_len, h_maxlen, realm_len, 0u, \"malloc returned NULL\");\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n\n  /* Probe immediately before the assert that is a no-op in this configuration */\n  mhd_probe_log(\"before_assert_pos_suffix_hmax\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"about to execute mhd_assert(pos + suffix_len <= h_maxlen)\");\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  mhd_probe_log(\"after_assert_pos_suffix_hmax\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"executed mhd_assert(pos + suffix_len <= h_maxlen)\");\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_probe_log(\"before_assert_pos_le_hmax_plus1\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"about to execute mhd_assert(pos <= h_maxlen + 1)\");\n    mhd_assert (pos <= h_maxlen + 1);\n    mhd_probe_log(\"after_assert_pos_le_hmax_plus1\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"executed mhd_assert(pos <= h_maxlen + 1)\");\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_probe_log(\"before_assert_pos_suffcharset_hmax\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"about to execute mhd_assert(pos + suff_charset_len <= h_maxlen)\");\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    mhd_probe_log(\"after_assert_pos_suffcharset_hmax\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"executed mhd_assert(pos + suff_charset_len <= h_maxlen)\");\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_probe_log(\"before_assert_zero_at_end\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"about to execute mhd_assert(0 == h_str[pos + suff_charset_len])\");\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n    mhd_probe_log(\"after_assert_zero_at_end\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"executed mhd_assert(0 == h_str[pos + suff_charset_len])\");\n  }\n\n  mhd_probe_log(\"before_add_response_header\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"about to call MHD_add_response_header\");\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  mhd_probe_log(\"after_add_response_header\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, ret == MHD_NO ? \"MHD_add_response_header returned MHD_NO\" : \"MHD_add_response_header returned success\");\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    mhd_probe_log(\"after_queue_response\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, ret == MHD_NO ? \"MHD_queue_response returned MHD_NO\" : \"MHD_queue_response returned success\");\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"add_header_failed\", connection, realm, pos, suffix_len, h_maxlen, realm_len, realm_quoted_len, \"Failed to add header - will not queue response\");\n  }\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The mhd_assert macro as defined (#define mhd_assert(ignore) ((void)0)) expands each mhd_assert( ... ); call to an expression statement whose only effect is to evaluate to void \u2014 i.e. a no-op. Those statements are executed (they appear on the executed control path) but have no effect; removing them would not change program behaviour. That matches the quoted MISRA C 2023 Rule 2.2 definition of dead code, so the reported violation is valid. (The failing test build is irrelevant to the reasoning: the macro expansion alone is sufficient to conclude these calls are dead code in that project configuration.)"
}