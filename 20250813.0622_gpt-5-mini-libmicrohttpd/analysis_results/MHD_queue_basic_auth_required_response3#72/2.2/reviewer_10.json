{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert(NULL != hdr); macro is defined as ((void)0). Thus the statement compiles to a no-op (no side-effects) at runtime; removing it would not change program behaviour. This is an executed operation with no effect, i.e. dead code, and therefore violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/578.txt\", \"a\");\n    if (f == NULL)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  mhd_probe_log(\"ENTER: MHD_queue_basic_auth_required_response3: connection=%p realm=%s prefer_utf8=%d response=%p\",\n                (void *) connection,\n                (realm != NULL) ? realm : \"(null)\",\n                prefer_utf8,\n                (void *) response);\n\n  if (NULL == response)\n  {\n    mhd_probe_log(\"EARLY RETURN: response is NULL -> MHD_NO\");\n    return MHD_NO;\n  }\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  mhd_probe_log(\"computed lengths: prefix_len=%zu realm_len=%zu suffix_len=%zu h_maxlen=%zu\",\n                prefix_len, realm_len, suffix_len, h_maxlen);\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"malloc FAILED for h_str (size=%zu)\", h_maxlen + 1);\n    return MHD_NO;\n  }\n  mhd_probe_log(\"malloc OK: h_str=%p (size=%zu)\", (void *) h_str, h_maxlen + 1);\n\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  mhd_probe_log(\"after memcpy prefix: pos=%zu prefix_len=%zu\", pos, prefix_len);\n\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  mhd_probe_log(\"MHD_str_quote returned realm_quoted_len=%zu (pos before=%zu)\", realm_quoted_len, pos);\n\n  pos += realm_quoted_len;\n  mhd_probe_log(\"pos after quoting realm: pos=%zu (h_maxlen=%zu)\", pos, h_maxlen);\n\n  /* Probe around mhd_assert to evidence execution and state */\n  mhd_probe_log(\"about to mhd_assert: expr=(pos + suffix_len <= h_maxlen) evaluated values: pos=%zu suffix_len=%zu h_maxlen=%zu\",\n                pos, suffix_len, h_maxlen);\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  mhd_probe_log(\"after mhd_assert: (pos + suffix_len <= h_maxlen) check executed (no-op if mhd_assert is ((void)0))\");\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_probe_log(\"prefer_utf8==0 branch: wrote quote and NUL, new pos=%zu\", pos);\n    mhd_probe_log(\"about to mhd_assert: expr=(pos <= h_maxlen + 1) values: pos=%zu h_maxlen=%zu\",\n                  pos, h_maxlen);\n    mhd_assert (pos <= h_maxlen + 1);\n    mhd_probe_log(\"after mhd_assert: (pos <= h_maxlen + 1) check executed\");\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_probe_log(\"prefer_utf8!=0 branch: about to mhd_assert: expr=(pos + suff_charset_len <= h_maxlen) values: pos=%zu suff_charset_len=%zu h_maxlen=%zu\",\n                  pos, suff_charset_len, h_maxlen);\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    mhd_probe_log(\"after mhd_assert: (pos + suff_charset_len <= h_maxlen) check executed\");\n\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_probe_log(\"copied suff_charset to h_str+%zu (suff_charset_len=%zu)\", pos, suff_charset_len);\n\n    mhd_probe_log(\"about to mhd_assert: expr=(0 == h_str[pos + suff_charset_len]) verifying NUL terminator at index %zu\",\n                  pos + suff_charset_len);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n    mhd_probe_log(\"after mhd_assert: NUL terminator check executed; value at that index: %d\",\n                  (int) h_str[pos + suff_charset_len]);\n  }\n\n  /* Log a short hex dump of the header buffer up to pos + suffix_len to help reproduce state */\n  {\n    size_t dump_len = pos + (suffix_len < 16 ? suffix_len : 16);\n    if (dump_len > h_maxlen)\n      dump_len = h_maxlen;\n    mhd_probe_log(\"h_str buffer dump (first %zu bytes):\", dump_len);\n    {\n      size_t i;\n      char tmp[128];\n      size_t off = 0;\n      for (i = 0; i < dump_len && off + 4 < sizeof(tmp); ++i)\n        off += snprintf(tmp + off, sizeof(tmp) - off, \"%02X \", (unsigned char) h_str[i]);\n      mhd_probe_log(\"%s\", tmp);\n    }\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  mhd_probe_log(\"MHD_add_response_header returned %d\", (int) ret);\n\n  free (h_str);\n  mhd_probe_log(\"freed h_str pointer\");\n\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    mhd_probe_log(\"MHD_queue_response returned %d\", (int) ret);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"MHD_add_response_header failed -> did not queue response\");\n  }\n\n  mhd_probe_log(\"EXIT: MHD_queue_basic_auth_required_response3 returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_queue_basic_auth_required_response3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct given the stated configuration. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not affect program behaviour. If, in the project configuration used, mhd_assert is defined as ((void)0) (i.e. it expands to a no-op), each mhd_assert invocation becomes an executed no-op statement. Removing those no-op statements would not change program behaviour, so they meet the definition of dead code and thus violate Rule 2.2.\n\nNote: this conclusion depends on the project-wide definition of mhd_assert. If the macro is defined differently (e.g. to perform runtime checks or logging) in the project configuration, then those assertions would not be dead and there would be no violation. But under the provided assumption that mhd_assert is ((void)0), the report is correct."
}