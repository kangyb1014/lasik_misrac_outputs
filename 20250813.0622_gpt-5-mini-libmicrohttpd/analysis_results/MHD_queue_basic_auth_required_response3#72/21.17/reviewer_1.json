{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 there is a feasible path that can make the memcpy write out of bounds. The code assumes h_maxlen = prefix_len + realm_len*2 + suffix_len fits in size_t and that the allocation of h_str (h_maxlen + 1) is large enough for memcpy(..., suff_charset_len + 1). If realm_len is extremely large (e.g. realm_len > SIZE_MAX/2), the multiplication realm_len * 2 can overflow (wrap), producing a much smaller h_maxlen and a too-small allocation; later memcpy(h_str + pos, suff_charset, suff_charset_len + 1) can then copy the final NUL byte past the allocated buffer. Thus the use of memcpy can result in accesses beyond the bounds of h_str unless integer overflow is checked/guarded against.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_state (const char *event, struct MHD_Connection *connection,\n               int prefer_utf8,\n               size_t prefix_len, size_t realm_len, size_t suffix_len,\n               size_t h_maxlen, size_t alloc_size, int overflow_flag,\n               size_t realm_quoted_len, size_t pos, size_t memcpy_len)\n{\n  FILE *f = fopen(\"/tmp/logs/583.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf (f, \"EVENT: %s\\n\", event);\n  fprintf (f, \" connection=%p prefer_utf8=%d\\n\", (void *) connection, prefer_utf8);\n  fprintf (f, \" prefix_len=%zu realm_len=%zu suffix_len=%zu\\n\",\n           prefix_len, realm_len, suffix_len);\n  fprintf (f, \" h_maxlen(computed)=%zu alloc_size=%zu overflow_flag=%d\\n\",\n           h_maxlen, alloc_size, overflow_flag);\n  fprintf (f, \" realm_quoted_len=%zu pos=%zu memcpy_len=%zu\\n\",\n           realm_quoted_len, pos, memcpy_len);\n  fprintf (f, \"---\\n\");\n  fclose (f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n\n  /* Compute wrapped arithmetic the same way original code does and also\n     determine whether multiplication would overflow in mathematical sense */\n  int overflow_flag = 0;\n  if (realm_len > (SIZE_MAX / 2))\n    overflow_flag = 1;\n\n  /* This mirrors the original behavior: size_t arithmetic (wrap) */\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n  {\n    size_t alloc_size = h_maxlen + 1; /* may wrap as original code */\n    mhd_log_state (\"computed_sizes\", connection, prefer_utf8,\n                   prefix_len, realm_len, suffix_len,\n                   h_maxlen, alloc_size, overflow_flag,\n                   (size_t)0, (size_t)0, (size_t)0);\n  }\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    mhd_log_state (\"malloc_failed\", connection, prefer_utf8,\n                   prefix_len, realm_len, suffix_len,\n                   h_maxlen, (h_maxlen + 1), overflow_flag,\n                   (size_t)0, (size_t)0, (size_t)0);\n    return MHD_NO;\n  }\n\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n\n  mhd_log_state (\"after_quote\", connection, prefer_utf8,\n                 prefix_len, realm_len, suffix_len,\n                 h_maxlen, (h_maxlen + 1), overflow_flag,\n                 realm_quoted_len, pos, (size_t)0);\n\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_log_state (\"non_utf8_terminated\", connection, prefer_utf8,\n                   prefix_len, realm_len, suffix_len,\n                   h_maxlen, (h_maxlen + 1), overflow_flag,\n                   realm_quoted_len, pos, (size_t)2);\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    size_t memcpy_len = suff_charset_len + 1;\n    mhd_log_state (\"before_memcpy_utf8\", connection, prefer_utf8,\n                   prefix_len, realm_len, suffix_len,\n                   h_maxlen, (h_maxlen + 1), overflow_flag,\n                   realm_quoted_len, pos, memcpy_len);\n    memcpy (h_str + pos, suff_charset, memcpy_len);\n    mhd_log_state (\"after_memcpy_utf8\", connection, prefer_utf8,\n                   prefix_len, realm_len, suffix_len,\n                   h_maxlen, (h_maxlen + 1), overflow_flag,\n                   realm_quoted_len, pos, memcpy_len);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  mhd_log_state (\"after_add_header\", connection, prefer_utf8,\n                 prefix_len, realm_len, suffix_len,\n                 h_maxlen, (h_maxlen + 1), overflow_flag,\n                 realm_quoted_len, pos, (size_t)0);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  mhd_log_state (\"return\", connection, prefer_utf8,\n                 prefix_len, realm_len, suffix_len,\n                 h_maxlen, (h_maxlen + 1), overflow_flag,\n                 realm_quoted_len, pos, (size_t)0);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_queue_basic_auth_required_response3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s scenario is correct. The code computes h_maxlen = prefix_len + realm_len * 2 + suffix_len using size_t arithmetic without checking for overflow. If realm_len > SIZE_MAX/2 the multiplication realm_len * 2 (and the subsequent additions) can wrap, producing a much smaller h_maxlen and thus an undersized allocation from malloc(h_maxlen + 1). Later the code does memcpy(h_str + pos, suff_charset, suff_charset_len + 1) which assumes the buffer is large enough; the preceding checks are only mhd_asserts (which may be compiled out) and do not prevent the wrapped arithmetic from producing an out\u2011of\u2011bounds write. Because memcpy is used and can be made to access past the allocated object when the size arithmetic wraps, this is a real potential violation of MISRA C 2023 Rule 21.17. The code should explicitly check for overflow (e.g. bounds on realm_len or use of safe arithmetic/guards) before performing the size calculations and allocation."
}