{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Several pointer-typed objects are only read from in MHD_connection_handle_write but are not const-qualified in their declarations. Examples: the local variable and struct member used as the response pointer (declared/typed as struct MHD_Response * / connection->rp.response) are only dereferenced for reading in this function and could be declared as const struct MHD_Response *; connection->write_buffer is only read from here and could be a const char * for this use; response->data_iov (MHD_iovec_ *) and other pointer members checked for NULL (e.g. response->crc) are only inspected/called and could point to const-qualified types. These non-const pointer declarations therefore violate MISRA C 2023 Rule 8.13 in this function's context.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/275.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n  {\n    mhd_log_probe (\"EXIT early: connection suspended (conn=%p)\", (void *) connection);\n    return;\n  }\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      mhd_log_probe (\"TLS handshake needed (conn=%p, tls_state=%d)\", (void *) connection, (int) connection->tls_state);\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        mhd_log_probe (\"TLS handshake not complete (conn=%p)\", (void *) connection);\n        return;\n      }\n      mhd_log_probe (\"TLS handshake completed (conn=%p)\", (void *) connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n\n  /* Log entry state */\n  mhd_log_probe (\"ENTRY: MHD_connection_handle_write conn=%p state=%d rq.url=%p daemon=%p write_send=%zu write_append=%zu rp.response=%p rsp_write_pos=%zu keepalive=%d\",\n                 (void *) connection,\n                 (int) connection->state,\n                 (void *) connection->rq.url,\n                 (void *) connection->daemon,\n                 connection->write_buffer_send_offset,\n                 connection->write_buffer_append_offset,\n                 (void *) connection->rp.response,\n                 connection->rp.rsp_write_position,\n                 (int) connection->keepalive);\n\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    mhd_log_probe (\"CONTINUE_SENDING: sent ret=%zd conn=%p continue_offset=%zu\",\n                   ret,\n                   (void *) connection,\n                   connection->continue_message_write_offset);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      /* Log headers-sending relevant state */\n      if (NULL != resp)\n      {\n        mhd_log_probe (\"HEADERS_SENDING: conn=%p resp=%p wb_ready=%zu resp.total_size=%zu resp.data_size=%zu resp.data_start=%zu resp.crc=%p resp.data_iov=%p send_reply_body=%d chunked=%d rsp_write_position=%zu\",\n                       (void *) connection,\n                       (void *) resp,\n                       wb_ready,\n                       (size_t) resp->total_size,\n                       (size_t) resp->data_size,\n                       (size_t) resp->data_start,\n                       (void *) resp->crc,\n                       (void *) resp->data_iov,\n                       (int) connection->rp.props.send_reply_body,\n                       (int) connection->rp.props.chunked,\n                       connection->rp.rsp_write_position);\n      }\n      else\n      {\n        mhd_log_probe (\"HEADERS_SENDING: conn=%p resp=NULL wb_ready=%zu\",\n                       (void *) connection,\n                       wb_ready);\n      }\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        mhd_log_probe (\"HEADERS_SENDING: sending headers+body (conn=%p resp=%p)\", (void *) connection, (void *) resp);\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        mhd_log_probe (\"HEADERS_SENDING: sending headers only (conn=%p resp=%p)\", (void *) connection, (void *) resp);\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      mhd_log_probe (\"HEADERS_SENDING: ret=%zd conn=%p wb_ready=%zu write_send_off_before=%zu write_append=%zu\",\n                     ret,\n                     (void *) connection,\n                     wb_ready,\n                     connection->write_buffer_send_offset,\n                     connection->write_buffer_append_offset);\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n        mhd_log_probe (\"HEADERS_SENDING: sent headers+part body conn=%p new_send_off=%zu rsp_write_pos=%zu\",\n                       (void *) connection,\n                       connection->write_buffer_send_offset,\n                       connection->rp.rsp_write_position);\n      }\n      else\n      {\n        connection->write_buffer_send_offset += (size_t) ret;\n        mhd_log_probe (\"HEADERS_SENDING: sent headers only conn=%p new_send_off=%zu\",\n                       (void *) connection,\n                       connection->write_buffer_send_offset);\n      }\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    mhd_log_probe (\"HEADERS_SENT: conn=%p\", (void *) connection);\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    mhd_log_probe (\"NORMAL_BODY_READY: conn=%p response=%p rsp_write_pos=%zu response_total_size=%zu\",\n                   (void *) connection,\n                   (void *) response,\n                   connection->rp.rsp_write_position,\n                   response ? (size_t) response->total_size : 0);\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        mhd_log_probe (\"NORMAL_BODY_READY: try_ready_normal_body returned NO (conn=%p)\", (void *) connection);\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        mhd_log_probe (\"NORMAL_BODY_READY: using sendfile (conn=%p)\", (void *) connection);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        mhd_log_probe (\"NORMAL_BODY_READY: using iovec send (conn=%p response=%p data_iov=%p)\", (void *) connection, (void *) response, (void *) response->data_iov);\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        mhd_log_probe (\"NORMAL_BODY_READY: sending data from offset=%\" PRIu64 \" (conn=%p) data_start=%zu data_size=%zu\",\n                       data_write_offset,\n                       (void *) connection,\n                       (size_t) response->data_start,\n                       (size_t) response->data_size);\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      mhd_log_probe (\"NORMAL_BODY_READY: after send ret=%zd conn=%p\", ret, (void *) connection);\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      mhd_log_probe (\"NORMAL_BODY_READY: advanced rsp_write_position=%zu conn=%p\",\n                     connection->rp.rsp_write_position,\n                     (void *) connection);\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n    {\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      mhd_log_probe (\"NORMAL_BODY_READY: full reply sent (conn=%p)\", (void *) connection);\n    }\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    mhd_log_probe (\"CHUNKED_BODY_READY: conn=%p send_off=%zu append_off=%zu\",\n                   (void *) connection,\n                   connection->write_buffer_send_offset,\n                   connection->write_buffer_append_offset);\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    mhd_log_probe (\"CHUNKED_BODY_READY: ret=%zd conn=%p\", ret, (void *) connection);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    mhd_log_probe (\"FOOTERS_SENDING: conn=%p send_off=%zu append_off=%zu\",\n                   (void *) connection,\n                   connection->write_buffer_send_offset,\n                   connection->write_buffer_append_offset);\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    mhd_log_probe (\"FOOTERS_SENDING: ret=%zd conn=%p\", ret, (void *) connection);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    mhd_log_probe (\"CONNECTION_CLOSED: conn=%p\", (void *) connection);\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    mhd_log_probe (\"DEFAULT: internal error closing conn=%p state=%d\", (void *) connection, (int) connection->state);\n    break;\n  }\n  return;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: MHD_connection_handle_write conn=0x5577af925870 state=13 rq.url=0x5577af925b14 daemon=0x5577af9252b0 write_send=0 write_append=125 rp.response=0x5577af92db40 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x5577af925870 resp=0x5577af92db40 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x5577af925870 resp=0x5577af92db40)\nHEADERS_SENDING: ret=125 conn=0x5577af925870 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x5577af925870 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x5577af92e500 state=13 rq.url=0x5577af925b14 daemon=0x5577af92e080 write_send=0 write_append=125 rp.response=0x5577af92e750 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x5577af92e500 resp=0x5577af92e750 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x5577af92e500 resp=0x5577af92e750)\nHEADERS_SENDING: ret=125 conn=0x5577af92e500 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x5577af92e500 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x5577af925b10 state=13 rq.url=0x5577af92ef34 daemon=0x5577af92e890 write_send=0 write_append=125 rp.response=0x5577af92ed10 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x5577af925b10 resp=0x5577af92ed10 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x5577af925b10 resp=0x5577af92ed10)\nHEADERS_SENDING: ret=125 conn=0x5577af925b10 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x5577af925b10 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x7f655c000b90 state=13 rq.url=0x7f655c000e14 daemon=0x5577af925d60 write_send=0 write_append=125 rp.response=0x7f6564000b90 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x7f655c000b90 resp=0x7f6564000b90 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x7f655c000b90 resp=0x7f6564000b90)\nHEADERS_SENDING: ret=125 conn=0x7f655c000b90 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x7f655c000b90 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x7f655c000b90 state=13 rq.url=0x7f655c000e14 daemon=0x5577af9261e0 write_send=0 write_append=125 rp.response=0x7f6564000b90 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x7f655c000b90 resp=0x7f6564000b90 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x7f655c000b90 resp=0x7f6564000b90)\nHEADERS_SENDING: ret=125 conn=0x7f655c000b90 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x7f655c000b90 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x7f655c000b90 state=13 rq.url=0x7f655c000e14 daemon=0x5577af926620 write_send=0 write_append=125 rp.response=0x7f6564000b90 rsp_write_pos=0 keepalive=2\nHEADERS_SENDING: conn=0x7f655c000b90 resp=0x7f6564000b90 wb_ready=125 resp.total_size=0 resp.data_size=0 resp.data_start=0 resp.crc=(nil) resp.data_iov=(nil) send_reply_body=0 chunked=0 rsp_write_position=0\nHEADERS_SENDING: sending headers only (conn=0x7f655c000b90 resp=0x7f6564000b90)\nHEADERS_SENDING: ret=125 conn=0x7f655c000b90 wb_ready=125 write_send_off_before=0 write_append=125\nHEADERS_SENDING: sent headers only conn=0x7f655c000b90 new_send_off=125\nENTRY: MHD_connection_handle_write conn=0x7f655c000b90 state=13 rq.url=0x7f655c000e14 daemon=0x5577af926a60 write_send=0 write_append=125 rp.response=0x7f655c008f40 rsp_write_pos=0 keepalive\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation (that many pointer-typed objects are only read in the logged runs) is factually accurate for the exercised execution paths, but the MISRA 8.13 claim is not correct in context. The function does not safely allow changing the pointee types to const: for example the code takes &response->mutex and calls MHD_mutex_lock_chk_/MHD_mutex_unlock_chk_ (in NORMAL_BODY_READY), which requires a mutable (non-const) mutex member of the pointed-to MHD_Response object. That defeats making response a pointer-to-const. The local resp variable is already a const pointer (struct MHD_Response *const resp), not a pointer-to-const; changing it to const struct MHD_Response * would break the mutex lock/unlock calls (and likely other API calls that expect mutable members). Also members such as connection->write_buffer, response->data_iov, etc. are part of larger objects used elsewhere for mutation; the rule \u201cshould point to const whenever possible\u201d is applied across the program and not just per single read-only call-sequence. Given these uses, the pointers cannot be safely const-qualified and hence there is no MISRA 8.13 violation here. Therefore the report is not correct."
}