{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If MHD_VECT_SEND is not defined, the prior #if branch reduces to 'if (true)' which returns from the function, so the subsequent #else branch (mhd_assert(false); return MHD_ERR_CONNRESET_;) is never reachable in that build. This constitutes unreachable code and thus violates MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const struct MHD_Connection *connection, const char *point)\n{\n  FILE *f = fopen (\"/tmp/logs/273.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"PROBE: %s\\n\", point);\n  if (NULL == connection)\n  {\n    fprintf (f, \"  connection: NULL\\n\\n\");\n    fclose (f);\n    return;\n  }\n\n  fprintf (f, \"  connection=%p\\n\", (const void *) connection);\n  fprintf (f, \"  state=%d suspended=%d\\n\", (int) connection->state,\n           (int) connection->suspended);\n#ifdef HTTPS_SUPPORT\n  fprintf (f, \"  tls_state=%d\\n\", (int) connection->tls_state);\n#endif\n  /* Safe prints of offsets/indices that are commonly present in the struct. */\n  fprintf (f, \"  continue_message_write_offset=%zu\\n\",\n           (size_t) connection->continue_message_write_offset);\n  fprintf (f, \"  write_buffer_append_offset=%zu write_buffer_send_offset=%zu\\n\",\n           (size_t) connection->write_buffer_append_offset,\n           (size_t) connection->write_buffer_send_offset);\n\n  /* rp and response may be present; check their pointers before deref. */\n  fprintf (f, \"  rp.response=%p rp.rsp_write_position=%zu\\n\",\n           (void *) connection->rp.response,\n           (size_t) connection->rp.rsp_write_position);\n  if (NULL != connection->rp.response)\n  {\n    const struct MHD_Response *resp = connection->rp.response;\n    fprintf (f, \"    response.total_size=%zu data_size=%zu data_start=%zu\\n\",\n             (size_t) resp->total_size,\n             (size_t) resp->data_size,\n             (size_t) resp->data_start);\n    fprintf (f, \"    response.crc=%p response.data_iov=%p\\n\",\n             (void *) resp->crc,\n             (void *) resp->data_iov);\n  }\n\n  /* Print some request related info if available. Avoid dereferencing NULLs. */\n  fprintf (f, \"  rq.url=%p daemon=%p\\n\",\n           (void *) connection->rq.url,\n           (void *) connection->daemon);\n\n  fprintf (f, \"---\\n\");\n  fclose (f);\n}\n\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n\n  /* Entry probe */\n  mhd_probe_log (connection, \"entry\");\n\n  if (connection->suspended)\n  {\n    mhd_probe_log (connection, \"early-return: suspended\");\n    return;\n  }\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      mhd_probe_log (connection, \"before-tls-handshake\");\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        mhd_probe_log (connection, \"early-return: tls-handshake-failed\");\n        return;\n      }\n      mhd_probe_log (connection, \"after-tls-handshake-success\");\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_probe_log (connection, \"assert-case: initial/request-headers states\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      mhd_probe_log (connection, \"continue-sending: ret<0\");\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        mhd_probe_log (connection, \"continue-sending: would-block (AGAIN)\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      mhd_probe_log (connection, \"continue-sending: fatal send error, closing\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    mhd_probe_log (connection, \"continue-sending: success and returning\");\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_probe_log (connection, \"assert-case: body/footers/full-req states\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_probe_log (connection, \"assert-case: start-reply\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      mhd_probe_log (connection, \"headers-sending: enter\");\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        mhd_probe_log (connection, \"headers-sending: ret<0\");\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          mhd_probe_log (connection, \"headers-sending: would-block (AGAIN)\");\n          return;\n        }\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        mhd_probe_log (connection, \"headers-sending: fatal error, closing\");\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      mhd_probe_log (connection, \"headers-sending: done, checking state\");\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      mhd_probe_log (connection, \"headers-sending: after check_write_done\");\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    mhd_probe_log (connection, \"headers-sent: nothing to do, return\");\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        mhd_probe_log (connection, \"normal-body-ready: try_ready_normal_body deferred\");\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        mhd_probe_log (connection, \"normal-body-ready: ret<0\");\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          mhd_probe_log (connection, \"normal-body-ready: would-block (AGAIN)\");\n          return;\n        }\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        mhd_probe_log (connection, \"normal-body-ready: fatal error, closing\");\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    mhd_probe_log (connection, \"normal-body-ready: done\");\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_probe_log (connection, \"assert-case: normal-body-unready\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      mhd_probe_log (connection, \"chunked-body-ready: ret<0\");\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        mhd_probe_log (connection, \"chunked-body-ready: would-block (AGAIN)\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      mhd_probe_log (connection, \"chunked-body-ready: fatal error, closing\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    mhd_probe_log (connection, \"chunked-body-ready: after check_write_done\");\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_probe_log (connection, \"assert-case: chunked-body-unready/sent\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      mhd_probe_log (connection, \"footers-sending: ret<0\");\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        mhd_probe_log (connection, \"footers-sending: would-block (AGAIN)\");\n        return;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      mhd_probe_log (connection, \"footers-sending: fatal error, closing\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    mhd_probe_log (connection, \"footers-sending: done\");\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_probe_log (connection, \"assert-case: full-reply-sent\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    mhd_probe_log (connection, \"closed: return\");\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_probe_log (connection, \"assert-case: upgrade\");\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_probe_log (connection, \"default: internal error path\");\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  mhd_probe_log (connection, \"function-exit-end\");\n  return;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nPROBE: entry\n  connection=0x55d46cc4f870\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc57b40 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc4f2b0\n---\nPROBE: headers-sending: enter\n  connection=0x55d46cc4f870\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc57b40 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc4f2b0\n---\nPROBE: headers-sending: done, checking state\n  connection=0x55d46cc4f870\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=125\n  rp.response=0x55d46cc57b40 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc4f2b0\n---\nPROBE: headers-sending: after check_write_done\n  connection=0x55d46cc4f870\n  state=14 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=0 write_buffer_send_offset=0\n  rp.response=0x55d46cc57b40 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc4f2b0\n---\nPROBE: entry\n  connection=0x55d46cc58500\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc58750 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc58080\n---\nPROBE: headers-sending: enter\n  connection=0x55d46cc58500\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc58750 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc58080\n---\nPROBE: headers-sending: done, checking state\n  connection=0x55d46cc58500\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=125\n  rp.response=0x55d46cc58750 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc58080\n---\nPROBE: headers-sending: after check_write_done\n  connection=0x55d46cc58500\n  state=14 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=0 write_buffer_send_offset=0\n  rp.response=0x55d46cc58750 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc4fb14 daemon=0x55d46cc58080\n---\nPROBE: entry\n  connection=0x55d46cc4fb10\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc58d10 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc58f34 daemon=0x55d46cc58890\n---\nPROBE: headers-sending: enter\n  connection=0x55d46cc4fb10\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=0\n  rp.response=0x55d46cc58d10 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) response.data_iov=(nil)\n  rq.url=0x55d46cc58f34 daemon=0x55d46cc58890\n---\nPROBE: headers-sending: done, checking state\n  connection=0x55d46cc4fb10\n  state=13 suspended=0\n  continue_message_write_offset=0\n  write_buffer_append_offset=125 write_buffer_send_offset=125\n  rp.response=0x55d46cc58d10 rp.rsp_write_position=0\n    response.total_size=0 data_size=0 data_start=0\n    response.crc=(nil) resp\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported. The provided MHD_connection_handle_write sample contains many state-driven branches (mhd_assert(0) cases) that are potentially reachable when the connection.state assumes those values; they are not inherently unreachable. The reported scenario about an #if/#else producing an unconditional 'if (true) return' and leaving an unreachable else branch does not match this translation unit or is not evidenced by the exhaustive test runs. The probe logs show the headers-sending path executing normally (enter \u2192 done, check_write_done \u2192 after check_write_done) for multiple connections; no evidence of a statically unreachable else branch in this function was observed. Therefore Agent A\u2019s report that this function violates MISRA C 2023 Rule 2.1 is incorrect."
}