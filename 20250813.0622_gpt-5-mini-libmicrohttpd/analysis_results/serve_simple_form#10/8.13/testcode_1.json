{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe parameter is declared as 'struct Session *session' (non-const). MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible. If serve_simple_form and any callees (for example add_session_cookie) do not modify the Session object through this pointer, this is a violation \u2014 the parameter should be declared as 'const struct Session *session'. If the function or its callees intentionally modify the Session object, then the non-const pointer is justified and no violation occurs.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified serve_simple_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/83.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of serve_simple_form as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of serve_simple_form:\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified serve_simple_form code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Minimal forward declarations so this translation unit compiles standalone. */\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0 };\nstruct MHD_Response;\nstruct MHD_Connection;\nstruct Session;\n\n/* External functions (implemented elsewhere in the real program). */\nstruct MHD_Response *MHD_create_response_from_buffer_static (size_t, const char *);\nint MHD_add_response_header (struct MHD_Response *, const char *, const char *);\nenum MHD_Result MHD_queue_response (struct MHD_Connection *, int, struct MHD_Response *);\nvoid MHD_destroy_response (struct MHD_Response *);\nvoid add_session_cookie (struct Session *session, struct MHD_Response *response);\n\n/*\n * Probe helper: append a log entry describing the control path and some\n * state about the Session pointer and other local pointers. The log file\n * is /tmp/logs/83.txt as requested.\n */\nstatic void\nlog_probe(const char *stage,\n          const char *mime,\n          const void *cls,\n          struct Session *session,\n          struct MHD_Response *response,\n          struct MHD_Connection *connection,\n          const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/83.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  /* Basic header for each probe line */\n  fprintf(f, \"[serve_simple_form] stage=%s mime=%s cls=%p session=%p response=%p connection=%p\\n\",\n          stage, mime ? mime : \"(null)\", cls, (void *)session, (void *)response,\n          (void *)connection);\n\n  if (extra && extra[0] != '\\0')\n    fprintf(f, \"  info: %s\\n\", extra);\n\n  /* If session pointer is non-NULL, attempt to log first up to 16 bytes in hex.\n     We guard by checking the pointer; dereferencing may still be unsafe in\n     some exotic contexts, but this provides useful diagnostic output in\n     typical cases without changing program logic. */\n  if (session != NULL) {\n    unsigned char buf[16];\n    /* Copy memory carefully; using memcpy to avoid strict-aliasing issues. */\n    memcpy(buf, (const void *)session, sizeof(buf));\n    fprintf(f, \"  session[0..15] =\");\n    for (size_t i = 0; i < sizeof(buf); ++i)\n      fprintf(f, \" %02x\", (unsigned)buf[i]);\n    fprintf(f, \"\\n\");\n  } else {\n    fprintf(f, \"  session is NULL\\n\");\n  }\n\n  fclose(f);\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* Log entry to show function start and input state. */\n  log_probe(\"entry\", mime, cls, session, NULL, connection, \"entering serve_simple_form\");\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n\n  /* Log after creating the response object. */\n  log_probe(\"after_create_response\", mime, cls, session, response, connection, \"created response\");\n\n  /* Probe before calling add_session_cookie to capture whether any change\n     occurs to the session via the callee (we log before and after). */\n  log_probe(\"before_add_session_cookie\", mime, cls, session, response, connection, \"about to call add_session_cookie\");\n  add_session_cookie (session, response);\n  log_probe(\"after_add_session_cookie\", mime, cls, session, response, connection, \"returned from add_session_cookie\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               \"Content-Type\",\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n    log_probe(\"header_failed\", mime, cls, session, response, connection, \"failed to set content type header\");\n  } else {\n    log_probe(\"header_set\", mime, cls, session, response, connection, \"content type header set\");\n  }\n\n  ret = MHD_queue_response (connection,\n                            200,\n                            response);\n\n  /* Log result of queuing the response and final session state. */\n  if (&ret != NULL) { /* trivial use to avoid unused-variable warnings in some builds */ }\n  log_probe(\"after_queue_response\", mime, cls, session, response, connection, \"queued response\");\n\n  MHD_destroy_response (response);\n\n  log_probe(\"exit\", mime, cls, session, NULL, connection, \"exiting serve_simple_form\");\n\n  return ret;\n}\n"
}