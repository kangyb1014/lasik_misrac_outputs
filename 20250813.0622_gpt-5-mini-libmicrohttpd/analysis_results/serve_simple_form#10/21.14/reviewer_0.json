{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp(hdr->value, \"close\", 5) to check for the string \"close\". hdr->value is a null-terminated header value (a C string). Using memcmp on C strings is exactly what MISRA C 2023 Rule 21.14 forbids. A concrete problematic case: if hdr->value contains \"closer\" (i.e. not equal as a null-terminated string) memcmp(...,5) will return 0 because the first 5 characters match, so the memcmp-based test is semantically different from a proper string comparison and violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *event,\n           const char *mime,\n           const char *form,\n           const void *session,\n           const void *connection,\n           const void *response,\n           int header_ok,\n           enum MHD_Result ret)\n{\n  FILE *f = fopen(\"/tmp/logs/86.txt\", \"a\");\n  if (f == NULL)\n  {\n    /* best-effort logging only; do not alter program flow */\n    return;\n  }\n\n  size_t form_len = (form != NULL) ? strlen (form) : 0;\n  fprintf (f, \"event=%s mime_ptr=%p form_len=%zu form_prefix=\\\"\", event, (const void *) mime, form_len);\n\n  /* print up to first 128 characters of the form safely */\n  if (form != NULL)\n  {\n    size_t i;\n    for (i = 0; i < form_len && i < 128; ++i)\n    {\n      unsigned char c = (unsigned char) form[i];\n      /* make logs single-line and visible */\n      if (c >= 32 && c <= 126)\n      {\n        fputc (c, f);\n      }\n      else if (c == '\\t')\n      {\n        fputs (\"\\\\t\", f);\n      }\n      else if (c == '\\n')\n      {\n        fputs (\"\\\\n\", f);\n      }\n      else\n      {\n        fputc ('.', f);\n      }\n    }\n    if (form_len > 128)\n    {\n      fputs(\"...\", f);\n    }\n  }\n\n  fprintf (f, \"\\\" session=%p connection=%p response=%p header_ok=%d ret=%d\\n\",\n           session, connection, response, header_ok, (int) ret);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* entry probe */\n  probe_log (\"enter\", mime, form, session, connection, NULL, -1, (enum MHD_Result) -1);\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n  add_session_cookie (session, response);\n\n  /* probe before adding header */\n  probe_log (\"before_add_header\", mime, form, session, connection, response, -1, (enum MHD_Result) -1);\n\n  /* call once and preserve original behavior */\n  int add_ok = MHD_add_response_header (response,\n                                        MHD_HTTP_HEADER_CONTENT_TYPE,\n                                        mime);\n  if (MHD_YES != add_ok)\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n\n  /* probe after header step */\n  probe_log (\"after_add_header\", mime, form, session, connection, response, add_ok, (enum MHD_Result) -1);\n\n  probe_log (\"before_queue\", mime, form, session, connection, response, add_ok, (enum MHD_Result) -1);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log (\"after_queue\", mime, form, session, connection, response, add_ok, ret);\n\n  MHD_destroy_response (response);\n\n  /* exit probe */\n  probe_log (\"exit\", mime, form, session, connection, NULL, add_ok, ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 R.21.14 prohibits using memcmp to compare null\u2011terminated C strings. The provided serve_simple_form implementation does not call memcmp at all \u2014 it uses strlen, MHD_create_response_from_buffer_static, MHD_add_response_header, MHD_queue_response, etc. The violation scenario quoted by agent A (memcmp(hdr->value, \"close\", 5)) describes a different snippet and is not present in the shown serve_simple_form code. Therefore the reported violation does not apply to the shown function. (If memcmp were present elsewhere in the codebase comparing a NUL\u2011terminated string against a literal, that would be a valid R.21.14 violation \u2014 but not here.)"
}