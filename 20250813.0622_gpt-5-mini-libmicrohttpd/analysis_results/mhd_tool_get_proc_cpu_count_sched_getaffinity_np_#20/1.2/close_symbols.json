{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_np_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY_NP) && defined(HAVE_GETPID)\n  /* NetBSD style */\n  cpuset_t *cpuset_ptr;\n  cpuset_ptr = cpuset_create ();\n  if (NULL != cpuset_ptr)\n  {\n    if (0 == sched_getaffinity_np (getpid (), cpuset_size (cpuset_ptr),\n                                   cpuset_ptr))\n    {\n      cpuid_t cpu_num;\n#if defined(HAVE_SYSCONF) && defined(HAVE_DECL__SC_NPROCESSORS_CONF)\n      unsigned int max_num = 0;\n      long sc_value;\n      sc_value = sysconf (_SC_NPROCESSORS_ONLN);\n      if (0 < sc_value)\n        max_num = (unsigned int) sc_value;\n      if (0 < max_num)\n      {\n        ret = 0;\n        for (cpu_num = 0; cpu_num < max_num; ++cpu_num)\n          if (0 < cpuset_isset (cpu_num, cpuset_ptr))\n            ++ret;\n      }\n      else /* Combined with the next 'if' */\n#endif /* HAVE_SYSCONF && HAVE_DECL__SC_NPROCESSORS_CONF */\n      if (1)\n      {\n        int res;\n        cpu_num = 0;\n        ret = 0;\n        do\n        {\n          res = cpuset_isset (cpu_num++, cpuset_ptr);\n          if (0 < res)\n            ++ret;\n        } while (0 <= res);\n      }\n#ifdef __NetBSD__\n      if (0 == ret)\n      {\n        /* On NetBSD \"unset\" affinity (exactly zero CPUs) means\n           \"all CPUs are available\". */\n        ret = mhd_tool_get_sys_cpu_count_sysctl_ ();\n      }\n#endif /* __NetBSD__ */\n    }\n    cpuset_destroy (cpuset_ptr);\n  }\n#endif /* HAVE_SCHED_GETAFFINITY_NP && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "cpuset_t",
    "cpuset_create",
    "cpuset_destroy",
    "cpuset_size",
    "cpuset_isset",
    "sched_getaffinity_np",
    "getpid",
    "cpuid_t",
    "sysconf",
    "_SC_NPROCESSORS_ONLN",
    "mhd_tool_get_sys_cpu_count_sysctl_",
    "HAVE_SCHED_GETAFFINITY_NP",
    "HAVE_GETPID",
    "HAVE_SYSCONF",
    "HAVE_DECL__SC_NPROCESSORS_CONF",
    "__NetBSD__"
  ],
  "explanation": "Each listed symbol is referenced directly (or via preprocessor condition) by the target function and must be inspected to decide whether any compiler/language extensions are used: \n\n- cpuset_t: need the typedef/definition to check for any non\u2011standard type qualifiers, extension keywords or compiler-specific attributes used in its declaration.  \n- cpuset_create: could be a macro, inline function, or function with compiler-specific constructs (statement expressions, GCC attributes); its definition may use language extensions.  \n- cpuset_destroy: same rationale as cpuset_create (macro/inline or attributes).  \n- cpuset_size: often a macro; its expansion may use non\u2011standard extensions (sizeof tricks, statement expressions, typeof, etc.).  \n- cpuset_isset: frequently implemented as a macro returning integer; its implementation may rely on extensions (e.g. GCC statement-expression or typeof).  \n- sched_getaffinity_np: declaration may carry compiler attributes or be a non\u2011standard library extension; check prototype for attributes or extension annotations.  \n- getpid: check its prototype/headers for any non\u2011standard attributes (rare but necessary to rule out extensions).  \n- cpuid_t: need the typedef to check for unusual compiler extensions in the type definition.  \n- sysconf: declaration/prototype may use macros or attributes; verify no language extensions are present.  \n- _SC_NPROCESSORS_ONLN: macro value/definition comes from headers; check for any non\u2011standard macro usage.  \n- mhd_tool_get_sys_cpu_count_sysctl_: this internal function is called conditionally; its declaration/definition must be inspected to ensure it does not use language extensions that affect the analyzed behavior.  \n- HAVE_SCHED_GETAFFINITY_NP, HAVE_GETPID, HAVE_SYSCONF, HAVE_DECL__SC_NPROCESSORS_CONF: these preprocessor symbols control compilation of blocks; you must know how they are defined (often by configure) to see which code paths are present and to inspect the corresponding code for extensions.  \n- __NetBSD__: compiler predefined macro that enables a NetBSD-specific branch; knowing whether this macro is defined determines whether the NetBSD-specific call (and any extensions it may use) must be analyzed.\n\nInspecting the definitions/prototypes of these symbols (and the headers that provide them) is sufficient to determine whether the target function or any code it depends on uses language extensions forbidden by the MISRA rule."
}