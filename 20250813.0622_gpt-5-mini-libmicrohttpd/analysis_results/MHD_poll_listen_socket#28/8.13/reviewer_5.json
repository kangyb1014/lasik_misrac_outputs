{
  "user_message": "An agent A claimed that the following MHD_poll_listen_socket code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_poll_listen_socket.\n```c\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void) resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_YES;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"poll failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The rule would be violated if the error-string function or the logging API use non-const pointers for read-only strings. For example, if MHD_socket_strerr_ is declared as `char *MHD_socket_strerr_(int err)` (returning a non-const pointer to a read-only/static error message) or if MHD_DLOG takes a non-const `char *` for its format/argument strings, then pointers to these immutable strings are not const-qualified and Rule 8.13 is violated. If both MHD_socket_strerr_ and MHD_DLOG are correctly declared to use `const char *`, there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nconst MHD_socket MHD_INVALID_SOCKET = -1;\nstruct MHD_ThreadHandle_ID { int dummy; };\nextern void mhd_assert (int);\nextern int MHD_thread_handle_ID_is_valid_ID_ (struct MHD_ThreadHandle_ID);\nextern int MHD_thread_handle_ID_is_current_thread_ (struct MHD_ThreadHandle_ID);\nextern int MHD_ITC_IS_VALID_ (struct MHD_Daemon *);\nextern int MHD_itc_r_fd_ (struct MHD_Daemon *);\nextern void MHD_itc_clear_ (struct MHD_Daemon *);\nextern int MHD_sys_poll_ (struct pollfd *, unsigned int, int);\nextern int MHD_socket_get_error_ (void);\nextern int MHD_SCKT_ERR_IS_EINTR_ (int);\nextern const char *MHD_socket_strerr_ (int);\nextern const char * _ (const char *msg);\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/227.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  time_t t = time (NULL);\n  struct tm *tm = localtime (&t);\n  if (tm)\n    fprintf (f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n             tm->tm_year + 1900,\n             tm->tm_mon + 1,\n             tm->tm_mday,\n             tm->tm_hour,\n             tm->tm_min,\n             tm->tm_sec);\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n                        int may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  mhd_assert (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid));\n  mhd_assert (MHD_thread_handle_ID_is_current_thread_ (daemon->tid));\n\n  /* Log entry and initial state */\n  mhd_probe_log (\"enter MHD_poll_listen_socket: daemon=%p, may_block=%d, listen_fd=%p, was_quiesced=%d, itc=%p, options=0x%08x\",\n                 (void *) daemon,\n                 may_block,\n                 /* listen_fd is an integral socket type; print via intptr_t cast */\n                 (void *) (intptr_t) daemon->listen_fd,\n                 (int) daemon->was_quiesced,\n                 /* daemon->itc is an aggregate; print its address to avoid treating it as an integer */\n                 (void *) &daemon->itc,\n                 (unsigned) daemon->options);\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n  {\n    p[poll_count].fd = ls;\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_listen = (int) poll_count;\n    poll_count++;\n  }\n  if (MHD_ITC_IS_VALID_ (daemon))\n  {\n    p[poll_count].fd = MHD_itc_r_fd_ (daemon);\n    p[poll_count].events = POLLIN;\n    p[poll_count].revents = 0;\n    poll_itc_idx = (int) poll_count;\n    poll_count++;\n  }\n\n  /* Log pollfd table after setup */\n  for (unsigned int i = 0; i < poll_count; ++i)\n    mhd_probe_log (\"pollfd[%u]: fd=%d, events=0x%x, revents=0x%x\",\n                   i,\n                   p[i].fd,\n                   p[i].events,\n                   p[i].revents);\n  mhd_probe_log (\"poll_count=%u, poll_listen=%d, poll_itc_idx=%d\",\n                 poll_count,\n                 poll_listen,\n                 poll_itc_idx);\n\n  /* Assume option mask check is done elsewhere; keep behavior */\n  if (0 != (daemon->options & 0)) /* placeholder bitmask check avoided here */\n    (void) resume_suspended_connections (daemon);\n\n  if (may_block == 0)\n    timeout = 0;\n  else\n    timeout = -1;\n\n  mhd_probe_log (\"will call poll with timeout=%d\", timeout);\n\n  if (0 == poll_count)\n  {\n    mhd_probe_log (\"no fds to poll, returning MHD_YES\");\n    return MHD_YES;\n  }\n  if (MHD_sys_poll_ (p,\n                     poll_count,\n                     timeout) < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    mhd_probe_log (\"poll returned error, err=%d\", err);\n\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_probe_log (\"poll interrupted by signal (EINTR), returning MHD_YES\");\n      return MHD_YES;\n    }\n#ifdef HAVE_MESSAGES\n    {\n      /* Capture error string as const char * to avoid treating read-only strings as modifiable */\n      const char *errstr = MHD_socket_strerr_ (err);\n      if (NULL == errstr)\n        errstr = \"(null)\";\n      mhd_probe_log (\"poll failed: %s\", errstr);\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                errstr);\n    }\n#else\n    /* If HAVE_MESSAGES is not defined, still log the numeric error for evidence */\n    mhd_probe_log (\"poll failed (no message subsystem): err=%d\", err);\n#endif\n    return MHD_NO;\n  }\n\n  /* Log results from poll */\n  for (unsigned int i = 0; i < poll_count; ++i)\n    mhd_probe_log (\"after poll: pollfd[%u]: fd=%d, events=0x%x, revents=0x%x\",\n                   i,\n                   p[i].fd,\n                   p[i].events,\n                   p[i].revents);\n\n  if ( (0 <= poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n  {\n    mhd_probe_log (\"itc fd %d has POLLIN, clearing itc\", p[poll_itc_idx].fd);\n    MHD_itc_clear_ (daemon->itc ? &daemon->itc : &daemon->itc); /* keep type-compatibility */\n  }\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n  {\n    mhd_probe_log (\"daemon->shutdown is set, returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n  {\n    mhd_probe_log (\"daemon->have_new is set, calling new_connections_list_process_\");\n    new_connections_list_process_ (daemon);\n  }\n\n  if ( (0 <= poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n  {\n    mhd_probe_log (\"listen fd %d has POLLIN, calling MHD_accept_connection\", p[poll_listen].fd);\n    (void) MHD_accept_connection (daemon);\n  }\n  mhd_probe_log (\"exiting MHD_poll_listen_socket with MHD_YES\");\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Conclusion: Agent A\u2019s claim is not definitively correct. The snippet shown does not itself create any non-const pointer variables or assignments that obviously violate MISRA C 2023 Rule 8.13. The only places where const-qualification matters are the external APIs used for messages: MHD_socket_strerr_, the _() message macro and MHD_DLOG. If those external declarations are const-correct (i.e. they return/accept const char * for immutable/static messages and format strings), then no Rule 8.13 violation occurs in this function. If, however, MHD_socket_strerr_ were declared to return char * (non-const) or MHD_DLOG\u2019s prototype accepted non-const char * for read-only format/argument strings, then that would be a violation (the code is effectively dealing with read-only strings and the pointer types should be const-qualified). In other words Agent A\u2019s scenario is possible, but the report as stated (that this function violates Rule 8.13) is not supported by the code shown \u2014 it only becomes a violation if the external APIs are declared non-const. Recommended action: ensure the prototypes for MHD_socket_strerr_, _() and MHD_DLOG use const char * for read-only strings to satisfy Rule 8.13."
}