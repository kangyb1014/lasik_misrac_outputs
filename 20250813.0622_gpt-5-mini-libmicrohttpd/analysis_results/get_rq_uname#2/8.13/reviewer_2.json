{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The field uname_info->userhash_hex is used only as an input (read-only) argument to MHD_hex_to_bin but is declared as char * (non-const). Since the pointed-to data is not modified, the pointer should be const-qualified (e.g. const char *userhash_hex). Passing a non-const pointer where a const-qualified pointer is appropriate violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/19.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  /* Log entry and key inputs */\n  mhd_probe_log(\"ENTER get_rq_uname: params=%p uname_type=%d uname_info=%p buf=%p buf_size=%zu\",\n                (void *) params, (int) uname_type, (void *) uname_info, (void *) buf, buf_size);\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  mhd_probe_log(\"initialised uname_info: username=%p username_len=%zu userhash_hex=%p userhash_hex_len=%zu userhash_bin=%p\",\n                (void *) uname_info->username, uname_info->username_len,\n                (void *) uname_info->userhash_hex, uname_info->userhash_hex_len,\n                (void *) uname_info->userhash_bin);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    mhd_probe_log(\"branch: STANDARD\");\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    mhd_probe_log(\"copied username: dest=%p len=%zu\",\n                  (void *) uname_info->username, uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    mhd_probe_log(\"branch: USERHASH\");\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    mhd_probe_log(\"copied userhash_hex: dest=%p hex_len=%zu (hex content pointer)\",\n                  (void *) uname_info->userhash_hex, uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n\n    mhd_probe_log(\"about to call MHD_hex_to_bin: hex_ptr=%p hex_len=%zu bin_ptr=%p\",\n                  (void *) uname_info->userhash_hex, uname_info->userhash_hex_len,\n                  (void *) uname_info->userhash_bin);\n\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n\n    mhd_probe_log(\"MHD_hex_to_bin returned: res=%zu (expected=%zu)\",\n                  res, uname_info->userhash_hex_len / 2);\n\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      mhd_probe_log(\"hex conversion failed: invalid length, marking invalid\");\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      mhd_probe_log(\"hex conversion succeeded: userhash_bin=%p buf_used=%zu uname_type=%d\",\n                    (void *) uname_info->userhash_bin, buf_used, (int) uname_info->uname_type);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    mhd_probe_log(\"branch: EXTENDED (username_ext at %p)\", (void *) &params->username_ext);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    mhd_probe_log(\"get_rq_extended_uname_copy_z returned: res=%zd\", res);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      mhd_probe_log(\"extended username copied: username=%p username_len=%zu buf_used=%zu\",\n                    (void *) uname_info->username, uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    mhd_probe_log(\"branch: UNKNOWN - asserted and marked invalid\");\n  }\n  mhd_assert (buf_size >= buf_used);\n\n  mhd_probe_log(\"EXIT get_rq_uname: final uname_type=%d buf_used=%zu username=%p username_len=%zu userhash_hex=%p userhash_hex_len=%zu userhash_bin=%p\",\n                (int) uname_info->uname_type, buf_used,\n                (void *) uname_info->username, uname_info->username_len,\n                (void *) uname_info->userhash_hex, uname_info->userhash_hex_len,\n                (void *) uname_info->userhash_bin);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA Rule 8.13 concerns how pointers are declared overall (they should be const-qualified when the pointed-to object is not modified). The snippet shows uname_info->userhash_hex is used as a read-only argument to MHD_hex_to_bin, but that alone is not sufficient to conclude a violation: (1) we do not have the declaration of struct MHD_DigestAuthUsernameInfo in the submission, nor visibility of all uses of userhash_hex elsewhere in the translation unit/program; it may be intended to point at mutable storage (buf) or be modified by other code, so changing the field to const char * might be incorrect. (2) Passing a non-const char * to a function that accepts const char * is allowed in C and is not itself a MISRA 8.13 violation \u2014 the rule targets pointer declarations, not call sites. (3) The provided test/instrumentation did not execute the function (empty log), so it gives no evidence that the field is in fact never used to modify the pointed data. To prove a Rule 8.13 violation you must show that the pointer is declared non-const and that, across the whole program, the pointed-to object is never modified through that pointer (so the declaration could safely be const). That proof is not present here. If in the broader codebase the field is truly read-only, the correct remediation would be to change the struct field to const char * and update all call sites; however, based on the data given, the report is not correct."
}