{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignment uname_info->userhash_hex_len = 0; is redundant (dead) because all current call sites pass a zero-initialized MHD_DigestAuthUsernameInfo: callers allocate with MHD_calloc_ (zeroed) or explicitly memset the stack structure to 0. Inside get_rq_uname the field is either overwritten in the USERHASH branch or remains zero (already ensured by the caller). Therefore removing this single assignment would not change program behaviour, so it constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n\n  /* Ensure directory exists; ignore errors if cannot create. */\n  (void) mkdir(\"/tmp/logs\", (mode_t)0755);\n\n  f = fopen(\"/tmp/logs/18.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  /* Log entry. Do not dereference uname_info fields here to avoid UB if\n     callers did not zero-initialize; just log pointer and uname_type. */\n  log_probe (\"ENTER get_rq_uname: uname_info=%p, uname_type=%d, buf=%p, buf_size=%zu\",\n             (void *) uname_info, (int) uname_type, (void *) buf, buf_size);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  /* The assignment below is the one reported as redundant. Log that it is\n     performed so callers and reviewers can observe the write. */\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  /* Log state after initialization assignments (safe because we just set them) */\n  log_probe (\"AFTER init assignments: username=%p, username_len=%zu, userhash_hex=%p, userhash_hex_len=%zu, userhash_bin=%p\",\n             (void *) uname_info->username,\n             uname_info->username_len,\n             (void *) uname_info->userhash_hex,\n             uname_info->userhash_hex_len,\n             (void *) uname_info->userhash_bin);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n\n    /* Log STANDARD branch results */\n    log_probe (\"BRANCH STANDARD: username=%p, username_len=%zu, buf_used=%zu, uname_type=%d\",\n               (void *) uname_info->username,\n               uname_info->username_len,\n               buf_used,\n               (int) uname_info->uname_type);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    log_probe (\"ENTER USERHASH branch: buf_used=%zu\", buf_used);\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n\n    /* Log the overwrite of userhash_hex_len (evidence that previous set to 0 is overwritten) */\n    log_probe (\"USERHASH: after copy: userhash_hex=%p, userhash_hex_len=%zu\",\n               (void *) uname_info->userhash_hex,\n               uname_info->userhash_hex_len);\n\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n\n    log_probe (\"USERHASH: hex_to_bin res=%zu, expected=%zu\",\n               res, uname_info->userhash_hex_len / 2);\n\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      log_probe (\"USERHASH: invalid hex -> set uname_type INVALID, userhash_bin=NULL\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n\n      log_probe (\"USERHASH: success: userhash_bin=%p, uname_type=%d, buf_used=%zu\",\n                 (void *) uname_info->userhash_bin,\n                 (int) uname_info->uname_type,\n                 buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n\n      log_probe (\"EXTENDED: username=%p, username_len=%zu, uname_type=%d, buf_used=%zu\",\n                 (void *) uname_info->username,\n                 uname_info->username_len,\n                 (int) uname_info->uname_type,\n                 buf_used);\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    log_probe (\"BRANCH UNKNOWN: set uname_type INVALID\");\n  }\n  mhd_assert (buf_size >= buf_used);\n\n  /* Final state log before return */\n  log_probe (\"EXIT get_rq_uname: uname_info=%p final: username=%p, username_len=%zu, userhash_hex=%p, userhash_hex_len=%zu, userhash_bin=%p, uname_type=%d, buf_used=%zu, buf_size=%zu\",\n             (void *) uname_info,\n             (void *) uname_info->username,\n             uname_info->username_len,\n             (void *) uname_info->userhash_hex,\n             uname_info->userhash_hex_len,\n             (void *) uname_info->userhash_bin,\n             (int) uname_info->uname_type,\n             buf_used,\n             buf_size);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The write uname_info->userhash_hex_len = 0; is a defensive initialization executed on every call path and is not provably dead. To classify it as dead code under MISRA 2.2 you must show that removing that operation would never change program behaviour across the whole project. That requires whole-program knowledge that every caller always supplies a zero-initialized MHD_DigestAuthUsernameInfo (or otherwise guarantees the field has the correct value). The provided evidence (a runtime probe that did not even exercise the function) does not establish that invariant, and the function itself contains branches (STANDARD, EXTENDED and the error/unknown branch) that do not overwrite userhash_hex_len. Removing the assignment could therefore introduce uninitialized data usage or change behaviour if any caller fails to zero-initialize the structure or if future changes add a caller that does not. MISRA expects code to avoid relying on external fragile assumptions; this explicit initialization is a valid and necessary defensive operation, not dead code."
}