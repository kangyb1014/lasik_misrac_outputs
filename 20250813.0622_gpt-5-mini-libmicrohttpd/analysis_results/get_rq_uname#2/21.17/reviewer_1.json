{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation: potential out-of-bounds writes when the remaining buffer space is insufficient. get_rq_param_unquoted_copy_z() uses memcpy(buf, param->value.str, param->value.len) and then buf[param->value.len]=0 without the caller guaranteeing that buf has room for param->value.len+1 bytes. get_rq_uname() calls get_rq_param_unquoted_copy_z() with buf = buf + buf_used but does not check that buf_size >= buf_used + param->value.len + 1 before the call, so memcpy (from <string.h>) may write past the buffer \u2014 violating MISRA C 2023 Rule 21.17. Additionally, in the EXTENDED path MHD_str_pct_decode_strict_n_ can return w == buf_size (it may fill all buf_size bytes) and then the fragment buf[w] = 0 writes at buf[buf_size] (one past the end), causing an out-of-bounds store (this second issue is not a <string.h> function but also results in an out-of-bounds access).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_uname_state(const char *stage,\n                    const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type,\n                    uint8_t *buf,\n                    size_t buf_size,\n                    size_t buf_used)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf(f, \"[get_rq_uname] %s\\n\", stage);\n  fprintf(f, \"  uname_type=%d, buf=%p, buf_size=%zu, buf_used=%zu\\n\",\n          (int) uname_type, (void *) buf, buf_size, buf_used);\n  if (params)\n  {\n    /* Guarded prints in case the fields exist in the struct used by callers. */\n    fprintf(f, \"  params->username.value.str=%p, params->username.value.len=%zu\\n\",\n            (void *) params->username.value.str,\n            (size_t) params->username.value.len);\n    fprintf(f, \"  params->username_ext.value.str=%p, params->username_ext.value.len=%zu\\n\",\n            (void *) params->username_ext.value.str,\n            (size_t) params->username_ext.value.len);\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void\nmhd_log_after_param_copy(const char *stage,\n                         const struct MHD_RqDAuth *params,\n                         enum MHD_DigestAuthUsernameType uname_type,\n                         uint8_t *buf,\n                         size_t buf_size,\n                         size_t buf_used,\n                         size_t ret_len)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (!f)\n    return;\n  size_t remaining = 0;\n  if (buf_size >= buf_used)\n    remaining = buf_size - buf_used;\n  fprintf(f, \"[get_rq_uname] %s (after copy)\\n\", stage);\n  fprintf(f, \"  returned_len=%zu, remaining_space=%zu\\n\", ret_len, remaining);\n  if (ret_len + 1 > remaining)\n    fprintf(f, \"  WARNING: returned_len+1 (%zu) > remaining_space (%zu) -> possible overflow\\n\",\n            ret_len + 1, remaining);\n  else\n    fprintf(f, \"  OK: returned_len+1 (%zu) <= remaining_space (%zu)\\n\",\n            ret_len + 1, remaining);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void\nmhd_log_after_extended(const char *stage,\n                       const struct MHD_RqDAuth *params,\n                       enum MHD_DigestAuthUsernameType uname_type,\n                       uint8_t *buf,\n                       size_t buf_size,\n                       size_t buf_used,\n                       ssize_t res)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (!f)\n    return;\n  size_t remaining = 0;\n  if (buf_size >= buf_used)\n    remaining = buf_size - buf_used;\n  fprintf(f, \"[get_rq_uname] %s (after extended copy)\\n\", stage);\n  fprintf(f, \"  res=%zd, remaining_space=%zu\\n\", res, remaining);\n  if (res == (ssize_t) remaining)\n    fprintf(f, \"  WARNING: res == remaining_space (%zu) -> writing terminator at buf[buf_size] possible\\n\",\n            remaining);\n  else if (res > (ssize_t) remaining)\n    fprintf(f, \"  ERROR: res (%zd) > remaining_space (%zu) -> overflow already occurred\\n\",\n            res, remaining);\n  else\n    fprintf(f, \"  OK: res (%zd) < remaining_space (%zu)\\n\", res, remaining);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  /* Log entry state */\n  mhd_log_uname_state(\"entry\", params, uname_type, buf, buf_size, buf_used);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n\n    /* Log before invoking the copy helper */\n    mhd_log_uname_state(\"before STANDARD copy\", params, uname_type, buf, buf_size, buf_used);\n\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n\n    /* Log result and whether it would overflow given remaining space */\n    mhd_log_after_param_copy(\"STANDARD\", params, uname_type, buf, buf_size, buf_used, uname_info->username_len);\n\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n\n    /* Log before invoking the copy helper */\n    mhd_log_uname_state(\"before USERHASH copy\", params, uname_type, buf, buf_size, buf_used);\n\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n\n    /* Log result and whether it would overflow given remaining space */\n    mhd_log_after_param_copy(\"USERHASH\", params, uname_type, buf, buf_size, buf_used, uname_info->userhash_hex_len);\n\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n\n    /* Log before invoking the extended copy helper */\n    mhd_log_uname_state(\"before EXTENDED copy\", params, uname_type, buf, buf_size, buf_used);\n\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      /* Log the result and potential off-by-one terminator issue */\n      mhd_log_after_extended(\"EXTENDED\", params, uname_type, buf, buf_size, buf_used, res);\n\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  /* Log final state */\n  mhd_log_uname_state(\"exit\", params, uname_type, buf, buf_size, buf_used);\n\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report from agent A is correct. get_rq_uname calls helper get_rq_param_unquoted_copy_z without passing any remaining-buffer length; that helper (as described by the scenario) uses memcpy(dest, src, src_len) and then writes dest[src_len] = '\\0'. Since get_rq_uname does not check that buf_size - buf_used >= src_len + 1 before calling, the memcpy and the terminating write can write past the end of the supplied buffer \u2014 exactly the kind of out-of-bounds access of standard string/memory functions prohibited by MISRA C 2023 Rule 21.17.\n\nAdditionally, the EXTENDED path is also problematic: get_rq_extended_uname_copy_z is called with the remaining size (buf_size - buf_used) and may return res == remaining; get_rq_uname then assumes it can write a terminator at buf[buf_used + res] which is buf[buf_size] (one past the buffer). That is an off-by-one out-of-bounds store (not a <string.h> call, but still an actual out-of-bounds access).\n\nConclusion: the scenario is valid \u2014 the code as shown can lead to out-of-bounds writes and therefore violates MISRA C 2023 Rule 21.17 (for the memcpy case) and has an additional off-by-one OOB risk in the EXTENDED path."
}