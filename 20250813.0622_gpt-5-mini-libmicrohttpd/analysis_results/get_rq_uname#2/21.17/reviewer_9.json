{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When uname_type == MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD the code sets uname_info->username = buf + buf_used and then calls get_rq_param_unquoted_copy_z which does memcpy(buf, param->value.str, param->value.len) and writes a terminating NUL at buf[param->value.len]. There is no prior check that buf_size - buf_used >= param->value.len + 1, so if the provided buffer is smaller than required (e.g. an attacker-supplied or simply large params->username.value.len) the memcpy and subsequent NUL write will access beyond the destination buffer. The same pattern occurs in the USERHASH branch (hex string copied without checking remaining buf space, then binary bytes written). This can lead to out-of-bounds writes \u2014 a direct violation of MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe(const char *stage,\n              const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              const uint8_t *buf,\n              size_t buf_size,\n              size_t buf_used)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"STAGE=%s uname_type=%d buf=%p buf_size=%zu buf_used=%zu\\n\",\n          stage, (int) uname_type, (const void *) buf, buf_size, buf_used);\n  if (NULL != params)\n  {\n    /* Log username parameter length and a short hex/printable prefix (safe bounded read). */\n    size_t plen = (size_t) params->username.value.len;\n    fprintf(f, \"  param.username.value.len=%zu\\n\", plen);\n    if (0 < plen && NULL != params->username.value.str)\n    {\n      size_t to_log = plen > 32 ? 32 : plen;\n      fprintf(f, \"  param.username.value.str[0..%zu]=\\\"\", to_log);\n      for (size_t i = 0; i < to_log; ++i)\n      {\n        unsigned char c = (unsigned char) params->username.value.str[i];\n        /* print printable ASCII directly, else hex escape */\n        if (c >= 0x20 && c < 0x7f)\n          fputc(c, f);\n        else\n          fprintf(f, \"\\\\x%02x\", c);\n      }\n      if (plen > to_log)\n        fprintf(f, \"... (truncated)\\\"\");\n      else\n        fprintf(f, \"\\\"\");\n      fprintf(f, \"\\n\");\n    }\n  }\n  fflush(f);\n  fclose(f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  /* Log entry state */\n  mhd_log_probe(\"entry\", params, uname_type, buf, buf_size, buf_used);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    /* Log before the risky copy */\n    mhd_log_probe(\"before_standard_copy\", params, uname_type, buf, buf_size, buf_used);\n\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n\n    buf_used += uname_info->username_len + 1;\n\n    /* Log after the copy */\n    mhd_log_probe(\"after_standard_copy\", params, uname_type, buf, buf_size, buf_used);\n\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    /* Log before userhash processing */\n    mhd_log_probe(\"before_userhash_copy\", params, uname_type, buf, buf_size, buf_used);\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n\n    /* Log intermediate results */\n    mhd_log_probe(\"after_userhash_hex_to_bin\", params, uname_type, buf, buf_size, buf_used);\n\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n\n      /* Log invalid conversion */\n      mhd_log_probe(\"userhash_invalid\", params, uname_type, buf, buf_size, buf_used);\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n\n      /* Log successful userhash handling */\n      mhd_log_probe(\"userhash_success\", params, uname_type, buf, buf_size, buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n\n    /* Log before extended uname processing */\n    mhd_log_probe(\"before_extended_copy\", params, uname_type, buf, buf_size, buf_used);\n\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n\n      /* Log after extended copy */\n      mhd_log_probe(\"after_extended_copy\", params, uname_type, buf, buf_size, buf_used);\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n\n  /* Log exit state */\n  mhd_log_probe(\"exit\", params, uname_type, buf, buf_size, buf_used);\n\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. get_rq_uname does not ensure that there is enough remaining space in buf before calling helper functions that copy data into buf, so those helpers (if implemented using the standard string functions or raw memcpy/strcpy semantics) can write past the end of the destination buffer and therefore can produce out-of-bounds accesses covered by MISRA C 2023 Rule 21.17.\n\nReasoning:\n- In the STANDARD branch uname_info->username is set to buf + buf_used and get_rq_param_unquoted_copy_z is invoked with only the destination pointer. There is no check that the remaining size (buf_size - buf_used) is >= the number of bytes copied + 1 for the terminating NUL. If get_rq_param_unquoted_copy_z uses memcpy/strcpy-like operations (as the reporter stated), an out-of-bounds write can occur.\n- The USERHASH branch follows the same pattern for copying the hex string into the buffer: it calls get_rq_param_unquoted_copy_z without passing or checking remaining buffer space, then converts hex to binary and writes binary bytes into buf at buf + buf_used again without checking available space first. That also can overflow the destination buffer.\n- The EXTENDED branch does pass buf_size - buf_used to its helper, so that branch is safe in this respect; but the presence of that safe pattern highlights that the other branches lack the same protection.\n- The final mhd_assert(buf_size >= buf_used) only checks after writes have occurred and so does not prevent or prove absence of intermediate out-of-bounds writes.\n\nCaveat: Definitive confirmation requires inspection of the implementations of get_rq_param_unquoted_copy_z and MHD_hex_to_bin. If those functions themselves enforce bounds (e.g. by limiting bytes copied to available space even without an explicit size parameter), then no overflow would occur. However, based on the reported behavior (memcpy and NUL write) and the absence of any prior size check, the code as shown fails to guarantee that string/memory operations cannot access beyond the destination buffer, and thus the reported violation of MISRA C 2023 Rule 21.17 is valid.\n\nRecommended remediation: either check buf_size - buf_used before the copy(s) against the needed length (including the NUL), or change the helper(s) to accept a destination size and ensure they never write beyond it."
}