{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs when uname_type == MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD (or USERHASH) and the remaining buffer (buf_size - buf_used) is smaller than the source length + 1. get_rq_uname passes (buf + buf_used) to get_rq_param_unquoted_copy_z which unconditionally does memcpy(buf, param->value.str, param->value.len) and writes buf[param->value.len] = 0. Because there is no prior check that buf_size - buf_used >= param->value.len + 1 (mhd_assert is a no-op), the memcpy and the terminating write can write beyond the provided buffer; updating buf_used with buf_used += username_len + 1 only occurs after the out-of-bounds write. Thus Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe_get_rq_uname(const char *note,\n                           const struct MHD_RqDAuth *params,\n                           enum MHD_DigestAuthUsernameType uname_type,\n                           struct MHD_DigestAuthUsernameInfo *uname_info,\n                           uint8_t *buf,\n                           size_t buf_size,\n                           size_t buf_used,\n                           size_t param_len)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] %s\\n\", (long)t, note);\n  fprintf(f, \"  uname_type=%d, buf=%p, buf_size=%lu, buf_used=%lu\\n\",\n          (int) uname_type, (void *) buf, (unsigned long) buf_size,\n          (unsigned long) buf_used);\n  if (uname_info)\n  {\n    fprintf(f, \"  uname_info=%p, uname_info->username=%p, username_len=%lu, userhash_hex=%p, userhash_hex_len=%lu, userhash_bin=%p\\n\",\n            (void *) uname_info,\n            (void *) uname_info->username,\n            (unsigned long) uname_info->username_len,\n            (void *) uname_info->userhash_hex,\n            (unsigned long) uname_info->userhash_hex_len,\n            (void *) uname_info->userhash_bin);\n  }\n  fprintf(f, \"  param_len=%lu\\n\", (unsigned long) param_len);\n  fclose(f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  /* Log entry state */\n  mhd_log_probe_get_rq_uname(\"enter get_rq_uname\", params, uname_type,\n                             uname_info, buf, buf_size, buf_used, 0);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    size_t param_len = 0;\n\n    /* Try to capture the reported parameter length for diagnostics. */\n    /* Accessing params->username.value.len mirrors how the function uses the param. */\n    param_len = (size_t) params->username.value.len;\n\n    uname_info->username = (char *) (buf + buf_used);\n\n    mhd_log_probe_get_rq_uname(\"before get_rq_param_unquoted_copy_z (STANDARD)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, param_len);\n\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n\n    mhd_log_probe_get_rq_uname(\"after get_rq_param_unquoted_copy_z (STANDARD)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, (size_t) uname_info->username_len);\n\n    buf_used += uname_info->username_len + 1;\n\n    mhd_log_probe_get_rq_uname(\"after increment buf_used (STANDARD)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, (size_t) uname_info->username_len);\n\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n    size_t param_len = (size_t) params->username.value.len;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n\n    mhd_log_probe_get_rq_uname(\"before get_rq_param_unquoted_copy_z (USERHASH)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, param_len);\n\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n\n    mhd_log_probe_get_rq_uname(\"after get_rq_param_unquoted_copy_z (USERHASH)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, (size_t) uname_info->userhash_hex_len);\n\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n\n      mhd_log_probe_get_rq_uname(\"userhash hex->bin failed (USERHASH)\",\n                                 params, uname_type, uname_info, buf, buf_size,\n                                 buf_used, (size_t) uname_info->userhash_hex_len);\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n\n      mhd_log_probe_get_rq_uname(\"after processing USERHASH success\", params,\n                                 uname_type, uname_info, buf, buf_size,\n                                 buf_used, (size_t) uname_info->userhash_hex_len);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    size_t param_len = (size_t) params->username_ext.value.len;\n\n    mhd_log_probe_get_rq_uname(\"before get_rq_extended_uname_copy_z (EXTENDED)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, param_len);\n\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n\n    mhd_log_probe_get_rq_uname(\"after get_rq_extended_uname_copy_z (EXTENDED)\",\n                               params, uname_type, uname_info, buf, buf_size,\n                               buf_used, (res >= 0) ? (size_t) res : 0);\n\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n\n      mhd_log_probe_get_rq_uname(\"after increment buf_used (EXTENDED)\",\n                                 params, uname_type, uname_info, buf, buf_size,\n                                 buf_used, uname_info->username_len);\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n\n    mhd_log_probe_get_rq_uname(\"unexpected uname_type (else branch)\", params,\n                               uname_type, uname_info, buf, buf_size, buf_used, 0);\n  }\n  mhd_assert (buf_size >= buf_used);\n\n  mhd_log_probe_get_rq_uname(\"exit get_rq_uname\", params, uname_type,\n                             uname_info, buf, buf_size, buf_used, 0);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in the presented scenario. In the STANDARD and USERHASH branches the function computes a destination pointer uname_info->username (or userhash_hex) as (char *)(buf + buf_used) and then calls get_rq_param_unquoted_copy_z(dest) without passing the remaining buffer size or otherwise checking that buf_size - buf_used is large enough for the copied bytes plus the terminating NUL. The EXTENDED branch uses a bounded copy (passes buf_size - buf_used) and checks the return value, but the other branches do not. Since mhd_assert is a no-op in production builds, there is no reliable precondition check that prevents the helper from writing beyond the provided buffer. If get_rq_param_unquoted_copy_z indeed performs an unconditional memcpy(dest, src, param_len) and then writes dest[param_len] = '\\0' (as the agent asserts), that is an out-of-bounds write when buf_size - buf_used < param_len + 1, and thus a violation of MISRA C 2023 Rule 21.17. (If, contrary to the agent\u2019s statement, the helper function internally enforces bounds and refuses to write beyond the destination, then there is no violation; however the API of the helper \u2014 no destination size argument \u2014 makes that unlikely.)"
}