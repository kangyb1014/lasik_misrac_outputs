{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The final else branch in get_rq_uname (the block with mhd_assert(0) and uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID) is unreachable in the project: callers (MHD_digest_auth_get_request_info3, MHD_digest_auth_get_username3 and MHD_digest_auth_get_username) obtain uname_type via get_rq_uname_type() and explicitly return or avoid calling get_rq_uname when uname_type is MHD_DIGEST_AUTH_UNAME_TYPE_MISSING or MHD_DIGEST_AUTH_UNAME_TYPE_INVALID, and the only remaining enum values (STANDARD, USERHASH, EXTENDED) are handled by the preceding if/else-if branches. Because mhd_assert is a no-op in production, the code still compiles but the else branch cannot be reached by any call path in the provided project code \u2014 violating MISRA C 2023 Rule 2.1 (no unreachable code).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log_entry(const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type,\n                    size_t buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (f)\n  {\n    /* Log entry and the computed uname_type for the request. */\n    fprintf(f, \"get_rq_uname ENTRY: uname_type=%d, get_rq_uname_type(params)=%d, buf_size=%zu\\n\",\n            (int) uname_type,\n            (int) get_rq_uname_type (params),\n            buf_size);\n    fclose(f);\n  }\n}\nstatic void\nmhd_probe_log_branch(const char *branch, size_t buf_used, struct MHD_DigestAuthUsernameInfo *uname_info)\n{\n  FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"get_rq_uname BRANCH: %s, buf_used=%zu, uname_type=%d, username_len=%zu, userhash_hex_len=%zu\\n\",\n            branch,\n            buf_used,\n            (int) uname_info->uname_type,\n            uname_info->username_len,\n            uname_info->userhash_hex_len);\n    fclose(f);\n  }\n}\nstatic void\nmhd_probe_log_userhash(size_t userhash_hex_len, size_t res, int invalid)\n{\n  FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"get_rq_uname USERHASH: userhash_hex_len=%zu, hex_to_bin_res=%zu, invalid=%d\\n\",\n            userhash_hex_len, res, invalid);\n    fclose(f);\n  }\n}\nstatic void\nmhd_probe_log_extended(ssize_t res)\n{\n  FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"get_rq_uname EXTENDED: get_rq_extended_uname_copy_z_res=%lld\\n\", (long long) res);\n    fclose(f);\n  }\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  /* Probe log: entry */\n  mhd_probe_log_entry (params, uname_type, buf_size);\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n\n    /* Probe log: standard branch */\n    mhd_probe_log_branch(\"STANDARD\", buf_used, uname_info);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      /* Probe log: invalid hex */\n      mhd_probe_log_userhash (uname_info->userhash_hex_len, res, 1);\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n\n      /* Probe log: valid userhash */\n      mhd_probe_log_userhash (uname_info->userhash_hex_len, res, 0);\n    }\n\n    /* Probe log: userhash branch */\n    mhd_probe_log_branch(\"USERHASH\", buf_used, uname_info);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n\n    /* Probe log: extended branch and result */\n    mhd_probe_log_extended (res);\n    mhd_probe_log_branch(\"EXTENDED\", buf_used, uname_info);\n  }\n  else\n  {\n    /* This block is reported as unreachable in the project; log if reached. */\n    FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"get_rq_uname ELSE: reached unreachable branch! uname_type=%d\\n\", (int) uname_type);\n      fclose(f);\n    }\n\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n\n  /* Probe log: exit */\n  {\n    FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"get_rq_uname EXIT: buf_used=%zu, final_uname_type=%d\\n\", buf_used, (int) uname_info->uname_type);\n      fclose(f);\n    }\n  }\n\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct for the provided project: the final else branch (the block with mhd_assert(0) and setting uname_type to INVALID) cannot be reached by any call path that exists in the project as described. The callers obtain uname_type from get_rq_uname_type(params) and either return or avoid calling get_rq_uname when uname_type is MHD_DIGEST_AUTH_UNAME_TYPE_MISSING or MHD_DIGEST_AUTH_UNAME_TYPE_INVALID; the only remaining defined enum values (STANDARD, USERHASH, EXTENDED) are handled by the prior if/else-if branches. Because mhd_assert is a no-op in production builds, the assertions do not introduce any runtime path to that else branch and do not make it reachable. Therefore, given the whole-project calling discipline described, that else block is unreachable and the report that this violates MISRA C 2023 Rule 2.1 (no unreachable code) is correct.\n\nCaveat: this conclusion depends on whole-project analysis \u2014 if there are other callers of get_rq_uname (or future changes) that can pass other uname_type values, then the branch would not be unreachable. If the code is intended as defensive/diagnostic, it should be documented or handled via an approved MISRA deviation rather than left as silently unreachable code."
}