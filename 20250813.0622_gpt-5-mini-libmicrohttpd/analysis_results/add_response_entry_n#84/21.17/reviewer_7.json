{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the pointer 'content' does not actually refer to an object of at least content_len bytes (for example, content points to a 4\u2011byte buffer but content_len is 10, or content is NULL while content_len is non\u2011zero), the call memchr(content, '\\n', content_len) will read past the object bounds and cause undefined behavior. In other words, if callers supply an incorrect content_len (larger than the actual buffer) or a NULL content with non\u2011zero length, this memchr use can access beyond the referenced object.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nwrite_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  write_log (\"ENTER add_response_entry_n: response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu\",\n             (void *) response, (int) kind, (const void *) header, header_len,\n             (const void *) content, content_len);\n\n  if (NULL == response)\n    {\n      write_log (\"RETURN false: response is NULL\");\n      return false;\n    }\n  if (0 == header_len)\n    {\n      write_log (\"RETURN false: header_len == 0\");\n      return false;\n    }\n  if (0 == content_len)\n    {\n      write_log (\"RETURN false: content_len == 0\");\n      return false;\n    }\n\n  /* Header checks */\n  write_log (\"Check header for '\\\\t' (header=%p, header_len=%zu)\", (const void *) header, header_len);\n  {\n    void *p = memchr (header, '\\t', header_len);\n    write_log (\"memchr(header,'\\\\t',%zu) -> %p\", header_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: header contains '\\\\t'\");\n        return false;\n      }\n  }\n\n  write_log (\"Check header for ' ' (header=%p, header_len=%zu)\", (const void *) header, header_len);\n  {\n    void *p = memchr (header, ' ', header_len);\n    write_log (\"memchr(header,' ',%zu) -> %p\", header_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: header contains ' '\");\n        return false;\n      }\n  }\n\n  write_log (\"Check header for '\\\\r' (header=%p, header_len=%zu)\", (const void *) header, header_len);\n  {\n    void *p = memchr (header, '\\r', header_len);\n    write_log (\"memchr(header,'\\\\r',%zu) -> %p\", header_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: header contains '\\\\r'\");\n        return false;\n      }\n  }\n\n  write_log (\"Check header for '\\\\n' (header=%p, header_len=%zu)\", (const void *) header, header_len);\n  {\n    void *p = memchr (header, '\\n', header_len);\n    write_log (\"memchr(header,'\\\\n',%zu) -> %p\", header_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: header contains '\\\\n'\");\n        return false;\n      }\n  }\n\n  /* Content checks. These memchr calls match the original logic and are\n     intentionally left as-is so they can reproduce the reported violation\n     scenario (e.g. content == NULL while content_len > 0). The probes log\n     the pointer and length before and after the calls. */\n  write_log (\"Check content for '\\\\r' (content=%p, content_len=%zu)\", (const void *) content, content_len);\n  {\n    void *p = memchr (content, '\\r', content_len);\n    write_log (\"memchr(content,'\\\\r',%zu) -> %p\", content_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: content contains '\\\\r'\");\n        return false;\n      }\n  }\n\n  write_log (\"Check content for '\\\\n' (content=%p, content_len=%zu)\", (const void *) content, content_len);\n  {\n    void *p = memchr (content, '\\n', content_len);\n    write_log (\"memchr(content,'\\\\n',%zu) -> %p\", content_len, p);\n    if (NULL != p)\n      {\n        write_log (\"RETURN false: content contains '\\\\n'\");\n        return false;\n      }\n  }\n\n  write_log (\"Calling MHD_add_response_entry_no_check_ (response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu)\",\n             (void *) response, (int) kind, (const void *) header, header_len,\n             (const void *) content, content_len);\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER add_response_entry_n: response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d5995090b0 content_len=8\nCheck header for '\\t' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\t',13) -> (nil)\nCheck header for ' ' (header=0x55d5995090b9, header_len=13)\nmemchr(header,' ',13) -> (nil)\nCheck header for '\\r' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\r',13) -> (nil)\nCheck header for '\\n' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\n',13) -> (nil)\nCheck content for '\\r' (content=0x55d5995090b0, content_len=8)\nmemchr(content,'\\r',8) -> (nil)\nCheck content for '\\n' (content=0x55d5995090b0, content_len=8)\nmemchr(content,'\\n',8) -> (nil)\nCalling MHD_add_response_entry_no_check_ (response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d5995090b0 content_len=8)\nENTER add_response_entry_n: response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d5995090de content_len=8\nCheck header for '\\t' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\t',13) -> (nil)\nCheck header for ' ' (header=0x55d5995090b9, header_len=13)\nmemchr(header,' ',13) -> (nil)\nCheck header for '\\r' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\r',13) -> (nil)\nCheck header for '\\n' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\n',13) -> (nil)\nCheck content for '\\r' (content=0x55d5995090de, content_len=8)\nmemchr(content,'\\r',8) -> (nil)\nCheck content for '\\n' (content=0x55d5995090de, content_len=8)\nmemchr(content,'\\n',8) -> (nil)\nCalling MHD_add_response_entry_no_check_ (response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d5995090de content_len=8)\nENTER add_response_entry_n: response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d599509118 content_len=8\nCheck header for '\\t' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\t',13) -> (nil)\nCheck header for ' ' (header=0x55d5995090b9, header_len=13)\nmemchr(header,' ',13) -> (nil)\nCheck header for '\\r' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\r',13) -> (nil)\nCheck header for '\\n' (header=0x55d5995090b9, header_len=13)\nmemchr(header,'\\n',13) -> (nil)\nCheck content for '\\r' (content=0x55d599509118, content_len=8)\nmemchr(content,'\\r',8) -> (nil)\nCheck content for '\\n' (content=0x55d599509118, content_len=8)\nmemchr(content,'\\n',8) -> (nil)\nCalling MHD_add_response_entry_no_check_ (response=0x55d5b5f002a0 kind=1 header=0x55d5995090b9 header_len=13 content=0x55d599509118 content_len=8)\nENTER add_response_entry_n: response=0x55d5b5f002a0 kind=1 header=0x55d599509b9b header_len=4 content=0x55d599509b7d content_len=29\nCheck header for '\\t' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\t',4) -> (nil)\nCheck header for ' ' (header=0x55d599509b9b, header_len=4)\nmemchr(header,' ',4) -> (nil)\nCheck header for '\\r' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\r',4) -> (nil)\nCheck header for '\\n' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\n',4) -> (nil)\nCheck content for '\\r' (content=0x55d599509b7d, content_len=29)\nmemchr(content,'\\r',29) -> (nil)\nCheck content for '\\n' (content=0x55d599509b7d, content_len=29)\nmemchr(content,'\\n',29) -> (nil)\nCalling MHD_add_response_entry_no_check_ (response=0x55d5b5f002a0 kind=1 header=0x55d599509b9b header_len=4 content=0x55d599509b7d content_len=29)\nENTER add_response_entry_n: response=0x55d5b5f002a0 kind=1 header=0x55d599509b9b header_len=4 content=0x55d599509be0 content_len=29\nCheck header for '\\t' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\t',4) -> (nil)\nCheck header for ' ' (header=0x55d599509b9b, header_len=4)\nmemchr(header,' ',4) -> (nil)\nCheck header for '\\r' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\r',4) -> (nil)\nCheck header for '\\n' (header=0x55d599509b9b, header_len=4)\nmemchr(header,'\\n',4) -> (nil)\nCheck content for '\\r' (content=0x55d599509be0, content_len=29)\nmemchr(content,'\\r',29) -> (nil)\nCheck content for '\\n' (content=0x55d599509be0, content_len=29)\nmemchr(content,'\\n',29) -> (nil)\nCalling MHD_add_response_entry_no_check_ (response=0x55d\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. memchr(ptr, c, n) reads up to n bytes starting at ptr and therefore requires that ptr refers to an object of at least n bytes (and not be NULL when n>0). add_response_entry_n checks that header_len and content_len are non\u2011zero, but it does not verify that header and content actually point to objects of at least those lengths (nor does it check content for NULL before calling memchr). As written, a caller-supplied NULL pointer with a non\u2011zero length or a pointer to a buffer smaller than the supplied length would make the memchr calls access beyond the referenced object and invoke undefined behavior, violating MISRA C 2023 Rule 21.17."
}