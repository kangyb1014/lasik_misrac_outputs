{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as '#define mhd_assert(ignore) ((void)0)'. Therefore the statement 'mhd_assert (c->read_buffer_offset <= new_buf_size);' is a no-op at runtime; its removal would not affect program behaviour. This constitutes dead code and violates MISRA C 2023 Rule 2.2. (If mhd_assert were defined to perform checks in some builds, those builds would not have dead code; but in the provided configuration it is a violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *where,\n                              struct MHD_Connection *connection,\n                              struct MHD_HTTP_Req_Header *saved_tail,\n                              enum _MHD_ParseCookie parse_res,\n                              bool allow_partially_correct_cookie,\n                              const char *extra)\n{\n  /* Lightweight probe: append a single-line record to the log file. */\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Print basic control-flow/state information useful to reproduce the\n     violation scenario. Keep output simple to avoid altering program logic. */\n  fprintf(f,\n          \"%s: conn=%p saved_tail=%p parse_res=%d allow_partial=%d extra=%s\\n\",\n          where,\n          (void *) connection,\n          (void *) saved_tail,\n          (int) parse_res,\n          (int) allow_partially_correct_cookie,\n          (NULL == extra) ? \"\" : extra);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  /* Log entry and initial state */\n  mhd_probe_log(\"enter\", connection, saved_tail, -1,\n                allow_partially_correct_cookie, \"start\");\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len)) {\n    /* Log missing header and early exit */\n    mhd_probe_log(\"no_cookie_header\", connection, saved_tail,\n                  MHD_PARSE_COOKIE_OK,\n                  allow_partially_correct_cookie,\n                  \"header not present\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n  if (0 == hdr_len) {\n    /* Log empty header and early exit */\n    mhd_probe_log(\"empty_cookie_header\", connection, saved_tail,\n                  MHD_PARSE_COOKIE_OK,\n                  allow_partially_correct_cookie,\n                  \"hdr_len==0\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  /* Log parse result before handling it */\n  mhd_probe_log(\"after_parse\", connection, saved_tail, parse_res,\n                allow_partially_correct_cookie, \"parsed cookie header\");\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    /* Log that the default branch was reached, including the unexpected\n       parse_res value and relevant pointers. This provides runtime\n       evidence that the assertion site was reached; if mhd_assert is a\n       no-op in this build the program will continue after this point.\n       Keep the original mhd_assert call to preserve behaviour. */\n    mhd_probe_log(\"default_branch_reached\", connection, saved_tail,\n                  parse_res, allow_partially_correct_cookie,\n                  \"about to call mhd_assert(0)\");\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  /* Final log before return */\n  mhd_probe_log(\"exit\", connection, saved_tail, parse_res,\n                allow_partially_correct_cookie, \"returning\");\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55676bfcecf0 saved_tail=0x55676bfd6e40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55a411996cf0 saved_tail=0x55a41199ee40 parse_res=-1 allow_partial=1 extra=start\nno_cookie_header: conn=0x55a411996cf0 saved_tail=0x55a41199ee40 parse_res=1 allow_partial=1 extra=header not present\nenter: conn=0x55a411996cf0 saved_tail=0x55a41199ee40 parse_res=-1 allow_partial=1 extra\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. The provided runtime traces (and the problem statement that the test-suite is exhaustive) show that the switch default branch was never taken \u2014 there is no \"default_branch_reached\" probe and no evidence that the mhd_assert statement was ever executed. Because the assertion site was not executed, it is unreachable in the tested project configuration and therefore not \"dead code\" per the rule (note 2: unreachable code is not dead code). Consequently the report that parse_cookie_header violates MISRA C 2023 Rule 2.2 is not correct for the given configuration and test evidence."
}