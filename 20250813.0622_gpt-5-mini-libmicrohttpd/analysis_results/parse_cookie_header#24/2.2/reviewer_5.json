{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement mhd_assert(NULL != res); expands to ((void)0) (per the provided macro definition). This yields an executed no-op statement whose removal would not affect program behaviour, so it is dead code and thus violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *label,\n               const void *connection_ptr,\n               const void *saved_tail_ptr,\n               int parse_res_val,\n               const char *hdr_ptr,\n               size_t hdr_len_val,\n               const char *note)\n{\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf (f, \"[probe] %s\\n\", label);\n  fprintf (f, \"  connection=%p\\n\", connection_ptr);\n  fprintf (f, \"  saved_tail=%p\\n\", saved_tail_ptr);\n  fprintf (f, \"  parse_res=%d\\n\", parse_res_val);\n  if (hdr_ptr != NULL)\n    fprintf (f, \"  hdr_ptr=%p hdr_len=%zu\\n\", hdr_ptr, hdr_len_val);\n  if (note != NULL)\n    fprintf (f, \"  note=%s\\n\", note);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  /* Log entry and saved_tail state */\n  mhd_probe_log (\"ENTRY\", connection, saved_tail, -1, NULL, 0, NULL);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n  {\n    mhd_probe_log (\"NO_COOKIE_HEADER\", connection, saved_tail, -1, NULL, 0,\n                   \"MHD_lookup_connection_value_n returned MHD_NO\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n  if (0 == hdr_len)\n  {\n    mhd_probe_log (\"EMPTY_COOKIE_HEADER\", connection, saved_tail, -1, hdr,\n                   hdr_len, \"Header length is zero\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n  {\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n    mhd_probe_log (\"ALLOC_FAIL\", connection, saved_tail, parse_res, hdr,\n                   hdr_len, \"MHD_connection_alloc_memory_ returned NULL\");\n  }\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    mhd_probe_log (\"BEFORE_PARSE\", connection, saved_tail, -1, cpy + i,\n                   hdr_len - i, \"About to call parse_cookies_string\");\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n\n    mhd_probe_log (\"AFTER_PARSE\", connection, saved_tail, (int) parse_res,\n                   cpy + i, hdr_len - i, \"parse_cookies_string returned\");\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    /* Log that we are entering the default (unexpected) branch. This captures\n       the control path that will execute the mhd_assert(0) statement which\n       may be compiled out to a no-op. */\n    mhd_probe_log (\"DEFAULT_BRANCH_ENTER\", connection, saved_tail,\n                   (int) parse_res, NULL, 0,\n                   \"About to execute mhd_assert(0) - may be no-op when disabled\");\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  mhd_probe_log (\"EXIT\", connection, saved_tail, (int) parse_res, hdr,\n                 hdr_len, \"Returning from parse_cookie_header\");\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n\n[probe] NO_COOKIE_HEADER\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n  note=MHD_lookup_connection_value_n returned MHD_NO\n\n[probe] ENTRY\n  connection=0x55c3bcb95cf0\n  saved_tail=0x55c3bcb9de40\n  parse_res=-1\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not supported by the provided test outputs. The alleged no-op comes from mhd_assert expanding to a (void)0; that would only be dead code if that statement is actually executed and its removal would not change program behaviour. The probe logs show only the ENTRY and NO_COOKIE_HEADER paths being taken repeatedly (MHD_lookup_connection_value_n returned MHD_NO), and there are no logs for entering the default branch (no DEFAULT_BRANCH_ENTER or AFTER_PARSE entries). Therefore the mhd_assert in the default: branch was never executed in the exhaustive test runs, so there is no executed no-op in these traces and no demonstrated violation of MISRA C 2023 Rule 2.2. Consequently the report is incorrect."
}