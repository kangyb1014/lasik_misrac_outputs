{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as ((void)0) in the provided code, so the statement mhd_assert ('=' == str[i]); becomes a no-op ((void)0). This is an executed operation whose removal would not affect program behaviour, i.e. dead code. (If mhd_assert were enabled in other builds it would not be dead, but in the supplied project configuration it is.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  mhd_probe_log(\"parse_cookie_header: enter connection=%p daemon=%p saved_tail=%p client_discipline=%d\",\n                (void *)connection,\n                (void *)connection->daemon,\n                (void *)saved_tail,\n                connection->daemon ? connection->daemon->client_discipline : -1);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len)) {\n    mhd_probe_log(\"parse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  mhd_probe_log(\"parse_cookie_header: Cookie header found hdr=%p hdr_len=%zu\", (void *)hdr, hdr_len);\n\n  if (0 == hdr_len) {\n    mhd_probe_log(\"parse_cookie_header: hdr_len == 0 -> return MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    mhd_probe_log(\"parse_cookie_header: copied cookie string cpy=%p trimmed_offset=%zu remaining_len=%zu\",\n                  (void *)cpy, i, hdr_len - i);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n    mhd_probe_log(\"parse_cookie_header: parse_cookies_string returned %d\", (int)parse_res);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_OK\");\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_OK_LAX saved_tail_changed=%d\",\n                  saved_tail != connection->rq.headers_received_tail);\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_MALFORMED saved_tail_changed=%d allow_partially_correct_cookie=%d\",\n                  saved_tail != connection->rq.headers_received_tail,\n                  allow_partially_correct_cookie);\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n        mhd_probe_log(\"parse_cookie_header: malformed -> removed extracted values, restored saved_tail=%p\", (void *)saved_tail);\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_NO_MEMORY\");\n    break;\n  default:\n    /* Log the unexpected enum value and surrounding state before asserting */\n    mhd_probe_log(\"parse_cookie_header: default case reached! parse_res=%d saved_tail=%p current_tail=%p allow_partially_correct_cookie=%d\",\n                  (int)parse_res,\n                  (void *)saved_tail,\n                  (void *)connection->rq.headers_received_tail,\n                  allow_partially_correct_cookie);\n    mhd_probe_log(\"parse_cookie_header: about to call mhd_assert(0)\");\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  mhd_probe_log(\"parse_cookie_header: exit parse_res=%d\", (int)parse_res);\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x556d383f4cf0 daemon=0x556d383f2350 saved_tail=0x556d383fce40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x55d779312cf0 daemon=0x55d779310350 saved_tail=0x55d77931ae40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x55d779312cf0 daemon=0x55d779310350 saved_tail=0x55d77931ae40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\nparse_cookie_header: enter connection=0x55d779312cf0 daemon=0x55d779310350 saved_tail=0x55d77931ae40 client_discipline=0\nparse_cookie_header: no Cookie header found -> return MHD_PARSE_COOKIE_OK\np\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour; unreachable code is explicitly not dead code. In parse_cookie_header the mhd_assert call appears only in the switch default branch. The provided exhaustive test log shows the default branch was never reached (no log lines from the default case or from an assertion), therefore the mhd_assert statement is not executed in the supplied project configuration and is unreachable. Per note 2 of Rule 2.2 unreachable code is not considered dead code. Consequently the agent A's claim that the mhd_assert call in this project is executed and therefore constitutes dead code is not supported by the supplied, exhaustive test output. The report is incorrect."
}