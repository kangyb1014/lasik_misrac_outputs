{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as ((void)0) in the project, so the statement mhd_assert(0 != name_len); expands to a no-op ((void)0). That operation has no effect at runtime and its removal would not change program behaviour, therefore it is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  /* Log entry and some state */\n  mhd_probe_log(\"parse_cookie_header: entry: connection=%p daemon=%p saved_tail=%p client_discipline=%d\",\n                (void *)connection,\n                (void *)connection->daemon,\n                (void *)saved_tail,\n                (int)connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len)) {\n    mhd_probe_log(\"parse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n  mhd_probe_log(\"parse_cookie_header: header found: hdr=%p hdr_len=%zu\", (const void *)hdr, hdr_len);\n\n  if (0 == hdr_len) {\n    mhd_probe_log(\"parse_cookie_header: hdr_len == 0. Returning MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    mhd_probe_log(\"parse_cookie_header: cpy allocated=%p hdr_len=%zu skip_i=%zu remaining=%zu substring='%.32s'\",\n                  (void *)cpy, hdr_len, i, (hdr_len >= i) ? (hdr_len - i) : 0, cpy + i);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  mhd_probe_log(\"parse_cookie_header: parse_cookies_string returned parse_res=%d\", (int)parse_res);\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_OK\");\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_OK_LAX: saved_tail=%p now=%p\",\n                  (void *)saved_tail, (void *)connection->rq.headers_received_tail);\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_MALFORMED saved_tail=%p now=%p allow_partially_correct_cookie=%d\",\n                  (void *)saved_tail, (void *)connection->rq.headers_received_tail,\n                  allow_partially_correct_cookie);\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n        mhd_probe_log(\"parse_cookie_header: malformed: restored saved_tail and cut off next\");\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: case MHD_PARSE_COOKIE_NO_MEMORY\");\n    break;\n  default:\n    /* Log the unexpected branch: this is where the original code called mhd_assert(0) */\n    mhd_probe_log(\"parse_cookie_header: default branch reached: about to call mhd_assert(0)\");\n    /* Call the original assertion as in the original code. In the project\n       configuration under test mhd_assert is defined as ((void)0); this runtime\n       log entry shows control flow reached this location while the assert\n       itself will be a no-op (dead code). */\n    mhd_assert (0);\n    mhd_probe_log(\"parse_cookie_header: returned from mhd_assert(0) (note: may be a no-op)\");\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  mhd_probe_log(\"parse_cookie_header: exit parse_res=%d\", (int)parse_res);\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x55b382906cf0 daemon=0x55b382904350 saved_tail=0x55b38290ee40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x5558bf879cf0 daemon=0x5558bf877350 saved_tail=0x5558bf881e40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x5558bf879cf0 daemon=0x5558bf877350 saved_tail=0x5558bf881e40 client_discipline=0\nparse_cookie_header: header not present (MHD_NO). Returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry: connection=0x5558bf879cf0 da\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 2.2 defines dead code as any operation that is executed but whose removal would not affect program behaviour. If the project defines mhd_assert as ((void)0), then the statement mhd_assert(0); expands to an expression statement with no observable effect. Executing that no-op does not change program behaviour, so its presence qualifies as dead code under Rule 2.2. Therefore the agent A\u2019s claim that this is a violation is valid."
}