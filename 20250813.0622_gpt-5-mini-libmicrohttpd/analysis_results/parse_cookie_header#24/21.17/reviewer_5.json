{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Possible integer wrap-around when computing hdr_len + 1. If hdr_len == SIZE_MAX (or otherwise so large that hdr_len + 1 wraps), the allocation request becomes incorrect (e.g. 0), so MHD_connection_alloc_memory_ may return a pointer to a buffer smaller than hdr_len+1. The subsequent memcpy(cpy, hdr, hdr_len) and cpy[hdr_len] = '\\0' then access beyond the allocated object bounds. No check for hdr_len < SIZE_MAX (or for overflow) is present, so Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void MHD_probe_log_cookie_state(const char *stage,\n                                       struct MHD_Connection *connection,\n                                       const char *hdr,\n                                       size_t hdr_len,\n                                       size_t alloc_req,\n                                       const void *alloc_ptr)\n{\n  FILE *f = fopen(\"/tmp/logs/199.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"[parse_cookie_header] %s: connection=%p hdr=%p hdr_len=%zu alloc_req=%zu alloc_ptr=%p\\n\",\n          stage,\n          (void *) connection,\n          (const void *) hdr,\n          hdr_len,\n          alloc_req,\n          alloc_ptr);\n  /* Dump a small prefix of the header to help reproduce the issue, but\n     avoid reading beyond hdr_len. */\n  if (hdr != NULL && hdr_len > 0)\n  {\n    size_t dump = hdr_len < 64 ? hdr_len : 64;\n    fprintf(f, \" hdr_prefix(%zu)='\", dump);\n    fwrite(hdr, 1, dump, f);\n    fprintf(f, \"'\\n\");\n  }\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  size_t alloc_req;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  /* Log state after header lookup and before allocation. */\n  alloc_req = hdr_len + 1; /* preserve original allocation intent */\n  MHD_probe_log_cookie_state(\"after_lookup\", connection, hdr, hdr_len, alloc_req, NULL);\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n\n  /* Log allocation result and relevant state. This captures the pointer\n     returned and the requested allocation size so agents can inspect\n     possible integer wrap-around or allocator behaviors. */\n  MHD_probe_log_cookie_state(\"after_alloc\", connection, hdr, hdr_len, alloc_req, (const void *) cpy);\n\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    /* Log immediately before copying to capture hdr_len and cpy pointer.\n       This helps reproduce cases where hdr_len is so large that the\n       allocation size wrapped or the allocator returned a smaller buffer. */\n    MHD_probe_log_cookie_state(\"before_memcpy\", connection, hdr, hdr_len, alloc_req, (const void *) cpy);\n\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    /* Log after copy completion. (May not be reached if memcpy overflows.) */\n    MHD_probe_log_cookie_state(\"after_memcpy\", connection, hdr, hdr_len, alloc_req, (const void *) cpy);\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for parse_cookie_header. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes cpy = MHD_connection_alloc_memory_(connection, hdr_len + 1) and then does memcpy(cpy, hdr, hdr_len) and cpy[hdr_len] = '\\0' without any check that hdr_len + 1 did not overflow size_t. If hdr_len == SIZE_MAX (or otherwise large enough to make hdr_len + 1 wrap to 0) the allocation call is invoked with a wrong (wrapped) size (e.g. 0). malloc/caller-provided allocator behavior for size 0 is unspecified: it may return NULL or a non-dereferenceable pointer; copying hdr_len bytes into that buffer or writing cpy[hdr_len] is therefore an out-of-bounds access and undefined behaviour. That is exactly the kind of bounds-overrun that MISRA C 2023 Rule 21.17 aims to prevent (use of memcpy must not result in accesses beyond the bounds of the referenced objects). Even if the allocator rejects the request and returns NULL, the code checks for NULL and handles that case; but the overflow/wrap case can turn the intended non-zero request into a small or zero request and so the subsequent memcpy/write can access beyond the allocated object.\n\nRecommendation: explicitly guard against integer wrap-around before making the allocation, e.g. check that hdr_len < SIZE_MAX (or use if (hdr_len + 1 > hdr_len) or compute alloc_req = hdr_len + 1 and check alloc_req != 0 and alloc_req > hdr_len as appropriate), and treat excessive hdr_len as an error (return MHD_PARSE_COOKIE_NO_MEMORY or MALFORMED). Alternatively use a checked-allocation helper that detects overflow of the size expression. This change removes the possibility of the memcpy/cpy[...] accessing beyond the allocated object, resolving the MISRA 21.17 violation."
}