{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of parse_cookie_header:\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */",
    "case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;",
    "default:\n    mhd_assert (0);\n    break;",
    "saved_tail->next = NULL;"
  ],
  "explanation": "I marked the above fragments for further investigation with respect to MISRA C 2023 Rule 2.1 (unreachable code) because each is a small region that may be unreachable depending on build-time configuration and/or the set of possible enum values returned by parse_cookies_string():\n\n- The default: mhd_assert(0); break; is a switch default that will be compiled into the function. If every possible value of parse_res is already handled by the explicit cases (and the function that produces parse_res cannot produce any other enumerators), this default is effectively unreachable; conversely, if parse_cookies_string can produce unexpected values, it is reachable \u2014 so it warrants inspection.\n\n- The (void) saved_tail; /* Mute compiler warning */ statement is only compiled when HAVE_MESSAGES is not defined. Depending on project-wide defines this code may or may not appear in the build; when it does appear it is a no-op intended to silence a warning \u2014 verify that it is not masking unreachable code or dead branches elsewhere.\n\n- The case MHD_PARSE_COOKIE_OK_LAX block contains logging guarded by HAVE_MESSAGES. If parse_cookies_string never returns MHD_PARSE_COOKIE_OK_LAX in current implementations, this entire case (or its logging) may be dead/unreachable in practice; verify whether OK_LAX is actually a reachable parse outcome.\n\n- The assignment saved_tail->next = NULL; is executed only in a narrow condition (MALFORMED + saved_tail changed + !allow_partially_correct_cookie). If saved_tail can never satisfy those predicates (e.g., saved_tail is always equal to connection->rq.headers_received_tail or is NULL), the assignment may be unreachable or indicate a logic error leading to undefined behavior; it should be checked.\n\nWhy other fragments were not marked:\n- The early returns (when the header is absent or hdr_len == 0) are normal control-flow and reachable by the respective input conditions; they are not dead code.\n- The allocation, memcpy, and cpy[hdr_len] = '\\0' are reachable whenever a non-empty header exists and allocation succeeds; these are necessary operations and not inherently unreachable.\n- The other switch cases (MHD_PARSE_COOKIE_OK, MHD_PARSE_COOKIE_MALFORMED, MHD_PARSE_COOKIE_NO_MEMORY) are legitimate runtime branches corresponding to parse outcomes; they are potentially reachable and thus not classified as unreachable here. The logging calls inside #ifdef HAVE_MESSAGES are compilation-dependent but are paired with runtime conditions; they should be reviewed for correctness but are not clearly unreachable in the source as presented.\n\nReview the marked fragments in the context of the actual build configurations and the implementation of parse_cookies_string (and any other code that writes to connection->rq.headers_received_tail) to determine whether they are truly unreachable and to resolve any violations of MISRA Rule 2.1."
}