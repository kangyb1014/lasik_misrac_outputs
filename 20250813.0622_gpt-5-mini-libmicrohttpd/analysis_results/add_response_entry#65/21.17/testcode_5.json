{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 memchr(content, '\\n', content_len) can access out-of-bounds because add_response_entry_n does not validate that content is non-NULL or that content_len does not exceed the actual object size. For example, if add_response_entry_n is (mistakenly) called with content == NULL and content_len > 0, memchr will dereference a NULL pointer; or if the caller supplies an incorrect content_len larger than the actual buffer (e.g. not the strlen length), memchr may read beyond the object. Although add_response_entry() computes content_len via strlen(content) and checks content != NULL, the callee itself lacks the necessary checks, so the use of memchr can lead to out-of-bounds accesses.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified add_response_entry code that contains useful probe functions that print useful logs to a file \"/tmp/logs/527.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of add_response_entry as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of add_response_entry:\n```c\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n```\n</target_code>\nPlease provide the modified add_response_entry code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nstatic void add_response_entry_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/527.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  /* Log entry and raw pointers (do not dereference pointers here) */\n  add_response_entry_log(\"add_response_entry called: response=%p kind=%d header=%p content=%p\",\n                         (void *) response, (int) kind, (const void *) header, (const void *) content);\n\n  if (NULL == content)\n  {\n    add_response_entry_log(\"add_response_entry: content is NULL -> returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Preserve original behavior: compute header_len via strlen(header) as before. */\n  add_response_entry_log(\"add_response_entry: computing header_len via strlen(header) header_ptr=%p\",\n                         (const void *) header);\n\n  header_len = strlen (header);\n\n  add_response_entry_log(\"add_response_entry: header_len=%zu\", header_len);\n\n  /* Compute content_len (content is non-NULL as checked above) */\n  content_len = strlen (content);\n\n  add_response_entry_log(\"add_response_entry: content_len=%zu\", content_len);\n\n  add_response_entry_log(\"add_response_entry: calling add_response_entry_n with response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu\",\n                         (void *) response, (int) kind,\n                         (const void *) header, header_len, (const void *) content, content_len);\n\n  int rc = add_response_entry_n (response, kind, header,\n                                 header_len, content,\n                                 content_len);\n\n  add_response_entry_log(\"add_response_entry: add_response_entry_n returned %d -> returning %s\",\n                         rc, rc ? \"MHD_YES\" : \"MHD_NO\");\n\n  return rc ? MHD_YES : MHD_NO;\n}\n"
}