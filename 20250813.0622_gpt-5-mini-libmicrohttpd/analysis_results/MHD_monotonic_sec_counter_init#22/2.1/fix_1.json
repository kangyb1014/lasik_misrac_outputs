{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nMHD_probe_log_state (const char *label)\n{\n  FILE *f = fopen (\"/tmp/logs/177.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Many of the globals used here are defined elsewhere in the project. We\n     print them cast to integer types that are broadly compatible so the probe\n     compiles without requiring their exact definitions here. */\n  fprintf (f, \"%s\\n\", label);\n  /* Attempt to print the most likely global variables used by the function. */\n  /* Use casts to avoid depending on exact types. */\n  fprintf (f, \"  mono_clock_source=%d\\n\", (int) mono_clock_source);\n  fprintf (f, \"  mono_clock_id=%ld\\n\", (long) mono_clock_id);\n  fprintf (f, \"  mono_clock_start=%lld\\n\", (long long) mono_clock_start);\n  fprintf (f, \"  mono_clock_service=%ld\\n\", (long) mono_clock_service);\n  fprintf (f, \"  tick_start=%llu\\n\", (unsigned long long) tick_start);\n  fprintf (f, \"  perf_freq=%llu\\n\", (unsigned long long) perf_freq);\n  fprintf (f, \"  perf_start=%llu\\n\", (unsigned long long) perf_start);\n  fprintf (f, \"  hrtime_start=%llu\\n\", (unsigned long long) hrtime_start);\n  fprintf (f, \"  gettime_start=%lld\\n\", (long long) gettime_start);\n  fprintf (f, \"  sys_clock_start=%lld\\n\", (long long) sys_clock_start);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nMHD_probe_log_msg (const char *msg)\n{\n  FILE *f = fopen (\"/tmp/logs/177.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s\\n\", msg);\n  fclose (f);\n}\n\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* log entry */\n  MHD_probe_log_state (\"MHD_monotonic_sec_counter_init: entry\");\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n    /* This branch is intentionally unreachable. We keep a probe here so\n       that if it ever executes (indicating a problem with compilation or\n       preprocessing) it will be recorded. */\n    MHD_probe_log_msg (\"UNEXPECTED: entered if(0) branch\");\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_COARSE\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_FAST\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_RAW_APPROX\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_RAW\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_BOOTTIME\");\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_UPTIME\");\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n    MHD_probe_log_state (\"selected MACH clock_get_time\");\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n    MHD_probe_log_state (\"selected GetTickCount64\");\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n    MHD_probe_log_state (\"selected QueryPerformanceCounter\");\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_HIGHRES\");\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n    MHD_probe_log_state (\"selected gethrtime\");\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    MHD_probe_log_state (\"no suitable clock source found\");\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    MHD_probe_log_msg (\"deallocated mono_clock_service due to failed clock_get_time\");\n    MHD_probe_log_state (\"after deallocation\");\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n    MHD_probe_log_state (\"after timespec_get\");\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n    MHD_probe_log_state (\"after gettimeofday\");\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n  MHD_probe_log_state (\"final state\");\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_mono_clock.c: In function 'MHD_probe_log_state':\nmhd_mono_clock.c:163:49: error: 'mono_clock_source' undeclared (first use in this function); did you mean 'mono_clock_start'?\n  163 |   fprintf (f, \"  mono_clock_source=%d\\n\", (int) mono_clock_source);\n      |                                                 ^~~~~~~~~~~~~~~~~\n      |                                                 mono_clock_start\nmhd_mono_clock.c:163:49: note: each undeclared identifier is reported only once for each function it appears in\nmhd_mono_clock.c:166:52: error: 'mono_clock_service' undeclared (first use in this function); did you mean 'mono_clock_start'?\n  166 |   fprintf (f, \"  mono_clock_service=%ld\\n\", (long) mono_clock_service);\n      |                                                    ^~~~~~~~~~~~~~~~~~\n      |                                                    mono_clock_start\nmhd_mono_clock.c:167:59: error: 'tick_start' undeclared (first use in this function); did you mean 'va_start'?\n  167 |   fprintf (f, \"  tick_start=%llu\\n\", (unsigned long long) tick_start);\n      |                                                           ^~~~~~~~~~\n      |                                                           va_start\nmhd_mono_clock.c:168:58: error: 'perf_freq' undeclared (first use in this function)\n  168 |   fprintf (f, \"  perf_freq=%llu\\n\", (unsigned long long) perf_freq);\n      |                                                          ^~~~~~~~~\nmhd_mono_clock.c:169:59: error: 'perf_start' undeclared (first use in this function); did you mean 'va_start'?\n  169 |   fprintf (f, \"  perf_start=%llu\\n\", (unsigned long long) perf_start);\n      |                                                           ^~~~~~~~~~\n      |                                                           va_start\nmhd_mono_clock.c:170:61: error: 'hrtime_start' undeclared (first use in this function); did you mean 'gettime_start'?\n  170 |   fprintf (f, \"  hrtime_start=%llu\\n\", (unsigned long long) hrtime_start);\n      |                                                             ^~~~~~~~~~~~\n      |                                                             gettime_start\nmake[3]: *** [Makefile:2133: libmicrohttpd_la-mhd_mono_clock.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_monotonic_sec_counter_init as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <time.h>\n\n/* Minimal definitions of globals and constants that are expected to\n   exist elsewhere in the project so this translation unit compiles on\n   its own. We use types compatible with the casts in the probe logging\n   functions. */\n\nenum _MHD_mono_clock_source {\n  _MHD_CLOCK_NO_SOURCE = 0,\n  _MHD_CLOCK_GETTIME,\n  _MHD_CLOCK_GET_TIME,\n  _MHD_CLOCK_GETTICKCOUNT64,\n  _MHD_CLOCK_PERFCOUNTER,\n  _MHD_CLOCK_GETHRTIME\n};\n\n/* Global state variables (originally defined elsewhere). */\nenum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\nlong mono_clock_id = -1;\nlong long mono_clock_start = 0;\nlong mono_clock_service = -1;\nunsigned long long tick_start = 0ULL;\nunsigned long long perf_freq = 0ULL;\nunsigned long long perf_start = 0ULL;\nunsigned long long hrtime_start = 0ULL;\nlong long gettime_start = 0;\nlong long sys_clock_start = 0;\n\n/* Constants used in the function (originally macros/consts in project). */\nconst long _MHD_UNWANTED_CLOCK = -1L;\nconst long _MHD_INVALID_CLOCK_SERV = -1L;\n\nstatic void\nMHD_probe_log_state (const char *label)\n{\n  FILE *f = fopen (\"/tmp/logs/177.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Many of the globals used here are defined elsewhere in the project. We\n     print them cast to integer types that are broadly compatible so the probe\n     compiles without requiring their exact definitions here. */\n  fprintf (f, \"%s\\n\", label);\n  /* Attempt to print the most likely global variables used by the function. */\n  /* Use casts to avoid depending on exact types. */\n  fprintf (f, \"  mono_clock_source=%d\\n\", (int) mono_clock_source);\n  fprintf (f, \"  mono_clock_id=%ld\\n\", (long) mono_clock_id);\n  fprintf (f, \"  mono_clock_start=%lld\\n\", (long long) mono_clock_start);\n  fprintf (f, \"  mono_clock_service=%ld\\n\", (long) mono_clock_service);\n  fprintf (f, \"  tick_start=%llu\\n\", (unsigned long long) tick_start);\n  fprintf (f, \"  perf_freq=%llu\\n\", (unsigned long long) perf_freq);\n  fprintf (f, \"  perf_start=%llu\\n\", (unsigned long long) perf_start);\n  fprintf (f, \"  hrtime_start=%llu\\n\", (unsigned long long) hrtime_start);\n  fprintf (f, \"  gettime_start=%lld\\n\", (long long) gettime_start);\n  fprintf (f, \"  sys_clock_start=%lld\\n\", (long long) sys_clock_start);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nMHD_probe_log_msg (const char *msg)\n{\n  FILE *f = fopen (\"/tmp/logs/177.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s\\n\", msg);\n  fclose (f);\n}\n\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  /* Use the global mono_clock_source rather than declaring a local variable\n     (preserves intended shared state visible to probe logging). */\n  mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* log entry */\n  MHD_probe_log_state (\"MHD_monotonic_sec_counter_init: entry\");\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n    /* This branch is intentionally unreachable. We keep a probe here so\n       that if it ever executes (indicating a problem with compilation or\n       preprocessing) it will be recorded. */\n    MHD_probe_log_msg (\"UNEXPECTED: entered if(0) branch\");\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_COARSE\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_FAST\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_RAW_APPROX\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC_RAW\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_BOOTTIME\");\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_MONOTONIC\");\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_UPTIME\");\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n    MHD_probe_log_state (\"selected MACH clock_get_time\");\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n    MHD_probe_log_state (\"selected GetTickCount64\");\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n    MHD_probe_log_state (\"selected QueryPerformanceCounter\");\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n    MHD_probe_log_state (\"selected CLOCK_HIGHRES\");\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n    MHD_probe_log_state (\"selected gethrtime\");\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    MHD_probe_log_state (\"no suitable clock source found\");\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    MHD_probe_log_msg (\"deallocated mono_clock_service due to failed clock_get_time\");\n    MHD_probe_log_state (\"after deallocation\");\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n    MHD_probe_log_state (\"after timespec_get\");\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n    MHD_probe_log_state (\"after gettimeofday\");\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n  MHD_probe_log_state (\"final state\");\n}\n",
  "explanation": "Declared the missing globals and related constants so the probe logging functions can reference them. Specifically: added an enum _MHD_mono_clock_source and global variables (mono_clock_source, mono_clock_id, mono_clock_start, mono_clock_service, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start) with types matching the casts used in the original fprintf calls. Also removed the local shadowing declaration of mono_clock_source inside MHD_monotonic_sec_counter_init and instead initialize the global mono_clock_source so the logging probes observe the same state. Included standard headers required for the used functions and types. These changes allow the file to compile standalone while preserving the original function logic as much as possible."
}