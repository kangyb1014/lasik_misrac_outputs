{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 if size + off overflows the unsigned integer range the bounds check can be bypassed. Example: let N = sizeof(session->value_1) (e.g. 256), off = 10, and size = UINT64_MAX - 5. The expression (size + off) is evaluated in an unsigned type and wraps to 4, so the test if (size + off >= N) is false and size is not reduced. The subsequent memcpy(&session->value_1[off], data, size) and the write session->value_1[size + off] = '\\0' then write far beyond the buffer, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified post_iterator code that contains useful probe functions that print useful logs to a file \"/tmp/logs/391.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of post_iterator as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of post_iterator:\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified post_iterator code.\n",
  "test_code": "static void post_iterator_log(const char *tag,\n                                  struct Session *session,\n                                  const char *key,\n                                  uint64_t off,\n                                  size_t size,\n                                  size_t buf_size,\n                                  unsigned long long sum_wrapped,\n                                  size_t adjusted_size,\n                                  const char *note)\n{\n  FILE *f = fopen(\"/tmp/logs/391.txt\", \"a\");\n  if (!f)\n    return;\n  /* Print a compact record of the important state. Use casts to avoid\n     dependencies on PRIu64. */\n  fprintf(f,\n          \"%s: tag=%s key=%s sid=%s off=%llu size=%zu buf_size=%zu sum_wrapped=%llu adjusted_size=%zu note=%s dest_ptr=%p data_ptr=%p\\n\",\n          \"POST_ITER\", tag,\n          key ? key : \"(null)\",\n          session && session->sid ? session->sid : \"(null)\",\n          (unsigned long long) off,\n          size,\n          buf_size,\n          (unsigned long long) sum_wrapped,\n          adjusted_size,\n          note ? note : \"\",\n          (void *) (session ? &session->value_1[0] : NULL), /* generic pointer to value_1 start */\n          (void *) NULL);\n  fclose(f);\n}\n\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  /* Log entry into function */\n  post_iterator_log(\"ENTER\", session, key, off, size, 0,\n                    (unsigned long long) (off + (uint64_t) size), 0,\n                    \"entry\");\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    /* Log DONE path and values of the two buffers (addresses/sid only) */\n    post_iterator_log(\"DONE\", session, key, off, size, 0,\n                      (unsigned long long) (off + (uint64_t) size), 0,\n                      \"DONE branch\");\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    size_t buf_size = sizeof(session->value_1);\n    /* Compute the same wrapped-sum expression used in the original code. */\n    unsigned long long sum_wrapped = (unsigned long long) off + (unsigned long long) size;\n\n    /* Log state before any bounds checks. This will show if sum \"wraps\" to a\n       small value so that the subsequent check can be bypassed. */\n    post_iterator_log(\"V1_BEFORE_CHECK\", session, key, off, size, buf_size,\n                      sum_wrapped, size, \"before bounds checks\");\n\n    if (off >= buf_size - 1)\n    {\n      post_iterator_log(\"V1_EARLY_RETURN_OFF\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"off >= buf_size-1, discarding\");\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= buf_size)\n    {\n      /* Log that cropping will be performed and the amount. */\n      size_t new_size = (size_t) (buf_size - off - 1);\n      post_iterator_log(\"V1_CROPPING\", session, key, off, size, buf_size,\n                        sum_wrapped, new_size, \"cropping to fit buffer\");\n      size = new_size; /* crop extra data */\n    }\n    else\n    {\n      /* Log that no cropping was done. This is key for reproducing the\n         overflow scenario: large size that, due to wrapping of (size+off),\n         appears small and bypasses cropping. */\n      post_iterator_log(\"V1_NO_CROP\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"no cropping performed\");\n    }\n\n    /* Log parameters immediately before memcpy (dest pointer and length). */\n    {\n      void *dest = (void *)&session->value_1[off];\n      post_iterator_log(\"V1_BEFORE_MEMCPY\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"about to memcpy\");\n      /* Keep original logic intact. */\n      memcpy (dest, data, size);\n    }\n\n    /* Log intent to write terminating null and the computed index (may be\n       wrapped) without accessing that index here. We log the computed index\n       as the same wrapped expression to provide evidence if it is small. */\n    unsigned long long final_index = (unsigned long long) off + (unsigned long long) size;\n    post_iterator_log(\"V1_BEFORE_NULL\", session, key, off, size, buf_size,\n                      final_index, size, \"about to write terminating null at index\");\n\n    /* Original terminating write. This may be out-of-bounds in the violation\n       scenario; we do not change the behavior. */\n    session->value_1[size + off] = '\\0';\n\n    /* Confirm completion of branch */\n    post_iterator_log(\"V1_DONE\", session, key, off, size, buf_size,\n                      final_index, size, \"v1 completed\");\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    size_t buf_size = sizeof(session->value_2);\n    unsigned long long sum_wrapped = (unsigned long long) off + (unsigned long long) size;\n\n    post_iterator_log(\"V2_BEFORE_CHECK\", session, key, off, size, buf_size,\n                      sum_wrapped, size, \"before bounds checks\");\n\n    if (off >= buf_size - 1)\n    {\n      post_iterator_log(\"V2_EARLY_RETURN_OFF\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"off >= buf_size-1, discarding\");\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= buf_size)\n    {\n      size_t new_size = (size_t) (buf_size - off - 1);\n      post_iterator_log(\"V2_CROPPING\", session, key, off, size, buf_size,\n                        sum_wrapped, new_size, \"cropping to fit buffer\");\n      size = new_size; /* crop extra data */\n    }\n    else\n    {\n      post_iterator_log(\"V2_NO_CROP\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"no cropping performed\");\n    }\n\n    {\n      void *dest = (void *)&session->value_2[off];\n      post_iterator_log(\"V2_BEFORE_MEMCPY\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"about to memcpy\");\n      memcpy (dest, data, size);\n    }\n\n    unsigned long long final_index = (unsigned long long) off + (unsigned long long) size;\n    post_iterator_log(\"V2_BEFORE_NULL\", session, key, off, size, buf_size,\n                      final_index, size, \"about to write terminating null at index\");\n\n    session->value_2[size + off] = '\\0';\n\n    post_iterator_log(\"V2_DONE\", session, key, off, size, buf_size,\n                      final_index, size, \"v2 completed\");\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n\n  post_iterator_log(\"UNSUPPORTED\", session, key, off, size, 0,\n                    (unsigned long long) (off + (uint64_t) size), 0,\n                    \"unsupported key\");\n  return MHD_YES;\n}"
}