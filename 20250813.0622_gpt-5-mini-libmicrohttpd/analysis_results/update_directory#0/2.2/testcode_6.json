{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe initial memcpy call is dead: memcpy(rdc.buf, INDEX_PAGE_HEADER, len) writes the header to the start of the buffer but, later in the same function, memcpy(rdc.buf, INDEX_PAGE_FOOTER, len) copies the footer into the same start location (apparently a bug \u2014 it likely intended rdc.buf + rdc.off). The footer overwrite occurs before the response is created, so the initial header memcpy has no effect on the observable program behaviour and could be removed. Therefore Rule 2.2 is violated. (The subsequent rdc.off = len is not dead \u2014 it is required to position subsequent appends.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified update_directory code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of update_directory as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of update_directory:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\nPlease provide the modified update_directory code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\n/* Probe helpers: append logs to /tmp/logs/2.txt. */\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/2.txt\", \"a\");\n  if (NULL == f)\n    return;\n  time_t t = time (NULL);\n  struct tm tm_buf;\n#if defined(_MSC_VER)\n  localtime_s (&tm_buf, &t);\n#else\n  localtime_r (&t, &tm_buf);\n#endif\n  char ts[64];\n  (void) strftime (ts, sizeof (ts), \"%Y-%m-%d %H:%M:%S\", &tm_buf);\n  fprintf (f, \"[%s] \", ts);\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\n/* Dump a memory region as printable characters (non-printable as '.'). */\nstatic void\nprobe_dump_region (const char *label, const void *buf, size_t off, size_t len)\n{\n  const unsigned char *b = (const unsigned char *) buf;\n  size_t i;\n  size_t max = len;\n  if (max > 256)\n    max = 256; /* limit output */\n  FILE *f = fopen (\"/tmp/logs/2.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s: offset=%zu len=%zu (showing up to %zu bytes):\\n\", label, off, len, max);\n  fprintf (f, \"\\\"\");\n  for (i = 0; i < max; ++i)\n  {\n    unsigned char c = b[off + i];\n    if (isprint (c) || c == '\\n' || c == '\\t')\n      fputc (c, f);\n    else\n      fputc ('.', f);\n  }\n  fprintf (f, \"\\\"\\n\");\n  fclose (f);\n}\n\n/* The target function with logging probes inserted. Original logic preserved. */\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n\n  /* Probe: log state before initial memcpy */\n  probe_log (\"[update_directory] before initial memcpy: rdc.buf=%p rdc.buf_len=%zu header_len=%zu\", (void *) rdc.buf, rdc.buf_len, len);\n  /* Dump beginning of buffer (uninitialised region) and header content */\n  probe_dump_region (\"buffer_before_initial\", rdc.buf, 0, 64);\n  probe_log (\"INDEX_PAGE_HEADER='%s'\", INDEX_PAGE_HEADER);\n\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n\n  /* Probe: log after initial memcpy */\n  probe_dump_region (\"buffer_after_initial\", rdc.buf, 0, len > 256 ? 256 : len);\n  probe_log (\"[update_directory] after initial memcpy: wrote %zu bytes, setting rdc.off = %zu\", len, len);\n\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n\n  /* Probe: log state immediately before footer memcpy */\n  probe_log (\"[update_directory] before footer memcpy: rdc.buf=%p rdc.off=%zu footer_len=%zu\", (void *) rdc.buf, rdc.off, len);\n  probe_log (\"INDEX_PAGE_FOOTER='%s'\", INDEX_PAGE_FOOTER);\n  /* Dump the beginning of the buffer so we can see if header is still present */\n  probe_dump_region (\"buffer_before_footer\", rdc.buf, 0, rdc.off < 256 ? rdc.off : 256);\n\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n\n  /* Probe: log after footer memcpy to show overwrite evidence */\n  probe_dump_region (\"buffer_after_footer\", rdc.buf, 0, len > 256 ? 256 : len);\n  probe_log (\"[update_directory] after footer memcpy: copied footer %zu bytes to start; rdc.off will be incremented from %zu by %zu\", len, rdc.off, len);\n\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n"
}