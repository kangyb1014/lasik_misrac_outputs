{
  "user_message": "Target function code is:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}, 'update_cached_response': {'callees': ['MHD_destroy_response'], 'callers': ['update_directory', 'main']}, 'list_directory': {'callees': [], 'callers': ['update_directory']}, 'MHD_create_response_from_buffer_with_free_callback': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['ahc_echo', 'fill_v1_form', 'fill_v1_v2_form', 'update_directory']}, 'mark_as_html': {'callees': ['MHD_add_response_header'], 'callers': ['update_directory', 'main']}, 'generate_page': {'callees': ['MHD_queue_response', 'MHD_create_response_from_fd', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_post_processor', 'MHD_post_process', 'MHD_destroy_post_processor', 'update_directory', 'return_directory_response'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct ResponseDataContext",
    "struct MHD_Response",
    "struct Language",
    "languages (array)",
    "categories (array)",
    "INDEX_PAGE_HEADER",
    "INDEX_PAGE_FOOTER",
    "MHD_NO",
    "list_directory (prototype/definition)",
    "update_cached_response (prototype/definition)",
    "MHD_create_response_from_buffer_with_free_callback (prototype/definition)",
    "mark_as_html (prototype/definition)",
    "MHD_add_response_header (prototype/definition)",
    "malloc",
    "free",
    "strlen",
    "memcpy",
    "snprintf",
    "stat / struct stat / prototype of stat"
  ],
  "explanation": "To determine whether update_directory uses any language/compiler extensions you must inspect the declarations/definitions of any symbols, macros or types used by it because those definitions may themselves use compiler-specific extensions (e.g. GCC statement-expressions, attributes, typeof, nonstandard initializers, token-pasting, compound literals used in macros, or other implementation-specific constructs). Specifically:\n\n- struct ResponseDataContext: its definition (fields and any attributes) may use extensions (flexible array members, attributes, bit-fields, packed, etc.). update_directory accesses its members (buf_len, buf, off).\n- struct MHD_Response: definition may include implementation attributes or nonstandard members that indicate extension use; used with MHD_create_... and mark_as_html.\n- struct Language: ensure fields (dirname, longname) are standard types and not declared with extensions.\n- languages (array): the array definition or initialization may use designated initializers or other extensions.\n- categories (array): same rationale as languages \u2014 its declaration/initialization may use extensions.\n- INDEX_PAGE_HEADER and INDEX_PAGE_FOOTER: macros/constants may be defined with nonstandard constructs (macros using ({ ... }), offsetof tricks, or attributes) that are language extensions.\n- MHD_NO: macro/enum value might be defined via extension or unusual macro tricks; list_directory return/value comparison depends on it.\n- list_directory (prototype/definition): the function signature or implementation could use extension features (nonstandard parameter types, attributes, macros) that affect how it is used here.\n- update_cached_response (prototype/definition): could be a macro or inline function using extensions; also its parameter type (MHD_Response *) may hide attributes.\n- MHD_create_response_from_buffer_with_free_callback (prototype/definition): critical to inspect because the identifier could be a macro wrapper that employs extensions (variadic macros, compound-statement macros, GCC attributes) or nonstandard calling conventions.\n- mark_as_html (prototype/definition): may be a macro using extensions or add attributes to MHD_Response.\n- MHD_add_response_header (prototype/definition): this is invoked (conditionally) and mark_as_html is said to call it \u2014 inspect for macro/attribute usage.\n- malloc, free, strlen, memcpy, snprintf: though standard library functions, their declarations in included headers can carry implementation-specific attributes or macros; also snprintf could be a macro or inline function with extensions on some platforms.\n- stat / struct stat / prototype of stat: the stat API and struct stat layout come from system headers that on some platforms use extensions or attributes; update_directory calls stat and uses struct stat.\n\nProviding these symbol definitions allows the next analyst to check whether any of them are implemented or declared using compiler-specific language extensions that would cause update_directory (or the code it depends on) to violate the MISRA prohibition on language extensions."
}