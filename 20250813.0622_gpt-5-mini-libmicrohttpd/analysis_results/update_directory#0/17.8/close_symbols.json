{
  "user_message": "Target function code is:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}, 'update_cached_response': {'callees': ['MHD_destroy_response'], 'callers': ['update_directory', 'main']}, 'list_directory': {'callees': [], 'callers': ['update_directory']}, 'MHD_create_response_from_buffer_with_free_callback': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['ahc_echo', 'fill_v1_form', 'fill_v1_v2_form', 'update_directory']}, 'mark_as_html': {'callees': ['MHD_add_response_header'], 'callers': ['update_directory', 'main']}, 'generate_page': {'callees': ['MHD_queue_response', 'MHD_create_response_from_fd', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_post_processor', 'MHD_post_process', 'MHD_destroy_post_processor', 'update_directory', 'return_directory_response'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "update_cached_response",
    "list_directory",
    "MHD_create_response_from_buffer_with_free_callback",
    "mark_as_html",
    "MHD_add_response_header",
    "MHD_NO",
    "struct ResponseDataContext",
    "struct MHD_Response",
    "struct Language",
    "languages (global)",
    "categories (global)",
    "INDEX_PAGE_HEADER",
    "INDEX_PAGE_FOOTER",
    "malloc",
    "free",
    "strlen",
    "memcpy",
    "snprintf",
    "stat",
    "struct stat",
    "initial_allocation (static local)"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d for update_directory you need the following symbols and why:\n\n- update_cached_response: called with a response pointer (or NULL). Need prototype/definition to confirm whether update_directory passes pointers or modifies any of its own parameters (it has none) and to see any side-effects on objects passed.\n- list_directory: called with &rdc and dir_name; its signature and behaviour are needed to know what it expects/returns and whether update_directory prepares/changes pointer arguments before the call.\n- MHD_create_response_from_buffer_with_free_callback: called with rdc.buf and &free; its prototype is required to confirm how the buffer pointer is used and whether update_directory must preserve or modify any pointer parameter semantics.\n- mark_as_html: called with the response; definition/prototype helps determine whether update_directory is passing/altering pointers (again, to ensure no parameter of update_directory is being modified \u2014 none exist \u2014 and to understand side effects on objects passed).\n- MHD_add_response_header: used (conditionally) to add headers to response; prototype clarifies how pointer parameters are used and whether update_directory manipulates them.\n- MHD_NO: constant returned by list_directory; needed to understand control flow and early returns that affect resources (not a parameter issue itself but affects calls that pass pointers).\n- struct ResponseDataContext: full definition (fields buf, buf_len, off) is required to see what update_directory stores into these fields and whether any of these are actually parameters in other contexts or alias to function parameters.\n- struct MHD_Response: type definition to understand what update_directory obtains/forwards and how pointer-to-response is handled.\n- struct Language: type of languages[] elements; needed to see dirname/longname types (char * vs array) so we know whether update_directory is manipulating pointer parameters or globals.\n- languages (global): declaration/definition to confirm it is a global (not a parameter) and the type of dirname used in stats and snprintf calls.\n- categories (global): declaration/definition to confirm it is a global array of strings (not function parameters) and to check how category pointers are used.\n- INDEX_PAGE_HEADER and INDEX_PAGE_FOOTER: their definitions (strings/macros) to verify lengths and use in memcpy; they are not parameters but needed to follow pointer/size computations.\n- malloc, free, strlen, memcpy, snprintf: standard library prototypes to ensure correct usage of pointer/size parameters inside update_directory (e.g., no reassignment of function parameters \u2014 there are none \u2014 and buffer pointer usage is correct).\n- stat and struct stat: prototype and type to understand how stat is called and whether dirname pointers are passed (and whether those are parameters or globals).\n- initial_allocation (static local): its declaration/value is used and modified in update_directory; include to confirm it is not a function parameter and to check that the function only modifies internal/static state, not parameters.\n\nIn short: include the called functions, the involved types (ResponseDataContext, MHD_Response, Language, struct stat), the global arrays (languages, categories), buffer/header constants, and the standard library functions used. These symbols let the reviewer determine whether update_directory modifies any incoming function parameters (it has none) or improperly modifies pointer parameters passed to other functions (by inspecting the callees' prototypes/behaviour)."
}