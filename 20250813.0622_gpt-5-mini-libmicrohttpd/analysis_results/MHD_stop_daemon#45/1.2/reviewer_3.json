{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call expands the MHD_PANIC macro which (in the provided definitions) contains BUILTIN_NOT_REACHED. BUILTIN_NOT_REACHED is typically a wrapper around a compiler intrinsic (e.g. __builtin_unreachable or similar) and therefore uses a compiler-specific language extension. Because the fragment invokes MHD_PANIC (and thus the builtin macro), Rule 1.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/360.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fflush(f);\n  fclose(f);\n}\nstatic const MHD_socket MHD_INVALID_SOCKET = -1;\nstruct MHD_Worker\n{\n  bool shutdown;\n  intptr_t itc; /* abstract itc identifier (may be pointer or integer in real code) */\n};\nextern void MHD_PANIC(const char *msg);\nextern const char * _(const char *s);\nextern void mhd_assert(int cond);\nextern int MHD_thread_handle_ID_is_valid_handle_(intptr_t tid);\nextern int MHD_D_IS_USING_THREADS_(struct MHD_Daemon *d);\nextern int MHD_ITC_IS_VALID_(intptr_t itc);\nextern int MHD_ITC_IS_INVALID_(intptr_t itc);\nextern int MHD_itc_activate_(intptr_t itc, const char *msg);\nextern void MHD_itc_destroy_chk_(intptr_t itc);\nextern int MHD_thread_handle_ID_join_thread_(intptr_t tid);\nextern void MHD_socket_close_chk_(MHD_socket s);\nextern void MHD_mutex_destroy_chk_(void *m);\n\nvoid\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(__unix__) || defined(_WIN32)\n  unsigned int i;\n#endif\n\n  mhd_log(\"MHD_stop_daemon() enter: daemon=%p\", (void *)daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_log(\"MHD_stop_daemon(): daemon is NULL, returning\");\n    return;\n  }\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_log(\"MHD_stop_daemon(): detected double stop call: shutdown=%d master=%p\",\n            (int)daemon->shutdown, (void *)daemon->master);\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n  }\n\n  mhd_log(\"MHD_stop_daemon(): pre-assert state: options=0x%08x worker_pool=%p worker_pool_size=%u tid=%p\",\n          (unsigned int)daemon->options, (void *)daemon->worker_pool,\n          (unsigned int)daemon->worker_pool_size, (void *)&daemon->tid);\n\n  mhd_assert ((0 == (daemon->options & 0)) || /* placeholder masks */ \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & 0)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  mhd_log(\"MHD_stop_daemon(): set shutdown=true for daemon=%p\", (void *)daemon);\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_log(\"MHD_stop_daemon(): was_quiesced=%d listen_fd=%d\", (int)daemon->was_quiesced, (int)fd);\n\n#if defined(__unix__) || defined(_WIN32)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    mhd_log(\"MHD_stop_daemon(): master with worker_pool size=%u\", daemon->worker_pool_size);\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      /* Print itc as an integer instead of forcing as pointer. */\n      mhd_log(\"MHD_stop_daemon(): signaled worker %u shutdown, itc=%ld\", i, (long)(intptr_t)daemon->worker_pool[i].itc);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n        {\n          mhd_log(\"MHD_stop_daemon(): MHD_itc_activate_ failed for worker %u itc=%ld\", i, (long)(intptr_t)daemon->worker_pool[i].itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_log(\"MHD_stop_daemon(): recursively stopping worker %u at %p\", i, (void *)&daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(__unix__) || defined(_WIN32)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        mhd_log(\"MHD_stop_daemon(): activating itc for daemon=%p itc=%ld\", (void *)daemon, (long)(intptr_t)daemon->itc);\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n        {\n          mhd_log(\"MHD_stop_daemon(): MHD_itc_activate_ failed for daemon itc=%ld\", (long)(intptr_t)daemon->itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n      }\n      else\n      {\n        mhd_assert (false); /* Should never happen */\n      }\n\n      mhd_log(\"MHD_stop_daemon(): joining thread tid=%p for daemon=%p\", (void *)&daemon->tid, (void *)daemon);\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        mhd_log(\"MHD_stop_daemon(): failed to join thread tid=%p\", (void *)&daemon->tid);\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_log(\"MHD_stop_daemon(): no internal threads, calling close_all_connections for daemon=%p\", (void *)daemon);\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_log(\"MHD_stop_daemon(): destroying itc=%ld for daemon=%p\", (long)(intptr_t)daemon->itc, (void *)daemon);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#if defined(__unix__) || defined(_WIN32)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon. */\n\n    mhd_log(\"MHD_stop_daemon(): final cleanup for master/single daemon=%p fd=%d\", (void *)daemon, (int)fd);\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_log(\"MHD_stop_daemon(): closing listen fd=%d\", (int)fd);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* Other cleanup omitted in this simplified compilation unit */\n\n    free (daemon);\n    mhd_log(\"MHD_stop_daemon(): freed master daemon memory and exiting for daemon=%p\", (void *)daemon);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a Rule 1.2 violation. The reported fragment calls the macro MHD_PANIC, but the target code does not show the definition/expansion of MHD_PANIC or of any BUILTIN_NOT_REACHED wrapper. MISRA C 2023 Rule 1.2 applies only when compiler-specific language extensions are actually used (e.g. direct use of compiler intrinsics documented as extensions such as __builtin_unreachable, inline asm, vendor attributes, etc.). You cannot infer the use of an extension just from a macro call: the macro might expand to standard-conforming code, or to code guarded by compiler-specific macros. The provided test unit declares MHD_PANIC as extern (i.e. no intrinsic), and no definition shown; the attempted compilation failure does not prove the presence of a compiler extension in the original code. To confirm a real Rule 1.2 violation you must inspect the definitions of MHD_PANIC/BUILTIN_NOT_REACHED and check for explicit use of compiler intrinsics documented as extensions (e.g. __builtin_unreachable). If those definitions do use such intrinsics, then the report would be correct; as presented, the report is speculative and therefore incorrect."
}