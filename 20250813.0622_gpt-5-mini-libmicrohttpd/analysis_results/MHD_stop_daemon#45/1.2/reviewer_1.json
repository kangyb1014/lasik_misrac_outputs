{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro defines _MHD_EXTERN as __attribute__((visibility(\"default\")))extern which uses the GCC/Clang __attribute__((...)) syntax \u2014 a compiler-specific language extension documented by those compilers. This use of a compiler attribute is an explicit language extension, so MISRA C 2023 Rule 1.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_ensure_logdir(void)\n{\n    /* Best-effort create directory /tmp/logs; ignore errors. */\n    (void) mkdir(\"/tmp/logs\", 0777);\n}\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f;\n    va_list ap;\n    time_t t;\n    char timestr[64];\n\n    mhd_probe_ensure_logdir();\n    f = fopen(\"/tmp/logs/360.txt\", \"a\");\n    if (NULL == f)\n        return;\n\n    t = time(NULL);\n    if (t != (time_t)-1)\n    {\n        struct tm tmv;\n        if (localtime_r(&t, &tmv) != NULL)\n            (void) strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tmv);\n        else\n            strncpy(timestr, \"unknown-time\", sizeof(timestr));\n    }\n    else\n        strncpy(timestr, \"time-error\", sizeof(timestr));\n\n    fprintf(f, \"[%s] \", timestr);\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void mhd_probe_log_compiler_info(void)\n{\n#if defined(__clang__)\n    mhd_probe_log(\"Compiler: clang (\\\"__clang__\\\" defined)\");\n#elif defined(__GNUC__)\n    mhd_probe_log(\"Compiler: gcc (\\\"__GNUC__\\\" defined)\");\n#else\n    mhd_probe_log(\"Compiler: unknown (neither __clang__ nor __GNUC__ defined)\");\n#endif\n#if defined(__has_attribute)\n#if __has_attribute(visibility)\n    mhd_probe_log(\"Compiler reports support for __attribute__((visibility(...))) via __has_attribute(visibility)\");\n#else\n    mhd_probe_log(\"__has_attribute present but visibility attribute not reported by __has_attribute\");\n#endif\n#else\n    mhd_probe_log(\"__has_attribute not available; cannot query attribute support via preprocessor\");\n#endif\n}\n\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  mhd_probe_log_compiler_info();\n  mhd_probe_log(\"ENTER MHD_stop_daemon: daemon=%p\", (void *) daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_probe_log(\"daemon is NULL -> returning immediately\");\n    return;\n  }\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_probe_log(\"Detected double-stop: daemon->shutdown=true and daemon->master==NULL -> about to panic\");\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n  }\n\n  mhd_probe_log(\"Assertions prior to shutdown: options=0x%08x, worker_pool=%p, tid_flag=%d\",\n                (unsigned int) daemon->options,\n                (void *) daemon->worker_pool,\n                (int) MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  mhd_probe_log(\"Set daemon->shutdown = true\");\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_probe_log(\"Computed fd = %d (was_quiesced=%d, listen_fd=%d)\",\n                (int) fd, (int) daemon->was_quiesced, (int) daemon->listen_fd);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    mhd_probe_log(\"Master daemon with worker pool: pool=%p size=%u\",\n                  (void *) daemon->worker_pool, daemon->worker_pool_size);\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      mhd_probe_log(\"Signaled worker %u: worker_pool[%u].shutdown = true\", i, i);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        mhd_probe_log(\"Worker %u: itc is valid -> activating itc\", i);\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"Worker %u: MHD_itc_activate_ returned false -> panic\", i);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n          mhd_probe_log(\"Worker %u: MHD_itc_activate_ succeeded\", i);\n      }\n      else\n      {\n        mhd_probe_log(\"Worker %u: itc is invalid -> expect fd != MHD_INVALID_SOCKET (fd=%d)\", i, (int) fd);\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n      }\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_probe_log(\"Calling shutdown on listen fd=%d (HAVE_LISTEN_SHUTDOWN)\", (int) fd);\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_probe_log(\"Recursing to stop worker %u at %p\", i, (void *) &daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_probe_log(\"Freed worker_pool memory\");\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        mhd_probe_log(\"No worker_pool but using threads: itc is valid -> activating itc\");\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"Threaded daemon: MHD_itc_activate_ failed -> panic\");\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n          mhd_probe_log(\"Threaded daemon: MHD_itc_activate_ succeeded\");\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n          {\n            mhd_probe_log(\"No itc and master==NULL -> calling shutdown(fd=%d)\", (int) fd);\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n          }\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        {\n          mhd_probe_log(\"No itc and no valid fd -> assertion fail expected (should never happen)\");\n          mhd_assert (false); /* Should never happen */\n        }\n      }\n\n      mhd_probe_log(\"Joining thread tid=%p\", (void *)(uintptr_t) daemon->tid);\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        mhd_probe_log(\"Failed to join thread -> panic\");\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      else\n        mhd_probe_log(\"Joined thread successfully\");\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_probe_log(\"No internal threads used -> calling close_all_connections(daemon=%p)\", (void *) daemon);\n      close_all_connections (daemon);\n    }\n    mhd_probe_log(\"Asserting all connection lists are NULL (cleanup)\\n\");\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_probe_log(\"itc valid -> destroying itc at %p\", (void *)(uintptr_t) daemon->itc);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n    {\n      mhd_probe_log(\"Closing epoll_fd=%d\", daemon->epoll_fd);\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n    {\n      mhd_probe_log(\"Closing epoll_upgrade_fd=%d\", daemon->epoll_upgrade_fd);\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    mhd_probe_log(\"Master/single daemon cleanup branch entered (master==NULL)\");\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_probe_log(\"Closing listen socket fd=%d\", (int) fd);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      mhd_probe_log(\"Deinitializing DH params\");\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      mhd_probe_log(\"Deinitializing TLS priority & credentials\");\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    mhd_probe_log(\"Freeing DAUTH-related allocations\");\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    mhd_probe_log(\"Freeing daemon structure at %p\", (void *) daemon);\n    free (daemon);\n  }\n  mhd_probe_log(\"EXIT MHD_stop_daemon (daemon master branch completed)\");\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 1.2 forbids the use of language/compiler extensions that are documented as extensions by the compiler. The GCC/Clang form __attribute__((visibility(\"default\"))) is a compiler-specific extension (documented as such by GCC/Clang) and is not part of standard C. If the _MHD_EXTERN macro expands to __attribute__((visibility(\"default\"))) extern (as stated by agent A), then the function declaration in the shown code uses that compiler attribute and therefore violates MISRA C 2023 Rule 1.2. \n\nCaveat: the conclusion depends on the actual definition of _MHD_EXTERN. If _MHD_EXTERN is defined differently (for example, just \"extern\" or conditionally empty for strict-standard builds), then there is no violation. Given agent A\u2019s claim that _MHD_EXTERN expands to the GCC/Clang attribute, the report is correct."
}