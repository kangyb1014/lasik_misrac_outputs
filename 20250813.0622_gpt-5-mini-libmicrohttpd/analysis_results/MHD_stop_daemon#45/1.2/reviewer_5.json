{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The fragment calls the MHD_PANIC macro; in the provided macro definition MHD_PANIC expands to include BUILTIN_NOT_REACHED. That token is typically mapped to a compiler builtin such as __builtin_unreachable (a compiler-specific intrinsic documented as an extension). Because the fragment invokes MHD_PANIC, it therefore uses a compiler language extension via BUILTIN_NOT_REACHED (and the codebase also contains other explicit extensions such as __attribute__((visibility(\"default\"))) in _MHD_EXTERN).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const MHD_socket MHD_INVALID_SOCKET = (MHD_socket)-1;\nstruct MHD_worker {\n    void *itc; /* inter-thread communication channel (represented as a pointer) */\n    bool shutdown;\n};\nvoid MHD_PANIC(const char *msg);\nconst char *_(const char *s);\nvoid mhd_assert(int cond);\nint MHD_thread_handle_ID_is_valid_handle_(void *tid);\nint MHD_thread_handle_ID_join_thread_(void *tid);\nint MHD_itc_activate_(void *itc, const char *msg);\nint MHD_ITC_IS_VALID_(void *itc);\nint MHD_ITC_IS_INVALID_(void *itc);\nint MHD_D_IS_USING_THREADS_(struct MHD_Daemon *d);\nint MHD_D_IS_USING_EPOLL_(struct MHD_Daemon *d);\nvoid MHD_socket_close_chk_(int fd);\nvoid MHD_itc_destroy_chk_(void *itc);\nvoid MHD_mutex_destroy_chk_(void *m);\nvoid gnutls_dh_params_deinit(void *p);\nvoid gnutls_priority_deinit(void *p);\nvoid gnutls_certificate_free_credentials(void *p);\nvoid gnutls_psk_free_server_credentials(void *p);\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/360.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nvoid\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n  unsigned int i;\n#endif\n\n  /* Entry probe */\n  mhd_log_probe(\"ENTER MHD_stop_daemon: daemon=%p\", (void *)daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_log_probe(\"MHD_stop_daemon: daemon is NULL, returning\");\n    return;\n  }\n\n  mhd_log_probe(\"daemon state: shutdown=%d master=%p was_quiesced=%d listen_fd=%ld options=0x%lx worker_pool=%p worker_pool_size=%u tid=%p\",\n                (int)daemon->shutdown,\n                (void *)daemon->master,\n                (int)daemon->was_quiesced,\n                (long)daemon->listen_fd,\n                (unsigned long)daemon->options,\n                (void *)daemon->worker_pool,\n                (unsigned int)daemon->worker_pool_size,\n                /* Some implementations store tid as non-pointer; to avoid \"cannot convert to a pointer type\"\n                   cast errors when tid isn't a pointer type, print the address of the tid field. */\n                (void *)&daemon->tid);\n\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    /* Log the double-stop scenario prior to invoking MHD_PANIC */\n    mhd_log_probe(\"MHD_stop_daemon: detected double stop (shutdown && master==NULL). About to call MHD_PANIC. daemon=%p\", (void *)daemon);\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n  }\n\n  mhd_assert ((0 == (daemon->options & 0)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & 0)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_log_probe(\"After setting shutdown=true: was_quiesced=%d fd=%ld\", (int)daemon->was_quiesced, (long)fd);\n\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    mhd_log_probe(\"Master daemon with worker_pool: pool=%p size=%u\", (void *)daemon->worker_pool, (unsigned int)daemon->worker_pool_size);\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      mhd_log_probe(\"Signaling worker %u: worker=%p itc=%p shutdown=%d\", i, (void *)&daemon->worker_pool[i], (void *)daemon->worker_pool[i].itc, (int)daemon->worker_pool[i].shutdown);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n        {\n          mhd_log_probe(\"MHD_itc_activate_ failed for worker %u itc=%p. About to call MHD_PANIC\", i, (void *)daemon->worker_pool[i].itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n      mhd_log_probe(\"Called shutdown(fd=%ld) for listen socket\", (long)fd);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_log_probe(\"Recursing into MHD_stop_daemon for worker %u at %p\", i, (void *)&daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_log_probe(\"Freed worker_pool for daemon=%p\", (void *)daemon);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n        {\n          mhd_log_probe(\"MHD_itc_activate_ failed for daemon itc=%p. About to call MHD_PANIC\", (void *)daemon->itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n          mhd_log_probe(\"Called shutdown(fd=%ld) in worker/single-daemon path (master==NULL)\", (long)fd);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        mhd_log_probe(\"MHD_thread_handle_ID_join_thread_ failed for tid=%p. About to call MHD_PANIC\", (void *)&daemon->tid);\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_log_probe(\"No internal threads: calling close_all_connections for daemon=%p\", (void *)daemon);\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_log_probe(\"Destroying itc for daemon itc=%p\", (void *)daemon->itc);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n    {\n      mhd_log_probe(\"Closing epoll_fd=%d for daemon=%p\", daemon->epoll_fd, (void *)daemon);\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n    {\n      mhd_log_probe(\"Closing epoll_upgrade_fd=%d for daemon=%p\", daemon->epoll_upgrade_fd, (void *)daemon);\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_log_probe(\"Closing listen_fd=%ld for master/single daemon=%p\", (long)fd, (void *)daemon);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      mhd_log_probe(\"Cleaning up DH params for daemon=%p\", (void *)daemon);\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & 0))\n    {\n      mhd_log_probe(\"Cleaning up TLS credentials for daemon=%p\", (void *)daemon);\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(_POSIX_THREADS) || defined(_WIN32)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    mhd_log_probe(\"Freeing daemon=%p (master cleanup)\", (void *)daemon);\n    free (daemon);\n  }\n  else\n  {\n    mhd_log_probe(\"Exiting MHD_stop_daemon for worker daemon=%p (master=%p)\", (void *)daemon, (void *)daemon->master);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not sufficient evidence to conclude a MISRA C 2023 Rule 1.2 violation from the fragment as provided. The source shown only uses macros (e.g. _MHD_EXTERN, MHD_PANIC) but does not include their definitions. Rule 1.2 prohibits use of compiler language extensions (for example __attribute__((...)) or __builtin_unreachable), however the rule applies only when the code actually uses such documented compiler extensions. Agent A's claim depends on the macro expansions (BUILTIN_NOT_REACHED -> __builtin_unreachable and _MHD_EXTERN -> __attribute__((visibility(\"default\")))) which were not shown in the provided code. The test instrumentation failed to build, so no concrete proof was produced. Therefore, based on the material given, the report is not proven correct. If you want a definite judgement, provide the macro definitions (or the header where _MHD_EXTERN, MHD_PANIC and BUILTIN_NOT_REACHED are defined) or confirm whether they expand to compiler-specific extensions; if they do, then the code would indeed violate MISRA C 2023 Rule 1.2."
}