{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/360.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    (void)vfprintf(f, fmt, ap);\n    va_end(ap);\n    (void)fclose(f);\n}\nstatic void mhd_log_daemon_state(void *daemon_ptr, const char *location)\n{\n    /* Print a best-effort set of fields. Access must only be done when\n       daemon_ptr is non-NULL and the struct layout is available in this\n       translation unit (it is in the original code). */\n    if (NULL == daemon_ptr)\n    {\n        mhd_probe_log(\"%s: daemon=NULL\\n\", location);\n        return;\n    }\n    /* Use the known field names from the original code. */\n    struct MHD_Daemon *d = (struct MHD_Daemon *)daemon_ptr;\n    mhd_probe_log(\n        \"%s: daemon=%p, shutdown=%d, master=%p, was_quiesced=%d, listen_fd=%d, options=0x%x, worker_pool=%p, worker_pool_size=%u, tid=%p, itc=%p\\n\",\n        location,\n        (void *)d,\n        (int)d->shutdown,\n        (void *)d->master,\n        (int)d->was_quiesced,\n        (int)d->listen_fd,\n        (unsigned int)d->options,\n        (void *)d->worker_pool,\n        (unsigned int)d->worker_pool_size,\n        (void *)d->tid,\n        (void *)d->itc\n    );\n}\n\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  /* Log function entry and note that the declaration used the token\n     \"_MHD_EXTERN\" (this is a source-level hint to reproduce the\n     compile-time extension usage scenario). */\n  mhd_probe_log(\"ENTER MHD_stop_daemon: declaration_includes=_MHD_EXTERN, daemon_ptr=%p\\n\", (void *)daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_probe_log(\"MHD_stop_daemon: daemon is NULL, returning immediately\\n\");\n    return;\n  }\n\n  /* Log initial state before checks that may panic. */\n  mhd_log_daemon_state(daemon, \"before_shutdown_check\");\n\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_probe_log(\"MHD_stop_daemon: detected double stop: shutdown=%d, master=%p - about to call MHD_PANIC\\n\", (int)daemon->shutdown, (void *)daemon->master);\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n  }\n\n  mhd_log_daemon_state(daemon, \"after_double_stop_check\");\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  mhd_probe_log(\"MHD_stop_daemon: set daemon->shutdown = true for %p\\n\", (void *)daemon);\n\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_probe_log(\"MHD_stop_daemon: chosen listen fd=%d (was_quiesced=%d)\\n\", (int)fd, (int)daemon->was_quiesced);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    mhd_probe_log(\"MHD_stop_daemon: entering master-with-worker-pool branch: pool_size=%u\\n\", (unsigned int)daemon->worker_pool_size);\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      mhd_probe_log(\"MHD_stop_daemon: worker[%u]=%p set shutdown=true, itc=%p\\n\", i, (void *)&daemon->worker_pool[i], (void *)daemon->worker_pool[i].itc);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for worker[%u], itc=%p - about to panic\\n\", i, (void *)daemon->worker_pool[i].itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ succeeded for worker[%u]\\n\", i);\n        }\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n      mhd_probe_log(\"MHD_stop_daemon: shutdown(listen_fd=%d) called (HAVE_LISTEN_SHUTDOWN)\\n\", (int)fd);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: recursively stopping worker[%u] at %p\\n\", i, (void *)&daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_probe_log(\"MHD_stop_daemon: freed worker_pool for daemon=%p\\n\", (void *)daemon);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for single/worker daemon itc=%p - about to panic\\n\", (void *)daemon->itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ succeeded for single/worker daemon itc=%p\\n\", (void *)daemon->itc);\n        }\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n          mhd_probe_log(\"MHD_stop_daemon: shutdown(listen_fd=%d) called for single/worker (HAVE_LISTEN_SHUTDOWN)\\n\", (int)fd);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        mhd_probe_log(\"MHD_stop_daemon: join_thread failed for tid=%p - about to panic\\n\", (void *)daemon->tid);\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      else\n      {\n        mhd_probe_log(\"MHD_stop_daemon: joined thread tid=%p successfully\\n\", (void *)daemon->tid);\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_probe_log(\"MHD_stop_daemon: calling close_all_connections for daemon=%p\\n\", (void *)daemon);\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_probe_log(\"MHD_stop_daemon: destroying itc=%p\\n\", (void *)daemon->itc);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing epoll_fd=%d\\n\", (int)daemon->epoll_fd);\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing epoll_upgrade_fd=%d\\n\", (int)daemon->epoll_upgrade_fd);\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    mhd_probe_log(\"MHD_stop_daemon: performing master cleanup for daemon=%p\\n\", (void *)daemon);\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing listen fd=%d\\n\", (int)fd);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: deinit dhparams for daemon=%p\\n\", (void *)daemon);\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      mhd_probe_log(\"MHD_stop_daemon: TLS cleanup for daemon=%p\\n\", (void *)daemon);\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    mhd_probe_log(\"MHD_stop_daemon: DAUTH cleanup for daemon=%p\\n\", (void *)daemon);\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    mhd_probe_log(\"MHD_stop_daemon: freeing daemon struct %p\\n\", (void *)daemon);\n    free (daemon);\n    mhd_probe_log(\"EXIT MHD_stop_daemon: completed cleanup for master daemon\\n\");\n  }\n  else\n  {\n    mhd_probe_log(\"EXIT MHD_stop_daemon: worker daemon cleanup complete for %p (master=%p)\\n\", (void *)daemon, (void *)daemon->master);\n  }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndaemon.c: In function 'mhd_log_daemon_state':\ndaemon.c:9308:9: error: cannot convert to a pointer type\n 9308 |         (void *)d->tid,\n      |         ^\ndaemon.c:9310:5: error: cannot convert to a pointer type\n 9310 |     );\n      |     ^\ndaemon.c: In function 'MHD_stop_daemon':\ndaemon.c:9375:7: error: cannot convert to a pointer type\n 9375 |       mhd_probe_log(\"MHD_stop_daemon: worker[%u]=%p set shutdown=true, itc=%p\\n\", i, (void *)&daemon->worker_pool[i], (void *)daemon->worker_pool[i].itc);\n      |       ^~~~~~~~~~~~~\ndaemon.c:9381:11: error: cannot convert to a pointer type\n 9381 |           mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for worker[%u], itc=%p - about to panic\\n\", i, (void *)daemon->worker_pool[i].itc);\n      |           ^~~~~~~~~~~~~\ndaemon.c:9429:11: error: cannot convert to a pointer type\n 9429 |           mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for single/worker daemon itc=%p - about to panic\\n\", (void *)daemon->itc);\n      |           ^~~~~~~~~~~~~\ndaemon.c:9435:11: error: cannot convert to a pointer type\n 9435 |           mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ succeeded for single/worker daemon itc=%p\\n\", (void *)daemon->itc);\n      |           ^~~~~~~~~~~~~\ndaemon.c:9455:9: error: cannot convert to a pointer type\n 9455 |         mhd_probe_log(\"MHD_stop_daemon: join_thread failed for tid=%p - about to panic\\n\", (void *)daemon->tid);\n      |         ^~~~~~~~~~~~~\ndaemon.c:9460:9: error: cannot convert to a pointer type\n 9460 |         mhd_probe_log(\"MHD_stop_daemon: joined thread tid=%p successfully\\n\", (void *)daemon->tid);\n      |         ^~~~~~~~~~~~~\ndaemon.c:9481:7: error: cannot convert to a pointer type\n 9481 |       mhd_probe_log(\"MHD_stop_daemon: destroying itc=%p\\n\", (void *)daemon->itc);\n      |       ^~~~~~~~~~~~~\nmake[3]: *** [Makefile:2112: libmicrohttpd_la-daemon.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_stop_daemon as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/360.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    (void)vfprintf(f, fmt, ap);\n    va_end(ap);\n    (void)fclose(f);\n}\nstatic void mhd_log_daemon_state(void *daemon_ptr, const char *location)\n{\n    /* Print a best-effort set of fields. Access must only be done when\n       daemon_ptr is non-NULL and the struct layout is available in this\n       translation unit (it is in the original code). */\n    if (NULL == daemon_ptr)\n    {\n        mhd_probe_log(\"%s: daemon=NULL\\n\", location);\n        return;\n    }\n    /* Use the known field names from the original code. */\n    struct MHD_Daemon *d = (struct MHD_Daemon *)daemon_ptr;\n    mhd_probe_log(\n        \"%s: daemon=%p, shutdown=%d, master=%p, was_quiesced=%d, listen_fd=%d, options=0x%x, worker_pool=%p, worker_pool_size=%u, tid=%p, itc=%p\\n\",\n        location,\n        (void *)d,\n        (int)d->shutdown,\n        (void *)d->master,\n        (int)d->was_quiesced,\n        (int)d->listen_fd,\n        (unsigned int)d->options,\n        (void *)d->worker_pool,\n        (unsigned int)d->worker_pool_size,\n        /* tid and itc may be non-pointer (e.g. structs/handles). Take their addresses\n           so we can safely print an address/pointer representation. */\n        (void *)&d->tid,\n        (void *)&d->itc\n    );\n}\n\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  /* Log function entry and note that the declaration used the token\n     \"_MHD_EXTERN\" (this is a source-level hint to reproduce the\n     compile-time extension usage scenario). */\n  mhd_probe_log(\"ENTER MHD_stop_daemon: declaration_includes=_MHD_EXTERN, daemon_ptr=%p\\n\", (void *)daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_probe_log(\"MHD_stop_daemon: daemon is NULL, returning immediately\\n\");\n    return;\n  }\n\n  /* Log initial state before checks that may panic. */\n  mhd_log_daemon_state(daemon, \"before_shutdown_check\");\n\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_probe_log(\"MHD_stop_daemon: detected double stop: shutdown=%d, master=%p - about to call MHD_PANIC\\n\", (int)daemon->shutdown, (void *)daemon->master);\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n  }\n\n  mhd_log_daemon_state(daemon, \"after_double_stop_check\");\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  mhd_probe_log(\"MHD_stop_daemon: set daemon->shutdown = true for %p\\n\", (void *)daemon);\n\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_probe_log(\"MHD_stop_daemon: chosen listen fd=%d (was_quiesced=%d)\\n\", (int)fd, (int)daemon->was_quiesced);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    mhd_probe_log(\"MHD_stop_daemon: entering master-with-worker-pool branch: pool_size=%u\\n\", (unsigned int)daemon->worker_pool_size);\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      mhd_probe_log(\"MHD_stop_daemon: worker[%u]=%p set shutdown=true, itc=%p\\n\", i, (void *)&daemon->worker_pool[i], (void *)&daemon->worker_pool[i].itc);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for worker[%u], itc=%p - about to panic\\n\", i, (void *)&daemon->worker_pool[i].itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ succeeded for worker[%u]\\n\", i);\n        }\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n      mhd_probe_log(\"MHD_stop_daemon: shutdown(listen_fd=%d) called (HAVE_LISTEN_SHUTDOWN)\\n\", (int)fd);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: recursively stopping worker[%u] at %p\\n\", i, (void *)&daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_probe_log(\"MHD_stop_daemon: freed worker_pool for daemon=%p\\n\", (void *)daemon);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ failed for single/worker daemon itc=%p - about to panic\\n\", (void *)&daemon->itc);\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n        }\n        else\n        {\n          mhd_probe_log(\"MHD_stop_daemon: MHD_itc_activate_ succeeded for single/worker daemon itc=%p\\n\", (void *)&daemon->itc);\n        }\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n          mhd_probe_log(\"MHD_stop_daemon: shutdown(listen_fd=%d) called for single/worker (HAVE_LISTEN_SHUTDOWN)\\n\", (int)fd);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        mhd_probe_log(\"MHD_stop_daemon: join_thread failed for tid=%p - about to panic\\n\", (void *)&daemon->tid);\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      else\n      {\n        mhd_probe_log(\"MHD_stop_daemon: joined thread tid=%p successfully\\n\", (void *)&daemon->tid);\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_probe_log(\"MHD_stop_daemon: calling close_all_connections for daemon=%p\\n\", (void *)daemon);\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_probe_log(\"MHD_stop_daemon: destroying itc=%p\\n\", (void *)&daemon->itc);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing epoll_fd=%d\\n\", (int)daemon->epoll_fd);\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing epoll_upgrade_fd=%d\\n\", (int)daemon->epoll_upgrade_fd);\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    mhd_probe_log(\"MHD_stop_daemon: performing master cleanup for daemon=%p\\n\", (void *)daemon);\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: closing listen fd=%d\\n\", (int)fd);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      mhd_probe_log(\"MHD_stop_daemon: deinit dhparams for daemon=%p\\n\", (void *)daemon);\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      mhd_probe_log(\"MHD_stop_daemon: TLS cleanup for daemon=%p\\n\", (void *)daemon);\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    mhd_probe_log(\"MHD_stop_daemon: DAUTH cleanup for daemon=%p\\n\", (void *)daemon);\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    mhd_probe_log(\"MHD_stop_daemon: freeing daemon struct %p\\n\", (void *)daemon);\n    free (daemon);\n    mhd_probe_log(\"EXIT MHD_stop_daemon: completed cleanup for master daemon\\n\");\n  }\n  else\n  {\n    mhd_probe_log(\"EXIT MHD_stop_daemon: worker daemon cleanup complete for %p (master=%p)\\n\", (void *)daemon, (void *)daemon->master);\n  }\n}\n",
  "explanation": "The compilation errors were caused by attempts to cast non-pointer fields (such as tid and itc) directly to (void *). Those fields can be non-scalar (e.g. structs/handles), so casting them to a pointer type is invalid. I changed the offending casts to take the address of those fields (e.g. (void *)&daemon->tid and (void *)&daemon->itc) so they can be printed safely with %p. No other logic was changed."
}