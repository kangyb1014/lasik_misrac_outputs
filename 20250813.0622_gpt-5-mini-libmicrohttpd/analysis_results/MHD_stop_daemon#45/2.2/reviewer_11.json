{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as mhd_assert(ignore) ((void)0). Therefore the statement mhd_assert((NULL == daemon->master) || (daemon->shutdown)); compiles to a no-op expression statement ((void)0); it is executed but has no effect and its removal would not affect program behaviour. This is dead code under MISRA C 2023 Rule 2.2 (given the current project macro definition).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nconst MHD_socket MHD_INVALID_SOCKET = (void *) -1;\nvoid MHD_PANIC (const char *msg);\nvoid mhd_assert (int cond);\nint MHD_thread_handle_ID_is_valid_handle_ (void *tid);\nint MHD_itc_activate_ (void *itc, const char *msg);\nint MHD_ITC_IS_VALID_ (void *itc);\nint MHD_ITC_IS_INVALID_ (void *itc);\nint MHD_D_IS_USING_THREADS_ (struct MHD_Daemon *d);\nint MHD_thread_handle_ID_join_thread_ (void *tid);\nvoid MHD_itc_destroy_chk_ (void *itc);\nvoid MHD_socket_close_chk_ (void *s);\nvoid MHD_mutex_destroy_chk_ (void *m);\nstatic void\nmhd_probe_log_state (const char *tag, struct MHD_Daemon *daemon)\n{\n  FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Print commonly used fields seen in MHD_stop_daemon to help reproduce\n     assertion / dead-code scenarios. Use pointer-format for tid and\n     listen_fd to avoid depending on the concrete typedefs of those\n     fields. */\n  (void) fprintf (f,\n                  \"%s: daemon=%p master=%p shutdown=%d options=0x%08x \"\n                  \"worker_pool=%p worker_pool_size=%u tid=%p \"\n                  \"was_quiesced=%d listen_fd=%p\\n\",\n                  tag,\n                  (void *) daemon,\n                  (void *) daemon->master,\n                  (int) daemon->shutdown,\n                  (unsigned) daemon->options,\n                  (void *) daemon->worker_pool,\n                  (unsigned) daemon->worker_pool_size,\n                  (void *) daemon->tid,\n                  (int) daemon->was_quiesced,\n                  (void *) daemon->listen_fd);\n  (void) fclose (f);\n}\nstatic void\nmhd_probe_log_assert_eval (const char *tag, int lhs, int rhs)\n{\n  FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n  if (NULL == f)\n    return;\n  (void) fprintf (f, \"%s: assertion parts -> lhs=%d rhs=%d (lhs || rhs == %d)\\n\",\n                  tag, lhs, rhs, (lhs || rhs));\n  (void) fclose (f);\n}\n\nvoid\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd = MHD_INVALID_SOCKET;\n\n  /* Entry probe */\n  mhd_probe_log_state (\"MHD_stop_daemon ENTER\", daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_probe_log_state (\"MHD_stop_daemon: daemon == NULL, returning\", daemon);\n    return;\n  }\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (\"MHD_stop_daemon() was called twice.\");\n\n  mhd_assert ((0 == (daemon->options & 0)) ||\n              (NULL != daemon->worker_pool) ||\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & 0)) &&\n               (NULL == daemon->worker_pool)) ||\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  /* Probe the specific assertion that is reported as a dead-code site. */\n  mhd_probe_log_state (\"Before slave-master mhd_assert\", daemon);\n  mhd_probe_log_assert_eval (\"slave-master assertion evaluation\",\n                             (NULL == daemon->master) ? 1 : 0,\n                             (daemon->shutdown) ? 1 : 0);\n\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  /* Log the change of shutdown flag: record previous state then after set. */\n  mhd_probe_log_state (\"Before setting daemon->shutdown = true\", daemon);\n  daemon->shutdown = true;\n  mhd_probe_log_state (\"After setting daemon->shutdown = true\", daemon);\n\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  /* For this minimal unit, skip threaded and epoll-specific cleanup\n     paths. Preserve non-threaded cleanup behavior. */\n  {\n    /* No internal threads are used for polling sockets. */\n    close_all_connections (daemon);\n\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n\n    if (daemon->itc)\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n    if (fd != MHD_INVALID_SOCKET)\n      MHD_socket_close_chk_ (fd);\n\n    MHD_mutex_destroy_chk_ (NULL);\n  }\n\n  if (NULL == daemon->master)\n  {\n    /* Final probe before freeing the daemon structure. */\n    mhd_probe_log_state (\"Master cleanup: about to free daemon\", daemon);\n    free (daemon);\n    mhd_probe_log_state (\"Master cleanup: freed daemon (note: pointer now dangling)\", daemon);\n  }\n\n  /* Exit probe */\n  mhd_probe_log_state (\"MHD_stop_daemon EXIT\", daemon);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct under the scenario Agent A described. If mhd_assert is defined as a no-op macro such as\n    #define mhd_assert(ignore) ((void)0)\nthen every call like\n    mhd_assert((NULL == daemon->master) || (daemon->shutdown));\nexpands to a no-op expression statement. That statement is executed (or at least present in the source) but has no effect; removing it would not change program behaviour (the condition is not evaluated and there are no side-effects left behind). By the plain text of MISRA C:2023 Rule 2.2 (\u201cAny operation that is executed but whose removal would not affect program behaviour constitutes dead code.\u201d) those assertion statements are dead code and therefore violate Rule 2.2.\n\nCaveats/nuance:\n- The conclusion depends on the actual macro definition in the project. If mhd_assert expands to something that evaluates the condition or performs logging/diagnostics, it is not dead code. If it expands to something that still forces evaluation of the operand (for example casting to void: (void)(cond)), that is not a no-op and may avoid the violation.\n- Timing/side-effect considerations in Note 1 of Rule 2.2 mean that if removing the assertion changed timing in a way that affects behaviour, it would not be considered dead code. In the concrete no-op macro case there is no generated code and thus no timing/behavioural effect.\n\nRecommendation: either ensure the assert macro preserves useful behaviour (e.g. logs or evaluates the condition in release builds if that is required for observable behaviour) or remove the assertion statements when the macro is a no-op so the project does not contain dead code (or refactor so the release macro evaluates something with observable effect as required by MISRA)."
}