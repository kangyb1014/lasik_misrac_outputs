{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_stop_daemon:\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_stop_daemon:\nstruct MHD_Daemon\n{\n\n  /**\n   * Callback function for all requests.\n   */\n  MHD_AccessHandlerCallback default_handler;\n\n  /**\n   * Closure argument to default_handler.\n   */\n  void *default_handler_cls;\n\n  /**\n   * Daemon's flags (bitfield).\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  enum MHD_FLAG options;\n\n  /**\n   * Head of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_head;\n\n  /**\n   * Tail of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_tail;\n\n  /**\n   * Head of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_head;\n\n  /**\n   * Tail of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_tail;\n\n  /**\n   * _MHD_YES if the @e listen_fd socket is a UNIX domain socket.\n   */\n  enum MHD_tristate listen_is_unix;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Head of EDLL of connections ready for processing (in epoll mode).\n   */\n  struct MHD_Connection *eready_head;\n\n  /**\n   * Tail of EDLL of connections ready for processing (in epoll mode)\n   */\n  struct MHD_Connection *eready_tail;\n\n  /**\n   * File descriptor associated with our epoll loop.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  int epoll_fd;\n\n  /**\n   * true if the @e listen_fd socket is in the 'epoll' set,\n   * false if not.\n   */\n  bool listen_socket_in_epoll;\n\n#ifdef UPGRADE_SUPPORT\n#ifdef HTTPS_SUPPORT\n  /**\n   * File descriptor associated with the #run_epoll_for_upgrade() loop.\n   * Only available if #MHD_USE_HTTPS_EPOLL_UPGRADE is set.\n   */\n  int epoll_upgrade_fd;\n\n  /**\n   * true if @e epoll_upgrade_fd is in the 'epoll' set,\n   * false if not.\n   */\n  bool upgrade_fd_in_epoll;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Head of EDLL of upgraded connections ready for processing (in epoll mode).\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_head;\n\n  /**\n   * Tail of EDLL of upgraded connections ready for processing (in epoll mode)\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_tail;\n#endif /* UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * Head of the XDLL of ALL connections with a default ('normal')\n   * timeout, sorted by timeout (earliest at the tail, most recently\n   * used connection at the head).  MHD can just look at the tail of\n   * this list to determine the timeout for all of its elements;\n   * whenever there is an event of a connection, the connection is\n   * moved back to the tail of the list.\n   *\n   * All connections by default start in this list; if a custom\n   * timeout that does not match @e connection_timeout_ms is set, they\n   * are moved to the @e manual_timeout_head-XDLL.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode as each thread\n   * needs only one connection-specific timeout.\n   */\n  struct MHD_Connection *normal_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a default timeout,\n   * sorted by timeout (earliest timeout at the tail).\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *normal_timeout_tail;\n\n  /**\n   * Head of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.  MHD will do a O(n) scan over this list to\n   * determine the current timeout.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_tail;\n\n  /**\n   * Function to call to check if we should accept or reject an\n   * incoming request.  May be NULL.\n   */\n  MHD_AcceptPolicyCallback apc;\n\n  /**\n   * Closure argument to apc.\n   */\n  void *apc_cls;\n\n  /**\n   * Function to call when we are done processing\n   * a particular request.  May be NULL.\n   */\n  MHD_RequestCompletedCallback notify_completed;\n\n  /**\n   * Closure argument to @e notify_completed.\n   */\n  void *notify_completed_cls;\n\n  /**\n   * Function to call when we are starting/stopping\n   * a connection.  May be NULL.\n   */\n  MHD_NotifyConnectionCallback notify_connection;\n\n  /**\n   * Closure argument to @e notify_connection.\n   */\n  void *notify_connection_cls;\n\n  /**\n   * Function to call with the full URI at the\n   * beginning of request processing.  May be NULL.\n   * <p>\n   * Returns the initial pointer to internal state\n   * kept by the client for the request.\n   */\n  LogCallback uri_log_callback;\n\n  /**\n   * Closure argument to @e uri_log_callback.\n   */\n  void *uri_log_callback_cls;\n\n  /**\n   * Function to call when we unescape escape sequences.\n   */\n  UnescapeCallback unescape_callback;\n\n  /**\n   * Closure for @e unescape_callback.\n   */\n  void *unescape_callback_cls;\n\n  /**\n   * Listen port.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  uint16_t port;\n\n#ifdef HAVE_MESSAGES\n  /**\n   * Function for logging error messages (if we\n   * support error reporting).\n   */\n  MHD_LogCallback custom_error_log;\n\n  /**\n   * Closure argument to @e custom_error_log.\n   */\n  void *custom_error_log_cls;\n#endif\n\n  /**\n   * Pointer to master daemon (NULL if this is the master)\n   */\n  struct MHD_Daemon *master;\n\n  /**\n   * Listen socket.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  MHD_socket listen_fd;\n\n  /**\n   * Listen socket is non-blocking.\n   */\n  bool listen_nonblk;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Worker daemons (one per thread)\n   */\n  struct MHD_Daemon *worker_pool;\n#endif\n\n  /**\n   * Table storing number of connections per IP\n   */\n  void *per_ip_connection_count;\n\n  /**\n   * Number of active parallel connections.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  unsigned int connections;\n\n  /**\n   * Size of the per-connection memory pools.\n   */\n  size_t pool_size;\n\n  /**\n   * Increment for growth of the per-connection memory pools.\n   */\n  size_t pool_increment;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Size of threads created by MHD.\n   */\n  size_t thread_stack_size;\n\n  /**\n   * Number of worker daemons\n   */\n  unsigned int worker_pool_size;\n\n  /**\n   * The select thread handle (if we have internal select)\n   */\n  MHD_thread_handle_ID_ tid;\n\n  /**\n   * Mutex for per-IP connection counts.\n   */\n  MHD_mutex_ per_ip_connection_mutex;\n\n  /**\n   * Mutex for (modifying) access to the \"cleanup\", \"normal_timeout\" and\n   * \"manual_timeout\" DLLs.\n   */\n  MHD_mutex_ cleanup_connection_mutex;\n\n  /**\n   * Mutex for any access to the \"new connections\" DL-list.\n   */\n  MHD_mutex_ new_connections_mutex;\n#endif\n\n  /**\n   * Our #MHD_OPTION_SERVER_INSANITY level, bits indicating\n   * which sanity checks are off.\n   */\n  enum MHD_DisableSanityCheck insanity_level;\n\n  /**\n   * Whether to allow/disallow/ignore reuse of listening address.\n   * The semantics is the following:\n   * 0: ignore (user did not ask for neither allow/disallow, use SO_REUSEADDR\n   *    except W32)\n   * >0: allow (use SO_REUSEPORT on most platforms, SO_REUSEADDR on Windows)\n   * <0: disallow (mostly no action, SO_EXCLUSIVEADDRUSE on Windows or SO_EXCLBIND\n   *     on Solaris)\n   */\n  int listening_address_reuse;\n\n\n  /**\n   * Inter-thread communication channel (also used to unblock\n   * select() in non-threaded code).\n   */\n  struct MHD_itc_ itc;\n\n  /**\n   * Are we shutting down?\n   */\n  volatile bool shutdown;\n\n  /**\n   * Has this daemon been quiesced via #MHD_quiesce_daemon()?\n   * If so, we should no longer use the @e listen_fd (including\n   * removing it from the @e epoll_fd when possible).\n   */\n  volatile bool was_quiesced;\n\n  /**\n   * Did we hit some system or process-wide resource limit while\n   * trying to accept() the last time? If so, we don't accept new\n   * connections until we close an existing one.  This effectively\n   * temporarily lowers the \"connection_limit\" to the current\n   * number of connections.\n   */\n  bool at_limit;\n\n  /*\n   * Do we need to process resuming connections?\n   */\n  volatile bool resuming;\n\n  /**\n   * Indicate that new connections in @e new_connections_head list\n   * need to be processed.\n   */\n  volatile bool have_new;\n\n  /**\n   * 'True' if some data is already waiting to be processed.\n   * If set to 'true' - zero timeout for select()/poll*()\n   * is used.\n   * Should be reset each time before processing connections\n   * and raised by any connection which require additional\n   * immediately processing (application does not provide\n   * data for response, data waiting in TLS buffers etc.)\n   */\n  bool data_already_pending;\n\n  /**\n   * Limit on the number of parallel connections.\n   */\n  unsigned int connection_limit;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Maximum number of connections per IP, or 0 for\n   * unlimited.\n   */\n  unsigned int per_ip_connection_limit;\n\n  /**\n   * The strictness level for parsing of incoming data.\n   * @see #MHD_OPTION_CLIENT_DISCIPLINE_LVL\n   */\n  int client_discipline;\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  /**\n   * The value of FD_SETSIZE used by the daemon.\n   * For external sockets polling this is the value provided by the application\n   * via MHD_OPTION_APP_FD_SETSIZE or current FD_SETSIZE value.\n   * For internal threads modes this is always current FD_SETSIZE value.\n   */\n  int fdset_size;\n\n  /**\n   * Indicates whether @a fdset_size value was set by application.\n   * 'false' if default value is used.\n   */\n  bool fdset_size_set_by_app;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /**\n   * True if SIGPIPE is blocked\n   */\n  bool sigpipe_blocked;\n\n#ifdef HTTPS_SUPPORT\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Head of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_head;\n\n  /**\n   * Tail of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_tail;\n#endif /* UPGRADE_SUPPORT */\n\n  /**\n   * Desired cipher algorithms.\n   */\n  gnutls_priority_t priority_cache;\n\n  /**\n   * What kind of credentials are we offering\n   * for SSL/TLS?\n   */\n  gnutls_credentials_type_t cred_type;\n\n  /**\n   * Server x509 credentials\n   */\n  gnutls_certificate_credentials_t x509_cred;\n\n  /**\n   * Diffie-Hellman parameters\n   */\n  gnutls_dh_params_t dh_params;\n\n  /**\n   * Server PSK credentials\n   */\n  gnutls_psk_server_credentials_t psk_cred;\n\n#if GNUTLS_VERSION_MAJOR >= 3\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for SNI support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK.\n   */\n  gnutls_certificate_retrieve_function2 *cert_callback;\n\n  /**\n   * Function that can be used to obtain the shared key.\n   */\n  MHD_PskServerCredentialsCallback cred_callback;\n\n  /**\n   * Closure for @e cred_callback.\n   */\n  void *cred_callback_cls;\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for OCSP stapling support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK2.\n   */\n  gnutls_certificate_retrieve_function3 *cert_callback2;\n#endif\n\n  /**\n   * Pointer to our SSL/TLS key (in ASCII) in memory.\n   */\n  const char *https_mem_key;\n\n  /**\n   * Pointer to our SSL/TLS certificate (in ASCII) in memory.\n   */\n  const char *https_mem_cert;\n\n  /**\n   * Pointer to 0-terminated HTTPS passphrase in memory.\n   */\n  const char *https_key_password;\n\n  /**\n   * Pointer to our SSL/TLS certificate authority (in ASCII) in memory.\n   */\n  const char *https_mem_trust;\n\n  /**\n   * Our Diffie-Hellman parameters in memory.\n   */\n  gnutls_dh_params_t https_mem_dhparams;\n\n  /**\n   * true if we have initialized @e https_mem_dhparams.\n   */\n  bool have_dhparams;\n\n  /**\n   * true if ALPN is disabled.\n   */\n  bool disable_alpn;\n\n  #endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n\n  /**\n   * Character array of random values.\n   */\n  const char *digest_auth_random;\n\n  /**\n   * Size of @a digest_auth_random.\n   */\n  size_t digest_auth_rand_size;\n\n  /**\n   * The malloc'ed copy of the @a digest_auth_random.\n   */\n  void *digest_auth_random_copy;\n\n  /**\n   * An array that contains the map nonce-nc.\n   */\n  struct MHD_NonceNc *nnc;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * A rw-lock for synchronizing access to @e nnc.\n   */\n  MHD_mutex_ nnc_lock;\n#endif\n\n  /**\n   * Size of the nonce-nc array.\n   */\n  unsigned int nonce_nc_size;\n\n  /**\n   * Nonce bind type.\n   */\n  unsigned int dauth_bind_type;\n\n  /**\n   * Default nonce validity length.\n   */\n  unsigned int dauth_def_nonce_timeout;\n\n  /**\n   * Default maximum nc (nonce count) value.\n   */\n  uint32_t dauth_def_max_nc;\n#endif\n\n#ifdef TCP_FASTOPEN\n  /**\n   * The queue size for incoming SYN + DATA packets.\n   */\n  unsigned int fastopen_queue_size;\n#endif\n\n  /**\n   * The size of queue for listen socket.\n   */\n  unsigned int listen_backlog_size;\n\n  /* TODO: replace with a single member */\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_listen_fd;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_epoll_fd;\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_num_connections;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_flags;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_port;\n\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  /**\n   * If set to 'true', accept() function will be used instead of accept4() even\n   * if accept4() is available.\n   * This is a workaround for zzuf, which does not support sockets created\n   * by accept4() function.\n   * There is no API to change the value of this member, it can be flipped\n   * only by direct access to the struct member.\n   */\n  bool avoid_accept4;\n#endif /* _DEBUG */\n}\n...\ntypedef int MHD_socket\n...\n#define MHD_INVALID_SOCKET (-1)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));",
    "MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));",
    "if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }",
    "if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));"
  ],
  "explanation": "Rule 8.13 concerns pointer declarations/parameters that should be const-qualified when they are not modified. The code contains very few pointer declarations inside this function; most pointers are members of struct MHD_Daemon and are intentionally non-const because MHD_stop_daemon modifies daemon state (e.g. daemon->shutdown, worker pool entries, freeing memory, closing sockets). Those members therefore must remain non-const and do not need investigation for this rule. Calls that pass struct pointers (e.g. &daemon->worker_pool[i] to MHD_stop_daemon, daemon->itc to MHD_itc_destroy_chk_) are passing objects that are or will be modified; making those pointers const would be incorrect. Members already declared const in the struct (https_mem_key, https_mem_cert, digest_auth_random, etc.) are properly const-qualified and need no investigation. The only possible violations worth investigating are places where string literals or gettext() results (which are effectively const char[]) are passed to functions \u2014 that can reveal functions whose parameters are non-const char* although they do not modify the pointed data. Accordingly I flagged the call sites that pass string literals/_() results to functions (MHD_itc_activate_ and MHD_PANIC / error messages). Other fragments (pointer members, free()/close calls, asserts, integer/handle usage) either mutate the objects (so cannot be const) or are not pointer-type issues relevant to Rule 8.13, and thus need not be investigated."
}