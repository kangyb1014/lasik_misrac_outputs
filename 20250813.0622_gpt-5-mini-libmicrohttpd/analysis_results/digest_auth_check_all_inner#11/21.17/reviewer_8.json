{
  "user_message": "An agent A claimed that the following digest_auth_check_all_inner code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of digest_auth_check_all_inner.\n```c\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return MHD_DAUTH_WRONG_HEADER;\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3)))\n    return MHD_DAUTH_WRONG_ALGO;\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop)))\n    return MHD_DAUTH_WRONG_QOP;\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  else if (params->userhash && (NULL == params->username.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  else if (params->userhash && (digest_size * 2 > params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  else if (params->userhash && (digest_size * 4 < params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n\n  if (NULL == params->realm.value.str)\n    return MHD_DAUTH_WRONG_REALM;\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len))\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->nc.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n      return MHD_DAUTH_WRONG_HEADER;\n\n    if (NULL == params->cnonce.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->cnonce.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len)\n      return MHD_DAUTH_TOO_LARGE;\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str)\n    return MHD_DAUTH_WRONG_URI;\n  else if (0 == params->uri.value.len)\n    return MHD_DAUTH_WRONG_URI;\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len)\n    return MHD_DAUTH_TOO_LARGE;\n\n  if (NULL == params->nonce.value.str)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (0 == params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n\n  if (NULL == params->response.value.str)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (0 == params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (digest_size * 4 < params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  if (! is_param_equal (&params->realm, realm, realm_len))\n    return MHD_DAUTH_WRONG_REALM;\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      if (! is_param_equal (&params->username, username, username_len))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname)\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      if (0 > res)\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size))\n      return MHD_DAUTH_WRONG_USERNAME;\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci))\n      return MHD_DAUTH_NONCE_STALE;    /* Too large 'nc' value */\n  }\n  else\n    nci = 1; /* Force 'nc' value */\n  /* Got 'nc' digital value */\n\n  /* Get 'nonce' with basic checks */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  if ((NONCE_STD_LEN (digest_size) != unquoted.len) ||\n      (! get_nonce_timestamp (unquoted.str, unquoted.len, &nonce_time)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, invalid nonce format.\\n\"));\n#endif\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (1)\n  {\n    uint64_t t;\n\n    t = MHD_monotonic_msec_counter ();\n    /*\n     * First level vetting for the nonce validity: if the timestamp\n     * attached to the nonce exceeds `nonce_timeout', then the nonce is\n     * stale.\n     */\n    if (TRIM_TO_TIMESTAMP (t - nonce_time) > (nonce_timeout * 1000))\n      return MHD_DAUTH_NONCE_STALE; /* too old */\n  }\n  if (1)\n  {\n    enum MHD_CheckNonceNC_ nonce_nc_check;\n    /*\n     * Checking if that combination of nonce and nc is sound\n     * and not a replay attack attempt. Refuse if nonce was not\n     * generated previously.\n     */\n    nonce_nc_check = check_nonce_nc (connection,\n                                     unquoted.str,\n                                     NONCE_STD_LEN (digest_size),\n                                     nonce_time,\n                                     nci);\n    if (MHD_CHECK_NONCENC_STALE == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. If this happens a lot, you should \"\n                     \"probably increase the size of the nonce array.\\n\"));\n      else\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. This is expected when client \" \\\n                     \"uses RFC2069-compatible mode and makes more than one \" \\\n                     \"request.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_STALE;\n    }\n    else if (MHD_CHECK_NONCENC_WRONG == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Received nonce that was not \"\n                   \"generated by MHD. This may indicate an attack attempt.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_WRONG;\n    }\n    mhd_assert (MHD_CHECK_NONCENC_OK == nonce_nc_check);\n  }\n  /* The nonce was generated by MHD, is not stale and nonce-nc combination was\n     not used before */\n\n  /* ** Build H(A2) and check URI match in the header and in the request ** */\n\n  /* Get 'uri' */\n  mhd_assert (! da->hashing);\n  digest_update_str (da, connection->rq.method);\n  digest_update_with_colon (da);\n#if 0\n  /* TODO: add support for \"auth-int\" */\n  digest_update_str (da, hentity);\n  digest_update_with_colon (da);\n#endif\n  unq_res = get_unquoted_param_copy (&params->uri, tmp1, ptmp2, &tmp2_size,\n                                     &unq_copy);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  digest_update (da, unq_copy.str, unq_copy.len);\n  /* The next check will modify copied URI string */\n  if (! check_uri_match (connection, unq_copy.str, unq_copy.len))\n    return MHD_DAUTH_WRONG_URI;\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  /* Skip digest calculation external error check, the next one checks both */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A2) */\n\n  /* ** Build H(A1) ** */\n  if (NULL == userdigest)\n  {\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calc_userdigest (da,\n                     username, username_len,\n                     realm, realm_len,\n                     password,\n                     hash1_bin);\n  }\n  /* TODO: support '-sess' versions */\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A1) */\n\n  /* **  Check 'response' ** */\n\n  mhd_assert (! da->hashing);\n  digest_reset (da);\n  /* Update digest with H(A1) */\n  mhd_assert (sizeof (tmp1) >= (digest_size * 2));\n  if (NULL == userdigest)\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n  else\n    MHD_bin_to_hex (userdigest, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A1) is not needed anymore, reuse the buffer.\n   * Use hash1_bin for the client's 'response' decoded to binary form. */\n  unq_res = get_unquoted_param (&params->response, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  if (digest_size != MHD_hex_to_bin (unquoted.str, unquoted.len, hash1_bin))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  /* Update digest with 'nonce' text value */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    /* Update digest with 'nc' text value */\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'cnonce' value */\n    unq_res = get_unquoted_param (&params->cnonce, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'qop' value */\n    unq_res = get_unquoted_param (&params->qop_raw, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n  }\n  /* Update digest with H(A2) */\n  MHD_bin_to_hex (hash2_bin, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A2) is not needed anymore, reuse the buffer.\n   * Use hash2_bin for the calculated response in binary form */\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 != memcmp (hash1_bin, hash2_bin, digest_size))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  if (MHD_DAUTH_BIND_NONCE_NONE != daemon->dauth_bind_type)\n  {\n    mhd_assert (sizeof(tmp1) >= (NONCE_STD_LEN (digest_size) + 1));\n    /* It was already checked that 'nonce' (including timestamp) was generated\n       by MHD. */\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calculate_nonce (nonce_time,\n                     connection->rq.http_mthd,\n                     connection->rq.method,\n                     daemon->digest_auth_random,\n                     daemon->digest_auth_rand_size,\n                     connection->addr,\n                     (size_t) connection->addr_len,\n                     connection->rq.url,\n                     connection->rq.url_len,\n                     connection->rq.headers_received,\n                     realm,\n                     realm_len,\n                     daemon->dauth_bind_type,\n                     da,\n                     tmp1);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (! is_param_equal (&params->nonce, tmp1,\n                          NONCE_STD_LEN (digest_size)))\n      return MHD_DAUTH_NONCE_OTHER_COND;\n    /* The 'nonce' was generated in the same conditions */\n  }\n\n  return MHD_DAUTH_OK;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential buffer over-read if is_param_equal uses the parameter-supplied length incorrectly. In this call username_len = strlen(username) (length without NUL) is passed together with params->username (which contains params->username.value.str and params->username.value.len). If is_param_equal internally calls a string.h routine (e.g. memcmp, memcpy or strncpy) using params->username.value.len (or any length larger than username_len) to compare/copy into the provided username pointer, and params->username.value.len > username_len, that will read beyond the end of the username buffer. For example, if is_param_equal does memcmp(params->username.value.str, username, params->username.value.len) or memcpy(dest, username, params->username.value.len), and params->username.value.len is greater than username_len, this results in an out-of-bounds access of username.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  /* Log entry and pointers for tracing potential over-read */\n  probe_log(\"ENTER digest_auth_check_all_inner: connection=%p realm=%p username=%p password=%p userdigest=%p mqop=%u malgo3=%u pbuf=%p da=%p\",\n            (void *) connection, (void *) realm, (void *) username, (void *) password,\n            (void *) userdigest, (unsigned) mqop, (unsigned) malgo3,\n            (void *) pbuf, (void *) da);\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params) {\n    probe_log(\"EXIT: params == NULL -> MHD_DAUTH_WRONG_HEADER\");\n    return MHD_DAUTH_WRONG_HEADER;\n  }\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3))) {\n    probe_log(\"Wrong algo: c_algo=%u malgo3=%u -> MHD_DAUTH_WRONG_ALGO\",\n              (unsigned) c_algo, (unsigned) malgo3);\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"Client requested session algorithm -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"MD5 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA512/256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop))) {\n    probe_log(\"Wrong qop: c_qop=%u mqop=%u -> MHD_DAUTH_WRONG_QOP\",\n              (unsigned) c_qop, (unsigned) mqop);\n    return MHD_DAUTH_WRONG_QOP;\n  }\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"auth-int QOP requested -> MHD_DAUTH_WRONG_QOP\");\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str)) {\n    probe_log(\"Missing username and username_ext -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;\n  }\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str)) {\n    probe_log(\"Both username and username_ext present -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  }\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len)) {\n    probe_log(\"Broken extended username, len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              params->username_ext.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  }\n  else if (params->userhash && (NULL == params->username.value.str)) {\n    probe_log(\"userhash used with extended notation -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  }\n  else if (params->userhash && (digest_size * 2 > params->username.value.len)) {\n    probe_log(\"userhash too few chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  }\n  else if (params->userhash && (digest_size * 4 < params->username.value.len)) {\n    probe_log(\"userhash too many chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n  }\n\n  if (NULL == params->realm.value.str) {\n    probe_log(\"realm missing -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len)) {\n    probe_log(\"realm too large: realm.len=%zu -> MHD_DAUTH_TOO_LARGE\",\n              params->realm.value.len);\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n  }\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str) {\n      probe_log(\"nc missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->nc.value.len) {\n      probe_log(\"nc zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n    {\n      probe_log(\"nc length too large -> MHD_DAUTH_WRONG_HEADER len=%zu\",\n                params->nc.value.len);\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n\n    if (NULL == params->cnonce.value.str) {\n      probe_log(\"cnonce missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->cnonce.value.len) {\n      probe_log(\"cnonce zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len) {\n      probe_log(\"cnonce too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n                params->cnonce.value.len);\n      return MHD_DAUTH_TOO_LARGE;\n    }\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str) {\n    probe_log(\"uri missing -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (0 == params->uri.value.len) {\n    probe_log(\"uri zero len -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len) {\n    probe_log(\"uri too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n              params->uri.value.len);\n    return MHD_DAUTH_TOO_LARGE;\n  }\n\n  if (NULL == params->nonce.value.str) {\n    probe_log(\"nonce missing -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (0 == params->nonce.value.len) {\n    probe_log(\"nonce zero len -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len) {\n    probe_log(\"nonce len too large -> MHD_DAUTH_NONCE_WRONG len=%zu\",\n              params->nonce.value.len);\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (NULL == params->response.value.str) {\n    probe_log(\"response missing -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (0 == params->response.value.len) {\n    probe_log(\"response zero len -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (digest_size * 4 < params->response.value.len) {\n    probe_log(\"response len too large -> MHD_DAUTH_RESPONSE_WRONG len=%zu\",\n              params->response.value.len);\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  probe_log(\"Comparing realm: supplied realm=%p realm_len=%zu params->realm.len=%zu params->realm.str=%p\",\n            (void *) realm, realm_len, params->realm.value.len,\n            (void *) params->realm.value.str);\n  if (! is_param_equal (&params->realm, realm, realm_len)) {\n    probe_log(\"Realm mismatch -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  probe_log(\"Username check: username=%p username_len=%zu params->username.str=%p params->username.len=%zu params->username_ext.str=%p params->username_ext.len=%zu params->userhash=%d\",\n            (void *) username, username_len,\n            (void *) params->username.value.str, params->username.value.len,\n            (void *) params->username_ext.value.str, params->username_ext.value.len,\n            params->userhash);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      /* Log the exact call parameters to is_param_equal to help detect mismatch */\n      probe_log(\"Calling is_param_equal(&params->username, username, username_len=%zu). params->username.len=%zu\",\n                username_len, params->username.value.len);\n      if (! is_param_equal (&params->username, username, username_len)) {\n        probe_log(\"Username mismatch (standard notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      probe_log(\"Extended username path: raw_len=%zu computed_buf_size=%zu\",\n                params->username_ext.value.len, buf_size);\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname) {\n        probe_log(\"get_buffer_for_size returned NULL for buf_size=%zu -> returning error/too large\", buf_size);\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      }\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      probe_log(\"get_rq_extended_uname_copy_z returned res=%zd (expected username_len=%zu). r_uname=%p\",\n                res, username_len, (void *) r_uname);\n      if (0 > res) {\n        probe_log(\"Broken extended notation -> MHD_DAUTH_WRONG_HEADER\");\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      }\n      probe_log(\"Comparing username (provided) and r_uname: username_len=%zu r_uname_len=%zd memcmp(username, r_uname, username_len)\",\n                username_len, res);\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len))) {\n        probe_log(\"Username mismatch (extended notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    probe_log(\"Userhash path: username=%p username_len=%zu params->username.len=%zu digest_size=%u\",\n              (void *) username, username_len, params->username.value.len, digest_size);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    probe_log(\"Computed userhash hex=%s calling is_param_equal_caseless with len=%u\",\n              tmp1, 2 * digest_size);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size)) {\n      probe_log(\"Userhash mismatch -> MHD_DAUTH_WRONG_USERNAME\");\n      return MHD_DAUTH_WRONG_USERNAME;\n    }\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res) {\n      probe_log(\"get_unquoted_param(nc) failed -> MHD_DAUTH_ERROR unq_res=%d\", (int) unq_res);\n      return MHD_DAUTH_ERROR;\n    }\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      probe_log(\"Invalid nc format -> MHD_DAUTH_WRONG_HEADER unquoted.len=%zu\", unquoted.len);\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      probe_log(\"Invalid nc value zero -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci)) {\n      probe_log(\"nc too large: nci=%llu max_nc=%u -> MHD_DAUTH_WRONG_HEADER\",\n                (unsigned long long) nci, max_nc);\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n\n    /* ... the rest of the original function continues unchanged ... */\n\n    /* NOTE: This patch only fixes the unterminated string literal and ensures\n       the comparison/return for an excessive nc value is syntactically\n       correct. The original function logic and subsequent checks should\n       remain as they were in the original source file. */\n  }\n\n  /* If execution reaches here in this truncated test-file, return a generic error\n     to keep the function well-formed. In the real source the function\n     contains many further checks and a proper return value. */\n  return MHD_DAUTH_ERROR;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for digest_auth_check_all_inner. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is speculative and not supported by the shown function body. digest_auth_check_all_inner itself does not call any string.h routine with a length that obviously exceeds the size of a local buffer: the direct memcmp() uses explicit lengths derived from strlen() or from returned buffer lengths (e.g. memcmp(username, r_uname, username_len) where r_uname was created with that size, and memcmp(hash1_bin, hash2_bin, digest_size)). The potentially risky calls are to helper functions (is_param_equal, is_param_equal_caseless, get_unquoted_param, etc.). Whether a buffer-overread occurs depends entirely on how those helpers are implemented. MISRA C Rule 21.17 forbids using string.h functions in a way that can access beyond object bounds, but you cannot conclude a violation by digest_auth_check_all_inner alone without inspecting the implementations of the callee helpers. In other words, the scenario described (is_param_equal doing memcmp with params->username.value.len) would indeed be a bug violating Rule 21.17, but that bug would be in is_param_equal, not in digest_auth_check_all_inner. Therefore the report that digest_auth_check_all_inner violates MISRA C 2023 Rule 21.17 is not correct as presented."
}