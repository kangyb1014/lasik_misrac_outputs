{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert(pos <= h_maxlen + 1) is redundant (dead) in the prefer_utf8==0 branch. Earlier the code computed suffix_len = 1 and asserted pos + suffix_len <= h_maxlen (i.e. pos + 1 <= h_maxlen) after realm_quoted_len was added. The subsequent two writes increase pos by 2, so pos <= h_maxlen + 1 is guaranteed by the earlier check and the computed h_maxlen. If mhd_assert expands to an executed runtime check in this build, that check will always be true and its removal would not affect program behaviour \u2014 therefore it constitutes dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_state(const char *event, struct MHD_Connection *connection,\n                                const char *method, void *req_cls,\n                                struct MHD_BasicAuthInfo *auth_info,\n                                enum MHD_Result maybe_ret)\n{\n  FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \"  connection=%p method=%s req_cls=%p maybe_ret=%d\\n\",\n          (void *) connection, (method ? method : \"(null)\"), req_cls,\n          (int) maybe_ret);\n  if (NULL == auth_info)\n  {\n    fprintf(f, \"  auth_info: NULL\\n\");\n  }\n  else\n  {\n    size_t ulen = auth_info->username_len;\n    size_t plen = auth_info->password_len;\n    fprintf(f, \"  auth_info: username_len=%zu username='\", ulen);\n    if (ulen > 0 && auth_info->username != NULL)\n    {\n      /* Write username bytes safely (not NUL-terminated in structure). */\n      size_t to_write = (ulen > 200) ? 200 : ulen;\n      fwrite(auth_info->username, 1, to_write, f);\n      if (ulen > to_write)\n        fprintf(f, \"...(%zu bytes omitted)\", ulen - to_write);\n    }\n    fprintf(f, \"' password_len=%zu password_ptr=%p\\n\", plen,\n            (void *) auth_info->password);\n  }\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  probe_log_state(\"entry\", connection, method, *req_cls, NULL, -1);\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    probe_log_state(\"method_not_get\", connection, method, *req_cls, NULL,\n                    MHD_NO);\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    probe_log_state(\"first_request_class\", connection, method, *req_cls,\n                    NULL, MHD_YES);\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  probe_log_state(\"after_basic_auth_get\", connection, method, *req_cls,\n                  auth_info, -1);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n\n    probe_log_state(\"auth_info_null_queue_auth_response\", connection, method,\n                    *req_cls, NULL, -1);\n\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    /* Log detailed comparison outcomes to help reproduce the scenario. */\n    probe_log_state(\"wrong_username_or_password\", connection, method,\n                    *req_cls, auth_info, -1);\n\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n\n    probe_log_state(\"queue_wrong_credentials_response\", connection, method,\n                    *req_cls, auth_info, -1);\n\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    probe_log_state(\"credentials_ok\", connection, method, *req_cls,\n                    auth_info, -1);\n\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n\n  probe_log_state(\"before_destroy_response_and_return\", connection, method,\n                  *req_cls, NULL, ret);\n\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for answer_to_connection. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The alleged redundant mhd_assert and the reasoning about pos, suffix_len and h_maxlen do not appear anywhere in the provided answer_to_connection implementation \u2014 Agent A is referring to a different piece of code. In the supplied answer_to_connection function all executed operations are meaningful for program behaviour: the early returns gate control flow, each branch sets response and ret before the common cleanup/return, and the (void) casts are explicit no-op annotations to suppress unused-parameter warnings (a standard idiom). There is no mhd_assert in this function and no executed statement whose removal would leave behaviour unchanged as described by Agent A, so Rule 2.2 is not violated for the shown code. (The empty test log only indicates the test harness did not exercise the function; it does not validate Agent A\u2019s assertion about a different assertion elsewhere.)"
}