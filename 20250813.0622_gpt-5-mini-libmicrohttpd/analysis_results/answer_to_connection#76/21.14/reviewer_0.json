{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation: memcmp is used to compare auth_info->username (which the provided code guarantees is NUL-terminated) with the string literal \"root\": (0 != memcmp(auth_info->username, \"root\", auth_info->username_len)). Rule 21.14 forbids using memcmp to compare null-terminated strings (use strcmp/strncmp instead).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/614.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and method. */\n  probe_log (\"enter: answer_to_connection: connection=%p method='%s' req_cls_ptr=%p req_cls_val=%p\",\n             (void *) connection,\n             (NULL != method) ? method : \"(null)\",\n             (void *) req_cls,\n             (NULL != req_cls) ? *req_cls : NULL);\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    probe_log (\"exit: method != GET -> returning MHD_NO\");\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    /* Log assignment and return path. */\n    probe_log (\"setting req_cls to connection (%p) and returning MHD_YES\", (void *) connection);\n    *req_cls = connection;\n    return MHD_YES;\n  }\n\n  /* Obtain basic auth info and log result. */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  probe_log (\"auth_info pointer=%p\", (void *) auth_info);\n\n  if (NULL == auth_info)\n  {\n    probe_log (\"no auth_info: will request authorization\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    /* Prepare and log detailed information used in the credential checks. */\n    size_t expected_user_len = strlen (\"root\");\n    size_t expected_pass_len = strlen (\"pa$$w0rd\");\n\n    /* Safely log username and password information. */\n    if (NULL != auth_info->username)\n    {\n      /* Use precision specifier to avoid reading beyond username_len. */\n      probe_log (\"auth username: ptr=%p len=%zu value='%.*s'\",\n                 (void *) auth_info->username,\n                 auth_info->username_len,\n                 (int) auth_info->username_len,\n                 auth_info->username);\n    }\n    else\n    {\n      probe_log (\"auth username: NULL\");\n    }\n\n    if (NULL != auth_info->password)\n    {\n      probe_log (\"auth password: ptr=%p len=%zu value='%.*s'\",\n                 (void *) auth_info->password,\n                 auth_info->password_len,\n                 (int) auth_info->password_len,\n                 auth_info->password);\n    }\n    else\n    {\n      probe_log (\"auth password: NULL\");\n    }\n\n    /* Compute the same boolean subconditions as the original code so we can log them\n       without changing the control flow. */\n    int username_len_mismatch = (expected_user_len != auth_info->username_len);\n    int username_content_mismatch = 0;\n    if (NULL != auth_info->username)\n    {\n      /* memcmp is used in original code; call it here to record the result. */\n      username_content_mismatch = (0 != memcmp (auth_info->username, \"root\", auth_info->username_len));\n    }\n    else\n    {\n      /* If username is NULL then treat as mismatch. */\n      username_content_mismatch = 1;\n    }\n\n    int password_null = (NULL == auth_info->password);\n    int password_len_mismatch = (expected_pass_len != auth_info->password_len);\n    int password_content_mismatch = 0;\n    if (!password_null)\n    {\n      password_content_mismatch = (0 != memcmp (auth_info->password, \"pa$$w0rd\", auth_info->password_len));\n    }\n\n    probe_log (\"checks: expected_user_len=%zu expected_pass_len=%zu username_len_mismatch=%d username_content_mismatch=%d password_null=%d password_len_mismatch=%d password_content_mismatch=%d\",\n               expected_user_len,\n               expected_pass_len,\n               username_len_mismatch,\n               username_content_mismatch,\n               password_null,\n               password_len_mismatch,\n               password_content_mismatch);\n\n    /* Recreate original combined condition using the computed booleans. */\n    if (username_len_mismatch || username_content_mismatch ||\n        password_null || password_len_mismatch || password_content_mismatch)\n    {\n      probe_log (\"credential check failed: returning auth required response\");\n      static const char *page =\n        \"<html><body>Wrong username or password</body></html>\";\n      response = MHD_create_response_from_buffer_static (strlen (page), page);\n      ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                     \"admins\",\n                                                     MHD_YES,\n                                                     response);\n    }\n    else\n    {\n      probe_log (\"credential check passed: returning secret page\");\n      static const char *page = \"<html><body>A secret.</body></html>\";\n      response = MHD_create_response_from_buffer_static (strlen (page), page);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    }\n  }\n\n  if (NULL != auth_info)\n  {\n    probe_log (\"freeing auth_info %p\", (void *) auth_info);\n    MHD_free (auth_info);\n  }\n  MHD_destroy_response (response);\n  probe_log (\"exiting: ret=%d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for answer_to_connection. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. Rule 21.14 forbids using memcmp to compare null-terminated strings. In the shown code memcmp is used to compare authentication strings against string literals (\"root\" and \"pa$$w0rd\"). Those literals are null-terminated, and the code already treats the username/password as C-strings (it checks their lengths against strlen(\"...\")). Because a null-terminated string is involved, using memcmp here violates MISRA C 2023 Rule 21.14. (The empty test log does not affect the rule analysis.)"
}