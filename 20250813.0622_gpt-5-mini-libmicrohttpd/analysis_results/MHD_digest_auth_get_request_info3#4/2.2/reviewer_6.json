{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In get_rq_uname(), the final else branch contains the statement mhd_assert(0);. In the provided project mhd_assert is defined as ((void)0), so this statement is a no-op that is executed when an unexpected uname_type is encountered. Because it performs no action, removing this statement would not change program behaviour, which makes it dead code and thus a violation of MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic size_t\nprobe_get_rq_uname (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type,\n                    struct MHD_DigestAuthUsernameInfo *uname_info,\n                    uint8_t *buf, size_t buf_sz)\n{\n  FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"probe_get_rq_uname: params=%p uname_type=%d uname_info=%p buf=%p buf_sz=%zu\\n\",\n            (void *) params, (int) uname_type, (void *) uname_info,\n            (void *) buf, buf_sz);\n    fclose(f);\n  }\n\n  /* Call the original function and log its return value. */\n  size_t res = get_rq_uname (params, uname_type, uname_info, buf, buf_sz);\n\n  f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"probe_get_rq_uname: returned %zu\\n\", res);\n    fclose(f);\n  }\n\n  return res;\n}\nstatic void\nprobe_log_state_start (const struct MHD_RqDAuth *params)\n{\n  FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"MHD_digest_auth_get_request_info3: entry params=%p\\n\", (void *) params);\n    if (params != NULL)\n    {\n      fprintf(f, \"  opaque=%p opaque.len=%zu realm=%p realm.len=%zu qop=%d cnonce=%p cnonce.len=%zu\\n\",\n              (void *) params->opaque.value.str, params->opaque.value.len,\n              (void *) params->realm.value.str, params->realm.value.len,\n              (int) params->qop,\n              (void *) params->cnonce.value.str, params->cnonce.value.len);\n    }\n    fclose(f);\n  }\n}\nstatic void\nprobe_log_mid (enum MHD_DigestAuthUsernameType uname_type,\n               size_t unif_buf_size, size_t unif_buf_used)\n{\n  FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"  uname_type=%d unif_buf_size=%zu unif_buf_used(before)=%zu\\n\",\n            (int) uname_type, unif_buf_size, unif_buf_used);\n    fclose(f);\n  }\n}\nstatic void\nprobe_log_end (struct MHD_DigestAuthInfo *info, enum MHD_GetRqNCResult nc_res)\n{\n  FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"MHD_digest_auth_get_request_info3: exit info=%p algo3=%d uname_type=%d opaque=%p opaque_len=%zu realm=%p realm_len=%zu qop=%d cnonce_len=%zu nc_res=%d nc=%u\\n\",\n            (void *) info,\n            (int) info->algo3,\n            (int) info->uname_type,\n            (void *) info->opaque, info->opaque_len,\n            (void *) info->realm, info->realm_len,\n            (int) info->qop,\n            info->cnonce_len,\n            (int) nc_res,\n            (unsigned) info->nc);\n    fclose(f);\n  }\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  probe_log_state_start (params);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  probe_log_mid (uname_type, unif_buf_size, unif_buf_used);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    /* Use probe wrapper so that inputs and return value of get_rq_uname are logged. */\n    size_t got = probe_get_rq_uname (params, uname_type,\n                                     (struct MHD_DigestAuthUsernameInfo *) info,\n                                     unif_buf_ptr + unif_buf_used,\n                                     unif_buf_size - unif_buf_used);\n    unif_buf_used += got;\n\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf(f, \"  get_rq_uname taken, added %zu bytes, unif_buf_used=%zu\\n\", got, unif_buf_used);\n      fclose(f);\n    }\n  }\n  else\n  {\n    info->uname_type = uname_type;\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf(f, \"  uname branch not taken, set info->uname_type=%d\\n\", (int) uname_type);\n      fclose(f);\n    }\n  }\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf(f, \"  opaque processed, opaque_len=%zu unif_buf_used=%zu\\n\", info->opaque_len, unif_buf_used);\n      fclose(f);\n    }\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf(f, \"  realm processed, realm_len=%zu unif_buf_used=%zu\\n\", info->realm_len, unif_buf_used);\n      fclose(f);\n    }\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  probe_log_end (info, nc_res);\n\n  return info;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_get_request_info3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s reasoning is plausible but incomplete \u2014 I judge the report to be not correct as stated. MISRA Rule 2.2 indeed prohibits dead code (an operation that is executed but whose removal would not affect program behaviour). However, two essential facts are missing from the scenario and so the claim as presented is not proven:\n\n1) Location of the code: the no-op mhd_assert(0) sits inside get_rq_uname(), not inside MHD_digest_auth_get_request_info3 itself. The rule is project-scoped, so a dead statement anywhere in the project would be a violation \u2014 but the report targeted MHD_digest_auth_get_request_info3 without showing the actual dead statement is in that function.\n\n2) Reachability/execution of the statement: MISRA Note 2 explicitly excludes unreachable code from being dead code. The agent must show that the branch containing mhd_assert(0) is actually reachable (i.e. executed) in the project\u2019s configuration. The provided test instrumentation did not exercise the function or demonstrate that the assert path is taken (the logs are empty for this function). Without evidence that the statement is executed, it cannot be classified as dead code under Rule 2.2.\n\nAdditional important point: whether the statement would be \u201cdead\u201d also depends on how mhd_assert is defined across the whole project/build configuration. If mhd_assert is indeed defined as ((void)0) everywhere in the project and the branch is executed at runtime, then the statement is a no-op and its removal would not change behaviour \u2014 that would meet the definition of dead code and thus be a Rule 2.2 violation. But the agent has not demonstrated both conditions (no-op definition in the active build and that the branch is reachable/executed).\n\nConclusion: the report as given is not proven/correct. To make a correct report you must (a) show the mhd_assert definition used in the actual project build is a no-op, and (b) show the branch containing mhd_assert(0) is reachable/executed (or otherwise provably executed). If both are true, then the project does contain dead code and would violate MISRA C:2023 Rule 2.2."
}