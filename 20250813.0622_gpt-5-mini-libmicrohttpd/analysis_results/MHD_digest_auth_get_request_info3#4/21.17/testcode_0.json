{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 get_rq_param_unquoted_copy_z uses memcpy(buf, param->value.str, param->value.len) and writes buf[param->value.len] = '\\0' without any explicit runtime check of the destination size. In MHD_digest_auth_get_request_info3 the caller relies on a prior computation (unif_buf_size) to have reserved param->value.len + 1 bytes and on mhd_assert checks (which expand to no-ops) rather than real bounds checks. A concrete violation scenario: an attacker-supplied very large Authorization header can make params->opaque.value.len large enough that the additions to unif_buf_size overflow size_t (or simply exceed available memory), leading to an allocated buffer smaller than param->value.len + 1. The subsequent call info->opaque_len = get_rq_param_unquoted_copy_z(&params->opaque, info->opaque) will then cause memcpy and the terminating write to access/write beyond the allocated buffer \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_digest_auth_get_request_info3 code that contains useful probe functions that print useful logs to a file \"/tmp/logs/39.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_digest_auth_get_request_info3 as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_get_request_info3:\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\nPlease provide the modified MHD_digest_auth_get_request_info3 code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Probe logger: write state information to /tmp/logs/39.txt. */\nstatic void mhd_probe_log_state(const char *stage,\n                                const void *params_ptr,\n                                const void *info_ptr,\n                                size_t unif_buf_size,\n                                size_t unif_buf_used,\n                                const void *unif_buf_ptr,\n                                const void *opaque_str,\n                                size_t opaque_len,\n                                const void *realm_str,\n                                size_t realm_len,\n                                size_t allocation_size)\n{\n  FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[MHD_PROBE] stage=%s\\n\", stage);\n  fprintf(f, \"  params_ptr=%p info_ptr=%p unif_buf_ptr=%p\\n\",\n          params_ptr, info_ptr, unif_buf_ptr);\n  fprintf(f, \"  unif_buf_size=%zu unif_buf_used=%zu allocation_request=%zu\\n\",\n          unif_buf_size, unif_buf_used, allocation_size);\n  fprintf(f, \"  opaque.str=%p opaque.len=%zu\\n\", opaque_str, opaque_len);\n  fprintf(f, \"  realm.str=%p realm.len=%zu\\n\", realm_str, realm_len);\n  fflush(f);\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  /* Log initial params state */\n  mhd_probe_log_state(\"entry\", (const void *)params, NULL,\n                      (size_t)0, (size_t)0, NULL,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)0);\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n\n  /* Log computed unif_buf_size before allocation */\n  mhd_probe_log_state(\"before_alloc\", (const void *)params, NULL,\n                      unif_buf_size, (size_t)0, NULL,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  /* Log after allocation */\n  mhd_probe_log_state(\"after_alloc\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    /* Capture returned size from get_rq_uname for logging */\n    size_t uname_added =\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n    mhd_probe_log_state(\"after_get_rq_uname\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + uname_added, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n    unif_buf_used += uname_added;\n  }\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    /* Log state right before copying opaque */\n    mhd_probe_log_state(\"before_copy_opaque\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    /* Capture return value for logging */\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n\n    /* Log result after copying opaque */\n    mhd_probe_log_state(\"after_copy_opaque\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + info->opaque_len + 1, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n\n    /* Log state right before copying realm */\n    mhd_probe_log_state(\"before_copy_realm\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n\n    /* Log result after copying realm */\n    mhd_probe_log_state(\"after_copy_realm\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + info->realm_len + 1, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  /* Log just before final assertion check */\n  mhd_probe_log_state(\"before_assert\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  /* Final log on exit */\n  mhd_probe_log_state(\"exit\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  return info;\n}\n"
}