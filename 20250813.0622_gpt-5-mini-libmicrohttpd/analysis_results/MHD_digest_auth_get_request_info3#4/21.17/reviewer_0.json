{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 get_rq_param_unquoted_copy_z uses memcpy(buf, param->value.str, param->value.len) and writes buf[param->value.len] = '\\0' without any explicit runtime check of the destination size. In MHD_digest_auth_get_request_info3 the caller relies on a prior computation (unif_buf_size) to have reserved param->value.len + 1 bytes and on mhd_assert checks (which expand to no-ops) rather than real bounds checks. A concrete violation scenario: an attacker-supplied very large Authorization header can make params->opaque.value.len large enough that the additions to unif_buf_size overflow size_t (or simply exceed available memory), leading to an allocated buffer smaller than param->value.len + 1. The subsequent call info->opaque_len = get_rq_param_unquoted_copy_z(&params->opaque, info->opaque) will then cause memcpy and the terminating write to access/write beyond the allocated buffer \u2014 violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log_state(const char *stage,\n                                const void *params_ptr,\n                                const void *info_ptr,\n                                size_t unif_buf_size,\n                                size_t unif_buf_used,\n                                const void *unif_buf_ptr,\n                                const void *opaque_str,\n                                size_t opaque_len,\n                                const void *realm_str,\n                                size_t realm_len,\n                                size_t allocation_size)\n{\n  FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[MHD_PROBE] stage=%s\\n\", stage);\n  fprintf(f, \"  params_ptr=%p info_ptr=%p unif_buf_ptr=%p\\n\",\n          params_ptr, info_ptr, unif_buf_ptr);\n  fprintf(f, \"  unif_buf_size=%zu unif_buf_used=%zu allocation_request=%zu\\n\",\n          unif_buf_size, unif_buf_used, allocation_size);\n  fprintf(f, \"  opaque.str=%p opaque.len=%zu\\n\", opaque_str, opaque_len);\n  fprintf(f, \"  realm.str=%p realm.len=%zu\\n\", realm_str, realm_len);\n  fflush(f);\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  /* Log initial params state */\n  mhd_probe_log_state(\"entry\", (const void *)params, NULL,\n                      (size_t)0, (size_t)0, NULL,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)0);\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n\n  /* Log computed unif_buf_size before allocation */\n  mhd_probe_log_state(\"before_alloc\", (const void *)params, NULL,\n                      unif_buf_size, (size_t)0, NULL,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  /* Log after allocation */\n  mhd_probe_log_state(\"after_alloc\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    /* Capture returned size from get_rq_uname for logging */\n    size_t uname_added =\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n    mhd_probe_log_state(\"after_get_rq_uname\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + uname_added, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n    unif_buf_used += uname_added;\n  }\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    /* Log state right before copying opaque */\n    mhd_probe_log_state(\"before_copy_opaque\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    /* Capture return value for logging */\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n\n    /* Log result after copying opaque */\n    mhd_probe_log_state(\"after_copy_opaque\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + info->opaque_len + 1, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n\n    /* Log state right before copying realm */\n    mhd_probe_log_state(\"before_copy_realm\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n\n    /* Log result after copying realm */\n    mhd_probe_log_state(\"after_copy_realm\", (const void *)params, (const void *)info,\n                        unif_buf_size, unif_buf_used + info->realm_len + 1, (const void *)unif_buf_ptr,\n                        (const void *)params->opaque.value.str,\n                        params->opaque.value.len,\n                        (const void *)params->realm.value.str,\n                        params->realm.value.len,\n                        (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  /* Log just before final assertion check */\n  mhd_probe_log_state(\"before_assert\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  /* Final log on exit */\n  mhd_probe_log_state(\"exit\", (const void *)params, (const void *)info,\n                      unif_buf_size, unif_buf_used, (const void *)unif_buf_ptr,\n                      (const void *)params->opaque.value.str,\n                      params->opaque.value.len,\n                      (const void *)params->realm.value.str,\n                      params->realm.value.len,\n                      (size_t)(sizeof(struct MHD_DigestAuthInfo) + unif_buf_size));\n\n  return info;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_get_request_info3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct under the presented assumptions. MISRA C 2023 Rule 21.17 forbids any use of the <string.h> functions that can access beyond the bounds of the target object. In the shown code the caller computes an allocation size (unif_buf_size) from attacker-controlled lengths (params->opaque.value.len, params->realm.value.len and whatever get_rq_unames_size/get_rq_uname return), then allocates that many bytes and later calls get_rq_param_unquoted_copy_z which, per the scenario, internally does memcpy(buf, param->value.str, param->value.len) and then buf[param->value.len] = '\\0' \u2014 but neither get_rq_param_unquoted_copy_z nor the caller performs a runtime check that the destination actually has param->value.len + 1 bytes available. The caller only uses an mhd_assert after the copies; mhd_assert is typically a no-op in production and does not prevent out-of-bounds writes. Two concrete, realistic problems follow: (1) integer overflow when computing unif_buf_size (params->... .len + 1 additions) can make the allocation too small; (2) allocation can fail or return a smaller usable region; the code does not check info for NULL or otherwise validate available space before memcpy in get_rq_param_unquoted_copy_z. Either case permits memcpy and the terminating write to access/write past the allocated buffer, violating Rule 21.17. Note: if the callee get_rq_param_unquoted_copy_z actually performs its own destination-size checks (or get_rq_uname/get_rq_unames_size guarantee tight bounds and no overflow), then the concrete violation would be avoided \u2014 but based on the provided scenario (callee using memcpy and writing the NUL without size checks) the report is correct and the code is noncompliant with MISRA C 2023 Rule 21.17."
}