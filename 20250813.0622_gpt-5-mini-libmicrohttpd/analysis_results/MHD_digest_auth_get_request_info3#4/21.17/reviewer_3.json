{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation possible: get_rq_param_unquoted_copy_z performs memcpy(buf, param->value.str, param->value.len) without receiving or checking buf size. Although callers (e.g. MHD_digest_auth_get_request_info3) normally compute and allocate space (param->value.len + 1), there is no overflow/limit check when accumulating unif_buf_size (size_t additions can wrap) and no formal contract enforced that buf is large enough. If an attacker-supplied header yields very large param->value.len (or causes unif_buf_size to wrap) the allocated buffer may be too small and memcpy will write past buf, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log39(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  mhd_log39(\"MHD_digest_auth_get_request_info3: connection=%p, params=%p\", (void *)connection, (void *)params);\n  if (NULL == params)\n  {\n    mhd_log39(\"MHD_digest_auth_get_request_info3: params is NULL, returning NULL\");\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n  mhd_log39(\"initial unif_buf_size=%zu\", unif_buf_size);\n\n  uname_type = get_rq_uname_type (params);\n  mhd_log39(\"uname_type=%d\", (int)uname_type);\n\n  /* get_rq_unames_size may be non-trivial; call it once and log the effect */\n  {\n    size_t add = get_rq_unames_size (params, uname_type);\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding unames_size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"after adding unames_size: add=%zu unif_buf_size=%zu\", add, unif_buf_size);\n  }\n\n  if (NULL != params->opaque.value.str)\n  {\n    size_t add = params->opaque.value.len + 1; /* Add one for zero-termination */\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding opaque size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"opaque present: value.str=%p value.len=%zu add=%zu unif_buf_size=%zu\", (void *)params->opaque.value.str, params->opaque.value.len, add, unif_buf_size);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    size_t add = params->realm.value.len + 1;  /* Add one for zero-termination */\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding realm size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"realm present: value.str=%p value.len=%zu add=%zu unif_buf_size=%zu\", (void *)params->realm.value.str, params->realm.value.len, add, unif_buf_size);\n  }\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  mhd_log39(\"after calloc: info=%p (requested bytes=%zu, struct_size=%zu)\", (void *)info, unif_buf_size + (size_t)sizeof(struct MHD_DigestAuthInfo), (size_t)sizeof(struct MHD_DigestAuthInfo));\n\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  mhd_log39(\"unif_buf_ptr=%p\", (void *)unif_buf_ptr);\n\n  unif_buf_used = 0;\n  mhd_log39(\"unif_buf_used initialized to %zu\", unif_buf_used);\n\n  info->algo3 = params->algo3;\n  mhd_log39(\"info->algo3 set to %d\", (int)info->algo3);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    size_t used_before = unif_buf_used;\n    size_t used_add = get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n    unif_buf_used += used_add;\n    mhd_log39(\"get_rq_uname: used_add=%zu unif_buf_used from %zu to %zu (remaining_space=%zu)\", used_add, used_before, unif_buf_used, (unif_buf_size > used_before) ? (unif_buf_size - used_before) : 0);\n  }\n  else\n  {\n    info->uname_type = uname_type;\n    mhd_log39(\"uname_type was missing/invalid, set info->uname_type=%d\", (int)info->uname_type);\n  }\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    mhd_log39(\"about to copy opaque: dest=%p unif_buf_used=%zu unif_buf_size=%zu param.len=%zu param.str=%p\", (void *)info->opaque, unif_buf_used, unif_buf_size, params->opaque.value.len, (void *)params->opaque.value.str);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    mhd_log39(\"get_rq_param_unquoted_copy_z returned opaque_len=%zu\", info->opaque_len);\n    unif_buf_used += info->opaque_len + 1;\n    mhd_log39(\"after opaque copy unif_buf_used=%zu (opaque_len+1=%zu)\", unif_buf_used, info->opaque_len + 1);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    mhd_log39(\"about to copy realm: dest=%p unif_buf_used=%zu unif_buf_size=%zu param.len=%zu param.str=%p\", (void *)info->realm, unif_buf_used, unif_buf_size, params->realm.value.len, (void *)params->realm.value.str);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    mhd_log39(\"get_rq_param_unquoted_copy_z returned realm_len=%zu\", info->realm_len);\n    unif_buf_used += info->realm_len + 1;\n    mhd_log39(\"after realm copy unif_buf_used=%zu (realm_len+1=%zu)\", unif_buf_used, info->realm_len + 1);\n  }\n\n  mhd_log39(\"final sizes: unif_buf_size=%zu unif_buf_used=%zu\", unif_buf_size, unif_buf_used);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n  mhd_log39(\"info->qop set to %d\", (int)info->qop);\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n  mhd_log39(\"info->cnonce_len=%zu\", info->cnonce_len);\n\n  nc_res = get_rq_nc (params, &info->nc);\n  mhd_log39(\"get_rq_nc returned %d info->nc=%u\", (int)nc_res, (unsigned)info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  mhd_log39(\"returning info=%p\", (void *)info);\n  return info;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_get_request_info3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function attempts to guarantee destination space by summing param lengths (adding +1 for zero terminator) and allocating that many bytes, but it does not robustly ensure that the arithmetic and allocation cannot under\u2011report the needed size. Specific problems: 1) unif_buf_size is built by repeated size_t additions with no overflow/limit checks \u2014 these additions can wrap and result in a smaller allocation than expected; 2) the subsequent copy routine used (get_rq_param_unquoted_copy_z) is called with only a destination pointer (no destination size) and, per the scenario, may internally call memcpy(dest, src, src_len). If that happens and the allocated/remaining buffer is too small, memcpy will write beyond the destination bounds; that is precisely the kind of out\u2011of\u2011bounds access prohibited by MISRA C:2023 Rule 21.17; 3) the final mhd_assert(unif_buf_size >= unif_buf_used) is a runtime check that may be compiled out (or not exercised in tests) and does not prevent the unsafe copy occurring earlier. Without a formal contract (or an explicit size parameter and overflow checks) guaranteeing the destination is large enough, a path exists where string/memory routines write past the buffer. Therefore the claimed violation (potential Rule 21.17 breach) is valid given the described behaviour of get_rq_param_unquoted_copy_z."
}