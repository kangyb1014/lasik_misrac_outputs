{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The initial assignment alloc_size = 0; is redundant: every control path in MHD_pool_create assigns alloc_size a meaningful value before it is used (either the page-rounded alloc_size for mmap/VirtualAlloc success, or alloc_size = ROUND_TO_ALIGN(max) in the MAP_FAILED/malloc path). Therefore the statement is executed but its removal would not affect program behaviour \u2014 it is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/626.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  probe_log(\"MHD_pool_create: enter max=%zu\", max);\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  probe_log(\"MHD_pool_create: initial alloc_size set to %zu\", alloc_size);\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n  {\n    probe_log(\"MHD_pool_create: malloc for pool failed, returning NULL\");\n    return NULL;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    probe_log(\"MHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=%zu)\", max);\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    probe_log(\"MHD_pool_create: rounded alloc_size for mmap/VirtualAlloc = %zu (page=%zu, max=%zu)\", alloc_size, (size_t)MHD_sys_page_size_, max);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    probe_log(\"MHD_pool_create: attempted mmap -> pool->memory=%p\", pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    probe_log(\"MHD_pool_create: attempted VirtualAlloc -> pool->memory=%p\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  probe_log(\"MHD_pool_create: no mmap/VirtualAlloc available -> pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    probe_log(\"MHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = %zu\", alloc_size);\n    pool->memory = malloc (alloc_size);\n    probe_log(\"MHD_pool_create: malloc fallback -> pool->memory=%p, alloc_size=%zu\", pool->memory, alloc_size);\n    if (NULL == pool->memory)\n    {\n      probe_log(\"MHD_pool_create: malloc fallback failed, freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    probe_log(\"MHD_pool_create: using malloc memory, is_mmap=false\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    probe_log(\"MHD_pool_create: using mmap/VirtualAlloc memory, is_mmap=true\");\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  probe_log(\"MHD_pool_create: final state -> memory=%p, pos=%zu, end=%zu, size=%zu, alloc_size=%zu\", pool->memory, pool->pos, pool->end, pool->size, alloc_size);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  probe_log(\"MHD_pool_create: exit returning pool=%p\", pool);\n  return pool;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4bf0e0, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4bf0e0, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c0340, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c0340, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c0590, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c0590, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c07e0, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c07e0, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c0a30, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c0a30, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c0c80, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c0c80, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c0ed0, alloc_size=32768\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: final state -> memory=0x55841f4c0ed0, pos=0, end=32768, size=32768, alloc_size=32768\nMHD_pool_create: exit returning pool=0x55841f4bf0b0\nMHD_pool_create: enter max=32768\nMHD_pool_create: initial alloc_size set to 0\nMHD_pool_create: chose fallback path -> pool->memory = MAP_FAILED (small max=32768)\nMHD_pool_create: MAP_FAILED branch -> alloc_size set to ROUND_TO_ALIGN(max) = 32768\nMHD_pool_create: malloc fallback -> pool->memory=0x55841f4c1120, alloc_size=32768\nMHD_pool_create: using malloc \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The initial statement alloc_size = 0; is redundant dead code. Every control path that reaches the later uses of alloc_size (pool->end, pool->size, the final assert, and _MHD_POISON_MEMORY) assigns alloc_size a meaningful value beforehand: either the page-rounded alloc_size in the mmap/VirtualAlloc branch or alloc_size = ROUND_TO_ALIGN(max) in the MAP_FAILED/malloc fallback. If malloc(pool) fails the function returns before alloc_size would be used. The assignment has no side effects and its removal would not change program behaviour, so the reported violation of Rule 2.2 is correct."
}