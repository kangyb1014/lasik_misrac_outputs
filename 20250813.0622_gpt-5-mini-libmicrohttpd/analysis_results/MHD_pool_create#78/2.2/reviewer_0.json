{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert(ignore) expands to ((void)0), so every call mhd_assert(...) in the project (for example mhd_assert(max > 0) in MHD_pool_create and the other mhd_assert calls in MHD_pool_destroy and new_connection_process_) becomes an executed no-op. Removing those no-op assert statements would not affect program behaviour, therefore they constitute dead code and violate MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/626.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_probe_log (\"MHD_pool_create: enter, max=%zu\", max);\n  mhd_assert (max > 0);\n  mhd_probe_log (\"MHD_pool_create: after assert (no-op), max=%zu\", max);\n\n  alloc_size = 0;\n  mhd_probe_log (\"MHD_pool_create: initial alloc_size=%zu\", alloc_size);\n\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_probe_log (\"MHD_pool_create: malloc(sizeof MemoryPool) -> pool=%p\", (void *) pool);\n  if (NULL == pool)\n  {\n    mhd_probe_log (\"MHD_pool_create: pool allocation failed, returning NULL\");\n    return NULL;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_probe_log (\"MHD_pool_create: chose MAP_FAILED path (small max=%zu), pool->memory=%p\", max, (void *) pool->memory);\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_probe_log (\"MHD_pool_create: mmap path, rounded alloc_size=%zu\", alloc_size);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_probe_log (\"MHD_pool_create: called mmap -> pool->memory=%p\", (void *) pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_probe_log (\"MHD_pool_create: called VirtualAlloc -> pool->memory=%p\", (void *) pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_probe_log (\"MHD_pool_create: platform without MAP_ANONYMOUS/_WIN32, pool->memory=%p\", (void *) pool->memory);\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    mhd_probe_log (\"MHD_pool_create: fallback malloc path, alloc_size=%zu\", alloc_size);\n    pool->memory = malloc (alloc_size);\n    mhd_probe_log (\"MHD_pool_create: malloc(%zu) -> pool->memory=%p\", alloc_size, (void *) pool->memory);\n    if (NULL == pool->memory)\n    {\n      mhd_probe_log (\"MHD_pool_create: pool->memory allocation failed, freeing pool=%p and returning NULL\", (void *) pool);\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_probe_log (\"MHD_pool_create: using malloc memory, is_mmap=false\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_probe_log (\"MHD_pool_create: using mmap/VirtualAlloc memory, is_mmap=true, pool->memory=%p, alloc_size=%zu\", (void *) pool->memory, alloc_size);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n\n  /* Log alignment information (original assert is a no-op in the analysis scenario) */\n  mhd_probe_log (\"MHD_pool_create: alignment check (computed mod) = %zu\",\n                 (size_t) (((uintptr_t) pool->memory) % (uintptr_t) ALIGN_SIZE));\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_probe_log (\"MHD_pool_create: pos=%zu, end=%zu, size=%zu\", pool->pos, pool->end, pool->size);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_probe_log (\"MHD_pool_create: exiting, returning pool=%p\", (void *) pool);\n  return pool;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aea0e0\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aeb340\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aeb590\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aeb7e0\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aeba30\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aebc80\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed mod) = 0\nMHD_pool_create: pos=0, end=32768, size=32768\nMHD_pool_create: exiting, returning pool=0x561597aea0b0\nMHD_pool_create: enter, max=32768\nMHD_pool_create: after assert (no-op), max=32768\nMHD_pool_create: initial alloc_size=0\nMHD_pool_create: malloc(sizeof MemoryPool) -> pool=0x561597aea0b0\nMHD_pool_create: chose MAP_FAILED path (small max=32768), pool->memory=0xffffffffffffffff\nMHD_pool_create: fallback malloc path, alloc_size=32768\nMHD_pool_create: malloc(32768) -> pool->memory=0x561597aebed0\nMHD_pool_create: using malloc memory, is_mmap=false\nMHD_pool_create: alignment check (computed \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. With mhd_assert defined as ((void)0) every mhd_assert(...) call in MHD_pool_create is an executed no-op; removing those statements would not change program behaviour. That matches MISRA C 2023 Rule 2.2\u2019s definition of dead code (an executed operation whose removal would not affect program behaviour). The provided probe output demonstrates that the asserts have no observable effect in the tested scenarios, supporting the claim that these assert calls are dead code."
}