{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement 'mhd_assert (max > 0);' expands to ((void)0) in this project (see '#define mhd_assert(ignore) ((void)0)'). As written it executes as a no-op and removing it would not change program behaviour, so it constitutes dead code (likely a disabled debug assertion).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/626.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  /* Log entry and incoming parameter to capture the assertion scenario */\n  mhd_probe_log(\"ENTRY: MHD_pool_create called with max=%zu\", max);\n\n  mhd_assert (max > 0);\n\n  /* Record that execution continued past the assertion location. If mhd_assert is a no-op,\n     this will show that removal would not change runtime flow for max==0. */\n  mhd_probe_log(\"AFTER_ASSERT: reached after mhd_assert(max>0); max=%zu\", max);\n  if (0 == max)\n    mhd_probe_log(\"ASSERT_NOOP_EVIDENCE: max==0 but execution continues (mhd_assert likely disabled)\");\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_probe_log(\"malloc(sizeof(MemoryPool)) -> pool=%p\", (void *)pool);\n  if (NULL == pool)\n  {\n    mhd_probe_log(\"ALLOC_FAIL: pool malloc returned NULL\");\n    return NULL;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_probe_log(\"BRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=%zu\", max);\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_probe_log(\"BRANCH: using mmap/VirtualAlloc path; rounded alloc_size=%zu (max=%zu, page=%zu)\", alloc_size, max, (size_t)MHD_sys_page_size_);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_probe_log(\"mmap called -> pool->memory=%p\", (void *)pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_probe_log(\"VirtualAlloc called -> pool->memory=%p\", (void *)pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_probe_log(\"BRANCH: no MAP_ANONYMOUS and not _WIN32 -> set pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    mhd_probe_log(\"FALLBACK: using malloc for pool->memory; alloc_size rounded to %zu\", alloc_size);\n    pool->memory = malloc (alloc_size);\n    mhd_probe_log(\"malloc(alloc_size) -> pool->memory=%p\", (void *)pool->memory);\n    if (NULL == pool->memory)\n    {\n      mhd_probe_log(\"ALLOC_FAIL: pool->memory malloc returned NULL; freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_probe_log(\"POOL_STATE: is_mmap=false\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_probe_log(\"POOL_STATE: is_mmap=true; pool->memory=%p; alloc_size=%zu\", (void *)pool->memory, alloc_size);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n\n  mhd_probe_log(\"FINAL_STATE: pool=%p, memory=%p, pos=%zu, end=%zu, size=%zu\", (void *)pool, (void *)pool->memory, pool->pos, pool->end, pool->size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_probe_log(\"EXIT: returning pool=%p\", (void *)pool);\n  return pool;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce70e0\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce70e0, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce8340\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce8340, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce8590\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce8590, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce87e0\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce87e0, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce8a30\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce8a30, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce8c80\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce8c80, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce8ed0\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce8ed0, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: MHD_pool_create called with max=32768\nAFTER_ASSERT: reached after mhd_assert(max>0); max=32768\nmalloc(sizeof(MemoryPool)) -> pool=0x55e42cce70b0\nBRANCH: small allocation or less than threshold -> set pool->memory = MAP_FAILED; max=32768\nFALLBACK: using malloc for pool->memory; alloc_size rounded to 32768\nmalloc(alloc_size) -> pool->memory=0x55e42cce9120\nPOOL_STATE: is_mmap=false\nFINAL_STATE: pool=0x55e42cce70b0, memory=0x55e42cce9120, pos=0, end=32768, size=32768\nEXIT: returning pool=0x55e42cce70b0\nENTRY: M\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The project defines mhd_assert(ignore) as ((void)0), so the statement mhd_assert(max > 0); compiles to a no-op expression statement. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not affect program behaviour; an executed ((void)0) fits that definition of dead code. The provided probe output (showing execution continuing past the assertion) and the assumption that the test suite is exhaustive support that removing the assertion would not change runtime behaviour, so the reported violation is valid."
}