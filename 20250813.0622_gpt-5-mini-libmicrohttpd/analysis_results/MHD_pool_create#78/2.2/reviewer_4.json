{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the supplied project configuration _MHD_POISON_MEMORY is defined as (void)0. The statement _MHD_POISON_MEMORY(pool->memory, pool->size); therefore expands to a no-op with no side-effects; removing this statement would not change program behaviour. This constitutes dead code according to MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n\n  /* Probe logging to help reproduce and capture the suspected dead-code call.\n     Logs are appended to \"/tmp/logs/626.txt\". Logging is non-intrusive and\n     does not change program logic or memory contents. */\n  {\n    FILE *log = fopen(\"/tmp/logs/626.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"MHD_pool_create: pool=%p max=%zu alloc_size=%zu is_mmap=%d mem=%p\\n\",\n              (void *)pool, max, alloc_size, (int)pool->is_mmap, pool->memory);\n\n      /* If memory was successfully allocated (not MAP_FAILED), capture a small\n         sample of bytes before and after the _MHD_POISON_MEMORY invocation so\n         other agents can observe whether the macro has observable side-effects. */\n      if (pool->memory != MAP_FAILED && pool->size > 0)\n      {\n        size_t sample = pool->size < 16u ? pool->size : 16u;\n        unsigned char *bytes = (unsigned char *) pool->memory;\n\n        fprintf(log, \"pre_poison_bytes:\");\n        for (size_t i = 0u; i < sample; ++i)\n          fprintf(log, \" %02x\", (unsigned int) bytes[i]);\n        fprintf(log, \"\\n\");\n      }\n\n      fprintf(log, \"invoking _MHD_POISON_MEMORY(pool->memory=%p, pool->size=%zu)\\n\",\n              pool->memory, pool->size);\n      fclose(log);\n    }\n  }\n\n  /* The original call under investigation. Keep it unchanged. */\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n\n  /* Post-poison probe: record the byte sample again to show whether the\n     poison operation modified memory contents. */\n  {\n    FILE *log = fopen(\"/tmp/logs/626.txt\", \"a\");\n    if (log)\n    {\n      if (pool->memory != MAP_FAILED && pool->size > 0)\n      {\n        size_t sample = pool->size < 16u ? pool->size : 16u;\n        unsigned char *bytes = (unsigned char *) pool->memory;\n\n        fprintf(log, \"post_poison_bytes:\");\n        for (size_t i = 0u; i < sample; ++i)\n          fprintf(log, \" %02x\", (unsigned int) bytes[i]);\n        fprintf(log, \"\\n\");\n      }\n\n      fprintf(log, \"MHD_pool_create returning pool=%p size=%zu end=%zu pos=%zu\\n\",\n              (void *)pool, pool->size, pool->end, pool->pos);\n      fclose(log);\n    }\n  }\n\n  return pool;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655e6f00\npre_poison_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655e6f00, pool->size=32768)\npost_poison_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 70 6f 73 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 70 6f 73 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 73 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 73 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 74 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 5f 70 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 70 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 70 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 61 6f 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 61 6f 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 61 20 69 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 61 20 69 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 61 20 48 73 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 61 20 48 73 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 61 20 48 54 6f 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 61 20 48 54 6f 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=32768 end=32768 pos=0\nMHD_pool_create: pool=0x55cb655e6ed0 max=32768 alloc_size=32768 is_mmap=0 mem=0x55cb655ef0f0\npre_poison_bytes: 50 55 54 00 2f 61 20 48 54 54 6e 5f 62 79 74 65\ninvoking _MHD_POISON_MEMORY(pool->memory=0x55cb655ef0f0, pool->size=32768)\npost_poison_bytes: 50 55 54 00 2f 61 20 48 54 54 6e 5f 62 79 74 65\nMHD_pool_create returning pool=0x55cb655e6ed0 size=3276\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. In the supplied project configuration _MHD_POISON_MEMORY expands to (void)0, so the statement _MHD_POISON_MEMORY(pool->memory, pool->size); is executed but has no side effects; removing it would not change program behaviour. That meets the definition of dead code in MISRA C 2023 Rule 2.2, therefore the code violates the rule in this project configuration."
}