{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'session' is declared as 'struct Session *session' but is only read (used to access session->value_1 and session->sid) and never modified. Therefore it could be 'const struct Session *session' (and add_session_cookie should likewise accept a const pointer). Because the pointer could and should be const-qualified, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_event(const char *event,\n                                const struct Session *session,\n                                int reply_len,\n                                struct MHD_Response *response,\n                                struct MHD_Connection *connection,\n                                int ret_val)\n{\n  FILE *fp = fopen(\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == fp)\n  {\n    /* best-effort logging only; do nothing if we cannot open the file */\n    return;\n  }\n\n  fprintf(fp, \"EVENT: %s\\n\", event);\n  fprintf(fp, \"  session ptr: %p\\n\", (const void *) session);\n  /* Log addresses of members to show they are read from the session structure */\n  if (session != NULL)\n  {\n    fprintf(fp, \"  session->value_1 addr: %p\\n\", (const void *) (&session->value_1));\n    fprintf(fp, \"  session->sid addr: %p\\n\", (const void *) (&session->sid));\n  }\n  fprintf(fp, \"  reply_len: %d\\n\", reply_len);\n  fprintf(fp, \"  response ptr: %p\\n\", (void *) response);\n  fprintf(fp, \"  connection ptr: %p\\n\", (void *) connection);\n  fprintf(fp, \"  ret_val (if known): %d\\n\", ret_val);\n  fprintf(fp, \"---\\n\");\n  fclose(fp);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry and session info (shows pointer is only read here) */\n  probe_log_event(\"enter fill_v1_form\", session, -1, NULL, connection, -1);\n\n  /* Emulate 'asprintf' */\n  /* Log that we are about to read session->value_1 for formatting */\n  probe_log_event(\"about to compute reply_len (reads session->value_1)\", session, -1, NULL, connection, -1);\n\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n  {\n    probe_log_event(\"snprintf computed negative reply_len -> internal error\", session, reply_len, NULL, connection, (int) MHD_NO);\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n  {\n    probe_log_event(\"malloc returned NULL -> out-of-memory\", session, reply_len, NULL, connection, (int) MHD_NO);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    probe_log_event(\"snprintf wrote unexpected number of bytes -> printf error\", session, reply_len, NULL, connection, (int) MHD_NO);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    /* Log just before calling add_session_cookie (shows non-const session is passed)\") */\n    probe_log_event(\"before add_session_cookie (session passed to function)\", session, reply_len, response, connection, -1);\n\n    add_session_cookie (session, response);\n\n    /* Log immediately after adding session cookie */\n    probe_log_event(\"after add_session_cookie\", session, reply_len, response, connection, -1);\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      probe_log_event(\"MHD_add_response_header failed (but continuing)\", session, reply_len, response, connection, -1);\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log_event(\"queued response\", session, reply_len, response, connection, (int) ret);\n\n    MHD_destroy_response (response);\n    probe_log_event(\"destroyed response\", session, reply_len, NULL, connection, (int) ret);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n    probe_log_event(\"MHD_create_response_from_buffer_with_free_callback returned NULL\", session, reply_len, NULL, connection, (int) ret);\n  }\n\n  probe_log_event(\"exit fill_v1_form\", session, reply_len, NULL, connection, (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the evidence shown. MISRA C 2023 Rule 8.13 indeed recommends that pointer parameters be to const-qualified types when they are used only for reading, but you must consider all uses of the parameter \u2014 including calls to other functions \u2014 before concluding a violation. In fill_v1_form the function reads session->value_1, but it also passes session to add_session_cookie(session, response). Because the prototype/implementation of add_session_cookie is not provided, you cannot determine whether that calleee mutates the Session object or requires a non-const pointer. Without proving that neither fill_v1_form nor any called function modifies the Session object (or requires a non-const parameter), you cannot conclude that the parameter should be const and therefore cannot claim a definite MISRA 8.13 violation. \n\nIf add_session_cookie (and any other callees) take a const struct Session * and do not perform modifications, then fill_v1_form could/should be changed to accept const struct Session *session (and add_session_cookie adjusted if necessary) to conform with Rule 8.13. But based on the provided code and logs (which are empty and do not demonstrate read-only usage), the report is not correct."
}