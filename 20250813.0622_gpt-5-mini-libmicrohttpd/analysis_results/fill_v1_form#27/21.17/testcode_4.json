{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The memmove()/memcpy() can write past the end of buf because buf_size is computed from an initial \u2018norm_len\u2019 estimate but the code then reduces norm_len and later unconditionally (only guarded by an mhd_assert) assumes there is extra space for inserting \"close, \". In the branch value_has_close && !already_has_close the memmove copies norm_len+1 bytes to buf + old_value_len + MHD_STATICSTR_LEN_(\"close, \") and memcpy writes the \"close\" token at buf. If the initially allocated buf_size (old_value_len + initial norm_len) is smaller than old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1 (the code only asserts this, does not enforce it), the memmove/memcpy will access beyond the allocated buffer. Therefore MISRA C 2023 Rule 21.17 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified fill_v1_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/223.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of fill_v1_form as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of fill_v1_form:\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified fill_v1_form code.\n",
  "test_code": "static void\nlog_fill_v1_form_state(const char *phase,\n                       int reply_len,\n                       size_t alloc_size,\n                       const char *reply_ptr,\n                       int snprintf_ret,\n                       const char *value1_ptr,\n                       size_t value1_len,\n                       const void *session_ptr,\n                       const void *connection_ptr)\n{\n  FILE *f = fopen(\"/tmp/logs/223.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[fill_v1_form] phase=%s\\n\", phase);\n  fprintf(f, \"  session=%p, connection=%p\\n\", session_ptr, connection_ptr);\n  fprintf(f, \"  reply_len=%d, alloc_size=%zu, snprintf_ret=%d\\n\",\n          reply_len, alloc_size, snprintf_ret);\n  fprintf(f, \"  reply_ptr=%p\\n\", (const void *) reply_ptr);\n  if (value1_ptr != NULL)\n    fprintf(f, \"  value1_ptr=%p, value1_len=%zu\\n\", (const void *) value1_ptr, value1_len);\n  else\n    fprintf(f, \"  value1_ptr=(null)\\n\");\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry */\n  log_fill_v1_form_state(\"entry\", -1, 0, NULL, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  log_fill_v1_form_state(\"after_snprintf_len\", reply_len, 0, NULL, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  if (0 > reply_len)\n  {\n    log_fill_v1_form_state(\"error_snprintf_len_negative\", reply_len, 0, NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  log_fill_v1_form_state(\"after_malloc\", reply_len, (size_t) ((size_t) reply_len + 1), reply, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  if (NULL == reply)\n  {\n    log_fill_v1_form_state(\"error_malloc_failed\", reply_len, (size_t) ((size_t) reply_len + 1), NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    log_fill_v1_form_state(\"error_snprintf_mismatch\", reply_len, (size_t) ((size_t) reply_len + 1), reply, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* Log after successful formatting */\n  log_fill_v1_form_state(\"after_successful_format\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      log_fill_v1_form_state(\"warning_no_content_type\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                             session ? session->value_1 : NULL,\n                             (session && session->value_1) ? strlen(session->value_1) : 0,\n                             (const void *) session,\n                             (const void *) connection);\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    log_fill_v1_form_state(\"after_queue_response\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    log_fill_v1_form_state(\"error_create_response_failed\", reply_len, (size_t) ((size_t) reply_len + 1), NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n"
}