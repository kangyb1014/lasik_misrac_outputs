{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assertion uses memcmp(hdr->value, \"close\", 5) to check whether the header value equals the null-terminated string \"close\". hdr->value is stored/used as a null-terminated header string (buf[pos] = 0), so memcmp is being used to compare null-terminated strings rather than the appropriate string routine.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_fill_v1_form_probe(const char *stage,\n                         const char *mime,\n                         const void *session_ptr,\n                         const char *value1,\n                         int reply_len,\n                         const void *reply_ptr,\n                         const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/222.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Basic, robust logging: avoid dereferencing possibly-null pointers in format */\n  fprintf(f,\n          \"[fill_v1_form] stage=%s session=%p mime=%s reply_len=%d reply_ptr=%p value1=%s extra=%s\\n\",\n          stage ? stage : \"(null)\",\n          session_ptr,\n          mime ? mime : \"(null)\",\n          reply_len,\n          reply_ptr,\n          (value1 != NULL) ? value1 : \"(null)\",\n          (extra != NULL) ? extra : \"(null)\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  const char *value1;\n  (void) cls; /* Unused */\n\n  /* Probe: entry state */\n  value1 = (session != NULL) ? session->value_1 : NULL;\n  log_fill_v1_form_probe(\"entry\", mime, (const void *) session, value1, -1, NULL, NULL);\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, value1);\n  log_fill_v1_form_probe(\"after_snprintf_len\", mime, (const void *) session, value1, reply_len, NULL, NULL);\n  if (0 > reply_len)\n  {\n    log_fill_v1_form_probe(\"error_negative_len\", mime, (const void *) session, value1, reply_len, NULL, \"Internal error\");\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  log_fill_v1_form_probe(\"after_malloc\", mime, (const void *) session, value1, reply_len, (const void *) reply, NULL);\n  if (NULL == reply)\n  {\n    log_fill_v1_form_probe(\"error_nomem\", mime, (const void *) session, value1, reply_len, NULL, \"Out-of-memory\");\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             value1))\n  {\n    log_fill_v1_form_probe(\"error_snprintf_mismatch\", mime, (const void *) session, value1, reply_len, (const void *) reply, \"printf error\");\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* log the produced reply buffer (safe: reply is null-terminated as from snprintf) */\n  log_fill_v1_form_probe(\"reply_ready\", mime, (const void *) session, value1, reply_len, (const void *) reply, reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    log_fill_v1_form_probe(\"response_created\", mime, (const void *) session, value1, reply_len, (const void *) response, NULL);\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      log_fill_v1_form_probe(\"header_set_failed\", mime, (const void *) session, value1, reply_len, (const void *) response, \"content-type failed\");\n      /* return response without content type anyway ... */\n    }\n    else\n    {\n      log_fill_v1_form_probe(\"header_set_ok\", mime, (const void *) session, value1, reply_len, (const void *) response, \"content-type ok\");\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    log_fill_v1_form_probe(\"after_queue_response\", mime, (const void *) session, value1, reply_len, (const void *) response, (ret == MHD_YES) ? \"queued_ok\" : \"queued_fail\");\n    MHD_destroy_response (response);\n    log_fill_v1_form_probe(\"after_destroy_response\", mime, (const void *) session, value1, reply_len, NULL, NULL);\n  }\n  else\n  {\n    free (reply);\n    log_fill_v1_form_probe(\"response_null\", mime, (const void *) session, value1, reply_len, NULL, \"response creation failed\");\n    ret = MHD_NO;\n  }\n  log_fill_v1_form_probe(\"exit\", mime, (const void *) session, value1, reply_len, NULL, (ret == MHD_YES) ? \"return_yes\" : \"return_no\");\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "I reviewed the provided fill_v1_form code and the probe/test code. There is no use of memcmp (or any comparison of a header value to a literal like \"close\") in the shown function. The agent A\u2019s scenario describes a memcmp(hdr->value, \"close\", 5) usage in some header-handling code, but that code is not present in the target function. Therefore the claimed violation of MISRA C 2023 Rule 21.14 does not apply to the displayed fill_v1_form implementation. If there is a separate header-parsing module that uses memcmp on a null-terminated string, that separate code would need to be inspected and (if true) changed to strcmp/strncmp; however, the report as applied to this fill_v1_form code is incorrect."
}