{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    *req_cls = &already_called_marker;\n    /* Wait for complete request */\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code takes the address of already_called_marker (declared as \u2018static int already_called_marker\u2019) and stores/compares it via a void* (through req_cls). The marker is never modified, so the pointer could/should point to a const-qualified type (e.g. declare the marker as \u2018static const int\u2019 and use a pointer-to-const). Using a non-const int* here therefore violates MISRA C 2023 Rule 8.13. Note: fixing this cleanly may require changes to the API (req_cls type) or an explicit cast when assigning a const address to the void* slot.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_req_state(const char *stage, const void *marker_addr, const void *req_cls_val, int equal)\n{\n  FILE *f = fopen(\"/tmp/logs/507.txt\", \"a\");\n  if (f != NULL)\n  {\n    (void) fprintf(f, \"%s: marker_addr=%p, req_cls_val=%p, equal=%d\\n\",\n                   stage, marker_addr, req_cls_val, equal);\n    (void) fclose(f);\n  }\n}\nstatic void log_auth_result(const char *stage, int res_e, int ret_val)\n{\n  FILE *f = fopen(\"/tmp/logs/507.txt\", \"a\");\n  if (f != NULL)\n  {\n    (void) fprintf(f, \"%s: auth_result=%d, return_val=%d\\n\", stage, res_e, ret_val);\n    (void) fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log initial state: address of marker and current req_cls value. */\n  {\n    void *current_req = NULL;\n    if (req_cls != NULL)\n    {\n      current_req = *req_cls; /* same dereference as in original code */\n    }\n    log_req_state(\"ENTRY\", (const void *)&already_called_marker, current_req,\n                  (current_req == (void *)&already_called_marker));\n  }\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    /* Log that we are about to set req_cls to point to the marker */\n    log_req_state(\"FIRST_TIME_BEFORE_SET\", (const void *)&already_called_marker, *req_cls, 0);\n\n    *req_cls = &already_called_marker;\n\n    /* Log after setting to capture the pointer assignment evidence */\n    log_req_state(\"FIRST_TIME_AFTER_SET\", (const void *)&already_called_marker, *req_cls,\n                  (*req_cls == (void *)&already_called_marker));\n\n    /* Wait for complete request */\n    log_auth_result(\"RETURN_EARLY\", -1, (int)MHD_YES);\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  log_req_state(\"BEFORE_AUTH_CHECK\", (const void *)&already_called_marker, *req_cls,\n                (*req_cls == (void *)&already_called_marker));\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n\n  /* Log the auth check result */\n  log_auth_result(\"AFTER_AUTH_CHECK\", (int)res_e, -1);\n\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    /* Log that we're about to destroy the response and return */\n    log_auth_result(\"AUTH_REQUIRED_RESPONSE\", (int)res_e, (int)ret);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n\n  /* Log successful response queuing and final pointer state */\n  log_auth_result(\"SUCCESS_RESPONSE_QUEUED\", (int)res_e, (int)ret);\n  log_req_state(\"EXIT\", (const void *)&already_called_marker, *req_cls,\n                (*req_cls == (void *)&already_called_marker));\n\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 (\u201cA pointer should point to a const\u2011qualified type whenever possible\u201d) is a guidance to prefer const qualification of pointed\u2011to types when it is feasible. In this function the pointer that is being written to (*req_cls) is provided by an external API and has type void **. The code stores the address of a static marker object into that API slot. The marker could be declared const (it is never modified), but doing so would create a qualifier mismatch: &already_called_marker would be a const int *, and assigning that to a plain void * (via the void ** API) would discard constness and require a cast \u2014 also undesirable and potentially non\u2011conforming. Because the pointer type (void **) is imposed by the external API, you cannot both (a) declare the marker const and (b) store its address into the existing void ** without an explicit cast or changing the API. Under MISRA reasoning this is an API compatibility constraint and not a straightforward violation of 8.13 in the code as written. If strict conformance is required, the options are to change the API to accept a pointer\u2011to\u2011const (so req_cls becomes pointer to const void *), or to document a formal deviation and/or add an explicit, justified cast. In short: the agent\u2019s claim is not correct as a plain violation \u2014 the situation is an API incompatibility/constraint rather than a simple failure to qualify the pointed type with const."
}