{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    *req_cls = &already_called_marker;\n    /* Wait for complete request */\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code stores the address of a non-const static int (already_called_marker) into a void* request context: '*req_cls = &already_called_marker;'. The object is used only as an immutable marker, so the pointer should point to a const-qualified type (e.g. const int or const void*) to prevent accidental modification and to respect Rule 8.13. (If the API permits, declare 'already_called_marker' as 'static const int' and use a const-qualified pointer type; otherwise a cast hides the qualifier loss.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nahc_echo_log_state(const char *event, void **req_cls, void *marker_addr, int marker_val, int res_e, int ret_val)\n{\n  FILE *fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n  if (NULL == fp)\n  {\n    return; /* Logging failure should not affect program logic */\n  }\n  /* Log key pointers and integer status values; keep entries simple to parse */\n  (void) fprintf(fp, \"[ahc_echo] event=%s req_cls_ptr=%p req_cls_pointed=%p marker_addr=%p marker_val=%d res_e=%d ret=%d\\n\",\n                 event,\n                 (void *) &req_cls,\n                 (void *) (req_cls ? *req_cls : NULL),\n                 marker_addr,\n                 marker_val,\n                 res_e,\n                 ret_val);\n  (void) fclose(fp);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and current state before the first conditional check */\n  ahc_echo_log_state(\"entry\", req_cls, (void *) &already_called_marker, already_called_marker, -1, -1);\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    /* Log decision to set marker into req_cls */\n    ahc_echo_log_state(\"assign_marker_before\", req_cls, (void *) &already_called_marker, already_called_marker, -1, -1);\n\n    *req_cls = &already_called_marker;\n\n    /* Log state after assignment */\n    ahc_echo_log_state(\"assign_marker_after\", req_cls, (void *) &already_called_marker, already_called_marker, -1, -1);\n\n    /* Wait for complete request */\n    ahc_echo_log_state(\"returning_wait\", req_cls, (void *) &already_called_marker, already_called_marker, -1, (int) MHD_YES);\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n\n  /* Log result of digest auth check */\n  ahc_echo_log_state(\"after_digest_check\", req_cls, (void *) &already_called_marker, already_called_marker, (int) res_e, -1);\n\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    /* Log before destroying response and returning */\n    ahc_echo_log_state(\"auth_required_return\", req_cls, (void *) &already_called_marker, already_called_marker, (int) res_e, (int) ret);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n\n  /* Log successful response path */\n  ahc_echo_log_state(\"success_return\", req_cls, (void *) &already_called_marker, already_called_marker, (int) res_e, (int) ret);\n\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C:2023 Rule 8.13 encourages pointers to point to const-qualified types where reasonably possible, but it applies to pointer declarations under the control of the code author and only \"whenever possible\". In this function the context pointer type (void **req_cls and the pointed-to void *) is fixed by the external API (libmicrohttpd callback signature) and therefore cannot be changed here. Declaring already_called_marker as const would indeed express the immutability intent, but assigning &already_called_marker (a const int *) into the API-provided void * slot would discard qualifiers (or require an explicit cast) \u2014 which itself is problematic and would not be a straightforward compliant change without changing the API. In short: the code\u2019s use of a non-const static int marker is a pragmatic result of the API signature; you cannot simply make the marker const without further API changes or introducing casts. Therefore the agent\u2019s claim that the shown code violates Rule 8.13 is not correct in this context."
}