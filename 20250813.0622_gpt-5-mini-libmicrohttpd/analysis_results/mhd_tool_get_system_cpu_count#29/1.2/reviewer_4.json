{
  "user_message": "An agent A claimed that the following mhd_tool_get_system_cpu_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_system_cpu_count.\n```c\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n#endif /* __linux__ || __GLIBC__  */\n\n  return -1; /* Cannot detect */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts the result of GetProcAddress through (void *) to a function pointer type: ptrGetThreadGroupAffinity = (GTGA_PTR) (void *) GetProcAddress (k32hndl, \"GetThreadGroupAffinity\"); This relies on conversion between object pointers and function pointers (data-pointer \u21c4 function-pointer), which is not guaranteed by ISO C and is only supported as an implementation-specific/extended behaviour on many compilers. Therefore it depends on a compiler-specific extension/implementation-defined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_append(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/232.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf(f, \"%s\\n\", msg);\n  fclose(f);\n}\nstatic void log_call_result(const char *name, int result)\n{\n  FILE *f = fopen(\"/tmp/logs/232.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf(f, \"Function %s returned %d (errno=%d)\\n\", name, result, errno);\n  fclose(f);\n}\nstatic int invoke_and_log(const char *name, int (*fn)(void))\n{\n  int r;\n  FILE *f = fopen(\"/tmp/logs/232.txt\", \"a\");\n  if (f) {\n    fprintf(f, \"Invoking %s()\\n\", name);\n    fclose(f);\n  }\n\n  r = fn();\n\n  log_call_result(name, r);\n  return r;\n}\n\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  log_append(\"ENTER: mhd_tool_get_system_cpu_count\");\n\n  /* Try specialised APIs first */\n  res = invoke_and_log(\"mhd_tool_get_sys_cpu_count_special_api_\",\n                       mhd_tool_get_sys_cpu_count_special_api_);\n  if (0 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (special_api) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = invoke_and_log(\"mhd_tool_get_sys_cpu_count_sysctl_\",\n                       mhd_tool_get_sys_cpu_count_sysctl_);\n  if (0 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysctl) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = invoke_and_log(\"mhd_tool_get_sys_cpu_count_sysconf_\",\n                       mhd_tool_get_sys_cpu_count_sysconf_);\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysconf) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysconf > 2) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = invoke_and_log(\"mhd_tool_get_proc_cpu_count\",\n                                    mhd_tool_get_proc_cpu_count);\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      char buf[128];\n      snprintf(buf, sizeof(buf), \"proc_cpu_count == res (%d). return %d\",\n               proc_cpu_count, res);\n      log_append(buf);\n      return res;\n    }\n    else\n    {\n      char buf[128];\n      snprintf(buf, sizeof(buf), \"proc_cpu_count (%d) != res (%d). continue\",\n               proc_cpu_count, res);\n      log_append(buf);\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = invoke_and_log(\"mhd_tool_get_sys_cpu_count_sysctl_fallback_\",\n                       mhd_tool_get_sys_cpu_count_sysctl_fallback_);\n  if (0 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysctl_fallback) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n\n  res = invoke_and_log(\"mhd_tool_get_sys_cpu_count_sysconf_fallback_\",\n                       mhd_tool_get_sys_cpu_count_sysconf_fallback_);\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysconf_fallback) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"early return (sysconf_fallback > 2) -> %d\", res);\n    log_append(buf);\n    return res;\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  log_append(\"EXIT: mhd_tool_get_system_cpu_count -> -1 (Cannot detect)\");\n  return -1; /* Cannot detect */\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_system_cpu_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the provided mhd_tool_get_system_cpu_count code. MISRA C 2023 Rule 1.2 prohibits use of compiler language extensions (extensions explicitly documented by the compiler). The target function contains only standard C constructs (local variables, function calls, #if/#else conditional compilation and standard library calls in the test harness) and does not perform any cast between object pointers and function pointers nor any other use of a documented compiler extension. The scenario described by agent A (casting GetProcAddress through (void *) to a function pointer) refers to a different piece of code that is not present in the supplied mhd_tool_get_system_cpu_count snippet. If such a cast exists elsewhere, that other code should be provided for review; casting between object and function pointers can be implementation-defined/unsupported by ISO C and could trigger a Rule 1.2 concern only if it relies on a documented compiler extension. As stands, the reported violation for this function is false."
}