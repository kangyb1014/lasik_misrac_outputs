{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "run_usock",
    "ws_receive_frame (declaration/prototype, if any)",
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "malloc (stdlib.h prototype)"
  ],
  "explanation": "run_usock: The only caller of ws_receive_frame per the call graph. You must inspect run_usock's definition to see (a) how the 'frame' argument is obtained/allocated/populated and whether it is ever modified by the caller (which determines if the 'frame' parameter could be const-qualified), (b) how the returned unsigned char * (msg) is used \u2014 whether the caller modifies or frees it \u2014 which determines whether the return type should be non-const or could be const. ws_receive_frame (declaration/prototype, if any): If there is a separate function prototype in the translation unit or a header, it may already include const qualifiers that must match the definition; the prototype can affect whether the current signature violates MISRA recommendations. WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: The macros/constants determine how frame[0] is inspected; knowing their definitions gives context about whether frame is treated read-only and whether those checks imply any intended mutability contract for the frame buffer. malloc (stdlib.h prototype): Confirms allocation semantics and return type (void *) and helps verify whether returning a modifiable pointer is intended; also for complete type/qualifier analysis related to the allocated buffer. Each of the above is necessary to decide whether the input pointer(s) (frame, length, type) and the returned pointer could or should be const-qualified under the MISRA rule, based on actual usage and existing declarations."
}