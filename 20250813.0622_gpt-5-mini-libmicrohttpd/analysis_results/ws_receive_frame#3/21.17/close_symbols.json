{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "frame (the buffer passed into ws_receive_frame)",
    "*length (the ssize_t value passed-by-reference to ws_receive_frame)",
    "run_usock (the caller and site that constructs/fills the frame and length)",
    "malloc (and NULL)",
    "ssize_t and size_t typedefs / their widths"
  ],
  "explanation": "WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: these protocol macros determine which branch is taken and therefore whether the code indexes into frame and copies/de-masks payload bytes \u2014 you must know their values/meanings to know when the data-copy path executes. frame (the buffer passed into ws_receive_frame): to check for out-of-bounds reads (frame[idx_first_mask + k] and frame[i]) you need the actual allocation/size and layout of this buffer. *length (the ssize_t value passed-by-reference): the function uses *length as the total buffer length and updates it; to judge whether index arithmetic (idx_first_mask, idx_first_data, loop bounds) can exceed the buffer you must know the initial value and constraints on *length. run_usock (the caller): the caller creates/fills the frame buffer and supplies the length \u2014 inspect run_usock to see how many bytes are present, whether length can be smaller than the computed header offsets, and any invariants (e.g., socket read result) that prevent OOB access. malloc (and NULL): msg allocation size uses data_length + 1; you need malloc semantics to reason about whether the requested size matches observed data_length and whether allocation failure changes control flow. ssize_t and size_t typedefs / widths: integer types and signed/unsigned conversions (especially when computing data_length = (size_t)*length - idx_first_data and casting idx_first_data to unsigned char) affect underflow/overflow behavior; know their sizes to analyze possible negative *length causing huge size_t values and resultant OOB."
}