{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "run_usock",
    "ws_send_frame",
    "send_all",
    "MHD_upgrade_action",
    "memcmp",
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "malloc"
  ],
  "explanation": "- run_usock: This is the direct caller of ws_receive_frame (per the static call graph). To decide whether ws_receive_frame leads to a MISRA violation you must inspect how the caller uses the returned msg (e.g. whether run_usock compares it with memcmp on a null-terminated string).\n- ws_send_frame: run_usock may pass the message returned by ws_receive_frame on to ws_send_frame; ws_send_frame must be inspected to see if it (or any downstream routine) uses memcmp to compare null\u2011terminated strings produced by ws_receive_frame.\n- send_all: Another function called by run_usock that could receive or inspect message buffers; include to check for memcmp usage on null\u2011terminated data.\n- MHD_upgrade_action: Called from run_usock and potentially involved in handling/inspecting WebSocket payloads; include to ensure no memcmp-on-string occurs there.\n- memcmp: The standard library function under scrutiny \u2014 search for and inspect all uses of memcmp in the caller chain to see whether it is being used to compare null\u2011terminated strings returned/produced by ws_receive_frame.\n- WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: The macros/defines determine control flow inside ws_receive_frame (whether the function produces a null\u2011terminated text message). You must know their values/semantics to determine if the text-frame branch (which creates a '\\0' terminated buffer) is reachable.\n- malloc: Although not directly related to memcmp, knowing malloc behavior and any alternative allocation wrappers used in the project is necessary to confirm the returned msg is a proper null\u2011terminated buffer (and whether callers may treat it as a C string)."
}