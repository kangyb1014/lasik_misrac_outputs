{
  "user_message": "An agent A claimed that the following create_response code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of create_response.\n```c\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strcmp(method, MHD_HTTP_METHOD_POST) can access memory beyond the bounds of the object referenced by 'method' if that pointer is NULL or does not point to a NUL-terminated string. For example, if the caller supplies method == NULL (or a non-terminated buffer), strcmp will dereference/read past the object's bounds, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log(const char *stage,\n          const char *method,\n          const char *url,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void *request)\n{\n  FILE *f = fopen(\"/tmp/logs/551.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log timestamp and key pointer/state information without dereferencing\n     potentially invalid pointers (to avoid introducing new out-of-bounds\n     accesses). */\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] stage=%s method_ptr=%p method_is_null=%d url_ptr=%p upload_data_ptr=%p upload_data_size=%s request_ptr=%p\\n\",\n          (long)t,\n          stage,\n          (const void *) method,\n          (method == NULL),\n          (const void *) url,\n          (const void *) upload_data,\n          (upload_data_size != NULL) ? ({ static char buf[32]; snprintf(buf, sizeof buf, \"%zu\", *upload_data_size); buf; }) : \"(null)\",\n          request);\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n\n    /* Probe before calling strcmp to capture the pointer value and state.\n       Do not dereference 'method' here (only log pointer and nullness) so we\n       don't introduce additional out-of-bounds accesses. */\n    probe_log(\"initial_post_check\", method, url, version, upload_data, upload_data_size, (void *) request);\n\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n\n  /* Probe before POST processing strcmp */\n  probe_log(\"post_processing_check\", method, url, version, upload_data, upload_data_size, (void *) request);\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  /* Probe before GET/HEAD checks to capture current method/url pointers. */\n  probe_log(\"get_head_check\", method, url, version, upload_data, upload_data_size, (void *) request);\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    /* Log page/url pointers before entering the loop to help reproduce any\n       issues related to url pointer validity used in strcmp below. */\n    probe_log(\"page_search_start\", method, url, version, upload_data, upload_data_size, (void *) request);\n\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for create_response. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario is technically possible only if the caller passes invalid inputs, but it is not a definite MISRA 21.17 violation in the context of this code as used. The create_response function is an MHD access-handler callback whose signature (libmicrohttpd) documents that url, method and version are supplied by the library as valid NUL\u2011terminated strings (and pages[].url are static NUL\u2011terminated strings). Given that contract, the calls to strcmp() and strlen() cannot legally access beyond the bounds of their pointed-to objects, so there is no rule breach in normal use.\n\nHowever, if the function could be invoked by some code that passes method or url == NULL or non\u2011NUL\u2011terminated buffers, then the use of strcmp/strlen would indeed risk out-of-bounds access and would violate Rule 21.17. To make the code robust and unambiguous from a MISRA perspective, either (a) assert/document the external contract that those pointers are non\u2011NULL and NUL\u2011terminated, or (b) add defensive checks (e.g. test for NULL before calling strcmp/strlen or use bounded functions with known lengths) so the code does not rely solely on external guarantees.\n\nIn summary: the agent\u2019s hypothetical is correct in itself (strcmp on a NULL or unterminated buffer would be out-of-bounds), but given the documented API contract of the MHD callback the reported violation is not applicable in this context. Therefore the report as a definite violation is not correct."
}