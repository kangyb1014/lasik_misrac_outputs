{
  "user_message": "An agent A claimed that the following MHD_set_response_options code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_response_options.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n        return MHD_NO;\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n    return MHD_NO;\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      break;\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function is declared with the macro _MHD_EXTERN which expands to the GCC-specific attribute syntax __attribute__((visibility(\"default\"))) (i.e. __attribute__((...))) before extern. The use of __attribute__((...)) is a compiler-specific language extension, so Rule 1.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  FILE *log = fopen(\"/tmp/logs/304.txt\", \"a\");\n  if (log)\n  {\n#if defined(__GNUC__)\n    fprintf(log, \"[probe] Compiler: GNUC %d.%d (patch %d)\\n\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#elif defined(__clang__)\n    fprintf(log, \"[probe] Compiler: Clang\\n\");\n#elif defined(_MSC_VER)\n    fprintf(log, \"[probe] Compiler: MSVC %d\\n\", _MSC_VER);\n#else\n    fprintf(log, \"[probe] Compiler: unknown\\n\");\n#endif\n#ifdef __has_attribute\n#if __has_attribute(visibility)\n    fprintf(log, \"[probe] Compiler reports support for __attribute__((visibility(...)))\\n\");\n#else\n    fprintf(log, \"[probe] Compiler reports NO support for __attribute__((visibility(...))) via __has_attribute\\n\");\n#endif\n#elif defined(__GNUC__)\n    /* GCC has supported visibility attribute for many versions */\n    fprintf(log, \"[probe] Assuming visibility attribute supported (GCC detected)\\n\");\n#else\n    fprintf(log, \"[probe] No portable check available for visibility attribute support\\n\");\n#endif\n  }\n\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  /* Log entry state */\n  if (log)\n  {\n    fprintf(log, \"[probe] ENTER MHD_set_response_options: response=%p, flags=0x%08x\\n\",\n            (void *)response, (unsigned int)flags);\n    if (response)\n    {\n      fprintf(log, \"[probe] response->flags_auto=0x%08x, response->flags=0x%08x, response->total_size=%llu\\n\",\n              (unsigned int)response->flags_auto,\n              (unsigned int)response->flags,\n              (unsigned long long)response->total_size);\n    }\n  }\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if (log) fprintf(log, \"[probe] Branch: response has MHD_RAF_HAS_CONTENT_LENGTH\\n\");\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      if (log) fprintf(log, \"[probe] Condition: trying to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH -> returning MHD_NO\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (log) fprintf(log, \"[probe] Condition: trying to remove MHD_RF_HEAD_ONLY_RESPONSE\\n\");\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n      {\n        if (log) fprintf(log, \"[probe] Sub-condition: no INSANITY_CONTENT_LENGTH in new flags -> returning MHD_NO\\n\");\n        if (log) fclose(log);\n        return MHD_NO;\n      }\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n  {\n    if (log) fprintf(log, \"[probe] Condition: HEAD_ONLY_RESPONSE requested but total_size != 0 -> returning MHD_NO\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  if (log) fprintf(log, \"[probe] After checks: ret=MHD_YES, response->flags set to 0x%08x\\n\", (unsigned int)response->flags);\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    if (log) fprintf(log, \"[probe] vararg option ro=%d\\n\", (int)ro);\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      if (log) fprintf(log, \"[probe] encountered MHD_RO_END inside loop (unexpected)\\n\");\n      break;\n    default:\n      if (log) fprintf(log, \"[probe] encountered unknown/unsupported response option (%d) -> setting ret=MHD_NO\\n\", (int)ro);\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n\n  if (log) fprintf(log, \"[probe] EXIT MHD_set_response_options: returning %d\\n\", (int)ret);\n  if (log) fclose(log);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_set_response_options. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the code shown. The source uses the identifier _MHD_EXTERN, but the snippet does not show its definition. MISRA C:2023 Rule 1.2 is about use of compiler language extensions (e.g. GCC\u2019s __attribute__((...))). If _MHD_EXTERN actually expands to an extension such as __attribute__((visibility(\"default\"))) then that would be the use of a compiler extension and should be reported. However, from the provided target_code there is no direct occurrence of __attribute__ (only the macro name), so you cannot conclude a violation from this snippet alone.\n\nThe provided test/probe code also gives no evidence: it only logs compiler/attribute support when the function runs, and the test log remained empty (the function apparently was not executed), so it does not prove the macro expands to a compiler extension either.\n\nRecommendation: inspect the header(s) to find the definition of _MHD_EXTERN. If it expands unconditionally to a compiler-specific attribute (e.g. __attribute__((...))) then Agent A\u2019s report would be correct; if it is defined empty or guarded by portable preprocessor checks (or maps to a standard-storage-class specifier), then there is no Rule 1.2 violation in the shown code. If an extension is used intentionally, document and justify it per project/MISRA deviation procedures or replace with a portable alternative."
}