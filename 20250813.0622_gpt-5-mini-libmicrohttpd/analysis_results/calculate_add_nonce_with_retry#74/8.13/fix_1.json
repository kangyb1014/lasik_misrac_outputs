{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/595.txt\", \"a\");\n  if (f == NULL)\n    return; /* Best-effort logging, don't change program behavior if logging fails */\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', f);\n  fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n  /* Log entry state */\n  mhd_probe_log (\"ENTER calculate_add_nonce_with_retry: connection=%p, daemon=%p, realm='%s', realm_len=%zu, timestamp1=%llu\",\n                 (void *) connection,\n                 (void *) connection->daemon,\n                 realm ? realm : \"(null)\",\n                 realm_len,\n                 (unsigned long long) timestamp1);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n  {\n    /* Log the condition where digest_auth_rand_size is zero */\n    mhd_probe_log (\"HAVE_MESSAGES: master()->digest_auth_rand_size == 0 (master=%p)\",\n                   (void *) MHD_get_master (connection->daemon));\n\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n  }\n#else\n  /* Still log presence/absence of master for tracing the violation scenario */\n  mhd_probe_log (\"NO_MESSAGES build: master pointer=%p\", (void *) MHD_get_master (connection->daemon));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Log failure of first attempt and info useful to reproduce scenario */\n    const size_t digest_size = digest_get_size (da);\n    mhd_probe_log (\"First calculate_add_nonce() failed: digest_size=%zu, hashing=%d\",\n                   digest_size, (int) da->hashing);\n\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n      mhd_probe_log (\"digest_ext_error() reported an extended error -> returning false\");\n      return false; /* No need to re-try */\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    /* Log master->nonce_nc_size to evidence the read-only nature of the access\n       that triggers the MISRA Rule 8.13 concern. */\n    {\n      struct MHD_Daemon *master_for_log = MHD_get_master (connection->daemon);\n      /* Record the pointer and the field we read */\n      mhd_probe_log (\"master pointer=%p, master->nonce_nc_size=%zu\",\n                     (void *) master_for_log,\n                     (size_t) master_for_log->nonce_nc_size);\n      if (0 == master_for_log->nonce_nc_size)\n      {\n        mhd_probe_log (\"master->nonce_nc_size == 0 -> returning false (no need to re-try)\");\n        return false; /* No need to re-try */\n      }\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    mhd_probe_log (\"timestamp1=%llu, timestamp2(initial)=%llu\",\n                   (unsigned long long) timestamp1,\n                   (unsigned long long) timestamp2);\n\n    if (timestamp1 == timestamp2)\n    {\n      mhd_probe_log (\"Timestamps equal; entering adjustment branch to derive timestamp2\");\n\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n      {\n        timestamp2 -= 2; /* Fallback value */\n        mhd_probe_log (\"timestamp adjustment fallback applied; new timestamp2=%llu\",\n                       (unsigned long long) timestamp2);\n      }\n      else\n      {\n        mhd_probe_log (\"timestamp adjusted to timestamp2=%llu (after base calculations)\",\n                       (unsigned long long) timestamp2);\n      }\n    }\n\n    digest_reset (da);\n    mhd_probe_log (\"Calling calculate_add_nonce() second time with timestamp2=%llu\",\n                   (unsigned long long) timestamp2);\n\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      mhd_probe_log (\"Second calculate_add_nonce() also failed -> returning false (use generated nonce)\");\n      return false;\n    }\n\n    mhd_probe_log (\"Second calculate_add_nonce() succeeded; copying nonce2 to nonce (digest_size=%zu)\",\n                   digest_size);\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n\n  mhd_probe_log (\"Exiting calculate_add_nonce_with_retry with result=true\");\n  return true;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c: In function 'calculate_add_nonce_with_retry':\ndigestauth.c:1843:41: error: 'struct DigestAlgorithm' has no member named 'hashing'\n 1843 |                    digest_size, (int) da->hashing);\n      |                                         ^~\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of calculate_add_nonce_with_retry as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/595.txt\", \"a\");\n  if (f == NULL)\n    return; /* Best-effort logging, don't change program behavior if logging fails */\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', f);\n  fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  /* 'hashing' is not a guaranteed member of struct DigestAlgorithm in all\n     versions; assert the pointer instead to preserve a similar level of\n     sanity checking without depending on a specific field. */\n  mhd_assert (da != NULL);\n\n  /* Log entry state */\n  mhd_probe_log (\"ENTER calculate_add_nonce_with_retry: connection=%p, daemon=%p, realm='%s', realm_len=%zu, timestamp1=%llu\",\n                 (void *) connection,\n                 (void *) connection->daemon,\n                 realm ? realm : \"(null)\",\n                 realm_len,\n                 (unsigned long long) timestamp1);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n  {\n    /* Log the condition where digest_auth_rand_size is zero */\n    mhd_probe_log (\"HAVE_MESSAGES: master()->digest_auth_rand_size == 0 (master=%p)\",\n                   (void *) MHD_get_master (connection->daemon));\n\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n  }\n#else\n  /* Still log presence/absence of master for tracing the violation scenario */\n  mhd_probe_log (\"NO_MESSAGES build: master pointer=%p\", (void *) MHD_get_master (connection->daemon));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Log failure of first attempt and info useful to reproduce scenario */\n    const size_t digest_size = digest_get_size (da);\n    /* DigestAlgorithm may not have a 'hashing' member in all builds; omit it\n       from the log to remain compatible. */\n    mhd_probe_log (\"First calculate_add_nonce() failed: digest_size=%zu\",\n                   digest_size);\n\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n      mhd_probe_log (\"digest_ext_error() reported an extended error -> returning false\");\n      return false; /* No need to re-try */\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    /* Log master->nonce_nc_size to evidence the read-only nature of the access\n       that triggers the MISRA Rule 8.13 concern. */\n    {\n      struct MHD_Daemon *master_for_log = MHD_get_master (connection->daemon);\n      /* Record the pointer and the field we read */\n      mhd_probe_log (\"master pointer=%p, master->nonce_nc_size=%zu\",\n                     (void *) master_for_log,\n                     (size_t) master_for_log->nonce_nc_size);\n      if (0 == master_for_log->nonce_nc_size)\n      {\n        mhd_probe_log (\"master->nonce_nc_size == 0 -> returning false (no need to re-try)\");\n        return false; /* No need to re-try */\n      }\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    mhd_probe_log (\"timestamp1=%llu, timestamp2(initial)=%llu\",\n                   (unsigned long long) timestamp1,\n                   (unsigned long long) timestamp2);\n\n    if (timestamp1 == timestamp2)\n    {\n      mhd_probe_log (\"Timestamps equal; entering adjustment branch to derive timestamp2\");\n\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n      {\n        timestamp2 -= 2; /* Fallback value */\n        mhd_probe_log (\"timestamp adjustment fallback applied; new timestamp2=%llu\",\n                       (unsigned long long) timestamp2);\n      }\n      else\n      {\n        mhd_probe_log (\"timestamp adjusted to timestamp2=%llu (after base calculations)\",\n                       (unsigned long long) timestamp2);\n      }\n    }\n\n    digest_reset (da);\n    mhd_probe_log (\"Calling calculate_add_nonce() second time with timestamp2=%llu\",\n                   (unsigned long long) timestamp2);\n\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      mhd_probe_log (\"Second calculate_add_nonce() also failed -> returning false (use generated nonce)\");\n      return false;\n    }\n\n    mhd_probe_log (\"Second calculate_add_nonce() succeeded; copying nonce2 to nonce (digest_size=%zu)\",\n                   digest_size);\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n\n  mhd_probe_log (\"Exiting calculate_add_nonce_with_retry with result=true\");\n  return true;\n}\n",
  "explanation": "The compilation failed because the code accessed da->hashing, but struct DigestAlgorithm does not guarantee a member named 'hashing'. To fix this without changing behavior, I removed direct accesses to da->hashing: replaced the assertion mhd_assert(! da->hashing) with mhd_assert(da != NULL) and removed the logging of the non-existent hashing field. These changes avoid referencing a missing struct member while keeping the original control flow and intent intact (sanity checking and logging of digest_size and retry behavior)."
}