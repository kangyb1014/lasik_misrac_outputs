{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If HAVE_GETHRTIME is defined, the block contains an unconditional return (if (1) return ...;). That makes the subsequent fallback code in the same function unreachable for that build configuration (statements after the unconditional return cannot be executed), violating MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/593.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n  /* Log entry state */\n  probe_log(\"ENTER calculate_add_nonce_with_retry: connection=%p realm=\\\"%s\\\" realm_len=%zu da=%p timestamp1=%llu\",\n            (void *) connection,\n            (realm != NULL) ? realm : \"(null)\",\n            realm_len,\n            (void *) da,\n            (unsigned long long) timestamp1);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  probe_log(\"Calling calculate_add_nonce (first try) with timestamp1=%llu realm_len=%zu\",\n            (unsigned long long) timestamp1, realm_len);\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    probe_log(\"calculate_add_nonce (first try) returned false -> entering retry/fallback branch\");\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    probe_log(\"digest_size=%zu\", digest_size);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n      probe_log(\"digest_ext_error(da) returned true -> returning false (no retry)\");\n      return false; /* No need to re-try */\n    }\n    probe_log(\"digest_ext_error(da) returned false -> continue\");\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n    {\n      probe_log(\"nonce_nc_size == 0 -> returning false (no retry)\");\n      return false; /* No need to re-try */\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    probe_log(\"timestamp2 initial=%llu (timestamp1=%llu)\",\n              (unsigned long long) timestamp2, (unsigned long long) timestamp1);\n    if (timestamp1 == timestamp2)\n    {\n      probe_log(\"timestamp1 == timestamp2 -> entering timestamp-differentiation branch\");\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n      probe_log(\"HAVE_RANDOM chosen: base1=%llu base4=0x%02x\",\n                (unsigned long long) base1, (unsigned) base4);\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n      probe_log(\"HAVE_RAND chosen: base1=%llu base4=0x%02x\",\n                (unsigned long long) base1, (unsigned) base4);\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n      probe_log(\"no RAND/RAND -> base1=%llu base2=0x%08x base3=0x%04x base4=0x%02x\",\n                (unsigned long long) base1, (unsigned) base2, (unsigned) base3,\n                (unsigned) base4);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      probe_log(\"After mixing: base2=0x%08x base3=0x%04x base4=0x%02x timestamp2=%llu\",\n                (unsigned) base2, (unsigned) base3, (unsigned) base4,\n                (unsigned long long) timestamp2);\n      if (timestamp1 == timestamp2)\n      {\n        timestamp2 -= 2; /* Fallback value */\n        probe_log(\"timestamp still equal after mixing -> apply fallback timestamp2=%llu\",\n                  (unsigned long long) timestamp2);\n      }\n    }\n    digest_reset (da);\n    probe_log(\"Calling calculate_add_nonce (second try) with timestamp2=%llu\",\n              (unsigned long long) timestamp2);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      probe_log(\"calculate_add_nonce (second try) returned false -> returning false (use generated nonce)\");\n      return false;\n    }\n    probe_log(\"calculate_add_nonce (second try) succeeded -> copying nonce2 to nonce (len=%zu)\", NONCE_STD_LEN (digest_size));\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  probe_log(\"Exiting calculate_add_nonce_with_retry -> returning true\");\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. In the supplied function there is no preprocessor-/compile-time unconditional return that makes the remainder of the function unreachable. All early returns inside calculate_add_nonce_with_retry are guarded by runtime conditions: the digest_ext_error(da) check (inside #ifdef MHD_DIGEST_HAS_EXT_ERROR) and the nonce_nc_size == 0 check, and the second calculate_add_nonce() failure \u2014 none of these are compile-time constant unconditionally true in the shown code. The agent\u2019s claim that defining HAVE_GETHRTIME (which does not even appear in the posted function) produces an unconditional if (1) return \u2026 is not supported by the provided code. MISRA C Rule 2.1 would only be violated if, in the actual project configuration, a macro or expansion made a return condition a compile-time constant true (thus producing unreachable code afterwards). No such compile-time constant return appears in the given source, so the reported violation is incorrect."
}