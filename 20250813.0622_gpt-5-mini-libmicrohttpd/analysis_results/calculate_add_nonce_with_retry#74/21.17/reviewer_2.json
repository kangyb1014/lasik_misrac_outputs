{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memcpy call copies NONCE_STD_LEN(digest_size) bytes into the destination pointer 'nonce' but the function has no parameter or internal check that proves the destination buffer is at least that large. While nonce2 is allocated as NONCE_STD_LEN(MAX_DIGEST)+1 (so the source is large enough), there is no guarantee the caller-provided 'nonce' buffer is >= NONCE_STD_LEN(digest_size). If the caller supplies a smaller buffer, memcpy will write past the end of 'nonce' (out-of-bounds).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n  /* Log entry state: timestamp, realm pointer, realm length, nonce pointer */\n  {\n    FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n    if (logf)\n    {\n      fprintf (logf, \"ENTER: calculate_add_nonce_with_retry: timestamp1=%llu realm=%p realm_len=%zu nonce=%p\\n\",\n               (unsigned long long) timestamp1,\n               (void *) realm,\n               realm_len,\n               (void *) nonce);\n      fclose (logf);\n    }\n  }\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Log that the first attempt failed and we are entering retry logic */\n    {\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"INFO: first calculate_add_nonce failed, entering retry block\\n\");\n        fclose (logf);\n      }\n    }\n\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"EXIT: digest_ext_error detected, aborting retry, returning false\\n\");\n        fclose (logf);\n      }\n      return false; /* No need to re-try */\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n    {\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"EXIT: nonce_nc_size == 0, no retry allowed, returning false\\n\");\n        fclose (logf);\n      }\n      return false; /* No need to re-try */\n    }\n\n    /* Log digest size and computed nonce lengths for both source and dest */\n    {\n      size_t dest_needed = NONCE_STD_LEN (digest_size);\n      size_t src_buf_size = (size_t) (NONCE_STD_LEN (MAX_DIGEST) + 1);\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"INFO: digest_size=%zu dest_needed=%zu src_buf_size=%zu nonce_dest_ptr=%p nonce2_buf_ptr=%p\\n\",\n                 digest_size,\n                 dest_needed,\n                 src_buf_size,\n                 (void *) nonce,\n                 (void *) nonce2);\n        fclose (logf);\n      }\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n\n      /* Log that we detected identical timestamps and adjusted timestamp2 */\n      {\n        FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n        if (logf)\n        {\n          fprintf (logf, \"INFO: timestamp1 == original timestamp2, adjusted timestamp2=%llu\\n\",\n                   (unsigned long long) timestamp2);\n          fclose (logf);\n        }\n      }\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"EXIT: second calculate_add_nonce failed, no free slot found, returning false\\n\");\n        fclose (logf);\n      }\n      return false;\n    }\n\n    /* Log the memcpy about to happen: source size, dest pointer, src pointer */\n    {\n      size_t copy_len = NONCE_STD_LEN (digest_size);\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"ACTION: About to memcpy copy_len=%zu from nonce2=%p to nonce=%p\\n\",\n                 copy_len,\n                 (void *) nonce2,\n                 (void *) nonce);\n        fclose (logf);\n      }\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n\n    /* Log completion of memcpy */\n    {\n      FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n      if (logf)\n      {\n        fprintf (logf, \"ACTION: memcpy completed, returning true (from retry path)\\n\");\n        fclose (logf);\n      }\n    }\n  }\n\n  /* Final success log */\n  {\n    FILE *logf = fopen(\"/tmp/logs/599.txt\", \"a\");\n    if (logf)\n    {\n      fprintf (logf, \"EXIT: calculate_add_nonce_with_retry returning true\\n\");\n      fclose (logf);\n    }\n  }\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The memcpy call copies NONCE_STD_LEN(digest_size) bytes into the caller-supplied pointer 'nonce' but the function signature provides no size parameter and there is no internal check that the destination buffer is large enough. While nonce2 is allocated large enough (NONCE_STD_LEN(MAX_DIGEST)+1) and the source length is derived from digest_size, nothing in this function guarantees that the caller-provided 'nonce' points to a buffer of at least NONCE_STD_LEN(digest_size) bytes. In the retry path the initial calculate_add_nonce failed (so the caller buffer may not have been validated by that call), and then memcpy could write past the end of 'nonce' if the caller supplied a smaller buffer. Absent an externally enforced API contract (a documented precondition or earlier validated allocation), this is a potential out-of-bounds access and therefore a violation of MISRA C 2023 Rule 21.17."
}