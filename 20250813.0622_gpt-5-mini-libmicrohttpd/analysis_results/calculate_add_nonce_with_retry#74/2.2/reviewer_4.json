{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When MHD_DIGEST_HAS_EXT_ERROR is defined but digest_ext_error(da) is implemented as a macro that always evaluates to false (as in the provided code: #define digest_ext_error(da) (false)), the conditional if (digest_ext_error(da)) is never true and the return false; statement can never be executed. That return is therefore dead code\u2014its removal would not affect program behaviour.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/594.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[pid %ld][%ld] \", (long) getpid (), (long) t);\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (da != NULL);\n\n  mhd_log_probe (\"Entered calculate_add_nonce_with_retry: connection=%p, daemon=%p, timestamp1=%\" PRIu64 \", realm_len=%zu, da=%p\",\n                 (void *) connection,\n                 (void *) connection->daemon,\n                 timestamp1,\n                 realm_len,\n                 (void *) da);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  mhd_log_probe (\"Calling calculate_add_nonce (first attempt) with timestamp1=%\" PRIu64, timestamp1);\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    mhd_log_probe (\"Initial calculate_add_nonce failed (no free slot or collision)\");\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    mhd_log_probe (\"digest_size=%zu\", digest_size);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    {\n      bool ext_err = digest_ext_error (da);\n      mhd_log_probe (\"digest_ext_error -> %d\", (int) ext_err);\n      if (ext_err)\n      {\n        mhd_log_probe (\"Returning false due to digest_ext_error -> no retry needed\");\n        return false; /* No need to re-try */\n      }\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    {\n      size_t nc_size = MHD_get_master (connection->daemon)->nonce_nc_size;\n      mhd_log_probe (\"nonce_nc_size=%zu\", nc_size);\n      if (0 == nc_size)\n      {\n        mhd_log_probe (\"Returning false because nonce_nc_size == 0 -> no retry needed\");\n        return false; /* No need to re-try */\n      }\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    mhd_log_probe (\"timestamp2 initial=%\" PRIu64, timestamp2);\n    if (timestamp1 == timestamp2)\n    {\n      mhd_log_probe (\"timestamp1 == timestamp2 -> entering jitter generation branch\");\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n      mhd_log_probe (\"HAVE_RANDOM branch used: base1 after random set to 0x%\" PRIx64 \", base4=0x%02x\", base1, base4);\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n      mhd_log_probe (\"HAVE_RAND branch used: base1 after rand set to 0x%\" PRIx64 \", base4=0x%02x\", base1, base4);\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n      mhd_log_probe (\"no-rand branch used: base1=0x%\" PRIx64 \", base2=0x%08x, base3=0x%04x, base4=0x%02x\",\n                     base1, base2, base3, base4);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      mhd_log_probe (\"After jitter adjustments: base1=0x%\" PRIx64 \", base2=0x%08x, base3=0x%04x, base4=0x%02x, timestamp2=%\" PRIu64,\n                     base1, base2, base3, base4, timestamp2);\n      if (timestamp1 == timestamp2)\n      {\n        timestamp2 -= 2; /* Fallback value */\n        mhd_log_probe (\"timestamp still equal after jitter -> fallback timestamp2=%\" PRIu64, timestamp2);\n      }\n    }\n    digest_reset (da);\n    mhd_log_probe (\"Calling calculate_add_nonce (second attempt) with timestamp2=%\" PRIu64, timestamp2);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      mhd_log_probe (\"Second calculate_add_nonce failed -> no free slot found, returning false (use generated nonce)\");\n      return false;\n    }\n    mhd_log_probe (\"Second calculate_add_nonce succeeded -> copying nonce2 into nonce and returning true\");\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  mhd_log_probe (\"Exiting calculate_add_nonce_with_retry -> returning true\");\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 2.2 forbids dead code at the project level. The single return false; inside the #ifdef MHD_DIGEST_HAS_EXT_ERROR block is only potentially dead if, in the whole project build configuration(s) where MHD_DIGEST_HAS_EXT_ERROR is defined, digest_ext_error(da) is guaranteed to be false (for example if it is defined as a compile-time constant macro that always expands to false). Agent A\u2019s scenario describes exactly that narrow condition (digest_ext_error(da) defined as (false)), in which case that return can never be executed and is dead code.\n\nHowever, whether a MISRA 2.2 violation actually exists depends on whole-project facts that are not present in the snippet: (a) whether MHD_DIGEST_HAS_EXT_ERROR is defined in the project configuration(s) in which this translation unit is built, and (b) the definitive project-wide definition of digest_ext_error. If digest_ext_error is a function or a macro whose value can be true at runtime (or differs across builds), or if MHD_DIGEST_HAS_EXT_ERROR is not defined in the project, the return is not dead. Because the report did not demonstrate that digest_ext_error is unconditionally false across the project builds, the claim cannot be confirmed from the provided information alone.\n\nRecommendation: search the project for the definition(s) of digest_ext_error and the build configurations that define MHD_DIGEST_HAS_EXT_ERROR. If digest_ext_error is indeed a compile-time constant false in all builds where the #ifdef is active, then the return is dead code and should be removed (or the guard/macro usage clarified). Otherwise there is no MISRA 2.2 violation."
}