{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In check_nonce_nc the code calls memcmp(nn->nonce, nonce, noncelen) where nn->nonce is asserted to have a terminating NUL at index noncelen (and the client-supplied nonce is also treated as a NUL-terminated string). Thus memcmp is being used to compare two null-terminated strings (of known length). This use violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_hex(FILE *f, const char *label, const char *buf, size_t len)\n{\n  size_t i;\n  fprintf(f, \"%s=\", label);\n  for (i = 0; i < len; ++i)\n    fprintf(f, \"%02x\", (unsigned char) buf[i]);\n  fprintf(f, \"\\n\");\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  FILE *logf = fopen(\"/tmp/logs/598.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTER calculate_add_nonce_with_retry\\n\");\n  }\n\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n  if (logf)\n  {\n    fprintf(logf, \"timestamp1=%\" PRIu64 \" realm_len=%zu\\n\", timestamp1, realm_len);\n    fprintf(logf, \"realm=\\\"\");\n    fprintf(logf, \"%.*s\", (int) realm_len, realm);\n    fprintf(logf, \"\\\"\\n\");\n    /* Log initial nonce buffer (may be uninitialised or will be filled by\n       the caller). Use a conservative maximum length to avoid overruns. */\n    probe_log_hex(logf, \"initial_nonce_prefix\",\n                  nonce, (size_t) NONCE_STD_LEN(MAX_DIGEST));\n  }\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    if (logf)\n      fprintf(logf, \"calculate_add_nonce(timestamp1) returned false\\n\");\n\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"digest_ext_error -> returning false\\n\");\n        fclose(logf);\n      }\n      return false; /* No need to re-try */\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n    {\n      if (logf)\n      {\n        fprintf(logf, \"nonce_nc_size == 0 -> no retry -> returning false\\n\");\n        fclose(logf);\n      }\n      return false; /* No need to re-try */\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (logf)\n      fprintf(logf, \"timestamp2(initial)=%\" PRIu64 \"\\n\", timestamp2);\n\n    if (timestamp1 == timestamp2)\n    {\n      if (logf)\n        fprintf(logf, \"timestamps equal, generating arbitrary difference\\n\");\n\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n\n      if (logf)\n        fprintf(logf, \"base1=0x%016\" PRIx64 \" base2=0x%08\" PRIx32 \" base3=0x%04\" PRIx16 \" base4=0x%02\" PRIx8 \" timestamp2(adjusted)=%\" PRIu64 \"\\n\",\n                base1, base2, base3, base4, timestamp2);\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      if (logf)\n      {\n        fprintf(logf, \"calculate_add_nonce(timestamp2) returned false -> returning false\\n\");\n        probe_log_hex(logf, \"nonce2_prefix_on_failure\", nonce2,\n                      (size_t) NONCE_STD_LEN(MAX_DIGEST));\n        fclose(logf);\n      }\n      return false;\n    }\n\n    if (logf)\n    {\n      fprintf(logf, \"calculate_add_nonce(timestamp2) succeeded\\n\");\n      probe_log_hex(logf, \"nonce2_prefix\", nonce2,\n                    (size_t) NONCE_STD_LEN (digest_size));\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n\n    if (logf)\n    {\n      probe_log_hex(logf, \"nonce_after_memcpy\",\n                    nonce, (size_t) NONCE_STD_LEN (digest_size));\n      fprintf(logf, \"exiting calculate_add_nonce_with_retry true\\n\");\n      fclose(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"calculate_add_nonce(timestamp1) succeeded -> returning true\\n\");\n      fclose(logf);\n    }\n  }\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is incorrect for the shown function. calculate_add_nonce_with_retry contains no call to memcmp (it uses memcpy, strlen, etc.). MISRA C 2023 Rule 21.14 forbids using memcmp to compare null-terminated strings, but since there is no memcmp use in the provided calculate_add_nonce_with_retry implementation, this function does not violate Rule 21.14. (If another function such as check_nonce_nc in the wider codebase does call memcmp to compare NUL\u2011terminated strings, that separate use would be the place to judge for a Rule 21.14 violation \u2014 not the function shown here.)"
}