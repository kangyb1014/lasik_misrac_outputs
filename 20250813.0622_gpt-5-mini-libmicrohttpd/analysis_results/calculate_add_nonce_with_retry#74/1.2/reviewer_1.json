{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The expression uses the macro _MHD_ROTL32 which expands to the compiler intrinsic __builtin_rotateleft32 (i.e. ((uint32_t)__builtin_rotateleft32((value32),(bits)))) \u2014 __builtin_rotateleft32 is a compiler-specific builtin (not standard C) and thus is a language extension. The fragment base2 = _MHD_ROTL32(base2, (((base4 >> 4) ^ base4) % 32)); therefore relies on that compiler extension, violating MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe(const char *event,\n              uint64_t timestamp1,\n              uint64_t timestamp2,\n              uint64_t base1,\n              uint32_t base2_before,\n              uint32_t base2_after,\n              uint16_t base3,\n              uint8_t base4,\n              const char *extra)\n{\n  FILE *fp = fopen(\"/tmp/logs/592.txt\", \"a\");\n  if (fp == NULL)\n    return;\n  fprintf(fp, \"%s: ts1=%llu ts2=%llu base1=0x%llx base2_before=0x%08x base2_after=0x%08x base3=0x%04x base4=0x%02x extra=%s\\n\",\n          event,\n          (unsigned long long) timestamp1,\n          (unsigned long long) timestamp2,\n          (unsigned long long) base1,\n          (unsigned int) base2_before,\n          (unsigned int) base2_after,\n          (unsigned int) base3,\n          (unsigned int) base4,\n          (extra != NULL) ? extra : \"\");\n  fclose(fp);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  /* Log entry into function with initial timestamp and realm length */\n  mhd_log_probe(\"enter\",\n                timestamp1,\n                0ULL,\n                0ULL,\n                0U,\n                0U,\n                0U,\n                0U,\n                \"realm_len\");\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n\n      /* Log state before performing the rotate-left (the macro under test) */\n      mhd_log_probe(\"before_rotl\",\n                    timestamp1,\n                    timestamp2,\n                    base1,\n                    base2,\n                    0U,\n                    0U,\n                    base4,\n                    \"about to call _MHD_ROTL32\");\n\n      /* Keep the value before and after rotate to capture evidence */\n      {\n        uint32_t base2_before = base2;\n        uint32_t base2_after;\n\n        base2_after = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n\n        /* Log the result of the rotation and surrounding state */\n        mhd_log_probe(\"after_rotl\",\n                      timestamp1,\n                      timestamp2,\n                      base1,\n                      base2_before,\n                      base2_after,\n                      0U,\n                      base4,\n                      \"_MHD_ROTL32 called\");\n\n        base2 = base2_after;\n      }\n\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n\n      /* Log timestamp adjustment */\n      mhd_log_probe(\"timestamp_adjust\",\n                    timestamp1,\n                    timestamp2,\n                    0ULL,\n                    0U,\n                    0U,\n                    base3,\n                    base4,\n                    \"adjusted timestamp2\");\n\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n\n      /* Log failure of second calculate_add_nonce attempt and the timestamp used */\n      mhd_log_probe(\"second_attempt_failed\",\n                    timestamp1,\n                    timestamp2,\n                    0ULL,\n                    0U,\n                    0U,\n                    0U,\n                    0U,\n                    \"no free slot found\");\n\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n\n  /* Log successful exit */\n  mhd_log_probe(\"exit\",\n                timestamp1,\n                0ULL,\n                0ULL,\n                0U,\n                0U,\n                0U,\n                0U,\n                \"returning true\");\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim cannot be confirmed from the snippet alone. The reported violation depends entirely on how the macro _MHD_ROTL32 is defined. MISRA C 2023 Rule 1.2 forbids using compiler language extensions; if _MHD_ROTL32 expands to a compiler-specific builtin such as __builtin_rotateleft32, that use would be a Rule 1.2 violation. However, the target code you provided only shows an invocation of _MHD_ROTL32 and does not include its definition. _MHD_ROTL32 might be implemented portably (for example by a standard C rotate idiom using shifts and masks) or it might be a thin wrapper around a compiler builtin; only the latter is a Rule 1.2 violation.\n\nTo determine correctness of agent A\u2019s report you should inspect the macro/inline definition of _MHD_ROTL32 (search the project headers). If it expands (directly or indirectly) to a compiler builtin documented as an extension (e.g. __builtin_rotateleft32) then the report is correct. If it is implemented in standard C (portable expression or an explicitly documented, non-extension mechanism) then the report is incorrect. The compiled test and added logging do not prove or disprove the presence of a builtin \u2014 they only show the function executes when compiled with your toolchain.\n\nConclusion: the report as stated is not provably correct given the provided code. It would be correct only if inspection of the macro shows it expands to a compiler-specific builtin; otherwise it is not a Rule 1.2 violation."
}