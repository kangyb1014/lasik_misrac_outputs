{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro uses the compiler-specific builtin __builtin_rotateright32: #define _MHD_ROTR32(value32, bits) ((uint32_t)__builtin_rotateright32((value32),(bits))). __builtin_rotateright32 is a compiler intrinsic (GCC/Clang extension), not standard ISO C, and is documented as an extension in compiler docs, so this violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/592.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic uint32_t\n_MHD_ROTR32 (uint32_t value, unsigned int bits)\n{\n  bits &= 31u;\n  return (value >> bits) | (value << ((32 - bits) & 31u));\n}\nstatic uint32_t\n_MHD_ROTL32 (uint32_t value, unsigned int bits)\n{\n  bits &= 31u;\n  return (value << bits) | (value >> ((32 - bits) & 31u));\n}\nstatic uint32_t\nprobe_rotr32 (uint32_t value, unsigned int bits, const char *ctx)\n{\n  mhd_probe_log (\"probe_rotr32 ENTER ctx=%s value=0x%08x bits=%u\",\n                 ctx ? ctx : \"(null)\", (unsigned) value, bits);\n  uint32_t res = _MHD_ROTR32 (value, bits);\n  mhd_probe_log (\"probe_rotr32 LEAVE ctx=%s result=0x%08x\", ctx ? ctx : \"(null)\", (unsigned) res);\n  return res;\n}\nstatic uint32_t\nprobe_rotl32 (uint32_t value, unsigned int bits, const char *ctx)\n{\n  mhd_probe_log (\"probe_rotl32 ENTER ctx=%s value=0x%08x bits=%u\",\n                 ctx ? ctx : \"(null)\", (unsigned) value, bits);\n  uint32_t res = _MHD_ROTL32 (value, bits);\n  mhd_probe_log (\"probe_rotl32 LEAVE ctx=%s result=0x%08x\", ctx ? ctx : \"(null)\", (unsigned) res);\n  return res;\n}\nstatic void\nmhd_assert (int expr)\n{\n  assert (expr);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n  /* Log entry state (include daemon as NULL because we don't have it here) */\n  mhd_probe_log (\n    \"ENTER calculate_add_nonce_with_retry conn=%p daemon=%p realm='%s' realm_len=%zu timestamp1=%\" PRIu64,\n    (void *) connection, (void *) NULL, realm, realm_len, timestamp1);\n\n  /* Construct a simple nonce: realm-timestamp-reallen */\n  if (nonce != NULL) {\n    /* assume caller provided enough space; this mirrors original code style */\n    snprintf (nonce, 256, \"%s-%\" PRIu64 \"-%zu\", realm, timestamp1, realm_len);\n  }\n\n  mhd_probe_log (\"LEAVE calculate_add_nonce_with_retry conn=%p nonce='%s'\", (void *) connection, nonce ? nonce : \"(null)\");\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the supplied code. Rule 1.2 is only violated if the source actually uses a compiler-documented language extension (for example a compiler builtin such as __builtin_rotateright32). The snippet you provided calls macros named _MHD_ROTR32 and _MHD_ROTL32, but it does not show their definitions. Agent A asserted that those macros expand to __builtin_rotateright32, but no definition or build evidence was supplied to prove that. Without the macro/header definition or a compiler diagnostic showing the builtin was used, there is no basis to report a MISRA 1.2 violation.\n\nIf in the actual codebase _MHD_ROTR32/_MHD_ROTL32 are indeed defined to use compiler-specific intrinsics (e.g. __builtin_rotateright32 or other documented compiler extensions), then the report would be correct and the usage would violate Rule 1.2. To settle this definitively, inspect the header where _MHD_ROTR32/_MHD_ROTL32 are defined or show the compiler-provided documentation or build output proving that a non\u2011standard builtin is used. The provided \"test_code\" replaces the macros with portable shift/rotate implementations (which are not compiler extensions) and thus does not demonstrate the asserted use of __builtin_rotateright32."
}