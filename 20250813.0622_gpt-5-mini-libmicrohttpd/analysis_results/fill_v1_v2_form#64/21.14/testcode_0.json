{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nIn the assertion mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); memcmp is used to compare hdr->value (a null-terminated header string) with the string literal \"close\". This is effectively comparing null-terminated strings using memcmp (even though only 5 bytes are compared), which violates MISRA C 2023 Rule 21.14. A string comparison function (e.g. strcmp/strncmp or the existing case-insensitive helpers) should be used instead.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified fill_v1_v2_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/518.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of fill_v1_v2_form as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of fill_v1_v2_form:\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified fill_v1_v2_form code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n\n/* Probe helpers to log control flow and state for reproducing the memcmp violation scenario.\n   These helpers write to /tmp/logs/518.txt and are safe (use strnlen to avoid overruns).\n*/\n\nstatic void log_append(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/518.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic void probe_session_state(const struct Session *session,\n                                const char *mime,\n                                size_t slen)\n{\n  if (session == NULL)\n  {\n    log_append(\"probe_session_state: session == NULL, mime=%s, slen=%zu\", mime ? mime : \"(null)\", slen);\n    return;\n  }\n\n  /* Use strnlen to avoid reading beyond intended bounds. Limit printed lengths. */\n  size_t v1_len = session->value_1 ? strnlen(session->value_1, 1024) : 0;\n  size_t v2_len = session->value_2 ? strnlen(session->value_2, 1024) : 0;\n\n  log_append(\"probe_session_state: session=%p, mime=%s, slen=%zu, value_1_len=%zu, value_2_len=%zu\",\n             (const void *) session,\n             mime ? mime : \"(null)\",\n             slen,\n             v1_len,\n             v2_len);\n\n  if (session->value_1)\n    log_append(\"probe_session_state: value_1=(%zu) '%.*s'\", v1_len, (int) v1_len, session->value_1);\n  else\n    log_append(\"probe_session_state: value_1=(null)\");\n\n  if (session->value_2)\n    log_append(\"probe_session_state: value_2=(%zu) '%.*s'\", v2_len, (int) v2_len, session->value_2);\n  else\n    log_append(\"probe_session_state: value_2=(null)\");\n}\n\n/* Probe that other agents can call to log memcmp-like comparisons. This does not perform memcmp;\n   it inspects whether the header value contains a NUL within the first n bytes, which is the\n   important aspect for detecting misuse of memcmp on NUL-terminated strings.\n*/\nstatic void probe_memcmp_usage(const char *hdr_value,\n                               const char *literal,\n                               size_t n,\n                               int cmp_result)\n{\n  if (hdr_value == NULL || literal == NULL)\n  {\n    log_append(\"probe_memcmp_usage: hdr_value=%p, literal=%p, n=%zu, cmp_result=%d\",\n               (const void *) hdr_value,\n               (const void *) literal,\n               n,\n               cmp_result);\n    return;\n  }\n\n  /* Check if hdr_value has a NUL within the first n bytes. This is what makes memcmp inappropriate\n     for comparing null-terminated strings. */\n  size_t hdr_nulen = strnlen(hdr_value, n + 1);\n  int has_nul_within_n = (hdr_nulen < n) ? 1 : 0;\n\n  /* Also measure literal NUL (should normally be present within n for string literal). */\n  size_t lit_nulen = strnlen(literal, n + 1);\n  int lit_has_nul_within_n = (lit_nulen < n) ? 1 : 0;\n\n  log_append(\"probe_memcmp_usage: hdr_value=%p, literal=%p, n=%zu, cmp_result=%d\",\n             (const void *) hdr_value,\n             (const void *) literal,\n             n,\n             cmp_result);\n  log_append(\"probe_memcmp_usage: hdr_first_%zu='%.*s'\", n, (int) (hdr_nulen > n ? n : hdr_nulen), hdr_value);\n  log_append(\"probe_memcmp_usage: hdr_has_nul_within_n=%d, hdr_nulen=%zu\", has_nul_within_n, hdr_nulen);\n  log_append(\"probe_memcmp_usage: literal_first_%zu='%.*s'\", n, (int) (lit_nulen > n ? n : lit_nulen), literal);\n  log_append(\"probe_memcmp_usage: literal_has_nul_within_n=%d, lit_nulen=%zu\", lit_has_nul_within_n, lit_nulen);\n\n  if (has_nul_within_n || lit_has_nul_within_n)\n  {\n    log_append(\"probe_memcmp_usage: WARNING: a NUL was detected within the first %zu bytes; using memcmp may be comparing NUL-terminated strings.\", n);\n  }\n}\n\n/* Modified fill_v1_v2_form: original logic preserved, with added probes to log key state and control flow. */\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Probe initial state */\n  /* Compute slen as original code does (before allocating reply) so we can log it). */\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_session_state(session, mime, slen);\n\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n  {\n    log_append(\"fill_v1_v2_form: malloc failed for size %zu\", slen + 1);\n    return MHD_NO;\n  }\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n\n  /* Log reply content up to a reasonable limit */\n  size_t reply_show = strnlen(reply, 4096);\n  log_append(\"fill_v1_v2_form: reply_len=%zu, reply_preview='%.*s'\", reply_show, (int) reply_show, reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    log_append(\"fill_v1_v2_form: MHD_create_response_from_buffer_with_free_callback returned NULL\");\n    return MHD_NO;\n  }\n\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    log_append(\"fill_v1_v2_form: Failed to set content encoding header: mime=%s\", mime ? mime : \"(null)\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  log_append(\"fill_v1_v2_form: queued response, ret=%d\", (int) ret);\n  MHD_destroy_response (response);\n  return ret;\n}\n"
}