{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function MHD_create_response_from_buffer_with_free_callback declares its buffer parameter as void *buffer even though it does not modify the pointed-to data \u2014 it merely forwards the pointer to MHD_create_response_from_buffer_with_free_callback_cls and stores it for sending/freeing. Per MISRA C 2023 Rule 8.13 the parameter should be declared const void *buffer (and only cast to void * when passing to an API that requires a non-const pointer), so the current non-const parameter type violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *fp = fopen(\"/tmp/logs/515.txt\", \"a\");\n  if (NULL == fp)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(fp, fmt, ap);\n  va_end(ap);\n  fputc('\\n', fp);\n  fclose(fp);\n}\nstatic void probe_log_buffer_preview(const void *buf, size_t len)\n{\n  const unsigned char *b = (const unsigned char *) buf;\n  size_t i;\n  size_t max_print = (len < 128u) ? len : 128u;\n  FILE *fp = fopen(\"/tmp/logs/515.txt\", \"a\");\n  if (NULL == fp)\n  {\n    return;\n  }\n  fprintf(fp, \"buffer=%p len=%zu preview=\\\"\", buf, len);\n  for (i = 0u; i < max_print; ++i)\n  {\n    unsigned char c = b[i];\n    if (c >= 0x20u && c < 0x7Fu)\n    {\n      fputc((int) c, fp);\n    }\n    else\n    {\n      fputs(\"\\\\x\", fp);\n      /* print two hex digits */\n      fprintf(fp, \"%02X\", (unsigned int) c);\n    }\n  }\n  if (len > max_print)\n  {\n    fputs(\"...\", fp);\n  }\n  fputs(\"\\\"\\n\", fp);\n  fclose(fp);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Log entry into the function with pointers we received. */\n  probe_log(\"fill_v1_v2_form: enter session=%p connection=%p mime=%p\", (void *) session, (void *) connection, (void *) mime);\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_log(\"Computed slen=%zu\", slen);\n\n  reply = malloc (slen + 1);\n  probe_log(\"malloc reply=%p (slen+1=%zu)\", (void *) reply, slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n\n  /* Log the contents (preview) of the reply buffer we constructed. */\n  probe_log_buffer_preview(reply, slen);\n\n  /* return static form */\n  probe_log(\"About to call MHD_create_response_from_buffer_with_free_callback with buffer (casted)=%p\", (void *) reply);\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    probe_log(\"MHD_create_response_from_buffer_with_free_callback returned NULL for reply=%p\", (void *) reply);\n    /* Ensure we log the free of reply on error path. */\n    free (reply);\n    probe_log(\"Freed reply=%p after failed response creation\", (void *) reply);\n    return MHD_NO;\n  }\n  probe_log(\"MHD_create_response_from_buffer_with_free_callback returned response=%p for reply=%p\", (void *) response, (void *) reply);\n\n  add_session_cookie (session, response);\n  probe_log(\"add_session_cookie called session=%p response=%p\", (void *) session, (void *) response);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    probe_log(\"MHD_add_response_header failed for response=%p mime=%p\", (void *) response, (void *) mime);\n  }\n  else\n  {\n    probe_log(\"MHD_add_response_header succeeded for response=%p mime=%p\", (void *) response, (void *) mime);\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log(\"MHD_queue_response returned %d for connection=%p response=%p\", (int) ret, (void *) connection, (void *) response);\n\n  MHD_destroy_response (response);\n  probe_log(\"MHD_destroy_response called for response=%p\", (void *) response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_v2_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 concerns how pointers are declared within the code under review: pointers should be const-qualified when the pointed-to object is not modified. In fill_v1_v2_form the function parameters that can and should be const are already const (cls and mime). The local buffer reply is mutable (allocated and written via snprintf), so it must be a non-const char * \u2014 there is no opportunity to qualify it const. The call to the external library function MHD_create_response_from_buffer_with_free_callback uses the library's API (which declares its parameter as void *). The fact that a third\u2011party API uses a non-const buffer parameter is an issue in that library's declaration (or design), not a direct MISRA violation in this function. Only if this function cast away constness (i.e. passed a const object to an API requiring non-const by casting) would fill_v1_v2_form risk violating Rule 8.13; no such cast-away-of-const occurs here (reply is non-const). Therefore Agent A's assertion that this function violates MISRA C 2023 Rule 8.13 is incorrect."
}