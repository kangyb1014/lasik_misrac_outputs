{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function assigns to the by-value parameter 'noncelen' (noncelen = strlen(nonce)) when noncelen == 0, thereby modifying a function parameter. This violates MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *event,\n           const char *const nonce,\n           size_t noncelen,\n           const uint64_t *const ptimestamp,\n           size_t conv_res)\n{\n  FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n  if (f != NULL)\n    {\n      /* Basic state */\n      fprintf (f, \"%s: nonce=%p noncelen=%zu ptimestamp=%p conv_res=%zu\\n\",\n               event,\n               (const void *) nonce,\n               noncelen,\n               (const void *) ptimestamp,\n               conv_res);\n\n      /* Also attempt to log the nonce string (if available) to help\n         reproducing the scenario. Keep this separate so failures to\n         print it don't affect the primary state log. */\n      if (nonce != NULL)\n        {\n          /* Limit the printed nonce length to avoid excessive logs. */\n          const size_t max_print = 256u;\n          char buf[257];\n          size_t n = strlen (nonce);\n          if (n > max_print)\n            n = max_print;\n          memcpy (buf, nonce, n);\n          buf[n] = '\\0';\n          fprintf (f, \"%s: nonce_str=\\\"%s\\\" (truncated=%zu)\\n\",\n                   event, buf, n);\n        }\n\n      fclose (f);\n    }\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  /* Log entry state. conv_res set to (size_t)-1 to indicate not-applicable. */\n  log_probe (\"entry\", nonce, noncelen, ptimestamp, (size_t) -1);\n\n  if (0 == noncelen)\n    {\n      /* Log before modifying the by-value parameter to capture the violation scenario. */\n      log_probe (\"pre_assign_noncelen_is_zero\", nonce, noncelen, ptimestamp, (size_t) -1);\n\n      noncelen = strlen (nonce);\n\n      /* Log after assignment so the trace shows the parameter modification. */\n      log_probe (\"post_assign_noncelen\", nonce, noncelen, ptimestamp, (size_t) -1);\n    }\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    {\n      log_probe (\"length_check_failed\", nonce, noncelen, ptimestamp, (size_t) -1);\n      return false;\n    }\n\n  /*\n   * Call the conversion once, store the result so we can log it and still\n   * preserve the original behavior.\n   */\n  size_t conv_res = MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                                           TIMESTAMP_CHARS_LEN,\n                                           ptimestamp);\n\n  /* Log the result of the conversion attempt. */\n  log_probe (\"after_timestamp_conversion\", nonce, noncelen, ptimestamp, conv_res);\n\n  if (TIMESTAMP_CHARS_LEN != conv_res)\n    {\n      log_probe (\"timestamp_conversion_failed\", nonce, noncelen, ptimestamp, conv_res);\n      return false;\n    }\n\n  log_probe (\"return_true\", nonce, noncelen, ptimestamp, conv_res);\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_nonce_timestamp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; that applies to by-value parameters as well as pointer parameters (with the note that the object pointed to may be modified but the pointer itself shall not). In the provided code the statement\n  noncelen = strlen (nonce);\nassigns to the by-value parameter noncelen, which is a direct violation of Rule 17.8. The fact that the test log was empty does not affect the semantic violation in the source.\n\nSuggested remediation: introduce a local variable and use that for any adjustments, e.g.:\n  size_t len = noncelen;\n  if (len == 0) len = strlen(nonce);\nand use len in subsequent checks and calls instead of modifying the parameter itself."
}