{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer parameter 'struct MHD_Connection *connection' is not const-qualified even though the function only reads from the pointed object (it only accesses connection->rq.headers_received and traverses headers). According to MISRA C 2023 Rule 8.13 this should be declared as 'const struct MHD_Connection *connection'. (Note: iterator_cls could also be made const if the iterator callback accepts a const context pointer, but that depends on the MHD_KeyValueIterator prototype.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/107.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  mhd_log_probe(\"MHD_get_connection_values: entry connection=%p kind=%d iterator=%p iterator_cls=%p\",\n                (void *)connection, (int)kind, (void *)iterator, iterator_cls);\n\n  if (NULL == connection)\n  {\n    mhd_log_probe(\"MHD_get_connection_values: connection is NULL -> returning -1\");\n    return -1;\n  }\n  ret = 0;\n  mhd_log_probe(\"MHD_get_connection_values: begin headers traversal, first_header=%p\", (void *)connection->rq.headers_received);\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    const char *h = (pos->header != NULL) ? pos->header : \"(null)\";\n    const char *v = (pos->value != NULL) ? pos->value : \"(null)\";\n    mhd_log_probe(\"MHD_get_connection_values: visiting header node %p kind=%d header=%s value=%s\",\n                  (void *)pos, (int)pos->kind, h, v);\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      mhd_log_probe(\"MHD_get_connection_values: header matched kind mask -> incremented ret=%d\", ret);\n      if (NULL != iterator)\n      {\n        mhd_log_probe(\"MHD_get_connection_values: calling iterator %p with iterator_cls=%p kind=%d header=%s value=%s\",\n                      (void *)iterator, iterator_cls, (int)pos->kind, h, v);\n        int rc = iterator (iterator_cls,\n                           pos->kind,\n                           pos->header,\n                           pos->value);\n        mhd_log_probe(\"MHD_get_connection_values: iterator returned %d\", rc);\n        if (MHD_NO == rc)\n        {\n          mhd_log_probe(\"MHD_get_connection_values: iterator requested stop -> returning ret=%d\", ret);\n          return ret;\n        }\n      }\n    }\n  }\n  mhd_log_probe(\"MHD_get_connection_values: end traversal -> returning ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_get_connection_values. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s observation is essentially correct. The function does not modify the object pointed to by the parameter connection: it only reads connection->rq.headers_received and traverses header nodes. MISRA C:2023 Rule 8.13 (\u201cA pointer should point to a const-qualified type whenever possible\u201d) therefore indicates that the parameter should be declared const struct MHD_Connection *connection. The same caveat the agent noted applies to iterator_cls: whether it can be const depends on the MHD_KeyValueIterator prototype. Also note that Rule 8.13 is a \u201cshould\u201d (advisory) requirement: a deviation may be justified for API compatibility or other design constraints (this function is externally visible via _MHD_EXTERN), but as written the code does not satisfy the guidance of 8.13. The provided logging test and empty log do not change this analysis."
}