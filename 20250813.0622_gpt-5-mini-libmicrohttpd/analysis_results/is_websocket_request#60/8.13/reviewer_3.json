{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'con' is declared as a non-const pointer (struct MHD_Connection *con) but it is unused (cast to void) and not modified. Per MISRA C 2023 Rule 8.13 it should be const-qualified (const struct MHD_Connection *con) whenever possible. Thus this fragment violates the rule unless the function signature must match an external (non-const) callback prototype, in which case the non-const declaration is required by the API.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void is_websocket_request_log(const char *stage,\n                                    struct MHD_Connection *con,\n                                    const char *upg_header,\n                                    const char *con_header,\n                                    int upg_present,\n                                    int con_present,\n                                    int upg_match,\n                                    void *strstr_ptr,\n                                    enum MHD_Result decision)\n{\n    FILE *f = fopen(\"/tmp/logs/483.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Best-effort logging only. */\n    }\n\n    fprintf(f, \"[%s] is_websocket_request enter\\n\", stage);\n    fprintf(f, \"  con (non-const as declared) = %p\\n\", (void *)con);\n\n    if (upg_header != NULL)\n    {\n        fprintf(f, \"  upg_header = %p (\\\"%s\\\")\\n\", (const void *)upg_header, upg_header);\n    }\n    else\n    {\n        fprintf(f, \"  upg_header = NULL\\n\");\n    }\n\n    if (con_header != NULL)\n    {\n        fprintf(f, \"  con_header = %p (\\\"%s\\\")\\n\", (const void *)con_header, con_header);\n    }\n    else\n    {\n        fprintf(f, \"  con_header = NULL\\n\");\n    }\n\n    fprintf(f, \"  checks: upg_present=%d, con_present=%d, upg_match=%d, strstr_ptr=%p\\n\",\n            upg_present, con_present, upg_match, strstr_ptr);\n\n    fprintf(f, \"  decision = %s\\n\", (decision == MHD_YES) ? \"MHD_YES\" : \"MHD_NO\");\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n    /* Note: the original code cast away 'con' to avoid an unused parameter\n       warning. To provide evidence for the violation scenario we now log the\n       pointer value (still using the non-const pointer as originally\n       declared) rather than casting it away. The logic of the function is\n       preserved. */\n\n    int upg_present = (upg_header != NULL) ? 1 : 0;\n    int con_present = (con_header != NULL) ? 1 : 0;\n\n    int upg_match = 0;\n    if (upg_present)\n    {\n        upg_match = (0 == strcmp (upg_header, WS_UPGRADE_VALUE)) ? 1 : 0;\n    }\n\n    void *strstr_ptr = NULL;\n    if (con_present)\n    {\n        strstr_ptr = (void *)strstr (con_header, \"Upgrade\");\n    }\n\n    enum MHD_Result result = ((upg_present != 0) && (con_present != 0)\n                              && (upg_match != 0)\n                              && (strstr_ptr != NULL))\n                             ? MHD_YES\n                             : MHD_NO;\n\n    /* Log the control path and state so other agents can reproduce the\n       scenario and see that 'con' was declared non-const and not modified. */\n    is_websocket_request_log(\"probe\", con, upg_header, con_header,\n                             upg_present, con_present, upg_match,\n                             strstr_ptr, result);\n\n    return result;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for is_websocket_request. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct in substance. In the shown code the parameter con is declared as a non\u2011const pointer (struct MHD_Connection *con), is unused (cast to void) and is never modified inside the function, therefore it could be declared as pointing to a const-qualified type (const struct MHD_Connection *con). MISRA C:2023 R8.13 recommends that pointers point to const-qualified types whenever possible, so this is a potential violation.\n\nHowever, whether this is an actual violation in the project depends on context: if this function must match an external API or callback prototype that requires a non-const pointer type, then the non-const declaration is required and the code is an acceptable exception. Casting the parameter to void to suppress an \"unused\" warning does not address the const-qualification concern. If the signature is not constrained by an external prototype, the correct fix is to change the parameter to const struct MHD_Connection *con; if it is constrained, document the rationale and suppress/justify the deviation for MISRA tooling.\n\n(The test logging code provided does not change the MISRA analysis \u2014 it only demonstrates the parameter is not used/modified; it does not remove the need to consider API compatibility.)"
}