{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "WS_UPGRADE_VALUE",
    "struct MHD_Connection",
    "strcmp",
    "strstr",
    "NULL",
    "<string.h>",
    "<stddef.h>"
  ],
  "explanation": "To determine whether is_websocket_request uses any compiler language extensions you must inspect each externally defined symbol or macro used by the function to ensure they are defined in standard C (not via compiler extensions such as statement-expressions, typeof, __attribute__ in non-standard ways, GCC extensions, or non-standard builtins). For each symbol:\n\n- enum MHD_Result: the return type may be declared using non-standard extensions (e.g. anonymous enums, compiler-specific attributes, or macros wrapping its declaration). Verify its definition is plain ISO C.\n- MHD_YES / MHD_NO: these enumerators or macros may be defined via non-standard constructs (macros that expand to GCC extensions, or uses of attributes). Inspect their actual definitions.\n- WS_UPGRADE_VALUE: this macro/constant supplies the string compared by strcmp and could be defined using non-standard constructs (e.g. statement-expressions, typeof, or other extensions). Check its definition.\n- struct MHD_Connection: the parameter type could be an alias or involve non-standard extensions (anonymous structs/unions, implementation-specific attributes). Confirm its declaration is standard C.\n- strcmp / strstr: these are standard library functions declared in <string.h>, but they could have been #defined or wrapped by project headers to use non-standard intrinsics or extensions. Inspect the actual declarations/defines to ensure they come from standard headers or plain prototypes.\n- NULL: the macro may be defined in a non-standard way (e.g. as ((void*)0) is allowed in C but some projects use compiler-specific tokens). Verify the definition in the included headers.\n- <string.h> and <stddef.h>: include the headers that normally declare strcmp/strstr and NULL/size_t etc. Checking these headers (or the project headers that replace them) is necessary to ensure no language extensions are introduced via macro redefinitions or non-standard declarations.\n\nConcentrating on these symbols lets the next analyst check whether any of them are implemented using compiler-specific extensions; if they are all standard C declarations/macros, the function itself uses only standard language constructs."
}