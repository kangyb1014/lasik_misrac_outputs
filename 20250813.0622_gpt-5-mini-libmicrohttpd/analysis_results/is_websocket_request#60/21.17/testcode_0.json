{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 con_header is obtained via MHD_lookup_connection_value (which does not provide a length) but the underlying storage in pos->value may be stored with an explicit length (pos->value_size) rather than guaranteed NUL termination. Calling strstr(con_header, \"Upgrade\") requires a NUL-terminated C string; if pos->value is not NUL-terminated this will read past the object bounds and cause undefined behaviour. Therefore the use of strstr here can violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified is_websocket_request code that contains useful probe functions that print useful logs to a file \"/tmp/logs/487.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of is_websocket_request as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of is_websocket_request:\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\nPlease provide the modified is_websocket_request code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <time.h>\n\n/* Probe helper: append a single-line log entry describing the inputs and\n   intermediate results. Writes to /tmp/logs/487.txt. This helper strives not\n   to read any pointed-to strings (so it won't introduce extra out-of-bounds\n   accesses) \u2014 it only prints pointer values and the results of the original\n   comparisons (which are executed by the caller to preserve original logic).\n*/\nstatic void\nis_ws_probe_log(const char *label, const char *upg_header, const char *con_header,\n                int upg_cmp_result, const char *strstr_result)\n{\n  /* Best-effort create log directory; ignore errors if it already exists. */\n  (void)mkdir(\"/tmp/logs\", 0777);\n\n  FILE *f = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (!f)\n    return; /* If logging isn't available, keep original behavior silently. */\n\n  time_t t = time(NULL);\n  /* Log: timestamp, label, pointer values, NULL flags, comparison results. */\n  fprintf(f, \"%ld: %s: upg_header=%p con_header=%p upg_header_is_null=%d con_header_is_null=%d upg_cmp_result=%d strstr_result=%p\\n\",\n          (long)t,\n          label,\n          (void *)upg_header,\n          (void *)con_header,\n          (int)(upg_header == NULL),\n          (int)(con_header == NULL),\n          upg_cmp_result,\n          (void *)strstr_result);\n\n  fclose(f);\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  /* Preserve original logic: only call strcmp and strstr when their inputs\n     are non-NULL. Capture their results so we can log them without changing\n     control flow. */\n  int upg_cmp = 1; /* non-zero means not equal (default) */\n  const char *strstr_res = NULL;\n\n  if (upg_header != NULL)\n    {\n      /* original comparison: 0 == strcmp(upg_header, WS_UPGRADE_VALUE) */\n      upg_cmp = strcmp (upg_header, WS_UPGRADE_VALUE);\n    }\n\n  if (con_header != NULL)\n    {\n      /* original check: NULL != strstr(con_header, \"Upgrade\") */\n      strstr_res = strstr (con_header, \"Upgrade\");\n    }\n\n  /* Log the control path and state so other agents can reproduce the\n     violation scenario. We log pointer addresses and results but we do not\n     read or print the pointed-to string contents (to avoid adding further\n     potentially out-of-bounds reads). */\n  is_ws_probe_log(\"is_websocket_request_check\", upg_header, con_header, upg_cmp, strstr_res);\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == upg_cmp)\n          && (NULL != strstr_res))\n         ? MHD_YES\n         : MHD_NO;\n}\n"
}