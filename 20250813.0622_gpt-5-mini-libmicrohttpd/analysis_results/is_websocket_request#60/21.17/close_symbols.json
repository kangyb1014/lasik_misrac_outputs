{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "strcmp",
    "strstr",
    "WS_UPGRADE_VALUE",
    "MHD_lookup_connection_value",
    "MHD_lookup_connection_value_n",
    "ahc_cb",
    "struct MHD_Connection"
  ],
  "explanation": "strcmp: Must know its semantics (reads both input C-strings until '\\0'). To prove no out-of-bounds read, the analyzer needs the contract that any pointer passed to strcmp is NUL-terminated and points to a valid buffer.\n\nstrstr: Same as above \u2014 it scans the haystack until a '\\0' is found. The analyzer must know that con_header (the haystack) is a valid NUL-terminated string so strstr cannot read past its buffer.\n\nWS_UPGRADE_VALUE: The string literal/constant compared against upg_header via strcmp. The analyzer must know its value/type and that it is a proper NUL-terminated string (so strcmp's access to it is safe).\n\nMHD_lookup_connection_value: This function is the likely producer of upg_header/con_header in the caller (ahc_cb). The analyzer needs its prototype and behavioral contract (return value semantics: whether it returns NULL or a pointer to a NUL-terminated, null-terminated buffer, ownership/lifetime guarantees) to decide whether strcmp/strstr use is safe.\n\nMHD_lookup_connection_value_n: Similarly, if ahc_cb uses this variant to obtain header strings, its prototype and guarantees about returned buffer termination and lifetime are required to determine whether strstr/strcmp can read beyond bounds.\n\nahc_cb: The caller that supplies upg_header and con_header to is_websocket_request. The analyzer must inspect ahc_cb to see how these pointers are obtained and whether any transformations/truncations are done (e.g., partial buffers, non-NUL-terminated slices) before passing them \u2014 this is essential to trace whether the pointers passed to strcmp/strstr can be non-terminated or point to short buffers.\n\nstruct MHD_Connection: To fully understand how headers are retrieved/stored (via MHD_lookup_connection_value APIs) and their lifetimes, the analyzer may need the connection structure/type definition and any relevant storage details (where header values live, whether they are copies, pointers into request buffer, etc.)."
}