{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strcmp(upg_header, WS_UPGRADE_VALUE) may read past the end of the object pointed to by upg_header if upg_header is not NUL-terminated. upg_header is obtained via MHD_lookup_connection_value which hands back pos->value (with an associated pos->value_size). The implementation does not guarantee the returned value is NUL-terminated, so strcmp can scan beyond pos->value_size until it finds a NUL, causing an out\u2011of\u2011bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_ws_probe(const char *upg_header, const char *con_header, int strcmp_performed, int strcmp_result, int strstr_performed, int strstr_found)\n{\n  FILE *f = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (!f) {\n    /* Try to create the directory and reopen. If that fails, give up silently. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n    f = fopen(\"/tmp/logs/487.txt\", \"a\");\n    if (!f) {\n      return;\n    }\n  }\n\n  fprintf(f, \"is_websocket_request called\\n\");\n  fprintf(f, \"  upg_header ptr=%p, is_null=%d\\n\", (const void *)upg_header, (int)(upg_header == NULL));\n  fprintf(f, \"  con_header ptr=%p, is_null=%d\\n\", (const void *)con_header, (int)(con_header == NULL));\n\n  if (strcmp_performed) {\n    fprintf(f, \"  strcmp performed, result=%d\\n\", strcmp_result);\n  } else {\n    fprintf(f, \"  strcmp not performed\\n\");\n  }\n\n  if (strstr_performed) {\n    fprintf(f, \"  strstr performed, found=%d\\n\", strstr_found);\n  } else {\n    fprintf(f, \"  strstr not performed\\n\");\n  }\n\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  int strcmp_performed = 0;\n  int strcmp_result = 1; /* non-zero by default (not equal) */\n  int strstr_performed = 0;\n  int strstr_found = 0;\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  /* Preserve original logic but split it up to allow logging of control flow and\n     the result of strcmp and strstr. Note: we do not attempt to read or print\n     the contents of upg_header or con_header to avoid introducing additional\n     out-of-bounds accesses; only their pointer values and whether they are NULL\n     are logged. The strcmp and strstr calls are performed exactly as in the\n     original code. */\n  if ((upg_header != NULL) && (con_header != NULL)) {\n    strcmp_performed = 1;\n    strcmp_result = strcmp (upg_header, WS_UPGRADE_VALUE);\n\n    strstr_performed = 1;\n    strstr_found = (NULL != strstr (con_header, \"Upgrade\"));\n\n    log_ws_probe(upg_header, con_header, strcmp_performed, strcmp_result, strstr_performed, strstr_found);\n\n    return ((0 == strcmp_result) && strstr_found) ? MHD_YES : MHD_NO;\n  }\n  else {\n    /* Log that strcmp and strstr were not performed because one of the headers is NULL */\n    log_ws_probe(upg_header, con_header, 0, 0, 0, 0);\n    return MHD_NO;\n  }\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for is_websocket_request. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code only checks that upg_header and con_header are non-NULL but does not ensure they are NUL-terminated or bounded. Both strcmp(upg_header, WS_UPGRADE_VALUE) and strstr(con_header, \"Upgrade\") read until a terminating NUL and therefore can access memory beyond the referenced objects if those buffers are not NUL-terminated. MISRA C 2023 Rule 21.17 forbids uses of the <string.h> functions that may access out-of-bounds memory. Unless the API that supplies upg_header/con_header formally guarantees NUL-termination, this use violates the rule. (If the supplier does guarantee termination, the call would be acceptable; in the absence of that guarantee the report is valid.) Suggested fixes: use length-aware checks (e.g. compare with memcmp given the known value_size, or copy to a local buffer and NUL-terminate within bounds, or use functions that take explicit lengths and ensure bounds.)"
}