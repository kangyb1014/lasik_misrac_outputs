{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "strcmp",
    "strstr",
    "memcmp",
    "WS_UPGRADE_VALUE",
    "preprocessor macro table (source/header files)",
    "<string.h> / C library declarations",
    "C library implementations of strcmp/strstr/memcmp"
  ],
  "explanation": "- strcmp: The function calls strcmp. To determine compliance you must know whether this identifier is a normal library function or has been aliased/implemented via memcmp (e.g. macro or wrapper). If strcmp is implemented as or mapped to memcmp, that could implicate the MISRA rule.\n- strstr: The function calls strstr. Some library implementations of substring/search functions may use memcmp internally; inspect strstr to ensure it does not compare null\u2011terminated strings via memcmp in a way that affects this call.\n- memcmp: The MISRA rule specifically forbids using memcmp to compare null\u2011terminated strings. You need the memcmp symbol (declaration/implementation) to check whether any of the called functions or macros ultimately call memcmp on null\u2011terminated data.\n- WS_UPGRADE_VALUE: This symbol is the right\u2011hand operand of strcmp. You must know its definition/type (string literal, char array, pointer to non\u2011terminated data, etc.) to determine whether comparisons here involve null\u2011terminated strings (which is the scope of the MISRA rule).\n- preprocessor macro table (source/header files): Any #define or macro that rebinds strcmp/strstr/memcmp (or replaces them with inline code) must be checked \u2014 a macro could map strcmp to memcmp or to an inline memcmp call.\n- <string.h> / C library declarations: The header declarations and any compiler builtin mappings are needed to detect inline/builtin/trampoline behavior (e.g. compiler optimizing strcmp to memcmp) or attributes that change behavior.\n- C library implementations of strcmp/strstr/memcmp: If compliance requires that calls inside library code are also considered, you must inspect the actual implementations used at build/link time to see whether they use memcmp on null\u2011terminated strings.\n\nCollecting these symbols/definitions will let the next analyst determine whether this function (or the functions it relies on) result in memcmp being used to compare null\u2011terminated strings, which is what the MISRA rule prohibits."
}