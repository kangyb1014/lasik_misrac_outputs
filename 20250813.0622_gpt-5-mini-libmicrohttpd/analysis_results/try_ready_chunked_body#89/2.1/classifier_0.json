{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of try_ready_chunked_body:\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_chunked_body:\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer (size_t size,\n                                 void *buffer,\n                                 enum MHD_ResponseMemoryMode mode)\n{\n  if (MHD_RESPMEM_MUST_FREE == mode)\n    return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                   buffer,\n                                                                   &free,\n                                                                   buffer);\n  if (MHD_RESPMEM_MUST_COPY == mode)\n    return MHD_create_response_from_buffer_copy (size,\n                                                 buffer);\n\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_callback (uint64_t size,\n                                   size_t block_size,\n                                   MHD_ContentReaderCallback crc,\n                                   void *crc_cls,\n                                   MHD_ContentReaderFreeCallback crfc)\n{\n  struct MHD_Response *response;\n\n  if ((NULL == crc) || (0 == block_size))\n    return NULL;\n  if (NULL == (response = MHD_calloc_ (1, sizeof (struct MHD_Response)\n                                       + block_size)))\n    return NULL;\n  response->fd = -1;\n  response->data = (void *) &response[1];\n  response->data_buffer_size = block_size;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n#endif\n  response->crc = crc;\n  response->crfc = crfc;\n  response->crc_cls = crc_cls;\n  response->reference_count = 1;\n  response->total_size = size;\n  return response;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  if ((NULL == iov) && (0 < iovcnt))\n    return NULL;\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n    return NULL;\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    if (0 == iov[i].iov_len)\n      continue;     /* skip zero-sized elements */\n    if (NULL == iov[i].iov_base)\n    {\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      if (0 == element_size)\n        continue;         /* skip zero-sized elements */\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n  }\n  return response;\n}\n...\nstatic void\nconnection_switch_from_recv_to_send (struct MHD_Connection *connection)\n{\n  /* Read buffer is not needed for this request, shrink it.*/\n  connection_shrink_read_buffer (connection);\n}\n...\nstatic void\nconnection_reset (struct MHD_Connection *connection,\n                  bool reuse)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Daemon *const d = connection->daemon;\n\n  if (! reuse)\n  {\n    /* Next function will destroy response, notify client,\n     * destroy memory pool, and set connection state to \"CLOSED\" */\n    MHD_connection_close_ (c,\n                           c->stop_with_error ?\n                           MHD_REQUEST_TERMINATED_WITH_ERROR :\n                           MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    c->read_buffer = NULL;\n    c->read_buffer_size = 0;\n    c->read_buffer_offset = 0;\n    c->write_buffer = NULL;\n    c->write_buffer_size = 0;\n    c->write_buffer_send_offset = 0;\n    c->write_buffer_append_offset = 0;\n  }\n  else\n  {\n    /* Reset connection to process the next request */\n    size_t new_read_buf_size;\n    mhd_assert (! c->stop_with_error);\n    mhd_assert (! c->discard_request);\n\n    if ( (NULL != d->notify_completed) &&\n         (c->rq.client_aware) )\n      d->notify_completed (d->notify_completed_cls,\n                           c,\n                           &c->rq.client_context,\n                           MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    c->rq.client_aware = false;\n\n    if (NULL != c->rp.response)\n      MHD_destroy_response (c->rp.response);\n    c->rp.response = NULL;\n\n    c->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n    c->state = MHD_CONNECTION_INIT;\n    c->event_loop_info =\n      (0 == c->read_buffer_offset) ?\n      MHD_EVENT_LOOP_INFO_READ : MHD_EVENT_LOOP_INFO_PROCESS;\n\n    memset (&c->rq, 0, sizeof(c->rq));\n\n    /* iov (if any) will be deallocated by MHD_pool_reset */\n    memset (&c->rp, 0, sizeof(c->rp));\n\n    c->write_buffer = NULL;\n    c->write_buffer_size = 0;\n    c->write_buffer_send_offset = 0;\n    c->write_buffer_append_offset = 0;\n    c->continue_message_write_offset = 0;\n\n    /* Reset the read buffer to the starting size,\n       preserving the bytes we have already read. */\n    new_read_buf_size = c->daemon->pool_size / 2;\n    if (c->read_buffer_offset > new_read_buf_size)\n      new_read_buf_size = c->read_buffer_offset;\n\n    c->read_buffer\n      = MHD_pool_reset (c->pool,\n                        c->read_buffer,\n                        c->read_buffer_offset,\n                        new_read_buf_size);\n    c->read_buffer_size = new_read_buf_size;\n  }\n  c->rq.client_context = NULL;\n}\n...\n#define MHD_SIZE_UNKNOWN UINT64_MAX\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nelse\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The branch is reachable when a response has no content-reader callback (response->crc == NULL) but the in-memory data window check fails \u2014 for example a response created with MHD_create_response_from_iovec that has multiple iov elements (response->data is not used, data_iov is filled, crc == NULL). In that case connection->rp.rsp_write_position will not lie inside response->data_start..data_start+data_size, the else branch is taken and the NULL == response->crc clause runs. The developer comment \u201cThere is no way to reach this code\u201d is therefore incorrect; the code is reachable."
}