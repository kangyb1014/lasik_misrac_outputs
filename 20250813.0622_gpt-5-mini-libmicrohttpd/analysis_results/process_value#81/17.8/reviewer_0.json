{
  "user_message": "An agent A claimed that the following process_value code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of process_value.\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignment 'value_end = last_escape;' modifies the pointer parameter 'value_end'. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the pointer itself must not be changed; the object it points to may be modified). Although modifying pp->xbuf and pp->xbuf_pos (objects pointed to by pp) is allowed, changing the pointer parameter value_end is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/653.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\nstatic void\nprobe_log_entry(const char *phase,\n                struct MHD_PostProcessor *pp,\n                const char *value_start,\n                const char *value_end,\n                const char *last_escape,\n                size_t xoff)\n{\n  probe_log(\"[%s] pp=%p xbuf_pos=%zu value_offset=%zu must_ikvi=%d\",\n            phase,\n            (void *) pp,\n            pp->xbuf_pos,\n            pp->value_offset,\n            (int) pp->must_ikvi);\n  probe_log(\"[%s] value_start=%p value_end=%p last_escape=%p xoff=%zu\",\n            phase,\n            (void *) value_start,\n            (void *) value_end,\n            (void *) last_escape,\n            xoff);\n}\nstatic void\nprobe_log_iteration(size_t iter,\n                    struct MHD_PostProcessor *pp,\n                    const char *value_start,\n                    const char *value_end,\n                    size_t xoff,\n                    size_t delta,\n                    int cut,\n                    size_t clen)\n{\n  probe_log(\"[iter %zu] pp=%p value_start=%p value_end=%p xoff=%zu delta=%zu cut=%d clen=%zu\",\n            iter,\n            (void *) pp,\n            (void *) value_start,\n            (void *) value_end,\n            xoff,\n            delta,\n            cut,\n            clen);\n}\nstatic void\nprobe_log_unescape_before(const char *buf, size_t xoff)\n{\n  probe_log(\"[unescape before] buf=%p xoff=%zu contents=\\\"%.*s\\\"\",\n            (void *) buf,\n            xoff,\n            (int) (xoff > 80 ? 80 : xoff),\n            buf);\n}\nstatic void\nprobe_log_unescape_after(size_t new_xoff)\n{\n  probe_log(\"[unescape after] new_xoff=%zu\", new_xoff);\n}\nstatic void\nprobe_log_ikvi_call(struct MHD_PostProcessor *pp,\n                     const char *key,\n                     size_t value_offset,\n                     size_t xoff)\n{\n  probe_log(\"[ikvi call] pp=%p key=%p value_offset=%zu xoff=%zu\",\n            (void *) pp,\n            (const void *) key,\n            value_offset,\n            xoff);\n}\nstatic void\nprobe_log_error(struct MHD_PostProcessor *pp)\n{\n  probe_log(\"[error] pp=%p state will be set to PP_Error\", (void *) pp);\n}\n\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n  size_t iter = 0;\n\n  probe_log_entry(\"entry\", pp, value_start, value_end, last_escape, 0);\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  probe_log_entry(\"after_initial_move\", pp, value_start, value_end, last_escape, xoff);\n\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    probe_log(\"[pre-assignment] condition true: value_end=%p last_escape=%p diff=%zu\",\n              (void *) value_end,\n              (void *) last_escape,\n              (size_t) (value_end - last_escape));\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    probe_log(\"[before memcpy to pp->xbuf] pp->xbuf_pos=%zu\",\n              pp->xbuf_pos);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    probe_log(\"[memcpy done] copied %zu bytes from last_escape=%p into pp->xbuf\",\n              (size_t) (value_end - last_escape),\n              (void *) last_escape);\n    /* Violation point: pointer parameter 'value_end' is modified here. Log before/after */\n    probe_log(\"[about to modify param] value_end (old)=%p last_escape=%p\",\n              (void *) value_end,\n              (void *) last_escape);\n    value_end = last_escape; /* This is the assignment reported as a Rule 17.8 violation */\n    probe_log(\"[after modify param] value_end (new)=%p\",\n              (void *) value_end);\n  }\n  else\n  {\n    probe_log(\"[pre-assignment] condition false: last_escape=%p or diff too large\",\n              (void *) last_escape);\n  }\n\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    probe_log_iteration(iter++, pp, value_start, value_end, xoff, delta, (int) cut, clen);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      probe_log(\"[memcpy into xbuf] from=%p bytes=%zu into xbuf+%zu\",\n                (void *) value_start,\n                delta,\n                xoff);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n        probe_log(\"[escape at end] single '%' cut=%d pp->xbuf_pos=%zu\",\n                  (int) cut,\n                  pp->xbuf_pos);\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n        probe_log(\"[escape at end] single '%' not cut delta=%zu clen=%zu\",\n                  delta,\n                  clen);\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n        probe_log(\"[escape at end] '%%' followed by one char cut=%d pp->xbuf_pos=%zu\",\n                  (int) cut,\n                  pp->xbuf_pos);\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n        probe_log(\"[escape at end] '%%' followed by one char not cut delta=%zu clen=%zu\",\n                  delta,\n                  clen);\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      probe_log_unescape_before(xbuf, xoff);\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n      probe_log_unescape_after(xoff);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      probe_log_ikvi_call(pp, (const char *) &pp[1], pp->value_offset, xoff);\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        probe_log_error(pp);\n        return;\n      }\n      probe_log(\"[ikvi returned success] updated pp->value_offset from %zu to %zu\",\n                pp->value_offset,\n                pp->value_offset + xoff);\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n      probe_log(\"[restore escape] moved %zu bytes to beginning of xbuf, new xoff=%zu\",\n                clen,\n                clen);\n    }\n    xoff = clen;\n  }\n\n  probe_log_entry(\"exit\", pp, value_start, value_end, last_escape, xoff);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[entry] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[entry] value_start=0x55fe8d5d3057 value_end=0x55fe8d5d305b last_escape=(nil) xoff=0\n[after_initial_move] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[after_initial_move] value_start=0x55fe8d5d3057 value_end=0x55fe8d5d305b last_escape=(nil) xoff=0\n[pre-assignment] condition false: last_escape=(nil) or diff too large\n[iter 0] pp=0x55fea8fc22a0 value_start=0x55fe8d5d3057 value_end=0x55fe8d5d305b xoff=0 delta=4 cut=0 clen=0\n[memcpy into xbuf] from=0x55fe8d5d3057 bytes=4 into xbuf+0\n[unescape before] buf=0x7ffddf273090 xoff=4 contents=\"xxxx\"\n[unescape after] new_xoff=4\n[ikvi call] pp=0x55fea8fc22a0 key=0x55fea8fc2340 value_offset=0 xoff=4\n[ikvi returned success] updated pp->value_offset from 0 to 4\n[exit] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=4 must_ikvi=0\n[exit] value_start=0x55fe8d5d305b value_end=0x55fe8d5d305b last_escape=(nil) xoff=0\n[entry] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[entry] value_start=0x55fe8d5d3062 value_end=0x55fe8d5d3066 last_escape=(nil) xoff=0\n[after_initial_move] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[after_initial_move] value_start=0x55fe8d5d3062 value_end=0x55fe8d5d3066 last_escape=(nil) xoff=0\n[pre-assignment] condition false: last_escape=(nil) or diff too large\n[iter 0] pp=0x55fea8fc22a0 value_start=0x55fe8d5d3062 value_end=0x55fe8d5d3066 xoff=0 delta=4 cut=0 clen=0\n[memcpy into xbuf] from=0x55fe8d5d3062 bytes=4 into xbuf+0\n[unescape before] buf=0x7ffddf273090 xoff=4 contents=\"yyyy\"\n[unescape after] new_xoff=4\n[ikvi call] pp=0x55fea8fc22a0 key=0x55fea8fc2340 value_offset=0 xoff=4\n[ikvi returned success] updated pp->value_offset from 0 to 4\n[exit] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=4 must_ikvi=0\n[exit] value_start=0x55fe8d5d3066 value_end=0x55fe8d5d3066 last_escape=(nil) xoff=0\n[entry] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[entry] value_start=0x55fe8d5d306c value_end=0x55fe8d5d306c last_escape=(nil) xoff=0\n[after_initial_move] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[after_initial_move] value_start=0x55fe8d5d306c value_end=0x55fe8d5d306c last_escape=(nil) xoff=0\n[pre-assignment] condition false: last_escape=(nil) or diff too large\n[iter 0] pp=0x55fea8fc22a0 value_start=0x55fe8d5d306c value_end=0x55fe8d5d306c xoff=0 delta=0 cut=0 clen=0\n[ikvi call] pp=0x55fea8fc22a0 key=0x55fea8fc2340 value_offset=0 xoff=0\n[ikvi returned success] updated pp->value_offset from 0 to 0\n[exit] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=0\n[exit] value_start=0x55fe8d5d306c value_end=0x55fe8d5d306c last_escape=(nil) xoff=0\n[entry] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[entry] value_start=0x55fe8d5d9644 value_end=0x55fe8d5d9644 last_escape=(nil) xoff=0\n[after_initial_move] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[after_initial_move] value_start=0x55fe8d5d9644 value_end=0x55fe8d5d9644 last_escape=(nil) xoff=0\n[pre-assignment] condition false: last_escape=(nil) or diff too large\n[iter 0] pp=0x55fea8fc22a0 value_start=0x55fe8d5d9644 value_end=0x55fe8d5d9644 xoff=0 delta=0 cut=0 clen=0\n[ikvi call] pp=0x55fea8fc22a0 key=0x55fea8fc2340 value_offset=0 xoff=0\n[ikvi returned success] updated pp->value_offset from 0 to 0\n[exit] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=0\n[exit] value_start=0x55fe8d5d9644 value_end=0x55fe8d5d9644 last_escape=(nil) xoff=0\n[entry] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[entry] value_start=0x55fe8d5d3078 value_end=0x55fe8d5d307e last_escape=0x55fe8d5d307c xoff=0\n[after_initial_move] pp=0x55fea8fc22a0 xbuf_pos=0 value_offset=0 must_ikvi=1\n[after_initial_move] value_start=0x55fe8d5d3078 value_end=0x55fe8d5d307e last_escape=0x55fe8d5d307c xoff=0\n[pre-assignment] condition false: last_escape=0x55fe8d5d307c or diff too large\n[iter 0] pp=0x55fea8fc22a0 value_start=0x55fe8d5d3078 value_end=0x55fe8d5d307e xoff=0 delta=6 cut=0 clen=0\n[memcpy into xbuf] from=0x55fe8d5d3078 bytes=6 into xbuf+0\n[escape at end] '%' followed by one char cut=1 pp->xbuf_pos=2\n[unescape before] buf=0x7ffddf273\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters themselves; while it permits modifying the object pointed to by a pointer parameter, it does not permit assigning a new value to the pointer parameter variable. The statement value_end = last_escape; changes the pointer parameter value_end (not the object it points to), so it violates Rule 17.8. Note: the parameter is declared as const char *value_end; the const applies to the pointee, not to the pointer, so the assignment is valid C but still disallowed by MISRA. A compliant fix is to copy the parameter into a local variable (e.g. const char *local_end = value_end;) and modify that local variable instead."
}