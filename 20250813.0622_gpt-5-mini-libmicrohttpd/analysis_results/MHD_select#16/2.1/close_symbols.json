{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon::shutdown",
    "struct MHD_Daemon::options",
    "struct MHD_Daemon::itc",
    "struct MHD_Daemon::listen_fd",
    "struct MHD_Daemon::was_quiesced",
    "struct MHD_Daemon::connections",
    "struct MHD_Daemon::connection_limit",
    "struct MHD_Daemon::at_limit",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "resume_suspended_connections",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "internal_get_fdset2",
    "MHD_add_to_fd_set_",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_INVALID_SOCKET",
    "FD_SETSIZE",
    "MHD_get_timeout64",
    "TIMEVAL_TV_SEC_MAX",
    "SIZEOF_UINT64_T",
    "SIZEOF_STRUCT_TIMEVAL_TV_SEC",
    "_MHD_TIMEVAL_TV_SEC_TYPE",
    "MHD_SYS_select_",
    "struct timeval (tv_sec/tv_usec)",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "internal_run_from_select",
    "MHD_NO",
    "MHD_YES",
    "MHD_DLOG"
  ],
  "explanation": "For a sound unreachable-code (MISRA) analysis of MHD_select you must know every symbol that can alter its control flow or that itself may introduce unreachable code. Brief reasons: \n\n- struct MHD_Daemon::shutdown: first statement returns if set \u2014 affects reachability of entire function body.\n- struct MHD_Daemon::options: used with MHD_TEST_ALLOW_SUSPEND_RESUME to conditionally call resume_suspended_connections; controls that branch.\n- MHD_TEST_ALLOW_SUSPEND_RESUME: flag mask used in the compound condition that may cause an early side-effect (calling resume_suspended_connections) \u2014 needed to decide if that call is reachable.\n- resume_suspended_connections: called in a conditional; its return value and internal behavior (call graph shows it may call __builtin_unreachable) can affect whether later code is reachable or triggers unreachable-code constructs.\n- MHD_D_IS_USING_THREAD_PER_CONN_: used multiple times to choose two very different code paths \u2014 required to see which path(s) are actually reachable.\n- internal_get_fdset2: called in single-threaded path; its return influences err_state and subsequent branches \u2014 needed to reason about code after the call and whether branches are taken.\n- MHD_add_to_fd_set_: called to add fds; its return affects err_state and branch outcomes in the per-thread path.\n- MHD_ITC_IS_VALID_: test whether to touch inter-thread control channel \u2014 controls whether related code is reachable.\n- MHD_itc_r_fd_: provides fd used in MHD_add_to_fd_set_ \u2014 needed to analyze whether MHD_add_to_fd_set_ is invoked with valid values (and thus whether the call sequence is reachable).\n- struct MHD_Daemon::itc: the presence/validity of the itc field controls the itc-added branch reachability.\n- struct MHD_Daemon::listen_fd: used to decide whether to add listen socket \u2014 affects reachability of accept/listen-related branches.\n- MHD_INVALID_SOCKET: sentinel compared against listen_fd \u2014 required to know whether listen branch can be taken.\n- struct MHD_Daemon::was_quiesced: combined with listen_fd to gate listen-socket branch reachability.\n- struct MHD_Daemon::connections, struct MHD_Daemon::connection_limit, struct MHD_Daemon::at_limit: used to decide whether to add the listen socket under connection-limit optimization \u2014 influence reachability of listen-accept code.\n- FD_SETSIZE: passed to internal_get_fdset2 and MHD_add_to_fd_set_ \u2014 may affect whether those helpers succeed or behave in a way that changes control flow.\n- MHD_get_timeout64: called to determine timeout selection; its return (success/value) controls whether timeout-related branches (tv NULL vs set) are reachable.\n- TIMEVAL_TV_SEC_MAX, SIZEOF_UINT64_T, SIZEOF_STRUCT_TIMEVAL_TV_SEC, _MHD_TIMEVAL_TV_SEC_TYPE: macros/types used in timeout arithmetic and conditional compilation \u2014 necessary to determine which assignments/branches are active and whether some assignments are effectively unreachable.\n- struct timeval (tv_sec/tv_usec): the type whose fields are written/read; understanding range/overflow behaviour is needed to determine whether certain assignments/branches are meaningful or unreachable.\n- MHD_SYS_select_: kernel/select wrapper whose return value drives error/normal-handling branches \u2014 needed to see which post-select branches are reachable.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: used when select fails; errno-checking logic decides whether function returns MHD_YES or MHD_NO \u2014 required to know whether error-handling branches are reachable.\n- internal_run_from_select: called after a successful select; its return value controls the final early return \u2014 needed to determine reachability of code after that call.\n- MHD_NO and MHD_YES: the enum result values used throughout for comparisons and returns \u2014 essential to understand which return statements are equivalent/possible and whether code after a return is unreachable.\n- MHD_DLOG: logging macro/function used in several branches (guarded by HAVE_MESSAGES) \u2014 while logging itself does not typically change control flow, its presence may mask or contain calls that could affect reachability (and it is present in the call graph), so include it to be sure no hidden control-flow/exit is introduced.\n\nIn short: include all daemon fields, the compile-time flags/macros and the called functions (and the relevant select/errno wrappers and timeout-related macros/types). With those symbols an analyzer can determine which conditionals can be true/false and whether any statements in MHD_select can never be reached (including the effect of called functions that may themselves contain unreachable-code constructs)."
}