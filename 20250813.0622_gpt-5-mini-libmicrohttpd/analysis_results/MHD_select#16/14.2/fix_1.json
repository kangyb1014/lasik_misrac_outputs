{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nMHD_probe_log (const char *stage,\n               struct MHD_Daemon *daemon,\n               int32_t millisec,\n               int err_state,\n               MHD_socket maxsock,\n               struct timeval *tv,\n               struct timeval timeout,\n               int num_ready,\n               MHD_socket ls,\n               bool itc_added)\n{\n  FILE *f = fopen(\"/tmp/logs/132.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"--- MHD_select probe: %s\\n\", stage);\n  fprintf (f, \"  daemon=%p\\n\", (void *) daemon);\n  fprintf (f, \"  millisec=%\" PRId32 \"\\n\", millisec);\n  fprintf (f, \"  err_state=%d\\n\", err_state);\n  fprintf (f, \"  maxsock=%lld\\n\", (long long) maxsock);\n  fprintf (f, \"  tv=%p\\n\", (void *) tv);\n  fprintf (f, \"  timeout.tv_sec=%ld, timeout.tv_usec=%ld\\n\",\n           (long) timeout.tv_sec, (long) timeout.tv_usec);\n  fprintf (f, \"  num_ready=%d\\n\", num_ready);\n  fprintf (f, \"  listen_fd=%lld\\n\", (long long) ls);\n  fprintf (f, \"  itc_added=%d\\n\", itc_added ? 1 : 0);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Log entry state */\n  MHD_probe_log (\"entry\", daemon, millisec, -1, (MHD_socket) -1, timeout, &timeout, -1, (MHD_socket) -1, false);\n\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n      /* log failure to get fdset */\n      MHD_probe_log (\"internal_get_fdset2_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, false);\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n        MHD_probe_log (\"itc_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, itc_added);\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n          MHD_probe_log (\"listen_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n        else\n        {\n          /* Log successful addition of listen fd */\n          MHD_probe_log (\"listen_add_succeeded\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n      }\n    }\n    else\n    {\n      /* Log that either listen fd invalid or quiesced */\n      MHD_probe_log (\"listen_skipped_or_quiesced\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n\n  /* Log state immediately before select */\n  MHD_probe_log (\"before_select\", daemon, millisec, err_state, maxsock, tv, timeout, -1, ls, false);\n\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n\n  /* Log result of select */\n  MHD_probe_log (\"after_select\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    /* Log select error */\n    MHD_probe_log (\"select_failed\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n\n  /* Log exit state (no ready descriptors processed) */\n  MHD_probe_log (\"exit_no_ready\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n  return MHD_NO;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndaemon.c: In function 'MHD_select':\ndaemon.c:4853:66: error: incompatible type for argument 6 of 'MHD_probe_log'\n 4853 |   MHD_probe_log (\"entry\", daemon, millisec, -1, (MHD_socket) -1, timeout, &timeout, -1, (MHD_socket) -1, false);\n      |                                                                  ^~~~~~~\n      |                                                                  |\n      |                                                                  struct timeval\ndaemon.c:4809:32: note: expected 'struct timeval *' but argument is of type 'struct timeval'\n 4809 |                struct timeval *tv,\n      |                ~~~~~~~~~~~~~~~~^~\ndaemon.c:4853:75: error: incompatible type for argument 7 of 'MHD_probe_log'\n 4853 |   MHD_probe_log (\"entry\", daemon, millisec, -1, (MHD_socket) -1, timeout, &timeout, -1, (MHD_socket) -1, false);\n      |                                                                           ^~~~~~~~\n      |                                                                           |\n      |                                                                           struct timeval *\ndaemon.c:4810:31: note: expected 'struct timeval' but argument is of type 'struct timeval *'\n 4810 |                struct timeval timeout,\n      |                ~~~~~~~~~~~~~~~^~~~~~~\nmake[3]: *** [Makefile:2112: libmicrohttpd_la-daemon.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_select as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void\nMHD_probe_log (const char *stage,\n               struct MHD_Daemon *daemon,\n               int32_t millisec,\n               int err_state,\n               MHD_socket maxsock,\n               struct timeval *tv,\n               struct timeval timeout,\n               int num_ready,\n               MHD_socket ls,\n               bool itc_added)\n{\n  FILE *f = fopen(\"/tmp/logs/132.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"--- MHD_select probe: %s\\n\", stage);\n  fprintf (f, \"  daemon=%p\\n\", (void *) daemon);\n  fprintf (f, \"  millisec=%\" PRId32 \"\\n\", millisec);\n  fprintf (f, \"  err_state=%d\\n\", err_state);\n  fprintf (f, \"  maxsock=%lld\\n\", (long long) maxsock);\n  fprintf (f, \"  tv=%p\\n\", (void *) tv);\n  fprintf (f, \"  timeout.tv_sec=%ld, timeout.tv_usec=%ld\\n\",\n           (long) timeout.tv_sec, (long) timeout.tv_usec);\n  fprintf (f, \"  num_ready=%d\\n\", num_ready);\n  fprintf (f, \"  listen_fd=%lld\\n\", (long long) ls);\n  fprintf (f, \"  itc_added=%d\\n\", itc_added ? 1 : 0);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Log entry state */\n  /* NOTE: swapped the two timeval arguments to match the prototype: */\n  /* argument 6 is struct timeval *tv, argument 7 is struct timeval timeout */\n  MHD_probe_log (\"entry\", daemon, millisec, -1, (MHD_socket) -1, &timeout, timeout, -1, (MHD_socket) -1, false);\n\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n      /* log failure to get fdset */\n      MHD_probe_log (\"internal_get_fdset2_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, false);\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n        MHD_probe_log (\"itc_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, itc_added);\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n          MHD_probe_log (\"listen_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n        else\n        {\n          /* Log successful addition of listen fd */\n          MHD_probe_log (\"listen_add_succeeded\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n      }\n    }\n    else\n    {\n      /* Log that either listen fd invalid or quiesced */\n      MHD_probe_log (\"listen_skipped_or_quiesced\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n\n  /* Log state immediately before select */\n  MHD_probe_log (\"before_select\", daemon, millisec, err_state, maxsock, tv, timeout, -1, ls, false);\n\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n\n  /* Log result of select */\n  MHD_probe_log (\"after_select\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    /* Log select error */\n    MHD_probe_log (\"select_failed\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n\n  /* Log exit state (no ready descriptors processed) */\n  MHD_probe_log (\"exit_no_ready\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n  return MHD_NO;\n}\n",
  "explanation": "The initial call to MHD_probe_log passed the timeval arguments in the wrong order (a struct timeval where a pointer was expected and vice versa). I swapped those two arguments in the \"entry\" log call to pass &timeout as the struct timeval * (6th parameter) and timeout as the struct timeval (7th parameter). No other logic was changed."
}