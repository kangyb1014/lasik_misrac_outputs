{
  "user_message": "An agent A claimed that the following MHD_select code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. .\n</misra_rule>\n<target_code>\nHere is the original code of MHD_select.\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The for loop declares urh as the loop counter (first clause: urh = daemon->urh_tail) and uses NULL != urh as the condition (second clause). However the iteration expression is urh = urhn, and urhn is assigned inside the loop body (urhn = urh->prev;). Clause 3 of MISRA C 2023 Rule 14.2 requires the third clause not to use objects that are modified in the loop body, so this use of urhn (which is modified in the body) violates Rule 14.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nMHD_probe_log (const char *stage,\n               struct MHD_Daemon *daemon,\n               int32_t millisec,\n               int err_state,\n               MHD_socket maxsock,\n               struct timeval *tv,\n               struct timeval timeout,\n               int num_ready,\n               MHD_socket ls,\n               bool itc_added)\n{\n  FILE *f = fopen(\"/tmp/logs/132.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"--- MHD_select probe: %s\\n\", stage);\n  fprintf (f, \"  daemon=%p\\n\", (void *) daemon);\n  fprintf (f, \"  millisec=%\" PRId32 \"\\n\", millisec);\n  fprintf (f, \"  err_state=%d\\n\", err_state);\n  fprintf (f, \"  maxsock=%lld\\n\", (long long) maxsock);\n  fprintf (f, \"  tv=%p\\n\", (void *) tv);\n  fprintf (f, \"  timeout.tv_sec=%ld, timeout.tv_usec=%ld\\n\",\n           (long) timeout.tv_sec, (long) timeout.tv_usec);\n  fprintf (f, \"  num_ready=%d\\n\", num_ready);\n  fprintf (f, \"  listen_fd=%lld\\n\", (long long) ls);\n  fprintf (f, \"  itc_added=%d\\n\", itc_added ? 1 : 0);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  /* Log entry state */\n  /* NOTE: swapped the two timeval arguments to match the prototype: */\n  /* argument 6 is struct timeval *tv, argument 7 is struct timeval timeout */\n  MHD_probe_log (\"entry\", daemon, millisec, -1, (MHD_socket) -1, &timeout, timeout, -1, (MHD_socket) -1, false);\n\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n      /* log failure to get fdset */\n      MHD_probe_log (\"internal_get_fdset2_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, false);\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n        MHD_probe_log (\"itc_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, (MHD_socket) -1, itc_added);\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n          MHD_probe_log (\"listen_add_failed\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n        else\n        {\n          /* Log successful addition of listen fd */\n          MHD_probe_log (\"listen_add_succeeded\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n        }\n      }\n    }\n    else\n    {\n      /* Log that either listen fd invalid or quiesced */\n      MHD_probe_log (\"listen_skipped_or_quiesced\", daemon, millisec, err_state, maxsock, &timeout, timeout, -1, ls, itc_added);\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n\n  /* Log state immediately before select */\n  MHD_probe_log (\"before_select\", daemon, millisec, err_state, maxsock, tv, timeout, -1, ls, false);\n\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n\n  /* Log result of select */\n  MHD_probe_log (\"after_select\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    /* Log select error */\n    MHD_probe_log (\"select_failed\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n\n  /* Log exit state (no ready descriptors processed) */\n  MHD_probe_log (\"exit_no_ready\", daemon, millisec, err_state, maxsock, tv, timeout, num_ready, ls, false);\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=0\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: entry\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=-1\n  maxsock=-1\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=-1\n  itc_added=0\n\n--- MHD_select probe: before_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  timeout.tv_sec=0, timeout.tv_usec=0\n  num_ready=-1\n  listen_fd=0\n  itc_added=0\n\n--- MHD_select probe: after_select\n  daemon=0x564d7dbe5860\n  millisec=0\n  err_state=0\n  maxsock=3\n  tv=0x7ffc11079aa0\n  tim\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The MHD_select implementation shown (including the instrumented test version) contains no for loop at all and does not declare or use variables named urh or urhn; therefore MISRA C:2023 Rule 14.2 (which applies to the three clauses of a for statement) cannot be violated in this function as presented. The test output and probe logs only show calls and state before/after select; they do not demonstrate any for-loop behavior or the described loop-counter/iteration-expression interaction. If a for loop with urh/urhn exists elsewhere, that code was not provided, so no violation can be established from the given code and logs."
}