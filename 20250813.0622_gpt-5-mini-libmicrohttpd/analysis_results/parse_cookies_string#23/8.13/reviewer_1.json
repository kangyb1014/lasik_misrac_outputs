{
  "user_message": "An agent A claimed that the following parse_cookies_string code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookies_string.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'value' is declared as 'const char *value' but is assigned to the struct member 'pos->value' which is a non-const pointer (pos->value = value). This drops the const qualifier from the pointer target (and likewise pos->header = key does the same), thereby discarding const qualification. According to MISRA C 2023 Rule 8.13 the pointer target should be const-qualified where possible \u2014 the struct members should be 'const char *' to avoid losing constness.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_call(const char *event,\n                           const char *name,\n                           size_t name_len,\n                           const char *value,\n                           size_t value_len,\n                           size_t i,\n                           size_t str_len,\n                           bool non_strict)\n{\n  FILE *f = fopen(\"/tmp/logs/187.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf(f, \"EVENT=%s i=%zu str_len=%zu non_strict=%d name_len=%zu value_len=%zu\\n\",\n          event, i, str_len, non_strict ? 1 : 0, name_len, value_len);\n  if (name != NULL && name_len > 0)\n  {\n    /* Print name (may contain non-printables); limit output to name_len) */\n    fprintf(f, \"  name=(%zu) '%.*s'\\n\", name_len, (int)name_len, name);\n  }\n  if (value != NULL)\n  {\n    fprintf(f, \"  value=(%zu) '%.*s'\\n\", value_len, (int)value_len, value);\n  }\n  fclose(f);\n}\nstatic void probe_log_event(const char *event, size_t i, size_t str_len, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/187.txt\", \"a\");\n  if (f == NULL)\n    return;\n  if (extra)\n    fprintf(f, \"EVENT=%s i=%zu str_len=%zu extra=%s\\n\", event, i, str_len, extra);\n  else\n    fprintf(f, \"EVENT=%s i=%zu str_len=%zu\\n\", event, i, str_len);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  /* Log entry into function */\n  probe_log_event(\"parse_cookies_string_entry\", 0, str_len, NULL);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n      {\n        probe_log_event(\"malformed_allow_wsp_empty\", i, str_len, \"whitespace_or_semicolon_not_allowed\");\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n      if (i == str_len)\n      {\n        probe_log_event(\"end_after_skip\", i, str_len, NULL);\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n      }\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if ((('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n           (';' == l) || (0 == l)))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n      {\n        probe_log_event(\"malformed_wsp_around_eq\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n    {\n      probe_log_event(\"malformed_incomplete_name\", i, str_len, NULL);\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    }\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n      {\n        probe_log_event(\"malformed_wsp_around_eq2\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if (('\\'' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n          {\n            probe_log_event(\"malformed_wsp_in_quoted\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n        {\n          probe_log_event(\"malformed_no_closing_quote\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        }\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n          {\n            probe_log_event(\"malformed_trailing_whitespace\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n      {\n        probe_log_event(\"malformed_garbage_at_end\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n      }\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n\n      /* Probe log before calling MHD_set_connection_value_n_nocheck_ for non-empty value */\n      probe_log_call(\"set_connection_value_non_empty\",\n                     str + name_start,\n                     name_len,\n                     str + value_start,\n                     value_len,\n                     i,\n                     str_len,\n                     non_strict);\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n      {\n        probe_log_event(\"set_connection_value_no_memory\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n    else\n    {\n      /* Probe log before calling MHD_set_connection_value_n_nocheck_ for empty value */\n      probe_log_call(\"set_connection_value_empty\",\n                     str + name_start,\n                     name_len,\n                     \"\",\n                     0,\n                     i,\n                     str_len,\n                     non_strict);\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n      {\n        probe_log_event(\"set_connection_value_no_memory_empty\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n        {\n          probe_log_event(\"malformed_no_next_cookie_after_semicolon\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n        {\n          probe_log_event(\"malformed_no_space_after_semicolon\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n          {\n            probe_log_event(\"malformed_trailing_space_after_semicolon\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n    }\n  }\n\n  probe_log_event(\"parse_cookies_string_exit\", i, str_len, NULL);\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for parse_cookies_string. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported scenario is not supported by the provided parse_cookies_string code. The agent claims a const char *value parameter is assigned into a non-const struct member (pos->value = value), dropping const qualification. In the shown function there is no const-qualified local pointer parameter named value; the function takes a mutable char *str and passes expressions like str + name_start and str + value_start (type char *) into MHD_set_connection_value_n_nocheck_. Those are non-const pointers, so no const qualifier is being discarded here. Also the function intentionally writes into str (zero-terminates name/value), so it cannot use const for str. The only other potential const issue would be passing the literal \"\"; in C string literals are string-literal objects and the snippet passes \"\" where the called function's parameter type determines conversion \u2014 but the agent did not show the callee/struct definition or any actual assignment from const char * to a non-const member in the given code. Therefore, based on the supplied code, the claim of a Rule 8.13 violation is incorrect."
}