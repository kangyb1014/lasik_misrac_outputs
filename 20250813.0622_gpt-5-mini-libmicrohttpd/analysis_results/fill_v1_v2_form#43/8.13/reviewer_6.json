{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1_V2, session->value_1,\n                        session->value_2);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) ((size_t) reply_len + 1),\n                             FORM_V1_V2,\n                             session->value_1,\n                             session->value_2))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function only reads fields from 'session' (session->value_1, session->value_2) and does not write to it in this function. The parameter is declared as 'struct Session *session' rather than 'const struct Session *session'. Under MISRA C 2023 Rule 8.13, the pointer should be const-qualified when possible. If the called helper add_session_cookie(session, ...) does not modify the session, then the current prototype violates Rule 8.13. Change the parameter to 'const struct Session *session' (unless add_session_cookie or other callees legitimately modify it).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_open(FILE **out)\n{\n  if (out == NULL)\n    return;\n  *out = fopen(\"/tmp/logs/347.txt\", \"a\");\n}\nstatic void probe_log_close(FILE *out)\n{\n  if (out != NULL)\n    fclose(out);\n}\nstatic void probe_log_hex(FILE *out, const unsigned char *data, size_t len)\n{\n  size_t i;\n  if (out == NULL || data == NULL)\n    return;\n  for (i = 0; i < len; ++i)\n  {\n    fprintf(out, \"%02X\", data[i]);\n    if ((i + 1) % 16 == 0 && (i + 1) < len)\n      fprintf(out, \"\\n\");\n    else if ((i + 1) < len)\n      fprintf(out, \" \");\n  }\n}\nstatic void probe_snapshot_field(FILE *out, const char *label, const void *field_addr, size_t field_size)\n{\n  unsigned char *buf = NULL;\n  if (out == NULL || field_addr == NULL)\n    return;\n  buf = (unsigned char *) malloc(field_size);\n  if (buf == NULL)\n  {\n    fprintf(out, \"%s: <snapshot alloc failed>\\n\", label);\n    return;\n  }\n  memcpy(buf, field_addr, field_size);\n  fprintf(out, \"%s (size=%zu) bytes: \", label, field_size);\n  probe_log_hex(out, buf, field_size);\n  fprintf(out, \"\\n\");\n  free(buf);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  FILE *logf = NULL;\n  probe_log_open(&logf);\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER fill_v1_v2_form: session=%p, mime=%p, connection=%p\\n\",\n            (void *) session, (const void *) mime, (void *) connection);\n  }\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1_V2, session->value_1,\n                        session->value_2);\n  if (logf != NULL)\n    fprintf(logf, \"Computed reply_len=%d\\n\", reply_len);\n\n  if (0 > reply_len)\n  {\n    if (logf != NULL)\n      fprintf(logf, \"reply_len < 0 -> returning MHD_NO\\n\");\n    probe_log_close(logf);\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (logf != NULL)\n    fprintf(logf, \"Allocated reply=%p (len=%d)\\n\", (void *) reply, reply_len);\n\n  if (NULL == reply)\n  {\n    if (logf != NULL)\n      fprintf(logf, \"malloc failed -> returning MHD_NO\\n\");\n    probe_log_close(logf);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) ((size_t) reply_len + 1),\n                             FORM_V1_V2,\n                             session->value_1,\n                             session->value_2))\n  {\n    if (logf != NULL)\n      fprintf(logf, \"snprintf mismatch -> freeing reply and returning MHD_NO\\n\");\n    free (reply);\n    probe_log_close(logf);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (logf != NULL)\n    fprintf(logf, \"MHD_create_response_from_buffer_with_free_callback -> response=%p\\n\",\n            (void *) response);\n\n  if (NULL != response)\n  {\n    /* Snapshot session state before calling add_session_cookie */\n    if (logf != NULL)\n    {\n      fprintf(logf, \"Snapshot BEFORE add_session_cookie:\\n\");\n      /* Record raw bytes of the fields to detect any change regardless of type */\n      probe_snapshot_field(logf, \"session->value_1\", &session->value_1, sizeof(session->value_1));\n      probe_snapshot_field(logf, \"session->value_2\", &session->value_2, sizeof(session->value_2));\n    }\n\n    add_session_cookie (session, response);\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"Returned from add_session_cookie. Snapshot AFTER:\\n\");\n      probe_snapshot_field(logf, \"session->value_1\", &session->value_1, sizeof(session->value_1));\n      probe_snapshot_field(logf, \"session->value_2\", &session->value_2, sizeof(session->value_2));\n\n      /* Compare raw bytes to detect any modification */\n      {\n        unsigned char before1[sizeof(session->value_1)];\n        unsigned char after1[sizeof(session->value_1)];\n        unsigned char before2[sizeof(session->value_2)];\n        unsigned char after2[sizeof(session->value_2)];\n\n        memcpy(before1, &session->value_1, sizeof(session->value_1));\n        memcpy(before2, &session->value_2, sizeof(session->value_2));\n        /* We already overwrote \"before\" with the same content; to properly\n           detect change we must capture before the call. However, above we\n           used probe_snapshot_field which allocated temporary buffers and\n           freed them. To reliably compare, capture before now by re-reading\n           would be identical. To avoid double-allocation, we re-capture\n           after and report differences conservatively. */\n\n        /* Re-capture after values */\n        memcpy(after1, &session->value_1, sizeof(session->value_1));\n        memcpy(after2, &session->value_2, sizeof(session->value_2));\n\n        if (0 != memcmp(before1, after1, sizeof(session->value_1)))\n          fprintf(logf, \"Detected change in session->value_1 (raw bytes differ)\\n\");\n        else\n          fprintf(logf, \"No change detected in session->value_1\\n\");\n\n        if (0 != memcmp(before2, after2, sizeof(session->value_2)))\n          fprintf(logf, \"Detected change in session->value_2 (raw bytes differ)\\n\");\n        else\n          fprintf(logf, \"No change detected in session->value_2\\n\");\n      }\n    }\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      if (logf != NULL)\n        fprintf(logf, \"Failed to set content type header\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    if (logf != NULL)\n      fprintf(logf, \"MHD_queue_response returned %d\\n\", (int) ret);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n    if (logf != NULL)\n      fprintf(logf, \"response == NULL -> freed reply and set ret=MHD_NO\\n\");\n  }\n\n  probe_log_close(logf);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_v2_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 8.13 says a pointer should point to a const-qualified type whenever possible. In the body of fill_v1_v2_form the function itself only reads session->value_1 and session->value_2, so, at this function-local level, a const qualifier would be appropriate. However the function passes session to add_session_cookie(session, response). Whether the parameter should be const in fill_v1_v2_form depends on the prototype and behavior of add_session_cookie (and any other callees that receive the pointer):\n\n- If add_session_cookie (or any other callee) legitimately modifies the Session object, the parameter must remain a non-const pointer and there is no violation.  \n- If add_session_cookie does not modify the Session and its prototype can be changed to accept const struct Session *, then fill_v1_v2_form should indeed declare session as const struct Session * to comply with Rule 8.13.\n\nThe test harness supplied by agent A did not prove that add_session_cookie leaves the session unchanged (the snapshot logic was flawed and the test log was empty), so it does not establish a definite violation. Therefore the agent\u2019s report is only conditionally correct: the code violates Rule 8.13 only when callees do not modify the Session and their prototypes can be changed to accept const; otherwise there is no violation.\n\nRecommendation: inspect the prototype and implementation of add_session_cookie (and any other functions passed session). If none modify the Session, update their prototypes and change the parameter to const struct Session *; if any modify it, keep the current non-const signature."
}