{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If kind != MHD_GET_ARGUMENT_KIND and the caller passes a non-NULL value pointer that is not NUL-terminated within its value_size bytes (for example a buffer of size 10 filled with 10 non-zero bytes and value_size == 10), the expression (value ? strlen(value) : 0) will call strlen on a non-NUL-terminated buffer and may read past the buffer bounds searching for a terminator. This constitutes an out-of-bounds access and thus violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void MHD_probe_log(const char *stage,\n                          int kind_val,\n                          const char *key,\n                          size_t key_size,\n                          const char *value,\n                          size_t value_size,\n                          size_t key_strlen_val,\n                          size_t value_strlen_val,\n                          int check_failed,\n                          int result)\n{\n    FILE *f = fopen(\"/tmp/logs/415.txt\", \"a\");\n    if (f == NULL)\n        return;\n\n    /* Print a compact record useful to reproduce the violation scenario. */\n    fprintf(f, \"stage=%s kind=%d key_ptr=%p key_size=%zu value_ptr=%p value_size=%zu key_strlen=%zu value_strlen=%zu check_failed=%d result=%d\\n\",\n            stage,\n            kind_val,\n            (const void *)key,\n            key_size,\n            (const void *)value,\n            value_size,\n            key_strlen_val,\n            value_strlen_val,\n            check_failed,\n            result);\n    fflush(f);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  /* Log entry with initial state. Use -1 for strlen fields to indicate not yet computed. */\n  MHD_probe_log(\"entry\", (int)kind, key, key_size, value, value_size, (size_t)-1, (size_t)-1, 0, -1);\n\n  /* Preserve original logic: compute strlen values the same way as original code.\n   * Note: calling strlen on a non-NUL-terminated buffer is the reported violation\n   * scenario; we intentionally perform the same calls so callers can reproduce it.\n   */\n  size_t key_strlen = (key ? strlen(key) : 0);\n  size_t value_strlen = (value ? strlen(value) : 0);\n\n  /* Determine whether the original check would fail. */\n  int check_failed = 0;\n  if ((MHD_GET_ARGUMENT_KIND != kind) &&\n      ( ((key ? key_strlen : 0) != key_size) ||\n        ((value ? value_strlen : 0) != value_size) ))\n    check_failed = 1;\n\n  /* Log computed lengths and whether the check failed. */\n  MHD_probe_log(\"after_strlen\", (int)kind, key, key_size, value, value_size, key_strlen, value_strlen, check_failed, -1);\n\n  if (check_failed)\n  {\n    /* Log the return path (MHD_NO == failure). */\n    MHD_probe_log(\"return_no\", (int)kind, key, key_size, value, value_size, key_strlen, value_strlen, check_failed, (int)MHD_NO);\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  /* Log that we are about to call the nocheck function. */\n  MHD_probe_log(\"call_nocheck\", (int)kind, key, key_size, value, value_size, key_strlen, value_strlen, check_failed, -1);\n\n  enum MHD_Result res = MHD_set_connection_value_n_nocheck_ (connection,\n                                                            kind,\n                                                            key,\n                                                            key_size,\n                                                            value,\n                                                            value_size);\n\n  /* Log the result returned by the nocheck function. */\n  MHD_probe_log(\"return_nocheck\", (int)kind, key, key_size, value, value_size, key_strlen, value_strlen, check_failed, (int)res);\n\n  return res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_set_connection_value_n. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls strlen(key) and strlen(value) whenever the pointer is non-NULL; if the caller supplies a non-NUL-terminated buffer (e.g. a 10-byte buffer filled with non-zero bytes and value_size == 10), strlen will scan past the end searching for a terminator and may read out-of-bounds. That potential out-of-bounds access is exactly what MISRA C 2023 Rule 21.17 forbids. (The only way this would not be a violation is if the function has a documented, enforced precondition that those pointers always reference NUL-terminated strings for the non-GET case; with no such guaranteed precondition in the code, the use of strlen is unsafe.)"
}