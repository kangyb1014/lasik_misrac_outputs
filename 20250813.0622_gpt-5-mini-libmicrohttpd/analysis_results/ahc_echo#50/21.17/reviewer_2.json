{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling strstr(url, \"../\") without validating 'url' can lead to out-of-bounds access. For example, if url == NULL (or if url does not point to a NUL-terminated buffer), strstr will dereference/read past the object bounds, causing undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  char *probe_strstr_result = NULL;\n  FILE *probe_log = NULL;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Probe: log entry and pointer state before any string operations. */\n  probe_log = fopen(\"/tmp/logs/407.txt\", \"a\");\n  if (NULL != probe_log)\n  {\n    /* Log pointer values only (do not dereference url or other potentially NULL pointers). */\n    fprintf(probe_log, \"ahc_echo invoked\\n\");\n    fprintf(probe_log, \"  url pointer: %p\\n\", (void *) url);\n    fprintf(probe_log, \"  method pointer: %p\\n\", (void *) method);\n    fprintf(probe_log, \"  version pointer: %p\\n\", (void *) version);\n    fprintf(probe_log, \"  req_cls pointer: %p\\n\", (void *) req_cls);\n    if (NULL != req_cls)\n      fprintf(probe_log, \"  *req_cls (pointed value): %p\\n\", (void *) (*req_cls));\n    else\n      fprintf(probe_log, \"  *req_cls: <req_cls is NULL>\\n\");\n    fflush(probe_log);\n    fclose(probe_log);\n    probe_log = NULL;\n  }\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n\n  /* Note: Original code called strstr(url, \"../\") without validating url.\n   * We keep that behavior to allow reproduction of the violation scenario.\n   * Before calling strstr we log pointer state (above). Now call strstr\n   * and log the result (address returned). If url is NULL this call will\n   * exhibit the same undefined behavior as in the original code.\n   */\n  probe_strstr_result = strstr (url, \"../\"); /* intentional: keep original behavior */\n\n  /* Log the result of strstr (if we reached here). */\n  probe_log = fopen(\"/tmp/logs/407.txt\", \"a\");\n  if (NULL != probe_log)\n  {\n    fprintf(probe_log, \"  strstr(.., \\\"../\\\") returned: %p\\n\", (void *) probe_strstr_result);\n    fflush(probe_log);\n    fclose(probe_log);\n    probe_log = NULL;\n  }\n\n  if (NULL != probe_strstr_result) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. MISRA C 2023 Rule 21.17 requires that calls to the <string.h> functions must not result in accesses beyond the bounds of the objects passed. The ahc_echo implementation calls strstr(url, \"../\") without first ensuring that the pointer url is non-NULL and that it points to a valid NUL-terminated character array. If url == NULL, or if it does not point to a NUL-terminated buffer, strstr will read out-of-bounds (undefined behavior). Additionally, later the code does open(url + 1, O_RDONLY) which also assumes that url points to at least one character plus a terminating NUL; if url were an empty string (or otherwise too short) that dereference/path would likewise cause out-of-bounds access/undefined behavior. While the surrounding library (libmicrohttpd) may guarantee a non-NULL, NUL-terminated url in practice, MISRA Rule 21.17 requires the calling code to avoid any possibility of out-of-bounds access unless such preconditions are guaranteed and documented; the function does not perform a defensive check (e.g. url != NULL and an appropriate length check) so it violates the rule. Recommended fixes: check url != NULL before calling strstr, ensure the buffer is NUL-terminated or use APIs that accept an explicit length, and validate length before using url + 1."
}