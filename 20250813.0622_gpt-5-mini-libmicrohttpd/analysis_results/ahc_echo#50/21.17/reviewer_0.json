{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the incoming parameter 'method' is NULL or not NUL-terminated, calling strcmp(method, MHD_HTTP_METHOD_GET) / strcmp(method, MHD_HTTP_METHOD_HEAD) will dereference or read past the bounds of the object referenced by 'method', causing undefined behavior. The code does not check 'method' for NULL or ensure it is a properly terminated string, so this can violate Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nahc_echo_probe(const char *stage,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size,\n               void **req_cls)\n{\n  FILE *f = fopen(\"/tmp/logs/407.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Log pointer values only to avoid dereferencing potentially invalid pointers. */\n  fprintf(f, \"stage=%s url=%p method=%p version=%p upload_data=%p upload_data_size=%p req_cls=%p\",\n          (NULL != stage) ? stage : \"(null)\",\n          (const void *) url,\n          (const void *) method,\n          (const void *) version,\n          (const void *) upload_data,\n          (const void *) upload_data_size,\n          (const void *) req_cls);\n\n  if (NULL != req_cls)\n  {\n    fprintf(f, \" *req_cls=%p\", (const void *) *req_cls);\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Probe: entering function and show pointer state. */\n  ahc_echo_probe(\"enter\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  /* Probe: just before method check. We intentionally do not alter the\n   * subsequent strcmp calls so the original control flow and potential\n   * violation behavior remain unchanged. */\n  ahc_echo_probe(\"before_method_check\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* Log that we are about to return due to unexpected method. */\n    ahc_echo_probe(\"unexpected_method_return\", url, method, version, upload_data, upload_data_size, req_cls);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  /* Log that method check passed. */\n  ahc_echo_probe(\"method_ok\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    /* Log before setting req_cls for the first call. */\n    ahc_echo_probe(\"first_call_set_req_cls\", url, method, version, upload_data, upload_data_size, req_cls);\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n\n  /* Log that we are proceeding to serve the request. */\n  ahc_echo_probe(\"proceed_after_first_call\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    ahc_echo_probe(\"url_forbidden_parent_dir\", url, method, version, upload_data, upload_data_size, req_cls);\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  }\n  else\n  {\n    ahc_echo_probe(\"opening_file\", url, method, version, upload_data, upload_data_size, req_cls);\n    fd = open (url + 1, O_RDONLY);\n  }\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      ahc_echo_probe(\"not_regular_file_close\", url, method, version, upload_data, upload_data_size, req_cls);\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    ahc_echo_probe(\"file_not_found_response\", url, method, version, upload_data, upload_data_size, req_cls);\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    ahc_echo_probe(\"file_found_response\", url, method, version, upload_data, upload_data_size, req_cls);\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      ahc_echo_probe(\"response_create_failed\", url, method, version, upload_data, upload_data_size, req_cls);\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n\n  ahc_echo_probe(\"exit\", url, method, version, upload_data, upload_data_size, req_cls);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario identifies a real class of runtime fault (calling strcmp on a NULL pointer or a non-NUL-terminated object can read out of bounds), but the report is not correct as a definitive MISRA Rule 21.17 violation for this code without further context. strcmp and strstr do require pointer parameters to point at valid NUL-terminated objects; if the caller (the libmicrohttpd callback contract) guarantees that method and url are non-NULL and properly terminated, the uses in ahc_echo do not violate 21.17. The agent gave no evidence that the API can pass NULL or unterminated strings; the empty test log does not demonstrate the defect. That said, from a strict MISRA perspective the function either should (a) validate these pointers/terminators before calling string.h functions, or (b) document and rely on a well\u2011specified external precondition (and ensure that is part of the system\u2019s safety argument). Without such a precondition or input validation, the code is potentially non\u2011conforming; but the agent\u2019s unconditional claim that the code violates 21.17 is not proven."
}