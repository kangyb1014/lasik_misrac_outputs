{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp(hdr->value, \"close\", 5) to test whether the header value equals the token \"close\". hdr->value is a C string (header values are stored/used as NUL-terminated strings elsewhere) and \"close\" is a NUL\u2011terminated string literal. Using memcmp to compare these string values violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null\u2011terminated strings).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_logf(const char *fmt, ...)\n{\n  FILE *f = NULL;\n  struct stat st;\n  va_list ap;\n\n  if (0 != stat(\"/tmp/logs\", &st))\n  {\n    /* attempt to create directory; ignore errors if it fails */\n    (void) mkdir(\"/tmp/logs\", 0777);\n  }\n\n  f = fopen(\"/tmp/logs/406.txt\", \"a\");\n  if (NULL == f)\n  {\n    /* If logging is not possible, silently return to avoid changing program flow. */\n    return;\n  }\n\n  va_start(ap, fmt);\n  (void) vfprintf(f, fmt, ap);\n  va_end(ap);\n\n  (void) fflush(f);\n  (void) fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry with key inputs and current req_cls pointer value. */\n  probe_logf(\"ahc_echo ENTRY: method=%s url=%s req_cls_ptr=%p req_cls_val=%p\\n\",\n             (NULL != method) ? method : \"(null)\",\n             (NULL != url) ? url : \"(null)\",\n             (void *) req_cls, (NULL != req_cls) ? *req_cls : (void *) 0);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    probe_logf(\"ahc_echo: unexpected method '%s' --> return MHD_NO\\n\",\n               (NULL != method) ? method : \"(null)\");\n    return MHD_NO;              /* unexpected method */\n  }\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    probe_logf(\"ahc_echo: first call detected, setting req_cls to %p and returning MHD_YES\\n\",\n               (void *) *req_cls);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* Log the URL inspection and potential security check. */\n  probe_logf(\"ahc_echo: serving path check, url=%s\\n\",\n             (NULL != url) ? url : \"(null)\");\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    probe_logf(\"ahc_echo: detected '..' in url -> refusing to traverse up, fd will be -1\\n\");\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  }\n  else\n  {\n    const char *fname = url + 1;\n    probe_logf(\"ahc_echo: attempting to open file '%s'\\n\",\n               (NULL != fname) ? fname : \"(null)\");\n    fd = open (fname, O_RDONLY);\n    probe_logf(\"ahc_echo: open('%s') returned fd=%d (errno=%d)\\n\",\n               (NULL != fname) ? fname : \"(null)\", fd, errno);\n  }\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      probe_logf(\"ahc_echo: fstat/regular check failed: fstat_ret=%d S_ISREG=%d\\n\",\n                 (int) (0 != fstat (fd, &buf)), (int) S_ISREG (buf.st_mode));\n      if (0 != close (fd))\n      {\n        probe_logf(\"ahc_echo: close(fd=%d) failed with errno=%d -> aborting\\n\",\n                   fd, errno);\n        abort ();\n      }\n      fd = -1;\n    }\n    else\n    {\n      probe_logf(\"ahc_echo: file is regular, st_size=%lld st_mode=0%o\\n\",\n                 (long long) buf.st_size, (unsigned int) buf.st_mode);\n    }\n  }\n  if (-1 == fd)\n  {\n    probe_logf(\"ahc_echo: preparing 404 response for url=%s\\n\",\n               (NULL != url) ? url : \"(null)\");\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    probe_logf(\"ahc_echo: queued 404 response -> ret=%d\\n\", (int) ret);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    probe_logf(\"ahc_echo: preparing 200 response from fd=%d size=%lld\\n\",\n               fd, (long long) buf.st_size);\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      probe_logf(\"ahc_echo: MHD_create_response_from_fd64 returned NULL for fd=%d -> closing fd and returning MHD_NO\\n\",\n                 fd);\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    probe_logf(\"ahc_echo: queued 200 response -> ret=%d\\n\", (int) ret);\n    MHD_destroy_response (response);\n  }\n\n  probe_logf(\"ahc_echo EXIT: returning ret=%d\\n\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the provided ahc_echo code. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings, but the ahc_echo function shown does not call memcmp anywhere. It uses strcmp, strstr and strlen, which are the correct functions for handling NUL\u2011terminated strings in this context. Agent A\u2019s described scenario (memcmp(hdr->value, \"close\", 5)) would indeed violate Rule 21.14 if it existed, but that call is not present in the supplied code. The test harness/logging provided simply exercised ahc_echo and produced no log output; that does not change that no memcmp usage appears in the function. Recommendation: if anywhere else in the codebase memcmp is used to compare NUL\u2011terminated strings, replace it with strcmp/strncmp (with appropriate length/termination checks) to comply with Rule 21.14."
}