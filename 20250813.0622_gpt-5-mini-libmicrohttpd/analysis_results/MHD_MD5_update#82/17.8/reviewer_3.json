{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Inside MHD_MD5_update the value of the function parameter 'length' is modified with the statement 'length -= bytes_left;'. This alters the parameter passed by value and therefore violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/661.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fputc('\\n', f);\n  va_end(ap);\n  fclose(f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n  /* Log entry and initial state */\n  mhd_probe_log(\"MHD_MD5_update ENTRY: ctx=%p data=%p length=%zu ctx->count=%zu\",\n                (void *)ctx, (const void *)data, length, (size_t)ctx->count);\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    mhd_probe_log(\"MHD_MD5_update: length == 0, returning early\");\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  mhd_probe_log(\"bytes_have computed: %u\", bytes_have);\n\n  ctx->count += length;\n  mhd_probe_log(\"ctx->count updated: %zu (added %zu)\", (size_t)ctx->count, length);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    mhd_probe_log(\"buffer not empty: bytes_have=%u bytes_left=%u length=%zu\", bytes_have, bytes_left, length);\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      mhd_probe_log(\"branch: length (%zu) >= bytes_left (%u) -- about to memcpy, advance data and modify length\", length, bytes_left);\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      mhd_probe_log(\"after memcpy and data advance: data=%p (advanced by %u)\", (const void *)data, bytes_left);\n\n      /* Violation point: parameter 'length' is modified here in original code */\n      mhd_probe_log(\"before modifying parameter 'length': length=%zu\", length);\n      length -= bytes_left;\n      mhd_probe_log(\"after modifying parameter 'length': length=%zu\", length);\n\n      md5_transform (ctx->H, ctx->buffer);\n      mhd_probe_log(\"md5_transform called on combined buffer\");\n      bytes_have = 0;\n    }\n    else\n    {\n      mhd_probe_log(\"not enough data to fill buffer: need %u more bytes, have %zu\", bytes_left, length);\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    mhd_probe_log(\"while-loop: processing full block, length=%zu data=%p\", length, (const void *)data);\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n    mhd_probe_log(\"while-loop: after transform data=%p length=%zu\", (const void *)data, length);\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    mhd_probe_log(\"copying incomplete tail: bytes_have=%u length=%zu data=%p\",\n                  bytes_have, length, (const void *)data);\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n\n  mhd_probe_log(\"MHD_MD5_update EXIT: ctx=%p final_length_%zu ctx->count=%zu\",\n                (void *)ctx, length, (size_t)ctx->count);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60020 length=28 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 28 (added 28)\ncopying incomplete tail: bytes_have=0 length=28 data=0x564f19d60020\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_28 ctx->count=28\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d6003d length=14 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 14 (added 14)\ncopying incomplete tail: bytes_have=0 length=14 data=0x564f19d6003d\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_14 ctx->count=14\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d6004c length=26 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 26 (added 26)\ncopying incomplete tail: bytes_have=0 length=26 data=0x564f19d6004c\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_26 ctx->count=26\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60067 length=26 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 26 (added 26)\ncopying incomplete tail: bytes_have=0 length=26 data=0x564f19d60067\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_26 ctx->count=26\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60088 length=104 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 104 (added 104)\nwhile-loop: processing full block, length=104 data=0x564f19d60088\nwhile-loop: after transform data=0x564f19d600c8 length=40\ncopying incomplete tail: bytes_have=0 length=40 data=0x564f19d600c8\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_40 ctx->count=104\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d600f8 length=378 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 378 (added 378)\nwhile-loop: processing full block, length=378 data=0x564f19d600f8\nwhile-loop: after transform data=0x564f19d60138 length=314\nwhile-loop: processing full block, length=314 data=0x564f19d60138\nwhile-loop: after transform data=0x564f19d60178 length=250\nwhile-loop: processing full block, length=250 data=0x564f19d60178\nwhile-loop: after transform data=0x564f19d601b8 length=186\nwhile-loop: processing full block, length=186 data=0x564f19d601b8\nwhile-loop: after transform data=0x564f19d601f8 length=122\nwhile-loop: processing full block, length=122 data=0x564f19d601f8\nwhile-loop: after transform data=0x564f19d60238 length=58\ncopying incomplete tail: bytes_have=0 length=58 data=0x564f19d60238\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_58 ctx->count=378\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60273 length=0 ctx->count=0\nMHD_MD5_update: length == 0, returning early\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60274 length=1 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 1 (added 1)\ncopying incomplete tail: bytes_have=0 length=1 data=0x564f19d60274\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_1 ctx->count=1\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60276 length=3 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 3 (added 3)\ncopying incomplete tail: bytes_have=0 length=3 data=0x564f19d60276\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_3 ctx->count=3\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d6027a length=14 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 14 (added 14)\ncopying incomplete tail: bytes_have=0 length=14 data=0x564f19d6027a\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_14 ctx->count=14\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d60290 length=62 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 62 (added 62)\ncopying incomplete tail: bytes_have=0 length=62 data=0x564f19d60290\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_62 ctx->count=62\nMHD_MD5_update ENTRY: ctx=0x7ffc7ee6d950 data=0x564f19d602d0 length=80 ctx->count=0\nbytes_have computed: 0\nctx->count updated: 80 (added 80)\nwhile-loop: processing full block, length=80 data=0x564f19d602d0\nwhile-loop: after transform data=0x564f19d60310 length=16\ncopying incomplete tail: bytes_have=0 length=16 data=0x564f19d60310\nMHD_MD5_update EXIT: ctx=0x7ffc7ee6d950 final_length_16 ctx->count=80\nMHD_MD5_update ENTRY: ctx=0x7ffc\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified. In MHD_MD5_update the value parameter 'length' is modified (length -= bytes_left; and length -= MD5_BLOCK_SIZE;), which violates the rule. Additionally, the pointer parameter 'data' is advanced (data += bytes_left; data += MD5_BLOCK_SIZE;), and the rule\u2019s note explicitly states that pointer parameters themselves shall not be modified (only the object they point to may be). The test logs show these modifications occurring during execution, confirming the violation(s)."
}