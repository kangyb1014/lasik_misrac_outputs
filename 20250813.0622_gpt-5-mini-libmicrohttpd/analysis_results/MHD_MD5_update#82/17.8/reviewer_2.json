{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement 'data += bytes_left;' modifies the pointer parameter 'data' (i.e. the pointer itself is changed). MISRA C 2023 Rule 17.8 prohibits modifying function parameters \u2014 while the object pointed to may be modified, the pointer parameter must not be changed. (Note: the code also later does 'data += MD5_BLOCK_SIZE;' which is the same violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_state(const char *label,\n                          const uint8_t *data_ptr,\n                          size_t length,\n                          unsigned int bytes_have,\n                          unsigned int bytes_left)\n{\n  FILE *f = fopen(\"/tmp/logs/661.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"%s: data=%p length=%zu bytes_have=%u bytes_left=%u\\n\",\n          label, (const void *) data_ptr, length, bytes_have, bytes_left);\n  if ((data_ptr != NULL) && (length > 0))\n  {\n    size_t n = (length < 16) ? length : 16;\n    fprintf(f, \"%s: first %zu bytes:\", label, n);\n    for (size_t i = 0; i < n; ++i)\n      fprintf(f, \" %02x\", data_ptr[i]);\n    fprintf(f, \"\\n\");\n  }\n  fclose(f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n  /* Log on entry */\n  mhd_log_state(\"entry\", data, length, 0u, 0u);\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  /* Log after updating count */\n  mhd_log_state(\"after_count\", data, length, bytes_have, 0u);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      /* Log state just before memcpy and pointer modification */\n      mhd_log_state(\"pre_first_copy\", data, length, bytes_have, bytes_left);\n\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n\n      /* Log state immediately after memcpy, before pointer change */\n      mhd_log_state(\"post_first_copy_before_ptr_inc\", data, length, bytes_have, bytes_left);\n\n      /* This is where the pointer parameter is modified in the original code. */\n      data += bytes_left;\n\n      /* Log state immediately after pointer change (evidence of pointer modification) */\n      mhd_log_state(\"post_first_copy_after_ptr_inc\", data, length - bytes_left, bytes_have, bytes_left);\n\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  /* Log before processing full blocks in the loop */\n  mhd_log_state(\"before_full_blocks_loop\", data, length, bytes_have, 0u);\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    /* Log each iteration: pointer before transform */\n    mhd_log_state(\"loop_before_transform\", data, length, bytes_have, MD5_BLOCK_SIZE);\n\n    md5_transform (ctx->H, data);\n\n    /* Log state just before pointer increment */\n    mhd_log_state(\"loop_after_transform_before_ptr_inc\", data, length, bytes_have, MD5_BLOCK_SIZE);\n\n    data += MD5_BLOCK_SIZE;\n\n    /* Log state immediately after pointer change (evidence of pointer modification) */\n    mhd_log_state(\"loop_after_transform_after_ptr_inc\", data, length - MD5_BLOCK_SIZE, bytes_have, MD5_BLOCK_SIZE);\n\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    mhd_log_state(\"pre_final_copy\", data, length, bytes_have, 0u);\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    mhd_log_state(\"post_final_copy\", data, length, bytes_have, 0u);\n  }\n\n  /* Log on exit with final pointer/length status */\n  mhd_log_state(\"exit\", data, length, bytes_have, 0u);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nentry: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\nentry: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nafter_count: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\nafter_count: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nbefore_full_blocks_loop: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\nbefore_full_blocks_loop: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\npre_final_copy: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\npre_final_copy: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\npost_final_copy: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\npost_final_copy: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nexit: data=0x55be7ad02020 length=28 bytes_have=0 bytes_left=0\nexit: first 16 bytes: 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nentry: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\nentry: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nafter_count: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\nafter_count: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nbefore_full_blocks_loop: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\nbefore_full_blocks_loop: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\npre_final_copy: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\npre_final_copy: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\npost_final_copy: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\npost_final_copy: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nexit: data=0x55be7ad0203d length=14 bytes_have=0 bytes_left=0\nexit: first 14 bytes: 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nentry: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\nentry: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nafter_count: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\nafter_count: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nbefore_full_blocks_loop: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\nbefore_full_blocks_loop: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\npre_final_copy: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\npre_final_copy: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\npost_final_copy: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\npost_final_copy: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nexit: data=0x55be7ad0204c length=26 bytes_have=0 bytes_left=0\nexit: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nentry: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\nentry: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nafter_count: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\nafter_count: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nbefore_full_blocks_loop: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\nbefore_full_blocks_loop: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\npre_final_copy: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\npre_final_copy: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\npost_final_copy: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\npost_final_copy: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nexit: data=0x55be7ad02067 length=26 bytes_have=0 bytes_left=0\nexit: first 16 bytes: 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nentry: data=0x55be7ad02088 length=104 bytes_have=0 bytes_left=0\nentry: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nafter_count: data=0x55be7ad02088 length=104 bytes_have=0 bytes_left=0\nafter_count: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nbefore_full_blocks_loop: data=0x55be7ad02088 length=104 bytes_have=0 bytes_left=0\nbefore_full_blocks_loop: first 16 bytes: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nloop_before_transform: data=0x55be7ad02088 length=104 bytes_have=0 bytes_left=64\nloop_before_transform: first 16 bytes: 61 62 6\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (the pointer itself must not be changed; only the object pointed-to may be modified). In MHD_MD5_update the parameter 'data' (declared as const uint8_t *data) is modified by the statements data += bytes_left; and data += MD5_BLOCK_SIZE; \u2014 these change the pointer variable, not the object it points to. That is a direct violation of R17.8. (The test logs show many runs where the branches that increment data did not execute for those inputs, but the presence of the pointer-modifying statements in the code is sufficient to violate the rule.) Suggested remediation: introduce a local pointer (for example 'const uint8_t *p = data;') and perform pointer arithmetic on that local variable, leaving the parameter 'data' unmodified."
}