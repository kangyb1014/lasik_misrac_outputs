{
  "user_message": "An agent A claimed that the following iterate_post code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of iterate_post.\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:GREETINGPAGE contains the \"%s\" conversion. In iterate_post the code does snprintf(answerstring, MAXANSWERSIZE, GREETINGPAGE, data). The 'data' parameter is accompanied by a length 'size' and is not guaranteed to be NUL-terminated. Passing a non\u2011terminated buffer to a %s conversion causes the formatter to read beyond the valid 'size' bytes until it finds a NUL, producing an out\u2011of\u2011bounds access of the object referenced by 'data'. This is a violation of MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_iterate_post(const char *stage, const char *key, const char *filename,\n                   const char *content_type, const char *transfer_encoding,\n                   const char *data, uint64_t off, size_t size)\n{\n  FILE *log = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if (!log)\n    return;\n\n  fprintf(log, \"--- iterate_post probe (%s) ---\\n\", stage);\n  fprintf(log, \"key='%s'\\n\", key ? key : \"(null)\");\n  fprintf(log, \"filename='%s'\\n\", filename ? filename : \"(null)\");\n  fprintf(log, \"content_type='%s'\\n\", content_type ? content_type : \"(null)\");\n  fprintf(log, \"transfer_encoding='%s'\\n\", transfer_encoding ? transfer_encoding : \"(null)\");\n  fprintf(log, \"off=%\" PRIu64 \"\\n\", off);\n  fprintf(log, \"size=%zu\\n\", size);\n  fprintf(log, \"data_ptr=%p\\n\", (void *)data);\n\n  /* Check if there is a NUL byte within the provided size. This is safe because\n     we only scan up to 'size' bytes. Using memchr avoids interpreting data as\n     a C string when it may not be NUL-terminated. */\n  if (data && size > 0)\n  {\n    const void *nul = memchr(data, '\\0', size);\n    if (nul)\n      fprintf(log, \"NUL-within-size: yes (index=%td)\\n\", (ptrdiff_t)((const char *)nul - data));\n    else\n      fprintf(log, \"NUL-within-size: no\\n\");\n\n    /* Dump up to the first 256 bytes in hex to avoid huge logs. */\n    size_t dump_len = size;\n    if (dump_len > 256U)\n      dump_len = 256U;\n\n    fprintf(log, \"data-hex[%zu]:\", dump_len);\n    for (size_t i = 0; i < dump_len; ++i)\n      fprintf(log, \" %02x\", (unsigned char)data[i]);\n    if (size > dump_len)\n      fprintf(log, \" ... (truncated)\");\n    fprintf(log, \"\\n\");\n\n    /* Also attempt a bounded text print: %.*s will print at most 'size'\n       characters, so it is safe even if the buffer is not NUL-terminated.\n       We cast size to int for the precision; if size is larger than INT_MAX\n       this cast may truncate, but such large sizes are unlikely in practice\n       for this probe. */\n    fprintf(log, \"data-as-text (bounded): \\n\");\n    fprintf(log, \"%.*s\\n\", (int)size, data);\n  }\n  else\n  {\n    fprintf(log, \"data: (null or size==0)\\n\");\n  }\n\n  fprintf(log, \"--- end probe (%s) ---\\n\\n\", stage);\n  fclose(log);\n}\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = (struct connection_info_struct *)coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  /* Probe entry -- capture the parameters and state before any processing. */\n  probe_iterate_post(\"entry\", key, filename, content_type, transfer_encoding, data, off, size);\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      /* Probe immediately before the risky snprintf call so that logs show\n         whether 'data' contains a NUL within 'size' bytes (evidence of the\n         violation scenario). */\n      probe_iterate_post(\"before_snprintf\", key, filename, content_type, transfer_encoding, data, off, size);\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n\n      /* Probe after snprintf to capture the pointer to answerstring and\n         allow inspection of the result if needed. Do not attempt to print\n         answerstring as a raw string here to avoid hiding or altering the\n         original behavior; only log its pointer value and a bounded hex\n         dump. */\n      probe_iterate_post(\"after_snprintf\", key, filename, content_type, transfer_encoding, answerstring, 0, (size_t)0);\n\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for iterate_post. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s description of the runtime problem is correct: if GREETINGPAGE contains a %s conversion and the 'data' buffer is not NUL-terminated (only a pointer+length is provided), then snprintf(..., GREETINGPAGE, data) may cause the formatter to read past the provided 'size' bytes until a NUL is found, producing an out\u2011of\u2011bounds access. However, MISRA C 2023 Rule 21.17 (as quoted) specifically addresses the string-handling functions from <string.h> (memcpy, strcpy, strlen, etc.). snprintf and the printf-family are not functions from <string.h>, so Rule 21.17 does not directly apply. Therefore the report that this code violates Rule 21.17 is not correct. That said, the code does contain a genuine safety/UB issue and should be fixed (for example, change GREETINGPAGE to use a precision specifier and call snprintf with %.*s and a checked (int)size, or copy the data into a NUL-terminated buffer before using %s, ensuring size <= INT_MAX and adding a terminating NUL)."
}