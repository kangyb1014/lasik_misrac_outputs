{
  "user_message": "An agent A claimed that the following iterate_post code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of iterate_post.\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call snprintf(answerstring, MAXANSWERSIZE, GREETINGPAGE, data) uses the %s format with 'data' which is not guaranteed to be NUL-terminated. Although size is checked to be <= MAXNAMESIZE, that only bounds the available bytes, not that a terminator exists. snprintf reads the source string until a NUL byte, so if 'data' contains exactly 'size' bytes without a terminating '\\0' (or the terminator lies beyond the provided buffer), snprintf will read beyond the bounds of the object pointed to by 'data'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MAXNAMESIZE = 256;\nstatic const int MAXANSWERSIZE = 2048;\nstatic const char GREETINGPAGE[] = \"Hello %s\";\nstatic void\nlog_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if (!f)\n    return;\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void\nlog_hex_ascii(const char *label, const void *data, size_t size, size_t limit)\n{\n  const unsigned char *p = (const unsigned char *) data;\n  size_t to_show = size < limit ? size : limit;\n  FILE *f = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf(f, \"%s: size=%zu, show=%zu\\n\", label, size, to_show);\n  fprintf(f, \"bytes: \");\n  for (size_t i = 0; i < to_show; ++i)\n    fprintf(f, \"%02X \", (unsigned) p[i]);\n  fprintf(f, \"\\nchars: \");\n  for (size_t i = 0; i < to_show; ++i)\n  {\n    unsigned char c = p[i];\n    fprintf(f, \"%c\", (c >= 0x20 && c < 0x7F) ? c : '.');\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  /* Log entry for every call to iterate_post with key and size info. */\n  log_probe(\"iterate_post called: key=%s, data_ptr=%p, size=%zu, off=%\" PRIu64,\n            key ? key : \"(null)\", (const void *) data, size, off);\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      /* Probe: check whether the provided 'data' buffer contains a NUL within\n         the provided 'size' bytes. We use memchr constrained to 'size' to\n         avoid reading beyond the supplied buffer. This does not change the\n         original logic; it only observes the buffer contents safely. */\n      int nul_found = 0;\n      size_t nul_offset = 0;\n      if (data != NULL)\n      {\n        const void *res = memchr(data, '\\0', size);\n        if (res != NULL)\n        {\n          nul_found = 1;\n          nul_offset = (const unsigned char *) res - (const unsigned char *) data;\n        }\n      }\n      else\n      {\n        log_probe(\"iterate_post: WARNING: data pointer is NULL\");\n      }\n\n      log_probe(\"iterate_post[name]: size=%zu, MAXNAMESIZE=%d, data_ptr=%p, nul_found=%d, nul_offset=%zu\",\n                size, MAXNAMESIZE, (const void *) data, nul_found, nul_offset);\n\n      if (data != NULL)\n      {\n        /* Dump up to first 64 bytes (bounded by size) for diagnosis. */\n        log_hex_ascii(\"iterate_post[name] data sample\", data, size, 64);\n      }\n\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      /* Log just before calling snprintf to capture the exact control flow. */\n      log_probe(\"iterate_post[name]: about to call snprintf(answerstring, %d, GREETINGPAGE, data)\", MAXANSWERSIZE);\n\n      /* Original behavior preserved: this call may read 'data' as a C string. */\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n\n      log_probe(\"iterate_post[name]: snprintf completed, answerstring_ptr=%p\", (void *) answerstring);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identified a real defect in the code: using snprintf(..., \"...%s\", data) assumes that data is a NUL-terminated C string, but the caller supplies a buffer with an explicit size (size) that may not include a terminating '\\0'. snprintf with %s will read until it finds a NUL byte and therefore can read past the provided buffer \u2014 this is an out\u2011of\u2011bounds access and must be fixed.\n\nHowever, the specific MISRA C 2023 Rule 21.17 cited by Agent A is narrowly phrased to address the string\u2011handling functions from <string.h> (the rule text and examples list functions such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn). snprintf is a <stdio.h> function and is not one of the <string.h> functions listed in that rule. Therefore, while the underlying problem is real and should be corrected, attributing this exact call to a violation of MISRA C 2023 Rule 21.17 is not correct.\n\nRecommendation: fix by using a bounded format (for example use \"%.*s\" with the provided size, after ensuring data is non-NULL and converting size to int safely) or copy up to size bytes into a NUL-terminated temporary buffer before using %s. Also check for NULL data and ensure no signed/size conversions introduce other violations."
}