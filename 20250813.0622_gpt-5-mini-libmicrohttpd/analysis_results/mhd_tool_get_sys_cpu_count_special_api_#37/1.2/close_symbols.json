{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_sys_cpu_count_special_api_': {'callees': [], 'callers': ['mhd_tool_get_system_cpu_count']}, 'mhd_tool_get_system_cpu_count': {'callees': ['mhd_tool_get_sys_cpu_count_special_api_', 'mhd_tool_get_sys_cpu_count_sysctl_', 'mhd_tool_get_sys_cpu_count_sysconf_', 'mhd_tool_get_proc_cpu_count', 'mhd_tool_get_sys_cpu_count_sysctl_fallback_', 'mhd_tool_get_sys_cpu_count_sysconf_fallback_'], 'callers': ['detect_cpu_core_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "WINAPI",
    "__stdcall",
    "GetProcAddress",
    "FARPROC",
    "LoadLibraryA",
    "FreeLibrary",
    "HMODULE",
    "GetActiveProcessorCount",
    "GetNativeSystemInfo",
    "GetSystemInfo",
    "SYSTEM_INFO",
    "DWORD",
    "WORD",
    "ALL_PROCESSOR_GROUPS",
    "vxCpuEnabledGet",
    "cpuset_t",
    "pstat_getdynamic",
    "struct pst_dynamic",
    "memset",
    "size_t",
    "NULL"
  ],
  "explanation": "Explain why each symbol is required for checking language-extension use:\n\n- WINAPI: This macro typically expands to a compiler-specific calling-convention annotation (for example __stdcall on MSVC). Calling-convention keywords are compiler extensions in many toolchains; you must inspect its definition to see whether an extension is used.\n\n- __stdcall: Common concrete calling-convention attribute that WINAPI maps to on Windows. It is explicitly a compiler extension in documentation for many compilers; include it to detect use of nonstandard calling conventions.\n\n- GetProcAddress: Its declared return type and usage (returned pointer being cast to a function pointer type) are relevant. The way GetProcAddress is declared (FARPROC or other) and how it is cast can show use of nonstandard pointer conversions or ABI-dependent behavior.\n\n- FARPROC: The Windows typedef for a generic function pointer (or equivalent). Knowing this type shows whether the code converts between data and function pointers or between different function-pointer types \u2014 conversions that may rely on compiler/ABI extensions.\n\n- LoadLibraryA / FreeLibrary / HMODULE: These Windows API symbols determine the types involved (HMODULE is usually an alias for HANDLE/void*), and whether the code relies on handle types or implementation-defined pointer representations; their declarations help decide if any extension annotations are present.\n\n- GetActiveProcessorCount: Present in the code and its prototype (calling convention, return type DWORD) must be known to determine whether the call or its casting uses nonstandard attributes or extensions.\n\n- GetNativeSystemInfo / GetSystemInfo / SYSTEM_INFO: These APIs and the SYSTEM_INFO struct (and its dwNumberOfProcessors member) determine whether the code relies on platform-specific typedefs or attributes. Declarations may carry calling-convention or alignment attributes that are compiler extensions.\n\n- DWORD / WORD / ALL_PROCESSOR_GROUPS: Windows typedefs/macros used in typedefs and calls. Their definitions (underlying integer types, macros) can reveal implementation-defined widths or extension usage in typedefs or attributes.\n\n- vxCpuEnabledGet / cpuset_t: VxWorks-specific API and type. cpuset_t could be an implementation-specific type or typedef that uses compiler extensions (bitset, attributes); vxCpuEnabledGet signature may include nonstandard calling conventions or attributes on some targets.\n\n- pstat_getdynamic / struct pst_dynamic: HP-UX-specific API and struct \u2014 include to check whether their declarations use any compiler extensions or attributes.\n\n- memset / size_t / NULL: Standard C symbols used in the function. Include them to confirm that the code uses only standard library facilities here and to distinguish standard behavior from any extension coming from other symbols.\n\nOverall: focus is on symbols that can hide compiler-specific annotations (calling conventions like __stdcall / WINAPI), nonstandard pointer conversions (FARPROC / GetProcAddress), or platform headers that may contain documented compiler extensions. These symbols must be inspected to decide whether the target function uses language extensions as defined by compiler documentation."
}