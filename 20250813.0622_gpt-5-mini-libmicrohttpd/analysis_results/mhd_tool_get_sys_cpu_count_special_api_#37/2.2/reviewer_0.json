{
  "user_message": "An agent A claimed that the following mhd_tool_get_sys_cpu_count_special_api_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_sys_cpu_count_special_api_.\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to memset((void *)&sysInfo, 0, sizeof(sysInfo)) is redundant immediately prior to ptrGetNativeSystemInfo(&sysInfo). The Windows API GetNativeSystemInfo fills the SYSTEM_INFO structure completely (including dwNumberOfProcessors, which is the only field subsequently used), so zeroing the structure beforehand does not affect program behaviour. Therefore this executed memset is dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_tool_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/298.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n  mhd_tool_log(\"ENTER: mhd_tool_get_sys_cpu_count_special_api_, initial ret=%d\", ret);\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    mhd_tool_log(\"pstat: about to memset psd_data at %p, size=%zu\", (void *)&psd_data, sizeof(psd_data));\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    mhd_tool_log(\"pstat: after memset psd_data.psd_proc_cnt=%ld (may be 0)\", (long) psd_data.psd_proc_cnt);\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      mhd_tool_log(\"pstat: pstat_getdynamic succeeded, psd_proc_cnt=%ld\", (long) psd_data.psd_proc_cnt);\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n      mhd_tool_log(\"pstat: computed ret=%d\", ret);\n    }\n    else\n    {\n      mhd_tool_log(\"pstat: pstat_getdynamic failed or returned unexpected value\");\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    mhd_tool_log(\"vxworks: vxCpuEnabledGet returned enb_set=%llu (raw)\", (unsigned long long) enb_set);\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n    mhd_tool_log(\"vxworks: counted CPUs ret=%d\", ret);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    mhd_tool_log(\"win32: LoadLibraryA kernel32.dll returned %p\", (void *) k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      mhd_tool_log(\"win32: GetProcAddress(GetActiveProcessorCount) returned %p\", (void *) ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        mhd_tool_log(\"win32: GetActiveProcessorCount returned %lu\", (unsigned long) res);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n        mhd_tool_log(\"win32: after GetActiveProcessorCount ret=%d\", ret);\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      mhd_tool_log(\"win32: GetProcAddress(GetNativeSystemInfo) returned %p\", (void *) ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        mhd_tool_log(\"win32: about to memset sysInfo at %p, size=%zu\", (void *)&sysInfo, sizeof(sysInfo));\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        mhd_tool_log(\"win32: after memset sysInfo.dwNumberOfProcessors=%lu (expected 0)\", (unsigned long) sysInfo.dwNumberOfProcessors);\n\n        ptrGetNativeSystemInfo (&sysInfo);\n        mhd_tool_log(\"win32: after GetNativeSystemInfo sysInfo.dwNumberOfProcessors=%lu\", (unsigned long) sysInfo.dwNumberOfProcessors);\n\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n        mhd_tool_log(\"win32: computed ret from GetNativeSystemInfo=%d\", ret);\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary (k32hndl);\n      mhd_tool_log(\"win32: Freed kernel32.dll handle %p\", (void *) k32hndl);\n    }\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    mhd_tool_log(\"win32: fallback path about to memset sysInfo at %p, size=%zu\", (void *)&sysInfo, sizeof(sysInfo));\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    mhd_tool_log(\"win32: fallback after memset sysInfo.dwNumberOfProcessors=%lu (expected 0)\", (unsigned long) sysInfo.dwNumberOfProcessors);\n    GetSystemInfo (&sysInfo);\n    mhd_tool_log(\"win32: after GetSystemInfo sysInfo.dwNumberOfProcessors=%lu\", (unsigned long) sysInfo.dwNumberOfProcessors);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n    mhd_tool_log(\"win32: fallback computed ret=%d\", ret);\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n  {\n    mhd_tool_log(\"EXIT: mhd_tool_get_sys_cpu_count_special_api_, returning -1\");\n    return -1;\n  }\n  mhd_tool_log(\"EXIT: mhd_tool_get_sys_cpu_count_special_api_, returning %d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_sys_cpu_count_special_api_. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Verdict: The agent A\u2019s report is correct in principle. The memset((void *)&sysInfo, 0, sizeof(sysInfo)) immediately prior to calling ptrGetNativeSystemInfo(&sysInfo) is executed, and according to the documented behaviour of the Windows API GetNativeSystemInfo the call fills the SYSTEM_INFO structure (including dwNumberOfProcessors, the field later used). Therefore, removing that memset would not change program behaviour in the normal, documented case \u2014 which matches MISRA C 2023 Rule 2.2\u2019s definition of dead code (an executed operation whose removal would not affect behaviour). \n\nCaveats: This conclusion relies on the API contract that ptrGetNativeSystemInfo always writes the relevant fields. The memset may be present as defensive programming against nonconforming platform implementations, older/third\u2011party replacements, or to avoid reads of uninitialised memory in error scenarios; such justifications should be documented. If that defensive intent exists, keep the memset but add a comment/justification or a directive for static analysis suppression. Otherwise the memset can be removed (or commented) to satisfy Rule 2.2.\n\nNote on the test: The empty log produced by the supplied test code does not invalidate the static reasoning above \u2014 it only shows the test did not exercise this code path, so it cannot be used as proof that the memset has (or has not) any runtime effect in a particular execution.\n"
}