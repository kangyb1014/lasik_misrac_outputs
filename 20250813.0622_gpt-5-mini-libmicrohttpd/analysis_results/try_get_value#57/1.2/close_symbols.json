{
  "user_message": "Target function code is:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_get_value': {'callees': [], 'callers': ['process_multipart_headers']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "strlen",
    "strstr",
    "strchr",
    "malloc",
    "memcpy",
    "NULL",
    "size_t",
    "<string.h>",
    "<stdlib.h>",
    "<stddef.h>"
  ],
  "explanation": "To decide whether try_get_value uses any compiler language extensions you must inspect the external symbols and their declarations/definitions to see if they are implemented using compiler-specific extensions (builtins, macros, inline functions with compiler attributes, inline assembly, non\u2011standard keywords, etc.). Each listed symbol is required for that inspection:\n\n- strlen, strstr, strchr, memcpy: these library functions may be provided as macros, inline wrappers, or compiler builtins (e.g. __builtin_strlen) in <string.h>. If they map to compiler builtins or non\u2011standard inline implementations the code could be relying on a language extension. You need their actual declarations/definitions from the implementation.\n\n- malloc: often provided via <stdlib.h>, and implementations may use compiler extensions or attributes (or be macros/wrappers). Inspecting malloc's declaration/definition is necessary to determine whether use of malloc introduces a language extension.\n\n- NULL: the macro/identifier for NULL can be defined in implementation\u2011specific ways; verify its definition to ensure no non\u2011standard extension is used.\n\n- size_t: check where and how size_t is defined (typically in <stddef.h> or other headers). Some toolchains may typedef it using compiler extensions; the exact typedef is needed to rule out extensions.\n\n- <string.h>, <stdlib.h>, <stddef.h>: the header files themselves must be inspected because they contain the prototypes/macros/type definitions referenced above. Compiler/vendor header implementations sometimes use language extensions in those headers; the headers are required to establish whether any extension is in use.\n\n(Other symbols in the static call graph such as callers are not needed to determine whether try_get_value itself uses language extensions.)"
}