{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential out-of-bounds access if pos->value is not NUL-terminated and MHD_str_has_token_caseless_ uses C string functions that expect NUL termination. In MHD_lookup_header_token_ci the code passes pos->value (no length parameter) and a token length; there is no check that pos->value is a terminated string. If MHD_str_has_token_caseless_ internally calls functions from <string.h> that scan until a NUL (e.g. strlen, strstr, strchr, strcasestr, strcmp, etc.), it can read past the allocated buffer of pos->value leading to an access beyond object bounds. Therefore the rule can be violated in that scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_151 (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  /* Log entry and key state */\n  mhd_log_151 (\"keepalive_possible: enter conn=%p, c->keepalive=%d, r=%p\\n\",\n               (void *) connection, (int) connection->keepalive, (void *) r);\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_log_151 (\"keepalive_possible: early return MUST_CLOSE (keepalive flag)\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n\n    mhd_log_151 (\"keepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=%p, upgrade_handler=%p\\n\",\n                 (void *) connection, (void *) r->upgrade_handler);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_log_151 (\"keepalive_possible: read_closed=%d discard_request=%d -> MUST_CLOSE\\n\",\n                 (int) c->read_closed, (int) c->discard_request);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_log_151 (\"keepalive_possible: response flags indicate HTTP/1.0 compat strict -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_log_151 (\"keepalive_possible: response has connection: close -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_log_151 (\"keepalive_possible: HTTP version not supported (rq.http_ver=%d) -> MUST_CLOSE\\n\",\n                 (int) c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  /* Log before calling header token lookup; this is the call that can lead\n   * to the scenario described by the reviewer (potential out-of-bounds if\n   * header value is not NUL-terminated and the lookup uses C string funcs). */\n  mhd_log_151 (\"keepalive_possible: about to call MHD_lookup_header_s_token_ci for 'Connection: close' on conn=%p\\n\",\n               (void *) connection);\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_log_151 (\"keepalive_possible: MHD_lookup_header_s_token_ci returned true for token 'close' on conn=%p -> MUST_CLOSE\\n\",\n                 (void *) connection);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    /* Log the 1.0 branch decision */\n    mhd_log_151 (\"keepalive_possible: HTTP/1.0 server or request (rq.http_ver=%d) -> checking for Keep-Alive header\\n\",\n                 (int) connection->rq.http_ver);\n\n    mhd_log_151 (\"keepalive_possible: about to call MHD_lookup_header_s_token_ci for 'Connection: Keep-Alive' on conn=%p\\n\",\n                 (void *) connection);\n\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_log_151 (\"keepalive_possible: MHD_lookup_header_s_token_ci returned true for token 'Keep-Alive' on conn=%p -> USE_KEEPALIVE\\n\",\n                   (void *) connection);\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_log_151 (\"keepalive_possible: no Keep-Alive token found on HTTP/1.0 -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_log_151 (\"keepalive_possible: HTTP/1.1 compatible -> USE_KEEPALIVE\\n\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_log_151 (\"keepalive_possible: default case -> MUST_CLOSE\\n\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nkeepalive_possible: enter conn=0x55c09d960870, c->keepalive=0, r=0x55c09d968b40\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c09d960870, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x55c09d969500, c->keepalive=0, r=0x55c09d969750\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c09d969500, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x55c09d960b10, c->keepalive=0, r=0x55c09d969d10\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c09d960b10, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd84000b90, c->keepalive=0, r=0x7fcd7c000b90\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd84000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd84000b90, c->keepalive=0, r=0x7fcd78000b90\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd84000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd84000b90, c->keepalive=0, r=0x7fcd78000b90\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd84000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd84000b90, c->keepalive=0, r=0x7fcd84008f40\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd84000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd84000b90, c->keepalive=0, r=0x7fcd84008f40\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd84000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd78000d90, c->keepalive=0, r=0x7fcd78000b70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd78000d90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd78000d90, c->keepalive=0, r=0x7fcd78000b70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd78000d90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd70000b90, c->keepalive=0, r=0x7fcd70008e40\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd70000b90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd78000d90, c->keepalive=0, r=0x7fcd78000b70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd78000d90, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd78000b70, c->keepalive=0, r=0x7fcd78008e20\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd78000b70, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x7fcd78000b70, c->keepalive=0, r=0x7fcd78008e20\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcd78000b70, upgrade_handler=0x55c08cf32dc2\nkeepalive_possible: enter conn=0x55c437ff0090, c->keepalive=0, r=0x55c437ff1360\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c437ff0090, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x55c437ff1d20, c->keepalive=0, r=0x55c437ff1f70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c437ff1d20, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x55c437ff0330, c->keepalive=0, r=0x55c437ff2530\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x55c437ff0330, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x7fcf28000b90, c->keepalive=0, r=0x7fcf20000b70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcf28000b90, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x7fcf28000b90, c->keepalive=0, r=0x7fcf20000b90\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcf28000b90, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x7fcf28000b90, c->keepalive=0, r=0x7fcf20000b70\nkeepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=0x7fcf28000b90, upgrade_handler=0x55c3fba5bdc2\nkeepalive_possible: enter conn=0x7fcf28000b90, c->keepalive=0, r=0x7fcf28001f40\nkeepalive_possible: upgrade handler present, MUST_UPGRAD\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The provided test logs show that every invocation of keepalive_possible took the early-return path triggered by a non-NULL r->upgrade_handler (log lines: \"upgrade handler present, MUST_UPGRADE return...\"). In the instrumented code the calls to MHD_lookup_header_s_token_ci (and the corresponding \"about to call MHD_lookup_header_s_token_ci\" log lines) would appear only if execution reached the header-inspection paths. No such \"about to call\" or subsequent header-lookup log entries are present in the output, which means the code paths that could invoke string-handling routines on pos->value were never executed in these tests. Given the stated assumptions (exhaustive test coverage, no missing scenarios) the observed behavior invalidates the claimed out-of-bounds scenario for this code: the potentially problematic header-lookup is never reached, so no access beyond object bounds occurs in these runs. Therefore the report of a MISRA C 2023 Rule 21.17 violation is not supported by the test output."
}