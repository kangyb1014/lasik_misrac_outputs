{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential out-of-bounds access if pos->value is not NUL-terminated and MHD_str_has_token_caseless_ uses C string functions that expect NUL termination. In MHD_lookup_header_token_ci the code passes pos->value (no length parameter) and a token length; there is no check that pos->value is a terminated string. If MHD_str_has_token_caseless_ internally calls functions from <string.h> that scan until a NUL (e.g. strlen, strstr, strchr, strcasestr, strcmp, etc.), it can read past the allocated buffer of pos->value leading to an access beyond object bounds. Therefore the rule can be violated in that scenario.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified keepalive_possible code that contains useful probe functions that print useful logs to a file \"/tmp/logs/151.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of keepalive_possible as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of keepalive_possible:\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\nPlease provide the modified keepalive_possible code.\n",
  "test_code": "static void\nmhd_log_151 (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  /* Log entry and key state */\n  mhd_log_151 (\"keepalive_possible: enter conn=%p, c->keepalive=%d, r=%p\\n\",\n               (void *) connection, (int) connection->keepalive, (void *) r);\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_log_151 (\"keepalive_possible: early return MUST_CLOSE (keepalive flag)\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n\n    mhd_log_151 (\"keepalive_possible: upgrade handler present, MUST_UPGRADE return. conn=%p, upgrade_handler=%p\\n\",\n                 (void *) connection, (void *) r->upgrade_handler);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_log_151 (\"keepalive_possible: read_closed=%d discard_request=%d -> MUST_CLOSE\\n\",\n                 (int) c->read_closed, (int) c->discard_request);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_log_151 (\"keepalive_possible: response flags indicate HTTP/1.0 compat strict -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_log_151 (\"keepalive_possible: response has connection: close -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_log_151 (\"keepalive_possible: HTTP version not supported (rq.http_ver=%d) -> MUST_CLOSE\\n\",\n                 (int) c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  /* Log before calling header token lookup; this is the call that can lead\n   * to the scenario described by the reviewer (potential out-of-bounds if\n   * header value is not NUL-terminated and the lookup uses C string funcs). */\n  mhd_log_151 (\"keepalive_possible: about to call MHD_lookup_header_s_token_ci for 'Connection: close' on conn=%p\\n\",\n               (void *) connection);\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_log_151 (\"keepalive_possible: MHD_lookup_header_s_token_ci returned true for token 'close' on conn=%p -> MUST_CLOSE\\n\",\n                 (void *) connection);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    /* Log the 1.0 branch decision */\n    mhd_log_151 (\"keepalive_possible: HTTP/1.0 server or request (rq.http_ver=%d) -> checking for Keep-Alive header\\n\",\n                 (int) connection->rq.http_ver);\n\n    mhd_log_151 (\"keepalive_possible: about to call MHD_lookup_header_s_token_ci for 'Connection: Keep-Alive' on conn=%p\\n\",\n                 (void *) connection);\n\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_log_151 (\"keepalive_possible: MHD_lookup_header_s_token_ci returned true for token 'Keep-Alive' on conn=%p -> USE_KEEPALIVE\\n\",\n                   (void *) connection);\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_log_151 (\"keepalive_possible: no Keep-Alive token found on HTTP/1.0 -> MUST_CLOSE\\n\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_log_151 (\"keepalive_possible: HTTP/1.1 compatible -> USE_KEEPALIVE\\n\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_log_151 (\"keepalive_possible: default case -> MUST_CLOSE\\n\");\n  return MHD_CONN_MUST_CLOSE;\n}\n"
}