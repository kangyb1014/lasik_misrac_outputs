{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If MHD_STATICSTR_LEN_ is implemented as something like (sizeof(s)-1) (the common pattern for static string macros), the macro MHD_lookup_header_s_token_ci(c,h,tkn) will pass those computed lengths to MHD_lookup_header_token_ci. When used correctly with compile-time string literals (e.g. MHD_HTTP_HEADER_CONNECTION and \"close\") this is safe. However, if a caller mistakenly passes non\u2011literal pointers (runtime char * variables) the sizeof(s) in the macro yields the size of the pointer (not the string length) and the resulting header_len/token_len will be incorrect. That incorrect length can cause the downstream functions (e.g. MHD_str_has_token_caseless_ or other string/comparison helpers that use the provided lengths) to read or compare more bytes than actually allocated for the pointed\u2011to token/header, leading to out\u2011of\u2011bounds accesses of the objects referenced by their pointer parameters and thus violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_keepalive_state (const char *stage,\n                           struct MHD_Connection *c,\n                           struct MHD_Response *r,\n                           const char *header,\n                           const char *token)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Print key pointers and a few fields that help reproduce the scenario.\n   * We do not dereference header/token contents to avoid any out-of-bounds\n   * reads; we only log the pointer values and connection/response state.\n   */\n  fprintf (f, \"[keepalive_probe] stage=%s\\n\", stage);\n  fprintf (f, \"  conn=%p rp.response=%p\\n\", (void *)c, (void *)r);\n  if (NULL != c)\n  {\n    /* print some connection/request fields */\n    fprintf (f, \"  conn->keepalive=%d conn->read_closed=%d conn->discard_request=%d conn->stop_with_error=%d\\n\",\n             (int)c->keepalive,\n             (int)c->read_closed,\n             (int)c->discard_request,\n             (int)c->stop_with_error);\n    fprintf (f, \"  conn->rq.http_ver=%u\\n\", (unsigned)c->rq.http_ver);\n  }\n  if (NULL != r)\n  {\n    fprintf (f, \"  response flags=0x%08x flags_auto=0x%08x upgrade_handler=%p\\n\",\n             (unsigned)r->flags,\n             (unsigned)r->flags_auto,\n             (void *)r->upgrade_handler);\n  }\n\n  /* Log the header and token pointer values. This is important evidence\n   * for the sizeof-macro misuse: if a caller passed a runtime pointer, its\n   * address will usually differ from addresses of static literals.\n   */\n  fprintf (f, \"  header_ptr=%p token_ptr=%p\\n\", (const void *)header, (const void *)token);\n\n  fclose (f);\n}\nstatic void\nmhd_probe_keepalive_result (struct MHD_Connection *c,\n                             enum MHD_ConnKeepAlive result,\n                             const char *reason)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"[keepalive_result] conn=%p result=%d reason=%s\\n\", (void *)c, (int)result, reason);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_probe_keepalive_state (\"early_must_close_keepalive_flag\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"keepalive flag == MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    mhd_probe_keepalive_state (\"upgrade_handler_present\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_UPGRADE, \"upgrade_handler present\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_probe_keepalive_state (\"read_closed_or_discard_request\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"read_closed or discard_request\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_probe_keepalive_state (\"response_flag_http_1_0_compatible_strict\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"response flag HTTP/1.0 compatible strict\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_probe_keepalive_state (\"response_has_connection_close\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"response has connection: close\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_probe_keepalive_state (\"http_version_not_supported\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"http version not supported\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  /* Probe before calling the header/token lookup that is implicated in the\n   * MISRA 21.17 violation scenario. We log pointer values for header and\n   * token so that downstream analysis can detect misuse of sizeof-based\n   * static-string macros when callers supply runtime pointers.\n   */\n  mhd_probe_keepalive_state (\"before_lookup_close\", c, r, MHD_HTTP_HEADER_CONNECTION, \"close\");\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"request header contains close token\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    mhd_probe_keepalive_state (\"http_1_0_path_before_keepalive_lookup\", c, r, MHD_HTTP_HEADER_CONNECTION, \"Keep-Alive\");\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_probe_keepalive_result (c, MHD_CONN_USE_KEEPALIVE, \"1.0 request with Keep-Alive header\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"1.0 request without Keep-Alive header\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_probe_keepalive_state (\"http_1_1_compatible\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_USE_KEEPALIVE, \"HTTP/1.1 compatible\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_probe_keepalive_state (\"default_must_close\", c, r, NULL, NULL);\n  mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"default case\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x55f907cde870 rp.response=0x55f907ce6b40\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x55f907cde870 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x55f907ce7500 rp.response=0x55f907ce7750\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x55f907ce7500 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x55f907cdeb10 rp.response=0x55f907ce7d10\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x55f907cdeb10 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.response=0x7f2374000b90\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f236c000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.response=0x7f2374000b90\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f236c000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.response=0x7f2370000b90\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f236c000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.response=0x7f236c008f40\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f236c000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.response=0x7f236c008f40\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f236c000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f2364000b90 rp.response=0x7f2364008e20\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f2364000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f2364000b90 rp.response=0x7f2364008e20\n  conn->keepalive=0 conn->read_closed=0 conn->discard_request=1 conn->stop_with_error=0\n  conn->rq.http_ver=3\n  response flags=0x00000000 flags_auto=0x00000001 upgrade_handler=0x55f8d049edc2\n  header_ptr=(nil) token_ptr=(nil)\n[keepalive_result] conn=0x7f2364000b90 result=2 reason=upgrade_handler present\n[keepalive_probe] stage=upgrade_handler_present\n  conn=0x7f236c000b90 rp.res\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. keepalive_possible invokes MHD_lookup_header_s_token_ci with compile-time string literals (MHD_HTTP_HEADER_CONNECTION, \"close\", \"Keep-Alive\"). The common sizeof(s)-1 pattern in a MHD_STATICSTR_LEN_ macro is safe for string literals because sizeof yields the actual array size. The MISRA 21.17 hazard described by agent A (sizeof returning pointer size when a runtime char * is passed) is a misuse of that macro by a caller supplying non-literal pointers, but it does not occur in keepalive_possible itself. The supplied test logs show only the early/upgrade_handler path (probes logged NULL header/token pointers) and provide no evidence of an out-of-bounds access originating from keepalive_possible. Therefore the specific claim that keepalive_possible violates MISRA C 2023 Rule 21.17 is incorrect."
}