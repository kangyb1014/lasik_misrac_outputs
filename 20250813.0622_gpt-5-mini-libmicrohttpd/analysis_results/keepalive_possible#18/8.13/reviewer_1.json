{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function takes a non-const pointer parameter (struct MHD_Connection *connection) and uses it only for read access in the fragment (reading connection->rq.http_ver and connection->rp.response->flags). According to MISRA C 2023 Rule 8.13 these pointers should be to const-qualified types when possible (e.g. const struct MHD_Connection *connection and const struct MHD_Response * for rp.response) unless the object is intended to be modified or passed to callees that require a non-const pointer. Since the shown code only reads fields, this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const struct MHD_Connection *c,\n                const struct MHD_Response *r,\n                const char *stage,\n                const char *decision)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  /* Log the main fields that matter for the keepalive decision. */\n  fprintf (f,\n           \"stage=%s, decision=%s, keepalive=%d, rq_http_ver=%d, \"\n           \"stop_with_error=%d, discard_request=%d, read_closed=%d, \"\n           \"r_flags=0x%X, r_flags_auto=0x%X, upgrade_handler=%p\\n\",\n           stage ? stage : \"(null)\",\n           decision ? decision : \"(none)\",\n           (int) c->keepalive,\n           (int) c->rq.http_ver,\n           (int) c->stop_with_error,\n           (int) c->discard_request,\n           (int) c->read_closed,\n           (unsigned) r->flags,\n           (unsigned) r->flags_auto,\n           (void *) r->upgrade_handler);\n\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  /* Log initial state */\n  mhd_log_probe (c, r, \"start\", NULL);\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_log_probe (c, r, \"early_keepalive_must_close\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    mhd_log_probe (c, r, \"upgrade_handler_present\", \"MHD_CONN_MUST_UPGRADE\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_log_probe (c, r, \"read_closed_or_discard\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_log_probe (c, r, \"http_1_0_compatible_strict\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_log_probe (c, r, \"has_connection_close_flag\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_log_probe (c, r, \"http_version_not_supported\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_log_probe (c, r, \"connection_header_close\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_log_probe (c, r, \"http_1_0_keep_alive_header_present\", \"MHD_CONN_USE_KEEPALIVE\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_log_probe (c, r, \"http_1_0_no_keep_alive\", \"MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_log_probe (c, r, \"http_1_1_compatible\", \"MHD_CONN_USE_KEEPALIVE\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_log_probe (c, r, \"final_fallback\", \"MHD_CONN_MUST_CLOSE\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=start, decision=(none), keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read_closed=0, r_flags=0x0, r_flags_auto=0x1, upgrade_handler=0x55d364187dc2\nstage=upgrade_handler_present, decision=MHD_CONN_MUST_UPGRADE, keepalive=0, rq_http_ver=3, stop_with_error=0, discard_request=1, read\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. keepalive_possible is a static (file-local) function whose parameter and the derived response pointer are only used for read access in the shown code: fields are read and passed to helpers, no writes occur through connection or r, and the log output confirms only reads of the relevant members. Under MISRA C 2023 Rule 8.13 a pointer should be to a const-qualified type whenever possible, so the parameter should be declared as const struct MHD_Connection *connection and the alias r as const struct MHD_Response * (or equivalent const qualifications). Therefore the agent A report that this code violates Rule 8.13 is correct."
}