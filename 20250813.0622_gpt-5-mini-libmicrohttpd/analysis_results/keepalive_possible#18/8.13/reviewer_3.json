{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter is declared as 'struct MHD_Connection *connection' (a pointer to a non-const type), yet the function only reads fields from the connection and never modifies the pointed-to object. The local alias 'struct MHD_Connection *const c = connection' makes the pointer itself const, not the pointee. Per MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type when possible (e.g. 'const struct MHD_Connection *connection'). Unless downstream called functions require a mutable pointer, this signature violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_conn_state(const char *where, struct MHD_Connection *c)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  struct MHD_Response *r = NULL;\n  if (NULL != c)\n    r = c->rp.response;\n\n  fprintf(f, \"keepalive_possible: %s\\n\", where);\n  fprintf(f, \"  connection=%p\\n\", (void *) c);\n  if (NULL != c)\n  {\n    fprintf(f, \"  keepalive=%d stop_with_error=%d discard_request=%d read_closed=%d http_ver=%d\\n\",\n            (int) c->keepalive,\n            (int) c->stop_with_error,\n            (int) c->discard_request,\n            (int) c->read_closed,\n            (int) c->rq.http_ver);\n  }\n  else\n  {\n    fprintf(f, \"  <no connection>\\n\");\n  }\n\n  if (NULL != r)\n  {\n    fprintf(f, \"  response=%p upgrade_handler=%p flags_auto=0x%08x flags=0x%08x\\n\",\n            (void *) r,\n            (void *) r->upgrade_handler,\n            (unsigned) r->flags_auto,\n            (unsigned) r->flags);\n  }\n  else\n  {\n    fprintf(f, \"  response=NULL\\n\");\n  }\n\n  fprintf(f, \"--\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  log_conn_state(\"entry\", c);\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    log_conn_state(\"must_close_due_to_keepalive_flag\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    log_conn_state(\"must_upgrade_due_to_upgrade_handler\", c);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    log_conn_state(\"must_close_due_to_read_closed_or_discard\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    log_conn_state(\"must_close_due_to_http_1_0_compatible_strict\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    log_conn_state(\"must_close_due_to_connection_close_header_auto\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    log_conn_state(\"must_close_due_to_unsupported_http_ver\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    log_conn_state(\"must_close_due_to_connection_close_header\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      log_conn_state(\"use_keepalive_due_to_keep_alive_header_http_1_0\", c);\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    log_conn_state(\"must_close_http_1_0_no_keepalive\", c);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    log_conn_state(\"use_keepalive_http_1_1_compatible\", c);\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  log_conn_state(\"must_close_fallback\", c);\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nkeepalive_possible: entry\n  connection=0x5562b8876870\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887eb40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x5562b8876870\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887eb40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x5562b887f500\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887f750 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x5562b887f500\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887f750 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x5562b8876b10\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887fd10 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x5562b8876b10\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x5562b887fd10 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe54c000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe54c000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe548000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe548000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe548000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe548000b90 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe544008f40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe544008f40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe544008f40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: must_upgrade_due_to_upgrade_handler\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe544008f40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 flags=0x00000000\n--\nkeepalive_possible: entry\n  connection=0x7fe544000b90\n  keepalive=0 stop_with_error=0 discard_request=1 read_closed=0 http_ver=3\n  response=0x7fe544008f40 upgrade_handler=0x5562932d4dc2 flags_auto=0x00000001 \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's assessment is correct. The function never modifies the object pointed to by 'connection' \u2014 it only reads fields and passes the pointer for read-only checks \u2014 yet the parameter is declared as 'struct MHD_Connection *connection'. The local alias 'struct MHD_Connection *const c' only makes the pointer itself const, not the pointee. Under MISRA C 2023 Rule 8.13, the pointer should instead point to a const-qualified type when possible (e.g. 'const struct MHD_Connection *connection'). The provided exhaustive test output shows only reads of the connection and response data and no writes, so the parameter can and should be const-qualified. Therefore the reported violation is correct."
}