{
  "user_message": "An agent A claimed that the following parse_dauth_params code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of parse_dauth_params.\n```c\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n      return false; /* The equal sign is not allowed as the first character */\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n          return false; /* No equal sign after parameter name, broken data */\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n          return false; /* No equal sign, broken data */\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n              return false; /* Binary zero in parameter value */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero in parameter value */\n            i++;\n          }\n          if (';' == str[i])\n            return false;  /* Semicolon in parameter value */\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n          return false; /* Garbage after parameter value */\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n          return false; /* Not allowed characters */\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero is not allowed */\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes &pdauth->qop_raw (type struct MHD_RqDAuthParam *). If the function get_rq_dauth_qop is declared as taking a non-const pointer (e.g. enum MHD_DigestAuthQOP get_rq_dauth_qop(struct MHD_RqDAuthParam *p)) but only reads the parameter (does not modify it), then the pointer parameter should be const-qualified. In that case the code violates MISRA C 2023 Rule 8.13. To conform, change the function prototype to accept const struct MHD_RqDAuthParam * (and leave the call unchanged).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_printf (const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n\n  /* Try to create the directory if it does not exist. Ignore errors. */\n  (void) mkdir(\"/tmp/logs\", 0777);\n\n  f = fopen(\"/tmp/logs/155.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_start (ap, fmt);\n  (void) vfprintf (f, fmt, ap);\n  va_end (ap);\n  (void) fputc('\\n', f);\n  (void) fclose (f);\n}\nstatic void\nmhd_log_pdauth_header (const char *str, size_t str_len, const struct MHD_RqDAuth *pdauth)\n{\n  mhd_log_printf (\"parse_dauth_params ENTRY: str=%p, str_len=%zu, pdauth=%p\",\n                  (const void *) str, str_len, (const void *) pdauth);\n  if (NULL != pdauth)\n  {\n    mhd_log_printf (\"pdauth pointers: &nonce=%p, &opaque=%p, &algorithm=%p, &response=%p,\",\n                    (const void *) &pdauth->nonce,\n                    (const void *) &pdauth->opaque,\n                    (const void *) &pdauth->algo3, /* best-effort pointer reporting */\n                    (const void *) &pdauth->response);\n    mhd_log_printf (\"                 &username=%p, &username_ext=%p, &realm=%p, &uri=%p\",\n                    (const void *) &pdauth->username,\n                    (const void *) &pdauth->username_ext,\n                    (const void *) &pdauth->realm,\n                    (const void *) &pdauth->uri);\n    mhd_log_printf (\"                 &qop_raw=%p, &cnonce=%p, &nc=%p\",\n                    (const void *) &pdauth->qop_raw,\n                    (const void *) &pdauth->cnonce,\n                    (const void *) &pdauth->nc);\n  }\n}\nstatic void\nmhd_log_qop_snapshot (const char *label, const struct MHD_RqDAuthParam *qop)\n{\n  if (NULL == qop)\n  {\n    mhd_log_printf (\"%s: qop param is NULL\", label);\n    return;\n  }\n  mhd_log_printf (\"%s: qop_param=%p, value.str=%p, value.len=%zu, quoted=%d\",\n                  label, (const void *) qop,\n                  (const void *) qop->value.str,\n                  qop->value.len,\n                  (int) qop->quoted);\n}\nstatic void\nmhd_log_token_match (size_t p, const struct _MHD_cstr_w_len *tk_name, size_t value_start, size_t value_len, bool quoted)\n{\n  if (NULL == tk_name)\n    return;\n  mhd_log_printf (\"token match: index=%zu, name=\\\"%.*s\\\" (len=%zu), value_start=%zu, value_len=%zu, quoted=%d\",\n                  p,\n                  (int) tk_name->len, tk_name->str, tk_name->len,\n                  value_start, value_len, (int) quoted);\n}\nstatic void\nmhd_log_before_return (bool result)\n{\n  mhd_log_printf (\"parse_dauth_params EXIT: returning %s\", result ? \"true\" : \"false\");\n}\n\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Log entry and initial pdauth/qop_raw snapshot */\n  mhd_log_pdauth_header (str, str_len, pdauth);\n  mhd_log_qop_snapshot (\"INITIAL qop_raw\", &pdauth->qop_raw);\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n    {\n      mhd_log_printf (\"parse error: '=' at first char (i=%zu)\", i);\n      mhd_log_before_return (false);\n      return false; /* The equal sign is not allowed as the first character */\n    }\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n        {\n          mhd_log_printf (\"parse error: no '=' after token '%.*s' (i=%zu)\",\n                          (int) tk_name->len, tk_name->str, i);\n          mhd_log_before_return (false);\n          return false; /* No equal sign after parameter name, broken data */\n        }\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n        {\n          mhd_log_printf (\"parse error: missing '=' after token '%.*s' (i=%zu)\",\n                          (int) tk_name->len, tk_name->str, i);\n          mhd_log_before_return (false);\n          return false; /* No equal sign, broken data */\n        }\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n            {\n              mhd_log_printf (\"parse error: binary zero in quoted value (i=%zu)\", i);\n              mhd_log_before_return (false);\n              return false; /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_log_printf (\"parse error: no closing quote (i=%zu)\", i);\n            mhd_log_before_return (false);\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_log_printf (\"parse error: binary zero in unquoted value (i=%zu)\", i);\n              mhd_log_before_return (false);\n              return false;  /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          if (';' == str[i])\n          {\n            mhd_log_printf (\"parse error: semicolon in parameter value (i=%zu)\", i);\n            mhd_log_before_return (false);\n            return false;  /* Semicolon in parameter value */\n          }\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n        {\n          mhd_log_printf (\"parse error: garbage after parameter value (i=%zu, ch=0x%02x)\", i, (unsigned) (unsigned char) str[i]);\n          mhd_log_before_return (false);\n          return false; /* Garbage after parameter value */\n        }\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        /* Log specific token matches; especially note qop token (index 8) */\n        mhd_log_token_match (p, tk_name, value_start, value_len, quoted);\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n        {\n          mhd_log_printf (\"parse error: invalid char while skipping unknown token (i=%zu)\", i);\n          mhd_log_before_return (false);\n          return false; /* Not allowed characters */\n        }\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_log_printf (\"parse error: binary zero in unknown token quoted part (i=%zu)\", i);\n              mhd_log_before_return (false);\n              return false;  /* Binary zero is not allowed */\n            }\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_log_printf (\"parse error: no closing quote in unknown token (i=%zu)\", i);\n            mhd_log_before_return (false);\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  /* Log algorithm processing */\n  mhd_log_printf (\"Calling get_rq_dauth_algo with algorithm param at %p\", (const void *) &algorithm);\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  mhd_log_printf (\"get_rq_dauth_algo returned %d\", (int) pdauth->algo3);\n\n  /* For qop: snapshot before call, call the function into a temp, and\n     snapshot after call to detect any unintended modification. */\n  {\n    struct MHD_RqDAuthParam qop_before_copy;\n\n    /* Copy the observable qop_raw fields */\n    qop_before_copy = pdauth->qop_raw;\n    mhd_log_qop_snapshot (\"BEFORE get_rq_dauth_qop\", &qop_before_copy);\n\n    /* Call the qop parser and capture its return value for logging. */\n    enum MHD_DigestAuthQOP qop_val = get_rq_dauth_qop (&pdauth->qop_raw);\n    mhd_log_printf (\"get_rq_dauth_qop returned %d\", (int) qop_val);\n\n    /* Snapshot after call */\n    mhd_log_qop_snapshot (\"AFTER get_rq_dauth_qop\", &pdauth->qop_raw);\n\n    /* Assign to pdauth->qop preserving original semantics */\n    pdauth->qop = qop_val;\n  }\n\n  mhd_log_before_return (true);\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for parse_dauth_params. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 R.8.13 concerns pointer declarations: a pointer should point to a const-qualified type whenever possible. The code shown does not itself declare a pointer to a non-const when it could be const in a way that violates the rule. The expression &pdauth->qop_raw passed to get_rq_dauth_qop yields a value of type struct MHD_RqDAuthParam *; whether there is an R.8.13 violation depends on the declaration of get_rq_dauth_qop, not on this call site. If get_rq_dauth_qop is declared to take struct MHD_RqDAuthParam * but in its implementation it only reads the pointee, then that function\u2019s parameter declaration should be changed to accept const struct MHD_RqDAuthParam * to satisfy R.8.13. Conversely, if get_rq_dauth_qop legitimately modifies the structure, the non-const parameter is correct and no violation occurs.\n\nTherefore the agent A\u2019s report that parse_dauth_params itself violates MISRA R.8.13 is not correct. The potential violation would be in the callee\u2019s prototype/definition (get_rq_dauth_qop), which must be inspected and adjusted if it does not modify the pointee."
}