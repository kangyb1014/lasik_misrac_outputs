{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code reads buf[0] without guaranteeing that the internal buffer contains at least one byte. If pp->buffer_pos == 0 (for example if pp->buffer_size == 0 or memcpy copied 0 bytes into the buffer so pp->buffer_pos remains 0), the test if (buf[0] == '-') will dereference memory outside the valid buffer region. This can occur when max == 0 and state_changed was non\u2011zero so the function proceeds into the state machine without data. That out\u2011of\u2011bounds access can be triggered after the prior memcpy/memmove operations, so Rule 21.17 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified post_process_multipart code that contains useful probe functions that print useful logs to a file \"/tmp/logs/455.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of post_process_multipart as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of post_process_multipart:\n```c\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified post_process_multipart code.\n",
  "test_code": "static void\nlog_pp_state (struct MHD_PostProcessor *pp,\n              const char *where,\n              const char *buf,\n              size_t ioff,\n              size_t poff,\n              size_t max,\n              size_t post_data_len)\n{\n  FILE *f = fopen(\"/tmp/logs/455.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf (f, \"[post_process_multipart] %s: skip_rn=%d state=%d buffer_pos=%zu buffer_size=%zu ioff=%zu poff=%zu max=%zu post_data_len=%zu\\n\",\n           where,\n           (int) pp->skip_rn,\n           (int) pp->state,\n           pp->buffer_pos,\n           pp->buffer_size,\n           ioff,\n           poff,\n           max,\n           post_data_len);\n  if (pp->buffer_pos > 0)\n  {\n    /* only print bytes if buffer has at least one byte */\n    unsigned char b0 = (unsigned char) buf[0];\n    fprintf (f, \"  buf[0]=0x%02x (%c)\\n\", b0,\n             (b0 >= 0x20 && b0 < 0x7f) ? buf[0] : '?');\n    if (pp->buffer_pos > 1)\n    {\n      unsigned char b1 = (unsigned char) buf[1];\n      fprintf (f, \"  buf[1]=0x%02x (%c)\\n\", b1,\n               (b1 >= 0x20 && b1 < 0x7f) ? buf[1] : '?');\n    }\n  }\n  else\n    fprintf (f, \"  (buffer empty)\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      /* log the out-of-memory condition */\n      log_pp_state (pp, \"OutOfMemoryBranch\", buf, ioff, poff, max, post_data_len);\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* log state right before the state machines run (this is\n       important: it captures buffer_pos==0 cases just before\n       the code dereferences buf[0]) */\n    log_pp_state (pp, \"BeforeStateMachines\", buf, ioff, poff, max, post_data_len);\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      /* log that we're about to check buf[0] for '\\n' */\n      log_pp_state (pp, \"RN_OptN_about_to_check_buf0\", buf, ioff, poff, max, post_data_len);\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      /* log that we're about to check buf[0] for '-' */\n      log_pp_state (pp, \"RN_Dash_about_to_check_buf0\", buf, ioff, poff, max, post_data_len);\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      /* log that we're about to check buf[0] for '\\r' */\n      log_pp_state (pp, \"RN_Full_about_to_check_buf0\", buf, ioff, poff, max, post_data_len);\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      /* log that we're about to check buf[0] for '\\n' in RN_Full */\n      log_pp_state (pp, \"RN_Full_about_to_check_buf0_for_lf\", buf, ioff, poff, max, post_data_len);\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      /* log that we're about to check buf[0] for '-' (Dash2) */\n      log_pp_state (pp, \"RN_Dash2_about_to_check_buf0\", buf, ioff, poff, max, post_data_len);\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      /* log before memmove that compacts the buffer */\n      log_pp_state (pp, \"BeforeMemmove_AGAIN\", buf, ioff, poff, max, post_data_len);\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    /* log before final memmove */\n    log_pp_state (pp, \"BeforeFinalMemmove\", buf, ioff, poff, max, post_data_len);\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    log_pp_state (pp, \"TruncatedPostDataError\", buf, ioff, poff, max, post_data_len);\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  log_pp_state (pp, \"ReturnSuccess\", buf, ioff, poff, max, post_data_len);\n  return MHD_YES;\n}\n"
}