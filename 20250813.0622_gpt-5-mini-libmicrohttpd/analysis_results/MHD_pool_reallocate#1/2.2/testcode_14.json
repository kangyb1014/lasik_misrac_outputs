{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe statement mhd_assert(pool->size >= pool->end - pool->pos); expands to ((void)0) (mhd_assert is defined as ((void)0)) so it is a no-op in the provided build. Removing this statement would not affect program behaviour, therefore it constitutes dead code. (If mhd_assert can be defined to perform checks in other build configurations then it would not be dead in those configurations; but given the supplied definition it is dead in this project configuration.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_pool_reallocate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/10.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_pool_reallocate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_pool_reallocate:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\nPlease provide the modified MHD_pool_reallocate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* Helper logging functions: append diagnostic information to /tmp/logs/10.txt */\nstatic void\nmhd_logf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\n/* Probe whether mhd_assert evaluates its argument (i.e. is active) by\n   passing an assignment expression. If mhd_assert is a no-op macro that\n   expands to ((void)0), the assignment will not be evaluated and the\n   probe variable will remain zero. */\nstatic int\nmhd_assert_active_check (void)\n{\n  int probe = 0;\n  /* If mhd_assert executes its argument, probe will become 1. */\n  mhd_assert (probe = 1);\n  return probe;\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  /* Log entry and initial pool state for later inspection. */\n  mhd_logf (\"MHD_pool_reallocate ENTRY: pool=%p old=%p old_size=%zu new_size=%zu\\n\",\n            (void *) pool, old, old_size, new_size);\n  if (pool)\n    mhd_logf (\" pool->memory=%p pos=%zu end=%zu size=%zu\\n\",\n              (void *) pool->memory, pool->pos, pool->end, pool->size);\n\n  /* Detect whether mhd_assert is active in this build. This provides\n     direct evidence for the reported violation scenario when it is a no-op. */\n  {\n    int assert_active = mhd_assert_active_check ();\n    mhd_logf (\" mhd_assert active? %d\\n\", assert_active);\n    if (!assert_active)\n      mhd_logf (\" NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\\n\");\n  }\n\n  /* Evaluate and log the assertion conditions (their boolean values) so\n     that the control path and state that the assertions would have\n     checked are captured even if the assertions themselves are no-ops. */\n  if (pool)\n  {\n    int c1 = (pool->end >= pool->pos);\n    int c2 = (pool->size >= pool->end - pool->pos);\n    int c3 = (old != NULL || old_size == 0);\n    int c4 = (pool->size >= old_size);\n    int c5 = (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n    mhd_logf (\" assertions (evaluated): end>=pos=%d size>=(end-pos)=%d old!=NULL||old_size==0=%d size>=old_size=%d pos==ROUND_TO_ALIGN(pos)=%d\\n\",\n              c1, c2, c3, c4, c5);\n  }\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_logf (\" branch: old!=NULL old_offset=%zu shrinking=%d\\n\",\n              old_offset, (int) shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    /* Log evaluations of the above assertions */\n    {\n      int a1 = mp_ptr_le_ (pool->memory, old);\n      int a2 = ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n      int a3 = ((old_size == 0) || (pool->pos > old_offset));\n      int a4 = ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n      mhd_logf (\" assertions (branch old): mp_ptr_le=%d size-redzone>=(old_offset+old_size)=%d pos>old_offset_or_zero=%d end-redzone>=(old_offset+old_size)=%d\\n\",\n                a1, a2, a3, a4);\n    }\n\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_logf (\" action: shrinking in-place, zeroing from %p length %zu\\n\",\n                (uint8_t *) old + new_size, old_size - new_size);\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_logf (\" condition: old is last allocated block; new_apos=%zu\\n\", new_apos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_logf (\" result: grow in-place failed: new_apos=%zu pool->end=%zu pool->pos=%zu -> returning NULL\\n\",\n                    new_apos, pool->end, pool->pos);\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_logf (\" result: resized in-place, return old=%p new_pos=%zu\\n\", old, pool->pos);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_logf (\" result: shrinking but not last block -> resized in-place, return old=%p\\n\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  mhd_logf (\" allocate path: asize=%zu pool->pos=%zu pool->end=%zu\\n\",\n            asize, pool->pos, pool->end);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_logf (\" result: allocation failed (wrap or not enough space) -> returning NULL\\n\");\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  mhd_logf (\" allocated new_blc=%p new_pos=%zu\\n\", (void *) new_blc, pool->pos);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    mhd_logf (\" moved data from old=%p to new=%p old_size=%zu\\n\", old, new_blc, old_size);\n  }\n  mhd_logf (\" result: return new_blc=%p\\n\", (void *) new_blc);\n  return new_blc;\n}\n"
}