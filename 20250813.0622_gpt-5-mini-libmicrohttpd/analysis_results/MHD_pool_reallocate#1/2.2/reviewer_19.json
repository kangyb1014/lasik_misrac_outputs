{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as ((void)0) in the provided project headers. Thus the statement mhd_assert(pool->pos == ROUND_TO_ALIGN(pool->pos)); becomes a no-op expression statement that executes but has no effect; removing it would not change program behaviour. Therefore this is dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  /* Log entry and initial pool state */\n  mhd_probe_log(\"ENTRY: pool=%p pos=%zu end=%zu size=%zu memory=%p old=%p old_size=%zu new_size=%zu\",\n                (void *)pool,\n                (pool != NULL) ? pool->pos : (size_t)0,\n                (pool != NULL) ? pool->end : (size_t)0,\n                (pool != NULL) ? pool->size : (size_t)0,\n                (pool != NULL) ? (void *)pool->memory : (void *)0,\n                old, old_size, new_size);\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_probe_log(\"ASSERT_CHECK: pool->end >= pool->pos (pos=%zu end=%zu)\", pool->pos, pool->end);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_probe_log(\"ASSERT_CHECK: pool->size >= pool->end - pool->pos (size=%zu end-pos=%zu)\", pool->size, pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_probe_log(\"ASSERT_CHECK: old!=NULL || old_size==0 (old=%p old_size=%zu)\", old, old_size);\n  mhd_assert (pool->size >= old_size);\n  mhd_probe_log(\"ASSERT_CHECK: pool->size >= old_size (pool->size=%zu old_size=%zu)\", pool->size, old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  mhd_probe_log(\"ASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=%zu)\", pool->pos);\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n  mhd_probe_log(\"ASSERT_CHECK: asan_region_is_poisoned(old=%p old_size=%zu) == NULL\", old, old_size);\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_probe_log(\"BRANCH: old!=NULL -> old_offset=%zu shrinking=%d\", old_offset, shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_probe_log(\"ASSERT_CHECK: mp_ptr_le_(pool->memory, old) (memory=%p old=%p)\", (void *)pool->memory, old);\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_probe_log(\"ASSERT_CHECK: pool->memory+pool->size >= old+old_size (pool->size=%zu old_offset=%zu old_size=%zu)\", pool->size, old_offset, old_size);\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_probe_log(\"ASSERT_CHECK: (old_size==0) || (pool->pos > old_offset) (pos=%zu old_offset=%zu old_size=%zu)\", pool->pos, old_offset, old_size);\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    mhd_probe_log(\"ASSERT_CHECK: (pool->end - RED_ZONE) >= (old_offset+old_size) (end=%zu old_offset=%zu old_size=%zu)\", pool->end, old_offset, old_size);\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_probe_log(\"ACTION: shrinking in-place, zeroing from old+new_size len=%zu\", old_size - new_size);\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_probe_log(\"BRANCH: old is last block: old_offset=%zu old_size=%zu new_size=%zu new_apos=%zu\", old_offset, old_size, new_size, new_apos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_probe_log(\"RETURN: grow-in-place failed: new_apos=%zu end=%zu pos=%zu (no space)\", new_apos, pool->end, pool->pos);\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      mhd_probe_log(\"ACTION: resized in-place, set pool->pos=%zu\", pool->pos);\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_probe_log(\"RETURN: resized in-place returning old=%p\", old);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_probe_log(\"RETURN: shrinking but not last block, returning old=%p\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  mhd_probe_log(\"ALLOC: need new block asize=%zu new_size=%zu pool->pos=%zu pool->end=%zu\", asize, new_size, pool->pos, pool->end);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_probe_log(\"RETURN: allocation fail (wrap or insufficient space) asize=%zu available=%zu\", asize, pool->end - pool->pos);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n  mhd_probe_log(\"ACTION: allocated new block new_blc=%p new_pos=%zu\", (void *)new_blc, pool->pos);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    mhd_probe_log(\"ACTION: moving data from old=%p old_size=%zu to new_blc=%p\", old, old_size, (void *)new_blc);\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    mhd_probe_log(\"ACTION: zeroed & poisoned old block old=%p old_size=%zu\", old, old_size);\n  }\n  mhd_probe_log(\"RETURN: new block=%p\", (void *)new_blc);\n  return new_blc;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: pool=0x55e9b5040ae0 pos=64 end=32640 size=32768 memory=0x55e9b5040b10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x55e9b5040b50 new_pos=32640\nRETURN: new block=0x55e9b5040b50\nENTRY: pool=0x55e9b5040ae0 pos=64 end=32640 size=32768 memory=0x55e9b5040b10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x55e9b5040b50 new_pos=32640\nRETURN: new block=0x55e9b5040b50\nENTRY: pool=0x55e9b5040ae0 pos=64 end=32640 size=32768 memory=0x55e9b5049f30 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x55e9b5049f70 new_pos=32640\nRETURN: new block=0x55e9b5049f70\nENTRY: pool=0x7fcae4000de0 pos=64 end=32640 size=32768 memory=0x7fcae4000e10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x7fcae4000e50 new_pos=32640\nRETURN: new block=0x7fcae4000e50\nENTRY: pool=0x7fcae4000de0 pos=64 end=32640 size=32768 memory=0x7fcae4000e10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x7fcae4000e50 new_pos=32640\nRETURN: new block=0x7fcae4000e50\nENTRY: pool=0x7fcae4000de0 pos=64 end=32640 size=32768 memory=0x7fcae4000e10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(pool->pos) (pos=64)\nALLOC: need new block asize=32576 new_size=32576 pool->pos=64 pool->end=32640\nACTION: allocated new block new_blc=0x7fcae4000e50 new_pos=32640\nRETURN: new block=0x7fcae4000e50\nENTRY: pool=0x7fcae4000de0 pos=64 end=32640 size=32768 memory=0x7fcae4000e10 old=(nil) old_size=0 new_size=32576\nASSERT_CHECK: pool->end >= pool->pos (pos=64 end=32640)\nASSERT_CHECK: pool->size >= pool->end - pool->pos (size=32768 end-pos=32576)\nASSERT_CHECK: old!=NULL || old_size==0 (old=(nil) old_size=0)\nASSERT_CHECK: pool->size >= old_size (pool->size=32768 old_size=0)\nASSERT_CHECK: pool->pos == ROUND_TO_ALIGN(p\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. With mhd_assert defined as ((void)0) the statement mhd_assert(pool->pos == ROUND_TO_ALIGN(pool->pos)); is an expression statement that performs no action. It is reachable and executed (as a no-op), and removing it would not alter program behaviour \u2014 which matches MISRA C 2023 Rule 2.2\u2019s definition of dead code. The provided probe output and test setup are consistent with the assertion macro producing no effect in this project build, so the code contains dead code and the report is correct."
}