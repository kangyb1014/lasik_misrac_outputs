{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro _MHD_POISON_MEMORY is defined as (void)0 in the provided configuration. Thus the statement _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size); becomes an executed no-op whenever the shrinking branch is taken. Removing that statement would not affect program behaviour in builds where the macro is a no-op, so it constitutes dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  /* Entry probe */\n  mhd_log_probe(\"MHD_pool_reallocate ENTRY: pool=%p memory=%p pos=%zu end=%zu size=%zu old=%p old_size=%zu new_size=%zu\",\n                (void *)pool, (void *)pool->memory, (size_t)pool->pos, (size_t)pool->end, (size_t)pool->size,\n                old, (size_t)old_size, (size_t)new_size);\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_log_probe(\"  old block present: old_offset=%zu shrinking=%s\",\n                  old_offset, shrinking ? \"true\" : \"false\");\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_log_probe(\"  shrinking: zeroing memory at %p length=%zu\",\n                    (void *)((uint8_t *) old + new_size), (size_t)(old_size - new_size));\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n\n      mhd_log_probe(\"  calling _MHD_POISON_MEMORY on %p length=%zu (may be no-op depending on build)\",\n                    (void *)((uint8_t *) old + new_size), (size_t)(old_size - new_size));\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      mhd_log_probe(\"  returned from _MHD_POISON_MEMORY\");\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_log_probe(\"  old is last allocated; old_apos=%zu new_apos=%zu pool->end=%zu pool->pos=%zu\",\n                    (size_t)ROUND_TO_ALIGN_PLUS_RED_ZONE(old_offset + old_size), (size_t)new_apos,\n                    (size_t)pool->end, (size_t)pool->pos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_log_probe(\"  grow in-place: insufficient space or wrap detected, returning NULL\");\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      mhd_log_probe(\"  resized in-place: updated pool->pos=%zu\", (size_t)pool->pos);\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_log_probe(\"  called _MHD_UNPOISON_MEMORY on %p length=%zu\", old, (size_t)new_size);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_log_probe(\"  shrinking but not last block: returning old (%p) - freed part remains allocated\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  mhd_log_probe(\"  need new block: computed asize=%zu (for new_size=%zu)\", (size_t)asize, (size_t)new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_log_probe(\"  allocation check failed: asize=%zu pool->end=%zu pool->pos=%zu => returning NULL\",\n                  (size_t)asize, (size_t)pool->end, (size_t)pool->pos);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  mhd_log_probe(\"  allocated new block new_blc=%p new_pos=%zu\", (void *)new_blc, (size_t)pool->pos);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  mhd_log_probe(\"  called _MHD_UNPOISON_MEMORY on %p length=%zu\", (void *)new_blc, (size_t)new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    mhd_log_probe(\"  copying old data from %p to %p length=%zu\", old, (void *)new_blc, (size_t)old_size);\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    mhd_log_probe(\"  zeroed old block at %p length=%zu and calling _MHD_POISON_MEMORY on it\", old, (size_t)old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    mhd_log_probe(\"  returned from _MHD_POISON_MEMORY for old block\");\n  }\n  mhd_log_probe(\"MHD_pool_reallocate EXIT: returning %p\", (void *)new_blc);\n  return new_blc;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_pool_reallocate ENTRY: pool=0x56089930cae0 memory=0x56089930cb10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x56089930cb50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x56089930cb50 length=32576\nMHD_pool_reallocate EXIT: returning 0x56089930cb50\nMHD_pool_reallocate ENTRY: pool=0x56089930cae0 memory=0x56089930cb10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x56089930cb50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x56089930cb50 length=32576\nMHD_pool_reallocate EXIT: returning 0x56089930cb50\nMHD_pool_reallocate ENTRY: pool=0x56089930cae0 memory=0x560899315f30 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x560899315f70 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x560899315f70 length=32576\nMHD_pool_reallocate EXIT: returning 0x560899315f70\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd930000e50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd930000e50 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd930000e50\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd930000e50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd930000e50 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd930000e50\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd930000e50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd930000e50 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd930000e50\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd930000e50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd930000e50 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd930000e50\nMHD_pool_reallocate ENTRY: pool=0x7fd92c000b90 memory=0x7fd92c0011a0 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd92c0011e0 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd92c0011e0 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd92c0011e0\nMHD_pool_reallocate ENTRY: pool=0x7fd92c000dc0 memory=0x7fd92c000df0 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd92c000e30 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd92c000e30 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd92c000e30\nMHD_pool_reallocate ENTRY: pool=0x7fd92c000dc0 memory=0x7fd92c000df0 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd92c000e30 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd92c000e30 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd92c000e30\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=32768 old=(nil) old_size=0 new_size=32576\n  need new block: computed asize=32576 (for new_size=32576)\n  allocated new block new_blc=0x7fd930000e50 new_pos=32640\n  called _MHD_UNPOISON_MEMORY on 0x7fd930000e50 length=32576\nMHD_pool_reallocate EXIT: returning 0x7fd930000e50\nMHD_pool_reallocate ENTRY: pool=0x7fd930000de0 memory=0x7fd930000e10 pos=64 end=32640 size=3\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.2 forbids dead code in the project (source that is executed but whose removal would not affect program behaviour). The invocation in question is a use of the macro _MHD_POISON_MEMORY. Whether that call is a no-op depends on build-time macro configuration. If in some builds the macro expands to a real poisoning action, removing the source statement would change behaviour in those builds, so the statement cannot be considered dead for the project as a whole. The supplied runlog also never exercises the shrinking branch (all traces show old == NULL), so the test output does not demonstrate an executed, redundant statement in that configuration. Finally, even if a given build defines the macro as (void)0 and the compiler emits no code, that is a build/configuration-specific effect \u2014 MISRA compliance is assessed with respect to the project/build configuration(s), and a macro intended to be active in other configurations is not dead code across the project. Therefore Agent A\u2019s claim of a Rule 2.2 violation is incorrect."
}