{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as ((void)0), so the statement mhd_assert((old_size == 0) || (pool->pos > old_offset)); expands to a no-op. The assertion expression is not evaluated and the resulting statement has no effect; removing it would not change program behaviour. This constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  /* Log entry and basic pool state. */\n  mhd_probe_log(\"MHD_pool_reallocate ENTRY: pool=%p, old=%p, old_size=%zu, new_size=%zu\",\n                (void *)pool, old, old_size, new_size);\n  if (pool != NULL) {\n    mhd_probe_log(\" pool->memory=%p, pool->pos=%zu, pool->end=%zu, pool->size=%zu\",\n                  (void *)pool->memory, (size_t)pool->pos, (size_t)pool->end, (size_t)pool->size);\n  }\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    /* Log evaluation of conditions relevant to the assertion/violation scenario. */\n    mhd_probe_log(\" IN-BLOCK: old_offset=%zu, shrinking=%s\",\n                  old_offset, shrinking ? \"true\" : \"false\");\n    mhd_probe_log(\" ASSERT-CHECKS: mp_ptr_le_(pool->memory, old)=%d\",\n                  (int) mp_ptr_le_ (pool->memory, old));\n    mhd_probe_log(\" ASSERT-CHECKS: (pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size) = %d\",\n                  (int) ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Log the specific assertion that is reported as a no-op by the other agent. */\n    mhd_probe_log(\" ASSERT-EXPR: (old_size == 0) || (pool->pos > old_offset) evaluates to %d\",\n                  (int) (((old_size == 0) || (pool->pos > old_offset))));\n    mhd_probe_log(\" ASSERT-EXPR2: (old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)) evaluates to %d\",\n                  (int) (((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)))));\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_probe_log(\" SHRINKING: zeroing from %p length %zu\", (uint8_t *) old + new_size, old_size - new_size);\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_probe_log(\" OLD-BLOCK-LAST: pool->pos matches end-of-old; new_apos=%zu\", new_apos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_probe_log(\" GROW-IN-PLACE: insufficient space or wrap: new_apos=%zu, pool->end=%zu, pool->pos=%zu\", new_apos, pool->end, pool->pos);\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_probe_log(\" RESIZED-IN-PLACE: returning old=%p, new_size=%zu, pool->pos=%zu\", old, new_size, pool->pos);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_probe_log(\" SHRINKED-NOT-LAST: returning old=%p (freed part remains allocated)\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  mhd_probe_log(\" ALLOC-NEW: computed asize=%zu\", asize);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_probe_log(\" ALLOC-NEW-FAIL: asize=%zu, available=%zu\", asize, pool->end - pool->pos);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    mhd_probe_log(\" MOVE-OLD-TO-NEW: new_blc=%p, old=%p, old_size=%zu\", new_blc, old, old_size);\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    mhd_probe_log(\" ZERO-OLD: old=%p, old_size=%zu\", old, old_size);\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  mhd_probe_log(\" ALLOC-RETURN: new_blc=%p, new_size=%zu, pool->pos=%zu\", new_blc, new_size, pool->pos);\n  return new_blc;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_pool_reallocate. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct for the scenario described. If, in the assessed project configuration, mhd_assert is defined as ((void)0) then each mhd_assert(...) line becomes an executed no-op expression statement. By the rule text (\u201cAny operation that is executed but whose removal would not affect program behaviour constitutes dead code\u201d) those statements are dead code and thus violate MISRA C 2023 Rule 2.2. Note the important caveat: MISRA compliance is evaluated for a given project/configuration. If the project configuration instead defines mhd_assert to perform observable actions (e.g. logging, diagnostics, abort), then those statements are not dead and there is no violation. The empty test log does not refute the logic \u2014 it only shows the provided test didn\u2019t exercise the function \u2014 the core issue is the macro expansion in the project configuration used for compliance."
}