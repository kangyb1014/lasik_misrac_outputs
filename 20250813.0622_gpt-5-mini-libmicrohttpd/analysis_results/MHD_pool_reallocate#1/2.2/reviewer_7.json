{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:With the provided macro definition '#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0' the statement '_MHD_UNPOISON_MEMORY(old, new_size);' is a no-op. It is executed but has no effect, so removing it would not change program behaviour in this build configuration. Therefore this instance is dead code and violates MISRA C 2023 Rule 2.2. (Note: in other build configurations where the macro expands to real instrumentation this would not be dead.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\nstatic void\nmhd_log_mem (const char *label, const void *p, size_t size)\n{\n  const unsigned char *b = (const unsigned char *) p;\n  size_t i, n = (size < 16U) ? size : 16U; /* limit dump */\n  mhd_log (\"%s: ptr=%p size=%zu dump_first=%zu_bytes:\", label, p, size, n);\n  for (i = 0U; i < n; ++i)\n    mhd_log (\" %02x\", (unsigned) b[i]);\n  mhd_log (\"\\n\");\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  /* Log entry state */\n  mhd_log (\"ENTER MHD_pool_reallocate: pool=%p old=%p old_size=%zu new_size=%zu\\n\",\n           (void *) pool, old, old_size, new_size);\n  if (NULL != pool)\n    mhd_log (\" pool->pos=%zu pool->end=%zu pool->size=%zu\\n\",\n             pool->pos, pool->end, pool->size);\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_log (\"old != NULL branch: old_offset=%zu shrinking=%d\\n\",\n             old_offset, (int) shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_log_mem (\"BEFORE_shrink_zero\", (uint8_t *) old + new_size, old_size - new_size);\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      mhd_log_mem (\"AFTER_shrink_zero\", (uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_log (\"last_allocated_block: new_apos=%zu pool->end=%zu pool->pos=%zu\\n\",\n               new_apos, pool->end, pool->pos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_log (\"RETURN NULL: not enough space or wrap while growing in-place\\n\");\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n\n      /* Probe around the _MHD_UNPOISON_MEMORY call so that callers can see the call occurred */\n      mhd_log (\"CALL _MHD_UNPOISON_MEMORY (in-place): ptr=%p new_size=%zu\\n\", old, new_size);\n      mhd_log_mem (\"PRE_UNPOISON_inplace\", old, (new_size < 16U) ? new_size : 16U);\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_log_mem (\"POST_UNPOISON_inplace\", old, (new_size < 16U) ? new_size : 16U);\n\n      mhd_log (\"RETURN old (resized in-place): old=%p\\n\", old);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_log (\"RETURN old (shrinking but not last-block): old=%p\\n\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_log (\"RETURN NULL: asize computation failed or not enough space asize=%zu pool->end=%zu pool->pos=%zu\\n\",\n             asize, pool->end, pool->pos);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  /* Probe around the allocation-time unpoison call */\n  mhd_log (\"CALL _MHD_UNPOISON_MEMORY (alloc): new_blc=%p new_size=%zu\\n\", (void *) new_blc, new_size);\n  mhd_log_mem (\"PRE_UNPOISON_alloc\", new_blc, (new_size < 16U) ? new_size : 16U);\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  mhd_log_mem (\"POST_UNPOISON_alloc\", new_blc, (new_size < 16U) ? new_size : 16U);\n\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    mhd_log_mem (\"COPY_FROM_old_before\", old, (old_size < 16U) ? old_size : 16U);\n    memcpy (new_blc, old, old_size);\n    mhd_log_mem (\"COPY_TO_new_after\", new_blc, (old_size < 16U) ? old_size : 16U);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    mhd_log_mem (\"OLD_zeroed_and_poisoned\", old, (old_size < 16U) ? old_size : 16U);\n  }\n  mhd_log (\"RETURN new_blc=%p\\n\", new_blc);\n  return new_blc;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER MHD_pool_reallocate: pool=0x55d494d96ae0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x55d494d96b50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x55d494d96b50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x55d494d96b50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x55d494d96b50\nENTER MHD_pool_reallocate: pool=0x55d494d96ae0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x55d494d96b50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x55d494d96b50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x55d494d96b50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x55d494d96b50\nENTER MHD_pool_reallocate: pool=0x55d494d96ae0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x55d494d9ff70 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x55d494d9ff70 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x55d494d9ff70 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x55d494d9ff70\nENTER MHD_pool_reallocate: pool=0x7fe0e0000de0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x7fe0e0000e50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x7fe0e0000e50\nENTER MHD_pool_reallocate: pool=0x7fe0e0000de0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x7fe0e0000e50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x7fe0e0000e50\nENTER MHD_pool_reallocate: pool=0x7fe0e0000de0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x7fe0e0000e50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x7fe0e0000e50\nENTER MHD_pool_reallocate: pool=0x7fe0e0000de0 old=(nil) old_size=0 new_size=32576\n pool->pos=64 pool->end=32640 pool->size=32768\nCALL _MHD_UNPOISON_MEMORY (alloc): new_blc=0x7fe0e0000e50 new_size=32576\nPRE_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPOST_UNPOISON_alloc: ptr=0x7fe0e0000e50 size=16 dump_first=16_bytes: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nRETURN new_blc=0x7fe0e0000e50\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. With the macro defined as '#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0' the invocation _MHD_UNPOISON_MEMORY(old, new_size); becomes an expression-statement that performs no action. Given the provided exhaustive test results and the stipulation that nothing observable changes, removing that statement would not affect program behaviour in this build configuration, so it qualifies as dead code under MISRA C 2023 Rule 2.2. (In other build configurations where the macro expands to real instrumentation the call would have effect and would not be dead.)"
}