{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (fields: uint8_t *memory; size_t pos; size_t end; size_t size)",
    "ROUND_TO_ALIGN(size_t)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t)",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_(void *p, uint8_t *base)",
    "mp_ptr_le_(uint8_t *base, void *p)",
    "mhd_assert (macro/function)",
    "_MHD_POISON_MEMORY(void *p, size_t n)",
    "_MHD_UNPOISON_MEMORY(void *p, size_t n)",
    "__asan_region_is_poisoned (optional)"
  ],
  "explanation": "For checking whether calls to memcpy/memset in MHD_pool_reallocate can access beyond object bounds you must know how allocation sizes, offsets and bounds are computed and the exact layout of the pool. Each symbol is required for these reasons:\n\n- struct MemoryPool (fields: uint8_t *memory; size_t pos; size_t end; size_t size): The code treats pool->memory as the base pointer and pool->pos, pool->end, pool->size as offsets/limits. You must know their types, units and semantics (are pos/end offsets or absolute pointers, what pool->size represents) to determine whether pointer arithmetic new_blc = pool->memory + pool->pos and checks using pool->end/pool->pos correctly bound the memory used by memcpy/memset.\n\n- ROUND_TO_ALIGN(size_t): The code uses ROUND_TO_ALIGN on pool->pos and to compute aligned boundaries. The exact rounding rule (alignment value, behavior on 0, overflow behavior) is needed to reason about the computed rounded sizes/positions and whether comparisons (e.g. pool->pos == ROUND_TO_ALIGN(pool->pos)) and arithmetic can allow out-of-bounds access.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t): This macro is used to compute allocation footprints (asize) and to test whether an existing block is the last allocation. Its exact definition (likely includes alignment plus red-zone addition) is required to compute how many bytes are reserved for a requested new_size and to ensure new_blc/new_size fit within pool bounds.\n\n- _MHD_RED_ZONE_SIZE: The extra bytes reserved (red zone) are added to allocation footprints. You must know its value to determine the true reserved size for each allocation and whether memcpy/memset ranges might overlap or exceed allocated blocks.\n\n- mp_ptr_diff_(void *p, uint8_t *base): The code computes old_offset = mp_ptr_diff_(old, pool->memory). You need this function's semantics (return type, how it computes offsets, behavior on out-of-range pointers or wrap) to know whether old_offset + old_size/new_size calculations are valid and not subject to overflow or misinterpretation.\n\n- mp_ptr_le_(uint8_t *base, void *p): Used to assert that old lies at/after pool->memory. Its exact comparison semantics are required to conclude that old is within the pool region and that subsequent arithmetic referring to old_offset is meaningful.\n\n- mhd_assert (macro/function): The code uses a number of mhd_assert checks that establish preconditions (bounds and invariants). You must know whether mhd_assert compiles to runtime checks that abort or are compiled out in production; if they are no-ops the code cannot rely on them to guarantee safety, and your analysis must treat those conditions as unchecked assumptions.\n\n- _MHD_POISON_MEMORY(void *p, size_t n) and _MHD_UNPOISON_MEMORY(void *p, size_t n): These are invoked on regions before/after use. Their definitions matter for two reasons: (1) to confirm they do not themselves write beyond the supplied ranges, and (2) to understand if they impose any additional runtime checks (ASAN) that would detect out-of-bounds behaviour. They also identify whether zeroing/unpoisoning occurs before memcpy/memset and can affect the validity of accesses.\n\n- __asan_region_is_poisoned (optional): The code conditionally asserts that the old region is unpoisoned. If present in the build, its semantics and return values influence whether some pointer checks are effective. Include it only if ASAN-related assertions are enabled in your build configuration.\n\nWith these symbols and definitions you can (a) compute the actual allocation footprint (asize) for new_size, (b) verify that the checks (asize > pool->end - pool->pos, comparisons against ROUND_TO_ALIGN_PLUS_RED_ZONE(old_offset + old_size), etc.) preclude calling memcpy(new_blc, old, old_size) or memset(...) with sizes or source/destination ranges that lie outside their allocated objects, and (c) determine whether any asserts that guarantee safety are compile-time/no-op or enforced at runtime."
}