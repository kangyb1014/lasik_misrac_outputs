{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "mhd_assert",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "_MHD_RED_ZONE_SIZE",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "__asan_region_is_poisoned",
    "MHD_ASAN_POISON_ACTIVE",
    "HAVE___ASAN_REGION_IS_POISONED",
    "uint8_t",
    "size_t",
    "bool"
  ],
  "explanation": "You must inspect the definitions of these symbols to decide whether the target function uses any compiler/language extensions (MISRA rule check). For each:\n\n- struct MemoryPool: its layout (members memory,pos,end,size) is needed to verify pointer arithmetic and casts; check its definition for compiler extensions (bit\u2011fields with implementation attributes, packed/aligned attributes, anonymous structs, etc.).\n- mhd_assert: usually a macro \u2014 inspect its expansion for use of extensions (statement expressions ({ ... }), typeof, __attribute__, variadic macros supported by C99, or compiler builtins).\n- ROUND_TO_ALIGN and ROUND_TO_ALIGN_PLUS_RED_ZONE: macros or inline functions that compute aligned sizes. They often hide GCC/clang extensions (statement expressions, typeof, __alignof__, __builtin_*). Inspect definitions for such extensions or nonstandard behavior (e.g. reliance on integer wrap via undefined behavior).\n- mp_ptr_diff_ and mp_ptr_le_: macros/helpers that perform pointer-to-integer casts or comparisons. Check whether they use nonstandard casts, pointer-to-integer conversions that rely on implementation-defined behavior, typeof, or statement expressions.\n- _MHD_RED_ZONE_SIZE: constant used by the rounding macros \u2014 include because associated macros may be implemented with nonstandard constructs tied to this value.\n- _MHD_POISON_MEMORY and _MHD_UNPOISON_MEMORY: typically map to AddressSanitizer intrinsics or platform-specific helpers. Inspect whether they expand to __asan_* intrinsics, compiler builtins, inline asm, or attributes (all are potential extensions).\n- __asan_region_is_poisoned: an AddressSanitizer runtime/compiler intrinsic (double underscore). Presence/usage is an explicit compiler/sanitizer extension; confirm conditional compilation and whether the call is active.\n- MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED: configuration macros that enable ASan-related code paths. Their definitions affect whether extensions are used at compile time.\n- uint8_t, size_t, bool: the fixed-width and boolean types themselves are standard, but verify which headers/typedefs are used; also check for any redefinitions or nonstandard typedefs/aliases that could use extensions.\n\nInspecting these definitions will reveal any use of language extensions (double\u2011underscore intrinsics, compiler builtins, statement expressions, typeof, inline asm, attributes, nonstandard pragmas, etc.). Standard library calls used directly in the function (memcpy, memset, NULL) are ordinary C and do not need further scrutiny unless their wrappers/macros are used above."
}