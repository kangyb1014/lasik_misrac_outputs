{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The helper digest_update_str(da, password) likely uses string.h functions (e.g. strlen or memcpy on a NUL-terminated C string) but calc_userdigest and callers do not validate the password pointer or its termination. In add_new_user_entry the password parameter is passed straight through to MHD_digest_auth_calc_userdigest -> calc_userdigest -> digest_update_str without a NULL check or explicit length. If password is NULL or points to a non NUL-terminated buffer, digest_update_str will call string functions (e.g. strlen) and thus access memory beyond the bounds of the referenced object (undefined behavior).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe(const char *stage,\n          const char *const username,\n          const char *const password,\n          const char *const realm,\n          const void *buf,\n          size_t bufsiz,\n          enum MHD_Result res,\n          int allow1,\n          int allow2)\n{\n  FILE *f = fopen(\"/tmp/logs/335.txt\", \"a\");\n  if (!f)\n    return;\n\n  /*\n   * Do NOT attempt to print the strings themselves (e.g. with %s) because\n   * that could dereference invalid or non-NUL-terminated pointers and\n   * introduce undefined behavior. Log only pointer values and sizes/state.\n   */\n  fprintf(f,\n          \"add_new_user_entry: stage=%s username_ptr=%p realm_ptr=%p password_ptr=%p buf_ptr=%p buf_size=%zu res=%d allow1=%d allow2=%d\\n\",\n          stage,\n          (const void *) username,\n          (const void *) realm,\n          (const void *) password,\n          buf,\n          bufsiz,\n          (int) res,\n          allow1,\n          allow2);\n\n  fclose(f);\n}\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  log_probe(\"entry\", username, password, realm, NULL, 0, (enum MHD_Result)0, allow_area_1, allow_area_2);\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    log_probe(\"no_space\", username, password, realm, NULL, 0, (enum MHD_Result)0, allow_area_1, allow_area_2);\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res) {\n    log_probe(\"before_hash_md5\", username, password, realm, entry->userhash_md5, sizeof(entry->userhash_md5), res, allow_area_1, allow_area_2);\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n    log_probe(\"after_hash_md5\", username, password, realm, entry->userhash_md5, sizeof(entry->userhash_md5), res, allow_area_1, allow_area_2);\n  }\n  if (MHD_NO != res) {\n    log_probe(\"before_digest_md5\", username, password, realm, entry->userdigest_md5, sizeof(entry->userdigest_md5), res, allow_area_1, allow_area_2);\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n    log_probe(\"after_digest_md5\", username, password, realm, entry->userdigest_md5, sizeof(entry->userdigest_md5), res, allow_area_1, allow_area_2);\n  }\n\n  if (MHD_NO != res) {\n    log_probe(\"before_hash_sha256\", username, password, realm, entry->userhash_sha256, sizeof(entry->userhash_sha256), res, allow_area_1, allow_area_2);\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n    log_probe(\"after_hash_sha256\", username, password, realm, entry->userhash_sha256, sizeof(entry->userhash_sha256), res, allow_area_1, allow_area_2);\n  }\n  if (MHD_NO != res) {\n    log_probe(\"before_digest_sha256\", username, password, realm, entry->userdigest_sha256, sizeof(entry->userdigest_sha256), res, allow_area_1, allow_area_2);\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n    log_probe(\"after_digest_sha256\", username, password, realm, entry->userdigest_sha256, sizeof(entry->userdigest_sha256), res, allow_area_1, allow_area_2);\n  }\n\n  if (MHD_NO != res) {\n    log_probe(\"before_hash_sha512_256\", username, password, realm, entry->userhash_sha512_256, sizeof(entry->userhash_sha512_256), res, allow_area_1, allow_area_2);\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n    log_probe(\"after_hash_sha512_256\", username, password, realm, entry->userhash_sha512_256, sizeof(entry->userhash_sha512_256), res, allow_area_1, allow_area_2);\n  }\n  if (MHD_NO != res) {\n    log_probe(\"before_digest_sha512_256\", username, password, realm, entry->userdigest_sha512_256, sizeof(entry->userdigest_sha512_256), res, allow_area_1, allow_area_2);\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n    log_probe(\"after_digest_sha512_256\", username, password, realm, entry->userdigest_sha512_256, sizeof(entry->userdigest_sha512_256), res, allow_area_1, allow_area_2);\n  }\n\n  if (MHD_NO == res) {\n    log_probe(\"failure_exit\", username, password, realm, NULL, 0, res, allow_area_1, allow_area_2);\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  log_probe(\"success_exit\", username, password, realm, NULL, 0, res, allow_area_1, allow_area_2);\n\n  return ! 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for add_new_user_entry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not provably correct based on the supplied code. MISRA C:2023 Rule 21.17 concerns the use of the <string.h> routines (strlen, memcpy, strcpy, etc.) in such a way that they access memory beyond the bounds of the referenced objects. The function add_new_user_entry itself does not call any <string.h> functions; it merely forwards the password pointer to MHD_digest_auth_calc_userdigest. A violation of 21.17 would occur at the site where a string.h function is actually called with an invalid pointer/length. If MHD_digest_auth_calc_userdigest (or calc_userdigest/digest_update_str) uses strlen/strcpy/etc. without checking that password is non-NULL and properly NUL-terminated, then those functions (not add_new_user_entry) would be the direct locus of a 21.17 violation. Whether add_new_user_entry is also at fault depends on the documented contract of the callee: if the callee requires a non-NULL, NUL-terminated password and add_new_user_entry is permitted by the broader program to receive NULL (or non-terminated buffers) and forwards them without checking, there is a mismatch in interface preconditions and a risk of out-of-bounds access \u2014 but that is a design/contract issue, not an automatic proof that add_new_user_entry itself violates 21.17. The empty test log does not demonstrate an out-of-bounds access. To resolve: inspect the implementations and/or specifications of MHD_digest_auth_calc_userdigest/calc_userdigest/digest_update_str. If they use string.h without validating inputs, fix them (validate inputs or document preconditions) or add checks in add_new_user_entry to ensure password is non-NULL and properly terminated (or pass an explicit length-safe API)."
}