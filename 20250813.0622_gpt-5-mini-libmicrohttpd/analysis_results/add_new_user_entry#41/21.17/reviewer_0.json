{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen(username) and strlen(realm) without prior validation that these pointers are non-NULL and point to NUL-terminated arrays. If username or realm is NULL (or points to a non-NUL-terminated buffer), strlen will read past the object bounds and invoke undefined behaviour. The later mhd_assert in calc_userhash does not prevent the strlen calls and may be compiled out, so it does not guarantee safety at the strlen call site. Therefore this can violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n  int ret_val = 0; /* default failure */\n  FILE *log = fopen(\"/tmp/logs/335.txt\", \"a\");\n\n  if (log)\n    {\n      /* Log entry to help reproduce the violation scenario. We log pointer\n         values and some state but do not dereference username/realm to avoid\n         introducing additional runtime faults. */\n      fprintf(log, \"add_new_user_entry: enter\\n\");\n      fprintf(log, \"  username=%p, password=%p, realm=%p\\n\",\n              (const void *) username,\n              (const void *) password,\n              (const void *) realm);\n      fprintf(log, \"  allow_area_1=%d, allow_area_2=%d\\n\",\n              allow_area_1, allow_area_2);\n      fprintf(log, \"  user_ids_used=%zu, user_ids_capacity=%zu\\n\",\n              (size_t) user_ids_used,\n              (size_t) (sizeof (user_ids) / sizeof (user_ids[0])));\n      fflush(log);\n    }\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    {\n      if (log)\n        {\n          fprintf(log, \"  exit: no space to add new entry (capacity reached)\\n\");\n          fclose(log);\n        }\n      return 0; /* No more space to add new entry */\n    }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  if (log)\n    {\n      fprintf(log, \"  assigned entry at %p -> entry->username=%p, entry->realm=%p\\n\",\n              (void *) entry,\n              (const void *) entry->username,\n              (const void *) entry->realm);\n      fflush(log);\n    }\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userhash (MD5) with username=%p realm=%p\\n\",\n                  (const void *) username, (const void *) realm);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           entry->userhash_md5,\n                                           sizeof (entry->userhash_md5));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after MD5 userhash\\n\", (int) res);\n          fflush(log);\n        }\n    }\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userdigest (MD5) with username=%p realm=%p password=%p\\n\",\n                  (const void *) username, (const void *) realm, (const void *) password);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                             username,\n                                             realm,\n                                             password,\n                                             entry->userdigest_md5,\n                                             sizeof (entry->userdigest_md5));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after MD5 userdigest\\n\", (int) res);\n          fflush(log);\n        }\n    }\n\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userhash (SHA256) with username=%p realm=%p\\n\",\n                  (const void *) username, (const void *) realm);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           entry->userhash_sha256,\n                                           sizeof (entry->userhash_sha256));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after SHA256 userhash\\n\", (int) res);\n          fflush(log);\n        }\n    }\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userdigest (SHA256) with username=%p realm=%p password=%p\\n\",\n                  (const void *) username, (const void *) realm, (const void *) password);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                             username,\n                                             realm,\n                                             password,\n                                             entry->userdigest_sha256,\n                                             sizeof (entry->userdigest_sha256));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after SHA256 userdigest\\n\", (int) res);\n          fflush(log);\n        }\n    }\n\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userhash (SHA512_256) with username=%p realm=%p\\n\",\n                  (const void *) username, (const void *) realm);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                           username,\n                                           realm,\n                                           entry->userhash_sha512_256,\n                                           sizeof (entry->userhash_sha512_256));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after SHA512_256 userhash\\n\", (int) res);\n          fflush(log);\n        }\n    }\n  if (MHD_NO != res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  calling MHD_digest_auth_calc_userdigest (SHA512_256) with username=%p realm=%p password=%p\\n\",\n                  (const void *) username, (const void *) realm, (const void *) password);\n          fflush(log);\n        }\n      res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                             username,\n                                             realm,\n                                             password,\n                                             entry->userdigest_sha512_256,\n                                             sizeof (entry->userdigest_sha512_256));\n      if (log)\n        {\n          fprintf(log, \"  returned res=%d after SHA512_256 userdigest\\n\", (int) res);\n          fflush(log);\n        }\n    }\n\n  if (MHD_NO == res)\n    {\n      if (log)\n        {\n          fprintf(log, \"  exit: digest/hash calculation failed (res==MHD_NO)\\n\");\n          fclose(log);\n        }\n      return 0; /* Failure exit point */\n    }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  ret_val = !0;\n\n  if (log)\n    {\n      fprintf(log, \"  success: new entry added at index %zu (entry=%p)\\n\",\n              (size_t) (user_ids_used - 1), (void *) entry);\n      fprintf(log, \"add_new_user_entry: exit returning %d\\n\", ret_val);\n      fclose(log);\n    }\n\n  return ret_val;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for add_new_user_entry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. The add_new_user_entry function shown does not itself call any functions from <string.h> (no strlen/memcpy/etc. are present). The only places where string handling might occur are the called helpers MHD_digest_auth_calc_userhash and MHD_digest_auth_calc_userdigest. Whether Rule 21.17 is violated therefore depends on the implementation and preconditions of those functions, not on add_new_user_entry itself. If those helper functions call strlen (or other string.h functions) without checking their pointer parameters for validity (and the caller can legitimately pass NULL or non-NUL-terminated buffers), then the helper functions would violate 21.17. Conversely, if the helpers document and require non-NULL, NUL-terminated strings as a precondition, then the caller (add_new_user_entry) must ensure it meets that contract; failing to do so would be a separate API-usage/documentation defect but does not by itself prove a 21.17 violation in add_new_user_entry. The agent\u2019s scenario incorrectly asserts that add_new_user_entry \u201ccalls strlen(username) and strlen(realm)\u201d; that attribution is inaccurate. To resolve this for real: inspect the implementations and contracts of MHD_digest_auth_calc_userhash/digest. If they may be called with NULL or unterminated buffers and they call strlen, they violate 21.17. If they require non-NULL, the caller should validate or document the requirement. Recommended fix: either validate username/realm/password are non-NULL (and have appropriate termination/length) before calling the helpers, or enforce/document non-NULL/NUL-terminated preconditions and have static analysis/QA ensure callers satisfy them."
}