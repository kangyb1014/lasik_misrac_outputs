{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count_cpuset_getaffinity_.\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The fragment is inside the #else branch of #if defined(HAVE_CPU_COUNT). In the supplied project configuration HAVE_CPU_COUNT is defined (HAVE_CPU_COUNT 1), so this branch is never compiled or executed. That makes the code unreachable in the project build and thus violates MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/137.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n\n  fclose (f);\n}\n\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n  mhd_probe_log (\"ENTER: mhd_tool_get_proc_cpu_count_cpuset_getaffinity_, initial ret=%d\", ret);\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  mhd_probe_log (\"COMPILE-TIME: HAVE_CPUSET_GETAFFINITY is defined\");\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    mhd_probe_log (\"RUNTIME: entering cpuset_getaffinity block because ret=%d\", ret);\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n      mhd_probe_log (\"RUNTIME: cpuset_getaffinity succeeded\");\n#ifdef HAVE_CPU_COUNT\n      mhd_probe_log (\"COMPILE-TIME: HAVE_CPU_COUNT is defined -> using CPU_COUNT(&cur_mask)\");\n      ret = CPU_COUNT (&cur_mask);\n      mhd_probe_log (\"RUNTIME: after CPU_COUNT, ret=%d\", ret);\n#else  /* ! HAVE_CPU_COUNT */\n      mhd_probe_log (\"COMPILE-TIME: HAVE_CPU_COUNT is NOT defined -> falling back to manual counting\");\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      mhd_probe_log (\"RUNTIME: after manual counting loop, ret=%d\", ret);\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n    else\n    {\n      mhd_probe_log (\"RUNTIME: cpuset_getaffinity failed or returned non-zero\");\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  mhd_probe_log (\"COMPILE-TIME: HAVE_CPU_COUNT_S is defined -> attempting extended mask path\");\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    mhd_probe_log (\"RUNTIME: allocating mask for %u cpus (%zu bytes)\", mask_size_cpus, mask_size_bytes);\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      mhd_probe_log (\"RUNTIME: CPU_ALLOC succeeded, p_mask=%p\", (void *) p_mask);\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        mhd_probe_log (\"COMPILE-TIME: MHD_FUNC_CPU_COUNT_S_GETS_CPUS is NOT defined -> calling CPU_COUNT_S(mask_size_bytes, p_mask)\");\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        mhd_probe_log (\"COMPILE-TIME: MHD_FUNC_CPU_COUNT_S_GETS_CPUS is defined -> calling CPU_COUNT_S(mask_size_cpus, p_mask)\");\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        mhd_probe_log (\"RUNTIME: after CPU_COUNT_S, ret=%d\", ret);\n      }\n      else\n      {\n        mhd_probe_log (\"RUNTIME: extended cpuset_getaffinity failed or returned non-zero\");\n      }\n      CPU_FREE (p_mask);\n      mhd_probe_log (\"RUNTIME: CPU_FREE called\");\n    }\n    else\n    {\n      mhd_probe_log (\"RUNTIME: CPU_ALLOC returned NULL\");\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#else\n  mhd_probe_log (\"COMPILE-TIME: HAVE_CPUSET_GETAFFINITY is NOT defined -> skipping cpuset_getaffinity logic\");\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n  {\n    mhd_probe_log (\"EXIT: returning -1 (ret=%d)\", ret);\n    return -1;\n  }\n  mhd_probe_log (\"EXIT: returning ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_proc_cpu_count_cpuset_getaffinity_. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The code inside the #else of the #if defined(HAVE_CPU_COUNT) is excluded by the preprocessor when HAVE_CPU_COUNT is defined, so that fragment does not appear in the translation unit produced for this project build. MISRA Rule 2.1 prohibits unreachable code that exists in the compiled program (i.e. in the translation unit) but cannot be executed due to control flow; it does not treat alternate branches that are removed by conditional compilation in the current project configuration as \"unreachable code\" in the compiled program. In other words, conditional-compilation alternatives are intended for portability and are not violations of Rule 2.1 unless they produce code that is present in the translation unit and provably cannot be executed. The empty runtime log only shows the function wasn't invoked in the test run and does not make the excluded #else branch a Rule 2.1 violation. If you want to avoid confusion, you can remove unused alternate branches or document them, or run static analysis across all intended build configurations."
}