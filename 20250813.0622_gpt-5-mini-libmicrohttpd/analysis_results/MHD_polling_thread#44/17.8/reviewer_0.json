{
  "user_message": "An agent A claimed that the following MHD_polling_thread code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_polling_thread.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In MHD_select(struct MHD_Daemon *daemon, int32_t millisec) the statement 'if (MHD_NO != err_state) millisec = 0;' assigns to the non-pointer parameter 'millisec'. Modifying a value parameter violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MHD_TEST_ALLOW_SUSPEND_RESUME = 0x01;\nstatic const int MHD_YES = 1;\nstatic void\nMHD_thread_handle_ID_set_current_thread_ID_(pthread_t *dest)\n{\n    if (dest)\n        *dest = pthread_self();\n}\nstatic int MHD_D_IS_USING_POLL_(struct MHD_Daemon *d) { return d ? d->use_poll : 0; }\nstatic int MHD_D_IS_USING_EPOLL_(struct MHD_Daemon *d) { return d ? d->use_epoll : 0; }\nstatic void probe_log (const char *tag, const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/357.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n\n  time_t t = time (NULL);\n  if ((time_t) -1 != t)\n  {\n    struct tm tm_buf;\n    if (localtime_r (&t, &tm_buf) != NULL)\n    {\n      char ts[32];\n      if (0 != strftime (ts, (sizeof ts), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n      {\n        (void) fprintf (f, \"%s \", ts);\n      }\n    }\n  }\n\n  (void) fprintf (f, \"[%s] \", (tag != NULL) ? tag : \"LOG\");\n\n  va_list ap;\n  va_start (ap, fmt);\n  (void) vfprintf (f, fmt, ap);\n  va_end (ap);\n\n  (void) fprintf (f, \"\\n\");\n  (void) fclose (f);\n}\n\nstatic void MHD_poll(struct MHD_Daemon *d, int ms) { (void)d; (void)ms; /* no-op */ }\nstatic void MHD_epoll(struct MHD_Daemon *d, int timeout) { (void)d; (void)timeout; /* no-op */ }\nstatic void MHD_select(struct MHD_Daemon *d, int millisec) { (void)d; (void)millisec; /* no-op */ }\nstatic void MHD_cleanup_connections(struct MHD_Daemon *d) { (void)d; /* no-op */ }\nstatic void resume_suspended_connections(struct MHD_Daemon *d) { (void)d; /* no-op */ }\nstatic void close_all_connections(struct MHD_Daemon *d) { (void)d; /* no-op */ }\nstatic void *\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = (struct MHD_Daemon *) cls;\n\n  probe_log (\"THREAD\", \"MHD_polling_thread start: daemon=%p\", (void *) daemon);\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n\n  /* Note: original code attempted to block SIGPIPE on the thread when\n     pthread_sigmask support was available. We won't manipulate signals here\n     but preserve the flag that indicates SIGPIPE is blocked when no error. */\n  daemon->sigpipe_blocked = false;\n\n  while (! daemon->shutdown)\n  {\n    probe_log (\"LOOP\", \"enter loop: daemon=%p shutdown=%d\", (void *) daemon, (int) daemon->shutdown);\n\n    if (MHD_D_IS_USING_POLL_ (daemon))\n    {\n      probe_log (\"CALL\", \"MHD_poll: daemon=%p block=%d\", (void *) daemon, (int) MHD_YES);\n      MHD_poll (daemon, MHD_YES);\n      probe_log (\"RETURN\", \"MHD_poll returned: daemon=%p\", (void *) daemon);\n    }\n    else if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      probe_log (\"CALL\", \"MHD_epoll: daemon=%p timeout=%d\", (void *) daemon, -1);\n      MHD_epoll (daemon, -1);\n      probe_log (\"RETURN\", \"MHD_epoll returned: daemon=%p\", (void *) daemon);\n    }\n    else\n    {\n      /* Record the call to MHD_select and the value passed for millisec. */\n      probe_log (\"CALL\", \"MHD_select: daemon=%p millisec=%d\", (void *) daemon, -1);\n      MHD_select (daemon, -1);\n      probe_log (\"RETURN\", \"MHD_select returned: daemon=%p\", (void *) daemon);\n    }\n\n    MHD_cleanup_connections (daemon);\n    probe_log (\"CLEANUP\", \"MHD_cleanup_connections executed: daemon=%p\", (void *) daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    probe_log (\"RESUME\", \"resuming suspended connections: daemon=%p\", (void *) daemon);\n    resume_suspended_connections (daemon);\n  }\n  probe_log (\"CLOSE\", \"closing all connections: daemon=%p\", (void *) daemon);\n  close_all_connections (daemon);\n\n  probe_log (\"THREAD\", \"MHD_polling_thread exit: daemon=%p\", (void *) daemon);\n\n  return (void *) 0;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the code shown. MISRA C 2023 Rule 17.8 forbids modifying a function parameter variable; it allows modifying the object pointed to by a pointer parameter but not the pointer parameter itself. In the provided MHD_polling_thread implementation there is no modification of the function parameter cls: it is immediately copied to a local pointer variable (struct MHD_Daemon *daemon = cls;) and only the object pointed to (daemon->...) is modified. Copying the parameter to a local variable and mutating the pointed-to object is permitted by the rule. The alleged assignment (millisec = 0) would be a violation only if it occurs inside MHD_select (i.e. that function modifies its non\u2011pointer parameter). That modification would be a defect in MHD_select itself, but it is not present in the shown MHD_polling_thread and cannot be concluded from the provided code. Recommendation: inspect the implementation of MHD_select; if it assigns to its non\u2011pointer parameter, change it to use a local variable or pass a pointer so as to comply with Rule 17.8."
}