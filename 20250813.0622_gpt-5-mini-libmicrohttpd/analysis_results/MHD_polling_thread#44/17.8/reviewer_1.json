{
  "user_message": "An agent A claimed that the following MHD_polling_thread code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_polling_thread.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function MHD_select has a parameter int32_t millisec which is assigned to (millisec = 0;) inside the function. Rule 17.8 prohibits modifying function parameters (the object referred to by a pointer parameter may be modified, but not the pointer itself). Since millisec is a non-pointer parameter and is being modified, this violates MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int32_t MHD_YES = 1;\nvoid MHD_thread_handle_ID_set_current_thread_ID_(void *tid);\nstatic inline int MHD_D_IS_USING_POLL_(struct MHD_Daemon *d) { return d->use_poll; }\nstatic inline int MHD_D_IS_USING_EPOLL_(struct MHD_Daemon *d) { return d->use_epoll; }\nstatic void MHD_log_probe(const char *event, struct MHD_Daemon *daemon, const char *note, int32_t value)\n{\n  FILE *fp = fopen(\"/tmp/logs/357.txt\", \"a\");\n  if (fp == NULL)\n  {\n    /* best-effort: try to create parent dir and reopen */\n    (void) system(\"mkdir -p /tmp/logs\");\n    fp = fopen(\"/tmp/logs/357.txt\", \"a\");\n  }\n  if (fp != NULL)\n  {\n    /* Print a compact record of the current state. Use casts to avoid\n     * format-mismatch warnings for fields whose exact types are\n     * application-specific. This function purposely does not change\n     * any program state. */\n    fprintf(fp, \"%s: event=%s daemon=%p shutdown=%d sigpipe_blocked=%d options=0x%08lx note=%s value=%d\\n\",\n            \"MHD_probe\",\n            event,\n            (void *) daemon,\n            (int) daemon->shutdown,\n            (int) daemon->sigpipe_blocked,\n            (unsigned long) daemon->options,\n            note ? note : \"\",\n            (int) value);\n    fflush(fp);\n    fclose(fp);\n  }\n}\n\nstatic void *\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n  sigset_t s_mask;\n  int err;\n\n  /* Log entry to the polling thread. */\n  MHD_log_probe(\"ENTRY\", daemon, \"polling thread start\", -1);\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n\n  /* Log after setting thread id. */\n  MHD_log_probe(\"AFTER_TID_SET\", daemon, \"thread id set\", -1);\n\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n\n  /* Log result of sigmask attempt. */\n  MHD_log_probe(\"SIGMASK\", daemon, \"pthread_sigmask result\", err);\n\n  while (! daemon->shutdown)\n  {\n    if (MHD_D_IS_USING_POLL_ (daemon))\n    {\n      MHD_log_probe(\"BRANCH\", daemon, \"using poll -> calling MHD_poll\", (int32_t) MHD_YES);\n      MHD_poll (daemon, (int) MHD_YES);\n    }\n    else if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      MHD_log_probe(\"BRANCH\", daemon, \"using epoll -> calling MHD_epoll\", -1);\n      MHD_epoll (daemon, -1);\n    }\n    else\n    {\n      /* Use a local variable to capture the intended millisec argument\n       * for MHD_select and log it. This preserves the original call\n       * semantics while providing a probe point for other agents to\n       * compare the passed value with any internal changes inside\n       * MHD_select. */\n      int32_t sel_millisec = -1;\n      MHD_log_probe(\"CALL\", daemon, \"about to call MHD_select\", sel_millisec);\n      MHD_select (daemon, sel_millisec);\n      /* Log immediately after returning from MHD_select so callers can\n       * correlate the call sequence. We intentionally do not assume any\n       * change to sel_millisec because it is passed by value. */\n      MHD_log_probe(\"RETURN\", daemon, \"returned from MHD_select\", sel_millisec);\n    }\n    MHD_cleanup_connections (daemon);\n\n    /* Log end of one loop iteration including shutdown flag so a trace\n     * can show when the loop ultimately exits. */\n    MHD_log_probe(\"LOOP\", daemon, \"end of iteration\", -1);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (/* emulate test bit */ (1UL) & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  MHD_log_probe(\"EXIT\", daemon, \"polling thread exit\", -1);\n\n  return (void *) 0;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C:2023 Rule 17.8 forbids modifying a function parameter inside that function (pointer parameters may be used to modify the object pointed to, but the pointer itself must not be changed). The code shown (MHD_polling_thread) does not modify its parameter cls; it assigns cls to a local pointer variable (daemon) and never writes to cls itself. The agent\u2019s claim refers to an assignment to a non-pointer parameter millisec inside MHD_select; if MHD_select indeed assigns to its parameter (e.g. millisec = 0;), that would be a violation, but it would be a violation in MHD_select\u2019s definition, not in MHD_polling_thread. No definition of MHD_select was provided and the supplied test code did not produce runnable evidence, so there is no basis to conclude the presented MHD_polling_thread code violates Rule 17.8. Therefore the report is incorrect."
}