{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 1.2.\nHere is the comment from the agent.\n<violation scenario>\nThe typedef uses the WINAPI macro in the function-pointer declaration: typedef BOOL (WINAPI *GPDCSM_PTR)(...); WINAPI typically expands to a Microsoft-specific calling convention (e.g. __stdcall), which is a compiler language extension documented by MS compilers. This use of a non\u2011standard calling convention macro violates MISRA C 2023 Rule 1.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified mhd_tool_get_proc_cpu_count code that contains useful probe functions that print useful logs to a file \"/tmp/logs/240.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of mhd_tool_get_proc_cpu_count as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_proc_cpu_count:\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\nPlease provide the modified mhd_tool_get_proc_cpu_count code.\n",
  "test_code": "#include <stdio.h>\n\n/* Probes for logging control flow and state to /tmp/logs/240.txt */\nstatic void\nmhd_tool_log_probe(const char *stage, const char *fname, int res, const void *addr)\n{\n  FILE *f = fopen(\"/tmp/logs/240.txt\", \"a\");\n  if (f == NULL)\n    return; /* don't disturb normal control flow if logging fails */\n\n  /* Log a compact record: stage, function name, address (if available), result */\n  fprintf(f, \"stage=%s func=%s addr=%p res=%d\\n\", stage, fname, addr, res);\n  fclose(f);\n}\n\n/* External declarations for the helper functions used by the original logic.\n   These are declared to allow logging their addresses and results without\n   changing their behavior. Their signatures are expected to match the real\n   definitions elsewhere in the program. */\nextern int mhd_tool_get_proc_cpu_count_sched_getaffinity_(void);\nextern int mhd_tool_get_proc_cpu_count_cpuset_getaffinity_(void);\nextern int mhd_tool_get_proc_cpu_count_sched_getaffinity_np_(void);\nextern int mhd_tool_get_proc_cpu_count_w32_(void);\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n  /* Log entry into the function */\n  mhd_tool_log_probe(\"entry\", \"mhd_tool_get_proc_cpu_count\", 0, (const void *)&mhd_tool_get_proc_cpu_count);\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"cpuset_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n    return res;\n  }\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  mhd_tool_log_probe(\"before_call\", \"cpuset_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n    return res;\n  }\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity_np\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity_np\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity_np\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"w32\", 0, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  /* The w32 path is the most relevant for detecting Windows-specific\n     calling-convention macros (e.g. WINAPI). Log the function address and\n     returned value so external analysis can correlate the path taken with\n     any Windows-specific symbols or typedefs in the codebase. */\n  mhd_tool_log_probe(\"after_call\", \"w32\", res, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"w32\", res, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"return\", \"final\", -1, NULL);\n  return -1;\n}\n"
}