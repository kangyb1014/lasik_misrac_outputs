{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code enclosed in \"#if 0 ... #endif\" is permanently excluded from compilation (constant false conditional). That block (GetThreadGroupAffinity usage) can never be part of any translation unit built with the current source and therefore is unreachable/dead code present in the project.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_msg (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/241.txt\", \"a\");\n  if (!f)\n    return;\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\nstatic void\nlog_call_result (const char *call_name, int res)\n{\n  if (res > 0)\n    log_msg(\"%s -> %d (positive, will be returned)\", call_name, res);\n  else\n    log_msg(\"%s -> %d\", call_name, res);\n}\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* Log which compile-time branch was selected so callers can see why\n     certain platform-specific code (possibly guarded elsewhere with\n     preprocessor conditions) may be excluded from the build. */\n  log_msg(\"mhd_tool_get_proc_cpu_count: compiled with __linux__ or __GLIBC__ branch\");\n\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_sched_getaffinity_\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_sched_getaffinity_\", res);\n  if (0 < res)\n    return res;\n\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_cpuset_getaffinity_\");\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_cpuset_getaffinity_\", res);\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  log_msg(\"mhd_tool_get_proc_cpu_count: compiled with non-Linux/non-GLIBC branch\");\n\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_cpuset_getaffinity_\");\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_cpuset_getaffinity_\", res);\n  if (0 < res)\n    return res;\n\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_sched_getaffinity_\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_sched_getaffinity_\", res);\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_sched_getaffinity_np_\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_sched_getaffinity_np_\", res);\n  if (0 < res)\n    return res;\n\n  log_msg(\"About to call: mhd_tool_get_proc_cpu_count_w32_\");\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  log_call_result(\"mhd_tool_get_proc_cpu_count_w32_\", res);\n  if (0 < res)\n    return res;\n\n  log_msg(\"No method returned a positive CPU count; returning -1\");\n  return -1;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_proc_cpu_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the supplied code. The function shown contains #if/#else conditional compilation controlled by macros (__linux__ / __GLIBC__), not a permanent \"#if 0\" block, and all calls present in the active translation unit are reachable at run time (subject to runtime returns). The agent's scenario asserts there is a \"#if 0 ... GetThreadGroupAffinity ... #endif\" block permanently excluded from every build, but no such block is present in the provided source for this function and no evidence (file/line showing a constant-false preprocessor condition) was provided. The empty test log only shows that the test run did not exercise this function; it does not demonstrate a MISRA 2.1 violation in the code shown. If there really is unreachable code guarded by a constant-false preprocessor condition elsewhere in the project, the reporter must point to the exact source location and show that the condition can never be true; only then can a definite MISRA 2.1 violation be concluded."
}