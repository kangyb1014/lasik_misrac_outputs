{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_iovec_track_ (definition)",
    "definition of the iov element type used in r_iov->iov (e.g. struct iovec or struct MHD_iovec_) \u2014 including fields iov_base and iov_len",
    "typedef MHD_iov_size_",
    "struct MHD_Connection (definition)",
    "declaration/signature of pre_send_setopt",
    "declaration/signature of post_send_setopt",
    "struct msghdr (declaration)",
    "struct iovec (declaration from <sys/uio.h>)",
    "WSABUF and LPWSABUF definitions (Windows path)"
  ],
  "explanation": "Why each symbol is needed for the MISRA-C \"pointer should point to a const-qualified type whenever possible\" check:\n\n- struct MHD_iovec_track_ (definition)\n  - The function parameter r_iov is declared as `struct MHD_iovec_track_ *const r_iov`. To decide whether the pointee should be const-qualified (i.e. `const struct MHD_iovec_track_ *`), we must know the actual members of this struct (names and types) and whether this function or callees modify any of those members (e.g. `sent`, `cnt`, `iov` pointer). The struct definition shows which fields are mutated here and elsewhere, so it is essential to determine if the pointee can be const.\n\n- definition of the iov element type used in r_iov->iov (e.g. struct iovec or struct MHD_iovec_) \u2014 including fields iov_base and iov_len\n  - The function reads and modifies elements of r_iov->iov: it advances r_iov->iov[r_iov->sent].iov_base and subtracts from iov_len. To know whether the data pointer type could/should be pointer-to-const (for MISRA purposes) we need the exact declaration of the iov element type (the types of iov_base and iov_len). For example, if iov_base is declared as `void *` (non-const) vs `const void *`, or if it is a char*/const char*, that directly affects whether const-qualification is possible/required.\n\n- typedef MHD_iov_size_\n  - This typedef is used when adjusting iov_len (cast/subtraction). Its underlying integer type and signedness affect whether modifying iov_len or casting to it would mask constness issues or create implied mutations. Knowing the typedef is necessary to reason about whether iov_len should be const-qualified or whether arithmetic here legitimately mutates the structure.\n\n- struct MHD_Connection (definition)\n  - The function accepts `struct MHD_Connection *connection` and writes to connection members (e.g. epoll_state) and passes it to pre/post send helper functions. To determine whether the connection pointer could be const-qualified (or pointer-to-const), we must inspect the struct to see which members are modified here and whether those modifications prevent adding const to the pointee type.\n\n- declaration/signature of pre_send_setopt\n  - send_iov_nontls calls pre_send_setopt(connection, true, push_data). If pre_send_setopt's prototype takes a non-const pointer to connection or mutates the pointed-to object, that prevents making the connection parameter a pointer-to-const. The declaration (parameter types and const qualification) is required to determine whether the call enforces non-const.\n\n- declaration/signature of post_send_setopt\n  - Similarly, post_send_setopt is invoked and may accept/modify connection or other pointers; its prototype tells whether those arguments must be non-const and thus whether the local pointer types must remain non-const.\n\n- struct msghdr (declaration)\n  - When HAVE_SENDMSG is used, msg.msg_iov is assigned r_iov->iov + r_iov->sent. The type of msg.msg_iov (usually struct iovec *) determines whether passing r_iov->iov requires a pointer-to-const or not. The msghdr declaration shows whether msg.msg_iov expects const-qualified iovec or not, which is relevant to whether the iov array and its element types should be const-qualified.\n\n- struct iovec (declaration from <sys/uio.h>)\n  - On POSIX systems the iov element is typically struct iovec with fields `void *iov_base` and `size_t iov_len`. The exact field types (pointer-to-void vs pointer-to-const-void) are required to determine whether the iov data could/should be const-qualified for MISRA.\n\n- WSABUF and LPWSABUF definitions (Windows path)\n  - On Windows the code casts r_iov->iov to LPWSABUF and calls WSASend. WSABUF has a buffer pointer type (e.g. `char *buf`). To reason about constness of the iov element and whether its buffer pointer could be pointer-to-const, we need WSABUF/LPWSABUF declarations.\n\nIn short: to decide if any pointer types in send_iov_nontls (the r_iov pointer, the iov[i].iov_base pointer, the connection pointer, or the iov array type) could or should be made pointer-to-const without breaking semantics, we need the concrete definitions and function prototypes listed above. Those symbols show which objects are mutated here or by called helpers, and the exact pointer types currently used in the iovec/msghdr/WSABUF APIs that influence whether const-qualification is possible."
}