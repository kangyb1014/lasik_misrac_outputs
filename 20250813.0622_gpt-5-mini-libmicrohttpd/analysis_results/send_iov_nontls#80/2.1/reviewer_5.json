{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:With HAVE_SENDMSG defined (as shown in the additional code) the preprocessor will always select the HAVE_SENDMSG branch. The #elif defined(HAVE_WRITEV) branch (the writev() call) can never be compiled/executed in this project configuration, so that fragment is unreachable.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/641.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  /* Log entry state */\n  mhd_probe_log (\"enter send_iov_nontls: connection=%p socket_fd=%ld state=%d daemon_options=0x%08x r_iov=%p r_iov->cnt=%zu r_iov->sent=%zu push_data=%d\",\n                 (void *) connection,\n                 (long) connection->socket_fd,\n                 (int) connection->state,\n                 (unsigned) connection->daemon->options,\n                 (void *) r_iov,\n                 (size_t) r_iov->cnt,\n                 (size_t) r_iov->sent,\n                 (int) push_data);\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    mhd_probe_log (\"early return: invalid socket or closed connection\");\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n    {\n      mhd_probe_log (\"_MHD_IOV_MAX == 0: returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    mhd_probe_log (\"_MHD_IOV_MAX (%d) < items_to_send (%zu): truncating to %d and disabling push_data\",\n                   (int) _MHD_IOV_MAX, items_to_send, (int) _MHD_IOV_MAX);\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  mhd_probe_log (\"branch chosen at compile-time: HAVE_SENDMSG\");\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  mhd_probe_log (\"prepared msghdr: msg_iovlen=%zu r_iov->sent=%zu items_to_send=%zu push_data=%d\",\n                 (size_t) msg.msg_iovlen, (size_t) r_iov->sent, items_to_send, (int) push_data);\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n  mhd_probe_log (\"sendmsg returned: res=%ld\", (long) res);\n#elif defined(HAVE_WRITEV)\n  mhd_probe_log (\"branch chosen at compile-time: HAVE_WRITEV\");\n  mhd_probe_log (\"writev params: socket_fd=%ld start_iov=%zu items_to_send=%zu push_data=%d\",\n                 (long) connection->socket_fd, (size_t) r_iov->sent, items_to_send, (int) push_data);\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n  mhd_probe_log (\"writev returned: res=%ld\", (long) res);\n#elif defined(MHD_WINSOCK_SOCKETS)\n  mhd_probe_log (\"branch chosen at compile-time: MHD_WINSOCK_SOCKETS\");\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  mhd_probe_log (\"WSASend params: cnt_w=%u push_data=%d r_iov->sent=%zu\",\n                 (unsigned) cnt_w, (int) push_data, (size_t) r_iov->sent);\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n  mhd_probe_log (\"WSASend returned: res=%ld bytes_sent=%u\", (long) res, (unsigned) bytes_sent);\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n    mhd_probe_log (\"send error: res=%ld err=%d\", (long) res, err);\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      mhd_probe_log (\"error path: EAGAIN -> return MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_probe_log (\"error path: EINTR -> return MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      mhd_probe_log (\"error path: REMOTE_DISCONNECT -> return MHD_ERR_CONNRESET_\");\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      mhd_probe_log (\"error path: EPIPE -> return MHD_ERR_PIPE_\");\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      mhd_probe_log (\"error path: EOPNOTSUPP -> return MHD_ERR_OPNOTSUPP_\");\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      mhd_probe_log (\"error path: ENOTCONN -> return MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      mhd_probe_log (\"error path: EINVAL -> return MHD_ERR_INVAL_\");\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      mhd_probe_log (\"error path: LOW_RESOURCES -> return MHD_ERR_NOMEM_\");\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      mhd_probe_log (\"error path: EBADF -> return MHD_ERR_BADF_\");\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    mhd_probe_log (\"error path: other -> return MHD_ERR_NOTCONN_\");\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    mhd_probe_log (\"adjusting tracking: initial track_sent=%zu r_iov->sent=%zu r_iov->cnt=%zu\",\n                   track_sent, (size_t) r_iov->sent, (size_t) r_iov->cnt);\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n      mhd_probe_log (\"consumed iov element, new track_sent=%zu r_iov->sent=%zu\",\n                     track_sent, (size_t) r_iov->sent);\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      post_send_setopt (connection, true, push_data);\n      mhd_probe_log (\"all iov sent: r_iov->cnt == r_iov->sent (%zu)\", (size_t) r_iov->sent);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        mhd_probe_log (\"partial send: remaining in current iov new iov_base=%p iov_len=%zu\",\n                       r_iov->iov[r_iov->sent].iov_base,\n                       (size_t) r_iov->iov[r_iov->sent].iov_len);\n      }\n    }\n  }\n\n  mhd_probe_log (\"exit send_iov_nontls: res=%ld r_iov->sent=%zu\",\n                 (long) res, (size_t) r_iov->sent);\n\n  return res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for send_iov_nontls. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The code in the #elif defined(HAVE_WRITEV) branch is not \"unreachable\" in the sense MISRA Rule 2.1 targets: it is excluded by the preprocessor when HAVE_SENDMSG is defined, so it does not exist in the resulting translation unit and therefore cannot be considered unreachable code in the compiled program. MISRA\u2019s rule about unreachable code concerns code that is present in the compiled program but cannot be executed at run time (for example a branch guarded by a constant true/false expression). Conditional compilation for platform/feature portability (mutually exclusive #ifdef/#elif branches) is the intended way to select one implementation at compile time and does not by itself create a Rule 2.1 violation. The empty test log only shows the function wasn\u2019t invoked (or the test didn\u2019t exercise it); it does not prove a MISRA unreachable-code breach. Therefore the agent A claim is incorrect."
}