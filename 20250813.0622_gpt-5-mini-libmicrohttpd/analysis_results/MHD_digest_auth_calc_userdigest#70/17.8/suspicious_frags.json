{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_calc_userdigest:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_digest_auth_calc_userdigest:\n_MHD_static_inline enum MHD_DigestBaseAlgo\nget_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3)\n{\n  unsigned int base_algo;\n\n  base_algo =\n    ((unsigned int) algo3)\n    & ~((unsigned int)\n        (MHD_DIGEST_AUTH_ALGO3_NON_SESSION\n         | MHD_DIGEST_AUTH_ALGO3_NON_SESSION));\n  return (enum MHD_DigestBaseAlgo) base_algo;\n}\n...\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n...\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n...\n_MHD_static_inline void\ndigest_update_with_colon (struct DigestAlgorithm *da)\n{\n  static const uint8_t colon = (uint8_t) ':';\n  digest_update (da, &colon, 1);\n}\n...\n_MHD_static_inline void\ndigest_update_str (struct DigestAlgorithm *da,\n                   const char *str)\n{\n  const size_t str_len = strlen (str);\n  digest_update (da, (const uint8_t *) str, str_len);\n}\n...\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n...\n#define digest_deinit(da) (void)0\n...\n#define digest_ext_error(da) (false)\n...\nstruct DigestAlgorithm\n{\n  /**\n   * A context for the digest algorithm, already initialized to be\n   * useful for @e init, @e update and @e digest.\n   */\n  union DigestCtx ctx;\n\n  /**\n   * The hash calculation algorithm.\n   */\n  enum MHD_DigestBaseAlgo algo;\n\n  /**\n   * Buffer for hex-print of the final digest.\n   */\n#ifdef _DEBUG\n  bool uninitialised; /**< The structure has been not set-up */\n  bool algo_selected; /**< The algorithm has been selected */\n  bool ready_for_hashing; /**< The structure is ready to hash data */\n  bool hashing; /**< Some data has been hashed, but the digest has not finalised yet */\n#endif /* _DEBUG */\n}\n...\nenum MHD_DigestAuthAlgo3\n{\n  /**\n   * Unknown or wrong algorithm type.\n   * Used in struct MHD_DigestAuthInfo to indicate client value that\n   * cannot by identified.\n   */\n  MHD_DIGEST_AUTH_ALGO3_INVALID = 0,\n\n  /**\n   * The 'MD5' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5 =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'MD5-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5_SESSION =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-256' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256 =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-256-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-512-256' (SHA-512/256) algorithm.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256 =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-512-256-sess' (SHA-512/256 session) algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_SESSION\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no code fragments that modify a function parameter variable itself (which MISRA C 2023 Rule 17.8 forbids). Summary of checks and reasons why no fragments require investigation:\n\n- MHD_digest_auth_calc_userdigest: reads its parameters and passes pointers to helper functions; it does not assign to or change any parameter variable. The userdigest_bin pointer is passed through to calc_userdigest/digest_calc_hash where the object pointed-to is written \u2014 this is allowed by the rule (the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified).\n\n- calc_userdigest: calls digest_update/digest_update_with_colon/digest_update_str/digest_calc_hash; it does not assign to or alter its pointer parameters themselves.\n\n- digest_update, digest_update_with_colon, digest_update_str: these functions use pointer parameters to pass data to hash update functions; they do not modify the pointer parameters (no assignments, increments or rebindings of the parameter variables).\n\n- digest_calc_hash and digest_init_one_time: modify the state of the DigestAlgorithm object via the pointer parameter (da->...), which is permitted because the object referred to by the pointer may be modified; neither function assigns to the pointer variable itself.\n\n- get_base_digest_algo: takes an enum parameter and only reads it (computes a local unsigned base_algo); the parameter is not modified.\n\n- Macros digest_deinit and digest_ext_error expand to (void)0 and (false) respectively, so they do not modify any parameter.\n\nNo occurrences of statements like \"param = ...\", \"param += ...\", \"++param\", or similar that would reassign or otherwise modify a parameter variable were found. Therefore there are no fragments that violate Rule 17.8."
}