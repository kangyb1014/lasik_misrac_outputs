{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call digest_deinit(&da) expands to the macro (void)0 (a no-op). It is executed but has no effect; removing that statement would not change program behaviour in the provided build configuration, so it is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void append_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/562.txt\", \"a\");\n    if (f == NULL)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\nstatic void dump_mem(const void *ptr, size_t size)\n{\n    const unsigned char *p = (const unsigned char *)ptr;\n    size_t i, limit = size;\n    /* avoid excessively large logs; cap to 256 bytes */\n    if (limit > 256U)\n        limit = 256U;\n    FILE *f = fopen(\"/tmp/logs/562.txt\", \"a\");\n    if (f == NULL)\n        return;\n    fprintf(f, \"dump_mem(%p, size=%zu) first %zu bytes:\\n\", ptr, (size_t)size, limit);\n    for (i = 0; i < limit; ++i)\n    {\n        if ((i % 16) == 0)\n            fprintf(f, \"%04zx: \", i);\n        fprintf(f, \"%02x \", (unsigned)p[i]);\n        if ((i % 16) == 15)\n            fprintf(f, \"\\n\");\n    }\n    if ((limit % 16) != 0)\n        fprintf(f, \"\\n\");\n    if (size > limit)\n        fprintf(f, \"... (truncated, total size=%zu)\\n\", (size_t)size);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  /* Log entry and parameter state */\n  append_log(\"MHD_digest_auth_calc_userdigest ENTER: algo3=%d, username=%p('%s'), realm=%p('%s'), password=%p, userdigest_bin=%p, bin_buf_size=%zu\",\n             (int)algo3,\n             (const void *)username, username ? username : \"(null)\",\n             (const void *)realm, realm ? realm : \"(null)\",\n             (const void *)password,\n             userdigest_bin,\n             bin_buf_size);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    append_log(\"digest_init_one_time FAILED\");\n    return MHD_NO;\n  }\n\n  append_log(\"digest_init_one_time SUCCEEDED\");\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    size_t username_len = username ? strlen (username) : 0;\n    size_t realm_len = realm ? strlen (realm) : 0;\n\n    append_log(\"About to calc_userdigest: username_len=%zu, realm_len=%zu\", username_len, realm_len);\n\n    /* Capture state of 'da' before calc_userdigest */\n    dump_mem(&da, sizeof da);\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n\n    append_log(\"calc_userdigest returned\");\n\n    /* Capture state of 'da' after calc_userdigest */\n    dump_mem(&da, sizeof da);\n\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      append_log(\"digest_ext_error detected\");\n      ret = MHD_NO;\n    }\n    else\n    {\n      append_log(\"no digest_ext_error detected\");\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n\n  /* Capture state immediately before digest_deinit */\n  append_log(\"Before digest_deinit: dumping 'da' state\");\n  dump_mem(&da, sizeof da);\n\n  /* This call is the reported no-op in some build configs. Keep it and log around it. */\n  append_log(\"Calling digest_deinit(&da)\");\n  digest_deinit (&da);\n  append_log(\"Returned from digest_deinit(&da)\");\n\n  /* Capture state immediately after digest_deinit to detect whether it modified 'da' */\n  append_log(\"After digest_deinit: dumping 'da' state\");\n  dump_mem(&da, sizeof da);\n\n  append_log(\"MHD_digest_auth_calc_userdigest EXIT: ret=%d\", (int)ret);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_calc_userdigest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is plausible in principle \u2014 if in the actual project configuration digest_deinit(&da) truly expands to a no-op (for example a macro defined as (void)0) then that expression statement is executed but has no effect, and removing it would not change program behaviour; that would satisfy MISRA C 2023 Rule 2.2 (dead code). However, the report as given does not demonstrate that this is the case in the project under review. The supplied test harness did not exercise the function (the log for this function is empty) and no preprocessed source or header showing digest_deinit's definition was provided. MISRA Rule 2.2 applies to the project/build actually analysed, so you must show the effective expansion in that build (e.g. inspect the preprocessing output or the defining header) to conclude a violation. Recommendation: examine the preprocessing output (compiler -E) or the header that defines digest_deinit; if it is indeed defined as a no-op in the project, the statement is dead code and must be removed or formally justified/marked as a deviation. Otherwise the report is not supported by the evidence given."
}