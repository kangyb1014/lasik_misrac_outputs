{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to strlen(str) in digest_update_str (invoked from calc_userdigest -> MHD_digest_auth_calc_userdigest) can read past the end of the object if the caller supplies a non\u2011null\u2011terminated buffer. There is no validation in MHD_digest_auth_calc_userdigest/calc_userdigest that the username/realm/password are NUL-terminated or limited in length, so a caller that passes a char[] filled without a terminating '\\0' (or a pointer not pointing to a valid NUL-terminated C string) will cause strlen to access beyond the object bounds, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_digest_probe_log(const char *stage,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (!f)\n    return;\n\n  /* Log stage and key pointer/size information. Avoid printing the\n     pointed-to data (no %s) to not cause additional out-of-bounds reads. */\n  fprintf(f, \"[MHD_DIGEST_PROBE] stage=%s\\n\", stage);\n  fprintf(f, \"  username_ptr=%p\\n\", (void *) username);\n  fprintf(f, \"  realm_ptr=%p\\n\", (void *) realm);\n  fprintf(f, \"  password_ptr=%p\\n\", (void *) password);\n  fprintf(f, \"  userdigest_bin_ptr=%p\\n\", userdigest_bin);\n  fprintf(f, \"  bin_buf_size=%zu\\n\", bin_buf_size);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  /* Log entry with pointer/size state. */\n  mhd_digest_probe_log(\"entry\", username, realm, password,\n                       userdigest_bin, bin_buf_size);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    mhd_digest_probe_log(\"digest_init_one_time_failed\", username, realm,\n                         password, userdigest_bin, bin_buf_size);\n    return MHD_NO;\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n  {\n    mhd_digest_probe_log(\"bin_buffer_too_small\", username, realm, password,\n                         userdigest_bin, bin_buf_size);\n    ret = MHD_NO;\n  }\n  else\n  {\n    /* Log just before calling strlen to mark the potentially unsafe access.\n       We intentionally do not modify the original calls to strlen: the goal\n       is to record evidence when they are invoked (including pointer values)\n       so callers that pass non-terminated buffers can be reproduced. */\n    mhd_digest_probe_log(\"before_strlen\", username, realm, password,\n                         userdigest_bin, bin_buf_size);\n\n    /* Preserve original behavior: call strlen exactly as before (may read\n       past bounds if caller supplied a non-terminated buffer). Capture the\n       returned lengths immediately and log them. */\n    size_t username_len = strlen (username);\n    size_t realm_len = strlen (realm);\n\n    {\n      FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n      if (f)\n      {\n        fprintf(f, \"[MHD_DIGEST_PROBE] strlen_results username_len=%zu realm_len=%zu\\n\",\n                username_len, realm_len);\n        fclose(f);\n      }\n    }\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n\n    mhd_digest_probe_log(\"after_calc_userdigest\", username, realm, password,\n                         userdigest_bin, bin_buf_size);\n\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      mhd_digest_probe_log(\"digest_ext_error_set\", username, realm, password,\n                           userdigest_bin, bin_buf_size);\n      ret = MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  mhd_digest_probe_log(\"exit\", username, realm, password,\n                       userdigest_bin, bin_buf_size);\n\n  return ret;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb008\n  realm_ptr=0x563c94fbb00a\n  password_ptr=0x563c94fbb00c\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94fbb008\n  realm_ptr=0x563c94fbb00a\n  password_ptr=0x563c94fbb00c\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] strlen_results username_len=1 realm_len=1\n[MHD_DIGEST_PROBE] stage=after_calc_userdigest\n  username_ptr=0x563c94fbb008\n  realm_ptr=0x563c94fbb00a\n  password_ptr=0x563c94fbb00c\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=exit\n  username_ptr=0x563c94fbb008\n  realm_ptr=0x563c94fbb00a\n  password_ptr=0x563c94fbb00c\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb00e\n  realm_ptr=0x563c94fbb017\n  password_ptr=0x563c94fbb021\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94fbb00e\n  realm_ptr=0x563c94fbb017\n  password_ptr=0x563c94fbb021\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] strlen_results username_len=8 realm_len=9\n[MHD_DIGEST_PROBE] stage=after_calc_userdigest\n  username_ptr=0x563c94fbb00e\n  realm_ptr=0x563c94fbb017\n  password_ptr=0x563c94fbb021\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=exit\n  username_ptr=0x563c94fbb00e\n  realm_ptr=0x563c94fbb017\n  password_ptr=0x563c94fbb021\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb02a\n  realm_ptr=0x563c94fbb034\n  password_ptr=0x563c94fbb03e\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94fbb02a\n  realm_ptr=0x563c94fbb034\n  password_ptr=0x563c94fbb03e\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] strlen_results username_len=9 realm_len=9\n[MHD_DIGEST_PROBE] stage=after_calc_userdigest\n  username_ptr=0x563c94fbb02a\n  realm_ptr=0x563c94fbb034\n  password_ptr=0x563c94fbb03e\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=exit\n  username_ptr=0x563c94fbb02a\n  realm_ptr=0x563c94fbb034\n  password_ptr=0x563c94fbb03e\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb04f\n  password_ptr=0x563c94fbb064\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb04f\n  password_ptr=0x563c94fbb064\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] strlen_results username_len=6 realm_len=20\n[MHD_DIGEST_PROBE] stage=after_calc_userdigest\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb04f\n  password_ptr=0x563c94fbb064\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=exit\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb04f\n  password_ptr=0x563c94fbb064\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb071\n  password_ptr=0x563c94fbb084\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb071\n  password_ptr=0x563c94fbb084\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] strlen_results username_len=6 realm_len=18\n[MHD_DIGEST_PROBE] stage=after_calc_userdigest\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb071\n  password_ptr=0x563c94fbb084\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=exit\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb071\n  password_ptr=0x563c94fbb084\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=entry\n  username_ptr=0x563c94fbb048\n  realm_ptr=0x563c94fbb093\n  password_ptr=0x563c94fbb0a9\n  userdigest_bin_ptr=0x7ffcd6406e20\n  bin_buf_size=16\n[MHD_DIGEST_PROBE] stage=before_strlen\n  username_ptr=0x563c94\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls strlen(username) and strlen(realm) without any validation or bounds information. MISRA C 2023 Rule 21.17 forbids the use of string.h functions in a way that can access beyond the bounds of the objects referenced by their pointer parameters. strlen reads until a NUL terminator; if a caller supplies a buffer or pointer that is not NUL-terminated within its valid bounds, strlen can read past the object boundary. The code does not enforce or check that username/realm/password are NUL-terminated or that their lengths are bounded, so the use of strlen here can result in out-of-bounds access and thus violates Rule 21.17."
}