{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strlen(username) can read past the bounds if username is NULL or not NUL-terminated. For example, if a caller passes a pointer to a fixed-size buffer that lacks a terminating '\\0' (e.g. char u[3] = {'a','b','c'}; MHD_digest_auth_calc_userdigest(..., u, ...)), or passes NULL, strlen(username) will access memory beyond the object and thus violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_digest_auth_calc_userdigest code that contains useful probe functions that print useful logs to a file \"/tmp/logs/567.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_digest_auth_calc_userdigest as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_calc_userdigest:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified MHD_digest_auth_calc_userdigest code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe logger: append control-flow and state information to /tmp/logs/567.txt */\nstatic void mhd_log_probe(const char *when,\n                          const char *username,\n                          const char *realm,\n                          const void *userdigest_bin,\n                          size_t bin_buf_size,\n                          const struct DigestAlgorithm *da)\n{\n  FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (!f)\n    return;\n\n  fprintf(f, \"[MHD_PROBE] %s\\n\", when);\n  fprintf(f, \"  username ptr = %p\\n\", (const void *)username);\n  fprintf(f, \"  realm ptr    = %p\\n\", (const void *)realm);\n  fprintf(f, \"  userdigest_bin ptr = %p\\n\", userdigest_bin);\n  fprintf(f, \"  bin_buf_size = %zu\\n\", bin_buf_size);\n\n  /* If we have a valid DigestAlgorithm pointer, try to log its size. */\n  if (da != NULL)\n    fprintf(f, \"  digest_get_size(&da) = %zu\\n\", (size_t) digest_get_size((struct DigestAlgorithm *)da));\n  else\n    fprintf(f, \"  DigestAlgorithm pointer is NULL\\n\");\n\n  /* Avoid dereferencing username/realm here to not change behavior; only report NULLness. */\n  fprintf(f, \"  username is %s\\n\", (username == NULL) ? \"NULL\" : \"non-NULL\");\n  fprintf(f, \"  realm    is %s\\n\", (realm == NULL) ? \"NULL\" : \"non-NULL\");\n\n  fflush(f);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  /* Log entry into the function with pointer state */\n  mhd_log_probe(\"entry\", username, realm, userdigest_bin, bin_buf_size, NULL);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3))) {\n    /* Log failure to initialize digest algorithm */\n    mhd_log_probe(\"digest_init_one_time failed\", username, realm, userdigest_bin, bin_buf_size, &da);\n    return MHD_NO;\n  }\n\n  /* Log after successful init: provide digest size info */\n  mhd_log_probe(\"after init\", username, realm, userdigest_bin, bin_buf_size, &da);\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    /* Log just before calling strlen on username/realm. This helps reproduce the violation scenario\n       where username could be NULL or not NUL-terminated. We purposely do NOT change the original\n       logic: we only log pointer state then proceed to call strlen as in the original code. */\n    mhd_log_probe(\"before strlen/calc_userdigest\", username, realm, userdigest_bin, bin_buf_size, &da);\n\n    /* Preserve original behavior: calls to strlen may read beyond bounds if username/realm are invalid. */\n    size_t username_len = strlen (username);\n    size_t realm_len = strlen (realm);\n\n    /* Log the lengths returned by strlen (note: calling strlen when username is NULL will typically crash,\n       which matches the original behavior being probed). */\n    {\n      FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n      if (f) {\n        fprintf(f, \"[MHD_PROBE] strlen(username) = %zu\\n\", username_len);\n        fprintf(f, \"[MHD_PROBE] strlen(realm)    = %zu\\n\", realm_len);\n        fflush(f);\n        fclose(f);\n      }\n    }\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    /* If userdigest_bin is provided and the buffer is large enough, log the digest bytes in hex\n       up to the digest size. This helps reproduce output state after successful calculation. */\n    if (userdigest_bin != NULL && digest_get_size(&da) <= bin_buf_size)\n    {\n      size_t dsz = digest_get_size(&da);\n      FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n      if (f)\n      {\n        unsigned char *b = (unsigned char *) userdigest_bin;\n        fprintf(f, \"[MHD_PROBE] userdigest_bin (hex, %zu bytes):\", dsz);\n        for (size_t i = 0; i < dsz; ++i)\n          fprintf(f, \" %02x\", (unsigned int) b[i]);\n        fprintf(f, \"\\n\");\n        fflush(f);\n        fclose(f);\n      }\n    }\n  }\n\n  /* Log result before deinitialization */\n  {\n    FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n    if (f) {\n      fprintf(f, \"[MHD_PROBE] ret before deinit = %d\\n\", (int) ret);\n      fflush(f);\n      fclose(f);\n    }\n  }\n\n  digest_deinit (&da);\n\n  /* Final log after deinit */\n  mhd_log_probe(\"exit\", username, realm, userdigest_bin, bin_buf_size, &da);\n\n  return ret;\n}\n"
}