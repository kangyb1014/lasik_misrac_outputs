{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The helper digest_update_str calls strlen(str) unconditionally. If a caller passes password == NULL (or a pointer to a non\u2011NUL\u2011terminated buffer), strlen will dereference/read beyond the object bounds. For example, calling MHD_digest_auth_calc_userdigest(..., password = NULL, ...) leads to digest_update_str -> strlen(NULL) (undefined behavior / out\u2011of\u2011bounds access).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n\n  if (log)\n    {\n      fprintf(log, \"ENTRY: MHD_digest_auth_calc_userdigest\\n\");\n      fprintf(log, \"  algo3=%d\\n\", (int) algo3);\n      fprintf(log, \"  username=%p (is_null=%d)\\n\", (void *) username, (username == NULL));\n      fprintf(log, \"  realm=%p (is_null=%d)\\n\", (void *) realm, (realm == NULL));\n      fprintf(log, \"  password=%p (is_null=%d)\\n\", (void *) password, (password == NULL));\n      fprintf(log, \"  userdigest_bin=%p\\n\", userdigest_bin);\n      fprintf(log, \"  bin_buf_size=%zu\\n\", bin_buf_size);\n      fflush(log);\n    }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    {\n      if (log)\n        {\n          fprintf(log, \"  digest_init_one_time: FAILED -> returning MHD_NO\\n\");\n          fclose(log);\n        }\n      return MHD_NO;\n    }\n\n  /* Record digest algorithm size and decision point. */\n  {\n    size_t needed = digest_get_size (&da);\n    if (log)\n      {\n        fprintf(log, \"  digest_get_size() = %zu\\n\", needed);\n        fprintf(log, \"  comparing needed > bin_buf_size -> %d\\n\", (needed > bin_buf_size));\n        fflush(log);\n      }\n\n    if (needed > bin_buf_size)\n      ret = MHD_NO;\n    else\n      {\n        /* Log that we are about to call calc_userdigest. Do not call strlen here on possibly NULL pointers\n           to avoid introducing additional dereferences beyond the original behavior. The original code\n           will still call strlen(username) and strlen(realm) below as before. */\n        if (log)\n          {\n            fprintf(log, \"  about to call calc_userdigest with: username=%p, realm=%p, password=%p\\n\",\n                    (void *) username, (void *) realm, (void *) password);\n            fprintf(log, \"  Note: not computing lengths here to avoid extra dereference in logging.\\n\");\n            fflush(log);\n          }\n\n        calc_userdigest (&da,\n                         username,\n                         strlen (username),\n                         realm,\n                         strlen (realm),\n                         password,\n                         userdigest_bin);\n        ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n        if (digest_ext_error (&da))\n          ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n        if (log)\n          {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n            fprintf(log, \"  after calc_userdigest: ret=%d (MHD_YES= %d, MHD_NO= %d), ext_error=%d\\n\",\n                    (int) ret, (int) MHD_YES, (int) MHD_NO, (int) digest_ext_error(&da));\n#else\n            fprintf(log, \"  after calc_userdigest: ret=%d (MHD_YES= %d, MHD_NO= %d)\\n\",\n                    (int) ret, (int) MHD_YES, (int) MHD_NO);\n#endif\n            fflush(log);\n          }\n      }\n  }\n\n  digest_deinit (&da);\n\n  if (log)\n    {\n      fprintf(log, \"EXIT: MHD_digest_auth_calc_userdigest -> returning %d\\n\", (int) ret);\n      fprintf(log, \"------------------------------------------------------------\\n\");\n      fclose(log);\n    }\n\n  return ret;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c39008 (is_null=0)\n  realm=0x55ed18c3900a (is_null=0)\n  password=0x55ed18c3900c (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c39008, realm=0x55ed18c3900a, password=0x55ed18c3900c\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c3900e (is_null=0)\n  realm=0x55ed18c39017 (is_null=0)\n  password=0x55ed18c39021 (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c3900e, realm=0x55ed18c39017, password=0x55ed18c39021\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c3902a (is_null=0)\n  realm=0x55ed18c39034 (is_null=0)\n  password=0x55ed18c3903e (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c3902a, realm=0x55ed18c39034, password=0x55ed18c3903e\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c39048 (is_null=0)\n  realm=0x55ed18c3904f (is_null=0)\n  password=0x55ed18c39064 (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c39048, realm=0x55ed18c3904f, password=0x55ed18c39064\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c39048 (is_null=0)\n  realm=0x55ed18c39071 (is_null=0)\n  password=0x55ed18c39084 (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c39048, realm=0x55ed18c39071, password=0x55ed18c39084\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c39048 (is_null=0)\n  realm=0x55ed18c39093 (is_null=0)\n  password=0x55ed18c390a9 (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c39048, realm=0x55ed18c39093, password=0x55ed18c390a9\n  Note: not computing lengths here to avoid extra dereference in logging.\n  after calc_userdigest: ret=1 (MHD_YES= 1, MHD_NO= 0)\nEXIT: MHD_digest_auth_calc_userdigest -> returning 1\n------------------------------------------------------------\nENTRY: MHD_digest_auth_calc_userdigest\n  algo3=65\n  username=0x55ed18c390b8 (is_null=0)\n  realm=0x55ed18c390c4 (is_null=0)\n  password=0x55ed18c390d4 (is_null=0)\n  userdigest_bin=0x7ffe80cd4150\n  bin_buf_size=16\n  digest_get_size() = 16\n  comparing needed > bin_buf_size -> 0\n  about to call calc_userdigest with: username=0x55ed18c390\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 forbids calling string.h functions in a way that can read beyond the bounds of the objects referenced by their pointer parameters. In the shown MHD_digest_auth_calc_userdigest implementation the only direct uses of strlen are strlen(username) and strlen(realm) \u2014 these are invoked unconditionally and would be a violation of Rule 21.17 if username or realm could be NULL or non\u2011NUL\u2011terminated. However, the agent A claim specifically asserts that calling MHD_digest_auth_calc_userdigest(..., password = NULL, ...) leads to strlen(NULL). In the provided source for MHD_digest_auth_calc_userdigest there is no direct strlen(password) call; password is forwarded to calc_userdigest without a length argument. Therefore the specific scenario asserted by agent A (strlen(NULL) happening inside MHD_digest_auth_calc_userdigest due to password == NULL) is not supported by the shown function. The test logs also show non\u2011NULL pointers and no evidence of a strlen(NULL) crash. Conclusion: the agent's report as stated (that password == NULL causes strlen(NULL) in this function) is not correct. Note: the function does still perform unconditional strlen on username and realm and so would violate 21.17 if those parameters can be NULL \u2014 but that is a different issue than the agent's password\u2011based scenario."
}