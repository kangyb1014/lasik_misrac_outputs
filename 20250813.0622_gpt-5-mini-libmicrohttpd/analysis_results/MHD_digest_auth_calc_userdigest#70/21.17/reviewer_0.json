{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling MHD_digest_auth_calc_userdigest with username == NULL or realm == NULL (or with a non\u2013NUL-terminated buffer) will cause strlen(username)/strlen(realm) to access memory beyond the referenced object. The function performs no NULL or termination checks before calling strlen, so a caller supplying NULL or a non-terminated char* can trigger out\u2011of\u2011bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  /* Log entry and pointers/state. Do NOT dereference username/realm here. */\n  mhd_probe_log(\"ENTRY: MHD_digest_auth_calc_userdigest(algo3=%d, username=%p, realm=%p, password=%p, userdigest_bin=%p, bin_buf_size=%zu)\",\n                (int)algo3, (const void *)username, (const void *)realm, (const void *)password, userdigest_bin, bin_buf_size);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    mhd_probe_log(\"digest_init_one_time FAILED\");\n    return MHD_NO;\n  }\n\n  /* Record the required digest size before any further action. */\n  {\n    size_t needed = digest_get_size (&da);\n    mhd_probe_log(\"digest_get_size -> %zu; provided bin_buf_size = %zu\", needed, bin_buf_size);\n    if (needed > bin_buf_size)\n    {\n      mhd_probe_log(\"Insufficient buffer: needed %zu > bin_buf_size %zu\", needed, bin_buf_size);\n      ret = MHD_NO;\n    }\n    else\n    {\n      /* Log whether username/realm pointers are NULL (do not dereference). */\n      mhd_probe_log(\"About to call calc_userdigest: username_is_null=%d, realm_is_null=%d\",\n                    (username == NULL) ? 1 : 0,\n                    (realm == NULL) ? 1 : 0);\n\n      /* Preserve original behavior: this call may call strlen(username)/strlen(realm)\n         and thus can trigger out-of-bounds if username/realm are NULL or not NUL-terminated. */\n      calc_userdigest (&da,\n                       username,\n                       strlen (username),\n                       realm,\n                       strlen (realm),\n                       password,\n                       userdigest_bin);\n\n      ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n      if (digest_ext_error (&da))\n      {\n        mhd_probe_log(\"digest_ext_error returned true; overriding return to MHD_NO\");\n        ret = MHD_NO;\n      }\n      else\n      {\n        mhd_probe_log(\"digest_ext_error returned false; keeping return %d\", (int)ret);\n      }\n#else\n      mhd_probe_log(\"calc_userdigest completed; setting return %d\", (int)ret);\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    }\n  }\n\n  digest_deinit (&da);\n  mhd_probe_log(\"EXIT: MHD_digest_auth_calc_userdigest returning %d\", (int)ret);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_calc_userdigest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls strlen(username) and strlen(realm) unconditionally and does not check that the pointer arguments are non-NULL or that they point to NUL-terminated character arrays. If a caller supplies username == NULL or realm == NULL, strlen(NULL) is undefined behavior and will access memory out-of-bounds. Likewise, if the caller passes a non\u2013NUL-terminated buffer, strlen will read past the object\u2019s bounds. Under MISRA C 2023 Rule 21.17 these uses are problematic unless the function has an enforced precondition (documented and guaranteed by the caller or by prior validation) that username and realm are valid, NUL-terminated strings. As written, the code does not perform those checks, so the reported violation is correct. Recommended fixes: validate pointers (username != NULL, realm != NULL) and/or require/accept explicit length parameters, or otherwise ensure the preconditions are enforced before calling strlen."
}