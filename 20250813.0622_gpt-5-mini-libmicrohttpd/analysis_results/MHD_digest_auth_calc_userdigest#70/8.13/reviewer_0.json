{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function digest_get_size takes a non-const pointer parameter 'struct DigestAlgorithm *da' but only reads members of the structure (mhd_assert and a read of da->algo) and does not modify the object. According to MISRA C 2023 Rule 8.13, the pointer should be to a const-qualified type whenever possible \u2014 the parameter should be 'const struct DigestAlgorithm *da'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/563.txt\", \"a\");\n  if (f == NULL)\n    return;\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] \", (long)t);\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void probe_dump_mem(const char *label, const void *p, size_t n)\n{\n  FILE *f = fopen(\"/tmp/logs/563.txt\", \"a\");\n  if (f == NULL)\n    return;\n  size_t i;\n  const unsigned char *b = (const unsigned char *)p;\n  fprintf(f, \"%s ptr=%p size=%zu:\", label, p, n);\n  /* limit bytes printed to avoid huge logs */\n  size_t limit = n < 64 ? n : 64;\n  for (i = 0; i < limit; ++i)\n    fprintf(f, \" %02X\", b[i]);\n  if (n > limit)\n    fprintf(f, \" ...\");\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  probe_log(\"ENTER MHD_digest_auth_calc_userdigest: algo3=%d, username=%p, realm=%p, userdigest_bin=%p, bin_buf_size=%zu\",\n            (int)algo3, (const void *)username, (const void *)realm, userdigest_bin, bin_buf_size);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    probe_log(\"digest_init_one_time failed, returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Take a snapshot of 'da' after init to detect any unintended modifications\n     by functions that take a non-const pointer. */\n  size_t da_size = sizeof (da);\n  unsigned char *da_snapshot = (unsigned char *)malloc(da_size);\n  if (da_snapshot != NULL)\n  {\n    memcpy(da_snapshot, &da, da_size);\n    probe_dump_mem(\"da (after init)\", &da, da_size);\n  }\n  else\n  {\n    probe_log(\"WARNING: failed to allocate da_snapshot (size=%zu)\", da_size);\n  }\n\n  /* Call digest_get_size once and log its returned value and comparison. */\n  size_t required_size = digest_get_size (&da);\n  probe_log(\"digest_get_size(&da) returned %zu\", required_size);\n\n  if (required_size > bin_buf_size)\n  {\n    probe_log(\"required_size (%zu) > bin_buf_size (%zu): setting ret = MHD_NO\",\n              required_size, bin_buf_size);\n    ret = MHD_NO;\n  }\n  else\n  {\n    probe_log(\"required_size (%zu) <= bin_buf_size (%zu): proceeding to calc_userdigest\",\n              required_size, bin_buf_size);\n\n    /* Log inputs (avoid logging password contents) */\n    probe_log(\"calc_userdigest called with username=%p (len=%zu), realm=%p (len=%zu)\",\n              (const void *)username, username ? strlen(username) : 0u,\n              (const void *)realm, realm ? strlen(realm) : 0u);\n\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n\n    probe_log(\"calc_userdigest returned; userdigest_bin=%p\",\n              userdigest_bin);\n\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      probe_log(\"digest_ext_error(&da) returned true: setting ret = MHD_NO\");\n      ret = MHD_NO;\n    }\n    else\n    {\n      probe_log(\"digest_ext_error(&da) returned false\");\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n\n  /* Snapshot before deinit to allow comparison with post-init snapshot. */\n  if (da_snapshot != NULL)\n  {\n    probe_dump_mem(\"da (before deinit)\", &da, da_size);\n    if (memcmp(da_snapshot, &da, da_size) == 0)\n      probe_log(\"da memory unchanged since init (memcmp == 0)\");\n    else\n      probe_log(\"da memory CHANGED since init (memcmp != 0)\");\n    free(da_snapshot);\n  }\n\n  digest_deinit (&da);\n  probe_log(\"digest_deinit(&da) called; returning %s\", ret == MHD_YES ? \"MHD_YES\" : \"MHD_NO\");\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_calc_userdigest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not proven correct for the provided code. MISRA C 2023 Rule 8.13 concerns using const in pointer parameter declarations when the function does not modify the pointed-to object. In the snippet shown, the only place where that rule might apply is the declaration/definition of digest_get_size (and any other functions taking struct DigestAlgorithm *). The target function MHD_digest_auth_calc_userdigest itself does not declare a non-const pointer parameter to struct DigestAlgorithm \u2014 it simply calls digest_get_size(&da). Whether a violation exists depends on the prototype/definition of digest_get_size (which is not shown). If digest_get_size is declared as taking struct DigestAlgorithm * but in fact does not modify the object, then that function\u2019s declaration would violate Rule 8.13 and should be changed to accept const struct DigestAlgorithm * (subject to API compatibility). However, you cannot conclude that MHD_digest_auth_calc_userdigest itself violates Rule 8.13 from the code shown. Also note there are valid reasons for a non-const parameter (the function might modify the object in some builds, or the API may require a non-const for backward compatibility). To verify the report, inspect the digest_get_size prototype/definition: if it never modifies *da, change its parameter to const struct DigestAlgorithm * to comply with Rule 8.13. Given the information provided, the agent\u2019s report (that MHD_digest_auth_calc_userdigest violates Rule 8.13) is not correct."
}