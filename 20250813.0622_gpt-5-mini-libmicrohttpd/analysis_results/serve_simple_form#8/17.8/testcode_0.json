{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nIn MHD_queue_response the parameter 'status_code' (an unsigned int function parameter) is modified: 'status_code &= ~MHD_ICY_FLAG;'. Rule 17.8 forbids modifying function parameters (the pointer exception does not apply), so this is a violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified serve_simple_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/69.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of serve_simple_form as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of serve_simple_form:\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified serve_simple_form code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/* Probe logger: append human-readable logs to /tmp/logs/69.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/69.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n/* Lightweight wrapper around MHD_queue_response that logs entry/exit state.\n   This preserves original behavior by calling the real MHD_queue_response.\n   It intentionally does not modify the passed status_code parameter. */\nstatic enum MHD_Result\nprobe_MHD_queue_response (struct MHD_Connection *connection,\n                          unsigned int status_code,\n                          struct MHD_Response *response)\n{\n  enum MHD_Result r;\n  probe_log(\"probe_MHD_queue_response: entry: connection=%p, status_code=0x%X, response=%p\",\n            (void *) connection, (unsigned) status_code, (void *) response);\n  /* Call the original function */\n  r = MHD_queue_response (connection, status_code, response);\n  probe_log(\"probe_MHD_queue_response: exit: returned=%d, connection=%p, status_code=0x%X, response=%p\",\n            (int) r, (void *) connection, (unsigned) status_code, (void *) response);\n  return r;\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* Log entry and key state for reproducing the violation scenario */\n  probe_log(\"serve_simple_form: entry: cls=%p, mime=%p, session=%p, connection=%p\",\n            (void *) cls, (void *) mime, (void *) session, (void *) connection);\n  if (form != NULL)\n  {\n    size_t len = strlen (form);\n    /* Log a short preview of the form content (up to 128 chars) */\n    char preview[129];\n    size_t copy_len = (len < 128) ? len : 128;\n    memcpy (preview, form, copy_len);\n    preview[copy_len] = '\\0';\n    probe_log(\"serve_simple_form: form pointer=%p, length=%zu, preview=\\\"%s\\\"\",\n              (void *) form, len, preview);\n  }\n  else\n  {\n    probe_log(\"serve_simple_form: form is NULL\");\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  probe_log(\"serve_simple_form: MHD_create_response_from_buffer_static returned response=%p\",\n            (void *) response);\n  if (NULL == response)\n  {\n    probe_log(\"serve_simple_form: response is NULL -> returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  add_session_cookie (session, response);\n  probe_log(\"serve_simple_form: add_session_cookie called (session=%p, response=%p)\",\n            (void *) session, (void *) response);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    probe_log(\"serve_simple_form: MHD_add_response_header failed (response=%p, mime=%p)\",\n              (void *) response, (void *) mime);\n  }\n\n  /* Log the status code we plan to pass to MHD_queue_response */\n  {\n    unsigned int planned_status = MHD_HTTP_OK;\n    probe_log(\"serve_simple_form: about to call MHD_queue_response with status_code=0x%X\",\n              (unsigned) planned_status);\n    /* Use the probe wrapper to capture entry/exit around MHD_queue_response */\n    ret = probe_MHD_queue_response (connection,\n                                    planned_status,\n                                    response);\n  }\n\n  probe_log(\"serve_simple_form: MHD_queue_response returned ret=%d\", (int) ret);\n  MHD_destroy_response (response);\n  probe_log(\"serve_simple_form: MHD_destroy_response called for response=%p\", (void *) response);\n  probe_log(\"serve_simple_form: exit: returning ret=%d\", (int) ret);\n  return ret;\n}\n"
}