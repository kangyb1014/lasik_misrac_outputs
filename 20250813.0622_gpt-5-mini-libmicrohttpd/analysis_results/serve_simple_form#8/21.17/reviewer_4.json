{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memmove copies norm_len+1 bytes from buf+old_value_len to buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len. The buffer was allocated with buf_size = old_value_len + initial_norm_len where initial_norm_len = value_len + value_len/2 + 1, and norm_len is later resized to the actual used length returned by the token-removal routine. The code only has an mhd_assert that there is enough room (buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1) but this assert can be compiled out. If the assertion does not hold, memmove will write/read past the end of the allocated buf. Example: with old_value_len == 0 and value_len == 5 (initial_norm_len == 8) and the removal routine leaving norm_len == 5, the memmove will attempt to move 6 bytes to buf+7 but buf was only allocated 8 bytes (indices 0..7), so the write at positions >=8 is out-of-bounds. Therefore this use of memmove can access beyond object bounds and violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *tag,\n           const char *form,\n           size_t form_len,\n           const char *mime,\n           const void *session,\n           const void *connection,\n           const void *response_ptr,\n           int header_status,\n           int ret_code)\n{\n  FILE *f = fopen (\"/tmp/logs/71.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Protect against NULL strings in the log to avoid crashing the logger. */\n  fprintf (f,\n           \"%s: form=%p len=%zu mime=%s session=%p connection=%p response=%p header=%d ret=%d\\n\",\n           tag,\n           (const void *) form,\n           form_len,\n           (mime != NULL) ? mime : \"(null)\",\n           session,\n           connection,\n           response_ptr,\n           header_status,\n           ret_code);\n\n  if (form != NULL)\n  {\n    /* Log a limited prefix of the form to avoid huge logs */\n    fprintf (f, \"%s: form-prefix=\\\"%.200s\\\"\\n\", tag, form);\n  }\n\n  fclose (f);\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n  size_t form_len = 0;\n\n  /* compute form length safely for logging (original code called strlen(form) */\n  if (form != NULL)\n    form_len = strlen (form);\n\n  /* Log entry state */\n  log_probe (\"ENTER\", form, form_len, mime, (const void *) session, (const void *) connection, NULL, -1, -1);\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n\n  /* Log after create attempt */\n  log_probe (\"AFTER_CREATE\", form, form_len, mime, (const void *) session, (const void *) connection, (const void *) response, -1, -1);\n\n  if (NULL == response)\n  {\n    log_probe (\"CREATE_FAILED\", form, form_len, mime, (const void *) session, (const void *) connection, NULL, -1, (int) MHD_NO);\n    return MHD_NO;\n  }\n\n  add_session_cookie (session, response);\n\n  /* capture header result for logging */\n  int header_res = MHD_add_response_header (response,\n                                            MHD_HTTP_HEADER_CONTENT_ENCODING,\n                                            mime);\n\n  if (MHD_YES != header_res)\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    /* Log header failure */\n    log_probe (\"HEADER_FAIL\", form, form_len, mime, (const void *) session, (const void *) connection, (const void *) response, header_res, -1);\n  }\n  else\n  {\n    /* Log header success */\n    log_probe (\"HEADER_OK\", form, form_len, mime, (const void *) session, (const void *) connection, (const void *) response, header_res, -1);\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n\n  /* Log queued response and the return code from queue */\n  log_probe (\"AFTER_QUEUE\", form, form_len, mime, (const void *) session, (const void *) connection, (const void *) response, header_res, (int) ret);\n\n  MHD_destroy_response (response);\n\n  /* Final state log */\n  log_probe (\"EXIT\", form, form_len, mime, (const void *) session, (const void *) connection, NULL, header_res, (int) ret);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's scenario describes a memmove overflow and a buffer-size arithmetic error, but the provided serve_simple_form does not use memmove at all. The only <string.h> function used in serve_simple_form is strlen(form). So the specific memmove-based overflow scenario is not applicable to this function \u2014 Agent A's report (as stated) is incorrect.\n\nNotes relevant to MISRA C 2023 Rule 21.17: strlen() is a string.h function and may read beyond object bounds if the pointer is NULL or not pointed at a NUL-terminated character array. The posted serve_simple_form does not check form != NULL or otherwise document a guarantee that cls points to a valid NUL-terminated string; therefore the strlen(form) call could violate Rule 21.17 if callers can pass a non-NUL-terminated or NULL pointer. That is a separate (valid) concern, but it is not the memmove overflow scenario Agent A described.\n\nRecommendation: either ensure by contract that cls is a non-NULL, NUL-terminated string, or change the code to validate form (e.g. check for NULL and use a provided length) before calling strlen to fully comply with Rule 21.17."
}