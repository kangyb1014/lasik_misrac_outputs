{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen(header) without validating that header is non-NULL and NUL-terminated. Since add_response_entry() can be reached via the public API MHD_add_response_header(), a caller could pass header == NULL (or a non-NUL-terminated buffer). In that case strlen(header) will dereference a NULL pointer or read past the object bounds, causing undefined behavior. Example: calling MHD_add_response_header(resp, NULL, \"value\") leads to add_response_entry executing header_len = strlen(header), violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *stage,\n                          const void *cls,\n                          const char *form,\n                          const char *mime,\n                          struct MHD_Response *response,\n                          int add_hdr_result,\n                          enum MHD_Result ret,\n                          size_t form_len)\n{\n  FILE *f = fopen(\"/tmp/logs/71.txt\", \"a\");\n  if (!f)\n    return;\n\n  /* Log control point, pointer values and known sizes only. */\n  fprintf(f, \"[%s] cls=%p form=%p mime=%p response=%p form_len=%zu add_hdr_result=%d ret=%d\\n\",\n          stage, cls, form, mime, response, form_len, add_hdr_result, (int) ret);\n\n  /* Record simple predicates useful to reproduce the strlen(NULL) scenario\n     without attempting to dereference any pointer that might be invalid. */\n  fprintf(f, \"[%s] form_is_null=%d mime_is_null=%d\\n\",\n          stage, (form == NULL) ? 1 : 0, (mime == NULL) ? 1 : 0);\n\n  fclose(f);\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n  int add_hdr_result = 0;\n  size_t form_len;\n\n  /* Probe: entering function, record pointers but do not dereference them here. */\n  probe_log(\"enter\", cls, form, mime, NULL, -1, 0, 0);\n\n  /* return static form */\n  /* preserve original behavior: compute length exactly as before */\n  form_len = strlen (form);\n  probe_log(\"before_create_response\", cls, form, mime, NULL, -1, 0, form_len);\n\n  response = MHD_create_response_from_buffer_static (form_len,\n                                                     (const void *) form);\n  probe_log(\"after_create_response\", cls, form, mime, response, -1, 0, form_len);\n\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n\n  /* Log immediately before attempting to add header so callers can see\n     whether mime (header) is NULL which is the root cause of the reported UB. */\n  probe_log(\"before_add_response_header\", cls, form, mime, response, -1, 0, form_len);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    add_hdr_result = 1; /* non-success */\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  probe_log(\"after_add_response_header\", cls, form, mime, response, add_hdr_result, 0, form_len);\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  probe_log(\"after_queue_response\", cls, form, mime, response, add_hdr_result, ret, form_len);\n\n  MHD_destroy_response (response);\n  probe_log(\"after_destroy_response\", cls, form, mime, NULL, add_hdr_result, ret, form_len);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function unconditionally calls strlen(form) where form is obtained by casting the caller-supplied pointer cls to const char *. There is no check that cls (form) is non-NULL or that it points to a NUL\u2011terminated object of adequate bounds before calling strlen. MISRA C 2023 Rule 21.17 requires that uses of string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. As written, serve_simple_form can lead to a NULL dereference or reads beyond the object bounds (if the caller passes NULL or a non\u2011NUL\u2011terminated buffer), so it violates the rule.\n\n(The agent\u2019s scenario mentions add_response_entry / MHD_add_response_header and strlen(header) in another place \u2014 that is a different call site but the underlying class of defect is the same: unguarded use of strlen on a caller-supplied pointer. The empty test log does not refute the issue; it only shows the probe did not exercise this function in the test run.)"
}