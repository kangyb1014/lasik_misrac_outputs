{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:add_response_entry calls strlen(content) after only checking content != NULL but without guaranteeing the buffer is NUL-terminated. If MHD_add_response_header (or any caller) passes a pointer to a buffer that is not terminated with '\\0' (for example a binary buffer or a fixed-size header/value buffer filled without a terminating NUL), strlen(content) will read past the buffer bounds and cause out-of-bounds access/undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* probe logging: record entry and pointer state */\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log) {\n      fprintf(log, \"ENTER serve_simple_form: cls=%p mime=%p session=%p connection=%p\\n\",\n              cls, (void *) mime, (void *) session, (void *) connection);\n      fprintf(log, \"form(pointer)=%p\\n\", (void *) form);\n      fprintf(log, \"about to call strlen(form) -- this mirrors original behavior\\n\");\n      fclose(log);\n    }\n  }\n\n  /* preserve original logic: call strlen(form) as in the original code */\n  size_t form_len = strlen (form);\n\n  /* log the result of strlen and a hex-dump (bounded) of the scanned bytes to help reproduce UB */\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log) {\n      fprintf(log, \"strlen(form) -> %zu\\n\", form_len);\n      /* Dump up to 64 bytes (bounded) of the buffer that strlen traversed. This will not read\n         more than strlen already did (we cap to 64 bytes) so we avoid introducing extra out-of-bounds\n         accesses beyond what the original strlen may have done. */\n      size_t dump = form_len < 64 ? form_len : 64;\n      fprintf(log, \"form hex dump (up to %zu bytes):\", dump);\n      for (size_t i = 0; i < dump; ++i)\n        fprintf(log, \" %02x\", (unsigned char) form[i]);\n      fprintf(log, \"\\n\");\n      fclose(log);\n    }\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (form_len,\n                                                     (const void *) form);\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log) {\n      fprintf(log, \"MHD_create_response_from_buffer_static returned %p\\n\", (void *) response);\n      fclose(log);\n    }\n  }\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    /* log header failure without dereferencing mime (print pointer only) */\n    {\n      FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n      if (log) {\n        fprintf(log, \"MHD_add_response_header failed: header=%p\\n\", (void *) mime);\n        fclose(log);\n      }\n    }\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log) {\n      fprintf(log, \"MHD_queue_response returned %d\\n\", (int) ret);\n      fprintf(log, \"EXIT serve_simple_form ret=%d\\n\", (int) ret);\n      fclose(log);\n    }\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function casts the incoming const void *cls to const char *form and calls strlen(form) unconditionally. strlen scans memory until it finds a '\\0' byte; if the object pointed to by cls is not guaranteed to be a NUL\u2011terminated array (for example if callers pass a binary buffer or a fixed\u2011size buffer filled without a terminator), strlen may read past the bounds of the object, yielding undefined behavior. MISRA C 2023 Rule 21.17 requires that use of string.h functions must not result in accesses beyond the referenced objects. The code as shown does not validate or otherwise guarantee that cls refers to a NUL\u2011terminated object, so it can violate Rule 21.17 unless an external API contract (not visible here) explicitly guarantees NUL termination. (The additional logging version still calls strlen(form) and therefore does not remove the risk; the empty test log only indicates the function may not have been exercised.) Recommended fixes: change the parameter type to const char * with documented termination guarantees, pass an explicit length instead of relying on strlen, or otherwise ensure the buffer is NUL\u2011terminated before calling strlen."
}