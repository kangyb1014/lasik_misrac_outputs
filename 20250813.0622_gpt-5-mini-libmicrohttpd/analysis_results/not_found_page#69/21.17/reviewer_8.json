{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 buffer overflow when inserting the \"close\" token. If hdr != NULL and the incoming value contains only the token \"close\" (so value_has_close == true, already_has_close == false and norm_len == 0), buf is allocated as buf_size = old_value_len + norm_len = (hdr->value_size + 2) + 0. After inserting the \"close\" token pos becomes MHD_STATICSTR_LEN(\"close\") + 2 (i.e. 5 + 2 = 7), and the code does memcpy(buf + pos, hdr->value, hdr->value_size). That copies hdr->value_size bytes into buf starting at offset 7, so pos + hdr->value_size = 7 + hdr->value_size which is greater than buf_size = hdr->value_size + 2, causing writes beyond the allocated buffer. Therefore Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_state(const char *stage,\n                const void *cls,\n                const char *mime,\n                const void *session,\n                const void *connection,\n                const void *response,\n                int ret,\n                int add_hdr_res)\n{\n  FILE *f = fopen(\"/tmp/logs/559.txt\", \"a\");\n  if (NULL == f)\n  {\n    /* Keep original behavior even if logging fails. */\n    fprintf(stderr, \"probe_log_state: failed to open /tmp/logs/559.txt\\n\");\n    return;\n  }\n\n  fprintf(f, \"--- not_found_page probe (%s) ---\\n\", stage ? stage : \"(null)\");\n  fprintf(f, \"cls=%p\\n\", cls);\n  fprintf(f, \"mime=%s\\n\", mime ? mime : \"(null)\");\n  fprintf(f, \"session=%p\\n\", session);\n  fprintf(f, \"connection=%p\\n\", connection);\n  fprintf(f, \"response=%p\\n\", response);\n  fprintf(f, \"ret=%d\\n\", ret);\n  fprintf(f, \"add_header_result=%d\\n\", add_hdr_res);\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Log entry state so other agents can correlate calls and reproductions. */\n  probe_log_state(\"entry\", cls, mime, session, connection, NULL, -1, -1);\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n  {\n    probe_log_state(\"response_create_failed\", cls, mime, session, connection, NULL, (int)MHD_NO, -1);\n    return MHD_NO;\n  }\n\n  /* Log after creating response (pointer & size info). */\n  probe_log_state(\"response_created\", cls, mime, session, connection, response, -1, -1);\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  /* Log the queue result and response pointer. */\n  probe_log_state(\"after_queue_response\", cls, mime, session, connection, response, (int)ret, -1);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    /* Record header addition failure in logs (and preserve original stderr message). */\n    probe_log_state(\"add_header_failed\", cls, mime, session, connection, response, (int)ret, 0);\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    probe_log_state(\"add_header_succeeded\", cls, mime, session, connection, response, (int)ret, 1);\n  }\n\n  MHD_destroy_response (response);\n\n  /* Final log before returning, including the return value. */\n  probe_log_state(\"exit\", cls, mime, session, connection, NULL, (int)ret, -1);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation scenario describes a memcpy writing past an allocated buffer (inserting a \"close\" token etc.), but that code is not present in the provided not_found_page function. In the shown function the only <string.h> usage is strlen(NOT_FOUND_ERROR) applied to a compile-time constant (a string literal) \u2014 that is safe and does not cause out-of-bounds access. The other string-related operation is passing mime to MHD_add_response_header, but any unsafe string handling would be inside the MHD library implementation (not in the shown code) and cannot be attributed to not_found_page itself. The agent A's scenario appears to refer to a different function that performs buffer allocation and memcpy; therefore the claimed Rule 21.17 violation is not demonstrated for the provided not_found_page code."
}