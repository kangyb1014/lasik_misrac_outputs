{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the caller passes a mime pointer that is not a valid NUL\u2011terminated string (for example a pointer into a buffer without a terminating '\\0' or an invalid/short object), MHD_add_response_header will eventually call add_response_entry which does content_len = strlen(content). strlen will read past the bounds of the referenced object, causing an out\u2011of\u2011bounds access and thus violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  FILE *logf = NULL;\n\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Open probe log file early so we can record control flow and state. */\n  logf = fopen(\"/tmp/logs/559.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"not_found_page: entry. cls=%p, mime=%p, session=%p, connection=%p\\n\",\n            cls, (const void *) mime, (void *) session, (void *) connection);\n    /* Log the compile-time constant we're about to use. Use original strlen on NOT_FOUND_ERROR as before. */\n    fprintf(logf, \"not_found_page: NOT_FOUND_ERROR length=%zu\\n\", strlen (NOT_FOUND_ERROR));\n    fflush(logf);\n  }\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"not_found_page: MHD_create_response_from_buffer_static returned NULL\\n\");\n      fclose(logf);\n    }\n    return MHD_NO;\n  }\n\n  if (logf)\n  {\n    fprintf(logf, \"not_found_page: created response %p\\n\", (void *) response);\n    fflush(logf);\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  if (logf)\n  {\n    fprintf(logf, \"not_found_page: MHD_queue_response returned %d\\n\", (int) ret);\n    /* Record that we are about to call MHD_add_response_header and the pointer state of mime. */\n    fprintf(logf, \"not_found_page: about to call MHD_add_response_header with mime pointer=%p, mime_is_null=%d\\n\",\n            (const void *) mime, (mime == NULL));\n    fflush(logf);\n  }\n\n  /* Call the library function that is suspected to trigger the violation. */\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    /* Log failure to set header */\n    if (logf)\n    {\n      fprintf(logf, \"not_found_page: MHD_add_response_header returned failure for mime pointer=%p\\n\", (const void *) mime);\n      fflush(logf);\n    }\n\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"not_found_page: MHD_add_response_header returned success for mime pointer=%p\\n\", (const void *) mime);\n      fflush(logf);\n    }\n  }\n\n  MHD_destroy_response (response);\n\n  if (logf)\n  {\n    fprintf(logf, \"not_found_page: exiting with ret=%d\\n\", (int) ret);\n    fclose(logf);\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The claim from agent A is plausible and \u2014 unless there is a documented, enforced precondition that the caller always supplies a valid NUL\u2011terminated string in mime \u2014 correct. The reviewed function itself performs only one direct strlen call (on NOT_FOUND_ERROR), which is safe (string literal). The potential out\u2011of\u2011bounds access is not from that call but from passing mime to MHD_add_response_header: if the library implementation of MHD_add_response_header (or its helper add_response_entry) calls strlen(content) on the supplied mime pointer, and if mime is not a valid NUL\u2011terminated string (or is NULL and the library does not handle that), then strlen will read past the bounds of the object and cause an out\u2011of\u2011bounds access, which violates MISRA C 2023 Rule 21.17.\n\nTherefore agent A\u2019s scenario identifies a real risk. Whether the code actually violates the rule in a compliant build depends on the contract of the caller/callee: if the framework guarantees mime is always a valid NUL\u2011terminated string (and never NULL), the call is safe; if not, the code is non\u2011compliant. To make the code unambiguously compliant, validate mime (e.g. check for NULL and ensure a proper string) or only call MHD_add_response_header with a verified/controlled string, or consult/use a library API that accepts length to avoid relying on strlen internally."
}