{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. If value_has_close is true and norm_len != 0, the code does memmove(buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len, buf + old_value_len, norm_len + 1) but buf was allocated with buf_size = old_value_len + (size_t)initial_norm_len. The code only asserts (via mhd_assert) that buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1, however buf_size is actually old_value_len + initial_norm_len so in normal builds the assertion may be disabled and the allocation does not account for the extra \"close, \" prefix. For a concrete example: value_len = 10 -> initial norm_len = 10 + 5 + 1 = 16, buf_size = 16; MHD_STATICSTR_LEN_(\"close, \") == 7, memmove will attempt to write 16+1 bytes starting at offset 7 which overruns the 16-byte buffer (writes up to offset 23). Therefore memmove (and subsequent memcpy) can access beyond the allocated buffer, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MHD_HTTP_NOT_FOUND = 404;\nstatic const char MHD_HTTP_HEADER_CONTENT_ENCODING[] = \"Content-Encoding\";\nstatic const char not_found_error_str[] =\n  \"<html><head><title>Not found</title></head><body>Go away.</body></html>\";\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/559.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Log entry and parameters */\n  probe_log (\"not_found_page: enter; cls=%p, mime=%p, session=%p, connection=%p\",\n             cls, (const void *) mime, (const void *) session, (const void *) connection);\n  if (mime != NULL)\n    probe_log (\"not_found_page: mime string='%s'\", mime);\n\n  /* unsupported HTTP method */\n  size_t not_found_len = 0;\n  /* Protect against not_found_error_str being NULL in some build configurations. */\n  if (&not_found_error_str != NULL)\n    not_found_len = strlen (not_found_error_str);\n  probe_log (\"not_found_page: NOT_FOUND_ERROR length=%zu\", not_found_len);\n\n  response =\n    MHD_create_response_from_buffer_static (strlen (not_found_error_str),\n                                            (const void *) not_found_error_str);\n  probe_log (\"not_found_page: MHD_create_response_from_buffer_static returned %p\", (void *) response);\n  if (NULL == response)\n  {\n    probe_log (\"not_found_page: response is NULL -> returning MHD_NO\");\n    return (enum MHD_Result) 0; /* MHD_NO (value preserved as original return) */\n  }\n\n  ret = MHD_queue_response (connection,\n                            /* The original used MHD_HTTP_NOT_FOUND; we log the fact */\n                            /* value is passed through unchanged */\n                            /* Keep the original call as-is to preserve behavior */\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  probe_log (\"not_found_page: MHD_queue_response returned %d\", (int) ret);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    probe_log (\"not_found_page: MHD_add_response_header failed for mime='%s'\", mime ? mime : \"(null)\");\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  else\n  {\n    probe_log (\"not_found_page: MHD_add_response_header succeeded for mime='%s'\", mime ? mime : \"(null)\");\n  }\n\n  MHD_destroy_response (response);\n  probe_log (\"not_found_page: destroyed response, returning ret=%d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Incorrect. The scenario described by agent A refers to a different code path that uses memmove/memcpy and a buf allocation mismatch (involving MHD_STATICSTR_LEN_(\"close, \") and old_value_len). None of that appears in the provided not_found_page implementation. The function shown only calls strlen(NOT_FOUND_ERROR) and passes the pointer to MHD_create_response_from_buffer_static; it does not perform any memmove/memcpy or manual buffer arithmetic that would cause an out\u2011of\u2011bounds access.\n\nMISRA C:2023 Rule 21.17 does include strlen, so a violation would exist if NOT_FOUND_ERROR were not a valid, null\u2011terminated object or if the called library routine performed unsafe accesses. But on the face of the provided code, NOT_FOUND_ERROR is used as a static string and strlen usage is conventional and bounded by the string\u2019s terminator. The detailed overflow scenario A gives does not correspond to this function, so the reported violation for not_found_page is not correct."
}