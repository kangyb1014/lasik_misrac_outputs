{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strchr(value, '\\r') and strchr(value, '\\n') without first ensuring that 'value' is non-NULL and points to a NUL-terminated character array. If a caller passes a non-NUL-terminated buffer (e.g. a pointer to a length-delimited header value that lacks a terminating '\\0') or NULL as the content for a \"Connection\" header, strchr will scan past the object bounds (or dereference NULL), causing an out-of-bounds access/undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic size_t\nsafe_strnlen (const char *s, size_t max)\n{\n  size_t i = 0;\n  if (NULL == s)\n    return 0u;\n  while (i < max && s[i])\n    ++i;\n  return i;\n}\nstatic void\nprobe_log_state (const char *stage,\n                 const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection,\n                 struct MHD_Response *response,\n                 enum MHD_Result ret)\n{\n  FILE *f = fopen (\"/tmp/logs/559.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"[not_found_page] stage=%s cls=%p session=%p connection=%p\\n\",\n           stage, cls, session, connection);\n\n  if (mime)\n    {\n      size_t len = safe_strnlen (mime, 256);\n      fprintf (f, \"[not_found_page] mime_len=%zu mime='\", len);\n      if (len > 0)\n        fwrite (mime, 1, len, f);\n      fprintf (f, \"'\\n\");\n    }\n  else\n    fprintf (f, \"[not_found_page] mime=NULL\\n\");\n\n  fprintf (f, \"[not_found_page] response=%p ret=%d\\n\", response, (int) ret);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* log entry state */\n  probe_log_state (\"entry\", cls, mime, session, connection, NULL, 0);\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n\n  /* log after create */\n  probe_log_state (\"after_create_response\", cls, mime, session, connection, response, 0);\n\n  if (NULL == response)\n    {\n      probe_log_state (\"response_null_return\", cls, mime, session, connection, response, (enum MHD_Result) MHD_NO);\n      return MHD_NO;\n    }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  /* log after queue */\n  probe_log_state (\"after_queue_response\", cls, mime, session, connection, response, ret);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    /* log header failure */\n    probe_log_state (\"add_header_failed\", cls, mime, session, connection, response, ret);\n  }\n  else\n    {\n      /* log header success */\n      probe_log_state (\"add_header_succeeded\", cls, mime, session, connection, response, ret);\n    }\n\n  MHD_destroy_response (response);\n\n  /* final return state */\n  probe_log_state (\"exit\", cls, mime, session, connection, NULL, ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The not_found_page function itself does not call strchr (or any other <string.h> function) on the mime parameter; the only string.h use in the shown code is strlen(NOT_FOUND_ERROR) on a string literal, which is NUL-terminated and safe. Agent A\u2019s scenario describes strchr(value, ...) being invoked on a possibly non-NUL-terminated or NULL pointer \u2014 but that call does not appear in the provided code. Passing mime to the external function MHD_add_response_header may cause library code to call string routines internally, but any unsafe use of strchr inside that library is not a direct violation by this function. If the MHD API requires a NUL-terminated, non-NULL header value, the caller should ensure that contract is met (or check mime before calling), but as written not_found_page does not itself violate MISRA C:2023 Rule 21.17."
}