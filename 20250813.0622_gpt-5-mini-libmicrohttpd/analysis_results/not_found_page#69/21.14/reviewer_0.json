{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp(hdr->value, \"close\", 5) to test equality against the string literal \"close\" where hdr->value is a null-terminated header value (buf[pos] = 0). Using memcmp to compare a null-terminated string against a string literal violates MISRA C 2023 Rule 21.14; a string comparison function such as strcmp/strncmp should be used instead.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_not_found(const char *phase,\n                const char *mime,\n                const void *connection,\n                const struct MHD_Response *response,\n                enum MHD_Result ret)\n{\n  FILE *f = fopen(\"/tmp/logs/558.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n\n  /* Log the probe entry with important state for reproducing control flow. */\n  fprintf(f, \"[not_found_page] phase=%s\\n\", phase);\n  fprintf(f, \"  mime pointer = %p\\n\", (const void *) mime);\n  fprintf(f, \"  mime string  = %s\\n\", (mime != NULL) ? mime : \"(null)\");\n  fprintf(f, \"  connection   = %p\\n\", connection);\n  fprintf(f, \"  response ptr = %p\\n\", (const void *) response);\n  fprintf(f, \"  ret value    = %d\\n\", (int) ret);\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Probe: function entry */\n  probe_not_found(\"entry\", mime, connection, NULL, 0);\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n\n  /* Probe: after create response */\n  probe_not_found(\"after_create_response\", mime, connection, response, 0);\n\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  /* Probe: after queue response */\n  probe_not_found(\"after_queue_response\", mime, connection, response, ret);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    /* Probe: header add failed */\n    probe_not_found(\"header_add_failed\", mime, connection, response, ret);\n  }\n  else\n  {\n    /* Probe: header add succeeded */\n    probe_not_found(\"header_add_succeeded\", mime, connection, response, ret);\n  }\n  MHD_destroy_response (response);\n\n  /* Probe: function exit */\n  probe_not_found(\"exit\", mime, connection, NULL, ret);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct for the provided not_found_page function. The posted code contains no call to memcmp (it calls strlen, MHD_create_response_from_buffer_static, MHD_queue_response, MHD_add_response_header, MHD_destroy_response, etc.). The scenario that cites memcmp(hdr->value, \"close\", 5) refers to different code (hdr->value) that is not present in the target function, so Rule 21.14 is not violated in the shown function. \n\nIf you do find memcmp used elsewhere to compare a null-terminated string against a literal, that would indeed violate MISRA C 2023 Rule 21.14 \u2014 such comparisons should use strcmp/strncmp (or otherwise ensure the objects are non-null-terminated binary buffers before using memcmp). But for this not_found_page code, the report is incorrect."
}