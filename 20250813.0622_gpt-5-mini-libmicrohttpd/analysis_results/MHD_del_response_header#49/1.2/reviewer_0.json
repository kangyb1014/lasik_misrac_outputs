{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function declaration uses the macro _MHD_EXTERN which is defined as __attribute__((visibility(\"default\")))extern. The use of GCC/Clang __attribute__((...)) is a compiler-specific language extension, so this violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void _mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/392.txt\", \"a\");\n    if (NULL == f)\n        return;\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_POSIX_VERSION)\n    localtime_r(&t, &tm_buf);\n    fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n            tm_buf.tm_year + 1900, tm_buf.tm_mon + 1, tm_buf.tm_mday,\n            tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec);\n#else\n    {\n        struct tm *tmp = localtime(&t);\n        if (tmp)\n            fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n                    tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n                    tmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n    }\n#endif\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  /* Log entry and note presence of the declaration macro token for auditors. */\n  _mhd_probe_log(\"ENTRY: MHD_del_response_header called; decl_macro_token='%s'\", \"_MHD_EXTERN\");\n  _mhd_probe_log(\"ENTRY: response=%p, header=%p, content=%p\", (void *)response, (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    _mhd_probe_log(\"NULL_CHECK: header or content is NULL -> returning MHD_NO\");\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  _mhd_probe_log(\"HEADER_LEN: header_len=%zu, header='%s'\", header_len, header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    _mhd_probe_log(\"SPECIAL_CONNECTION: matched Connection header path; calling del_response_header_connection response=%p content='%s'\", (void *)response, content);\n    enum MHD_Result _res_conn = del_response_header_connection (response, content);\n    _mhd_probe_log(\"SPECIAL_CONNECTION: del_response_header_connection returned=%d\", (int)_res_conn);\n    return _res_conn;\n  }\n\n  content_len = strlen (content);\n  _mhd_probe_log(\"CONTENT_LEN: content_len=%zu, content='%s'\", content_len, content);\n  pos = response->first_header;\n  _mhd_probe_log(\"LOOP_START: starting iteration; first_header=%p\", (void *)pos);\n  while (NULL != pos)\n  {\n    _mhd_probe_log(\"LOOP_POS: pos=%p header_size=%zu value_size=%zu header_ptr=%p value_ptr=%p\",\n                   (void *)pos, (size_t)pos->header_size, (size_t)pos->value_size,\n                   (void *)pos->header, (void *)pos->value);\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _mhd_probe_log(\"MATCH_FOUND: header and content match at pos=%p; proceeding to remove\", (void *)pos);\n      _MHD_remove_header (response, pos);\n      _mhd_probe_log(\"REMOVE: _MHD_remove_header called for pos=%p\", (void *)pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      _mhd_probe_log(\"FREE: freed pos and its header/value; checking flags_auto to clear relevant bits\");\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        unsigned long long old_flags = (unsigned long long) response->flags_auto;\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        _mhd_probe_log(\"FLAG_CLEAR: cleared TRANS_ENC_CHUNKED; flags_auto old=0x%llx new=0x%llx\",\n                       old_flags, (unsigned long long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        unsigned long long old_flags = (unsigned long long) response->flags_auto;\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        _mhd_probe_log(\"FLAG_CLEAR: cleared DATE_HDR; flags_auto old=0x%llx new=0x%llx\",\n                       old_flags, (unsigned long long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        _mhd_probe_log(\"FLAG_CHECK: Content-Length header removed; verifying remaining elements\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          unsigned long long old_flags = (unsigned long long) response->flags_auto;\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n          _mhd_probe_log(\"FLAG_CLEAR: cleared CONTENT_LENGTH; flags_auto old=0x%llx new=0x%llx\",\n                         old_flags, (unsigned long long) response->flags_auto);\n        }\n        else\n        {\n          _mhd_probe_log(\"FLAG_CHECK: another Content-Length element still present; flags_auto unchanged=0x%llx\",\n                         (unsigned long long) response->flags_auto);\n        }\n      }\n      _mhd_probe_log(\"RETURN: matched and removed header -> returning MHD_YES\");\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  _mhd_probe_log(\"RETURN: no matching header found -> returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c0b9, content=0x55e0f5d4c0b0\n[2025-08-13 06:35:25] HEADER_LEN: header_len=13, header='Header-Type-A'\n[2025-08-13 06:35:25] CONTENT_LEN: content_len=8, content='value-a1'\n[2025-08-13 06:35:25] LOOP_START: starting iteration; first_header=0x55e11173b3a0\n[2025-08-13 06:35:25] LOOP_POS: pos=0x55e11173b3a0 header_size=13 value_size=8 header_ptr=0x55e11173b360 value_ptr=0x55e11173b380\n[2025-08-13 06:35:25] MATCH_FOUND: header and content match at pos=0x55e11173b3a0; proceeding to remove\n[2025-08-13 06:35:25] REMOVE: _MHD_remove_header called for pos=0x55e11173b3a0\n[2025-08-13 06:35:25] FREE: freed pos and its header/value; checking flags_auto to clear relevant bits\n[2025-08-13 06:35:25] RETURN: matched and removed header -> returning MHD_YES\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c0b9, content=0x55e0f5d4c118\n[2025-08-13 06:35:25] HEADER_LEN: header_len=13, header='Header-Type-A'\n[2025-08-13 06:35:25] CONTENT_LEN: content_len=8, content='value-a3'\n[2025-08-13 06:35:25] LOOP_START: starting iteration; first_header=0x55e11173b420\n[2025-08-13 06:35:25] LOOP_POS: pos=0x55e11173b420 header_size=13 value_size=8 header_ptr=0x55e11173b3e0 value_ptr=0x55e11173b400\n[2025-08-13 06:35:25] LOOP_POS: pos=0x55e11173b860 header_size=13 value_size=8 header_ptr=0x55e11173b380 value_ptr=0x55e11173b360\n[2025-08-13 06:35:25] MATCH_FOUND: header and content match at pos=0x55e11173b860; proceeding to remove\n[2025-08-13 06:35:25] REMOVE: _MHD_remove_header called for pos=0x55e11173b860\n[2025-08-13 06:35:25] FREE: freed pos and its header/value; checking flags_auto to clear relevant bits\n[2025-08-13 06:35:25] RETURN: matched and removed header -> returning MHD_YES\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c12f, content=0x55e0f5d4c118\n[2025-08-13 06:35:25] HEADER_LEN: header_len=13, header='Header-Type-C'\n[2025-08-13 06:35:25] CONTENT_LEN: content_len=8, content='value-a3'\n[2025-08-13 06:35:25] LOOP_START: starting iteration; first_header=0x55e11173b420\n[2025-08-13 06:35:25] LOOP_POS: pos=0x55e11173b420 header_size=13 value_size=8 header_ptr=0x55e11173b3e0 value_ptr=0x55e11173b400\n[2025-08-13 06:35:25] RETURN: no matching header found -> returning MHD_NO\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c0b9, content=0x55e0f5d4c15b\n[2025-08-13 06:35:25] HEADER_LEN: header_len=13, header='Header-Type-A'\n[2025-08-13 06:35:25] CONTENT_LEN: content_len=7, content='value-c'\n[2025-08-13 06:35:25] LOOP_START: starting iteration; first_header=0x55e11173b420\n[2025-08-13 06:35:25] LOOP_POS: pos=0x55e11173b420 header_size=13 value_size=8 header_ptr=0x55e11173b3e0 value_ptr=0x55e11173b400\n[2025-08-13 06:35:25] RETURN: no matching header found -> returning MHD_NO\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c196, content=0x55e0f5d4c1ea\n[2025-08-13 06:35:25] HEADER_LEN: header_len=10, header='Connection'\n[2025-08-13 06:35:25] SPECIAL_CONNECTION: matched Connection header path; calling del_response_header_connection response=0x55e11173b2a0 content='e,b,c,d,a'\n[2025-08-13 06:35:25] SPECIAL_CONNECTION: del_response_header_connection returned=1\n[2025-08-13 06:35:25] ENTRY: MHD_del_response_header called; decl_macro_token='_MHD_EXTERN'\n[2025-08-13 06:35:25] ENTRY: response=0x55e11173b2a0, header=0x55e0f5d4c196, content=0x55e0f5d4c22f\n[2025-08-13 06:35:25] HEADER_LEN: header_len=10, header='Connection'\n[2025-08-13 06:35:25] SPECIAL_CONNECTION: matched Connection header path; calling del_response_header_connection response=0x55e11173b2a0 content='\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The report is valid: the declaration uses the _MHD_EXTERN macro which (per the provided scenario) expands to __attribute__((visibility(\"default\"))) extern. The GCC/Clang __attribute__((...)) annotation is a documented compiler-specific language extension; MISRA C 2023 Rule 1.2 prohibits use of language extensions that are explicitly identified as such by the compiler documentation. The test output shows the declaration macro token('_MHD_EXTERN') in use and the function is declared with that macro, so the code does use a compiler-specific extension and therefore breaches Rule 1.2."
}