{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 calling strlen(content) with only a NULL check does not guarantee that 'content' points to a NUL\u2011terminated object. If a caller passes a non\u2011NUL\u2011terminated buffer (or a pointer into a region whose terminator lies beyond its allocated bounds), strlen(content) can read past the object boundary. In this function that can lead to content_len > pos->value_size and the subsequent memcmp(content, pos->value, content_len) will read beyond pos->value, causing an out\u2011of\u2011bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  mhd_log(\"MHD_del_response_header: entry response=%p header=%p content=%p\",\n          (void *) response, (void *) header, (void *) content);\n\n  if ( (NULL == header) ||\n       (NULL == content) ) {\n    mhd_log(\"MHD_del_response_header: NULL parameter detected header=%p content=%p -> MHD_NO\",\n            (void *) header, (void *) content);\n    return MHD_NO;\n  }\n\n  header_len = strlen (header);\n  mhd_log(\"MHD_del_response_header: header_len=%zu header_ptr=%p\",\n          header_len, (void *) header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len)) {\n    mhd_log(\"MHD_del_response_header: matched Connection header, delegating to del_response_header_connection\");\n    enum MHD_Result r = del_response_header_connection (response, content);\n    mhd_log(\"MHD_del_response_header: del_response_header_connection returned %d\", (int) r);\n    return r;\n  }\n\n  content_len = strlen (content);\n  mhd_log(\"MHD_del_response_header: content_len=%zu content_ptr=%p\",\n          content_len, (void *) content);\n\n  pos = response->first_header;\n  mhd_log(\"MHD_del_response_header: starting scan first_header=%p\", (void *) pos);\n  while (NULL != pos)\n  {\n    mhd_log(\"MHD_del_response_header: visiting pos=%p header_size=%zu value_size=%zu header_addr=%p value_addr=%p\",\n            (void *) pos, pos->header_size, pos->value_size,\n            (void *) pos->header, (void *) pos->value);\n\n    if (header_len == pos->header_size)\n    {\n      if (content_len == pos->value_size)\n      {\n        /* safe to memcmp because lengths are equal */\n        int header_cmp = memcmp (header, pos->header, header_len);\n        int content_cmp = memcmp (content, pos->value, content_len);\n        mhd_log(\"MHD_del_response_header: lengths equal header_cmp=%d content_cmp=%d\",\n                header_cmp, content_cmp);\n        if ((0 == header_cmp) && (0 == content_cmp))\n        {\n          mhd_log(\"MHD_del_response_header: match found at pos=%p - removing header\", (void *) pos);\n          _MHD_remove_header (response, pos);\n          free (pos->header);\n          free (pos->value);\n          free (pos);\n          if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n                header_len) &&\n               MHD_str_equal_caseless_bin_n_ (header,\n                                              MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                              header_len) )\n          {\n            mhd_log(\"MHD_del_response_header: clearing RAF_HAS_TRANS_ENC_CHUNKED flag\");\n            response->flags_auto &=\n              ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n          }\n          else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                     header_len) &&\n                    MHD_str_equal_caseless_bin_n_ (header,\n                                                   MHD_HTTP_HEADER_DATE,\n                                                   header_len) )\n          {\n            mhd_log(\"MHD_del_response_header: clearing RAF_HAS_DATE_HDR flag\");\n            response->flags_auto &=\n              ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n          }\n          else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                     header_len) &&\n                    MHD_str_equal_caseless_bin_n_ (header,\n                                                   MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                   header_len) )\n          {\n            if (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                     header_len))\n            {\n              mhd_log(\"MHD_del_response_header: clearing RAF_HAS_CONTENT_LENGTH flag\");\n              response->flags_auto &=\n                ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n            }\n          }\n          mhd_log(\"MHD_del_response_header: removed header, returning MHD_YES\");\n          return MHD_YES;\n        }\n        else\n        {\n          mhd_log(\"MHD_del_response_header: lengths equal but memcmp not equal header_cmp=%d content_cmp=%d\",\n                  header_cmp, content_cmp);\n        }\n      }\n      else\n      {\n        mhd_log(\"MHD_del_response_header: header sizes equal but value sizes differ: content_len=%zu pos->value_size=%zu\",\n                content_len, pos->value_size);\n      }\n    }\n    else\n    {\n      mhd_log(\"MHD_del_response_header: header_len mismatch: header_len=%zu pos->header_size=%zu\",\n              header_len, pos->header_size);\n    }\n    pos = pos->next;\n  }\n  mhd_log(\"MHD_del_response_header: no match found -> MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da960b9 content=0x557c0da960b0\nMHD_del_response_header: header_len=13 header_ptr=0x557c0da960b9\nMHD_del_response_header: content_len=8 content_ptr=0x557c0da960b0\nMHD_del_response_header: starting scan first_header=0x557c473fb3a0\nMHD_del_response_header: visiting pos=0x557c473fb3a0 header_size=13 value_size=8 header_addr=0x557c473fb360 value_addr=0x557c473fb380\nMHD_del_response_header: lengths equal header_cmp=0 content_cmp=0\nMHD_del_response_header: match found at pos=0x557c473fb3a0 - removing header\nMHD_del_response_header: removed header, returning MHD_YES\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da960b9 content=0x557c0da96118\nMHD_del_response_header: header_len=13 header_ptr=0x557c0da960b9\nMHD_del_response_header: content_len=8 content_ptr=0x557c0da96118\nMHD_del_response_header: starting scan first_header=0x557c473fb420\nMHD_del_response_header: visiting pos=0x557c473fb420 header_size=13 value_size=8 header_addr=0x557c473fb3e0 value_addr=0x557c473fb400\nMHD_del_response_header: lengths equal header_cmp=0 content_cmp=1\nMHD_del_response_header: lengths equal but memcmp not equal header_cmp=0 content_cmp=1\nMHD_del_response_header: visiting pos=0x557c473fb640 header_size=13 value_size=8 header_addr=0x557c473fb380 value_addr=0x557c473fb360\nMHD_del_response_header: lengths equal header_cmp=0 content_cmp=0\nMHD_del_response_header: match found at pos=0x557c473fb640 - removing header\nMHD_del_response_header: removed header, returning MHD_YES\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da9612f content=0x557c0da96118\nMHD_del_response_header: header_len=13 header_ptr=0x557c0da9612f\nMHD_del_response_header: content_len=8 content_ptr=0x557c0da96118\nMHD_del_response_header: starting scan first_header=0x557c473fb420\nMHD_del_response_header: visiting pos=0x557c473fb420 header_size=13 value_size=8 header_addr=0x557c473fb3e0 value_addr=0x557c473fb400\nMHD_del_response_header: lengths equal header_cmp=2 content_cmp=1\nMHD_del_response_header: lengths equal but memcmp not equal header_cmp=2 content_cmp=1\nMHD_del_response_header: no match found -> MHD_NO\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da960b9 content=0x557c0da9615b\nMHD_del_response_header: header_len=13 header_ptr=0x557c0da960b9\nMHD_del_response_header: content_len=7 content_ptr=0x557c0da9615b\nMHD_del_response_header: starting scan first_header=0x557c473fb420\nMHD_del_response_header: visiting pos=0x557c473fb420 header_size=13 value_size=8 header_addr=0x557c473fb3e0 value_addr=0x557c473fb400\nMHD_del_response_header: header sizes equal but value sizes differ: content_len=7 pos->value_size=8\nMHD_del_response_header: no match found -> MHD_NO\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da96196 content=0x557c0da961ea\nMHD_del_response_header: header_len=10 header_ptr=0x557c0da96196\nMHD_del_response_header: matched Connection header, delegating to del_response_header_connection\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da96196 content=0x557c0da9622f\nMHD_del_response_header: header_len=10 header_ptr=0x557c0da96196\nMHD_del_response_header: matched Connection header, delegating to del_response_header_connection\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da96196 content=0x557c0da96391\nMHD_del_response_header: header_len=10 header_ptr=0x557c0da96196\nMHD_del_response_header: matched Connection header, delegating to del_response_header_connection\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry response=0x557c473fb2a0 header=0x557c0da96196 content=0x557c0da9644c\nMHD_del_response_header: header_len=10 header_ptr=0x557c0da96196\nMHD_del_response_header: matched Connection header, delegating to del_response_header_connection\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's hypothetical is that strlen(content) could read past the bounds of the object referenced by content and thereby cause out\u2011of\u2011bounds accesses later. In the actual code: (1) both strlen(header) and strlen(content) are called only after NULL checks, but the code relies on header/content being NUL\u2011terminated C strings (that is the API contract); (2) the memcmp calls are only executed when the computed lengths equal the stored sizes (header_len == pos->header_size && content_len == pos->value_size), so memcmp will not read more bytes from pos->header/pos->value than their recorded sizes; and (3) the supplied exhaustive test log shows no evidence of any strlen or memcmp access beyond object bounds (matches and mismatches occur, no crashes or OOB behavior reported). Given the exhaustive test results and the guarded memcmp usage, the reported MISRA 21.17 violation is not supported. Therefore the report is incorrect."
}