{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code obtains header_len via strlen(header) (header is a null-terminated C string) and then calls memcmp(header, pos->header, header_len). pos->header is also stored and used as a null-terminated string (allocated with room for the terminating NUL). Using memcmp to compare these null-terminated strings (even though a length is provided) violates MISRA C 2023 Rule 21.14. The same pattern exists for content using content_len = strlen(content) and memcmp(content, pos->value, content_len).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_append(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/398.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  mhd_log_append(\"MHD_del_response_header called: response=%p, header=%p, content=%p\",\n                 (void *) response, (void *) header, (void *) content);\n  mhd_log_append(\"header_str='%s', content_str='%s'\",\n                 (NULL != header) ? header : \"<NULL>\",\n                 (NULL != content) ? content : \"<NULL>\");\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    mhd_log_append(\"One or both parameters NULL -> returning MHD_NO\");\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  mhd_log_append(\"computed header_len=%zu\", header_len);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    mhd_log_append(\"Matched special connection header branch -> calling del_response_header_connection\");\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  mhd_log_append(\"computed content_len=%zu\", content_len);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    mhd_log_append(\"Inspecting header node pos=%p: pos->header=%p, pos->value=%p\",\n                   (void *) pos, (void *) pos->header, (void *) pos->value);\n    mhd_log_append(\"pos->header_size=%zu, pos->value_size=%zu\",\n                   pos->header_size, pos->value_size);\n\n    /* Evaluate the same comparisons as in the original code but record\n       intermediate results so they can be logged for reproducing the\n       violation scenario. This preserves the original logic. */\n    int header_size_eq = (header_len == pos->header_size);\n    int content_size_eq = (content_len == pos->value_size);\n    int cmp_header = 1; /* non-zero means not equal by default */\n    int cmp_content = 1;\n\n    if (header_size_eq)\n    {\n      /* memcmp is used in original code; call it here to capture the result */\n      cmp_header = memcmp (header, pos->header, header_len);\n    }\n    else\n    {\n      mhd_log_append(\"header size mismatch: header_len=%zu vs pos->header_size=%zu\",\n                     header_len, pos->header_size);\n    }\n\n    if (content_size_eq)\n    {\n      cmp_content = memcmp (content, pos->value, content_len);\n    }\n    else\n    {\n      mhd_log_append(\"content size mismatch: content_len=%zu vs pos->value_size=%zu\",\n                     content_len, pos->value_size);\n    }\n\n    mhd_log_append(\"Comparison results: header_size_eq=%d, content_size_eq=%d, cmp_header=%d, cmp_content=%d\",\n                   header_size_eq, content_size_eq, cmp_header, cmp_content);\n\n    if ((header_size_eq) &&\n        (content_size_eq) &&\n        (0 == cmp_header) &&\n        (0 == cmp_content))\n    {\n      mhd_log_append(\"Match found -> removing header pos=%p\", (void *) pos);\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        mhd_log_append(\"Cleared MHD_RAF_HAS_TRANS_ENC_CHUNKED flag\");\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        mhd_log_append(\"Cleared MHD_RAF_HAS_DATE_HDR flag\");\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n          mhd_log_append(\"Cleared MHD_RAF_HAS_CONTENT_LENGTH flag\");\n        }\n      }\n      mhd_log_append(\"Header removed -> returning MHD_YES\");\n      return MHD_YES;\n    }\n    mhd_log_append(\"No match for this header node -> continue\");\n    pos = pos->next;\n  }\n  mhd_log_append(\"Reached end of header list -> returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c010b9, content=0x559da8c010b0\nheader_str='Header-Type-A', content_str='value-a1'\ncomputed header_len=13\ncomputed content_len=8\nInspecting header node pos=0x559de8ba03a0: pos->header=0x559de8ba0360, pos->value=0x559de8ba0380\npos->header_size=13, pos->value_size=8\nComparison results: header_size_eq=1, content_size_eq=1, cmp_header=0, cmp_content=0\nMatch found -> removing header pos=0x559de8ba03a0\nHeader removed -> returning MHD_YES\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c010b9, content=0x559da8c01118\nheader_str='Header-Type-A', content_str='value-a3'\ncomputed header_len=13\ncomputed content_len=8\nInspecting header node pos=0x559de8ba0420: pos->header=0x559de8ba03e0, pos->value=0x559de8ba0400\npos->header_size=13, pos->value_size=8\nComparison results: header_size_eq=1, content_size_eq=1, cmp_header=0, cmp_content=1\nNo match for this header node -> continue\nInspecting header node pos=0x559de8ba0640: pos->header=0x559de8ba0380, pos->value=0x559de8ba0360\npos->header_size=13, pos->value_size=8\nComparison results: header_size_eq=1, content_size_eq=1, cmp_header=0, cmp_content=0\nMatch found -> removing header pos=0x559de8ba0640\nHeader removed -> returning MHD_YES\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c0112f, content=0x559da8c01118\nheader_str='Header-Type-C', content_str='value-a3'\ncomputed header_len=13\ncomputed content_len=8\nInspecting header node pos=0x559de8ba0420: pos->header=0x559de8ba03e0, pos->value=0x559de8ba0400\npos->header_size=13, pos->value_size=8\nComparison results: header_size_eq=1, content_size_eq=1, cmp_header=2, cmp_content=1\nNo match for this header node -> continue\nReached end of header list -> returning MHD_NO\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c010b9, content=0x559da8c0115b\nheader_str='Header-Type-A', content_str='value-c'\ncomputed header_len=13\ncomputed content_len=7\nInspecting header node pos=0x559de8ba0420: pos->header=0x559de8ba03e0, pos->value=0x559de8ba0400\npos->header_size=13, pos->value_size=8\ncontent size mismatch: content_len=7 vs pos->value_size=8\nComparison results: header_size_eq=1, content_size_eq=0, cmp_header=0, cmp_content=1\nNo match for this header node -> continue\nReached end of header list -> returning MHD_NO\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c011ea\nheader_str='Connection', content_str='e,b,c,d,a'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c0122f\nheader_str='Connection', content_str='i,k,l,m,n,o,p,close'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c01391\nheader_str='Connection', content_str='1,3,5,7,9'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c0144c\nheader_str='Connection', content_str='12  ,10  ,8  ,close'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c01502\nheader_str='Connection', content_str='4  ,5,6,7  8,'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c01570\nheader_str='Connection', content_str='close, 10, 12, 22, nothing'\ncomputed header_len=10\nMatched special connection header branch -> calling del_response_header_connection\nMHD_del_response_header called: response=0x559de8ba02a0, header=0x559da8c01196, content=0x559da8c015e1\nheader_str='Connection', content_str='2'\ncomputed \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null-terminated strings. In the code both header and content are treated as null-terminated C strings (strlen is used to obtain header_len and content_len), and memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) are then used to compare them. That is exactly the disallowed pattern. The provided test/log output demonstrates that those memcmp calls are executed and used to determine string equality, confirming the violation. Therefore the reported violation is valid for both the header and content comparisons."
}