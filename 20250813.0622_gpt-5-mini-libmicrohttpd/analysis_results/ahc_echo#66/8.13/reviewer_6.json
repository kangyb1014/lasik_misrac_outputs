{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'cls' is declared as 'void *cls' but is not modified in the function (it's only cast away as unused). According to MISRA C 2023 Rule 8.13 it should be 'const void *cls' when possible. This is a violation unless the function prototype must match an external API (e.g. a library callback) that requires a non-const 'void *' parameter, in which case the non-const declaration is unavoidable.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void ahc_echo_log(const char *stage, void *cls, const char *method,\n                         void **req_cls, struct MHD_Connection *connection,\n                         const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/531.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf(f, \"ahc_echo - %s: cls=%p method=%s req_cls=%p *req_cls=%p connection=%p\",\n          stage, cls, method ? method : \"(null)\", (void *) req_cls,\n          (void *) (req_cls ? *req_cls : NULL), (void *) connection);\n  if (extra != NULL)\n    fprintf(f, \" | %s\", extra);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry with the raw 'cls' pointer value to provide evidence that\n   * the parameter is not modified by this function. This helps reproduce\n   * the Rule 8.13 scenario where 'cls' could be const-qualified.\n   */\n  ahc_echo_log(\"entry\", cls, method, req_cls, connection, NULL);\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    ahc_echo_log(\"unexpected_method\", cls, method, req_cls, connection,\n                 \"return MHD_NO\");\n    return MHD_NO;              /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    /* Log that we are setting *req_cls to &aptr to indicate first-call behavior. */\n    ahc_echo_log(\"first_call_set_req_cls\", cls, method, req_cls, connection,\n                 \"setting *req_cls = &aptr and returning MHD_YES\");\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n\n  /* Log that we are resetting request context when done. */\n  ahc_echo_log(\"processing_after_first_call\", cls, method, req_cls, connection,\n               \"resetting *req_cls to NULL\");\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  /* Log auth_info pointer and, if present, some safe details about the\n   * username/password lengths and comparisons so callers can see how the\n   * authentication check proceeded without modifying program behavior.\n   */\n  if (NULL == auth_info)\n  {\n    ahc_echo_log(\"auth_info_null\", cls, method, req_cls, connection,\n                 \"no auth_info returned\");\n  }\n  else\n  {\n    /* compute the same intermediate checks used in the original 'fail'\n     * expression for logging purposes (do not change logic).\n     */\n    size_t want_user_len = strlen(\"Aladdin\");\n    size_t want_pass_len = strlen(\"open sesame\");\n    int username_len_ok = (want_user_len == auth_info->username_len);\n    int username_match = 0;\n    if (auth_info->username != NULL && username_len_ok)\n      username_match = (0 == memcmp (auth_info->username, \"Aladdin\",\n                                     auth_info->username_len));\n    int password_len_ok = (auth_info->password != NULL) &&\n                          (want_pass_len == auth_info->password_len);\n    int password_match = 0;\n    if (password_len_ok)\n      password_match = (0 == memcmp (auth_info->password, \"open sesame\",\n                                     auth_info->password_len));\n\n    char extra_buf[256];\n    /* safe snprintf-like building without including stdio in expression; use snprintf if available\n     * But to avoid adding new includes or complex behavior, use fprintf directly in helper instead.\n     */\n    snprintf(extra_buf, sizeof(extra_buf),\n             \"auth_info=%p user_len=%zu user_len_ok=%d user_match=%d pass_len=%zu pass_len_ok=%d pass_match=%d\",\n             (void *) auth_info,\n             (size_t) auth_info->username_len, username_len_ok, username_match,\n             (size_t) auth_info->password_len, password_len_ok, password_match);\n    ahc_echo_log(\"auth_info_details\", cls, method, req_cls, connection, extra_buf);\n  }\n\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n\n  if (fail)\n  {\n    ahc_echo_log(\"auth_failed\", cls, method, req_cls, connection, NULL);\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n    /* log the response and return code for the failed-auth path */\n    ahc_echo_log(\"queued_basic_auth_required_response\", cls, method, req_cls,\n                 connection, \"queued response for denied access\");\n  }\n  else\n  {\n    ahc_echo_log(\"auth_ok\", cls, method, req_cls, connection, NULL);\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    ahc_echo_log(\"queued_ok_response\", cls, method, req_cls, connection,\n                 \"queued MHD_HTTP_OK\");\n  }\n\n  if (NULL != auth_info)\n  {\n    ahc_echo_log(\"freeing_auth_info\", cls, method, req_cls, connection, NULL);\n    MHD_free (auth_info);\n  }\n  ahc_echo_log(\"destroying_response\", cls, method, req_cls, connection,\n               NULL);\n  MHD_destroy_response (response);\n  ahc_echo_log(\"exit\", cls, method, req_cls, connection, NULL);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation that cls is not modified inside ahc_echo and therefore could be const-qualified is correct in principle (MISRA C 2023 Rule 8.13: prefer pointers to const when possible). However, in this case ahc_echo implements the canonical libmicrohttpd access handler callback signature (void *cls, struct MHD_Connection *..., const char *..., const char *..., const char *..., const char *, size_t *, void **), which requires a non-const void * parameter. Because the function must match that external API\u2019s prototype, the non-const declaration is unavoidable and the rule\u2019s requirement is exempted. Therefore the report that the code violates Rule 8.13 is not correct for this code as shown. If this function were not required to match an external prototype, then changing cls to const void * would be the appropriate fix (or else document/suppress the deviation when matching the external API)."
}