{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pread64",
    "pread",
    "lseek64",
    "lseek",
    "read",
    "SSIZE_MAX",
    "ssize_t",
    "off_t",
    "HAVE_PREAD64",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "_get_osfhandle",
    "HANDLE",
    "INVALID_HANDLE_VALUE",
    "OVERLAPPED",
    "ULARGE_INTEGER",
    "ReadFile",
    "DWORD",
    "MHD_Response",
    "response->fd",
    "response->fd_off",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "_WIN32",
    "__CYGWIN__",
    "uintptr_t",
    "uint64_t",
    "int64_t",
    "INT32_MAX",
    "SEEK_SET"
  ],
  "explanation": "Each listed symbol is needed to determine whether the target function uses compiler or platform-specific language extensions (which would violate the MISRA rule).\n\n- pread64: POSIX/GNU extension (64-bit pread). Required to know if a non\u2011ISO function is being used.\n- pread: POSIX function (not ISO C). Needed to decide if a POSIX-only call is present.\n- lseek64: GNU/OS extension (64-bit lseek). Required to detect use of non\u2011standard APIs.\n- lseek: POSIX function. Needed to check for non\u2011ISO usage.\n- read: POSIX function. Required to determine use of POSIX I/O instead of ISO C.\n- SSIZE_MAX: typically a POSIX/limits macro. Needed to see if non\u2011standard limits macros are used.\n- ssize_t: POSIX typedef (not in ISO C90). Required to decide if a non\u2011standard type is used.\n- off_t: POSIX typedef for file offsets. Required to check for non\u2011standard types and width assumptions.\n- HAVE_PREAD64, HAVE_PREAD, HAVE_LSEEK64: build/configuration macros that select code paths. Required to know which platform-specific APIs are actually compiled in.\n- _get_osfhandle: MSVC/CRT extension to get OS handle from file descriptor. Required to detect Microsoft CRT-specific usage.\n- HANDLE: Windows API typedef (non\u2011standard C). Needed to decide if Windows API types (extensions) are used.\n- INVALID_HANDLE_VALUE: Windows constant. Required to evaluate Windows\u2011specific error handling and platform extension usage.\n- OVERLAPPED: Windows API struct. Needed to check use of Windows overlapped I/O (API extension beyond ISO C).\n- ULARGE_INTEGER: Windows union/struct for 64\u2011bit parts. Required to verify Windows API usage and conversions.\n- ReadFile: Windows API function. Required to determine whether Windows-specific I/O (non\u2011ISO) is used.\n- DWORD: Windows typedef. Needed to confirm use of Windows-specific integer types.\n- MHD_Response: application/library type (libmicrohttpd). Required to know types of members used (fd, fd_off) and whether the library defines any nonstandard behaviors or macros.\n- response->fd: member used as an OS file descriptor/handle. Required to determine its type (int, HANDLE, etc.) and whether casts rely on nonstandard behavior.\n- response->fd_off: member added to offset calculation. Needed to determine its signedness/width and possible reliance on nonstandard types.\n- MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM: library return constants. Required to understand return semantics and whether the code relies on nonstandard values/types.\n- _WIN32, __CYGWIN__: predefined platform macros that enable conditional compilation. Required to know which platform-specific branches are active for a given build.\n- uintptr_t: C99 integer type for pointer casts. Needed to decide whether C99 features are being used (may be allowed or disallowed depending on the MISRA profile).\n- uint64_t, int64_t: C99 fixed-width integer types used for offsets. Required to judge whether C99 integer types (standard or extension for some toolchains) are used.\n- INT32_MAX: limit macro (from limits.h or stdint.h). Required to determine width-related checks and whether non\u2011standard limits are used.\n- SEEK_SET: POSIX constant for lseek. Needed to check use of POSIX constants.\n\nIn short: to evaluate the MISRA rule about language extensions you must know which platform or library APIs/types/macros are actually referenced or enabled by configuration macros, and whether those APIs/types are part of standard ISO C or are platform/compiler extensions. The symbols above are the ones that determine whether non\u2011ISO (POSIX, GNU, Windows, CRT, or library) extensions are used in this function."
}