{
  "user_message": "An agent A claimed that the following file_reader code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of file_reader.\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Given the provided project configuration where HAVE_PREAD64 (and HAVE_PREAD / HAVE_LSEEK64) are defined, the #if defined(HAVE_PREAD64) branch above is always taken and the #else /* ! HAVE_PREAD */ fragment can never be compiled or executed. Thus the code in that fragment is unreachable (dead) in this project configuration.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/617.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  /* Log entry and key state */\n  log_probe (\"file_reader: entry pos=%\" PRIu64 \" max=%zu fd=%d fd_off=%lld offset64=%\" PRId64,\n             pos, max, response->fd, (long long) response->fd_off, (int64_t) offset64);\n\n  if (offset64 < 0)\n  {\n    log_probe (\"file_reader: offset64 < 0 -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  log_probe (\"file_reader: compiled with HAVE_PREAD64 -> using pread64 (offset=%\" PRId64 \")\", (int64_t) offset64);\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  log_probe (\"file_reader: compiled with HAVE_PREAD -> using pread (offset=%\" PRId64 \")\", (int64_t) offset64);\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n  {\n    log_probe (\"file_reader: pread branch - offset64 too large for off_t -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n  }\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n  log_probe (\"file_reader: compiled without HAVE_PREAD/HAVE_PREAD64 -> using seek+read path (offset=%\" PRId64 \")\", (int64_t) offset64);\n#if defined(HAVE_LSEEK64)\n  log_probe (\"file_reader: compiled with HAVE_LSEEK64 -> using lseek64 (offset=%\" PRId64 \")\", (int64_t) offset64);\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n  {\n    log_probe (\"file_reader: lseek64 failed -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#else  /* ! HAVE_LSEEK64 */\n  log_probe (\"file_reader: no lseek64 -> using lseek (offset=%\" PRId64 \")\", (int64_t) offset64);\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n  {\n    log_probe (\"file_reader: lseek branch - offset64 too large for off_t -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n  {\n    log_probe (\"file_reader: lseek failed -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n  {\n    log_probe (\"file_reader: read returned 0 -> MHD_CONTENT_READER_END_OF_STREAM\");\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (n < 0)\n  {\n    log_probe (\"file_reader: read returned error (n=%zd) -> MHD_CONTENT_READER_END_WITH_ERROR\", n);\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n  log_probe (\"file_reader: read returned n=%zd -> returning n\", n);\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n  {\n    log_probe (\"file_reader: INVALID_HANDLE_VALUE -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  }\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    log_probe (\"file_reader: Windows path -> ReadFile fh=%p offset=%\" PRId64 \" toRead=%u\", (void *) (uintptr_t) fh, (int64_t) offset64, toRead);\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n    {\n      log_probe (\"file_reader: ReadFile failed -> returning MHD_CONTENT_READER_END_WITH_ERROR\");\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    }\n    if (0 == resRead)\n    {\n      log_probe (\"file_reader: ReadFile returned 0 -> MHD_CONTENT_READER_END_OF_STREAM\");\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n    log_probe (\"file_reader: ReadFile returned resRead=%u -> returning (ssize_t)resRead\", resRead);\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for file_reader. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.1 forbids unreachable code in the delivered project (i.e. in the translation units that are actually compiled/linked into the build). The fragments controlled by #if/#elif/#else are resolved by the preprocessor: if HAVE_PREAD64 is defined the #if defined(HAVE_PREAD64) branch is compiled and the #else /* ! HAVE_PREAD */ branch is not present in the translation unit at all. Code that is removed by the preprocessor is not part of the project and therefore is not \u201cunreachable code\u201d under Rule 2.1. \n\nIf you want to verify what code is actually in the project, inspect the preprocessed output (e.g. gcc -E) or the built object for that configuration. The empty test log only shows the test did not exercise file_reader at runtime (or logging was not reached), and does not demonstrate a Rule 2.1 violation. Only if the translation unit actually contains code that can never be executed at runtime (for example, statements after an unconditional return inside compiled code) would Rule 2.1 be violated; that is not the situation shown here. "
}