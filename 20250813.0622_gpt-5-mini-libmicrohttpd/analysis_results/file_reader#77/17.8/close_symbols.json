{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "SSIZE_MAX",
    "INT32_MAX",
    "HAVE_PREAD",
    "HAVE_PREAD64",
    "HAVE_LSEEK64",
    "_WIN32",
    "__CYGWIN__",
    "struct MHD_Response",
    "size_t",
    "ssize_t",
    "uint64_t",
    "read",
    "pread",
    "pread64",
    "lseek",
    "lseek64",
    "ReadFile",
    "_get_osfhandle",
    "HANDLE",
    "INVALID_HANDLE_VALUE",
    "OVERLAPPED",
    "ULARGE_INTEGER",
    "DWORD",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM"
  ],
  "explanation": "Brief rationale for each symbol (why it is needed to decide whether the function modifies its parameters in violation of the MISRA rule):\n\n- SSIZE_MAX: used in the expression \"if (max > SSIZE_MAX) max = SSIZE_MAX;\" \u2014 needed to recognise that the parameter 'max' is being assigned/clamped (a direct parameter modification).\n\n- INT32_MAX: used in several branches to decide feasibility of seeks/reads; required to understand the conditional logic that may lead to early returns vs. further code that may modify parameters.\n\n- HAVE_PREAD, HAVE_PREAD64, HAVE_LSEEK64: compile-time feature macros control which code path is compiled. Whether the assignment to 'max' or other parameter-related behaviour exists depends on these macros, so they are required to determine which branch and potential parameter modifications are active.\n\n- _WIN32, __CYGWIN__: platform macros that select the Windows vs. POSIX code paths. The POSIX path contains the assignment to 'max'; the Windows path does not. Knowing which path compiles is essential for assessing a violation.\n\n- struct MHD_Response: the function casts cls to this type and accesses response->fd and response->fd_off. To confirm that cls (the parameter) itself is not being modified (only the local 'response' pointer is used) and to check whether accesses are to the object pointed to (allowed) you must know this type's definition and field types (fd, fd_off).\n\n- size_t, ssize_t, uint64_t: the parameter and return types affect interpretation of comparisons and assignments (e.g. signed/unsigned issues). Confirming types ensures correct determination of whether the code modifies the parameter variable (max) vs. only manipulating values or conversions.\n\n- read, pread, pread64, lseek, lseek64, ReadFile: these I/O functions receive 'buf' (and other values) but operate on the memory pointed to by 'buf' rather than the pointer variable itself. Including these symbols lets the analyser confirm that passing 'buf' does not constitute modification of the pointer parameter (only the pointee), which is allowed by the MISRA rule.\n\n- _get_osfhandle, HANDLE, INVALID_HANDLE_VALUE, OVERLAPPED, ULARGE_INTEGER, DWORD: Windows-specific symbols used in the Windows branch. They are needed to inspect that the Windows code does not assign to pointer or non-pointer parameters (e.g. no assignment to 'max' or 'buf') and that any manipulations are on local variables or pointees only.\n\n- MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM: return-code macros/constants are used throughout; knowing them is helpful to see whether the function returns early before/after any parameter modification, and to ensure return statements do not implicitly modify parameters.\n\nOverall: the most critical facts for MISRA Rule checking here are (a) which compile-time path is active (_WIN32 / HAVE_PREAD etc.), and (b) the presence of the assignment \"max = SSIZE_MAX\" in the non-Windows path. The listed symbols let a verifier determine whether that assignment is compiled in, whether any other statements write to the parameter variables (cls, pos, buf, max), and whether passes to external functions only modify pointees and not the pointer parameter variables themselves."
}