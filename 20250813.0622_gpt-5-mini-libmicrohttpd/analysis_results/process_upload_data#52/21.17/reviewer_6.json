{
  "user_message": "An agent A claimed that the following process_upload_data code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of process_upload_data.\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:strcmp(key, \"language\") reads both strings until a terminating NUL. The literal \"language\" is NUL-terminated, but there is no check that the caller-provided key is NUL-terminated (or non-NULL). If key points to a buffer that does not contain a terminating NUL within its allocated bounds (or key is NULL), strcmp will read past the end of the object referenced by key, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *label,\n                          const char *key,\n                          const char *filename,\n                          const char *data,\n                          uint64_t off,\n                          size_t size,\n                          struct UploadContext *uc)\n{\n  FILE *f = fopen(\"/tmp/logs/423.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log basic pointer/state info only (avoid dereferencing client-provided\n     pointers to prevent introducing new out-of-bounds accesses). */\n  fprintf(f, \"PROBE %s: key=%p, key_is_null=%d, filename=%p, data=%p, off=%llu, size=%zu, uc=%p\\n\",\n          label,\n          (void *) key,\n          (int) (key == NULL),\n          (void *) filename,\n          (void *) data,\n          (unsigned long long) off,\n          size,\n          (void *) uc);\n  if (NULL != uc)\n  {\n    /* Don't dereference strings inside uc; log their pointer values and fd */\n    fprintf(f, \"  uc->fd=%d, uc->filename=%p, uc->category=%p, uc->language=%p\\n\",\n            uc->fd,\n            (void *) uc->filename,\n            (void *) uc->category,\n            (void *) uc->language);\n  }\n  fflush(f);\n  (void) fclose(f);\n}\n\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  /* Probes: log state just before each strcmp that could read the caller\n     supplied `key`. This helps reproduce a crash or out-of-bounds read by\n     showing the last recorded state before strcmp is invoked. */\n  probe_log(\"before_cmp_category\", key, filename, data, off, size, uc);\n  if (0 == strcmp (key, \"category\"))\n  {\n    probe_log(\"after_cmp_category_eq\", key, filename, data, off, size, uc);\n    return do_append (&uc->category, data, size);\n  }\n\n  probe_log(\"before_cmp_language\", key, filename, data, off, size, uc);\n  if (0 == strcmp (key, \"language\"))\n  {\n    probe_log(\"after_cmp_language_eq\", key, filename, data, off, size, uc);\n    return do_append (&uc->language, data, size);\n  }\n\n  probe_log(\"before_cmp_upload\", key, filename, data, off, size, uc);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    probe_log(\"cmp_upload_not_equal\", key, filename, data, off, size, uc);\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  probe_log(\"cmp_upload_equal\", key, filename, data, off, size, uc);\n\n  if (NULL == filename)\n  {\n    probe_log(\"no_filename\", key, filename, data, off, size, uc);\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    probe_log(\"missing_form_data\", key, filename, data, off, size, uc);\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      probe_log(\"path_traversal_detected\", key, filename, data, off, size, uc);\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      probe_log(\"filename_overflow_or_error\", key, filename, data, off, size, uc);\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      probe_log(\"open_failed\", key, filename, data, off, size, uc);\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n    probe_log(\"file_opened\", key, uc->filename, data, off, size, uc);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    probe_log(\"write_failed\", key, uc->filename, data, off, size, uc);\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  probe_log(\"return_success\", key, uc->filename, data, off, size, uc);\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for process_upload_data. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in the absence of a documented, provable guarantee that the incoming key pointer is non-NULL and points to a NUL-terminated object. MISRA C 2023 Rule 21.17 requires that calls to string.h functions must not access beyond the bounds of the objects referenced by their pointer parameters. The code calls strcmp(key, \"category\"), strcmp(key, \"language\") and strcmp(key, \"upload\") without checking key for NULL or otherwise ensuring that key points to a NUL-terminated buffer. While the string literals are NUL-terminated, strcmp will read through key until it finds a NUL; if key is NULL or not NUL-terminated within its allocated bounds, strcmp can read out of bounds (or dereference NULL), violating Rule 21.17. \n\nIf there is an external, documented API contract (from the caller/library) that guarantees key is always non-NULL and NUL-terminated, then the usage is acceptable. However, no such guarantee was provided in the report, so as presented the code does violate Rule 21.17. Recommended fixes: validate key != NULL before calling strcmp, or use a length-bounded comparison based on a known length obtained from the API, or otherwise ensure the precondition (NUL-termination) is satisfied before calling strcmp."
}