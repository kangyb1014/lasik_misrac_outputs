{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe member uc->filename is declared as char * but is only used for read-only operations (printing, unlink) and is never modified through the pointer; assigning strdup(fn) to uc->filename therefore produces a non-const pointer where a const-qualified pointer could be used. This means the pointer should have been declared const char *filename in struct UploadContext (or otherwise const-qualified) to follow MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_upload_data code that contains useful probe functions that print useful logs to a file \"/tmp/logs/419.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_upload_data as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_upload_data:\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified process_upload_data code.\n",
  "test_code": "static enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  FILE *logf = NULL;\n\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  /* Open probe log (best-effort). */\n  logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf (logf,\n             \"process_upload_data ENTRY: uc=%p key='%s' filename='%s' size=%zu fd=%d category=%p language=%p uc->filename=%p\\n\",\n             (void *) uc,\n             (key != NULL) ? key : \"(null)\",\n             (filename != NULL) ? filename : \"(null)\",\n             size,\n             (uc != NULL) ? uc->fd : -2,\n             (void *) ((uc != NULL) ? uc->category : NULL),\n             (void *) ((uc != NULL) ? uc->language : NULL),\n             (void *) ((uc != NULL) ? uc->filename : NULL));\n    fflush (logf);\n    fclose (logf);\n    logf = NULL;\n  }\n\n  if (0 == strcmp (key, \"category\"))\n  {\n    /* Log branch taken */\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf, \"process_upload_data: appending to category (size=%zu)\\n\", size);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    return do_append (&uc->category, data, size);\n  }\n  if (0 == strcmp (key, \"language\"))\n  {\n    /* Log branch taken */\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf, \"process_upload_data: appending to language (size=%zu)\\n\", size);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    return do_append (&uc->language, data, size);\n  }\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf, \"process_upload_data: unexpected key '%s' -> ignored\\n\", key);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf, \"process_upload_data: filename is NULL -> aborting\\n\");\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf,\n               \"process_upload_data: missing form data for filename='%s' category=%p language=%p -> response=request_refused_response\\n\",\n               filename,\n               (void *) uc->category,\n               (void *) uc->language);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n\n      logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf (logf,\n                 \"process_upload_data: rejected filename='%s' due to path traversal or separators\\n\",\n                 filename);\n        fflush (logf);\n        fclose (logf);\n        logf = NULL;\n      }\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n\n      logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf (logf,\n                 \"process_upload_data: filename too long or snprintf error for filename='%s' -> response=request_refused_response\\n\",\n                 filename);\n        fflush (logf);\n        fclose (logf);\n        logf = NULL;\n      }\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n\n      logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf (logf,\n                 \"process_upload_data: open() failed for path='%s' errno=%d (%s)\\n\",\n                 fn,\n                 errno,\n                 strerror (errno));\n        fflush (logf);\n        fclose (logf);\n        logf = NULL;\n      }\n      return MHD_NO;\n    }\n    /* Log the filename that will be assigned to uc->filename (before strdup) */\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf, \"process_upload_data: assigning uc->filename = strdup(\\\"%s\\\") ; uc=%p\\n\", fn, (void *) uc);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n    uc->filename = strdup (fn);\n\n    /* Log result of strdup */\n    logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (NULL != logf)\n    {\n      fprintf (logf,\n               \"process_upload_data: strdup returned %p for fn='%s' ; uc->filename=%p\\n\",\n               (void *) uc->filename,\n               fn,\n               (void *) uc->filename);\n      fflush (logf);\n      fclose (logf);\n      logf = NULL;\n    }\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      /* Log unlink/free actions and the filename pointer/state */\n      logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf (logf,\n                 \"process_upload_data: write failed; will unlink('%s') and free uc->filename=%p ; errno=%d (%s)\\n\",\n                 uc->filename,\n                 (void *) uc->filename,\n                 errno,\n                 strerror (errno));\n        fflush (logf);\n        fclose (logf);\n        logf = NULL;\n      }\n\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n\n      /* Log post-unlink state */\n      logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n      if (NULL != logf)\n      {\n        fprintf (logf, \"process_upload_data: after cleanup uc->filename=%p uc->fd=%d\\n\", (void *) uc->filename, uc->fd);\n        fflush (logf);\n        fclose (logf);\n        logf = NULL;\n      }\n    }\n    return MHD_NO;\n  }\n\n  /* Successful write (or size was 0) -- log progress */\n  logf = fopen(\"/tmp/logs/419.txt\", \"a\");\n  if (NULL != logf)\n  {\n    fprintf (logf, \"process_upload_data: wrote %zu bytes to uc->fd=%d uc->filename=%p\\n\", size, uc->fd, (void *) uc->filename);\n    fflush (logf);\n    fclose (logf);\n    logf = NULL;\n  }\n  return MHD_YES;\n}\n"
}