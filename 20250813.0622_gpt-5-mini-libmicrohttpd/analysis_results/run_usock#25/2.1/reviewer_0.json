{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call msg = ws_receive_frame(...) sets *type = WS_OPCODE_CON_CLOSE_FRAME but returns NULL for close frames. Immediately after that call run_usock checks if (NULL == msg) { break; } so execution will break out of the loop before reaching the later else branch. Therefore the branch\n    else { if (type == WS_OPCODE_CON_CLOSE_FRAME) { free(msg); break; } }\ncan never be reached: to enter it type != WS_OPCODE_TEXT_FRAME must hold and msg must be non-NULL, but ws_receive_frame always returns NULL when it sets type to WS_OPCODE_CON_CLOSE_FRAME. This makes the close-frame handling block unreachable, violating MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/201.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  time_t t = time (NULL);\n  struct tm tm_buf;\n  if (localtime_r (&t, &tm_buf) != NULL)\n  {\n    char timebuf[64];\n    if (strftime (timebuf, sizeof (timebuf), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n      fprintf (f, \"%s \", timebuf);\n  }\n  fprintf (f, \"[tid=%lu] \", (unsigned long) pthread_self ());\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  probe_log (\"run_usock entry: ws=%p sock=%d urh=%p\", (void *) ws,\n             ws ? (int) ws->sock : -1, (void *) urh);\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    probe_log (\"recv returned got=%zd\", got);\n    if (0 >= got)\n    {\n      probe_log (\"recv indicates connection closed or error (got=%zd) -> break\", got);\n      break;\n    }\n    probe_log (\"calling ws_receive_frame with buffer (got=%zd)\", got);\n    msg = ws_receive_frame (buf, &got, &type);\n    probe_log (\"ws_receive_frame returned msg=%p type=%d got=%zd\", (void *) msg, type, got);\n    if (NULL == msg)\n    {\n      probe_log (\"msg == NULL -> breaking out of loop\");\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      probe_log (\"processing TEXT frame: msg=%p\", (void *) msg);\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          probe_log (\"ws_send_frame returned sent=%zd for text=%p\", sent, (void *) text);\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      probe_log (\"freeing msg at %p (text frame)\", (void *) msg);\n      free (msg);\n      if (-1 == sent)\n      {\n        probe_log (\"send failed (sent=%zd) -> break\", sent);\n        break;\n      }\n    }\n    else\n    {\n      probe_log (\"non-TEXT frame received: type=%d msg=%p\", type, (void *) msg);\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        probe_log (\"close frame handling: free(msg=%p) and break\", (void *) msg);\n        free (msg);\n        break;\n      }\n      else\n      {\n        probe_log (\"frame type %d is not TEXT nor CLOSE; leaving msg=%p as-is and continuing loop\", type, (void *) msg);\n      }\n    }\n  }\n  probe_log (\"exiting receive loop, beginning cleanup for sock=%d\", ws ? (int) ws->sock : -1);\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      probe_log (\"cleared CLIENT_SOCKS[%d] for sock=%d\", i, ws->sock);\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  probe_log (\"freed ws and calling MHD_upgrade_action to close urh=%p\", (void *) urh);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  probe_log (\"run_usock exit\");\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the information given. Agent A\u2019s claim depends on the behaviour of ws_receive_frame (that it sets type = WS_OPCODE_CON_CLOSE_FRAME and always returns NULL for close frames). The run_usock code itself does not prove that behaviour; whether the else branch (handling a non\u2011text close frame) is reachable depends entirely on ws_receive_frame\u2019s contract/implementation. Without evidence that ws_receive_frame always returns NULL when it sets type to CLOSE, you cannot conclude the close-frame branch is unreachable. The provided probe build produced no runtime evidence (the log was empty) and no implementation of ws_receive_frame was supplied, so there is no proof of an impossible branch. Therefore the report of a MISRA 2.1 violation is not correct based on the available code.\n\nRecommendation: inspect or document ws_receive_frame\u2019s behaviour. If it is guaranteed to return NULL for close frames, then the close-frame handling in the else branch is indeed unreachable and should be removed or the code restructured; otherwise keep the branch. To settle this formally, either examine the ws_receive_frame implementation or run tests/analysis that demonstrate the branch cannot be executed."
}