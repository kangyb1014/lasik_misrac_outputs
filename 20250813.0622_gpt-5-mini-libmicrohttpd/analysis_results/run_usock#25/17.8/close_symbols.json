{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "MHD_UpgradeResponseHandle",
    "make_blocking",
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "MHD_upgrade_action",
    "MHD_upgraded_connection_mark_app_closed_",
    "free",
    "CLIENT_SOCKS",
    "MUTEX"
  ],
  "explanation": "Explain why each symbol is required to determine if the function modifies its parameter (void *cls):\n\n- struct WsData\n  - Needed to know the layout and types of ws's members (urh, sock, etc.). This shows that the function only reads/writes members of the object pointed to by cls (allowed) and whether any member access could alias the parameter variable itself.\n\n- MHD_UpgradeResponseHandle\n  - Type of ws->urh passed to MHD_upgrade_action; knowing its type/prototype confirms that the call cannot be modifying the local parameter variable cls (it only receives the urh pointer).\n\n- make_blocking\n  - Called with ws->sock. The prototype/signature is needed to confirm it does not accept a pointer-to-pointer or otherwise gain access to the cls local variable (i.e. it does not take void ** or similar that could allow modification of the parameter variable).\n\n- ws_receive_frame\n  - Its signature shows what it can modify (it receives buf, &got, &type). Confirming it does not accept or obtain a pointer to ws/cls ensures it cannot modify the parameter variable itself.\n\n- ws_send_frame\n  - Called with ws->sock and text; its prototype is needed to verify it does not take or derive the address of ws/cls (no void ** parameter) and therefore cannot modify the parameter variable.\n\n- send_all\n  - Called (indirectly) by ws_send_frame. Its prototype is required to ensure it does not accept pointer-to-pointer parameters that could be used to modify the local parameter variable cls.\n\n- MHD_upgrade_action\n  - The prototype (and its behavior) is needed to confirm it does not have any mechanism to alter the caller's local parameter variable cls (it receives urh and an action code only).\n\n- MHD_upgraded_connection_mark_app_closed_\n  - callee of MHD_upgrade_action (present in the static graph). Its definition/signature ensures that following the MHD_upgrade_action chain there is no code that can access/alter run_usock's cls local variable.\n\n- free\n  - free(ws) is used. Knowing free's prototype confirms it takes a pointer to the object (allowed to deallocate the object pointed to by cls) and does not modify the parameter variable cls itself. This distinguishes deallocating the pointed object (permitted) from modifying the parameter variable (disallowed).\n\n- CLIENT_SOCKS\n  - Global array inspected/modified under MUTEX. Its declaration/type is required to check for possible aliasing between elements of CLIENT_SOCKS and the ws/cls pointer (e.g., if CLIENT_SOCKS held pointers to the same storage as cls), which could imply indirect modification of the parameter object or confusion about whether the parameter variable itself is changed.\n\n- MUTEX\n  - The mutex used around CLIENT_SOCKS modifications. Its declaration/usage is required to reason about concurrent modifications and to ensure no covert path exists by which the thread-synchronization primitives or their implementations could alter the local parameter variable cls.\n\nRationale summary: to decide if run_usock violates the MISRA rule (a function parameter shall not be modified), the analyzer must confirm (a) the local parameter variable cls is never assigned to after entry, and (b) no called function or global construct can obtain the address of that parameter variable (or otherwise cause it to be modified). The symbols above are the minimal set needed to inspect signatures and possible aliasing/indirection paths that could lead to modification of the parameter variable rather than only modification of the object it points to (which is allowed)."
}