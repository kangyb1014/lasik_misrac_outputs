{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If ws_receive_frame does not modify the input buffer and returns data that the caller only reads, then both the parameter and the returned pointer should be const-qualified. In the code fragment msg = ws_receive_frame(buf, &got, &type); msg is declared as unsigned char * (non-const) and buf is passed as a non-const array; this permits modification even if none is intended. Thus if ws_receive_frame merely reads buf and returns a read-only pointer, the correct form would be e.g. const unsigned char *ws_receive_frame(const unsigned char *buf, ssize_t *got, int *type); and msg should be const unsigned char *msg; failing to use const in that case violates MISRA C 2023 Rule 8.13. Note: if ws_receive_frame actually returns heap memory that the caller must free or the caller is expected to modify the returned data, then const would not be appropriate and no violation would occur.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_write(const char *fmt, ...)\n{\n  FILE *f = NULL;\n  va_list ap;\n\n  /* Try to open the requested log file. If the parent dir doesn't exist, try to create it. */\n  f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == f)\n  {\n    /* best-effort: attempt to create directory, ignore errors */\n    (void) mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  }\n  if (NULL == f)\n  {\n    /* Fallback: try /tmp */\n    f = fopen(\"/tmp/203.txt\", \"a\");\n  }\n  if (NULL == f)\n  {\n    /* If even that fails, nothing we can do */\n    return;\n  }\n\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fflush(f);\n  fclose(f);\n}\nstatic void log_buf_hex(FILE *f, const unsigned char *b, ssize_t len, ssize_t max)\n{\n  ssize_t i, lim = (len < max) ? len : max;\n  for (i = 0; i < lim; ++i)\n    fprintf(f, \"%02x\", b[i]);\n  if (len > lim)\n    fprintf(f, \"...\");\n}\nstatic void probe_log_before_recv(int sock)\n{\n  log_write(\"[run_usock] sock=%d: entering recv loop\\n\", sock);\n}\nstatic void probe_log_after_recv(int sock, ssize_t got)\n{\n  log_write(\"[run_usock] sock=%d: recv returned got=%zd\\n\", sock, got);\n}\nstatic void probe_log_before_ws_receive_frame(int sock, const unsigned char *buf, ssize_t got)\n{\n  FILE *f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == f)\n  {\n    (void) mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  }\n  if (NULL == f)\n    f = fopen(\"/tmp/203.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[run_usock] sock=%d: calling ws_receive_frame with got=%zd, buf(first 32 bytes hex)=\", sock, got);\n  log_buf_hex(f, buf, got, 32);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void probe_log_after_ws_receive_frame(int sock, const unsigned char *buf, ssize_t got, unsigned char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == f)\n  {\n    (void) mkdir(\"/tmp/logs\", 0777);\n    f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  }\n  if (NULL == f)\n    f = fopen(\"/tmp/203.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[run_usock] sock=%d: ws_receive_frame returned msg=%p\\n\", sock, (void *) msg);\n  if (NULL != msg)\n  {\n    /* Detect if returned pointer points into the original buffer */\n    if ((msg >= buf) && (msg < buf + sizeof(((unsigned char[1]){0}) ) + 2047))\n    {\n      /* The above expression avoids direct use of sizeof(buf) here; we'll compute offset safely */\n    }\n    /* compute offset more directly */\n    if ((msg >= buf) && (msg < buf + 2048))\n    {\n      fprintf(f, \"[run_usock] sock=%d: msg points inside buf at offset=%td\\n\", sock, (ptrdiff_t)(msg - buf));\n    }\n    else\n    {\n      fprintf(f, \"[run_usock] sock=%d: msg does NOT point inside buf\\n\", sock);\n    }\n\n    fprintf(f, \"[run_usock] sock=%d: msg(first 32 bytes hex)=\", sock);\n    log_buf_hex(f, (const unsigned char *) msg, got, 32);\n    fprintf(f, \"\\n\");\n  }\n  fclose(f);\n}\nstatic void probe_log_buf_compare(int sock, const unsigned char *before, const unsigned char *after, ssize_t got)\n{\n  /* Compare before and after buffers for the received length */\n  ssize_t i;\n  for (i = 0; i < got; ++i)\n  {\n    if (before[i] != after[i])\n    {\n      log_write(\"[run_usock] sock=%d: buf modified at index %zd: before=0x%02x after=0x%02x\\n\",\n                sock, i, (unsigned int) before[i], (unsigned int) after[i]);\n      return;\n    }\n  }\n  log_write(\"[run_usock] sock=%d: buf unmodified for %zd bytes\\n\", sock, got);\n}\nstatic void probe_log_before_free_msg(int sock, unsigned char *msg)\n{\n  log_write(\"[run_usock] sock=%d: about to free msg=%p\\n\", sock, (void *) msg);\n}\nstatic void probe_log_after_free_msg(int sock)\n{\n  log_write(\"[run_usock] sock=%d: msg freed\\n\", sock);\n}\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n  unsigned char buf_copy[2048];\n\n  make_blocking (ws->sock);\n  probe_log_before_recv((int) ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    probe_log_after_recv((int) ws->sock, got);\n    if (0 >= got)\n    {\n      log_write(\"[run_usock] sock=%d: recv indicated connection closed or error, breaking loop\\n\", (int) ws->sock);\n      break;\n    }\n\n    /* save a copy of the buffer to detect modifications by ws_receive_frame */\n    if (got > 0 && got <= (ssize_t) sizeof(buf))\n      memcpy(buf_copy, buf, (size_t) got);\n\n    probe_log_before_ws_receive_frame((int) ws->sock, buf, got);\n    msg = ws_receive_frame (buf, &got, &type);\n    probe_log_after_ws_receive_frame((int) ws->sock, buf, got, msg);\n\n    /* Compare buffer to see if ws_receive_frame modified it */\n    if (got > 0 && got <= (ssize_t) sizeof(buf))\n      probe_log_buf_compare((int) ws->sock, buf_copy, buf, got);\n\n    if (NULL == msg)\n    {\n      log_write(\"[run_usock] sock=%d: ws_receive_frame returned NULL, breaking loop\\n\", (int) ws->sock);\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          log_write(\"[run_usock] sock=%d: allocated text=%p, sending result sent=%zd\\n\", (int) ws->sock, (void *) text, sent);\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n\n      probe_log_before_free_msg((int) ws->sock, msg);\n      free (msg);\n      probe_log_after_free_msg((int) ws->sock);\n\n      if (-1 == sent)\n      {\n        log_write(\"[run_usock] sock=%d: send failed, breaking loop\\n\", (int) ws->sock);\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        probe_log_before_free_msg((int) ws->sock, msg);\n        free (msg);\n        probe_log_after_free_msg((int) ws->sock);\n        log_write(\"[run_usock] sock=%d: received close frame, breaking loop\\n\", (int) ws->sock);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 8.13 asks that pointers point to const-qualified types when that is possible. In the code shown, making the pointers const is not possible/appropriate: buf is written by recv() (so it must be mutable), and msg is passed to free() (and is treated as owned/allocated data that the caller frees), so it must be a non-const pointer. The agent\u2019s hypothetical is valid only if the ws_receive_frame API actually promised a read-only view (i.e. it took a const input buffer and returned a pointer to read-only data that the caller must not free or modify). There is no evidence of that in the snippet \u2014 the use of free(msg), in particular, indicates the returned pointer is owned and mutable. To be certain you must inspect the ws_receive_frame declaration and its ownership contract; as presented, the report of a Rule 8.13 violation is not correct."
}