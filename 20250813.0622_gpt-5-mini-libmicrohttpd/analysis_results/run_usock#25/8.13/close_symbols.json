{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ws_receive_frame (prototype)",
    "ws_send_frame (prototype)",
    "send_all (prototype)",
    "struct WsData (definition)",
    "struct MHD_UpgradeResponseHandle (definition)",
    "MHD_upgrade_action (prototype)",
    "CLIENT_SOCKS (declaration)",
    "MAX_CLIENTS (declaration)",
    "MHD_INVALID_SOCKET (macro/constant)"
  ],
  "explanation": "For checking MISRA: 'pointer should point to a const-qualified type whenever possible' you must know the exact pointer types/ownership/const qualifiers used by called functions and the data structures manipulated in run_usock. Each symbol is required for the reasons below:\n\n- ws_receive_frame (prototype): run_usock assigns its return to 'msg' and later frees it and never mutates its contents. The function prototype reveals the return pointer type (e.g. unsigned char * vs const unsigned char *), any const qualification on the input buffer parameter, and ownership semantics. If ws_receive_frame returns a pointer-to-const, freeing it or passing it to non-const APIs could be a violation; if it returns non-const, that affects whether msg could/should be declared const.\n\n- ws_send_frame (prototype): run_usock calls ws_send_frame with 'text' (and text is constructed but not modified by ws_send_frame). The prototype shows whether the function expects a const-qualified buffer parameter (e.g. const void * or const char *) or a mutable pointer. That determines whether passing a non-const char * is appropriate or whether ws_send_frame should accept const.\n\n- send_all (prototype): ws_send_frame calls send_all (per call graph). The prototype shows whether the low-level send routine accepts const-qualified buffers; this affects whether higher-level functions (ws_send_frame and thus callers like run_usock) should propagate const qualification for their buffer parameters.\n\n- struct WsData (definition): run_usock uses ws->urh and ws->sock. The struct definition reveals the types (and any const qualifiers) of these members. In particular, the type of ws->urh determines whether passing it to MHD_upgrade_action should use a const-qualified pointer; the type of ws->sock determines compatibility with CLIENT_SOCKS and socket API signatures.\n\n- struct MHD_UpgradeResponseHandle (definition): to determine whether urh should be treated as pointer-to-const when passed to MHD_upgrade_action (and whether run_usock is violating constness by passing a non-const pointer or by later calling functions that mutate it).\n\n- MHD_upgrade_action (prototype): run_usock calls this with urh and a constant action. Its prototype shows whether the parameter accepting the handle is const-qualified (e.g. const struct MHD_UpgradeResponseHandle *) or not; mismatches between the handle type and the function prototype indicate const-related issues.\n\n- CLIENT_SOCKS (declaration), MAX_CLIENTS (declaration), MHD_INVALID_SOCKET (macro/constant): these reveal the element type of CLIENT_SOCKS and the type/value used for invalid sockets. Knowing the element type of CLIENT_SOCKS and ws->sock type (from struct WsData) is necessary to determine whether any pointer-to-integer or integer-to-pointer conversions are hiding constness issues, and to ensure the correct type compatibility (not strictly pointer const but necessary context to reason about ws->sock usage and any required qualifications).\n\nNote: standard library prototypes (snprintf, malloc, free, recv) and pthread functions are assumed available from headers; they do not generally change the const qualification decisions in run_usock beyond the items listed above. The listed symbols are the minimum additional declarations/definitions required to decide whether pointers in run_usock (returned/accepted/passed) should be const-qualified and whether current usage violates MISRA's pointer-to-const guidance."
}