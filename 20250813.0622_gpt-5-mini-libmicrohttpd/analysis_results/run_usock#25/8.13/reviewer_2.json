{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The variable 'msg' is declared as 'unsigned char *' but is only read (passed to snprintf as the '%s' argument). Per MISRA C 2023 Rule 8.13 the pointer should be to a const-qualified type when possible. Here 'msg' should be declared as a pointer to const (for example 'const unsigned char *msg' or 'const char *msg') because the buffer is not modified by snprintf. (Also note the unsigned char -> char mismatch when used with '%s'.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_usock_log(const char *stage, struct WsData *ws,\n                 unsigned char *msg, ssize_t got, int type,\n                 int buf_size, ssize_t sent)\n{\n  FILE *f = fopen(\"/tmp/logs/203.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  fprintf(f, \"--- run_usock probe: %s ---\\n\", stage);\n  fprintf(f, \"ws ptr: %p\\n\", (void *) ws);\n  /* Print sock value as used elsewhere in this file */\n  fprintf(f, \"ws->sock: %d\\n\", (int) ws->sock);\n  fprintf(f, \"got: %zd, type: %d, buf_size: %d, sent: %zd\\n\",\n          got, type, buf_size, sent);\n\n  if (msg != NULL)\n  {\n    /* Log pointer value and a short hex dump. Cast for printing pointer. */\n    fprintf(f, \"msg ptr: %p\\n\", (void *) msg);\n\n    /* Hex-dump up to the first 32 bytes or until NUL. This mirrors the\n       fact that the code later uses msg with \"%%s\" (reading it as a C string).\n       We limit the dump to avoid excessively large logs. */\n    fprintf(f, \"msg hex (up to 32 bytes or until NUL):\");\n    {\n      int i;\n      for (i = 0; i < 32; i++)\n      {\n        unsigned char c = msg[i];\n        fprintf(f, \" %02x\", c);\n        if (c == '\\0')\n          break;\n      }\n      fprintf(f, \"\\n\");\n    }\n\n    /* Attempt a safe string extraction for logging: copy up to 256 chars\n       into a local buffer and NUL-terminate. This is a diagnostic only and\n       uses the same read-as-bytes assumption present when the code passes\n       'msg' to snprintf with \"%s\". */\n    {\n      char tmp[257];\n      int j;\n      for (j = 0; j < 256; j++)\n      {\n        unsigned char c = msg[j];\n        tmp[j] = (char) c;\n        if (c == '\\0')\n          break;\n      }\n      tmp[256] = '\\0';\n      /* Cast to const char * to match format expectations. */\n      fprintf(f, \"msg as C-string (up to 256 bytes): %s\\n\", (const char *) tmp);\n    }\n\n    /* Note the use site: the pointer is an unsigned char * but is passed to\n       snprintf with \"%s\" in the original code. Record that fact for audit. */\n    fprintf(f, \"NOTE: variable 'msg' declared as 'unsigned char *' and used with '\\%%s' format.\\n\");\n  }\n  else\n  {\n    fprintf(f, \"msg: NULL\\n\");\n  }\n\n  fprintf(f, \"--- end probe: %s ---\\n\\n\", stage);\n  fclose(f);\n}\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  probe_usock_log(\"entry\", ws, NULL, 0, -1, -1, -1);\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    probe_usock_log(\"after_recv\", ws, NULL, got, -1, -1, -1);\n\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    probe_usock_log(\"after_ws_receive_frame\", ws, msg, got, type, -1, -1);\n\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n\n      /* Log just before computing the snprintf size using \"%s\" with\n         an unsigned char * to capture the violation scenario. */\n      probe_usock_log(\"before_snprintf_size\", ws, msg, got, type, -1, -1);\n\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n\n      probe_usock_log(\"after_snprintf_size\", ws, msg, got, type, buf_size, -1);\n\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n\n          probe_usock_log(\"after_ws_send_attempt\", ws, msg, got, type, buf_size, sent);\n\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n\n      probe_usock_log(\"after_free_msg_text_frame\", ws, NULL, got, type, buf_size, sent);\n\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        probe_usock_log(\"close_frame_before_free\", ws, msg, got, type, -1, -1);\n        free (msg);\n        probe_usock_log(\"close_frame_after_free\", ws, NULL, got, type, -1, -1);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n\n  probe_usock_log(\"cleanup_before_upgrade_action\", ws, NULL, 0, -1, -1, -1);\n\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n\n  probe_usock_log(\"exit\", ws, NULL, 0, -1, -1, -1);\n\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. While \u2018msg\u2019 is only read by run_usock (it is passed to snprintf and then freed), you cannot unilaterally make it a const-qualified pointer without other changes. The buffer is allocated by ws_receive_frame and later freed by free(msg); free has the prototype void free(void *), so making msg a const unsigned char * would either require casting away const when calling free (which would raise other MISRA concerns) or changing the ownership/consumer APIs. Thus it is not evidently \u201cpossible\u201d to qualify msg as const in the existing code as-is, so a violation of Rule 8.13 is not automatic.\n\nAlso note a separate concern: passing an unsigned char * to snprintf with \"%s\" is a type/semantic mismatch and should be fixed (use a char * or perform a proper conversion). If you want to satisfy Rule 8.13 safely the correct fix is to propagate const-correctness through the allocation/ownership/API (e.g. have ws_receive_frame return const char * for read-only views, or copy into a non-const buffer prior to freeing), rather than simply changing the local declaration and casting for free."
}