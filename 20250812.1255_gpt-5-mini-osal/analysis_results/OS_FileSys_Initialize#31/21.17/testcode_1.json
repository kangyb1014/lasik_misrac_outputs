{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe macro OS_CHECK_STRING(fsvolname, sizeof(filesys->volume_name), ...) expands to a LENGTHCHECK that likely uses strlen to determine the source string length. If the caller supplies fsvolname that is not NUL-terminated within its allocated bounds (or points to a buffer shorter than the characters stored), strlen(fsvolname) can read past the end of that object, violating Rule 21.17. Note: sizeof(filesys->volume_name) is computed at compile time and is not itself problematic, but the runtime strlen on an unterminated or undersized source buffer can cause out\u2011of\u2011bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileSys_Initialize code that contains useful probe functions that print useful logs to a file \"/tmp/logs/255.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileSys_Initialize as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileSys_Initialize:\n```c\nint32 OS_FileSys_Initialize(char *address, const char *fsdevname, const char *fsvolname, size_t blocksize,\n                            osal_blockcount_t numblocks, bool should_format)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n\n    /*\n     * Check parameters\n     *\n     * Note \"address\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_STRING(fsdevname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(fsvolname, sizeof(filesys->volume_name), OS_FS_ERR_PATH_TOO_LONG);\n\n    /* check names are not empty strings */\n    if (fsdevname[0] == 0 || fsvolname[0] == 0)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, fsdevname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, fsdevname);\n\n        /* populate the VolumeName and BlockSize ahead of the Impl call,\n         * so the implementation can reference this info if necessary */\n        filesys->blocksize = blocksize;\n        filesys->numblocks = numblocks;\n        filesys->address   = address;\n        strncpy(filesys->volume_name, fsvolname, sizeof(filesys->volume_name) - 1);\n\n        /*\n         * Determine basic type of filesystem, if not already known\n         *\n         * if either an address was supplied, or if the volume name\n         * contains the string \"RAM\" then it is a RAM disk. Otherwise\n         * leave the type as UNKNOWN and let the implementation decide.\n         */\n        if (filesys->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n            (filesys->address != NULL || strncmp(filesys->volume_name, OS_FILESYS_RAMDISK_VOLNAME_PREFIX,\n                                                 sizeof(OS_FILESYS_RAMDISK_VOLNAME_PREFIX) - 1) == 0))\n        {\n            filesys->fstype = OS_FILESYS_TYPE_VOLATILE_DISK;\n        }\n\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * The \"mkfs\" call also formats the device.\n             * this is the primary difference between mkfs and initfs.\n             */\n            if (should_format)\n            {\n                return_code = OS_FileSysFormatVolume_Impl(&token);\n            }\n\n            if (return_code == OS_SUCCESS)\n            {\n                filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            }\n            else\n            {\n                /*\n                 * To avoid leaving in an intermediate state,\n                 * this also stops the volume if formatting failed.\n                 * Cast to void to repress analysis warnings for\n                 * ignored return value.\n                 */\n                (void)OS_FileSysStopVolume_Impl(&token);\n            }\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileSys_Initialize code.\n",
  "test_code": "int32 OS_FileSys_Initialize(char *address, const char *fsdevname, const char *fsvolname, size_t blocksize,\n                            osal_blockcount_t numblocks, bool should_format)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n\n    /*\n     * Probe logging: record entry parameters and compile-time buffer sizes.\n     * This log is written before the OS_CHECK_STRING macros so that if those\n     * macros (e.g. via a strlen call) read out-of-bounds and crash, the\n     * pre-check information is preserved for diagnosis.\n     */\n    {\n        FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"ENTER OS_FileSys_Initialize\\n\");\n            fprintf(logf, \"  address=%p\\n\", (void *)address);\n            fprintf(logf, \"  fsdevname=%p\\n\", (const void *)fsdevname);\n            fprintf(logf, \"  fsvolname=%p\\n\", (const void *)fsvolname);\n            fprintf(logf, \"  blocksize=%zu\\n\", blocksize);\n            fprintf(logf, \"  numblocks=%llu\\n\", (unsigned long long)numblocks);\n            fprintf(logf, \"  should_format=%d\\n\", should_format ? 1 : 0);\n\n            /* Log the (compile-time) target buffer sizes used in checks. */\n            /* sizeof on an expression that is a pointer is not evaluated and is safe here. */\n            fprintf(logf, \"  sizeof(filesys->device_name) = %zu\\n\",\n                    sizeof(((OS_filesys_internal_record_t *)0)->device_name));\n            fprintf(logf, \"  sizeof(filesys->volume_name) = %zu\\n\",\n                    sizeof(((OS_filesys_internal_record_t *)0)->volume_name));\n\n            fflush(logf);\n            fclose(logf);\n        }\n    }\n\n    /*\n     * Check parameters\n     *\n     * Note \"address\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_STRING(fsdevname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(fsvolname, sizeof(filesys->volume_name), OS_FS_ERR_PATH_TOO_LONG);\n\n    /* Log that the pre-string checks completed (if execution reaches here). */\n    {\n        FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"After OS_CHECK_STRING macros - reached without apparent crash.\\n\");\n            fprintf(logf, \"  fsdevname=%p fsvolname=%p\\n\", (const void *)fsdevname, (const void *)fsvolname);\n            fflush(logf);\n            fclose(logf);\n        }\n    }\n\n    /* check names are not empty strings */\n    if (fsdevname[0] == 0 || fsvolname[0] == 0)\n    {\n        /* Log the empty-name condition. Reading the first byte here mirrors the\n         * original code's behaviour and should not introduce additional out-of-bounds\n         * accesses beyond what the original code already performs. */\n        FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Rejected: empty name detected\\n\");\n            fprintf(logf, \"  fsdevname[0]=0x%02x fsvolname[0]=0x%02x\\n\", (unsigned char)fsdevname[0], (unsigned char)fsvolname[0]);\n            fflush(logf);\n            fclose(logf);\n        }\n\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, fsdevname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, fsdevname);\n\n        /* populate the VolumeName and BlockSize ahead of the Impl call,\n         * so the implementation can reference this info if necessary */\n        filesys->blocksize = blocksize;\n        filesys->numblocks = numblocks;\n        filesys->address   = address;\n\n        /* Log state just before copying the volume name. */\n        {\n            FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"About to strncpy volume_name\\n\");\n                fprintf(logf, \"  dest=filesys->volume_name (size=%zu)\\n\",\n                        sizeof(((OS_filesys_internal_record_t *)0)->volume_name));\n                fprintf(logf, \"  src=%p\\n\", (const void *)fsvolname);\n                /* Log only the first character (as original code does) to avoid\n                 * performing more extensive reads that could introduce new errors. */\n                if (fsvolname != NULL)\n                {\n                    fprintf(logf, \"  src[0]=0x%02x\\n\", (unsigned char)fsvolname[0]);\n                }\n                fflush(logf);\n                fclose(logf);\n            }\n        }\n\n        strncpy(filesys->volume_name, fsvolname, sizeof(filesys->volume_name) - 1);\n\n        /* Log result after strncpy (note: strncpy does not necessarily NUL terminate if overflow). */\n        {\n            FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"After strncpy into filesys->volume_name\\n\");\n                /* Print the first few bytes of the destination buffer in hex up to a small limit\n                 * to avoid long outputs. This reads from the destination buffer which is owned by\n                 * the OS_filesys_table and should be safe. */\n                size_t i;\n                fprintf(logf, \"  volume_name[0..7]=\");\n                for (i = 0; i < 8 && i < sizeof(filesys->volume_name); ++i)\n                {\n                    fprintf(logf, \"%02x \", (unsigned char)filesys->volume_name[i]);\n                }\n                fprintf(logf, \"\\n\");\n                fflush(logf);\n                fclose(logf);\n            }\n        }\n\n        /*\n         * Determine basic type of filesystem, if not already known\n         *\n         * if either an address was supplied, or if the volume name\n         * contains the string \"RAM\" then it is a RAM disk. Otherwise\n         * leave the type as UNKNOWN and let the implementation decide.\n         */\n        if (filesys->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n            (filesys->address != NULL || strncmp(filesys->volume_name, OS_FILESYS_RAMDISK_VOLNAME_PREFIX,\n                                                 sizeof(OS_FILESYS_RAMDISK_VOLNAME_PREFIX) - 1) == 0))\n        {\n            filesys->fstype = OS_FILESYS_TYPE_VOLATILE_DISK;\n\n            /* Log that filesystem type was set to volatile. */\n            FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"Set filesys->fstype = OS_FILESYS_TYPE_VOLATILE_DISK (address=%p)\\n\", (void *)filesys->address);\n                fflush(logf);\n                fclose(logf);\n            }\n        }\n\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * The \"mkfs\" call also formats the device.\n             * this is the primary difference between mkfs and initfs.\n             */\n            if (should_format)\n            {\n                return_code = OS_FileSysFormatVolume_Impl(&token);\n            }\n\n            if (return_code == OS_SUCCESS)\n            {\n                filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            }\n            else\n            {\n                /*\n                 * To avoid leaving in an intermediate state,\n                 * this also stops the volume if formatting failed.\n                 * Cast to void to repress analysis warnings for\n                 * ignored return value.\n                 */\n                (void)OS_FileSysStopVolume_Impl(&token);\n            }\n        }\n\n        /* Log final return_code from the Impl calls prior to finalization. */\n        {\n            FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"Before OS_ObjectIdFinalizeNew: return_code=%ld\\n\", (long)return_code);\n                fflush(logf);\n                fclose(logf);\n            }\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, NULL);\n    }\n\n    /* Final log of overall return value */\n    {\n        FILE *logf = fopen(\"/tmp/logs/255.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"EXIT OS_FileSys_Initialize return %ld\\n\", (long)return_code);\n            fflush(logf);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n"
}