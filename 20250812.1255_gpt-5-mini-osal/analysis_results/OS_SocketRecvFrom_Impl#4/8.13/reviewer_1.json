{
  "user_message": "An agent A claimed that the following OS_SocketRecvFrom_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketRecvFrom_Impl.\n```c\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n        }\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    return_code = OS_QUEUE_EMPTY;\n                }\n                else\n                {\n                    OS_DEBUG(\"recvfrom: %s\\n\", strerror(errno));\n                    return_code = OS_ERROR;\n                }\n            }\n            else\n            {\n                return_code = os_result;\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                }\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'impl' is declared as a mutable pointer: 'OS_impl_file_internal_record_t *impl;'. Within OS_SocketRecvFrom_Impl the code only reads impl->selectable and impl->fd and never modifies the object pointed to. Therefore the pointer could and should be declared as 'const OS_impl_file_internal_record_t *impl' to indicate non\u2011modification and satisfy MISRA C 2023 Rule 8.13. (Note: OS_OBJECT_TABLE_GET returns a non\u2011const pointer, but assigning that to a const pointer is allowed.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/35.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /* Log entry state */\n    probe_log(\"OS_SocketRecvFrom_Impl ENTRY: token_ptr=%p, buffer=%p, buflen=%zu, RemoteAddr=%p, timeout=%d, impl_ptr=%p\",\n              (void *)token, buffer, buflen, (void *)RemoteAddr, (int)timeout, (void *)impl);\n\n    if (impl != NULL)\n    {\n        probe_log(\"impl state: selectable=%d, fd=%d\", (int)impl->selectable, (int)impl->fd);\n    }\n    else\n    {\n        probe_log(\"impl is NULL\");\n    }\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n        probe_log(\"RemoteAddr == NULL: sa=%p, addrlen=%lu\", (void *)sa, (unsigned long)addrlen);\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n        probe_log(\"RemoteAddr != NULL: sa=%p, addrlen(initial)=%lu, RemoteAddr_ptr=%p\", (void *)sa, (unsigned long)addrlen, (void *)RemoteAddr);\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    probe_log(\"operation set to OS_STREAM_STATE_READABLE (0x%08x)\", (unsigned)operation);\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl != NULL && impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        probe_log(\"impl->selectable == true: using select path, waitflags=0x%08x\", waitflags);\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n        probe_log(\"after OS_SelectSingle_Impl: return_code=%d, operation=0x%08x\", (int)return_code, (unsigned)operation);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n            probe_log(\"non-select path & timeout==0: waitflags=0x%08x\", waitflags);\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n            probe_log(\"non-select path & timeout>0: waitflags=0x%08x\", waitflags);\n        }\n        return_code = OS_SUCCESS;\n        probe_log(\"non-select path: return_code set to OS_SUCCESS\");\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"proceeding to check operation mask: operation=0x%08x\", (unsigned)operation);\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n            probe_log(\"operation not readable -> timeout: return_code=%d\", (int)return_code);\n        }\n        else\n        {\n            probe_log(\"operation readable: calling recvfrom(fd=%d, buffer=%p, buflen=%zu, waitflags=0x%08x, sa=%p, addrlen_ptr=%p)\",\n                      (int)(impl ? impl->fd : -1), buffer, buflen, (unsigned)waitflags, (void *)sa, (void *)&addrlen);\n\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n            probe_log(\"recvfrom returned os_result=%d, errno=%d (%s), addrlen(after)=%lu\", os_result, errno,\n                      strerror(errno), (unsigned long)addrlen);\n\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    return_code = OS_QUEUE_EMPTY;\n                    probe_log(\"recvfrom signaled EAGAIN/EWOULDBLOCK -> return_code=OS_QUEUE_EMPTY\");\n                }\n                else\n                {\n                    OS_DEBUG(\"recvfrom: %s\\n\", strerror(errno));\n                    return_code = OS_ERROR;\n                    probe_log(\"recvfrom error -> return_code=OS_ERROR\");\n                }\n            }\n            else\n            {\n                return_code = os_result;\n                probe_log(\"recvfrom success -> return_code=%d, bytes_received=%d\", (int)return_code, os_result);\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                    probe_log(\"RemoteAddr updated: ActualLength=%lu\", (unsigned long)RemoteAddr->ActualLength);\n                }\n            }\n        }\n    }\n\n    probe_log(\"OS_SocketRecvFrom_Impl EXIT: return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketRecvFrom_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_SocketRecvFrom_Impl the local pointer impl is only used to read fields (impl->selectable and impl->fd) and the function never modifies the object pointed to. Under MISRA C:2023 Rule 8.13 (\u201cA pointer should point to a const\u2011qualified type whenever possible\u201d) the pointer should be declared to point to const data (e.g. const OS_impl_file_internal_record_t *impl) to reflect that the function does not modify the pointee. Assigning the non\u2011const result of OS_OBJECT_TABLE_GET to a const pointer is allowed in C (no cast required), so making this change is feasible. The provided probe/test code compiling and not logging any activity does not invalidate the analysis of the source\u2011level issue. Therefore the agent A report is correct."
}