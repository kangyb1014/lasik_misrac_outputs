{
  "user_message": "An agent A claimed that the following OS_SymbolLookup_Static code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SymbolLookup_Static.\n```c\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n            return_code = OS_ERROR;\n            break;\n        }\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If a table entry has StaticSym->Module == NULL but the caller supplies a non-NULL ModuleName, the expression strcmp(StaticSym->Module, ModuleName) will be evaluated. This passes a NULL pointer as the first argument to strcmp, causing an access beyond the bounds of the referenced object (undefined behavior). Therefore the use of strcmp here can violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uintptr_t cpuaddr;\nstruct OS_static_symbol_record\n{\n    const char *Name;\n    const char *Module;\n    uintptr_t   Address;\n};\ntypedef struct OS_static_symbol_record\n{\n    const char *Name;\n    const char *Module;\n    uintptr_t   Address;\n} OS_static_symbol_record_t;\nstatic OS_static_symbol_record_t _static_sym_table[] = {\n    { \"foo\", \"modA\", (uintptr_t)0x1234 },\n    { \"bar\", NULL,   (uintptr_t)0x5678 },\n    { NULL,  NULL,    0 }\n};\nOS_static_symbol_record_t *OS_STATIC_SYMTABLE_SOURCE = _static_sym_table;\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    /* Initial call log */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static called: SymbolName=%p ModuleName=%p\\n\",\n                    (const void *)SymbolName, (const void *)ModuleName);\n            if (SymbolName != NULL)\n            {\n                fprintf(logf, \"  SymbolName string: '%s'\\n\", SymbolName);\n            }\n            fclose(logf);\n        }\n    }\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n\n            /* Log end-of-list condition */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Reached end of static symbol table (Name == NULL).\\n\");\n                    fclose(logf);\n                }\n            }\n\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /* Log current table entry state before any comparisons. Do not dereference\n         * StaticSym->Module if it is NULL. This logging is intentionally done\n         * before the strcmp calls so that the state that leads to the violation\n         * can be observed in the log. */\n        {\n            FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n            if (logf != NULL)\n            {\n                /* Log pointers and address value in a portable way */\n                fprintf(logf, \"Checking entry: Name_ptr=%p Module_ptr=%p Address_val=0x%\" PRIxPTR \"\\n\",\n                        (const void *)StaticSym->Name,\n                        (const void *)StaticSym->Module,\n                        (uintptr_t)StaticSym->Address);\n\n                /* Safe string prints: only print strings when non-NULL */\n                if (StaticSym->Name != NULL)\n                {\n                    fprintf(logf, \"  Name string: '%s'\\n\", StaticSym->Name);\n                }\n                if (StaticSym->Module != NULL)\n                {\n                    fprintf(logf, \"  Module string: '%s'\\n\", StaticSym->Module);\n                }\n                else\n                {\n                    fprintf(logf, \"  Module string: (null)\\n\");\n                }\n\n                if (ModuleName != NULL)\n                {\n                    fprintf(logf, \"  Caller ModuleName: '%s'\\n\", ModuleName);\n                }\n                else\n                {\n                    fprintf(logf, \"  Caller ModuleName: (null)\\n\");\n                }\n\n                fclose(logf);\n            }\n        }\n\n        /* Original comparison logic preserved. The logging above ensures that\n         * if StaticSym->Module is NULL while ModuleName is non-NULL, this fact\n         * will be recorded just prior to the strcmp call that reproduces the\n         * reported violation scenario. */\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n\n            /* Log success with resolved address */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n                            (StaticSym->Name != NULL) ? StaticSym->Name : \"(null)\",\n                            (const void *)StaticSym->Module,\n                            (uintptr_t)StaticSym->Address);\n                    fclose(logf);\n                }\n            }\n\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    /* Log return code */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static returning code %d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the original code the expression\n\n    (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0)\n\nrelies on short\u2011circuiting of || to avoid calling strcmp when ModuleName is NULL. However, if ModuleName is non\u2011NULL and StaticSym->Module is NULL, the right side is evaluated and strcmp is invoked with a NULL pointer as its first argument. That is undefined behavior (strcmp will dereference its pointer parameter) and therefore violates MISRA C 2023 Rule 21.17. \n\nAdditionally, the code also calls strcmp(StaticSym->Name, SymbolName) without checking SymbolName for NULL; a caller supplying SymbolName == NULL would likewise cause a strcmp with a NULL argument (another violation). \n\n(The provided test harness failed to compile due to a duplicate/redefinition of the struct/typedef in the test code, but that does not affect the correctness of the reported MISRA violation.)"
}