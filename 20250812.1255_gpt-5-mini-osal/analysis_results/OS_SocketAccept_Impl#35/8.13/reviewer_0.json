{
  "user_message": "An agent A claimed that the following OS_SocketAccept_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAccept_Impl.\n```c\nint32 OS_SocketAccept_Impl(const OS_object_token_t *sock_token, const OS_object_token_t *conn_token,\n                           OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    uint32                          operation;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *sock_impl;\n    OS_impl_file_internal_record_t *conn_impl;\n\n    sock_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *sock_token);\n    conn_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *conn_token);\n\n    operation = OS_STREAM_STATE_READABLE;\n    if (sock_impl->selectable)\n    {\n        return_code = OS_SelectSingle_Impl(sock_token, &operation, timeout);\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            addrlen       = Addr->ActualLength;\n            conn_impl->fd = accept(sock_impl->fd, (struct sockaddr *)&Addr->AddrData, &addrlen);\n            if (conn_impl->fd < 0)\n            {\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                Addr->ActualLength = addrlen;\n\n                OS_IMPL_SET_SOCKET_FLAGS(conn_token);\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro takes the address of the macro parameter (&(tok)). In OS_SocketAccept_Impl a const OS_object_token_t *sock_token is dereferenced and passed to the macro as *sock_token. That yields the address of a const-qualified object (const OS_object_token_t *), which is then passed to OS_ObjectIndexFromToken. If OS_ObjectIndexFromToken (or the macro expansion) expects a non-const pointer, the const qualifier is effectively discarded. This forces passing a non-const pointer where a const-qualified pointer would be appropriate and thus violates the intent of MISRA C 2023 Rule 8.13. Suggested fixes: change OS_ObjectIndexFromToken to accept a const OS_object_token_t * or change the macro/signature to preserve const-correctness.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/283.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_SocketAccept_Impl(const OS_object_token_t *sock_token, const OS_object_token_t *conn_token,\n                           OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    uint32                          operation;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *sock_impl;\n    OS_impl_file_internal_record_t *conn_impl;\n\n    /* Log entry and input pointers (do not dereference tokens here to avoid UB) */\n    os_log_probe(\"ENTER: OS_SocketAccept_Impl: sock_token=%p, conn_token=%p, Addr=%p, timeout=%d\",\n                 (void *)sock_token, (void *)conn_token, (void *)Addr, (int)timeout);\n\n    /* Log that the token is const-qualified and that the macro will be invoked with *sock_token / *conn_token */\n    os_log_probe(\"NOTE: Calling OS_OBJECT_TABLE_GET with *sock_token (address of const-qualified object)\");\n\n    sock_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *sock_token);\n    conn_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *conn_token);\n\n    os_log_probe(\"LOOKUP: sock_impl=%p, conn_impl=%p\", (void *)sock_impl, (void *)conn_impl);\n\n    if (sock_impl != NULL)\n    {\n        /* Log selected fields from sock_impl if available */\n        os_log_probe(\"SOCK_IMPL: selectable=%d, fd=%d\", (int)sock_impl->selectable, (int)sock_impl->fd);\n    }\n    else\n    {\n        os_log_probe(\"SOCK_IMPL: NULL returned from lookup\");\n    }\n\n    if (conn_impl != NULL)\n    {\n        os_log_probe(\"CONN_IMPL before accept: fd=%d\", (int)conn_impl->fd);\n    }\n    else\n    {\n        os_log_probe(\"CONN_IMPL: NULL returned from lookup\");\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    if (sock_impl->selectable)\n    {\n        os_log_probe(\"ACTION: sock is selectable -> calling OS_SelectSingle_Impl (operation initial=0x%08\" PRIx32 \")\",\n                     operation);\n\n        return_code = OS_SelectSingle_Impl(sock_token, &operation, timeout);\n\n        os_log_probe(\"SELECT_RETURN: return_code=%d, operation=0x%08\" PRIx32 \"\",\n                     (int)return_code, operation);\n    }\n    else\n    {\n        os_log_probe(\"ACTION: sock is NOT selectable -> skipping select\");\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            os_log_probe(\"TIMEOUT: operation not readable (operation=0x%08\" PRIx32 \") -> returning OS_ERROR_TIMEOUT\",\n                         operation);\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            /* Preserve original behavior: capture Addr length, perform accept, and update records. */\n            addrlen = Addr->ActualLength;\n            os_log_probe(\"BEFORE_ACCEPT: sock_fd=%d, addrlen=%lu, Addr->ActualLength=%lu\",\n                         (sock_impl ? (int)sock_impl->fd : -1), (unsigned long)addrlen,\n                         (unsigned long)Addr->ActualLength);\n\n            conn_impl->fd = accept(sock_impl->fd, (struct sockaddr *)&Addr->AddrData, &addrlen);\n\n            os_log_probe(\"AFTER_ACCEPT: accept returned fd=%d, addrlen=%lu\",\n                         (int)conn_impl->fd, (unsigned long)addrlen);\n\n            if (conn_impl->fd < 0)\n            {\n                os_log_probe(\"ACCEPT_ERROR: conn_impl->fd < 0 -> setting return_code=OS_ERROR\");\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                Addr->ActualLength = addrlen;\n\n                os_log_probe(\"ACCEPT_SUCCESS: updated Addr->ActualLength=%lu, calling OS_IMPL_SET_SOCKET_FLAGS with conn_token=%p\",\n                             (unsigned long)Addr->ActualLength, (void *)conn_token);\n\n                OS_IMPL_SET_SOCKET_FLAGS(conn_token);\n\n                os_log_probe(\"POST_FLAGS: completed OS_IMPL_SET_SOCKET_FLAGS for conn_token=%p\", (void *)conn_token);\n            }\n        }\n    }\n\n    os_log_probe(\"EXIT: OS_SocketAccept_Impl returning %d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. The function OS_SocketAccept_Impl itself declares its token parameters as const OS_object_token_t * and does not remove the const qualifier. Taking *sock_token yields an lvalue of type const OS_object_token_t and &(*sock_token) (what the macro expands to) has type const OS_object_token_t *. If a compile error or qualifier discard occurs, that indicates the macro or the callee it invokes (e.g. OS_ObjectIndexFromToken) is declared to take a non-const pointer, which is the actual place where const-correctness is violated. MISRA C 2023 Rule 8.13 (\u201ca pointer should point to a const-qualified type whenever possible\u201d) would be infringed by that macro/callee signature, not by OS_SocketAccept_Impl which already uses const-qualified pointer parameters. The correct fixes are to make the macro/callee accept a const OS_object_token_t * (or otherwise preserve const-correctness), or to explicitly copy the token into a non-const object if mutation is required."
}