{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. The call strcmp(stream->stream_name, Filename) can read past the bounds of either operand if they are not null-terminated. The definition OS_stream_internal_record_t::stream_name is a fixed array (char[OS_MAX_PATH_LEN]) but OS_FileOpenCheck does not guarantee it is terminated; if stream_name was filled (for example) via strncpy without writing a '\\0' or contains exactly OS_MAX_PATH_LEN non-zero chars, strcmp will scan past the array and access out-of-bounds. Similarly, if the caller passes a Filename buffer that is not null-terminated, strcmp can read past Filename. Example: OS_MAX_PATH_LEN==32 and stream_name contains 32 non-\"\\0\" bytes \u2014 strcmp will read beyond stream_name into adjacent memory, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int int32;\nstatic const int OS_MAX_PATH_LEN = 256;\nstatic const int OS_SocketDomain_INVALID = 0;\nstatic const int32 OS_SUCCESS = 0;\nstatic const int32 OS_ERROR = -1;\nstatic const size_t OS_STREAM_TABLE_SIZE = 4;\ntypedef struct\n{\n    unsigned long token; /* token value used for identification */\n} OS_object_iter_t;\ntypedef struct\n{\n    char stream_name[256];\n    int socket_domain;\n} OS_stream_internal_record_t;\nstatic void OS_FileOpenCheck_LogProbe(const OS_stream_internal_record_t *stream, const char *Filename, unsigned long token, const char *stage)\n{\n    FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_FileOpenCheck] stage=%s token=%lu stream_ptr=%p Filename_ptr=%p socket_domain=%d\\n\",\n            stage, token, (const void *)stream, (const void *)Filename, (int)stream->socket_domain);\n\n    /* Check for NUL within the fixed-size stream_name buffer without reading past it */\n    void *nulpos = memchr(stream->stream_name, '\\0', (size_t)OS_MAX_PATH_LEN);\n    if (nulpos != NULL)\n    {\n        size_t len = (const char *)nulpos - stream->stream_name;\n        fprintf(f, \"stream_name: NUL found within bound at len=%zu\\n\", len);\n    }\n    else\n    {\n        fprintf(f, \"stream_name: NO NUL found within OS_MAX_PATH_LEN=%d\\n\", OS_MAX_PATH_LEN);\n    }\n\n    /* Dump the raw bytes of stream_name (bounded) as hex so agents can see exact contents even if not NUL-terminated */\n    fprintf(f, \"stream_name bytes:\");\n    for (int i = 0; i < OS_MAX_PATH_LEN; ++i)\n    {\n        fprintf(f, \" %02X\", (unsigned char)stream->stream_name[i]);\n    }\n    fprintf(f, \"\\n\\n\");\n\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32 return_code;\n\n    /* Check parameters (explicit check instead of relying on a macro) */\n    if (Filename == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return_code = OS_ERROR;\n\n    /* Iterate the stream table directly (keeps original logic of checking each active stream) */\n    for (unsigned long idx = 0; idx < OS_STREAM_TABLE_SIZE; ++idx)\n    {\n        OS_stream_internal_record_t *stream = &OS_stream_table[idx];\n\n        /* Log the state before performing the strcmp (do NOT read Filename contents) */\n        OS_FileOpenCheck_LogProbe(stream, Filename, (unsigned long)idx, \"before_cmp\");\n\n        /* Preserve original logic as much as possible but compute strcmp result separately so we can log it. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            int cmp_result = strcmp(stream->stream_name, Filename);\n\n            /* Log the comparison result after the call. If strcmp itself triggers an out-of-bounds access,\n             * the program may crash here; the prior log entry will still exist and can be used as evidence.\n             */\n            {\n                FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (f != NULL)\n                {\n                    fprintf(f, \"[OS_FileOpenCheck] after_cmp token=%lu stream_ptr=%p Filename_ptr=%p cmp_result=%d\\n\\n\",\n                            (unsigned long)idx, (const void *)stream, (const void *)Filename, cmp_result);\n                    fclose(f);\n                }\n            }\n\n            if (cmp_result == 0)\n            {\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strcmp reads both operands until a NUL byte is found; if either operand is not NUL-terminated within the bounds of its object, strcmp will read past the object boundary and thus violate MISRA C 2023 Rule 21.17. In the posted code stream->stream_name is a fixed-size char array (char[OS_MAX_PATH_LEN]) but OS_FileOpenCheck does not guarantee it contains a terminating '\\0' (it may have been written by strncpy or otherwise filled with exactly OS_MAX_PATH_LEN non-zero bytes). Similarly, Filename is caller-supplied and only checked for non-NULL, not for termination. Therefore the call strcmp(stream->stream_name, Filename) can legitimately cause out-of-bounds reads and is a violation of Rule 21.17. Recommended fixes include: ensure stream_name is always NUL-terminated when written, or use a comparison that bounds reads (e.g. compare lengths first and/or use a bounded comparison with an explicit maximum that is no larger than the object sizes and ensure the other operand is also bounded), or maintain and use explicit stored lengths and compare with memcmp. "
}