{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 potential out-of-bounds read when strcmp is used on stream_name. The array stream_name has size OS_MAX_PATH_LEN but there is no guarantee it is NUL-terminated. For example, if the filename stored into stream_name was copied with strncpy(stream_name, src, OS_MAX_PATH_LEN) (or memcpy), and src length >= OS_MAX_PATH_LEN, stream_name will not contain a terminating '\\0'. Later strcmp(stream->stream_name, Filename) will keep reading past the end of stream_name looking for a NUL, causing an access beyond the bounds. Therefore Rule 21.17 can be violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_stream_state(const OS_stream_internal_record_t *stream, const char *Filename)\n{\n    FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Do not affect program flow if logging fails */\n    }\n\n    fprintf(f, \"---- OS_FileOpenCheck probe ----\\n\");\n    fprintf(f, \"stream pointer: %p\\n\", (const void *)stream);\n    if (stream == NULL)\n    {\n        fprintf(f, \"stream is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    /* Log socket domain value */\n    fprintf(f, \"socket_domain: %d\\n\", (int)stream->socket_domain);\n\n    /* Log Filename pointer and a safe representation */\n    fprintf(f, \"Filename pointer: %p\\n\", (const void *)Filename);\n    if (Filename != NULL)\n    {\n        /* Print small, safe summary of Filename */\n        fprintf(f, \"Filename (escaped): \\\"\");\n        for (const char *p = Filename; *p != '\\0' && (size_t)(p - Filename) < 128; ++p)\n        {\n            unsigned char c = (unsigned char)*p;\n            if (isprint(c) && c != '\"' && c != '\\\\')\n                fputc(c, f);\n            else\n                fprintf(f, \"\\\\x%02x\", c);\n        }\n        if (Filename[0] != '\\0' && strlen(Filename) >= 128)\n            fprintf(f, \"... (truncated)\");\n        fprintf(f, \"\\\"\\n\");\n    }\n\n#ifdef OS_MAX_PATH_LEN\n    {\n        /* We know the buffer size; it is therefore safe to inspect up to OS_MAX_PATH_LEN bytes. */\n        size_t max_len = (size_t)OS_MAX_PATH_LEN;\n        size_t i;\n        const char *name = stream->stream_name;\n        int nul_found = 0;\n\n        /* Search for NUL within the array bounds */\n        for (i = 0; i < max_len; ++i)\n        {\n            if (name[i] == '\\0')\n            {\n                nul_found = 1;\n                break;\n            }\n        }\n\n        fprintf(f, \"OS_MAX_PATH_LEN: %zu\\n\", max_len);\n        fprintf(f, \"stream_name NUL found within bounds: %s\\n\", nul_found ? \"yes\" : \"no\");\n\n        /* Print a safe, escaped representation of stream_name up to the first NUL or max_len */\n        fprintf(f, \"stream_name (escaped, up to %zu bytes): \\\"\", max_len);\n        for (i = 0; i < max_len; ++i)\n        {\n            unsigned char c = (unsigned char)name[i];\n            if (c == '\\0')\n                break;\n            if (isprint(c) && c != '\"' && c != '\\\\')\n                fputc(c, f);\n            else\n                fprintf(f, \"\\\\x%02x\", c);\n        }\n        if (!nul_found)\n            fprintf(f, \"\\\" ... [no NUL within %zu bytes]\\n\", max_len);\n        else\n            fprintf(f, \"\\\"\\n\");\n    }\n#else\n    /* If OS_MAX_PATH_LEN is not available we MUST NOT attempt to read the stream_name contents\n       as that could itself read out-of-bounds. Log that we could not safely inspect the buffer. */\n    fprintf(f, \"OS_MAX_PATH_LEN not defined: cannot safely inspect stream_name contents.\\n\");\n#endif\n\n    fprintf(f, \"---- end probe ----\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Preserve original logic: only evaluate strcmp if socket_domain matches. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            /* Insert probe here to capture the state just before the strcmp that may read past bounds. */\n            probe_log_stream_state(stream, Filename);\n\n            if (strcmp(stream->stream_name, Filename) == 0)\n            {\n                /* Log the match event as well for traceability */\n                FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (f != NULL)\n                {\n                    fprintf(f, \"Match found: stream=%p, Filename=%p -> returning OS_SUCCESS\\n\", (void *)stream, (const void *)Filename);\n                    fclose(f);\n                }\n\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Summary: The report is correct. Reasoning: MISRA C 2023 Rule 21.17 requires that uses of string.h functions (e.g. strcmp) must not cause accesses beyond the bounds of the referenced objects. In the shown OS_FileOpenCheck the code calls strcmp(stream->stream_name, Filename). The function checks that Filename is non-NULL but does not guarantee that stream->stream_name is NUL-terminated. If stream_name is a fixed-size buffer (OS_MAX_PATH_LEN) and prior code populated it with strncpy(..., OS_MAX_PATH_LEN) or memcpy of OS_MAX_PATH_LEN bytes (or otherwise failed to write a terminating '\\0'), then stream_name may have no terminating NUL and strcmp will read past the end of the buffer searching for one \u2014 causing an out-of-bounds read and therefore a breach of Rule 21.17.\n\nThis is a potential (and real) violation unless there is a proven global invariant elsewhere in the codebase that stream->stream_name is always NUL-terminated. The provided test probe not producing output does not refute the issue \u2014 it only shows the probe may not have been exercised.\n\nRecommended fixes: ensure stream_name is always NUL-terminated on every write (e.g. explicitly set the last byte to '\\0'), or avoid unbounded string operations by using a bounded comparison such as strncmp(stream->stream_name, Filename, OS_MAX_PATH_LEN) combined with a check for equal lengths, or detect NUL within the buffer before calling strcmp.\n"
}