{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 potential out-of-bounds read when strcmp is used on stream_name. The array stream_name has size OS_MAX_PATH_LEN but there is no guarantee it is NUL-terminated. For example, if the filename stored into stream_name was copied with strncpy(stream_name, src, OS_MAX_PATH_LEN) (or memcpy), and src length >= OS_MAX_PATH_LEN, stream_name will not contain a terminating '\\0'. Later strcmp(stream->stream_name, Filename) will keep reading past the end of stream_name looking for a NUL, causing an access beyond the bounds. Therefore Rule 21.17 can be violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileOpenCheck code that contains useful probe functions that print useful logs to a file \"/tmp/logs/191.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileOpenCheck as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileOpenCheck:\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileOpenCheck code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <ctype.h>\n\n/* Probe helper: logs relevant state to /tmp/logs/191.txt. */\nstatic void probe_log_stream_state(const OS_stream_internal_record_t *stream, const char *Filename)\n{\n    FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Do not affect program flow if logging fails */\n    }\n\n    fprintf(f, \"---- OS_FileOpenCheck probe ----\\n\");\n    fprintf(f, \"stream pointer: %p\\n\", (const void *)stream);\n    if (stream == NULL)\n    {\n        fprintf(f, \"stream is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    /* Log socket domain value */\n    fprintf(f, \"socket_domain: %d\\n\", (int)stream->socket_domain);\n\n    /* Log Filename pointer and a safe representation */\n    fprintf(f, \"Filename pointer: %p\\n\", (const void *)Filename);\n    if (Filename != NULL)\n    {\n        /* Print small, safe summary of Filename */\n        fprintf(f, \"Filename (escaped): \\\"\");\n        for (const char *p = Filename; *p != '\\0' && (size_t)(p - Filename) < 128; ++p)\n        {\n            unsigned char c = (unsigned char)*p;\n            if (isprint(c) && c != '\"' && c != '\\\\')\n                fputc(c, f);\n            else\n                fprintf(f, \"\\\\x%02x\", c);\n        }\n        if (Filename[0] != '\\0' && strlen(Filename) >= 128)\n            fprintf(f, \"... (truncated)\");\n        fprintf(f, \"\\\"\\n\");\n    }\n\n#ifdef OS_MAX_PATH_LEN\n    {\n        /* We know the buffer size; it is therefore safe to inspect up to OS_MAX_PATH_LEN bytes. */\n        size_t max_len = (size_t)OS_MAX_PATH_LEN;\n        size_t i;\n        const char *name = stream->stream_name;\n        int nul_found = 0;\n\n        /* Search for NUL within the array bounds */\n        for (i = 0; i < max_len; ++i)\n        {\n            if (name[i] == '\\0')\n            {\n                nul_found = 1;\n                break;\n            }\n        }\n\n        fprintf(f, \"OS_MAX_PATH_LEN: %zu\\n\", max_len);\n        fprintf(f, \"stream_name NUL found within bounds: %s\\n\", nul_found ? \"yes\" : \"no\");\n\n        /* Print a safe, escaped representation of stream_name up to the first NUL or max_len */\n        fprintf(f, \"stream_name (escaped, up to %zu bytes): \\\"\", max_len);\n        for (i = 0; i < max_len; ++i)\n        {\n            unsigned char c = (unsigned char)name[i];\n            if (c == '\\0')\n                break;\n            if (isprint(c) && c != '\"' && c != '\\\\')\n                fputc(c, f);\n            else\n                fprintf(f, \"\\\\x%02x\", c);\n        }\n        if (!nul_found)\n            fprintf(f, \"\\\" ... [no NUL within %zu bytes]\\n\", max_len);\n        else\n            fprintf(f, \"\\\"\\n\");\n    }\n#else\n    /* If OS_MAX_PATH_LEN is not available we MUST NOT attempt to read the stream_name contents\n       as that could itself read out-of-bounds. Log that we could not safely inspect the buffer. */\n    fprintf(f, \"OS_MAX_PATH_LEN not defined: cannot safely inspect stream_name contents.\\n\");\n#endif\n\n    fprintf(f, \"---- end probe ----\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Preserve original logic: only evaluate strcmp if socket_domain matches. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            /* Insert probe here to capture the state just before the strcmp that may read past bounds. */\n            probe_log_stream_state(stream, Filename);\n\n            if (strcmp(stream->stream_name, Filename) == 0)\n            {\n                /* Log the match event as well for traceability */\n                FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (f != NULL)\n                {\n                    fprintf(f, \"Match found: stream=%p, Filename=%p -> returning OS_SUCCESS\\n\", (void *)stream, (const void *)Filename);\n                    fclose(f);\n                }\n\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n"
}