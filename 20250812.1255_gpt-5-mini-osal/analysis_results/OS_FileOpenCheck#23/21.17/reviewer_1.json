{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro only checks that Filename is non-NULL; it does not ensure Filename points to a NUL-terminated character array or that the object is large enough for strcmp to read. For example, if a caller passes a pointer to a non-NUL-terminated buffer (e.g. char buf[4] = {'a','b','c','d'}; OS_FileOpenCheck(buf);) or a pointer into a smaller object without a terminating '\\0', the subsequent strcmp(stream->stream_name, Filename) can read past the bounds of the object referenced by Filename, causing an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be performed, silently continue to preserve program behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Log entry and parameter state */\n    probe_log(\"OS_FileOpenCheck ENTER: Filename=%p\", (const void *)Filename);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log iterator and stream metadata (do not dereference string pointers) */\n        /* Print the token as a pointer to avoid treating an aggregate as an integer */\n        probe_log(\"ITER: token=%p, stream_ptr=%p, stream_name_ptr=%p, socket_domain=%d\",\n                  (const void *)&iter.token,\n                  (const void *)stream,\n                  (const void *)(stream ? stream->stream_name : NULL),\n                  (int)(stream ? stream->socket_domain : -1));\n\n        /* Log that we are about to compare names. This log is critical: if the program\n         * crashes inside strcmp due to Filename not being NUL-terminated or pointing\n         * past its object's bounds, the last log will show the parameters used for the call. */\n        probe_log(\"ABOUT_TO_STRCMP: stream_name=%p, Filename=%p\",\n                  (const void *)(stream ? stream->stream_name : NULL),\n                  (const void *)Filename);\n\n        /* Preserve original logic: perform the strcmp and record its result. */\n        {\n            int cmp_result = 0;\n\n            /* Perform the compare as in the original code. If this call reads out-of-bounds\n             * it may crash; the logs above will help reproduce and diagnose the scenario. */\n            if (stream != NULL)\n            {\n                cmp_result = strcmp(stream->stream_name, Filename);\n                probe_log(\"STRCMP_RESULT: %d (stream_name=%p, Filename=%p)\",\n                          cmp_result,\n                          (const void *)stream->stream_name,\n                          (const void *)Filename);\n            }\n            else\n            {\n                probe_log(\"STRCMP_SKIPPED: stream is NULL\");\n            }\n\n            /* Ensure we don't dereference stream when it's NULL */\n            if (stream != NULL && stream->socket_domain == OS_SocketDomain_INVALID && (cmp_result == 0))\n            {\n                probe_log(\"MATCH_FOUND: token=%p, stream_name=%p\", (const void *)&iter.token, (const void *)stream->stream_name);\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    probe_log(\"OS_FileOpenCheck EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls strcmp(stream->stream_name, Filename) after only checking Filename for non-NULL. strcmp requires both arguments to be pointers to NUL-terminated character arrays; if a caller passes a non-NUL-terminated buffer or a pointer into a smaller object without a terminating '\\0', strcmp may read past the bounds of the object referenced by Filename, producing an out-of-bounds access. That is exactly what MISRA C 2023 Rule 21.17 forbids. (Note: whether this is a practical fault at run-time depends on the API contract \u2014 if the function\u2019s documented precondition requires a NUL-terminated string, then the caller is at fault \u2014 but MISRA requires that uses of string.h functions be written so they cannot result in out-of-bounds accesses; the code as shown does not enforce or otherwise guarantee that precondition.) Recommended fixes include validating/copying the input to ensure a NUL terminator, using a bounded comparison (e.g. strncmp with a known maximum length tied to stream->stream_name capacity), or otherwise documenting and statically enforcing the NUL-terminated-string precondition."
}