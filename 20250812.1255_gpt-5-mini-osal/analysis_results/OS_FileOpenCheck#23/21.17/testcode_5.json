{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call strcmp(stream->stream_name, Filename) can read past the bounds of either operand if they are not null-terminated. The definition OS_stream_internal_record_t::stream_name is a fixed array (char[OS_MAX_PATH_LEN]) but OS_FileOpenCheck does not guarantee it is terminated; if stream_name was filled (for example) via strncpy without writing a '\\0' or contains exactly OS_MAX_PATH_LEN non-zero chars, strcmp will scan past the array and access out-of-bounds. Similarly, if the caller passes a Filename buffer that is not null-terminated, strcmp can read past Filename. Example: OS_MAX_PATH_LEN==32 and stream_name contains 32 non-\"\\0\" bytes \u2014 strcmp will read beyond stream_name into adjacent memory, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileOpenCheck code that contains useful probe functions that print useful logs to a file \"/tmp/logs/191.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileOpenCheck as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileOpenCheck:\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileOpenCheck code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe helper: log safe, bounded information about the stream record and the Filename pointer.\n * This function intentionally does NOT attempt to read the contents of Filename (unknown size)\n * to avoid introducing additional out-of-bounds reads. It only examines stream->stream_name up to\n * OS_MAX_PATH_LEN (which is a fixed-size array) using memchr and byte-wise dumps which is safe.\n */\nstatic void OS_FileOpenCheck_LogProbe(const OS_stream_internal_record_t *stream, const char *Filename, unsigned long token, const char *stage)\n{\n    FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_FileOpenCheck] stage=%s token=%lu stream_ptr=%p Filename_ptr=%p socket_domain=%d\\n\",\n            stage, token, (const void *)stream, (const void *)Filename, (int)stream->socket_domain);\n\n    /* Check for NUL within the fixed-size stream_name buffer without reading past it */\n    void *nulpos = memchr(stream->stream_name, '\\0', (size_t)OS_MAX_PATH_LEN);\n    if (nulpos != NULL)\n    {\n        size_t len = (const char *)nulpos - stream->stream_name;\n        fprintf(f, \"stream_name: NUL found within bound at len=%zu\\n\", len);\n    }\n    else\n    {\n        fprintf(f, \"stream_name: NO NUL found within OS_MAX_PATH_LEN=%d\\n\", OS_MAX_PATH_LEN);\n    }\n\n    /* Dump the raw bytes of stream_name (bounded) as hex so agents can see exact contents even if not NUL-terminated */\n    fprintf(f, \"stream_name bytes:\");\n    for (int i = 0; i < OS_MAX_PATH_LEN; ++i)\n    {\n        fprintf(f, \" %02X\", (unsigned char)stream->stream_name[i]);\n    }\n    fprintf(f, \"\\n\\n\");\n\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log the state before performing the strcmp (do NOT read Filename contents) */\n        OS_FileOpenCheck_LogProbe(stream, Filename, (unsigned long)iter.token, \"before_cmp\");\n\n        /* Preserve original logic as much as possible but compute strcmp result separately so we can log it. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            int cmp_result = strcmp(stream->stream_name, Filename);\n\n            /* Log the comparison result after the call. If strcmp itself triggers an out-of-bounds access,\n             * the program may crash here; the prior log entry will still exist and can be used as evidence.\n             */\n            {\n                FILE *f = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (f != NULL)\n                {\n                    fprintf(f, \"[OS_FileOpenCheck] after_cmp token=%lu stream_ptr=%p Filename_ptr=%p cmp_result=%d\\n\\n\",\n                            (unsigned long)iter.token, (const void *)stream, (const void *)Filename, cmp_result);\n                    fclose(f);\n                }\n            }\n\n            if (cmp_result == 0)\n            {\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n"
}