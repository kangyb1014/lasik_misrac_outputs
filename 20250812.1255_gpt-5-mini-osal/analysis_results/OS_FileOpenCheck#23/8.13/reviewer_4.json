{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The struct member stream_name is declared as a non-const char array (char stream_name[OS_MAX_PATH_LEN]) but is only used here in a read-only way (passed to strcmp). MISRA C 2023 Rule 8.13 requires that pointers point to const-qualified types whenever possible, so a read-only string buffer should be declared const. In this code fragment stream->stream_name is not const-qualified yet is used only for comparison, so this is a violation; change the member to const char stream_name[...] (or otherwise ensure the object is mutable when necessary) to comply.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE *log = fopen(\"/tmp/logs/187.txt\", \"a\");\n\n    /* Log entry and input parameter (avoid dereference if NULL) */\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck called with Filename=%s\\n\", (Filename != NULL) ? Filename : \"(null)\");\n        fflush(log);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Probe: log iterator token and stream state */\n        if (log)\n        {\n            /* iter.token is an aggregate type in some builds; print its address instead of casting to integer */\n            fprintf(log, \"Iterator token=%p, stream=%p, socket_domain=%d, stream_name=%s\\n\",\n                    (void *)&iter.token,\n                    (void *)stream,\n                    (int)stream->socket_domain,\n                    (stream->stream_name != NULL) ? stream->stream_name : \"(null)\");\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log the strcmp result and the match */\n            if (log)\n            {\n                fprintf(log, \"Match: stream->stream_name == Filename (\\\"%s\\\") for token=%p\\n\",\n                        stream->stream_name, (void *)&iter.token);\n                fflush(log);\n            }\n\n            return_code = OS_SUCCESS;\n            break;\n        }\n        else\n        {\n            /* Log no-match decision (explicitly record why) */\n            if (log)\n            {\n                int cmp = strcmp(stream->stream_name, Filename);\n                fprintf(log, \"No match for token=%p: socket_domain=%d, strcmp=%d\\n\",\n                        (void *)&iter.token, (int)stream->socket_domain, cmp);\n                fflush(log);\n            }\n        }\n    }\n\n    if (log)\n    {\n        fprintf(log, \"Destroying iterator and returning code=%d\\n\", (int)return_code);\n        fflush(log);\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 concerns pointer types and advises that pointers should be to const-qualified targets when the pointed-to object is not modified through that pointer. Agent A focused on the struct member stream_name being a non-const char array and suggested making the member itself const. That is a different concern. Passing a char array to strcmp (which takes const char *) is perfectly fine; the array decays to const char * for the call and no rule violation follows from that call alone.\n\nTo apply Rule 8.13 here the relevant declaration would be the pointer variable(s) in this function. If the function only reads the stream record, then declaring the local pointer as const OS_stream_internal_record_t *stream (rather than OS_stream_internal_record_t *stream) would be the direct way to satisfy the rule for this function. Changing the definition of the struct member to const char stream_name[] is not required (and could be wrong) if the member is intended to be mutable elsewhere (e.g. set/updated by other code). Without seeing the struct definition and its other uses, one cannot conclude a violation. Therefore the reported violation (that stream_name must be const) is incorrect."
}