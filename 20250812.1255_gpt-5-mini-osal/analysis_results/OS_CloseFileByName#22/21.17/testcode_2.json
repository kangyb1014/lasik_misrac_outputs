{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strcmp(stream->stream_name, Filename) can read past the bounds of stream->stream_name or Filename because strcmp scans both operands until a '\\0'. Nothing in this fragment guarantees that stream->stream_name (fixed-size array of length OS_MAX_PATH_LEN) is NUL-terminated, nor that the caller-provided Filename is NUL-terminated within its allocated bounds. For example, if stream->stream_name was set via a bounded copy that did not append a terminating NUL (or was corrupted), strcmp will read beyond the OS_MAX_PATH_LEN buffer and violate Rule 21.17. Similarly a non-terminated Filename would also cause out-of-bounds reads.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CloseFileByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/183.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CloseFileByName:\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CloseFileByName code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n\n/* Probe helper: logs information about the stream record and the Filename pointer.\n * Writes to /tmp/logs/183.txt. This function is careful to only read the stream_name\n * buffer up to its compile-time size (sizeof(stream->stream_name)) to avoid introducing\n * new out-of-bounds accesses. It does NOT attempt to read the contents of Filename\n * (only logs the pointer) because the storage size for Filename is not known here.\n */\nstatic void OS_CloseFileByName_probe(const OS_stream_internal_record_t *stream, const char *Filename, int token)\n{\n    FILE *f = fopen(\"/tmp/logs/183.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Determine the compile-time size of the stream_name array and whether it contains a NUL within that bound. */\n    size_t buf_len = sizeof(stream->stream_name);\n    const void *nul_ptr = memchr(stream->stream_name, '\\0', buf_len);\n    size_t name_len = nul_ptr ? ((const char *)nul_ptr - stream->stream_name) : buf_len;\n\n    fprintf(f, \"OS_CloseFileByName_probe: iter.token=%d stream_ptr=%p socket_domain=%d Filename_ptr=%p\\n\",\n            token,\n            (const void *)stream,\n            (int)stream->socket_domain,\n            (const void *)Filename);\n\n    fprintf(f, \"  stream_name buffer_size=%zu NUL_in_buffer=%s name_print_len=%zu\\n\",\n            buf_len,\n            (nul_ptr ? \"yes\" : \"no\"),\n            name_len);\n\n    /* Print the stream_name safely up to the discovered length (or full buffer if no NUL). */\n    fprintf(f, \"  stream_name[0..%zu]: '\", name_len);\n    if (name_len > 0)\n    {\n        /* Use precision in printf to ensure only name_len bytes are read */\n        fprintf(f, \"%.*s\", (int)name_len, stream->stream_name);\n    }\n    fprintf(f, \"'\\n\");\n\n    fprintf(f, \"  NOTE: Filename content not read; only pointer logged to avoid reading unknown-sized object.\\n\");\n    fprintf(f, \"----\\n\");\n\n    fclose(f);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Preserve original logic: only call strcmp if socket_domain matches. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            /* Probe/log state right before the strcmp that may read until a NUL. */\n            OS_CloseFileByName_probe(stream, Filename, iter.token);\n\n            if (strcmp(stream->stream_name, Filename) == 0)\n            {\n                /* call OS_close() on the entry referred to by the iterator */\n                close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n                if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n                {\n                    return_code = close_code;\n                }\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n"
}