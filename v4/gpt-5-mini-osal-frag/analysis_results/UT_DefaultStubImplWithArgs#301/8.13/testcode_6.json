{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe pointer StubPtr->Data.Rvc.Buf.IndirectPtr is used only as the source for memcpy (read-only). If IndirectPtr is declared as a non-const pointer (e.g. void *IndirectPtr), this violates MISRA C 2023 Rule 8.13 because the pointer should be const-qualified (const void *) when it points to data that is not modified. Fix by declaring IndirectPtr as const void * (or the appropriate const-qualified type). If IndirectPtr is already declared const, then there is no violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_DefaultStubImplWithArgs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2215.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of UT_DefaultStubImplWithArgs:\n```c\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified UT_DefaultStubImplWithArgs code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original UT_DefaultStubImplWithArgs with it.\n  - Your function must have the exact same signature as UT_DefaultStubImplWithArgs.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call UT_DefaultStubImplWithArgs to check logs.\n  - Your function MUST preserve the original logic of UT_DefaultStubImplWithArgs as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, UT_DefaultStubImplWithArgs will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of UT_DefaultStubImplWithArgs as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "int32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n    FILE *               logfp = NULL;\n\n    /* Open log file early to capture entry and state. Use append mode so multiple calls accumulate. */\n    logfp = fopen(\"/tmp/logs/2215.txt\", \"a\");\n    if (logfp != NULL)\n    {\n        fprintf(logfp, \"ENTER: UT_DefaultStubImplWithArgs(FunctionName=%p, FuncKey=%p, DefaultRc=%ld)\\n\",\n                (void *)FunctionName, (void *)FuncKey, (long)DefaultRc);\n        if (FunctionName != NULL)\n        {\n            fprintf(logfp, \"       FunctionName=\\\"%s\\\"\\n\", FunctionName);\n        }\n        fflush(logfp);\n    }\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Found ContextTblPtr=%p; Int32StatusCode=%ld; Int32StatusIsSet=%d\\n\",\n                    (void *)ContextTblPtr, (long)LocalContext.Int32StatusCode, (int)LocalContext.Int32StatusIsSet);\n            fflush(logfp);\n        }\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: No context entry; zeroed LocalContext\\n\");\n            fflush(logfp);\n        }\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    if (logfp != NULL)\n    {\n        fprintf(logfp, \"INFO: RvcPtr=%p\\n\", (void *)RvcPtr);\n        fflush(logfp);\n    }\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n\n        if (logfp != NULL)\n        {\n            /* Attempt to log the buffer pointer/address info available in the RvcBuf structure */\n            void *rvc_buf_addr = (void *)&RvcPtr->Data.Rvc.Buf;\n            void *indirect_ptr = (void *)RvcPtr->Data.Rvc.Buf.IndirectPtr;\n            fprintf(logfp, \"INFO: Loaded Int32Status from RvcPtr: AddrOfBuf=%p, IndirectPtr=%p, Int32StatusIsSet=%d, Int32StatusCode=%ld\\n\",\n                    rvc_buf_addr, indirect_ptr, (int)LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n            fflush(logfp);\n        }\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Int32Status not set by RVC; using DefaultRc=%ld\\n\", (long)DefaultRc);\n            fflush(logfp);\n        }\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"DEBUG: UtDebug emitted for %s: RetcodeString=%s, Int32StatusCode=%ld\\n\",\n                    FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n            fflush(logfp);\n        }\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Counter entry at %p; Count(before)=%u, Count(after)=%u, StoredValue=%ld\\n\",\n                    (void *)StubPtr, (unsigned)Counter, (unsigned)StubPtr->Data.Rc.Count, (long)StubPtr->Data.Rc.Value);\n            fflush(logfp);\n        }\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Callback hook executed; GotInt32StatusFromHook=%d, Int32StatusCode=%ld\\n\",\n                    (int)GotInt32StatusFromHook, (long)LocalContext.Int32StatusCode);\n            fflush(logfp);\n        }\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: No callback hook present\\n\");\n            fflush(logfp);\n        }\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Final handler invoked: StubPtr=%p\\n\", (void *)StubPtr);\n            fflush(logfp);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            if (logfp != NULL)\n            {\n                fprintf(logfp, \"ACTION: Copying Int32StatusCode to return buffer: BasePtr=%p, Size=%lu\\n\",\n                        (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n                fflush(logfp);\n            }\n\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            if (logfp != NULL)\n            {\n                fprintf(logfp, \"ACTION: After memcpy Int32->BasePtr; Position=%lu\\n\", (unsigned long)StubPtr->Data.Buff.Position);\n                fflush(logfp);\n            }\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (logfp != NULL)\n                {\n                    void *ind_ptr = (void *)StubPtr->Data.Rvc.Buf.IndirectPtr;\n                    const char *ctype = StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\";\n                    fprintf(logfp, \"CHECK: OPAQUE branch: StubPtr->Data.Buff.TotalSize=%lu, StubPtr->Data.Rvc.ActualSz=%lu, ContentType=%s, RvcPtr=%p, IndirectPtr=%p, BasePtr=%p\\n\",\n                            (unsigned long)StubPtr->Data.Buff.TotalSize,\n                            (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                            ctype,\n                            (void *)RvcPtr,\n                            ind_ptr,\n                            (void *)StubPtr->Data.Buff.BasePtr);\n                    fflush(logfp);\n                }\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    /*\n                     * This memcpy is the primary spot related to the reported MISRA violation.\n                     * Log the pointer and size used so that downstream analysis can confirm whether\n                     * the source pointer was used read-only and should be declared const-qualified.\n                     */\n                    if (logfp != NULL)\n                    {\n                        void *ind_ptr = (void *)StubPtr->Data.Rvc.Buf.IndirectPtr;\n                        fprintf(logfp, \"ACTION: Performing memcpy from IndirectPtr=%p to BasePtr=%p, Size=%lu\\n\",\n                                ind_ptr, (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n                        fflush(logfp);\n                    }\n\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                    if (logfp != NULL)\n                    {\n                        fprintf(logfp, \"ACTION: After memcpy IndirectPtr->BasePtr; Position=%lu\\n\",\n                                (unsigned long)StubPtr->Data.Buff.Position);\n                        fflush(logfp);\n                    }\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                if (logfp != NULL)\n                {\n                    fprintf(logfp, \"ACTION: UT_LoadRetval succeeded for non-opaque genre; Position=%lu\\n\",\n                            (unsigned long)StubPtr->Data.Buff.Position);\n                    fflush(logfp);\n                }\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            if (logfp != NULL)\n            {\n                fprintf(logfp, \"ACTION: No configured return value; zero-filling BasePtr=%p, Size=%lu\\n\",\n                        (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n                fflush(logfp);\n            }\n\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            if (logfp != NULL)\n            {\n                fprintf(logfp, \"ACTION: After zero-fill; Position=%lu\\n\", (unsigned long)StubPtr->Data.Buff.Position);\n                fflush(logfp);\n            }\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        if (logfp != NULL)\n        {\n            fprintf(logfp, \"INFO: Clearing deferred RvcPtr=%p\\n\", (void *)RvcPtr);\n            fflush(logfp);\n        }\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    if (logfp != NULL)\n    {\n        fprintf(logfp, \"EXIT: UT_DefaultStubImplWithArgs returning Int32StatusCode=%ld\\n\", (long)LocalContext.Int32StatusCode);\n        fclose(logfp);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n"
}