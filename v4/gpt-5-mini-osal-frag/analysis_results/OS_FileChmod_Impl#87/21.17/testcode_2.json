{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf OS_TranslatePath copies the incoming 'path' into the local_path buffer using string.h routines without checking the destination size (for example: strcpy(local_path, path) or memcpy(local_path, path, strlen(path)+1)), and the length of 'path' is >= OS_MAX_LOCAL_PATH_LEN, the call will write beyond the bounds of local_path (and/or read beyond path) and thus violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileChmod_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2863.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of OS_FileChmod_Impl:\n```c\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n        }\n    }\n\n    close(fd);\n\n    return status;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified OS_FileChmod_Impl code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original OS_FileChmod_Impl with it.\n  - Your function must have the exact same signature as OS_FileChmod_Impl.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call OS_FileChmod_Impl to check logs.\n  - Your function MUST preserve the original logic of OS_FileChmod_Impl as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, OS_FileChmod_Impl will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of OS_FileChmod_Impl as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "int32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open a log file for diagnostic tracing of control flow/state */\n    {\n        FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n        if (log)\n        {\n            fprintf(log, \"ENTER: OS_FileChmod_Impl local_path=%p path=%s access_mode=%u\\n\",\n                    (void *)local_path,\n                    (local_path != NULL) ? local_path : \"(null)\",\n                    (unsigned)access_mode);\n            fclose(log);\n        }\n    }\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        int saved_errno_open_ro = errno;\n\n        /* Log the failed open attempt */\n        {\n            FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n            if (log)\n            {\n                fprintf(log, \"open(RDONLY) failed: path=%s fd=%d errno=%d (%s)\\n\",\n                        (local_path != NULL) ? local_path : \"(null)\", fd, saved_errno_open_ro, strerror(saved_errno_open_ro));\n                fclose(log);\n            }\n        }\n\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            int saved_errno_open_wo = errno;\n\n            /* Log the failed open attempt (write) */\n            {\n                FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n                if (log)\n                {\n                    fprintf(log, \"open(WRONLY) failed: path=%s fd=%d errno=%d (%s)\\n\",\n                            (local_path != NULL) ? local_path : \"(null)\", fd, saved_errno_open_wo, strerror(saved_errno_open_wo));\n                    fclose(log);\n                }\n            }\n\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(saved_errno_open_wo), saved_errno_open_wo);\n            return OS_ERROR;\n        }\n        else\n        {\n            /* Log successful write-only open */\n            FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n            if (log)\n            {\n                fprintf(log, \"open(WRONLY) succeeded: path=%s fd=%d\\n\",\n                        (local_path != NULL) ? local_path : \"(null)\", fd);\n                fclose(log);\n            }\n        }\n    }\n    else\n    {\n        /* Log successful read-only open */\n        FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n        if (log)\n        {\n            fprintf(log, \"open(RDONLY) succeeded: path=%s fd=%d\\n\",\n                    (local_path != NULL) ? local_path : \"(null)\", fd);\n            fclose(log);\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        int saved_errno_fstat = errno;\n\n        /* Log fstat failure and errno */\n        {\n            FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n            if (log)\n            {\n                fprintf(log, \"fstat failed: path=%s fd=%d errno=%d (%s)\\n\",\n                        (local_path != NULL) ? local_path : \"(null)\", fd, saved_errno_fstat, strerror(saved_errno_fstat));\n                fclose(log);\n            }\n        }\n\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(saved_errno_fstat), saved_errno_fstat);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* Log the intended mode changes and key state */\n        {\n            FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n            if (log)\n            {\n                fprintf(log, \"pre-fchmod: path=%s fd=%d uid=%u gid=%u original_mode=0%o new_mode=0%o access_mode=%u\\n\",\n                        (local_path != NULL) ? local_path : \"(null)\", fd,\n                        (unsigned)st.st_uid, (unsigned)st.st_gid,\n                        (unsigned)st.st_mode /* note: this is after modification above */,\n                        (unsigned)st.st_mode,\n                        (unsigned)access_mode);\n                fclose(log);\n            }\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            int saved_errno_fchmod = errno;\n\n            /* Log fchmod failure and errno */\n            {\n                FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n                if (log)\n                {\n                    fprintf(log, \"fchmod failed: path=%s fd=%d errno=%d (%s)\\n\",\n                            (local_path != NULL) ? local_path : \"(null)\", fd, saved_errno_fchmod, strerror(saved_errno_fchmod));\n                    fclose(log);\n                }\n            }\n\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (saved_errno_fchmod == ENOTSUP || saved_errno_fchmod == ENOSYS || saved_errno_fchmod == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(saved_errno_fchmod), saved_errno_fchmod);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n\n            /* Log successful fchmod */\n            FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n            if (log)\n            {\n                fprintf(log, \"fchmod succeeded: path=%s fd=%d new_mode=0%o status=%d\\n\",\n                        (local_path != NULL) ? local_path : \"(null)\", fd, (unsigned)st.st_mode, (int)status);\n                fclose(log);\n            }\n        }\n    }\n\n    /* Always close the fd and log the close */\n    {\n        int saved_errno_close = 0;\n        if (close(fd) < 0)\n        {\n            saved_errno_close = errno;\n        }\n\n        FILE *log = fopen(\"/tmp/logs/2863.txt\", \"a\");\n        if (log)\n        {\n            if (saved_errno_close != 0)\n            {\n                fprintf(log, \"close(fd=%d) failed errno=%d (%s)\\n\", fd, saved_errno_close, strerror(saved_errno_close));\n            }\n            else\n            {\n                fprintf(log, \"close(fd=%d) succeeded\\n\", fd);\n            }\n            fprintf(log, \"EXIT: OS_FileChmod_Impl path=%s final_status=%d\\n\",\n                    (local_path != NULL) ? local_path : \"(null)\", (int)status);\n            fclose(log);\n        }\n    }\n\n    return status;\n}\n"
}