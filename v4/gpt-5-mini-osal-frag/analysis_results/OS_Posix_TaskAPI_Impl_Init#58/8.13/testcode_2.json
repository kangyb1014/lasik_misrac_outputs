{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code passes the result of strerror(errno) (type char *) directly to OS_DEBUG without const-qualifying it. strerror returns a pointer to a static message that should be treated as read-only; per MISRA C 2023 R8.13 the pointer should be to a const-qualified type. The call therefore uses a non-const pointer where a const-qualified pointer is appropriate. Fix: capture the result in a const char * (e.g. const char *msg = strerror(errno);) or cast to const char * when passing to OS_DEBUG.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_Posix_TaskAPI_Impl_Init code that contains useful probe functions that print useful logs to a file \"/tmp/logs/215.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of OS_Posix_TaskAPI_Impl_Init:\n```c\nint32 OS_Posix_TaskAPI_Impl_Init(void)\n{\n    int                    ret;\n    long                   ret_long;\n    int                    sig;\n    struct sched_param     sched_param;\n    int                    sched_policy;\n    POSIX_PriorityLimits_t sched_fifo_limits;\n    bool                   sched_fifo_valid;\n    POSIX_PriorityLimits_t sched_rr_limits;\n    bool                   sched_rr_valid;\n\n    /* Initialize Local Tables */\n    memset(OS_impl_task_table, 0, sizeof(OS_impl_task_table));\n\n    /* Clear the \"limits\" structs otherwise the compiler may warn\n     * about possibly being used uninitialized (false warning)\n     */\n    memset(&sched_fifo_limits, 0, sizeof(sched_fifo_limits));\n    memset(&sched_rr_limits, 0, sizeof(sched_rr_limits));\n\n    /*\n     * Create the key used to store OSAL task IDs\n     */\n    ret = pthread_key_create(&POSIX_GlobalVars.ThreadKey, NULL);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"Error creating thread key: %s (%d)\\n\", strerror(ret), ret);\n        return OS_ERROR;\n    }\n\n    /*\n    ** Disable Signals to parent thread and therefore all\n    ** child threads create will block all signals\n    ** Note: Timers will not work in the application unless\n    **       threads are spawned in OS_Application_Startup.\n    */\n    sigfillset(&POSIX_GlobalVars.MaximumSigMask);\n\n    /*\n     * Keep these signals unblocked so the process can be interrupted\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGINT);  /* CTRL+C */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGABRT); /* Abort */\n\n    /*\n     * One should not typically block ANY of the synchronous error\n     * signals, i.e. SIGSEGV, SIGFPE, SIGILL, SIGBUS\n     *\n     * The kernel generates these signals in response to hardware events\n     * and they get routed to the _specific thread_ that was executing when\n     * the problem occurred.\n     *\n     * While it is technically possible to block these signals, the result is\n     * undefined, and it makes debugging _REALLY_ hard.  If the kernel ever does\n     * send one it means there really is a major problem, best to listen to it,\n     * and not ignore it.\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGSEGV); /* Segfault */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGILL);  /* Illegal instruction */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGBUS);  /* Bus Error */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGFPE);  /* Floating Point Exception */\n\n    /*\n     * Set the mask and store the original (default) mask in the POSIX_GlobalVars.NormalSigMask\n     */\n    sigprocmask(SIG_SETMASK, &POSIX_GlobalVars.MaximumSigMask, &POSIX_GlobalVars.NormalSigMask);\n\n    /*\n     * Add all \"RT\" signals into the POSIX_GlobalVars.NormalSigMask\n     * This will be used for the signal mask of the main thread\n     * (This way it will end up as the default/original signal mask plus all RT sigs)\n     */\n    for (sig = SIGRTMIN; sig <= SIGRTMAX; ++sig)\n    {\n        sigaddset(&POSIX_GlobalVars.NormalSigMask, sig);\n    }\n\n    /*\n     * SIGHUP is used to wake up the main thread when necessary,\n     * so make sure it is NOT in the set.\n     */\n    sigdelset(&POSIX_GlobalVars.NormalSigMask, SIGHUP);\n\n    /*\n    ** Install noop as the signal handler for SIGUP.\n    */\n    signal(SIGHUP, OS_NoopSigHandler);\n\n    /*\n    ** Raise the priority of the current (main) thread so that subsequent\n    ** application initialization will complete.  This had previously been\n    ** done by the BSP and but it is moved here.\n    **\n    ** This will only work if the user owning this process has permission\n    ** to create real time threads.  Otherwise, the default priority will\n    ** be retained.  Typically this is only the root user, but finer grained\n    ** permission controls are out there.  So if it works, great, but if\n    ** a permission denied error is generated, that is OK too - this allows\n    ** easily debugging code as a normal user.\n    */\n    ret = pthread_getschedparam(pthread_self(), &sched_policy, &sched_param);\n    if (ret == 0)\n    {\n        POSIX_GlobalVars.SelectedRtScheduler = sched_policy; /* Fallback/default */\n        do\n        {\n            sched_fifo_valid = OS_Posix_GetSchedulerParams(SCHED_FIFO, &sched_fifo_limits);\n            sched_rr_valid   = OS_Posix_GetSchedulerParams(SCHED_RR, &sched_rr_limits);\n\n            /*\n             * If both policies are valid, choose the best. In general, FIFO is preferred\n             * since it is simpler.\n             *\n             * But, RR is preferred if mapping several OSAL priority levels into the\n             * same local priority level. For instance, if 2 OSAL tasks are created at priorities\n             * \"2\" and \"1\", both may get mapped to local priority 98, and if using FIFO then the\n             * task at priority \"2\" could run indefinitely, never letting priority \"1\" execute.\n             *\n             * This violates the original intent, which would be to have priority \"1\" preempt\n             * priority \"2\" tasks.  RR is less bad since it at least guarantees both tasks some\n             * CPU time,\n             */\n            if (sched_fifo_valid && sched_rr_valid)\n            {\n                /*\n                 * If the spread from min->max is greater than what OSAL actually needs,\n                 * then FIFO is the preferred scheduler.  Must take into account one extra level\n                 * for the root task.\n                 */\n                if ((sched_fifo_limits.PriorityMax - sched_fifo_limits.PriorityMin) > OS_MAX_TASK_PRIORITY)\n                {\n                    sched_policy               = SCHED_FIFO;\n                    POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n                }\n                else\n                {\n                    sched_policy               = SCHED_RR;\n                    POSIX_GlobalVars.PriLimits = sched_rr_limits;\n                }\n            }\n            else if (sched_fifo_valid)\n            {\n                /* only FIFO is available */\n                sched_policy               = SCHED_FIFO;\n                POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n            }\n            else if (sched_rr_valid)\n            {\n                /* only RR is available */\n                sched_policy               = SCHED_RR;\n                POSIX_GlobalVars.PriLimits = sched_rr_limits;\n            }\n            else\n            {\n                /* Nothing is valid, use default */\n                break;\n            }\n\n            /*\n             * This OSAL POSIX implementation will reserve the absolute highest priority\n             * for the root thread, which ultimately will just pend in sigsuspend() so\n             * it will not actually DO anything, except if sent a signal.  This way,\n             * that thread will still be able to preempt a high-priority user thread that\n             * has gone awry (i.e. using 100% cpu in FIFO mode).\n             */\n            sched_param.sched_priority = POSIX_GlobalVars.PriLimits.PriorityMax;\n            --POSIX_GlobalVars.PriLimits.PriorityMax;\n\n            OS_DEBUG(\"Selected policy %d for RT tasks, root task = %d\\n\", sched_policy,\n                     (int)sched_param.sched_priority);\n\n            /*\n             * If the spread from min->max is greater than what OSAL actually needs,\n             * then truncate it at the number of OSAL priorities.  This will end up mapping 1:1.\n             * and leaving the highest priority numbers unused.\n             */\n            if ((POSIX_GlobalVars.PriLimits.PriorityMax - POSIX_GlobalVars.PriLimits.PriorityMin) >\n                OS_MAX_TASK_PRIORITY)\n            {\n                POSIX_GlobalVars.PriLimits.PriorityMax = POSIX_GlobalVars.PriLimits.PriorityMin + OS_MAX_TASK_PRIORITY;\n            }\n\n            ret = pthread_setschedparam(pthread_self(), sched_policy, &sched_param);\n            if (ret != 0)\n            {\n                OS_DEBUG(\"Could not setschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n                break;\n            }\n\n            /*\n             * Set the boolean to indicate that \"setschedparam\" worked --\n             * This means that it is also expected to work for future calls.\n             */\n            POSIX_GlobalVars.SelectedRtScheduler  = sched_policy;\n            POSIX_GlobalVars.EnableTaskPriorities = true;\n        } while (0);\n    }\n    else\n    {\n        OS_DEBUG(\"Could not getschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n    }\n\n#if !defined(OSAL_CONFIG_DEBUG_PERMISSIVE_MODE)\n    /*\n     * In strict (non-permissive) mode, if the task priority setting did not work, fail with an error.\n     * This would be used on a real target where it needs to be ensured that priorities are active\n     * and the \"silent fallback\" of debug mode operation is not desired.\n     */\n    if (!POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        return OS_ERROR;\n    }\n#endif\n\n    ret_long = sysconf(_SC_PAGESIZE);\n    if (ret_long < 0)\n    {\n        OS_DEBUG(\"Could not get page size via sysconf: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n    POSIX_GlobalVars.PageSize = ret_long;\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified OS_Posix_TaskAPI_Impl_Init code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original OS_Posix_TaskAPI_Impl_Init with it.\n  - Your function must have the exact same signature as OS_Posix_TaskAPI_Impl_Init.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call OS_Posix_TaskAPI_Impl_Init to check logs.\n  - Your function MUST preserve the original logic of OS_Posix_TaskAPI_Impl_Init as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, OS_Posix_TaskAPI_Impl_Init will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of OS_Posix_TaskAPI_Impl_Init as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "int32 OS_Posix_TaskAPI_Impl_Init(void)\n{\n    int                    ret;\n    long                   ret_long;\n    int                    sig;\n    struct sched_param     sched_param;\n    int                    sched_policy;\n    POSIX_PriorityLimits_t sched_fifo_limits;\n    bool                   sched_fifo_valid;\n    POSIX_PriorityLimits_t sched_rr_limits;\n    bool                   sched_rr_valid;\n\n    /* Open diagnostic log for this test probe */\n    FILE *os_probe_log = fopen(\"/tmp/logs/215.txt\", \"a\");\n    if (os_probe_log != NULL)\n    {\n        fprintf(os_probe_log, \"ENTER: OS_Posix_TaskAPI_Impl_Init()\\n\");\n        fflush(os_probe_log);\n    }\n\n    /* Initialize Local Tables */\n    memset(OS_impl_task_table, 0, sizeof(OS_impl_task_table));\n\n    /* Clear the \"limits\" structs otherwise the compiler may warn\n     * about possibly being used uninitialized (false warning)\n     */\n    memset(&sched_fifo_limits, 0, sizeof(sched_fifo_limits));\n    memset(&sched_rr_limits, 0, sizeof(sched_rr_limits));\n\n    /*\n     * Create the key used to store OSAL task IDs\n     */\n    ret = pthread_key_create(&POSIX_GlobalVars.ThreadKey, NULL);\n    if (ret != 0)\n    {\n        /* Probe: capture strerror result and pointer information before reporting */\n        if (os_probe_log != NULL)\n        {\n            const char *probe_msg = strerror(ret);\n            fprintf(os_probe_log, \"ERROR: pthread_key_create failed: ret=%d, strerror_ptr=%p, strerror=\\\"%s\\\"\\n\",\n                    ret, (void *)probe_msg, probe_msg);\n            fflush(os_probe_log);\n        }\n\n        OS_DEBUG(\"Error creating thread key: %s (%d)\\n\", strerror(ret), ret);\n\n        if (os_probe_log != NULL)\n        {\n            fprintf(os_probe_log, \"EXIT: OS_Posix_TaskAPI_Impl_Init() early return OS_ERROR (pthread_key_create)\\n\");\n            fclose(os_probe_log);\n        }\n        return OS_ERROR;\n    }\n\n    /*\n    ** Disable Signals to parent thread and therefore all\n    ** child threads create will block all signals\n    ** Note: Timers will not work in the application unless\n    **       threads are spawned in OS_Application_Startup.\n    */\n    sigfillset(&POSIX_GlobalVars.MaximumSigMask);\n\n    /*\n     * Keep these signals unblocked so the process can be interrupted\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGINT);  /* CTRL+C */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGABRT); /* Abort */\n\n    /*\n     * One should not typically block ANY of the synchronous error\n     * signals, i.e. SIGSEGV, SIGFPE, SIGILL, SIGBUS\n     *\n     * The kernel generates these signals in response to hardware events\n     * and they get routed to the _specific thread_ that was executing when\n     * the problem occurred.\n     *\n     * While it is technically possible to block these signals, the result is\n     * undefined, and it makes debugging _REALLY_ hard.  If the kernel ever does\n     * send one it means there really is a major problem, best to listen to it,\n     * and not ignore it.\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGSEGV); /* Segfault */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGILL);  /* Illegal instruction */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGBUS);  /* Bus Error */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGFPE);  /* Floating Point Exception */\n\n    /*\n     * Set the mask and store the original (default) mask in the POSIX_GlobalVars.NormalSigMask\n     */\n    sigprocmask(SIG_SETMASK, &POSIX_GlobalVars.MaximumSigMask, &POSIX_GlobalVars.NormalSigMask);\n\n    /*\n     * Add all \"RT\" signals into the POSIX_GlobalVars.NormalSigMask\n     * This will be used for the signal mask of the main thread\n     * (This way it will end up as the default/original signal mask plus all RT sigs)\n     */\n    for (sig = SIGRTMIN; sig <= SIGRTMAX; ++sig)\n    {\n        sigaddset(&POSIX_GlobalVars.NormalSigMask, sig);\n    }\n\n    /*\n     * SIGHUP is used to wake up the main thread when necessary,\n     * so make sure it is NOT in the set.\n     */\n    sigdelset(&POSIX_GlobalVars.NormalSigMask, SIGHUP);\n\n    /*\n    ** Install noop as the signal handler for SIGUP.\n    */\n    signal(SIGHUP, OS_NoopSigHandler);\n\n    /*\n    ** Raise the priority of the current (main) thread so that subsequent\n    ** application initialization will complete.  This had previously been\n    ** done by the BSP and but it is moved here.\n    **\n    ** This will only work if the user owning this process has permission\n    ** to create real time threads.  Otherwise, the default priority will\n    ** be retained.  Typically this is only the root user, but finer grained\n    ** permission controls are out there.  So if it works, great, but if\n    ** a permission denied error is generated, that is OK too - this allows\n    ** easily debugging code as a normal user.\n    */\n    ret = pthread_getschedparam(pthread_self(), &sched_policy, &sched_param);\n    if (ret == 0)\n    {\n        POSIX_GlobalVars.SelectedRtScheduler = sched_policy; /* Fallback/default */\n        do\n        {\n            sched_fifo_valid = OS_Posix_GetSchedulerParams(SCHED_FIFO, &sched_fifo_limits);\n            sched_rr_valid   = OS_Posix_GetSchedulerParams(SCHED_RR, &sched_rr_limits);\n\n            /*\n             * If both policies are valid, choose the best. In general, FIFO is preferred\n             * since it is simpler.\n             *\n             * But, RR is preferred if mapping several OSAL priority levels into the\n             * same local priority level. For instance, if 2 OSAL tasks are created at priorities\n             * \"2\" and \"1\", both may get mapped to local priority 98, and if using FIFO then the\n             * task at priority \"2\" could run indefinitely, never letting priority \"1\" execute.\n             *\n             * This violates the original intent, which would be to have priority \"1\" preempt\n             * priority \"2\" tasks.  RR is less bad since it at least guarantees both tasks some\n             * CPU time,\n             */\n            if (sched_fifo_valid && sched_rr_valid)\n            {\n                /*\n                 * If the spread from min->max is greater than what OSAL actually needs,\n                 * then FIFO is the preferred scheduler.  Must take into account one extra level\n                 * for the root task.\n                 */\n                if ((sched_fifo_limits.PriorityMax - sched_fifo_limits.PriorityMin) > OS_MAX_TASK_PRIORITY)\n                {\n                    sched_policy               = SCHED_FIFO;\n                    POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n                }\n                else\n                {\n                    sched_policy               = SCHED_RR;\n                    POSIX_GlobalVars.PriLimits = sched_rr_limits;\n                }\n            }\n            else if (sched_fifo_valid)\n            {\n                /* only FIFO is available */\n                sched_policy               = SCHED_FIFO;\n                POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n            }\n            else if (sched_rr_valid)\n            {\n                /* only RR is available */\n                sched_policy               = SCHED_RR;\n                POSIX_GlobalVars.PriLimits = sched_rr_limits;\n            }\n            else\n            {\n                /* Nothing is valid, use default */\n                break;\n            }\n\n            /*\n             * This OSAL POSIX implementation will reserve the absolute highest priority\n             * for the root thread, which ultimately will just pend in sigsuspend() so\n             * it will not actually DO anything, except if sent a signal.  This way,\n             * that thread will still be able to preempt a high-priority user thread that\n             * has gone awry (i.e. using 100% cpu in FIFO mode).\n             */\n            sched_param.sched_priority = POSIX_GlobalVars.PriLimits.PriorityMax;\n            --POSIX_GlobalVars.PriLimits.PriorityMax;\n\n            OS_DEBUG(\"Selected policy %d for RT tasks, root task = %d\\n\", sched_policy,\n                     (int)sched_param.sched_priority);\n\n            /* Probe: log policy selection */\n            if (os_probe_log != NULL)\n            {\n                fprintf(os_probe_log, \"INFO: Selected policy %d, root priority %d, PriLimits min=%d max=%d\\n\",\n                        sched_policy, (int)sched_param.sched_priority,\n                        POSIX_GlobalVars.PriLimits.PriorityMin, POSIX_GlobalVars.PriLimits.PriorityMax);\n                fflush(os_probe_log);\n            }\n\n            /*\n             * If the spread from min->max is greater than what OSAL actually needs,\n             * then truncate it at the number of OSAL priorities.  This will end up mapping 1:1.\n             * and leaving the highest priority numbers unused.\n             */\n            if ((POSIX_GlobalVars.PriLimits.PriorityMax - POSIX_GlobalVars.PriLimits.PriorityMin) >\n                OS_MAX_TASK_PRIORITY)\n            {\n                POSIX_GlobalVars.PriLimits.PriorityMax = POSIX_GlobalVars.PriLimits.PriorityMin + OS_MAX_TASK_PRIORITY;\n            }\n\n            ret = pthread_setschedparam(pthread_self(), sched_policy, &sched_param);\n            if (ret != 0)\n            {\n                /* Probe: capture strerror result and pointer information before reporting */\n                if (os_probe_log != NULL)\n                {\n                    const char *probe_msg = strerror(ret);\n                    fprintf(os_probe_log, \"ERROR: pthread_setschedparam failed: ret=%d, strerror_ptr=%p, strerror=\\\"%s\\\"\\n\",\n                            ret, (void *)probe_msg, probe_msg);\n                    fflush(os_probe_log);\n                }\n\n                OS_DEBUG(\"Could not setschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n                break;\n            }\n\n            /*\n             * Set the boolean to indicate that \"setschedparam\" worked --\n             * This means that it is also expected to work for future calls.\n             */\n            POSIX_GlobalVars.SelectedRtScheduler  = sched_policy;\n            POSIX_GlobalVars.EnableTaskPriorities = true;\n        } while (0);\n    }\n    else\n    {\n        /* Probe: capture strerror result and pointer information before reporting */\n        if (os_probe_log != NULL)\n        {\n            const char *probe_msg = strerror(ret);\n            fprintf(os_probe_log, \"ERROR: pthread_getschedparam failed: ret=%d, strerror_ptr=%p, strerror=\\\"%s\\\"\\n\",\n                    ret, (void *)probe_msg, probe_msg);\n            fflush(os_probe_log);\n        }\n\n        OS_DEBUG(\"Could not getschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n    }\n\n#if !defined(OSAL_CONFIG_DEBUG_PERMISSIVE_MODE)\n    /*\n     * In strict (non-permissive) mode, if the task priority setting did not work, fail with an error.\n     * This would be used on a real target where it needs to be ensured that priorities are active\n     * and the \"silent fallback\" of debug mode operation is not desired.\n     */\n    if (!POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        if (os_probe_log != NULL)\n        {\n            fprintf(os_probe_log, \"EXIT: OS_Posix_TaskAPI_Impl_Init() returning OS_ERROR (EnableTaskPriorities not set)\\n\");\n            fclose(os_probe_log);\n        }\n        return OS_ERROR;\n    }\n#endif\n\n    ret_long = sysconf(_SC_PAGESIZE);\n    if (ret_long < 0)\n    {\n        /* Probe: capture strerror(errno) into a const char * and log pointer/content for evidence */\n        if (os_probe_log != NULL)\n        {\n            const char *probe_msg = strerror(errno);\n            fprintf(os_probe_log, \"ERROR: sysconf(_SC_PAGESIZE) failed: errno=%d, strerror_ptr=%p, strerror=\\\"%s\\\"\\n\",\n                    errno, (void *)probe_msg, probe_msg);\n            fflush(os_probe_log);\n        }\n\n        OS_DEBUG(\"Could not get page size via sysconf: %s\\n\", strerror(errno));\n\n        if (os_probe_log != NULL)\n        {\n            fprintf(os_probe_log, \"EXIT: OS_Posix_TaskAPI_Impl_Init() returning OS_ERROR (sysconf)\\n\");\n            fclose(os_probe_log);\n        }\n        return OS_ERROR;\n    }\n    POSIX_GlobalVars.PageSize = ret_long;\n\n    if (os_probe_log != NULL)\n    {\n        fprintf(os_probe_log, \"EXIT: OS_Posix_TaskAPI_Impl_Init() returning OS_SUCCESS, PageSize=%ld\\n\", ret_long);\n        fclose(os_probe_log);\n    }\n\n    return OS_SUCCESS;\n}\n"
}