{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nPotential indirect recursion via event callbacks: OS_ObjectIdFinalizeNew calls OS_ObjectIdTransactionFinish(...) and then OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED,...). If a registered event handler invoked by OS_NotifyEvent calls an OS API that allocates/deletes objects (e.g. OS_ObjectIdAllocateNew/OS_ObjectIdFinalizeNew or other routine that ultimately calls OS_ObjectIdFinalizeNew), the call chain would be: OS_ObjectIdFinalizeNew -> OS_NotifyEvent -> user_event_handler -> OS_ObjectIdAllocateNew -> OS_ObjectIdFinalizeNew, creating an indirect recursive call to OS_ObjectIdFinalizeNew and thus violating Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdTransferToken code that contains useful probe functions that print useful logs to a file \"/tmp/logs/720.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdTransferToken:\n```c\nvoid OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* start with a simple copy */\n    *token_to = *token_from;\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified OS_ObjectIdTransferToken code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original OS_ObjectIdTransferToken with it.\n  - Your function must have the exact same signature as OS_ObjectIdTransferToken.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call OS_ObjectIdTransferToken to check logs.\n  - Your function MUST preserve the original logic of OS_ObjectIdTransferToken as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, OS_ObjectIdTransferToken will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of OS_ObjectIdTransferToken as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "void OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* Minimal logging to /tmp/logs/720.txt to capture control flow and state\n     * This preserves the original behavior while adding probes that help\n     * reproduce the indirect-recursion scenario via event callbacks.\n     *\n     * Logging strategy:\n     * - Log entry and pointer values before any dereference (so we don't\n     *   introduce new crashes by dereferencing a NULL pointer during logging).\n     * - Perform the original copy operation: *token_to = *token_from;\n     * - After the copy, safely log relevant token state (lock_mode and a\n     *   short raw-byte dump) via token_to (the copied value) and token_from.\n     * - Nullify token_from->lock_mode as in the original implementation and\n     *   log the final state.\n     */\n\n    FILE *log = fopen(\"/tmp/logs/720.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"ENTER OS_ObjectIdTransferToken: token_from=%p token_to=%p\\n\",\n                (void *)token_from, (void *)token_to);\n        fflush(log);\n    }\n\n    /* start with a simple copy (original logic) */\n    *token_to = *token_from;\n\n    if (log)\n    {\n        /* Log lock modes after the copy; these accesses assume the copy succeeded\n         * (matching the original function's dereference behavior). */\n        /* Use integer casts for printing in case lock_mode is an enum. */\n        fprintf(log, \"After copy: token_to=%p token_to->lock_mode=%d\\n\",\n                (void *)token_to, (int)token_to->lock_mode);\n\n        /* Attempt a limited raw dump of the token bytes to help diagnose\n         * control/state flow leading to callbacks that may re-enter allocation\n         * routines. Cap the dump at 64 bytes for readability. */\n        if (token_to != NULL)\n        {\n            size_t tok_size = sizeof(*token_to);\n            size_t dump_size = tok_size < 64 ? tok_size : 64;\n            unsigned char *b = (unsigned char *)token_to;\n\n            fprintf(log, \"token_to raw:\");\n            for (size_t i = 0; i < dump_size; ++i)\n            {\n                fprintf(log, \" %02X\", (unsigned int)b[i]);\n            }\n            fprintf(log, \"\\n\");\n        }\n\n        /* Also attempt to log the source token's lock mode prior to nullify.\n         * This helps correlate the state transition that could lead to\n         * callbacks invoking object allocation/deallocation APIs. */\n        if (token_from != NULL)\n        {\n            fprintf(log, \"Before nullify: token_from=%p token_from->lock_mode=%d\\n\",\n                    (void *)token_from, (int)token_from->lock_mode);\n        }\n\n        fflush(log);\n    }\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n\n    if (log)\n    {\n        fprintf(log, \"After nullify: token_from=%p token_from->lock_mode=%d\\n\",\n                (void *)token_from, (int)token_from->lock_mode);\n        fprintf(log, \"EXIT OS_ObjectIdTransferToken\\n\\n\");\n        fflush(log);\n        fclose(log);\n    }\n}\n"
}