{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes &connection->socket_context to the callback daemon->notify_connection. If the notify_connection function pointer is declared to take a non-const pointer (e.g. void (*notify_connection)(void *cls, struct MHD_Connection *conn, struct MHD_Socket_Context *ctx, int reason)) but the callback does not need to modify socket_context, then the parameter should be const-qualified (e.g. const struct MHD_Socket_Context *ctx). In that case the code violates MISRA C 2023 Rule 8.13. Conversely, if the callback legitimately modifies the socket_context, no violation occurs. The fragment alone cannot prove intent; the violation arises when the callback\u2019s prototype omits const where it could be used.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified new_connection_process_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/555.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of new_connection_process_:\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified new_connection_process_ code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original new_connection_process_ with it.\n  - Your function must have the exact same signature as new_connection_process_.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call new_connection_process_ to check logs.\n  - Your function MUST preserve the original logic of new_connection_process_ as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, new_connection_process_ will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of new_connection_process_ as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "static enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n  FILE *log = NULL;\n\n  /* Try to open log file for append. If it fails, continue silently. */\n  log = fopen(\"/tmp/logs/555.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"ENTRY: new_connection_process_ daemon=%p connection=%p socket_fd=%d\\n\",\n            (void *) daemon,\n            (void *) connection,\n            connection ? connection->socket_fd : -1);\n    fflush(log);\n  }\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n\n    if (log)\n    {\n      fprintf(log, \"POOL_FAIL: connection=%p pool_create failed errno=%d\\n\",\n              (void *) connection, errno);\n      fflush(log);\n      /* keep log open until function exit */\n    }\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n\n      if (log)\n      {\n        fprintf(log, \"CONN_LIMIT: daemon=%p connections=%u limit=%u\\n\",\n                (void *) daemon,\n                (unsigned) daemon->connections,\n                (unsigned) daemon->connection_limit);\n        fflush(log);\n      }\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n      {\n        /* Capture and log socket_context bytes around notify callback\n         * to detect whether the callback mutates the context. */\n        size_t sc_sz = sizeof connection->socket_context;\n        unsigned char *pre = NULL;\n        int pre_ok = 0;\n\n        if (log)\n        {\n          fprintf(log, \"NOTIFY_CALL: about to call notify_connection (STARTED)\\n\");\n          fprintf(log, \"  notify_connection ptr=%p cls=%p conn=%p ctx_addr=%p sc_size=%zu reason=%d\\n\",\n                  (void *) daemon->notify_connection,\n                  (void *) daemon->notify_connection_cls,\n                  (void *) connection,\n                  (void *) &connection->socket_context,\n                  sc_sz,\n                  MHD_CONNECTION_NOTIFY_STARTED);\n\n          /* Try to snapshot socket_context bytes */\n          if (sc_sz > 0)\n          {\n            pre = (unsigned char *) malloc (sc_sz);\n            if (NULL != pre)\n            {\n              memcpy (pre, &connection->socket_context, sc_sz);\n              pre_ok = 1;\n\n              /* Dump up to first 256 bytes for readability */\n              size_t dump_n = sc_sz < 256 ? sc_sz : 256;\n              fprintf(log, \"  pre_ctx_bytes:\");\n              for (size_t i = 0; i < dump_n; ++i)\n                fprintf(log, \" %02x\", pre[i]);\n              if (dump_n < sc_sz)\n                fprintf(log, \" ...\");\n              fprintf(log, \"\\n\");\n            }\n            else\n            {\n              fprintf(log, \"  pre_ctx_snapshot: malloc failed for size=%zu\\n\", sc_sz);\n            }\n          }\n          fflush(log);\n        }\n\n        /* Call the original callback */\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n\n        if (log)\n        {\n          if (pre_ok)\n          {\n            unsigned char *post = (unsigned char *) malloc (sc_sz);\n            if (post)\n            {\n              memcpy (post, &connection->socket_context, sc_sz);\n              int same = (0 == memcmp (pre, post, sc_sz));\n              fprintf(log, \"NOTIFY_RETURN: notify_connection (STARTED) returned, socket_context %smodified\\n\",\n                      same ? \"not \" : \"\");\n\n              size_t dump_n = sc_sz < 256 ? sc_sz : 256;\n              fprintf(log, \"  post_ctx_bytes:\");\n              for (size_t i = 0; i < dump_n; ++i)\n                fprintf(log, \" %02x\", post[i]);\n              if (dump_n < sc_sz)\n                fprintf(log, \" ...\");\n              fprintf(log, \"\\n\");\n\n              free (post);\n            }\n            else\n            {\n              fprintf(log, \"  post_ctx_snapshot: malloc failed for size=%zu\\n\", sc_sz);\n            }\n            free (pre);\n          }\n          else if (sc_sz > 0)\n          {\n            fprintf(log, \"NOTIFY_RETURN: no pre snapshot available to compare\\n\");\n          }\n          fflush(log);\n        }\n      }\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n        {\n          if (log)\n          {\n            fprintf(log, \"EXIT: returning MHD_YES (thread-per-conn created) connection=%p tid=%p\\n\",\n                    (void *) connection,\n                    (void *) &connection->tid);\n            fflush(log);\n            fclose(log);\n            log = NULL;\n          }\n          return MHD_YES;  /* *** Function success exit point *** */\n        }\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              if (log)\n              {\n                fprintf(log, \"EXIT: returning MHD_YES (epoll added) connection=%p epoll_fd=%d\\n\",\n                        (void *) connection, daemon->epoll_fd);\n                fflush(log);\n                fclose(log);\n                log = NULL;\n              }\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            if (log)\n            {\n              fprintf(log, \"EXIT: returning MHD_YES (turbo epoll branch) connection=%p\\n\",\n                      (void *) connection);\n              fflush(log);\n              fclose(log);\n              log = NULL;\n            }\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        {\n          if (log)\n          {\n            fprintf(log, \"EXIT: returning MHD_YES (no epoll) connection=%p\\n\",\n                    (void *) connection);\n            fflush(log);\n            fclose(log);\n            log = NULL;\n          }\n          return MHD_YES;    /* *** Function success exit point *** */\n        }\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n      {\n        /* Snapshot before CLOSE notify */\n        size_t sc_sz = sizeof connection->socket_context;\n        unsigned char *pre = NULL;\n        int pre_ok = 0;\n\n        if (log)\n        {\n          fprintf(log, \"NOTIFY_CALL: about to call notify_connection (CLOSED)\\n\");\n          fprintf(log, \"  notify_connection ptr=%p cls=%p conn=%p ctx_addr=%p sc_size=%zu reason=%d\\n\",\n                  (void *) daemon->notify_connection,\n                  (void *) daemon->notify_connection_cls,\n                  (void *) connection,\n                  (void *) &connection->socket_context,\n                  sc_sz,\n                  MHD_CONNECTION_NOTIFY_CLOSED);\n\n          if (sc_sz > 0)\n          {\n            pre = (unsigned char *) malloc (sc_sz);\n            if (NULL != pre)\n            {\n              memcpy (pre, &connection->socket_context, sc_sz);\n              pre_ok = 1;\n\n              size_t dump_n = sc_sz < 256 ? sc_sz : 256;\n              fprintf(log, \"  pre_ctx_bytes:\");\n              for (size_t i = 0; i < dump_n; ++i)\n                fprintf(log, \" %02x\", pre[i]);\n              if (dump_n < sc_sz)\n                fprintf(log, \" ...\");\n              fprintf(log, \"\\n\");\n            }\n            else\n            {\n              fprintf(log, \"  pre_ctx_snapshot: malloc failed for size=%zu\\n\", sc_sz);\n            }\n          }\n          fflush(log);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n\n        if (log)\n        {\n          if (pre_ok)\n          {\n            unsigned char *post = (unsigned char *) malloc (sc_sz);\n            if (post)\n            {\n              memcpy (post, &connection->socket_context, sc_sz);\n              int same = (0 == memcmp (pre, post, sc_sz));\n              fprintf(log, \"NOTIFY_RETURN: notify_connection (CLOSED) returned, socket_context %smodified\\n\",\n                      same ? \"not \" : \"\");\n\n              size_t dump_n = sc_sz < 256 ? sc_sz : 256;\n              fprintf(log, \"  post_ctx_bytes:\");\n              for (size_t i = 0; i < dump_n; ++i)\n                fprintf(log, \" %02x\", post[i]);\n              if (dump_n < sc_sz)\n                fprintf(log, \" ...\");\n              fprintf(log, \"\\n\");\n\n              free (post);\n            }\n            else\n            {\n              fprintf(log, \"  post_ctx_snapshot: malloc failed for size=%zu\\n\", sc_sz);\n            }\n            free (pre);\n          }\n          else if (sc_sz > 0)\n          {\n            fprintf(log, \"NOTIFY_RETURN: no pre snapshot available to compare (CLOSED)\\n\");\n          }\n          fflush(log);\n        }\n      }\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n\n  if (log)\n  {\n    fprintf(log, \"EXIT: returning MHD_NO daemon=%p connection(freed)=%p eno=%d\\n\",\n            (void *) daemon, (void *) connection, eno);\n    fflush(log);\n    fclose(log);\n    log = NULL;\n  }\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n"
}