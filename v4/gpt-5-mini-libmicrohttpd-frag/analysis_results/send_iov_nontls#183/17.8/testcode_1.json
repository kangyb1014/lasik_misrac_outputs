{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.8.\nHere is the comment from the agent.\n<violation scenario>\nWithin send_iov_nontls, when _MHD_IOV_MAX < items_to_send the code executes: items_to_send = _MHD_IOV_MAX; push_data = false; \u2014 this assigns to the parameter push_data (a non-pointer parameter). MISRA C 2023 Rule 17.8 prohibits modifying function parameters, so this is a violation. (Use a local copy e.g., bool local_push_data = push_data and modify that instead.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified send_iov_nontls code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2622.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of send_iov_nontls:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified send_iov_nontls code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original send_iov_nontls with it.\n  - Your function must have the exact same signature as send_iov_nontls.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call send_iov_nontls to check logs.\n  - Your function MUST preserve the original logic of send_iov_nontls as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, send_iov_nontls will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of send_iov_nontls as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "static ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n  FILE *logf = NULL;\n\n  /* Open log file for append so we can record control flow/state. */\n  logf = fopen(\"/tmp/logs/2622.txt\", \"a\");\n  if (logf)\n  {\n    if (connection)\n      fprintf(logf, \"ENTER send_iov_nontls: connection=%p, daemon=%p, socket_fd=%d, state=%d, r_iov=%p, r_iov->cnt=%zu, r_iov->sent=%zu, push_data=%d\\n\",\n              (void *)connection, (void *)connection->daemon,\n              (int) connection->socket_fd, (int) connection->state,\n              (void *) r_iov, (size_t) r_iov->cnt, (size_t) r_iov->sent,\n              (int) push_data);\n    else\n      fprintf(logf, \"ENTER send_iov_nontls: connection=NULL, r_iov=%p, r_iov->cnt=%zu, r_iov->sent=%zu, push_data=%d\\n\",\n              (void *) r_iov, (size_t) r_iov->cnt, (size_t) r_iov->sent,\n              (int) push_data);\n  }\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    if (logf)\n    {\n      fprintf(logf, \"EARLY RETURN: invalid socket or closed: socket_fd=%d, state=%d => %d\\n\",\n              (int) connection->socket_fd, (int) connection->state, (int) MHD_ERR_NOTCONN_);\n      fclose(logf);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  if (logf)\n    fprintf(logf, \"Computed items_to_send = r_iov->cnt(%zu) - r_iov->sent(%zu) = %zu\\n\",\n            (size_t) r_iov->cnt, (size_t) r_iov->sent, (size_t) items_to_send);\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (logf)\n      fprintf(logf, \"_MHD_IOV_MAX (%d) < items_to_send (%zu) branch taken\\n\", (int) _MHD_IOV_MAX, (size_t) items_to_send);\n    if (0 == _MHD_IOV_MAX)\n    {\n      if (logf)\n      {\n        fprintf(logf, \"_MHD_IOV_MAX == 0 => EARLY RETURN %d\\n\", (int) MHD_ERR_NOTCONN_);\n        fclose(logf);\n      }\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    /* Log values before modification */\n    if (logf)\n      fprintf(logf, \"Before truncation: items_to_send=%zu, push_data=%d\\n\", (size_t) items_to_send, (int) push_data);\n\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n\n    /* Log values after modification to capture the violation scenario */\n    if (logf)\n      fprintf(logf, \"After truncation: items_to_send=%zu (set to _MHD_IOV_MAX=%d), push_data set to %d\\n\",\n              (size_t) items_to_send, (int) _MHD_IOV_MAX, (int) push_data);\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  if (logf)\n    fprintf(logf, \"Calling pre_send_setopt (sendmsg path) with push_data=%d\\n\", (int) push_data);\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  if (logf)\n    fprintf(logf, \"Calling pre_send_setopt (writev path) with push_data=%d\\n\", (int) push_data);\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    if (logf)\n      fprintf(logf, \"_WIN64 path: items_to_send (%zu) > UINT32_MAX, setting cnt_w=UINT32_MAX and push_data=false\\n\", (size_t) items_to_send);\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n    if (logf)\n      fprintf(logf, \"After _WIN64 truncation: cnt_w=%u, push_data=%d\\n\", (unsigned) cnt_w, (int) push_data);\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  if (logf)\n    fprintf(logf, \"Calling pre_send_setopt (WSASend path) with push_data=%d, cnt_w=%u\\n\", (int) push_data, (unsigned) cnt_w);\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (logf)\n    fprintf(logf, \"send operation returned res=%zd\\n\", (ssize_t) res);\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (logf)\n      fprintf(logf, \"send error: err=%d\\n\", err);\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (logf)\n      {\n        fprintf(logf, \"EAGAIN -> return %d\\n\", (int) MHD_ERR_AGAIN_);\n        fclose(logf);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"EINTR -> return %d\\n\", (int) MHD_ERR_AGAIN_);\n        fclose(logf);\n      }\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"REMOTE_DISCONNECT -> return %d\\n\", (int) MHD_ERR_CONNRESET_);\n        fclose(logf);\n      }\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"EPIPE -> return %d\\n\", (int) MHD_ERR_PIPE_);\n        fclose(logf);\n      }\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"EOPNOTSUPP -> return %d\\n\", (int) MHD_ERR_OPNOTSUPP_);\n        fclose(logf);\n      }\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"ENOTCONN -> return %d\\n\", (int) MHD_ERR_NOTCONN_);\n        fclose(logf);\n      }\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"EINVAL -> return %d\\n\", (int) MHD_ERR_INVAL_);\n        fclose(logf);\n      }\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"LOW_RESOURCES -> return %d\\n\", (int) MHD_ERR_NOMEM_);\n        fclose(logf);\n      }\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      if (logf)\n      {\n        fprintf(logf, \"EBADF -> return %d\\n\", (int) MHD_ERR_BADF_);\n        fclose(logf);\n      }\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    if (logf)\n    {\n      fprintf(logf, \"Unhandled socket error %d -> return %d\\n\", err, (int) MHD_ERR_NOTCONN_);\n      fclose(logf);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    if (logf)\n      fprintf(logf, \"Some data sent: res=%zd -> track_sent=%zu\\n\", (ssize_t) res, (size_t) track_sent);\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n      if (logf)\n        fprintf(logf, \"Advanced r_iov->sent to %zu, remaining track_sent=%zu\\n\", (size_t) r_iov->sent, (size_t) track_sent);\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      if (logf)\n        fprintf(logf, \"All iov elements sent. Calling post_send_setopt with push_data=%d\\n\", (int) push_data);\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        if (logf)\n          fprintf(logf, \"Partial send: adjusted current iov base and len, new iov_len=%zu\\n\",\n                  (size_t) r_iov->iov[r_iov->sent].iov_len);\n      }\n    }\n  }\n\n  if (logf)\n  {\n    fprintf(logf, \"EXIT send_iov_nontls returning res=%zd, final r_iov->sent=%zu, push_data=%d\\n\",\n            (ssize_t) res, (size_t) r_iov->sent, (int) push_data);\n    fclose(logf);\n  }\n\n  return res;\n}\n"
}