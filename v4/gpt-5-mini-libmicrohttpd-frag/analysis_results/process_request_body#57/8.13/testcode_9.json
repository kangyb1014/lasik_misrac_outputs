{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local pointer buffer_head is declared as char * but in this fragment it is only used for read access (buffer_head[0], buffer_head[1]). Since no modification of the pointed-to characters occurs via buffer_head, it could be declared const char *; therefore the current non-const pointer violates MISRA C 2023 Rule 8.13. (Fix: change declaration to const char *buffer_head.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_request_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1825.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of process_request_body:\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified process_request_body code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original process_request_body with it.\n  - Your function must have the exact same signature as process_request_body.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call process_request_body to check logs.\n  - Your function MUST preserve the original logic of process_request_body as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, process_request_body will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of process_request_body as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "static void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  /* Logging probe */\n  FILE *logf = fopen(\"/tmp/logs/1825.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTER process_request_body: connection=%p daemon=%p discp_lvl=%d bare_lf_as_crlf=%d allow_bws=%d\\n\",\n            (void *)connection, (void *)daemon, discp_lvl, (int)bare_lf_as_crlf, (int)allow_bws);\n    fflush(logf);\n  }\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  if (logf)\n  {\n    fprintf(logf, \"initial buffer_head=%p available=%zu read_buffer_offset=%zu\\n\",\n            (void *)buffer_head, available, connection->read_buffer_offset);\n    fflush(logf);\n  }\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if (logf)\n        {\n          fprintf(logf, \"chunk end sequence check: available=%zu buffer_head=%p\\n\",\n                  available, (void *)buffer_head);\n          if (available >= 1)\n            fprintf(logf, \" bytes[0]=0x%02x ('%c')\\n\", (unsigned char)buffer_head[0],\n                    (buffer_head[0] >= ' ' && buffer_head[0] <= '~') ? buffer_head[0] : '?');\n          if (available >= 2)\n            fprintf(logf, \" bytes[1]=0x%02x ('%c')\\n\", (unsigned char)buffer_head[1],\n                    (buffer_head[1] >= ' ' && buffer_head[1] <= '~') ? buffer_head[1] : '?');\n          fflush(logf);\n        }\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n        {\n          if (logf) { fprintf(logf, \"need more upload data while skipping end-of-chunk newline (available=%zu)\\n\", available); fflush(logf); }\n          if (logf) fclose(logf);\n          return;\n        }\n        if (0 == i)\n        {\n          /* malformed encoding */\n          if (logf) { fprintf(logf, \"malformed chunk encoding: no newline found at chunk end\\n\"); fflush(logf); }\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          if (logf) fclose(logf);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        if (logf) { fprintf(logf, \"skipped %zu bytes at chunk end, new available=%zu buffer_head=%p\\n\", i, available, (void *)buffer_head); fflush(logf); }\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n        {\n          if (logf) { fprintf(logf, \"no more available after skipping chunk end\\n\"); fflush(logf); }\n          if (logf) fclose(logf);\n          return;\n        }\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n        if (logf) { fprintf(logf, \"processing middle of chunk: cur_chunk_left=%"
}