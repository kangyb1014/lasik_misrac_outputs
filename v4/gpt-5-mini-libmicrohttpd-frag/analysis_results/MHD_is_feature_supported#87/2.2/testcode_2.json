{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe switch default label contains only a 'break;' statement which is executed when none of the enumerated cases match. Removing that 'break;' would not change program behaviour because control simply falls out of the switch to the subsequent 'return MHD_NO;'. Therefore the executed 'break;' is an operation whose removal would not affect behaviour (dead code).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_is_feature_supported code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1038.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\n</response format>\n<target_code>\nHere is the code of MHD_is_feature_supported:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n\n<instruction>\n\nPlease provide the modified MHD_is_feature_supported code.\n\nThe information below explains how I\u2019ll use the function you provide. Please use it as a reference when generating code.\n1. Replacement\n  - I will parse your function and replace the original MHD_is_feature_supported with it.\n  - Your function must have the exact same signature as MHD_is_feature_supported.\n  - It must be a complete, self-contained definition; (no omissions, placeholders (e.g., \"...\"), or comments indicating skipped/omitted logic.)\n2. Logging / reachability\n  - I will run a test suite that is guaranteed to call MHD_is_feature_supported to check logs.\n  - Your function MUST preserve the original logic of MHD_is_feature_supported as much as possible.\n  - The log output must not be empty. Even if you are verifying dead code, MHD_is_feature_supported will be reached; insert a minimal probe/log to demonstrate that the target function was entered.\n3. Coverage\n  - I will run the same test suite to measure coverage.\n  - Test outcomes must match those of the original code.\n  - If reproducing the rule violation necessarily causes a crash (e.g., the violation inherently triggers a crash), that is acceptable; otherwise, your function should not crash under the existing test suite so coverage can be measured.\n4. Test code constraints\n  - The test code MUST preserve the original logic of MHD_is_feature_supported as much as possible.\n  - DO NOT introduce new violations to demonstrate your scenario.\n  - The test code MUST be compilable and executable.\n  - The test code MUST include line breaks.\n  - You MUST NOT define the main function.\n  - You MUST NOT define macros.\n  - You MUST NOT REDEFINE any existing identifiers, such as macros, static/global variables, or functions.\n  - Do not break string literals or include stray/unmatched double quotes; the code must parse cleanly with no quote-related errors.\n\nThese are common mistakes of generated codes. Do not make these mistakes:\n- Redefining existing functions, variables, types, or macros.\n- Broken string literals or unmatched quotes.\n- Invoking undeclared function.\n- Using undeclared member in a struct.\n- Invoking functions with wrong parameter type.\n\n</instruction>\n",
  "test_code": "_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  enum MHD_Result res = MHD_NO;\n  FILE *log = fopen(\"/tmp/logs/1038.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"MHD_is_feature_supported ENTER feature=%d\\n\", (int)feature);\n    fclose(log);\n  }\n\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    res = MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    res = MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n    break;\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    res = MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    res = MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    break;\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    res = MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    res = MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    break;\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    res = MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    res = MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    break;\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    res = MHD_YES;\n#elif defined(HAVE_PREAD)\n    res = (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    res = MHD_YES;\n#else\n    res = (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n    break;\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    res = MHD_NO;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    res = MHD_NO;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    res = MHD_YES;\n#else\n    res = MHD_NO;\n#endif\n    break;\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    res = MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    res = MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    break;\n\n  default:\n    log = fopen(\"/tmp/logs/1038.txt\", \"a\");\n    if (log)\n    {\n      fprintf(log, \"MHD_is_feature_supported: default label taken for feature=%d; executing break\\n\", (int)feature);\n      fclose(log);\n    }\n    break;\n  }\n\n  log = fopen(\"/tmp/logs/1038.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"MHD_is_feature_supported EXIT feature=%d result=%d\\n\", (int)feature, (int)res);\n    fclose(log);\n  }\n\n  return res;\n}\n"
}