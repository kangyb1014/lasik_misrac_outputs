{
  "user_message": "An agent A claimed that the following metal_open code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of metal_open.\n```c\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Passing a non-NULL, non-NUL-terminated buffer as path. metal_open calls strlen(path) to check for empty string; if the caller provides a pointer to a buffer that is not NUL-terminated (for example a fixed-size char array filled without a terminating '\\0'), strlen will read past the object bounds causing an out-of-bounds access. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nvoid metal_open_probe_non_nul_terminated(void)\n{\n    FILE *log = fopen(\"/tmp/logs/103.txt\", \"w\");\n    if (!log)\n        return;\n\n    fprintf(log, \"Probe: create non NUL-terminated buffer and call metal_open\\n\");\n\n    /* Create a small buffer and intentionally do not NUL-terminate it */\n    char buf[8];\n    /* copy 7 bytes, leaving no space for the terminating NUL */\n    memcpy(buf, \"ABCDEFG\", 7);\n\n    fprintf(log, \"Buffer bytes (hex):\");\n    for (size_t i = 0; i < sizeof(buf); ++i) {\n        fprintf(log, \" %02X\", (unsigned char)buf[i]);\n    }\n    fprintf(log, \"\\n\");\n\n    fprintf(log, \"Calling metal_open(buf, 0) - this will call strlen(buf) which may read beyond buf bounds\\n\");\n    fflush(log);\n\n    /* Call metal_open with the non-terminated buffer to exercise the strlen() usage */\n    int ret = metal_open(buf, 0);\n\n    fprintf(log, \"metal_open returned %d\\n\", ret);\n    fclose(log);\n}\n\nint metal_open(const char *path, int shm)\n{\n    const int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n    const int mode = S_IRUSR | S_IWUSR;\n    int fd;\n\n    /* Probe log: record entry and pointer value */\n    {\n        FILE *log = fopen(\"/tmp/logs/103.txt\", \"a\");\n        if (log) {\n            fprintf(log, \"metal_open: entry path=%p\\n\", (const void *)path);\n            fclose(log);\n        }\n    }\n\n    if (!path || !strlen(path))\n        return -EINVAL;\n\n    fd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n    return fd < 0 ? -errno : fd;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_open. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. strlen(path) scans memory until it finds a '\\0'; if a caller passes a non-NULL, non-NUL-terminated buffer (for example a fixed-size char array lacking a terminating '\\0'), the call may read beyond the bounds of the object and cause an out-of-bounds access. MISRA C 2023 Rule 21.17 prohibits uses of <string.h> functions that can result in such out-of-bounds accesses unless the code can guarantee the pointer parameters reference NUL-terminated objects within their bounds. metal_open does not enforce or document such a guarantee and does not use a bounded variant (e.g. strnlen) or an explicit length parameter, so the call to strlen can be non-compliant. To remediate, either document and enforce the precondition that path is a valid NUL-terminated string, or use a bounded routine (strnlen with a maximum length) or change the API to accept a length to ensure no out-of-bounds access can occur."
}