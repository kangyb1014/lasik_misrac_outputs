{
  "user_message": "Target function code is:\n```c\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_map': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_uio_dev_open': {'callees': ['metal_uio_dev_bind', 'metal_open', 'metal_uio_read_map_attr', 'metal_map', 'metal_io_init', 'metal_linux_irq_register_dev'], 'callers': []}, 'metal_shmem_try_map': {'callees': ['metal_map', 'metal_unmap', 'metal_io_init', 'metal_virt2phys'], 'callers': ['metal_shmem_open']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mmap",
    "MAP_FAILED",
    "PROT_READ",
    "PROT_WRITE",
    "MAP_SHARED",
    "MAP_PRIVATE",
    "MAP_ANONYMOUS",
    "off_t",
    "size_t",
    "errno",
    "flock",
    "LOCK_EX",
    "LOCK_UN",
    "fstat",
    "struct stat",
    "ftruncate",
    "sys/mman.h",
    "sys/stat.h",
    "sys/file.h",
    "errno.h",
    "unistd.h"
  ],
  "explanation": "For checking MISRA C 'no language extensions' you must inspect how each external symbol is defined/implemented (macros, typedefs, prototypes, or header content) because language extensions frequently appear in header definitions rather than in this function body. Explanations: \n- mmap: prototype may carry compiler-specific attributes (e.g. __attribute__, __nothrow__, nonstandard calling conventions); its declaration must be inspected for extensions. \n- MAP_FAILED: macro expansion (often ((void *) -1)) could use casts/constructs that need verification for nonstandard behavior. \n- PROT_READ / PROT_WRITE: macros/constants; check they are plain integer macros and do not use compiler extensions. \n- MAP_SHARED / MAP_PRIVATE / MAP_ANONYMOUS: flag macros may be aliases or use platform-specific conditional macros; must verify they are not implemented using compiler extensions. \n- off_t: typedef may be defined via implementation-specific typedefs or attributes (e.g. __extension__, __int128 aliases); inspect for use of nonstandard typedefs. \n- size_t: check typedef origin (stddef.h/sys/types.h) for any implementation-specific extensions. \n- errno: typically a macro that can expand to a function call or thread-local accessor (e.g. __errno_location(), __thread), which are implementation-specific or use compiler extensions; inspect its definition. \n- flock: function prototype/declaration should be inspected for attributes or nonstandard linkage. \n- LOCK_EX / LOCK_UN: macros; confirm they are simple constants. \n- fstat: declaration may include attributes or extension markers. \n- struct stat: layout/typedefs may hide implementation-specific constructs; check headers. \n- ftruncate: function prototype may include nonstandard attributes. \n- Header symbols (sys/mman.h, sys/stat.h, sys/file.h, errno.h, unistd.h): include these headers to inspect the exact macro and prototype definitions \u2014 many extensions are introduced there (inline functions, __attribute__ annotations, __thread, GCC-specific macros). \n\nCollecting these symbols and headers lets the next analyst inspect macro expansions, typedefs, and prototypes for any use of compiler-specific language extensions (double-underscore identifiers, __attribute__, __extension__, __thread, asm, typeof, etc.)."
}