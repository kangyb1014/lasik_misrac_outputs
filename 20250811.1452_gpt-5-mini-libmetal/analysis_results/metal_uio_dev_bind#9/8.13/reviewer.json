{
  "user_message": "An agent A claimed that the following metal_uio_dev_bind code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_bind.\n```c\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n\t\t\t      struct linux_driver *ldrv)\n{\n\tstruct sysfs_attribute *attr;\n\tint result;\n\n\tif (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0)\n\t\treturn 0;\n\n\tif (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n\t\tmetal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n\t\t\t  ldev->dev_name, ldev->sdev->driver_name);\n\t\treturn -EBUSY;\n\t}\n\n\tattr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s has no override\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldrv->drv_name,\n\t\t\t\t       strlen(ldrv->drv_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\",\n\t\t\t  ldev->dev_name);\n\t\treturn -errno;\n\t}\n\tldev->override = attr;\n\n\tattr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n\tif (!attr) {\n\t\tmetal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = sysfs_write_attribute(attr, ldev->dev_name,\n\t\t\t\t       strlen(ldev->dev_name));\n\tif (result) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n\t\t\t  ldev->dev_name, ldrv->drv_name);\n\t\treturn -errno;\n\t}\n\n\tmetal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n\t\t  ldev->dev_name, ldrv->drv_name);\n\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function metal_uio_dev_bind takes a non-const pointer to struct linux_driver (struct linux_driver *ldrv) even though it only reads from the driver structure (reads drv_name and sdrv) and does not modify the driver object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type when possible (i.e., const struct linux_driver *ldrv). The current signature prevents conveying that the function will not modify the driver structure and thus violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_uio_dev_bind(struct linux_device *ldev,\n                              struct linux_driver *ldrv)\n{\n    /* Logging to /tmp/logs/75.txt to trace control path and state for the violation scenario */\n    FILE *log = fopen(\"/tmp/logs/75.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter metal_uio_dev_bind: ldev=%p ldrv=%p dev_name=%s drv_name=%s\\n\",\n                (void *)ldev, (void *)ldrv,\n                (ldev && ldev->dev_name[0]) ? ldev->dev_name : \"(null)\",\n                (ldrv && ldrv->drv_name) ? ldrv->drv_name : \"(null)\");\n    }\n\n    struct sysfs_attribute *attr;\n    int result;\n\n    if (strcmp(ldev->sdev->driver_name, ldrv->drv_name) == 0) {\n        if (log != NULL) {\n            fprintf(log, \"driver already bound: %s == %s -> return 0\\n\",\n                    ldev->sdev->driver_name, ldrv->drv_name);\n            fclose(log);\n        }\n        return 0;\n    }\n\n    if (strcmp(ldev->sdev->driver_name, SYSFS_UNKNOWN) != 0) {\n        if (log != NULL) {\n            fprintf(log, \"device %s in use by driver %s -> -EBUSY\\n\",\n                    ldev->dev_name, ldev->sdev->driver_name);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_INFO, \"device %s in use by driver %s\\n\",\n                  ldev->dev_name, ldev->sdev->driver_name);\n        return -EBUSY;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"attempt to get device override attribute for %s\\n\", ldev->dev_name);\n    }\n\n    attr = sysfs_get_device_attr(ldev->sdev, \"driver_override\");\n    if (!attr) {\n        if (log != NULL) {\n            fprintf(log, \"device %s has no override -> -errno(%d)\\n\", ldev->dev_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"device %s has no override\\n\", ldev->dev_name);\n        return -errno;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"writing driver name '%s' to device override for %s\\n\",\n                ldrv->drv_name, ldev->dev_name);\n    }\n\n    result = sysfs_write_attribute(attr, ldrv->drv_name,\n                                   strlen(ldrv->drv_name));\n    if (result) {\n        if (log != NULL) {\n            fprintf(log, \"failed to set override on %s -> -errno(%d)\\n\", ldev->dev_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to set override on %s\\n\", ldev->dev_name);\n        return -errno;\n    }\n    ldev->override = attr;\n\n    if (log != NULL) {\n        fprintf(log, \"got device override attribute, attempt to get driver bind attribute for %s\\n\", ldrv->drv_name);\n    }\n\n    attr = sysfs_get_driver_attr(ldrv->sdrv, \"bind\");\n    if (!attr) {\n        if (log != NULL) {\n            fprintf(log, \"driver %s has no bind attribute -> -ENOTSUP\\n\", ldrv->drv_name);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"driver %s has no bind\\n\", ldrv->drv_name);\n        return -ENOTSUP;\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"writing device name '%s' to driver bind attribute for %s\\n\",\n                ldev->dev_name, ldrv->drv_name);\n    }\n\n    result = sysfs_write_attribute(attr, ldev->dev_name,\n                                   strlen(ldev->dev_name));\n    if (result) {\n        if (log != NULL) {\n            fprintf(log, \"failed to bind %s to %s -> -errno(%d)\\n\", ldev->dev_name, ldrv->drv_name, errno);\n            fclose(log);\n        }\n        metal_log(METAL_LOG_ERROR, \"failed to bind %s to %s\\n\",\n                  ldev->dev_name, ldrv->drv_name);\n        return -errno;\n    }\n\n    metal_log(METAL_LOG_DEBUG, \"bound device %s to driver %s\\n\",\n              ldev->dev_name, ldrv->drv_name);\n\n    if (log != NULL) {\n        fprintf(log, \"bound device %s to driver %s -> return 0\\n\",\n                ldev->dev_name, ldrv->drv_name);\n        fclose(log);\n    }\n\n    return 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_bind. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is essentially correct. In the body of metal_uio_dev_bind the parameter ldrv is only read (drv_name and sdrv are accessed, and their contents are passed to other functions); the function does not modify the driver object or any of its members. Under MISRA C:2023 Rule 8.13 a pointer parameter should be const-qualified when possible, so the signature could and should be changed to const struct linux_driver *ldrv (or otherwise the code should justify why it cannot be const).\n\nOne caveat: if metal_uio_dev_bind must match an external API or callback prototype that requires a non-const struct linux_driver * (so you cannot change the signature), then the present non-const parameter is necessary and the rule can be considered deliberately not applicable (and should be documented as a deviation). Absent such an external constraint, the current code is a violation of Rule 8.13 and should be fixed by adding the const qualification or documenting/justifying the deviation."
}