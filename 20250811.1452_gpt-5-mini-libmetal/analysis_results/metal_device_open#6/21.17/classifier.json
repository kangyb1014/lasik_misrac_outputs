{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_device_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/55.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_device_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_device_open:\n```c\nint metal_device_open(const char *bus_name, const char *dev_name,\n\t\t      struct metal_device **device)\n{\n\tstruct metal_bus *bus;\n\tint error;\n\n\tif (!bus_name || !strlen(bus_name) ||\n\t    !dev_name || !strlen(dev_name) ||\n\t    !device)\n\t\treturn -EINVAL;\n\n\terror = metal_bus_find(bus_name, &bus);\n\tif (error)\n\t\treturn error;\n\n\tif (!bus->ops.dev_open)\n\t\treturn -ENODEV;\n\n\terror = (*bus->ops.dev_open)(bus, dev_name, device);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_device_open:\nint metal_bus_find(const char *name, struct metal_bus **result)\n{\n\tstruct metal_list *node;\n\tstruct metal_bus *bus;\n\n\tmetal_list_for_each(&_metal.common.bus_list, node) {\n\t\tbus = metal_container_of(node, struct metal_bus, node);\n\t\tif (strcmp(bus->name, name) == 0 && result) {\n\t\t\t*result = bus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n...\nstruct metal_bus {\n\tconst char\t\t*name;\n\tstruct metal_bus_ops\tops;\n\tstruct metal_list\tdevices;\n\tstruct metal_list\tnode;\n}\n</additional code>\nJudge whether the above metal_device_open code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Violation: metal_device_open calls strlen(bus_name) and strlen(dev_name) without any guarantee that the pointers refer to NUL-terminated character arrays. If a caller passes a non-NULL pointer to a character buffer that is not NUL-terminated (for example a fixed-size buffer filled but missing '\\0'), strlen will read past the bounds of the buffer causing an out-of-bounds access. Example concrete scenario: char buf[3] = {'b','u','s'}; /* no NUL */ metal_device_open(buf, \"dev\", &dev); The strlen(bus_name) call will scan beyond buf and can read out-of-bounds, violating MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stddef.h>\n\n/* Forward declarations/definitions required to keep original logic. */\nstruct metal_device;\nstruct metal_bus;\nstruct metal_bus_ops {\n    int (*dev_open)(struct metal_bus *bus, const char *name,\n                    struct metal_device **device);\n};\nstruct metal_bus {\n    const char *name;\n    struct metal_bus_ops ops;\n};\n\nint metal_bus_find(const char *name, struct metal_bus **result);\n\n/* Simple logging helper that appends information to /tmp/logs/55.txt. */\nstatic void log_append(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint metal_device_open(const char *bus_name, const char *dev_name,\n                      struct metal_device **device)\n{\n    struct metal_bus *bus;\n    int error;\n    size_t len_bus;\n    size_t len_dev;\n\n    log_append(\"enter metal_device_open: bus_name=%p dev_name=%p device=%p\",\n               (const void *)bus_name, (const void *)dev_name,\n               (const void *)device);\n\n    /* Preserve the original checks but split them so we can log state. */\n    if (bus_name == NULL) {\n        log_append(\"reject: bus_name is NULL\");\n        return -EINVAL;\n    }\n\n    /* The following strlen calls are the ones that can access beyond bounds\n       if the provided pointers are not NUL-terminated. This reproduces the\n       original behavior and demonstrates the potential out-of-bounds access. */\n    log_append(\"about to call strlen(bus_name) on %p\", (const void *)bus_name);\n    len_bus = strlen(bus_name);\n    log_append(\"strlen(bus_name) = %zu\", len_bus);\n    if (len_bus == 0) {\n        log_append(\"reject: bus_name is empty\");\n        return -EINVAL;\n    }\n\n    if (dev_name == NULL) {\n        log_append(\"reject: dev_name is NULL\");\n        return -EINVAL;\n    }\n\n    log_append(\"about to call strlen(dev_name) on %p\", (const void *)dev_name);\n    len_dev = strlen(dev_name);\n    log_append(\"strlen(dev_name) = %zu\", len_dev);\n    if (len_dev == 0) {\n        log_append(\"reject: dev_name is empty\");\n        return -EINVAL;\n    }\n\n    if (device == NULL) {\n        log_append(\"reject: device pointer is NULL\");\n        return -EINVAL;\n    }\n\n    log_append(\"calling metal_bus_find('%s')\", bus_name);\n    error = metal_bus_find(bus_name, &bus);\n    log_append(\"metal_bus_find returned %d, bus=%p\", error, (void *)bus);\n    if (error) {\n        return error;\n    }\n\n    if (!bus->ops.dev_open) {\n        log_append(\"reject: bus->ops.dev_open is NULL\");\n        return -ENODEV;\n    }\n\n    log_append(\"calling bus->ops.dev_open for dev_name='%s'\", dev_name);\n    error = (*bus->ops.dev_open)(bus, dev_name, device);\n    log_append(\"bus->ops.dev_open returned %d, device=%p\", error,\n               (void *)(device ? *device : NULL));\n    if (error) {\n        return error;\n    }\n\n    log_append(\"metal_device_open: success\");\n    return 0;\n}\n"
}