{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_register_generic_device code that contains useful probe functions that print useful logs to a file \"/tmp/logs/63.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_register_generic_device as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_register_generic_device:\n```c\nint metal_register_generic_device(struct metal_device *device)\n{\n\tif (!device->name || !strlen(device->name) ||\n\t    device->num_regions > METAL_MAX_DEVICE_REGIONS)\n\t\treturn -EINVAL;\n\n\tdevice->bus = &metal_generic_bus;\n\tmetal_list_add_tail(&_metal.common.generic_device_list,\n\t\t\t    &device->node);\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_register_generic_device:\nint metal_irq_register_controller(struct metal_irq_controller *cntr)\n{\n\tint irq_base;\n\tstruct metal_list *node;\n\n\tif (cntr == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tif (node == &cntr->node) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Allocate IRQ numbers which are not yet used by any IRQ\n\t * controllers.\n\t */\n\tirq_base = metal_irq_allocate(cntr->irq_base, cntr->irq_num);\n\tif (irq_base == METAL_IRQ_ANY) {\n\t\treturn -EINVAL;\n\t}\n\tcntr->irq_base = irq_base;\n\n\tmetal_list_add_tail(&irq_cntrs, &cntr->node);\n\treturn 0;\n}\n</additional code>\nJudge whether the above metal_register_generic_device code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Violation occurs when device->name is non-NULL but not NUL-terminated (or points to a buffer shorter than the actual string), so the strlen(device->name) call may read past the end of the object and cause an out-of-bounds access.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <errno.h>\n\n/* Minimal supporting types and state to make the function compilable. */\nstruct metal_list {\n    struct metal_list *next;\n};\n\nstruct metal_bus {\n    int placeholder;\n};\n\nstruct metal_device {\n    const char *name;\n    int num_regions;\n    struct metal_bus *bus;\n    struct metal_list node;\n};\n\n/* Global objects used by the original function. */\nenum { METAL_MAX_DEVICE_REGIONS = 16 };\nstatic struct metal_bus metal_generic_bus = { 0 };\nstatic struct {\n    struct {\n        struct metal_list generic_device_list;\n    } common;\n} _metal = { { { NULL } } };\n\n/* Minimal list helper to preserve original logic. */\nvoid metal_list_add_tail(struct metal_list *head, struct metal_list *node)\n{\n    /* Simple singly-linked insertion at head for test purposes. */\n    node->next = head->next;\n    head->next = node;\n}\n\n/* Modified metal_register_generic_device with logging probes to /tmp/logs/63.txt.\n   Preserves the original logic (strlen usage) while adding logging. */\nint metal_register_generic_device(struct metal_device *device)\n{\n    FILE *log = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter metal_register_generic_device: device=%p\\n\", (void *)device);\n    }\n\n    if (device == NULL) {\n        if (log != NULL) {\n            fprintf(log, \"device == NULL -> return -EINVAL\\n\");\n            fclose(log);\n        }\n        return -EINVAL;\n    }\n\n    if (device->name == NULL) {\n        if (log != NULL) {\n            fprintf(log, \"device->name == NULL\\n\");\n        }\n    } else {\n        /* This reproduces the original check that may be unsafe if the\n           caller provided a non-NUL-terminated buffer for device->name. */\n        size_t len = strlen(device->name);\n        if (log != NULL) {\n            fprintf(log, \"device->name=%p strlen=%zu\\n\", (const void *)device->name, len);\n        }\n    }\n\n    /* Original compound condition retained. Note: the strlen calls here are\n       exactly those that can cause an out-of-bounds access if name is not\n       NUL-terminated. This is the violation scenario for MISRA C 2023 Rule 21.17. */\n    if (!device->name || !strlen(device->name) || device->num_regions > METAL_MAX_DEVICE_REGIONS) {\n        if (log != NULL) {\n            fprintf(log, \"validation failed: name=%p num_regions=%d -> return -EINVAL\\n\",\n                    (const void *)device->name, device->num_regions);\n            fclose(log);\n        }\n        return -EINVAL;\n    }\n\n    device->bus = &metal_generic_bus;\n    metal_list_add_tail(&_metal.common.generic_device_list, &device->node);\n\n    if (log != NULL) {\n        fprintf(log, \"device registered: name=%p num_regions=%d\\n\", (const void *)device->name, device->num_regions);\n        fclose(log);\n    }\n    return 0;\n}\n"
}