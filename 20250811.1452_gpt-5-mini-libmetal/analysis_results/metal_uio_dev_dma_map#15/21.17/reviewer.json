{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the caller passes sg_out pointing to an array that contains fewer than nents_in elements, the memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) will write past the end of the sg_out object. For example, if nents_in == 5 but sg_out points to an array of 3 struct metal_sg entries, the memcpy will overflow sg_out and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct metal_io_region;\nstruct metal_sg;\nstruct device_container {\n    struct metal_io_region *regions;\n    size_t num_regions;\n};\nstatic void logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/127.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* use char* for pointer arithmetic to be standard-conforming */\n        vaddr_sg_lo = (char *)sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + (size_t)sg_in[i].len;\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the failing input address and length */\n            logf(\"%s,%s: input address isn't MMIO addr: vaddr=0x%p, len=%d\\n\",\n                 __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* Log detailed state before performing memcpy so a test harness\n           can detect overflow scenarios: addresses, element count, bytes */\n        size_t bytes = (size_t)nents_in * sizeof(struct metal_sg);\n        logf(\"%s: preparing to memcpy from sg_in=0x%p to sg_out=0x%p, nents_in=%d, bytes=%zu\\n\",\n             __func__, (void *)sg_in, (void *)sg_out, nents_in, bytes);\n\n        /* Perform the copy identical to original logic */\n        memcpy(sg_out, sg_in, bytes);\n\n        /* Log after memcpy to show completion of the control path */\n        logf(\"%s: memcpy completed\\n\", __func__);\n    }\n    return nents_in;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 21.17 requires that uses of memcpy (and other <string.h> functions) must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the shown function the call memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) is performed without any check that the object pointed to by sg_out is large enough to receive nents_in elements. Therefore, if a caller supplies an sg_out buffer that contains fewer than nents_in elements, the memcpy will write past the end of that object, violating Rule 21.17. (A similar risk exists for sg_in if it does not actually contain nents_in elements, although the earlier loop does access sg_in up to nents_in\u20131 which already presumes sg_in is large enough.) If there is an external API contract guaranteeing sg_out has at least nents_in elements, that contract must be enforced or documented; otherwise the function should verify the destination size before calling memcpy to be compliant."
}