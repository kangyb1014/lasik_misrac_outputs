{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_uio_dev_dma_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/123.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_uio_dev_dma_map:\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_uio_dev_dma_map:\nstruct metal_sg {\n\tvoid *virt; /**< CPU virtual address */\n\tstruct metal_io_region *io; /**< IO region */\n\tint len; /**< length */\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\nJudge whether the above metal_uio_dev_dma_map code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The function metal_uio_dev_dma_map takes a non-const pointer parameter struct metal_sg *sg_in and uses the pointed-to pointers (sg_in[i].virt and io->virt) only for read-only address comparisons. The function does not modify the objects pointed to by sg_in or by the region->virt pointers. Per MISRA C 2023 Rule 8.13, pointers should point to const-qualified types whenever possible; thus sg_in (and the local address pointers) should be const-qualified. This is a specific violation: sg_in should be declared as const struct metal_sg *sg_in (and related virt members could be const void *), because the function only reads from them and never modifies them.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n\n/* Minimal type definitions required for compilation. */\ntypedef unsigned long metal_phys_addr_t;\nstruct metal_io_ops { /* empty; preserved as in original context */ };\n\nstruct metal_io_region {\n    void                    *virt;      /* base virtual address */\n    const metal_phys_addr_t *physmap;   /* table of base physical addresses */\n    size_t                  size;       /* size of the I/O region */\n    unsigned long           page_shift;\n    metal_phys_addr_t       page_mask;\n    unsigned int            mem_flags;\n    struct metal_io_ops     ops;\n};\n\nstruct metal_sg {\n    void *virt;                  /* CPU virtual address */\n    struct metal_io_region *io;  /* IO region */\n    int len;                     /* length */\n};\n\nstruct linux_device {\n    const char *dev_name;\n    struct {\n        struct metal_io_region *regions;\n        unsigned int num_regions;\n    } device;\n};\n\nstruct linux_bus { /* unused in this function */ };\n\n/*\n * Modified metal_uio_dev_dma_map that preserves the original logic but\n * emits detailed logs to /tmp/logs/123.txt to demonstrate the violation\n * scenario: sg_in is non-const although only read.\n *\n * Note: No main() is defined.\n */\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    /* Use char * for address arithmetic while preserving original logic */\n    void *vaddr_sg_lo = NULL;\n    void *vaddr_sg_hi = NULL;\n    void *vaddr_lo = NULL;\n    void *vaddr_hi = NULL;\n    struct metal_io_region *io;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Open log file to record the control path and state information */\n    FILE *log = fopen(\"/tmp/logs/123.txt\", \"a\");\n    if (log != NULL) {\n        fprintf(log, \"enter: %s, dev=%s, nents_in=%d\\n\", __func__,\n                (ldev != NULL) ? ldev->dev_name : \"(null)\", nents_in);\n    }\n\n    /* Check if the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* preserve original semantics: compute start and end addresses */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = (char *)vaddr_sg_lo + sg_in[i].len;\n\n        if (log != NULL) {\n            fprintf(log, \"sg[%d]: virt=%p, len=%d, roi=[%p,%p)\\n\",\n                    i, vaddr_sg_lo, sg_in[i].len, vaddr_sg_lo, vaddr_sg_hi);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = (char *)vaddr_lo + io->size;\n\n            if (log != NULL) {\n                fprintf(log, \"  region[%d]: virt=%p, size=%zu, r=[%p,%p)\\n\",\n                        j, vaddr_lo, io->size, vaddr_lo, vaddr_hi);\n            }\n\n            if (vaddr_sg_lo >= vaddr_lo && vaddr_sg_hi <= vaddr_hi) {\n                if (log != NULL) {\n                    fprintf(log, \"  match: sg[%d] in region[%d]\\n\", i, j);\n                }\n                break;\n            }\n        }\n\n        if (j == (int)ldev->device.num_regions) {\n            /* Log the warning and the failing addresses */\n            if (log != NULL) {\n                fprintf(log, \"warning: %s,%s: input address isn't MMIO addr: %p,%d.\\n\",\n                        __func__, (ldev != NULL) ? ldev->dev_name : \"(null)\",\n                        vaddr_sg_lo, sg_in[i].len);\n                /* Also log that sg_in was only read and not modified, demonstrating\n                 * that sg_in could be const-qualified (MISRA C Rule 8.13 scenario).\n                 */\n                fprintf(log, \"note: sg_in was not modified by %s; parameter is non-const -> Rule 8.13 violation scenario.\\n\",\n                        __func__);\n                fclose(log);\n            }\n            return -EINVAL;\n        }\n    }\n\n    if (sg_out != sg_in) {\n        /* preserve original behavior: copy descriptors */\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n        if (log != NULL) {\n            fprintf(log, \"copied %d sg descriptors from %p to %p\\n\",\n                    nents_in, (void *)sg_in, (void *)sg_out);\n        }\n    }\n\n    if (log != NULL) {\n        fprintf(log, \"exit: %s returning %d\\n\", __func__, nents_in);\n        fclose(log);\n    }\n\n    return nents_in;\n}\n"
}