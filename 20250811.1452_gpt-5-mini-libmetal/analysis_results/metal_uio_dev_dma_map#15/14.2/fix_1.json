{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct metal_io_region {\n    void            *virt;\n    const void      *physmap;\n    size_t           size;\n    unsigned long    page_shift;\n    unsigned long    page_mask;\n    unsigned int     mem_flags;\n    void             *ops;\n};\nstruct metal_sg {\n    void *virt; /**< CPU virtual address */\n    struct metal_io_region *io; /**< IO region */\n    int len; /**< length */\n};\nstruct device_struct {\n    struct metal_io_region *regions;\n    unsigned int num_regions;\n};\nextern void metal_log(int level, const char *fmt, ...);\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n    FILE *log = fopen(\"/tmp/logs/124.txt\", \"a\");\n\n    (void)lbus;\n    (void)dir;\n\n    if (log) {\n        fprintf(log, \"metal_uio_dev_dma_map: enter nents_in=%d\\n\", nents_in);\n    }\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n        if (log) {\n            fprintf(log, \"outer: i=%d, sg.virt=%p, sg.len=%d, vaddr_sg_lo=%p, vaddr_sg_hi=%p\\n\",\n                    i, sg_in[i].virt, sg_in[i].len, vaddr_sg_lo, vaddr_sg_hi);\n        }\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            if (log) {\n                fprintf(log, \"  inner: j=%d, io=%p, vaddr_lo=%p, vaddr_hi=%p\\n\",\n                        j, (void *)io, vaddr_lo, vaddr_hi);\n            }\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                if (log) {\n                    fprintf(log, \"  inner: match at j=%d, breaking\\n\", j);\n                }\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            if (log) {\n                fprintf(log, \"no region match for sg[%d]: virt=%p len=%d, returning -EINVAL\\n\",\n                        i, vaddr_sg_lo, sg_in[i].len);\n                fclose(log);\n            }\n            metal_log(0,\n              \"%s,%s: input address isn't MMIO addr: %p,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\n    if (log) {\n        fprintf(log, \"metal_uio_dev_dma_map: exit returning %d\\n\", nents_in);\n        fclose(log);\n    }\n    return nents_in;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\n/tmp/tmprx538y9h/src/lib/system/linux/device.c:319:8: error: redefinition of 'struct metal_io_region'\n  319 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\nIn file included from /tmp/tmprx538y9h/build/lib/include/metal/device.h:16,\n                 from /tmp/tmprx538y9h/src/lib/system/linux/device.c:20:\n/tmp/tmprx538y9h/build/lib/include/metal/io.h:73:8: note: originally defined here\n   73 | struct metal_io_region {\n      |        ^~~~~~~~~~~~~~~\n/tmp/tmprx538y9h/src/lib/system/linux/device.c:328:8: error: redefinition of 'struct metal_sg'\n  328 | struct metal_sg {\n      |        ^~~~~~~~\nIn file included from /tmp/tmprx538y9h/build/lib/include/metal/device.h:18,\n                 from /tmp/tmprx538y9h/src/lib/system/linux/device.c:20:\n/tmp/tmprx538y9h/build/lib/include/metal/dma.h:33:8: note: originally defined here\n   33 | struct metal_sg {\n      |        ^~~~~~~~\nIn file included from /tmp/tmprx538y9h/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmprx538y9h/build/lib/include/metal/io.h:22,\n                 from /tmp/tmprx538y9h/build/lib/include/metal/device.h:16,\n                 from /tmp/tmprx538y9h/src/lib/system/linux/device.c:20:\n/tmp/tmprx538y9h/build/lib/include/metal/log.h:98:37: error: expected identifier or '(' before '{' token\n   98 | #define metal_log(level, fmt, ...) ({                              \\\n      |                                     ^\n/tmp/tmprx538y9h/src/lib/system/linux/device.c:337:13: note: in expansion of macro 'metal_log'\n  337 | extern void metal_log(int level, const char *fmt, ...);\n      |             ^~~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:216: lib/CMakeFiles/metal-shared.dir/system/linux/device.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_uio_dev_dma_map as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n/*\n * NOTE: removed local re-definitions of struct metal_io_region, struct metal_sg,\n * and struct device_struct to avoid redefinition conflicts with the project's\n * headers (these are provided by included project headers elsewhere in the\n * translation unit). Also removed a local extern declaration for metal_log since\n * the project headers define metal_log (possibly as a macro) and a redeclaration\n * conflicts with that definition.\n */\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                 struct linux_device *ldev,\n                 uint32_t dir,\n                 struct metal_sg *sg_in,\n                 int nents_in,\n                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n    FILE *log = fopen(\"/tmp/logs/124.txt\", \"a\");\n\n    (void)lbus;\n    (void)dir;\n\n    if (log) {\n        fprintf(log, \"metal_uio_dev_dma_map: enter nents_in=%d\\n\", nents_in);\n    }\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n        if (log) {\n            fprintf(log, \"outer: i=%d, sg.virt=%p, sg.len=%d, vaddr_sg_lo=%p, vaddr_sg_hi=%p\\n\",\n                    i, sg_in[i].virt, sg_in[i].len, vaddr_sg_lo, vaddr_sg_hi);\n        }\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            if (log) {\n                fprintf(log, \"  inner: j=%d, io=%p, vaddr_lo=%p, vaddr_hi=%p\\n\",\n                        j, (void *)io, vaddr_lo, vaddr_hi);\n            }\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                if (log) {\n                    fprintf(log, \"  inner: match at j=%d, breaking\\n\", j);\n                }\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            if (log) {\n                fprintf(log, \"no region match for sg[%d]: virt=%p len=%d, returning -EINVAL\\n\",\n                        i, vaddr_sg_lo, sg_in[i].len);\n                fclose(log);\n            }\n            /* use project's metal_log (do not redeclare it here) */\n            metal_log(0,\n              \"%s,%s: input address isn't MMIO addr: %p,%d.\\n\",\n            __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\n    if (log) {\n        fprintf(log, \"metal_uio_dev_dma_map: exit returning %d\\n\", nents_in);\n        fclose(log);\n    }\n    return nents_in;\n}\n",
  "explanation": "I removed the local re-definitions of struct metal_io_region, struct metal_sg, and struct device_struct because those types are already defined in the project's headers and the duplicate definitions caused redefinition errors. I also removed the local extern declaration for metal_log since the project's headers define it (possibly as a macro), and redeclaring it caused a conflict. I added standard includes (stdio.h, string.h, stdint.h, errno.h) needed for functions and macros used in the function. The original logic of metal_uio_dev_dma_map is preserved."
}