{
  "user_message": "An agent A claimed that the following metal_uio_dev_dma_map code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of metal_uio_dev_dma_map.\n```c\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n\t\t\t\t struct linux_device *ldev,\n\t\t\t\t uint32_t dir,\n\t\t\t\t struct metal_sg *sg_in,\n\t\t\t\t int nents_in,\n\t\t\t\t struct metal_sg *sg_out)\n{\n\tint i, j;\n\tvoid *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n\tstruct metal_io_region *io;\n\n\t(void)lbus;\n\t(void)dir;\n\n\t/* Check if the the input virt address is MMIO address */\n\tfor (i = 0; i < nents_in; i++) {\n\t\tvaddr_sg_lo = sg_in[i].virt;\n\t\tvaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\t\tfor (j = 0, io = ldev->device.regions;\n\t\t     j < (int)ldev->device.num_regions; j++, io++) {\n\t\t\tvaddr_lo = io->virt;\n\t\t\tvaddr_hi = vaddr_lo + io->size;\n\t\t\tif (vaddr_sg_lo >= vaddr_lo &&\n\t\t\t    vaddr_sg_hi <= vaddr_hi) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == (int)ldev->device.num_regions) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n\t\t\t__func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\treturn nents_in;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code performs pointer arithmetic on void* objects (e.g. vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len; and vaddr_hi = vaddr_lo + io->size;). Pointer arithmetic on void* is a compiler language extension in many toolchains (GNU C treats void* arithmetic as bytewise), so the source uses a language extension and thus violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int metal_uio_dev_dma_map(struct linux_bus *lbus,\n                                 struct linux_device *ldev,\n                                 uint32_t dir,\n                                 struct metal_sg *sg_in,\n                                 int nents_in,\n                                 struct metal_sg *sg_out)\n{\n    int i, j;\n    void *vaddr_sg_lo, *vaddr_sg_hi, *vaddr_lo, *vaddr_hi;\n    struct metal_io_region *io;\n    FILE *log = NULL;\n\n    (void)lbus;\n    (void)dir;\n\n    /* Open log file to record control path and state for the violation scenario */\n    log = fopen(\"/tmp/logs/120.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"ENTER %s: dev=%s, nents_in=%d\\n\",\n                __func__, (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\", nents_in);\n    }\n\n    /* Check if the the input virt address is MMIO address */\n    for (i = 0; i < nents_in; i++) {\n        /* The following pointer arithmetic on void* is a compiler extension\n           (used here to reproduce the violation scenario). */\n        vaddr_sg_lo = sg_in[i].virt;\n        vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len;\n\n        if (log) {\n            fprintf(log, \"sg[%d]: virt=%p, len=%d, computed_hi=%p\\n\",\n                    i, (void *)vaddr_sg_lo, sg_in[i].len, (void *)vaddr_sg_hi);\n        }\n\n        for (j = 0, io = ldev->device.regions;\n             j < (int)ldev->device.num_regions; j++, io++) {\n            vaddr_lo = io->virt;\n            vaddr_hi = vaddr_lo + io->size;\n            if (log) {\n                fprintf(log, \"  region[%d]: base=%p, size=%zu, hi=%p\\n\",\n                        j, (void *)vaddr_lo, io->size, (void *)vaddr_hi);\n            }\n            if (vaddr_sg_lo >= vaddr_lo &&\n                vaddr_sg_hi <= vaddr_hi) {\n                if (log) {\n                    fprintf(log, \"  sg[%d] is within region[%d]\\n\", i, j);\n                }\n                break;\n            }\n        }\n        if (j == (int)ldev->device.num_regions) {\n            if (log) {\n                fprintf(log, \"WARNING: %s,%s: input address isn't MMIO addr: sg_index=%d, virt=%p, len=%d\\n\",\n                        __func__, (ldev && ldev->dev_name) ? ldev->dev_name : \"(null)\",\n                        i, (void *)vaddr_sg_lo, sg_in[i].len);\n            }\n            if (log) fclose(log);\n            metal_log(METAL_LOG_WARNING,\n                      \"%s,%s: input address isn't MMIO addr: 0x%x,%d.\\n\",\n                      __func__, ldev->dev_name, vaddr_sg_lo, sg_in[i].len);\n            return -EINVAL;\n        }\n    }\n    if (sg_out != sg_in)\n        memcpy(sg_out, sg_in, nents_in * (sizeof(struct metal_sg)));\n\n    if (log) {\n        fprintf(log, \"EXIT %s: returning %d\\n\", __func__, nents_in);\n        fclose(log);\n    }\n    return nents_in;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for metal_uio_dev_dma_map. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code performs pointer arithmetic on objects of type void* (vaddr_sg_hi = vaddr_sg_lo + sg_in[i].len; and vaddr_hi = vaddr_lo + io->size;). Pointer arithmetic on void* is not allowed by standard C (void is an incomplete type), and many toolchains (including GCC) provide void* arithmetic as a documented compiler extension. MISRA C 2023 Rule 1.2 forbids using language extensions that are explicitly documented as such, so this use violates the rule. The fact the test code compiled simply means the compiler used supports that extension; to conform to MISRA the code should be changed to use a character-pointer type (e.g. (char *) or (uint8_t *)) for byte-wise address arithmetic or otherwise avoid the compiler extension."
}