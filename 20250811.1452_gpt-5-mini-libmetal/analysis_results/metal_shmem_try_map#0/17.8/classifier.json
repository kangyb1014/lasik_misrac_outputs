{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified metal_shmem_try_map code that contains useful probe functions that print useful logs to a file \"/tmp/logs/5.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_shmem_try_map as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of metal_shmem_try_map:\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\n#define metal_align_up(size, align) metal_align_down((size)+(align)-1,align)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic const struct metal_io_ops metal_shmem_io_ops = {\n\tNULL, NULL, NULL, NULL, NULL, metal_shmem_io_close, NULL, NULL\n}\n...\n#define METAL_BAD_OFFSET ((unsignedlong)-1)\n...\ntypedef unsigned long metal_phys_addr_t\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n</additional code>\nJudge whether the above metal_shmem_try_map code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function modifies the value of the scalar parameter 'size' (assigning to the parameter variable: size = metal_align_up(size, ps->page_size);). MISRA C 2023 Rule 17.8 forbids modifying function parameters; modifying a pointer parameter itself is forbidden (the object pointed-to may be modified), and modifying scalar parameters is also disallowed. Thus this is a violation.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <stddef.h>\n\ntypedef unsigned long metal_phys_addr_t;\n\nstruct metal_io_ops { /* opaque for this test */ };\n\nstruct metal_page_size {\n    size_t page_size;\n    unsigned long page_shift;\n    int mmap_flags;\n};\n\nstruct metal_io_region {\n    void *virt;\n    const metal_phys_addr_t *physmap;\n    size_t size;\n    unsigned long page_shift;\n    metal_phys_addr_t page_mask;\n    unsigned int mem_flags;\n    struct metal_io_ops ops;\n};\n\n/* External symbols used by the function; declared but not defined here. */\nextern int metal_map(int fd, off_t off, size_t size, int prot, int flags, void **mem);\nextern void metal_unmap(void *mem, size_t size);\nextern int metal_virt2phys(void *vaddr, metal_phys_addr_t *pphys);\nextern void metal_io_init(struct metal_io_region *io, void *mem, metal_phys_addr_t *phys,\n                          size_t size, unsigned long page_shift, unsigned int mem_flags,\n                          const struct metal_io_ops *ops);\nextern const struct metal_io_ops metal_shmem_io_ops;\nextern struct { int pagemap_fd; } _metal;\n\n/* Provide a sentinel value matching the original semantics. */\nstatic const metal_phys_addr_t METAL_BAD_OFFSET = (metal_phys_addr_t)-1;\n\n/* The instrumented function. Logs control flow and key state to \"/tmp/logs/5.txt\". */\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n                               struct metal_io_region **result)\n{\n    FILE *log = fopen(\"/tmp/logs/5.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"enter metal_shmem_try_map: fd=%d, size=%zu, page_size=%zu, pagemap_fd=%d\\n\",\n                fd, size, ps ? ps->page_size : 0, _metal.pagemap_fd);\n    }\n\n    size_t pages, page, phys_size;\n    struct metal_io_region *io;\n    metal_phys_addr_t *phys;\n    uint8_t *virt;\n    void *mem;\n    int error;\n\n    /* Violation: modifying the scalar parameter 'size' */\n    if (log) fprintf(log, \"original size=%zu\\n\", size);\n    size = ((size + ps->page_size - 1) / ps->page_size) * ps->page_size; /* same effect as metal_align_up */\n    if (log) fprintf(log, \"aligned size=%zu (page_size=%zu)\\n\", size, ps->page_size);\n\n    pages = size / ps->page_size;\n    if (log) fprintf(log, \"pages=%zu\\n\", pages);\n\n    error = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n    if (error) {\n        if (log) fprintf(log, \"metal_map failed: error=%d\\n\", error);\n        if (log) fclose(log);\n        return error;\n    }\n    if (log) fprintf(log, \"metal_map succeeded: mem=%p\\n\", mem);\n\n    error = mlock(mem, size);\n    if (error) {\n        if (log) fprintf(log, \"mlock failed: errno=%d (%s)\\n\", errno, strerror(errno));\n    } else {\n        if (log) fprintf(log, \"mlock succeeded\\n\");\n    }\n\n    phys_size = sizeof(*phys) * pages;\n    phys = malloc(phys_size);\n    if (!phys) {\n        if (log) fprintf(log, \"malloc for phys failed (size=%zu)\\n\", phys_size);\n        metal_unmap(mem, size);\n        if (log) fclose(log);\n        return -ENOMEM;\n    }\n    if (log) fprintf(log, \"allocated phys array at %p (bytes=%zu)\\n\", (void*)phys, phys_size);\n\n    io = malloc(sizeof(*io));\n    if (!io) {\n        if (log) fprintf(log, \"malloc for io failed (size=%zu)\\n\", sizeof(*io));\n        free(phys);\n        metal_unmap(mem, size);\n        if (log) fclose(log);\n        return -ENOMEM;\n    }\n    if (log) fprintf(log, \"allocated io region at %p\\n\", (void*)io);\n\n    if (_metal.pagemap_fd < 0) {\n        phys[0] = 0;\n        if (log) fprintf(log, \"pagemap_fd < 0: using offsets as phys[0]=0\\n\");\n        metal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n    } else {\n        for (virt = mem, page = 0; page < pages; page++) {\n            size_t offset = page * ps->page_size;\n\n            error = metal_virt2phys(virt + offset, &phys[page]);\n            if (error < 0) {\n                phys[page] = METAL_BAD_OFFSET;\n                if (log) fprintf(log, \"virt2phys failed for page %zu -> BAD_OFFSET\\n\", page);\n            } else {\n                if (log) fprintf(log, \"virt2phys: page %zu -> phys[%zu]=%lu\\n\", page, page, (unsigned long)phys[page]);\n            }\n        }\n        metal_io_init(io, mem, phys, size, ps->page_shift, 0, &metal_shmem_io_ops);\n    }\n\n    *result = io;\n    if (log) fprintf(log, \"mapping complete: io=%p, result set\\n\", (void*)io);\n\n    if (log) fclose(log);\n    return 0;\n}\n"
}