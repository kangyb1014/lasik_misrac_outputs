{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function modifies the value of the scalar parameter 'size' (assigning to the parameter variable: size = metal_align_up(size, ps->page_size);). MISRA C 2023 Rule 17.8 forbids modifying function parameters; modifying a pointer parameter itself is forbidden (the object pointed-to may be modified), and modifying scalar parameters is also disallowed. Thus this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct metal_page_size;\nstruct metal_io_region;\nstruct metal_state;\nextern int metal_map(int fd, off_t off, size_t size, int prot, int flags, void **mem);\nextern int metal_unmap(void *mem, size_t size);\nextern void metal_io_init(struct metal_io_region *io, void *virt,\n                          const unsigned long *phys, size_t size,\n                          unsigned int page_shift, unsigned int mem_flags,\n                          const struct metal_io_ops *ops);\nextern struct metal_state _metal;\n\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n                               struct metal_io_region **result)\n{\n    FILE *log = fopen(\"/tmp/logs/5.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"enter metal_shmem_try_map: fd=%d, size=%zu, page_size=%zu, pagemap_fd=?\\n\",\n                fd, size, ps ? ps->page_size : 0);\n    }\n\n    size_t pages, page, phys_size;\n    struct metal_io_region *io;\n    unsigned long *phys;\n    uint8_t *virt;\n    void *mem;\n    int error;\n\n    /* Align size up to page size (same effect as metal_align_up). */\n    if (log) fprintf(log, \"original size=%zu\\n\", size);\n    size = ((size + ps->page_size - 1) / ps->page_size) * ps->page_size;\n    if (log) fprintf(log, \"aligned size=%zu (page_size=%zu)\\n\", size, ps->page_size);\n\n    pages = size / ps->page_size;\n    if (log) fprintf(log, \"pages=%zu\\n\", pages);\n\n    error = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n    if (error) {\n        if (log) fprintf(log, \"metal_map failed: error=%d\\n\", error);\n        if (log) fclose(log);\n        return error;\n    }\n    if (log) fprintf(log, \"metal_map succeeded: mem=%p\\n\", mem);\n\n    error = mlock(mem, size);\n    if (error) {\n        if (log) fprintf(log, \"mlock failed: errno=%d (%s)\\n\", errno, strerror(errno));\n    } else {\n        if (log) fprintf(log, \"mlock succeeded\\n\");\n    }\n\n    phys_size = sizeof(*phys) * pages;\n    phys = malloc(phys_size);\n    if (!phys) {\n        if (log) fprintf(log, \"malloc for phys failed (size=%zu)\\n\", phys_size);\n        metal_unmap(mem, size);\n        if (log) fclose(log);\n        return -ENOMEM;\n    }\n    if (log) fprintf(log, \"allocated phys array at %p (bytes=%zu)\\n\", (void*)phys, phys_size);\n\n    io = malloc(sizeof(*io));\n    if (!io) {\n        if (log) fprintf(log, \"malloc for io failed (size=%zu)\\n\", sizeof(*io));\n        free(phys);\n        metal_unmap(mem, size);\n        if (log) fclose(log);\n        return -ENOMEM;\n    }\n    if (log) fprintf(log, \"allocated io region at %p\\n\", (void*)io);\n\n    /* If the pagemap fd is not available, fall back to zero offsets. */\n    /* Note: _metal is declared externally; use its fields as provided by\n       the project's headers/definitions. We avoid redeclaring _metal here. */\n    /* Use the METAL_BAD_OFFSET macro from the project's headers where needed. */\n\n    if (_metal.pagemap_fd < 0) {\n        phys[0] = 0;\n        if (log) fprintf(log, \"pagemap_fd < 0: using offsets as phys[0]=0\\n\");\n        metal_io_init(io, mem, phys, size, (unsigned int)-1, 0, &metal_shmem_io_ops);\n    } else {\n        for (virt = (uint8_t *)mem, page = 0; page < pages; page++) {\n            size_t offset = page * ps->page_size;\n\n            error = metal_virt2phys(virt + offset, &phys[page]);\n            if (error < 0) {\n                phys[page] = (unsigned long)METAL_BAD_OFFSET;\n                if (log) fprintf(log, \"virt2phys failed for page %zu -> BAD_OFFSET\\n\", page);\n            } else {\n                if (log) fprintf(log, \"virt2phys: page %zu -> phys[%zu]=%lu\\n\", page, page, (unsigned long)phys[page]);\n            }\n        }\n        metal_io_init(io, mem, phys, size, ps->page_shift, 0, &metal_shmem_io_ops);\n    }\n\n    *result = io;\n    if (log) fprintf(log, \"mapping complete: io=%p, result set\\n\", (void*)io);\n\n    if (log) fclose(log);\n    return 0;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C:2023 Rule 17.8 prohibits modifying function parameters; while the object pointed to by a pointer parameter may be changed, scalar parameters and the pointer objects themselves must not be assigned to. In metal_shmem_try_map the statement\n\n    size = metal_align_up(size, ps->page_size);\n\nassigns to the scalar parameter size, which is a direct violation of Rule 17.8. (By contrast, writing *result = io; is permitted because it modifies the object pointed to, not the pointer parameter itself.)\n\nFix: copy the parameter to a local variable (for example, size_t aligned_size = metal_align_up(size, ps->page_size);) and use that local variable throughout the function."
}