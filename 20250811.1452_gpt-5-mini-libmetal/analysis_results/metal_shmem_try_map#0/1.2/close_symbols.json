{
  "user_message": "Target function code is:\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_shmem_try_map': {'callees': ['metal_map', 'metal_unmap', 'metal_io_init', 'metal_virt2phys'], 'callers': ['metal_shmem_open']}, 'metal_map': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_unmap': {'callees': [], 'callers': ['metal_uio_dev_close', 'metal_shmem_io_close', 'metal_shmem_try_map']}, 'metal_io_init': {'callees': [], 'callers': ['metal_uio_dev_open', 'metal_shmem_try_map']}, 'metal_virt2phys': {'callees': [], 'callers': ['metal_shmem_try_map']}, 'metal_shmem_open': {'callees': ['metal_shmem_open_generic', 'metal_open', 'metal_shmem_try_map'], 'callers': ['shmem_child']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_page_size",
    "struct metal_io_region",
    "metal_phys_addr_t",
    "metal_shmem_io_ops",
    "_metal",
    "metal_align_up",
    "metal_map",
    "metal_unmap",
    "metal_io_init",
    "metal_virt2phys",
    "metal_log",
    "METAL_LOG_WARNING",
    "METAL_BAD_OFFSET",
    "mlock",
    "strerror",
    "errno",
    "ENOMEM",
    "malloc",
    "free"
  ],
  "explanation": "Brief rationale for each symbol (why it must be inspected to detect compiler/language extensions):\n\n- struct metal_page_size: The function dereferences ps->page_size, ps->mmap_flags and ps->page_shift. The struct definition may include compiler-specific extensions (e.g. bit-fields with non-standard widths, packed/aligned attributes, or extension annotations) that would violate the MISRA extension prohibition.\n\n- struct metal_io_region: The code allocates and initializes this type. Its definition could contain non-standard attributes, packed/aligned pragmas, or compiler-specific fields/macros that are language extensions.\n\n- metal_phys_addr_t: This typedef\u2019s underlying type must be checked \u2014 it might be an implementation-specific type (e.g. __int128, __attribute__ decorated type, or other compiler extension) that would constitute a language extension.\n\n- metal_shmem_io_ops: The object passed by address to metal_io_init may be initialized elsewhere using compiler extensions (designated initializers beyond standard, compound literals, statement expressions, GCC attributes). Inspecting its definition ensures no extension usage is hidden there.\n\n- _metal: The global object _metal (used as _metal.pagemap_fd) may be declared with compiler-specific attributes or pragmas; its type/definition must be checked for extensions (section attributes, packed/aligned, visibility attributes, etc.).\n\n- metal_align_up: This helper may be a macro or inline that commonly uses typeof, statement expressions, or other GNU extensions. Inspect the implementation to ensure it doesn\u2019t rely on compiler extensions.\n\n- metal_map: The prototype/definition should be inspected for nonstandard calling conventions, attributes, or macros implementing it with extensions. The call site uses its return value and mem pointer allocation behavior that might be influenced by such extensions.\n\n- metal_unmap: As above, its declaration/implementation may contain attributes or be a macro using extensions; check to ensure no extension use affects this function.\n\n- metal_io_init: Its declaration and any macros wrapping it could use nonstandard features (attributes, variadic macro tricks, compound literals) \u2014 inspect to ensure safe standard usage.\n\n- metal_virt2phys: This function/macro could be implemented using compiler extensions (inline assembly, builtins, or GCC-specific intrinsics). The for-loop relies on it; check its implementation for extensions.\n\n- metal_log: Logging is often implemented via macros that may use variadic macros, __attribute__ ((__format__)), or GCC extensions; inspect its definition to ensure only standard language features are used.\n\n- METAL_LOG_WARNING: This macro/enum value may expand to compiler-specific constructs or be tied to macros that use extensions; check its definition and any macros that use it.\n\n- METAL_BAD_OFFSET: A macro constant can hide casts, shifts, or bitwise tricks using extension features. Inspect its definition for nonstandard constructs or type-generic macros.\n\n- mlock: A POSIX function, but the header or wrapper could be a macro or inline wrapper that uses platform-specific extensions; verify the used declaration is standard.\n\n- strerror: Standard library function, but ensure no local wrapper macro or custom implementation uses compiler extensions.\n\n- errno: errno is often a macro that may expand to thread-local or compiler-specific constructs (e.g. __errno_location()); inspect its definition to ensure no compiler extension is used in the translation unit.\n\n- ENOMEM: Standard errno macro, but check the headers or any project re-definitions to ensure no extension-based definitions.\n\n- malloc / free: Standard functions, but projects sometimes wrap them with macros or attributes (malloc-like attributes, custom allocators with attributes). Inspect any local/project wrappers for compiler-specific extensions.\n\nIn short: inspect the typedefs, struct definitions, macros and function declarations/implementations referenced by the target function (especially macros like metal_align_up, metal_log, METAL_* and typedefs/global objects) because they are the likely places where compiler-specific language extensions (typeof, statement expressions, attributes, inline assembly, nonstandard storage-class specifiers, etc.) would be used and would cause a violation of the MISRA rule."
}