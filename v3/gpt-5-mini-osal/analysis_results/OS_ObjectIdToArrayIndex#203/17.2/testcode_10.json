{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nOS_printf calls OS_DEBUG and OS_ConsoleWrite. If OS_DEBUG is defined to call OS_printf (e.g. a macro that forwards to OS_printf), or if the console implementation used by OS_ConsoleWrite/OS_ConsoleOutput_Impl ultimately calls OS_printf, then OS_printf would indirectly call itself (OS_printf -> OS_DEBUG/OS_ConsoleWrite -> ... -> OS_printf). That indirect recursion would violate MISRA C 2023 Rule 17.2. The fragment itself does not prove a violation, but the presence of either OS_DEBUG or console output paths that invoke OS_printf creates a violation scenario.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdToArrayIndex code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2036.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdToArrayIndex as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdToArrayIndex:\n```c\nint32 OS_ObjectIdToArrayIndex(osal_objtype_t idtype, osal_id_t object_id, osal_index_t *ArrayIndex)\n{\n    uint32         max_id;\n    uint32         obj_index;\n    osal_objtype_t actual_type;\n    int32          return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(ArrayIndex);\n\n    obj_index   = OS_ObjectIdToSerialNumber_Impl(object_id);\n    actual_type = OS_ObjectIdToType_Impl(object_id);\n\n    /*\n     * If requested by the caller, enforce that the ID is of the correct type.\n     * If the caller passed OS_OBJECT_TYPE_UNDEFINED, then anything is allowed.\n     */\n    if (idtype != OS_OBJECT_TYPE_UNDEFINED && actual_type != idtype)\n    {\n        return_code = OS_ERR_INVALID_ID;\n    }\n    else\n    {\n        max_id = OS_GetMaxForObjectType(actual_type);\n        if (max_id == 0)\n        {\n            return_code = OS_ERR_INVALID_ID;\n        }\n        else\n        {\n            return_code = OS_SUCCESS;\n            *ArrayIndex = OSAL_INDEX_C(obj_index % max_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdToArrayIndex code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe wrappers and logging for OS_ObjectIdToArrayIndex\n * Writes logs to /tmp/logs/2036.txt describing control flow and state.\n * Preserves original logic; wrappers call the original implementation functions.\n */\n\nstatic void os_obj_log(const char *msg, unsigned long long idtype, unsigned long long object_id,\n                       unsigned long long actual_type, unsigned long long obj_index,\n                       unsigned long long max_id, int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/2036.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Log a single-line record with relevant numeric state. */\n        fprintf(f, \"%s | idtype=%llu object_id=%llu actual_type=%llu obj_index=%llu max_id=%llu return_code=%d\\n\",\n                msg, idtype, object_id, actual_type, obj_index, max_id, (int)return_code);\n        fclose(f);\n    }\n}\n\n/* Wrapper probes that call the original implementation functions and log before/after. */\nstatic uint32 probe_ObjectIdToSerialNumber_Impl(osal_id_t object_id)\n{\n    uint32 res;\n\n    os_obj_log(\"ENTER probe_ObjectIdToSerialNumber_Impl\", 0ULL, (unsigned long long)object_id, 0ULL, 0ULL, 0ULL, 0);\n    res = OS_ObjectIdToSerialNumber_Impl(object_id);\n    os_obj_log(\"EXIT probe_ObjectIdToSerialNumber_Impl\", 0ULL, (unsigned long long)object_id, 0ULL, (unsigned long long)res, 0ULL, 0);\n\n    return res;\n}\n\nstatic osal_objtype_t probe_ObjectIdToType_Impl(osal_id_t object_id)\n{\n    osal_objtype_t res;\n\n    os_obj_log(\"ENTER probe_ObjectIdToType_Impl\", 0ULL, (unsigned long long)object_id, 0ULL, 0ULL, 0ULL, 0);\n    res = OS_ObjectIdToType_Impl(object_id);\n    os_obj_log(\"EXIT probe_ObjectIdToType_Impl\", 0ULL, (unsigned long long)object_id, (unsigned long long)res, 0ULL, 0ULL, 0);\n\n    return res;\n}\n\nstatic uint32 probe_GetMaxForObjectType(osal_objtype_t actual_type)\n{\n    uint32 res;\n\n    os_obj_log(\"ENTER probe_GetMaxForObjectType\", (unsigned long long)actual_type, 0ULL, (unsigned long long)actual_type, 0ULL, 0ULL, 0);\n    res = OS_GetMaxForObjectType(actual_type);\n    os_obj_log(\"EXIT probe_GetMaxForObjectType\", (unsigned long long)actual_type, 0ULL, (unsigned long long)actual_type, 0ULL, (unsigned long long)res, 0);\n\n    return res;\n}\n\nint32 OS_ObjectIdToArrayIndex(osal_objtype_t idtype, osal_id_t object_id, osal_index_t *ArrayIndex)\n{\n    uint32         max_id;\n    uint32         obj_index;\n    osal_objtype_t actual_type;\n    int32          return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(ArrayIndex);\n\n    /* Use probe wrappers to capture values from the impl functions */\n    obj_index   = probe_ObjectIdToSerialNumber_Impl(object_id);\n    actual_type = probe_ObjectIdToType_Impl(object_id);\n\n    /* Initial log with values obtained so far */\n    os_obj_log(\"AFTER impl calls\", (unsigned long long)idtype, (unsigned long long)object_id,\n               (unsigned long long)actual_type, (unsigned long long)obj_index, 0ULL, 0);\n\n    /*\n     * If requested by the caller, enforce that the ID is of the correct type.\n     * If the caller passed OS_OBJECT_TYPE_UNDEFINED, then anything is allowed.\n     */\n    if (idtype != OS_OBJECT_TYPE_UNDEFINED && actual_type != idtype)\n    {\n        return_code = OS_ERR_INVALID_ID;\n        os_obj_log(\"TYPE_MISMATCH -> returning\", (unsigned long long)idtype, (unsigned long long)object_id,\n                   (unsigned long long)actual_type, (unsigned long long)obj_index, 0ULL, return_code);\n    }\n    else\n    {\n        max_id = probe_GetMaxForObjectType(actual_type);\n        if (max_id == 0)\n        {\n            return_code = OS_ERR_INVALID_ID;\n            os_obj_log(\"MAX_ID_ZERO -> returning\", (unsigned long long)idtype, (unsigned long long)object_id,\n                       (unsigned long long)actual_type, (unsigned long long)obj_index, (unsigned long long)max_id, return_code);\n        }\n        else\n        {\n            return_code = OS_SUCCESS;\n            *ArrayIndex = OSAL_INDEX_C(obj_index % max_id);\n            os_obj_log(\"SUCCESS -> computed ArrayIndex\", (unsigned long long)idtype, (unsigned long long)object_id,\n                       (unsigned long long)actual_type, (unsigned long long)obj_index, (unsigned long long)max_id, return_code);\n        }\n    }\n\n    return return_code;\n}\n"
}