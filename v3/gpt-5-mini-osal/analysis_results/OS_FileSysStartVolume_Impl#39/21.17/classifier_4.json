{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileSysStartVolume_Impl:\n```c\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    break;\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileSysStartVolume_Impl:\nconst char OS_POSIX_DEVICEFILE_PREFIX[] = \"/dev/\"\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The code bounds-checks the destination and limits the copy length before calling memcpy: mplen is the snprintf() return (the current length) and is only used when mplen < sizeof(local->system_mountpt) (so mplen <= sizeof-1). vollen is computed with OS_strnlen() and then reduced when (vollen + mplen) >= sizeof(local->system_mountpt) to sizeof(...) - mplen - 1, guaranteeing room for the terminating NUL written afterwards. Thus memcpy(&local->system_mountpt[mplen], local->volume_name, vollen) cannot write past system_mountpt, and source/destination are distinct object members (no overlap). Therefore MISRA C 2023 Rule 21.17 is not violated."
}