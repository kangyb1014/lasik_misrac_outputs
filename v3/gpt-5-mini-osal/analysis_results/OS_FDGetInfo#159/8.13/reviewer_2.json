{
  "user_message": "An agent A claimed that the following OS_FDGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_FDGetInfo.\n```c\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(fd_prop->Path, record->name_entry, sizeof(fd_prop->Path) - 1);\n        }\n        fd_prop->User    = record->creator;\n        fd_prop->IsValid = true;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe declaration uses a const pointer to mutable records: extern OS_common_record_t *const OS_global_stream_table. Rule 8.13 expects the pointee to be const-qualified when possible. In OS_FDGetInfo the code only reads from the table (record->name_entry, record->creator), so the table could be declared as const OS_common_record_t *const OS_global_stream_table. Because the pointee is not const-qualified even though it could be, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FDGetInfo:\ntypedef struct\n{\n    char      Path[OS_MAX_PATH_LEN];\n    osal_id_t User;\n    uint8     IsValid; /* For backward compatibility -- always true if OS_FDGetInfo returned true */\n} OS_file_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_common_record_t *const OS_global_stream_table\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\n#define OS_SUCCESS (0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not proven correct. Rule 8.13 says a pointer should point to a const-qualified type whenever possible. In OS_FDGetInfo the object referenced by record is only read, so the local pointer variable could (and should) be declared as pointer-to-const: e.g. \"const OS_common_record_t *record\". Assigning the result of OS_OBJECT_TABLE_GET (a non-const OS_common_record_t *) to a const-qualified pointer is permitted, so the function itself can be made compliant without changing the global declaration.\n\nThe agent asserts the global should be changed to \"const OS_common_record_t *const OS_global_stream_table\". That may or may not be possible for the whole program \u2014 whether the global's pointee can be made const depends on whether other translation units modify those records. The provided code does not show that the global is immutable everywhere, so you cannot conclude the global must be const. Therefore the report (that this code violates MISRA C 2023 Rule 8.13 because the global's pointee is not const) is not supported by the evidence; the immediate and local violation (non-const local pointer) is fixable by making the local pointer const, so a definitive rule violation is not established from the shown code."
}