{
  "user_message": "An agent A claimed that the following UtAssert_EndTest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_EndTest.\n```c\nvoid UtAssert_EndTest(void)\n{\n    uint32                 Ct;\n    bool                   SegmentValid;\n    UtAssert_TestCounter_t Local_SegmentCounters;\n    char                   Local_SegmentName[sizeof(CurrentSegment)];\n\n    UT_BSP_Lock();\n\n    SegmentValid = (UT_SegmentCounters.TotalTestCases > 0);\n    if (SegmentValid)\n    {\n        ++UT_TotalCounters.TestSegmentCount;\n        UT_SegmentCounters.TestSegmentCount = UT_TotalCounters.TestSegmentCount;\n        UT_TotalCounters.TotalTestCases += UT_SegmentCounters.TotalTestCases;\n        for (Ct = 0; Ct < UTASSERT_CASETYPE_MAX; ++Ct)\n        {\n            UT_TotalCounters.CaseCount[Ct] += UT_SegmentCounters.CaseCount[Ct];\n        }\n        memcpy(&Local_SegmentCounters, &UT_SegmentCounters, sizeof(Local_SegmentCounters));\n\n        /*\n         * note, strcpy is OK because both are fixed size buffers of the same size,\n         * and the null termination on CurrentSegment was locally enforced already\n         */\n        strcpy(Local_SegmentName, CurrentSegment);\n    }\n\n    memset(&UT_SegmentCounters, 0, sizeof(UT_SegmentCounters));\n\n    UT_BSP_Unlock();\n\n    if (SegmentValid)\n    {\n        UtAssert_DoTestSegmentReport(Local_SegmentName, &Local_SegmentCounters);\n    }\n    else\n    {\n        UT_BSP_DoText(UTASSERT_CASETYPE_END, \"No test cases\\n\");\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the function UtAssert_DoTestSegmentReport is declared to take non-const pointers (e.g. void UtAssert_DoTestSegmentReport(char *segmentName, UtAssert_TestCounter_t *counters)) but it only reads from the name and the counters, then Rule 8.13 is violated. Both Local_SegmentName and Local_SegmentCounters are used as input-only for reporting and therefore the corresponding parameters should be declared as const (const char * and const UtAssert_TestCounter_t *) so the pointers point to const-qualified types.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtAssert_EndTest: enter\nPre-lock state: UT_SegmentCounters.TotalTestCases=0\nPre-lock UT_SegmentCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nPre-lock UT_TotalCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nCurrentSegment (pre): 'SETUP'\nComputed SegmentValid=0\nPost-memset UT_SegmentCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAfter unlock: SegmentValid=0\nNo test cases: invoking UT_BSP_DoText\nUtAssert_EndTest: exit\nUtAssert_EndTest: enter\nPre-lock state: UT_SegmentCounters.TotalTestCases=1\nPre-lock UT_SegmentCounters: size=64 bytes:\n00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\nPre-lock UT_TotalCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nCurrentSegment (pre): 'OS_VxWorks_BinSemAPI_Impl_Init'\nComputed SegmentValid=1\nBefore update: UT_TotalCounters.TestSegmentCount=0, UT_SegmentCounters.TestSegmentCount=0, UT_SegmentCounters.TotalTestCases=1\nAfter update: UT_TotalCounters.TestSegmentCount=1, UT_SegmentCounters.TestSegmentCount=1, UT_TotalCounters.TotalTestCases=1\nLocal_SegmentName='OS_VxWorks_BinSemAPI_Impl_Init'\nLocal_SegmentCounters: size=64 bytes:\n01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\nPost-memset UT_SegmentCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAfter unlock: SegmentValid=1\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName='OS_VxWorks_BinSemAPI_Impl_Init' and address Local_SegmentCounters=0x7fff673c9a90\nPayload passed to UtAssert_DoTestSegmentReport (Local_SegmentCounters): size=64 bytes:\n01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\nReturned from UtAssert_DoTestSegmentReport\nUtAssert_EndTest: exit\nUtAssert_EndTest: enter\nPre-lock state: UT_SegmentCounters.TotalTestCases=2\nPre-lock UT_SegmentCounters: size=64 bytes:\n00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00\nPre-lock UT_TotalCounters: size=64 bytes:\n01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00\nCurrentSegment (pre): 'OS_BinSemCreate_Impl'\nComputed SegmentValid=1\nBefore update: UT_TotalCounters.TestSegmentCount=1, UT_SegmentCounters.TestSegmentCount=0, UT_SegmentCounters.TotalTestCases=2\nAfter update: UT_TotalCounters.TestSegmentCount=2, UT_SegmentCounters.TestSegmentCount=2, UT_TotalCounters.TotalTestCases=3\nLocal_SegmentName='OS_BinSemCreate_Impl'\nLocal_SegmentCounters: size=64 bytes:\n02 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00\nPost-memset UT_SegmentCounters: size=64 bytes:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_EndTest:\nUtAssert_TestCounter_t UT_SegmentCounters = {0}\n...\nUtAssert_TestCounter_t UT_TotalCounters   = {0}\n...\nstatic char            CurrentSegment[64]\n...\ntypedef struct\n{\n    uint32 TestSegmentCount;\n    uint32 TotalTestCases;\n    uint32 CaseCount[UTASSERT_CASETYPE_MAX];\n} UtAssert_TestCounter_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is essentially correct, but the issue is with the callee's parameter types rather than UtAssert_EndTest itself. MISRA C 2023 Rule 8.13 requires that pointers be declared to point to const-qualified types whenever possible. In UtAssert_EndTest the locals Local_SegmentName and Local_SegmentCounters are prepared as input-only values and are passed by address to UtAssert_DoTestSegmentReport. If UtAssert_DoTestSegmentReport is declared as something like\n  void UtAssert_DoTestSegmentReport(char *segmentName, UtAssert_TestCounter_t *counters)\nbut only reads from those objects, then the function's parameter types should be const-qualified (const char * and const UtAssert_TestCounter_t *) to comply with Rule 8.13. The execution log and surrounding comments indicate the data is used only for reporting (read-only), so changing the callee prototype to accept pointers to const is appropriate.\n\nNote: If the callee actually modifies the pointed-to objects or the API intentionally requires non-const for other reasons, then leaving the parameters non-const would be justified and not a violation. Given the scenario presented (the callee only reads the data), Agent A's claim of a Rule 8.13 violation is correct."
}