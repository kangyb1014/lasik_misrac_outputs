{
  "user_message": "An agent A claimed that the following UtAssert_EndTest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_EndTest.\n```c\nvoid UtAssert_EndTest(void)\n{\n    uint32                 Ct;\n    bool                   SegmentValid;\n    UtAssert_TestCounter_t Local_SegmentCounters;\n    char                   Local_SegmentName[sizeof(CurrentSegment)];\n\n    UT_BSP_Lock();\n\n    SegmentValid = (UT_SegmentCounters.TotalTestCases > 0);\n    if (SegmentValid)\n    {\n        ++UT_TotalCounters.TestSegmentCount;\n        UT_SegmentCounters.TestSegmentCount = UT_TotalCounters.TestSegmentCount;\n        UT_TotalCounters.TotalTestCases += UT_SegmentCounters.TotalTestCases;\n        for (Ct = 0; Ct < UTASSERT_CASETYPE_MAX; ++Ct)\n        {\n            UT_TotalCounters.CaseCount[Ct] += UT_SegmentCounters.CaseCount[Ct];\n        }\n        memcpy(&Local_SegmentCounters, &UT_SegmentCounters, sizeof(Local_SegmentCounters));\n\n        /*\n         * note, strcpy is OK because both are fixed size buffers of the same size,\n         * and the null termination on CurrentSegment was locally enforced already\n         */\n        strcpy(Local_SegmentName, CurrentSegment);\n    }\n\n    memset(&UT_SegmentCounters, 0, sizeof(UT_SegmentCounters));\n\n    UT_BSP_Unlock();\n\n    if (SegmentValid)\n    {\n        UtAssert_DoTestSegmentReport(Local_SegmentName, &Local_SegmentCounters);\n    }\n    else\n    {\n        UT_BSP_DoText(UTASSERT_CASETYPE_END, \"No test cases\\n\");\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes a string literal to UT_BSP_DoText. If UT_BSP_DoText is declared as taking a non-const pointer (for example: void UT_BSP_DoText(int type, char *text)), then the function should instead take a pointer to const (const char *text) because the text is not modified. In that case Rule 8.13 is violated. (If UT_BSP_DoText is already declared as taking const char * then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=0\nComputed SegmentValid=false\nAbout to memset UT_SegmentCounters (was TotalTestCases=0)\nCalling UT_BSP_DoText with literal at 0x5569d3dd8a3b: \"No test cases\n\"\nReturned from UT_BSP_DoText\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=1\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_VxWorks_BinSemAPI_Impl_Init\"\nLocal_SegmentCounters.TotalTestCases=1\nAbout to memset UT_SegmentCounters (was TotalTestCases=1)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_VxWorks_BinSemAPI_Impl_Init\", Local_SegmentCounters.TotalTestCases=1\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=2\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemCreate_Impl\"\nLocal_SegmentCounters.TotalTestCases=2\nAbout to memset UT_SegmentCounters (was TotalTestCases=2)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemCreate_Impl\", Local_SegmentCounters.TotalTestCases=2\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=1\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemDelete_Impl\"\nLocal_SegmentCounters.TotalTestCases=1\nAbout to memset UT_SegmentCounters (was TotalTestCases=1)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemDelete_Impl\", Local_SegmentCounters.TotalTestCases=1\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=2\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemGive_Impl\"\nLocal_SegmentCounters.TotalTestCases=2\nAbout to memset UT_SegmentCounters (was TotalTestCases=2)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemGive_Impl\", Local_SegmentCounters.TotalTestCases=2\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=2\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemFlush_Impl\"\nLocal_SegmentCounters.TotalTestCases=2\nAbout to memset UT_SegmentCounters (was TotalTestCases=2)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemFlush_Impl\", Local_SegmentCounters.TotalTestCases=2\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=1\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemTake_Impl\"\nLocal_SegmentCounters.TotalTestCases=1\nAbout to memset UT_SegmentCounters (was TotalTestCases=1)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemTake_Impl\", Local_SegmentCounters.TotalTestCases=1\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=3\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemTimedWait_Impl\"\nLocal_SegmentCounters.TotalTestCases=3\nAbout to memset UT_SegmentCounters (was TotalTestCases=3)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemTimedWait_Impl\", Local_SegmentCounters.TotalTestCases=3\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=1\nComputed SegmentValid=true\nSegment copied: Local_SegmentName=\"OS_BinSemGetInfo_Impl\"\nLocal_SegmentCounters.TotalTestCases=1\nAbout to memset UT_SegmentCounters (was TotalTestCases=1)\nCalling UtAssert_DoTestSegmentReport with Local_SegmentName=\"OS_BinSemGetInfo_Impl\", Local_SegmentCounters.TotalTestCases=1\nReturned from UtAssert_DoTestSegmentReport\nEXIT: UtAssert_EndTest\nENTER: UtAssert_EndTest\nState before SegmentValid: UT_SegmentCounters.TotalTestCases=0\nComputed SegmentValid=false\nAbout to mem\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_EndTest:\nUtAssert_TestCounter_t UT_SegmentCounters = {0}\n...\nUtAssert_TestCounter_t UT_TotalCounters   = {0}\n...\nstatic char            CurrentSegment[64]\n...\ntypedef struct\n{\n    uint32 TestSegmentCount;\n    uint32 TotalTestCases;\n    uint32 CaseCount[UTASSERT_CASETYPE_MAX];\n} UtAssert_TestCounter_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's reasoning is conditionally correct but not proven by the supplied code. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible. If the function UT_BSP_DoText is declared with a non-const parameter (for example: void UT_BSP_DoText(int type, char *text)) and the function does not modify the pointed-to characters, then that declaration would be non-compliant with Rule 8.13 and passing the string literal would evidence the mismatch. However, the code excerpts provided do not include the prototype/definition of UT_BSP_DoText, so there is no direct proof in the submission that the function parameter is non-const. Therefore the claim that UtAssert_EndTest (as shown) violates MISRA Rule 8.13 cannot be confirmed. If UT_BSP_DoText is declared to take a const char * (or otherwise the parameter is appropriately const-qualified), there is no violation. To decide definitively, inspect the declaration of UT_BSP_DoText; if it uses char * for a non-modifiable string argument it should be changed to const char * to comply with Rule 8.13."
}