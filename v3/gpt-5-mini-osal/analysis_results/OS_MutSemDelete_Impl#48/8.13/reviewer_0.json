{
  "user_message": "An agent A claimed that the following OS_MutSemDelete_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemDelete_Impl.\n```c\nint32 OS_MutSemDelete_Impl(const OS_object_token_t *token)\n{\n    int                              status;\n    OS_impl_mutex_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_mutex_table, *token);\n\n    status = pthread_mutex_destroy(&(impl->id)); /* 0 = success */\n\n    if (status != 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 the macro can create a non-const pointer to the token object even though the index function takes a pointer-to-const. The macro takes tok by value and forms &(tok). If the caller supplies a non-const lvalue (for example: OS_object_token_t mytok; OS_OBJECT_TABLE_GET(tbl, mytok)), the expression &(mytok) has type OS_object_token_t * (non-const). Rule 8.13 requires pointers to refer to const-qualified types when possible; here the pointer to the token could and should be const (OS_object_token_t const *). Note: in the provided use in OS_MutSemDelete_Impl (they pass *token where token is const OS_object_token_t *), the particular call does not violate the rule, but the macro definition itself is susceptible to violating MISRA C 2023 Rule 8.13 in other call sites.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_MutSemDelete_Impl:\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    pthread_mutex_t id;\n} OS_impl_mutex_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_mutex_internal_record_t OS_impl_mutex_table[OS_MAX_MUTEXES]\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim that OS_MutSemDelete_Impl violates MISRA C:2023 Rule 8.13 is not correct for the code shown. In this function the macro is invoked as OS_OBJECT_TABLE_GET(..., *token) where token is declared const OS_object_token_t *. The sub\u2011expression *(token) is an lvalue of const OS_object_token_t, so &( *token ) (what the macro forms) has type const OS_object_token_t *, and therefore this particular use does not create a non\u2011const pointer and does not breach Rule 8.13.\n\nIt is true that the macro definition OS_OBJECT_TABLE_GET(tbl, tok) uses &(tok) and so the pointer type produced depends on the const qualification of the actual macro argument. If a caller passes a non\u2011const lvalue (e.g. OS_object_token_t mytok; OS_OBJECT_TABLE_GET(tbl, mytok)), the resulting pointer expression will be OS_object_token_t * (non\u2011const) and that use could be seen as inconsistent with the spirit of Rule 8.13. That, however, would be a problem with the macro or with call sites that pass non\u2011const tokens, not a violation in the shown OS_MutSemDelete_Impl function.\n\nTherefore agent A\u2019s general observation about the macro\u2019s potential to yield a non\u2011const pointer is correct, but the reported violation of Rule 8.13 for OS_MutSemDelete_Impl itself is incorrect."
}