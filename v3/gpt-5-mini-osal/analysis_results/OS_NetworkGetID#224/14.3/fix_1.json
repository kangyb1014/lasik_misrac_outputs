{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic const int OS_SUCCESS = 0;\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2245.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* If logging is not possible, preserve original behavior. */\n    }\n\n    /* Timestamp for easier ordering of events */\n    time_t t = time(NULL);\n    struct tm tmv;\n    if (localtime_r(&t, &tmv) == NULL)\n    {\n        fprintf(f, \"[unknown time] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tmv) > 0)\n        {\n            fprintf(f, \"%s \", buf);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_NetworkGetID(void)\n{\n    int32 IdBuf;\n\n    probe_log(\"OS_NetworkGetID: entered; &IdBuf=%p\", (void *)&IdBuf);\n\n    /* always delegate to low-level API */\n    int32 impl_result = OS_NetworkGetID_Impl(&IdBuf);\n    probe_log(\"OS_NetworkGetID: OS_NetworkGetID_Impl returned %d; IdBuf (raw)=%d\", (int)impl_result, (int)IdBuf);\n\n    if (impl_result != OS_SUCCESS)\n    {\n        /* Log the taken failure path and value returned to caller. */\n        probe_log(\"OS_NetworkGetID: impl_result (%d) != OS_SUCCESS (%d) -> returning -1\", (int)impl_result, (int)OS_SUCCESS);\n\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    probe_log(\"OS_NetworkGetID: impl_result == OS_SUCCESS (%d) -> returning IdBuf=%d\", (int)OS_SUCCESS, (int)IdBuf);\n\n    return IdBuf;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from /tmp/tmpc8bifz7d/src/src/os/shared/inc/os-shared-globaldefs.h:36,\n                 from /tmp/tmpc8bifz7d/src/src/os/shared/inc/os-shared-network.h:30,\n                 from /tmp/tmpc8bifz7d/src/src/os/shared/src/osapi-network.c:47:\n/tmp/tmpc8bifz7d/src/src/os/inc/osapi-error.h:96:41: error: expected identifier or '(' before numeric constant\n   96 | #define OS_SUCCESS                     (0)   /**< @brief Successful execution */\n      |                                         ^\n/tmp/tmpc8bifz7d/src/src/os/shared/src/osapi-network.c:94:18: note: in expansion of macro 'OS_SUCCESS'\n   94 | static const int OS_SUCCESS = 0;\n      |                  ^~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:258: CMakeFiles/osal.dir/src/os/shared/src/osapi-network.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_NetworkGetID as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed version of the file - removed conflicting local OS_SUCCESS and added minimal typedefs/declarations\n * The original logic of OS_NetworkGetID is preserved.\n */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stdint.h>\n\n/* Provide a minimal int32 type so this file compiles standalone. */\ntypedef int32_t int32;\n\n/* Declare the low-level implementation function (do not define/mocK it here). */\nextern int32 OS_NetworkGetID_Impl(int32 *IdBuf);\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2245.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* If logging is not possible, preserve original behavior. */\n    }\n\n    /* Timestamp for easier ordering of events */\n    time_t t = time(NULL);\n    struct tm tmv;\n    if (localtime_r(&t, &tmv) == NULL)\n    {\n        fprintf(f, \"[unknown time] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tmv) > 0)\n        {\n            fprintf(f, \"%s \", buf);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_NetworkGetID(void)\n{\n    int32 IdBuf;\n\n    probe_log(\"OS_NetworkGetID: entered; &IdBuf=%p\", (void *)&IdBuf);\n\n    /* always delegate to low-level API */\n    int32 impl_result = OS_NetworkGetID_Impl(&IdBuf);\n    probe_log(\"OS_NetworkGetID: OS_NetworkGetID_Impl returned %d; IdBuf (raw)=%d\", (int)impl_result, (int)IdBuf);\n\n    /* Use literal 0 to represent success (equivalent to OS_SUCCESS) */\n    if (impl_result != 0)\n    {\n        /* Log the taken failure path and value returned to caller. */\n        probe_log(\"OS_NetworkGetID: impl_result (%d) != OS_SUCCESS (%d) -> returning -1\", (int)impl_result, 0);\n\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    probe_log(\"OS_NetworkGetID: impl_result == OS_SUCCESS (%d) -> returning IdBuf=%d\", 0, (int)IdBuf);\n\n    return IdBuf;\n}\n",
  "explanation": "The compilation error was caused by a local definition 'static const int OS_SUCCESS = 0;' colliding with an existing OS_SUCCESS macro from project headers. I removed that conflicting declaration and used the literal 0 where the success constant is needed (semantically equivalent to OS_SUCCESS). To make this file self-contained and compilable, I added standard headers and a typedef for int32, and declared the external OS_NetworkGetID_Impl function (without defining it). The original logic and control flow of OS_NetworkGetID were preserved."
}