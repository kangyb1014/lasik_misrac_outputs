{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf the function OS_ObjectIdFinalizeDelete does not modify the object referred to by token but its parameter is declared as a pointer to a non-const type (for example: int32 OS_ObjectIdFinalizeDelete(int32 status, OS_object_token_t *token)), then Rule 8.13 is violated. The parameter should be declared as a pointer to const (int32 OS_ObjectIdFinalizeDelete(int32 status, const OS_object_token_t *token)) so that the pointer points to a const-qualified type whenever possible.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_close code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1653.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_close as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_close:\n```c\nint32 OS_close(osal_id_t filedes)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_GenericClose_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_close code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdbool.h>\n\n/*\n * Probe helpers to log control flow and token state to /tmp/logs/1653.txt.\n * These helpers do not change the OS_close logic; they only observe and\n * record state before and after calls that are relevant to the Rule 8.13\n * violation scenario (i.e. whether OS_ObjectIdFinalizeDelete modifies the\n * object referred to by token despite token being passed as a non-const\n * pointer).\n */\n\nstatic FILE *probe_log_open_append(void)\n{\n    FILE *f = fopen(\"/tmp/logs/1653.txt\", \"a\");\n    return f; /* may be NULL if open fails; callers must handle */\n}\n\nstatic void probe_logf(const char *fmt, ...)\n{\n    FILE *f = probe_log_open_append();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nstatic unsigned char *probe_snapshot_token(const void *token, size_t *out_size)\n{\n    if (token == NULL)\n    {\n        if (out_size) *out_size = 0;\n        return NULL;\n    }\n\n    size_t size = sizeof(*(const char (*)[sizeof(*(const void *)0)])token); /* fallback to sizeof(token) type at compile time */\n    /* Note: the above line is intentionally written to allow sizeof on the token's type\n     * at compile time. The compiler will substitute the real type of token (OS_object_token_t).\n     * If the compiler cannot evaluate that expression, use a direct sizeof below when available.\n     */\n\n    /* In practice, use a direct sizeof of the token type. To keep this snippet\n     * generic and compileable when pasted into the real code base, we instead\n     * compute size using sizeof(*((const OS_object_token_t *)0)) at the call site.\n     */\n    /* This function will be called with the proper type, and here we will allocate\n     * based on the size returned by the caller via out_size. To keep behavior\n     * deterministic we will return a copy using the out_size provided by the caller.\n     */\n    (void)size; /* silence unused-variable in this generic helper */\n    return NULL; /* this generic helper is overridden by the type-aware wrapper below */\n}\n\n/* Type-aware wrappers that operate on OS_object_token_t specifically. */\nstatic unsigned char *probe_snapshot_OS_object_token(const OS_object_token_t *token, size_t *out_size)\n{\n    if (token == NULL)\n    {\n        if (out_size) *out_size = 0;\n        return NULL;\n    }\n\n    size_t size = sizeof(*token);\n    unsigned char *buf = (unsigned char *)malloc(size);\n    if (buf == NULL)\n    {\n        if (out_size) *out_size = 0;\n        return NULL;\n    }\n\n    memcpy(buf, token, size);\n    if (out_size) *out_size = size;\n    return buf;\n}\n\nstatic void probe_compare_and_log_OS_object_token(const unsigned char *before, const unsigned char *after, size_t size)\n{\n    FILE *f = probe_log_open_append();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"Token comparison: size=%zu bytes\", size);\n\n    if (before == NULL || after == NULL)\n    {\n        fprintf(f, \"One of the snapshots is NULL (before=%p, after=%p)\", (const void *)before, (const void *)after);\n        fclose(f);\n        return;\n    }\n\n    size_t diffs = 0;\n    for (size_t i = 0; i < size; ++i)\n    {\n        if (before[i] != after[i])\n        {\n            if (diffs < 32)\n            {\n                fprintf(f, \"diff at byte %zu: 0x%02x -> 0x%02x\", i, before[i], after[i]);\n            }\n            diffs++;\n        }\n    }\n\n    fprintf(f, \"Total differing bytes: %zu\", diffs);\n    fclose(f);\n}\n\n/* The original OS_close implementation with probes inserted. */\nint32 OS_close(osal_id_t filedes)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    probe_logf(\"OS_close: entry filedes=%ld\", (long)filedes);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, filedes, &token);\n    probe_logf(\"OS_close: OS_ObjectIdGetById returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Take a snapshot of the token before any modification */\n        size_t before_size = 0;\n        unsigned char *before_snapshot = probe_snapshot_OS_object_token(&token, &before_size);\n        probe_logf(\"OS_close: snapshot taken before GenericClose (size=%zu)\", before_size);\n\n        return_code = OS_GenericClose_Impl(&token);\n        probe_logf(\"OS_close: OS_GenericClose_Impl returned %d\", (int)return_code);\n\n        /* Take another snapshot just prior to calling FinalizeDelete to\n         * capture the token state that is passed to OS_ObjectIdFinalizeDelete.\n         */\n        size_t pre_finalize_size = 0;\n        unsigned char *pre_finalize_snapshot = probe_snapshot_OS_object_token(&token, &pre_finalize_size);\n        probe_logf(\"OS_close: snapshot taken before FinalizeDelete (size=%zu)\", pre_finalize_size);\n\n        /* Call the finalize routine (this is the call mentioned in the violation scenario).\n         * We log the return code and then take an after-snapshot to detect whether the\n         * token object was modified by the function even though it was passed as a\n         * non-const pointer.\n         */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        probe_logf(\"OS_close: OS_ObjectIdFinalizeDelete returned %d\", (int)return_code);\n\n        size_t after_size = 0;\n        unsigned char *after_snapshot = probe_snapshot_OS_object_token(&token, &after_size);\n        probe_logf(\"OS_close: snapshot taken after FinalizeDelete (size=%zu)\", after_size);\n\n        /* Compare the pre- and post- snapshots and log any differences. */\n        if (pre_finalize_snapshot != NULL && after_snapshot != NULL && pre_finalize_size == after_size)\n        {\n            probe_compare_and_log_OS_object_token(pre_finalize_snapshot, after_snapshot, after_size);\n        }\n        else\n        {\n            probe_logf(\"OS_close: unable to compare snapshots (pre=%p, post=%p, pre_size=%zu, post_size=%zu)\",\n                       (const void *)pre_finalize_snapshot, (const void *)after_snapshot, pre_finalize_size, after_size);\n        }\n\n        /* free snapshots */\n        free(before_snapshot);\n        free(pre_finalize_snapshot);\n        free(after_snapshot);\n    }\n\n    probe_logf(\"OS_close: exit returning %d\", (int)return_code);\n    return return_code;\n}\n"
}