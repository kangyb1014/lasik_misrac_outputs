{
  "user_message": "Target function code is:\n```c\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n            return_code = OS_ERROR;\n            break;\n        }\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SymbolLookup_Static': {'callees': [], 'callers': ['OS_SymbolLookup', 'OS_ModuleSymbolLookup']}, 'OS_SymbolLookup': {'callees': ['OS_printf', 'OS_SymbolLookup_Impl', 'OS_SymbolLookup_Static', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}, 'OS_ModuleSymbolLookup': {'callees': ['OS_printf', 'OS_ObjectIdGetById', 'OS_ObjectIndexFromToken', 'OS_ModuleSymbolLookup_Impl', 'OS_SymbolLookup_Static', 'OS_ObjectIdRelease', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_static_symbol_record_t",
    "OS_STATIC_SYMTABLE_SOURCE",
    "cpuaddr",
    "strcmp",
    "NULL",
    "OS_SUCCESS",
    "OS_ERROR",
    "OS_ERR_NOT_IMPLEMENTED"
  ],
  "explanation": "For checking the MISRA rule (a function parameter shall not be modified) you need the following additional symbols and why:\n\n- OS_static_symbol_record_t\n  - Provides the definition of the static symbol table entry (fields Name, Module, Address). Required to verify the types/constness of Name and Module (they are passed to strcmp) and the type of Address (to confirm that *SymbolAddress = (cpuaddr)StaticSym->Address modifies the object pointed-to by the pointer parameter, not the pointer parameter itself).\n\n- OS_STATIC_SYMTABLE_SOURCE\n  - The initial pointer/array used to initialize the local StaticSym. Needed to ensure this symbol is a separate static data source and does not alias any of the function parameters (which would affect whether modifications are to parameter objects or unrelated storage).\n\n- cpuaddr\n  - The typedef of cpuaddr is required to determine whether SymbolAddress is a pointer to an integer, pointer-to-pointer, etc., so the assignment to *SymbolAddress can be classified as modifying the pointed-to object (allowed) rather than modifying the parameter itself (prohibited).\n\n- strcmp\n  - The prototype (int strcmp(const char *, const char *)) confirms that strcmp takes const char * arguments and does not modify its arguments; this shows the calls do not modify SymbolName or ModuleName.\n\n- NULL\n  - The definition of NULL (macro) ensures that comparisons ModuleName == NULL and checks of StaticSym->Name == NULL are conventional pointer comparisons and not some macro that could cause parameter modification.\n\n- OS_SUCCESS, OS_ERROR, OS_ERR_NOT_IMPLEMENTED\n  - The return-code macros/constants are required to fully understand control flow and returns, but primarily to confirm no hidden macros alter parameter values as part of their expansion.\n\nTogether these symbols let a reviewer determine whether any of the function parameters (SymbolAddress, SymbolName, ModuleName) are being reassigned or otherwise modified (disallowed) versus having the objects they point to modified (allowed)."
}