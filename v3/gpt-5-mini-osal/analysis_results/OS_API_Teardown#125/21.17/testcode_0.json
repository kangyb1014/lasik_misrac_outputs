{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The code calls OS_strnlen(record->name_entry, buffer_size) where buffer_size is the size of the destination buffer provided by the caller. If buffer_size is larger than the actual allocated size of the object pointed to by record->name_entry (or if the source string is not NUL-terminated within its own allocation), OS_strnlen may read past the bounds of record->name_entry. That read-while-searching for NUL would be an access beyond the bounds of the source object. Following that, memcpy(buffer, record->name_entry, name_len) would also read from beyond the source object when name_len is adjusted (or if strnlen returned an overlarge value), producing undefined behavior. Example concrete scenario: record->name_entry points to a 16-byte storage that happens not to contain a NUL in those 16 bytes, but the caller passed buffer_size = 64; OS_strnlen will attempt to examine up to 64 bytes and thus read past the 16-byte object \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_API_Teardown code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1259.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_API_Teardown as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_API_Teardown:\n```c\nvoid OS_API_Teardown(void)\n{\n    /*\n     * This should delete any remaining user-created objects/tasks\n     */\n    OS_DeleteAllObjects();\n\n    /*\n     * This should cause the \"internal\" objects (e.g. console utility task)\n     * to exit, and will prevent any new objects from being created.\n     */\n    OS_ApplicationShutdown(true);\n}\n```\n</target_code>\nPlease provide the modified OS_API_Teardown code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* External functions from the original system. Do not change their signatures. */\nextern void OS_DeleteAllObjects(void);\nextern void OS_ApplicationShutdown(bool);\n\n/* Simple logging helper that appends to the required log file. */\nstatic void write_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1259.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fclose(f);\n}\n\n/*\n * Probe function to capture the relevant state relating to the strnlen/memcpy scenario.\n * This function intentionally avoids reading beyond the supplied \"src_alloc_size\" to\n * prevent creating a new out-of-bounds access while still logging evidence of a risky call.\n *\n * Parameters:\n *  - name_entry: pointer to the source string (may point to a buffer of src_alloc_size bytes)\n *  - src_alloc_size: the number of bytes actually allocated for name_entry\n *  - buffer_size: the size passed by the caller to functions such as OS_strnlen\n *  - dest_buffer: destination pointer provided by the caller (may be NULL if only logging is desired)\n */\nvoid OS_API_Probe_RecordName(const char *name_entry, size_t src_alloc_size, size_t buffer_size, void *dest_buffer)\n{\n    if (name_entry == NULL)\n    {\n        write_log(\"Probe: name_entry == NULL\\n\");\n        return;\n    }\n\n    write_log(\"Probe: name_entry=%p src_alloc_size=%zu buffer_size=%zu dest_buffer=%p\\n\",\n              (const void *)name_entry, src_alloc_size, buffer_size, dest_buffer);\n\n    /* Determine a safe scanning limit: do not read past the actual allocation. */\n    size_t safe_limit = (buffer_size < src_alloc_size) ? buffer_size : src_alloc_size;\n\n    /* Scan for NUL within the safe limit only. This mirrors a safe implementation of strnlen. */\n    size_t i;\n    bool nul_found = false;\n    for (i = 0u; i < safe_limit; ++i)\n    {\n        if (name_entry[i] == '\\0')\n        {\n            nul_found = true;\n            break;\n        }\n    }\n\n    size_t safe_name_len = (nul_found ? i : safe_limit);\n\n    write_log(\"Probe result: safe_name_len=%zu nul_found=%d (scanned up to %zu bytes)\\n\",\n              safe_name_len, (int)nul_found, safe_limit);\n\n    if (buffer_size > src_alloc_size)\n    {\n        write_log(\"WARNING: Provided buffer_size (%zu) > src_alloc_size (%zu).\\n\",\n                  buffer_size, src_alloc_size);\n        write_log(\"If a naive OS_strnlen(name_entry, buffer_size) were used, it could read beyond the bounds of name_entry.\\n\");\n    }\n    else\n    {\n        write_log(\"buffer_size (%zu) <= src_alloc_size (%zu): calling OS_strnlen with buffer_size would be bounded by allocation.\\n\",\n                  buffer_size, src_alloc_size);\n    }\n\n    write_log(\"Planned memcpy length based on safe scan = %zu\\n\", safe_name_len);\n\n    /* Perform a safe memcpy only up to safe_name_len (which is <= src_alloc_size). */\n    if (dest_buffer != NULL && safe_name_len > 0u)\n    {\n        memcpy(dest_buffer, name_entry, safe_name_len);\n        write_log(\"Performed safe memcpy of %zu bytes from %p to %p\\n\",\n                  safe_name_len, (const void *)name_entry, dest_buffer);\n\n        /* Log whether destination will be NUL-terminated by this copy (it won't be if we didn't copy a NUL). */\n        if (nul_found)\n        {\n            write_log(\"Note: source contained a NUL within the safe limit; destination contains the NUL (if space available).\\n\");\n        }\n        else\n        {\n            write_log(\"Note: source did NOT contain a NUL within the safe limit; destination may not be NUL-terminated.\\n\");\n        }\n    }\n    else if (dest_buffer == NULL)\n    {\n        write_log(\"No destination buffer provided; skipped memcpy.\\n\");\n    }\n    else\n    {\n        write_log(\"safe_name_len == 0; nothing copied.\\n\");\n    }\n}\n\n/*\n * Modified OS_API_Teardown preserving original logic, with logging probes before/after\n * the critical calls so the control flow and timing are captured in the log file.\n */\nvoid OS_API_Teardown(void)\n{\n    write_log(\"OS_API_Teardown: entry\\n\");\n\n    write_log(\"OS_API_Teardown: calling OS_DeleteAllObjects()\\n\");\n    OS_DeleteAllObjects();\n    write_log(\"OS_API_Teardown: returned from OS_DeleteAllObjects()\\n\");\n\n    write_log(\"OS_API_Teardown: calling OS_ApplicationShutdown(true)\\n\");\n    OS_ApplicationShutdown(true);\n    write_log(\"OS_API_Teardown: returned from OS_ApplicationShutdown(true)\\n\");\n\n    write_log(\"OS_API_Teardown: exit\\n\");\n}\n"
}