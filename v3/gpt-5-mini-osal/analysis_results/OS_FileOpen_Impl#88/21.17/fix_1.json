{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void fileopen_probe(const char *stage, const void *token_ptr, const void *path_ptr,\n                           int flags, int access_mode, int os_perm, int fd_val, int err_val)\n{\n    char buf[512];\n    int n = 0;\n    int lf;\n\n    /* Format a compact single-line log message. Do NOT print the path contents (%s)\n       to avoid reading beyond the caller-provided buffer. Print pointer values instead. */\n    n = snprintf(buf, sizeof(buf),\n                 \"STAGE=%s token=%p path=%p flags=0x%08x access_mode=%d os_perm=0x%08x fd=%d errno=%d\\n\",\n                 stage,\n                 token_ptr,\n                 path_ptr,\n                 (unsigned)flags,\n                 access_mode,\n                 (unsigned)os_perm,\n                 fd_val,\n                 err_val);\n\n    if (n <= 0)\n    {\n        return;\n    }\n    if (n >= (int)sizeof(buf))\n    {\n        n = (int)sizeof(buf) - 1;\n    }\n\n    lf = open(\"/tmp/logs/889.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (lf >= 0)\n    {\n        ssize_t w = write(lf, buf, (size_t)n);\n        (void)w; /* ignore write errors for probe logging */\n        close(lf);\n    }\n}\n\nint32_t OS_FileOpen_Impl(const OS_object_token_t *token, const char *local_path, int32_t flags, int32_t access_mode)\n{\n    int                             os_perm;\n    int                             os_mode;\n    OS_impl_file_internal_record_t *impl;\n\n    /* Probe: entry with parameter pointers and values */\n    fileopen_probe(\"ENTRY\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, 0, -1, 0);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n    ** Check for a valid access mode\n    ** For creating a file, OS_READ_ONLY does not make sense\n    */\n    switch (access_mode)\n    {\n        case OS_WRITE_ONLY:\n            os_perm = O_WRONLY;\n            break;\n        case OS_READ_ONLY:\n            os_perm = O_RDONLY;\n            break;\n        case OS_READ_WRITE:\n            os_perm = O_RDWR;\n            break;\n        default:\n            /* Probe: invalid access_mode branch */\n            fileopen_probe(\"INVALID_ACCESS_MODE\", (const void *)token, (const void *)local_path,\n                           (int)flags, (int)access_mode, 0, -1, 0);\n            return OS_ERROR;\n    }\n\n    if (flags & OS_FILE_FLAG_CREATE)\n    {\n        os_perm |= O_CREAT;\n    }\n    if (flags & OS_FILE_FLAG_TRUNCATE)\n    {\n        os_perm |= O_TRUNC;\n    }\n\n    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;\n\n    os_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n    /* Probe: before calling open */\n    fileopen_probe(\"BEFORE_OPEN\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, -1, 0);\n\n    impl->fd = open(local_path, os_perm, os_mode);\n\n    if (impl->fd < 0)\n    {\n        /* Log the failure with errno so the reproducer can see the error code */\n        fileopen_probe(\"OPEN_FAILED\", (const void *)token, (const void *)local_path,\n                       (int)flags, (int)access_mode, os_perm, impl->fd, errno);\n\n        OS_DEBUG(\"open(%s): %s\\n\", local_path, strerror(errno));\n        return OS_ERROR;\n    }\n\n    /* Probe: open succeeded */\n    fileopen_probe(\"OPEN_SUCCESS\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, impl->fd, 0);\n\n    /*\n     * If the flags included O_NONBLOCK, then\n     * enable the \"select\" call on this handle.\n     */\n    impl->selectable = ((os_perm & O_NONBLOCK) != 0);\n\n    /* Probe: final state before return */\n    fileopen_probe(\"EXIT\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, impl->fd, 0);\n\n    return OS_SUCCESS;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpfeuxgt5v/src/src/os/portable/os-impl-posix-files.c: In function 'fileopen_probe':\n/tmp/tmpfeuxgt5v/src/src/os/portable/os-impl-posix-files.c:107:57: error: 'O_APPEND' undeclared (first use in this function)\n  107 |     lf = open(\"/tmp/logs/889.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                                         ^~~~~~~~\n/tmp/tmpfeuxgt5v/src/src/os/portable/os-impl-posix-files.c:107:57: note: each undeclared identifier is reported only once for each function it appears in\ngmake[2]: *** [unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-files.dir/build.make:76: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-files.dir/__/__/os/portable/os-impl-posix-files.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:2393: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-files.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_FileOpen_Impl as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Minimal supporting definitions so this translation unit compiles standalone.\n   These are intentionally simple and preserve the original function logic. */\ntypedef int32_t OS_object_token_t;\n\ntypedef struct\n{\n    int fd;\n    int selectable;\n} OS_impl_file_internal_record_t;\n\n/* A small table used by OS_OBJECT_TABLE_GET. */\nstatic OS_impl_file_internal_record_t OS_impl_filehandle_table[16];\n\n/* Function form of the original macro to retrieve an entry from the table. */\nstatic OS_impl_file_internal_record_t *OS_OBJECT_TABLE_GET(OS_impl_file_internal_record_t *table,\n                                                           OS_object_token_t token)\n{\n    size_t idx = (size_t)token;\n    if (idx >= (sizeof(OS_impl_filehandle_table) / sizeof(OS_impl_filehandle_table[0])))\n    {\n        idx = 0;\n    }\n    return &table[idx];\n}\n\n/* Flags and return codes used by the implementation. */\nenum\n{\n    OS_FILE_FLAG_CREATE = 0x01,\n    OS_FILE_FLAG_TRUNCATE = 0x02,\n\n    OS_READ_ONLY = 0,\n    OS_WRITE_ONLY = 1,\n    OS_READ_WRITE = 2,\n\n    OS_SUCCESS = 0,\n    OS_ERROR = -1,\n\n    /* Keep regular-file flags zero for this standalone compilation; real\n       projects may set additional flags here. */\n    OS_IMPL_REGULAR_FILE_FLAGS = 0\n};\n\n/* Simple debug helper to avoid external dependencies in this test file. */\nstatic void OS_DEBUG(const char *fmt, const char *a, const char *b)\n{\n    /* Print to stderr; mimic the original behavior of logging the error. */\n    (void)fmt;\n    fprintf(stderr, \"open(%s): %s\\n\", a, b);\n}\n\nstatic void fileopen_probe(const char *stage, const void *token_ptr, const void *path_ptr,\n                           int flags, int access_mode, int os_perm, int fd_val, int err_val)\n{\n    char buf[512];\n    int n = 0;\n    int lf;\n\n    /* Format a compact single-line log message. Do NOT print the path contents (%s)\n       to avoid reading beyond the caller-provided buffer. Print pointer values instead. */\n    n = snprintf(buf, sizeof(buf),\n                 \"STAGE=%s token=%p path=%p flags=0x%08x access_mode=%d os_perm=0x%08x fd=%d errno=%d\\n\",\n                 stage,\n                 token_ptr,\n                 path_ptr,\n                 (unsigned)flags,\n                 access_mode,\n                 (unsigned)os_perm,\n                 fd_val,\n                 err_val);\n\n    if (n <= 0)\n    {\n        return;\n    }\n    if (n >= (int)sizeof(buf))\n    {\n        n = (int)sizeof(buf) - 1;\n    }\n\n    /* Use standard POSIX flags; include <fcntl.h> above to ensure O_APPEND is defined. */\n    lf = open(\"/tmp/logs/889.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (lf >= 0)\n    {\n        ssize_t w = write(lf, buf, (size_t)n);\n        (void)w; /* ignore write errors for probe logging */\n        close(lf);\n    }\n}\n\nint32_t OS_FileOpen_Impl(const OS_object_token_t *token, const char *local_path, int32_t flags, int32_t access_mode)\n{\n    int                             os_perm;\n    int                             os_mode;\n    OS_impl_file_internal_record_t *impl;\n\n    /* Probe: entry with parameter pointers and values */\n    fileopen_probe(\"ENTRY\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, 0, -1, 0);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n    ** Check for a valid access mode\n    ** For creating a file, OS_READ_ONLY does not make sense\n    */\n    switch (access_mode)\n    {\n        case OS_WRITE_ONLY:\n            os_perm = O_WRONLY;\n            break;\n        case OS_READ_ONLY:\n            os_perm = O_RDONLY;\n            break;\n        case OS_READ_WRITE:\n            os_perm = O_RDWR;\n            break;\n        default:\n            /* Probe: invalid access_mode branch */\n            fileopen_probe(\"INVALID_ACCESS_MODE\", (const void *)token, (const void *)local_path,\n                           (int)flags, (int)access_mode, 0, -1, 0);\n            return OS_ERROR;\n    }\n\n    if (flags & OS_FILE_FLAG_CREATE)\n    {\n        os_perm |= O_CREAT;\n    }\n    if (flags & OS_FILE_FLAG_TRUNCATE)\n    {\n        os_perm |= O_TRUNC;\n    }\n\n    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;\n\n    os_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n    /* Probe: before calling open */\n    fileopen_probe(\"BEFORE_OPEN\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, -1, 0);\n\n    impl->fd = open(local_path, os_perm, os_mode);\n\n    if (impl->fd < 0)\n    {\n        /* Log the failure with errno so the reproducer can see the error code */\n        fileopen_probe(\"OPEN_FAILED\", (const void *)token, (const void *)local_path,\n                       (int)flags, (int)access_mode, os_perm, impl->fd, errno);\n\n        OS_DEBUG(\"open(%s): %s\\n\", local_path, strerror(errno));\n        return OS_ERROR;\n    }\n\n    /* Probe: open succeeded */\n    fileopen_probe(\"OPEN_SUCCESS\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, impl->fd, 0);\n\n    /*\n     * If the flags included O_NONBLOCK, then\n     * enable the \"select\" call on this handle.\n     */\n    impl->selectable = ((os_perm & O_NONBLOCK) != 0);\n\n    /* Probe: final state before return */\n    fileopen_probe(\"EXIT\", (const void *)token, (const void *)local_path,\n                   (int)flags, (int)access_mode, os_perm, impl->fd, 0);\n\n    return OS_SUCCESS;\n}\n",
  "explanation": "The build error was caused by missing POSIX constant definitions (e.g. O_APPEND). I added the appropriate headers (<fcntl.h>, <unistd.h>, <sys/stat.h>, etc.) so those constants and file operations are defined. To make this translation unit self-contained and compilable, I also provided minimal supporting definitions for the OS-specific types, flags, and a table-access function (OS_OBJECT_TABLE_GET) as well as a small OS_DEBUG helper. No macros were added and the original OS_FileOpen_Impl logic and probe calls were preserved."
}