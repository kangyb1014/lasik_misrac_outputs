{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_IdleLoop:\n```c\nvoid OS_IdleLoop()\n{\n    /*\n     * Wait until the shutdown value is set to the shutdown number\n     * In most \"real\" embedded systems, this will never happen.\n     * However it will happen in debugging situations (CTRL+C, etc).\n     */\n    while (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        OS_IdleLoop_Impl();\n    }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nwhile (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n{\n    OS_IdleLoop_Impl();\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in normal usage: the while-loop is reachable and will execute as long as OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER. This does not constitute unreachable code under MISRA C 2023 Rule 2.1. A concrete violation scenario would be if the condition is provably always false (or always true in a way that makes subsequent code unattainable) \u2014 for example, if OS_SharedGlobalVars.GlobalState is a compile-time constant (or statically proven to equal OS_SHUTDOWN_MAGIC_NUMBER for all executions) so the loop body can never be entered. In that specific situation the loop body would be unreachable and Rule 2.1 would be violated."
}