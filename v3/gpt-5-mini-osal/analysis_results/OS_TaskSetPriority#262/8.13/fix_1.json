{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void dump_bytes_hex(FILE *fp, const void *ptr, size_t size)\n{\n    const unsigned char *b = (const unsigned char *)ptr;\n    size_t i;\n    for (i = 0; i < size; ++i)\n    {\n        fprintf(fp, \"%02X\", (unsigned int)b[i]);\n        if ((i & 0xF) == 0xF && i + 1 < size)\n            fprintf(fp, \" \");\n    }\n}\nstatic void log_probe(const char *stage,\n                      const void *task_id_ptr, size_t task_id_size,\n                      const void *new_prio_ptr, size_t new_prio_size,\n                      const void *token_ptr, size_t token_size,\n                      const void *task_ptr, size_t task_size,\n                      int rc_get, int rc_impl)\n{\n    FILE *fp = fopen(\"/tmp/logs/2623.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging is not available, fail silently to avoid affecting logic. */\n        return;\n    }\n\n    /* timestamp */\n    {\n        time_t t = time(NULL);\n        char buf[64];\n        struct tm tm;\n        if (t != (time_t)-1 && localtime_r(&t, &tm) != NULL && strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tm) > 0)\n        {\n            fprintf(fp, \"[%s] \", buf);\n        }\n    }\n\n    fprintf(fp, \"STAGE=%s rc_get=%d rc_impl=%d\\n\", stage, rc_get, rc_impl);\n\n    if (task_id_ptr != NULL && task_id_size > 0)\n    {\n        fprintf(fp, \"  task_id (%zu bytes) = 0x\", task_id_size);\n        dump_bytes_hex(fp, task_id_ptr, task_id_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (new_prio_ptr != NULL && new_prio_size > 0)\n    {\n        fprintf(fp, \"  new_priority (%zu bytes) = 0x\", new_prio_size);\n        dump_bytes_hex(fp, new_prio_ptr, new_prio_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (token_ptr != NULL && token_size > 0)\n    {\n        fprintf(fp, \"  token (%zu bytes) = 0x\", token_size);\n        dump_bytes_hex(fp, token_ptr, token_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (task_ptr != NULL && task_size > 0)\n    {\n        fprintf(fp, \"  task_ptr (%zu bytes) = 0x\", task_size);\n        /* Only dump a limited prefix of the task record to avoid noisy logs */\n        dump_bytes_hex(fp, task_ptr, task_size > 64 ? 64 : task_size);\n        if (task_size > 64) fprintf(fp, \"..(truncated)\");\n        fprintf(fp, \"\\n\");\n    }\n\n    fprintf(fp, \"---\\n\");\n    fclose(fp);\n}\n\nint32 OS_TaskSetPriority(osal_id_t task_id, osal_priority_t new_priority)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n\n    /* Log immediately after attempting to get the object id */\n    log_probe(\"after_ObjectIdGetById\",\n              &task_id, sizeof(task_id),\n              &new_priority, sizeof(new_priority),\n              &token, sizeof(token),\n              NULL, 0,\n              return_code, -1);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Log before calling the platform-impl function */\n        log_probe(\"before_TaskSetPriority_Impl\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  return_code, -1);\n\n        return_code = OS_TaskSetPriority_Impl(&token, new_priority);\n\n        /* Log immediately after calling the platform-impl function */\n        log_probe(\"after_TaskSetPriority_Impl\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  /* rc_get */ 0, /* placeholder - original return_code has been updated */ return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* Use the abstracted priority, not the OS one */\n            /* Change the priority in the table as well */\n            task->priority = new_priority;\n\n            /* Log the success and the updated task priority field */\n            log_probe(\"after_priority_update\",\n                      &task_id, sizeof(task_id),\n                      &new_priority, sizeof(new_priority),\n                      &token, sizeof(token),\n                      task, sizeof(*task),\n                      /* rc_get */ 0, return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after releasing the object token */\n        log_probe(\"after_ObjectIdRelease\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  /* rc_get */ 0, return_code);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpw3d_k_ul/src/src/os/shared/src/osapi-task.c: In function 'log_probe':\n/tmp/tmpw3d_k_ul/src/src/os/shared/src/osapi-task.c:329:19: error: storage size of 'tm' isn't known\n  329 |         struct tm tm;\n      |                   ^~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/__/__/os/shared/src/osapi-task.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:4283: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_TaskSetPriority as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <time.h>\n#include <stddef.h>\n\nstatic void dump_bytes_hex(FILE *fp, const void *ptr, size_t size)\n{\n    const unsigned char *b = (const unsigned char *)ptr;\n    size_t i;\n    for (i = 0; i < size; ++i)\n    {\n        fprintf(fp, \"%02X\", (unsigned int)b[i]);\n        if ((i & 0xF) == 0xF && i + 1 < size)\n            fprintf(fp, \" \");\n    }\n}\nstatic void log_probe(const char *stage,\n                      const void *task_id_ptr, size_t task_id_size,\n                      const void *new_prio_ptr, size_t new_prio_size,\n                      const void *token_ptr, size_t token_size,\n                      const void *task_ptr, size_t task_size,\n                      int rc_get, int rc_impl)\n{\n    FILE *fp = fopen(\"/tmp/logs/2623.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging is not available, fail silently to avoid affecting logic. */\n        return;\n    }\n\n    /* timestamp */\n    {\n        time_t t = time(NULL);\n        char buf[64];\n        struct tm tm;\n        if (t != (time_t)-1 && localtime_r(&t, &tm) != NULL && strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tm) > 0)\n        {\n            fprintf(fp, \"[%s] \", buf);\n        }\n    }\n\n    fprintf(fp, \"STAGE=%s rc_get=%d rc_impl=%d\\n\", stage, rc_get, rc_impl);\n\n    if (task_id_ptr != NULL && task_id_size > 0)\n    {\n        fprintf(fp, \"  task_id (%zu bytes) = 0x\", task_id_size);\n        dump_bytes_hex(fp, task_id_ptr, task_id_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (new_prio_ptr != NULL && new_prio_size > 0)\n    {\n        fprintf(fp, \"  new_priority (%zu bytes) = 0x\", new_prio_size);\n        dump_bytes_hex(fp, new_prio_ptr, new_prio_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (token_ptr != NULL && token_size > 0)\n    {\n        fprintf(fp, \"  token (%zu bytes) = 0x\", token_size);\n        dump_bytes_hex(fp, token_ptr, token_size);\n        fprintf(fp, \"\\n\");\n    }\n\n    if (task_ptr != NULL && task_size > 0)\n    {\n        fprintf(fp, \"  task_ptr (%zu bytes) = 0x\", task_size);\n        /* Only dump a limited prefix of the task record to avoid noisy logs */\n        dump_bytes_hex(fp, task_ptr, task_size > 64 ? 64 : task_size);\n        if (task_size > 64) fprintf(fp, \"..(truncated)\");\n        fprintf(fp, \"\\n\");\n    }\n\n    fprintf(fp, \"---\\n\");\n    fclose(fp);\n}\n\nint32 OS_TaskSetPriority(osal_id_t task_id, osal_priority_t new_priority)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n\n    /* Log immediately after attempting to get the object id */\n    log_probe(\"after_ObjectIdGetById\",\n              &task_id, sizeof(task_id),\n              &new_priority, sizeof(new_priority),\n              &token, sizeof(token),\n              NULL, 0,\n              return_code, -1);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Log before calling the platform-impl function */\n        log_probe(\"before_TaskSetPriority_Impl\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  return_code, -1);\n\n        return_code = OS_TaskSetPriority_Impl(&token, new_priority);\n\n        /* Log immediately after calling the platform-impl function */\n        log_probe(\"after_TaskSetPriority_Impl\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  /* rc_get */ 0, /* placeholder - original return_code has been updated */ return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* Use the abstracted priority, not the OS one */\n            /* Change the priority in the table as well */\n            task->priority = new_priority;\n\n            /* Log the success and the updated task priority field */\n            log_probe(\"after_priority_update\",\n                      &task_id, sizeof(task_id),\n                      &new_priority, sizeof(new_priority),\n                      &token, sizeof(token),\n                      task, sizeof(*task),\n                      /* rc_get */ 0, return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after releasing the object token */\n        log_probe(\"after_ObjectIdRelease\",\n                  &task_id, sizeof(task_id),\n                  &new_priority, sizeof(new_priority),\n                  &token, sizeof(token),\n                  task, sizeof(*task),\n                  /* rc_get */ 0, return_code);\n    }\n\n    return return_code;\n}\n",
  "explanation": "The compile error was due to the use of struct tm and related time functions without including <time.h>. I added #include <time.h> (and ensured <stdio.h> and <stddef.h> are included) at the top so struct tm, time(), localtime_r(), and strftime() are declared. No other logic or functions were changed; the OS_TaskSetPriority implementation and logging behavior are preserved."
}