{
  "user_message": "An agent A claimed that the following UtAssert_GetOpText code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_GetOpText.\n```c\nconst char *UtAssert_GetOpText(UtAssert_Compare_t CompareType)\n{\n    const char *OpText;\n\n    switch (CompareType)\n    {\n        case UtAssert_Compare_EQ: /* actual equals reference value */\n            OpText = \"==\";\n            break;\n        case UtAssert_Compare_NEQ: /* actual does not non equal reference value */\n            OpText = \"!=\";\n            break;\n        case UtAssert_Compare_LT: /* actual less than reference (exclusive) */\n            OpText = \"<\";\n            break;\n        case UtAssert_Compare_GT: /* actual greater than reference (exclusive)  */\n            OpText = \">\";\n            break;\n        case UtAssert_Compare_LTEQ: /* actual less than or equal to reference (inclusive) */\n            OpText = \"<=\";\n            break;\n        case UtAssert_Compare_GTEQ: /* actual greater than reference (inclusive) */\n            OpText = \">=\";\n            break;\n        case UtAssert_Compare_BITMASK_SET: /* bit(s) in reference are set in actual */\n            OpText = \"&\";\n            break;\n        case UtAssert_Compare_BITMASK_UNSET: /* bit(s) in reference are not set in actual */\n            OpText = \"&~\";\n            break;\n        default: /* should never happen */\n            OpText = \"??\";\n            break;\n    }\n\n    return OpText;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'RadixType' (of type UtAssert_Radix_t) is assigned to: 'RadixType = UtAssert_Radix_HEX;' when Typename contains '*'. This modifies the function parameter variable rather than using a local copy; per MISRA C 2023 Rule 17.8 a function parameter shall not be modified. Instead a local variable should be used (e.g., 'UtAssert_Radix_t LocalRadix = RadixType;') and modified as needed.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAssert_GetOpText: CompareType=1, OpText=\"==\"\nUtAsser\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_GetOpText:\ntypedef enum\n{\n    UtAssert_Compare_NONE,          /**< invalid/not used, always false */\n    UtAssert_Compare_EQ,            /**< actual equals reference value */\n    UtAssert_Compare_NEQ,           /**< actual does not non equal reference value */\n    UtAssert_Compare_LT,            /**< actual less than reference (exclusive) */\n    UtAssert_Compare_GT,            /**< actual greater than reference (exclusive)  */\n    UtAssert_Compare_LTEQ,          /**< actual less than or equal to reference (inclusive) */\n    UtAssert_Compare_GTEQ,          /**< actual greater than reference (inclusive) */\n    UtAssert_Compare_BITMASK_SET,   /**< actual equals reference value */\n    UtAssert_Compare_BITMASK_UNSET, /**< actual equals reference value */\n    UtAssert_Compare_MAX            /**< placeholder, not used */\n} UtAssert_Compare_t\n...\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    if (strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        ActualText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n    if (strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        RefText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is incorrect as applied to UtAssert_GetOpText. In the posted UtAssert_GetOpText implementation the parameter CompareType is only read (used in the switch) and is never assigned to, so there is no modification of the function parameter and no violation of MISRA C 2023 Rule 17.8 in that function.\n\nHowever, the scenario described by agent A (assigning RadixType = UtAssert_Radix_HEX when Typename contains '*') refers to a different function (UtAssert_GenericIntegerCompare). That assignment would indeed modify a non-pointer function parameter and thus would violate Rule 17.8. The proper fix is to use a local copy (e.g., UtAssert_Radix_t LocalRadix = RadixType;) and modify LocalRadix, then use LocalRadix in subsequent calls. The execution log shown is unrelated to the claimed change to a parameter in UtAssert_GetOpText."
}