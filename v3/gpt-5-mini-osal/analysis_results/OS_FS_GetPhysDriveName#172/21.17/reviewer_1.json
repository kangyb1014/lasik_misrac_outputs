{
  "user_message": "An agent A claimed that the following OS_FS_GetPhysDriveName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FS_GetPhysDriveName.\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the caller passes a destination buffer smaller than OS_FS_PHYS_NAME_LEN (64). The code calls strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1) which may write up to 63 bytes into PhysDriveName, and then writes a terminator at PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] (index 63). If PhysDriveName does not point to at least 64 bytes (for example char buf[16]; OS_FS_GetPhysDriveName(buf, ...) ), these writes will exceed the buffer bounds and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FS_GetPhysDriveName:\n#define OS_FS_PHYS_NAME_LEN 64\n...\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\nOS_filesys_internal_record_t OS_filesys_table[LOCAL_NUM_OBJECTS]\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM 0x10\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CHECK_PATHNAME(str) OS_CHECK_STRING(str,OS_MAX_PATH_LEN,OS_FS_ERR_PATH_TOO_LONG)\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_SUCCESS (0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function unconditionally copies up to OS_FS_PHYS_NAME_LEN - 1 bytes into the caller-supplied PhysDriveName buffer and then writes a terminator at PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] without any check that the object referenced by PhysDriveName is at least OS_FS_PHYS_NAME_LEN bytes long. MISRA C 2023 Rule 21.17 forbids use of string.h functions that can access beyond the bounds of the objects referenced by their pointer parameters. Because the code does not provably ensure the destination buffer size, a caller passing a smaller buffer (e.g. char buf[16]) can cause out-of-bounds writes via strncpy and the fixed terminating write, so the reported violation is valid. To remediate, the function should take/verify a destination-size parameter (or otherwise ensure the buffer is at least OS_FS_PHYS_NAME_LEN), or copy using a length computed from the actual destination object size (or a safe wrapper like strlcpy) and ensure termination without writing past the provided buffer."
}