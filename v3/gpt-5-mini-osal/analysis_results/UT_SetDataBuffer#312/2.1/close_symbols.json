{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UtAssert_Abort",
    "UT_StubTableEntry_t",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF",
    "UT_DefaultHandler_OS_QueuePut",
    "UT_EntryKey_t"
  ],
  "explanation": "UT_GetStubEntry \u2014 Need the function definition/behavior to determine whether it can ever return NULL for given FuncKey and UT_ENTRYTYPE_UNUSED. If it is provably never-NULL (or always-NULL) then the corresponding branch(s) in UT_SetDataBuffer would be unreachable.\n\nUtAssert_Abort \u2014 Need the declaration/definition (especially any noreturn semantics) to know whether calling it makes subsequent code unreachable; this affects reachability analysis of code paths that lead to or follow the call.\n\nUT_StubTableEntry_t \u2014 Need the full struct definition to confirm which members are used and whether any assignments/side-effects could be optimized away or rendered unreachable by type/aliasing rules; also useful to see whether writes are observable.\n\nUT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER \u2014 Need the macros/constants so the semantics of the UT_GetStubEntry call argument are known and to check for any compile-time constant propagation that could make a branch constant/unreachable.\n\nUT_MODEFLAG_ALLOC_BUF \u2014 Need the constant definition to ensure that setting ModeFlags has no hidden control-flow implications and to check for any compile-time constant interactions that could affect reachability.\n\nUT_DefaultHandler_OS_QueuePut \u2014 Need the caller(s) implementation(s) to know how UT_SetDataBuffer is invoked in practice (what values for DataBuffer, BufferSize and AllocateCopy are passed). If callers always pass values that make a branch condition constant (e.g. AllocateCopy always false), that would indicate unreachable code in the other branch.\n\nUT_EntryKey_t \u2014 Need the typedef/range/representation of FuncKey because UT_GetStubEntry behavior may depend on the key domain; constant or limited ranges could make some branches unreachable."
}