{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_DefaultHandler_OS_QueuePut",
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "malloc",
    "UtAssert_Abort"
  ],
  "explanation": "Needed symbols and why they matter for checking \"controlling expressions shall not be invariant\":\n\n- UT_GetStubEntry\n  - The controlling expression 'if (StubPtr == NULL)' depends entirely on the return value of UT_GetStubEntry. To decide whether that test can ever vary (i.e. is not invariant) we must know UT_GetStubEntry semantics/implementation (can it return NULL, under what inputs, any side-effects, deterministic behavior).\n\n- UT_DefaultHandler_OS_QueuePut\n  - This is the only caller shown in the static call graph. To determine whether the input controlling expression 'if (DataBuffer != NULL && BufferSize > 0)' or the 'if (AllocateCopy)' test can be invariant in practice, we must inspect the caller to see what actual arguments it supplies (are they constant, derived from constants, or variable?). If the caller always passes the same constant values, the controlling expressions in UT_SetDataBuffer could be effectively invariant.\n\n- UT_StubTableEntry_t\n  - The code tests StubPtr and later dereferences StubPtr->Data.Buff.BasePtr and sets fields. To reason about whether 'StubPtr->Data.Buff.BasePtr == NULL' (after malloc) is a meaningful, variable test, and to ensure the controlling expressions are valid, the struct definition is required (types of BasePtr, TotalSize, Position, ModeFlags); it also helps determine whether any member access is actually a constant expression (e.g., if compiled as macro/constant) or dependent on runtime state.\n\n- UT_EntryKey_t\n  - The type/representation of FuncKey can affect UT_GetStubEntry selection behavior. Knowing whether UT_EntryKey_t is an enum, integer, or opaque type helps determine if calls to UT_GetStubEntry from callers may always use the same key (making downstream tests invariant).\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER\n  - These constants are passed to UT_GetStubEntry and assigned to StubPtr->EntryType. Their definitions may influence UT_GetStubEntry behavior (i.e. whether it always returns the same entry or NULL) and thus whether the 'StubPtr == NULL' test is variable.\n\n- malloc\n  - The controlling expression 'if (StubPtr->Data.Buff.BasePtr == NULL)' depends on malloc's return. To conclude whether that condition is potentially variable (not invariant) one must know if malloc could fail in the build/test environment or whether it is replaced/wrapped to always succeed/fail. Knowledge of the allocator behavior matters for the invariance check.\n\n- UtAssert_Abort\n  - Although not a controlling expression itself, UtAssert_Abort is called from branches controlled by the expressions under inspection. Its semantics (notably whether it is noreturn/aborting) affect control-flow reasoning: if the call never returns, a branch could be considered terminal, which matters when deciding whether a condition is effectively invariant in the remaining reachable code paths.\n\nNotes:\n- Standard library declarations for memcpy and size_t/bool are routine; they do not affect whether the controlling expressions are invariant, so they are not included here.\n- If additional callers of UT_SetDataBuffer are discovered, those caller implementations should also be provided because they may supply constant arguments that make the controlling expressions invariant."
}