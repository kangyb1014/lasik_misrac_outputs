{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t (typedef)",
    "UT_StubTableEntry_t (complete struct/union definition, including nested Data/Buff types and all fields: FuncKey, EntryType, ModeFlags, Data)",
    "Definition(s) of the nested Data and Buff types used inside UT_StubTableEntry_t (all member types: BasePtr, TotalSize, Position, etc.)",
    "Type of ModeFlags field (the underlying integer/bitfield type used for ModeFlags)",
    "UT_GetStubEntry (prototype/signature and implementation if it contains nonstandard declarations)",
    "UtAssert_Abort (prototype/signature and implementation if it contains nonstandard declarations)",
    "UT_ENTRYTYPE_UNUSED (macro or enum definition)",
    "UT_ENTRYTYPE_DATA_BUFFER (macro or enum definition)",
    "UT_MODEFLAG_ALLOC_BUF (macro or enum definition)",
    "bool (definition / header include that brings it in \u2014 e.g. stdbool.h or alternative typedef)",
    "size_t (definition / header include \u2014 e.g. stddef.h or alternative typedef)",
    "malloc (declaration \u2014 header or custom wrapper)",
    "memcpy (declaration \u2014 header or custom wrapper)",
    "NULL (macro definition)"
  ],
  "explanation": "To determine whether UT_SetDataBuffer uses any compiler/language extensions you must inspect the actual types, macros and declarations it references. Specifically:\n\n- UT_EntryKey_t: Check whether this typedef uses any compiler-specific extension (e.g. __int128, __attribute__, nonstandard integer types).\n- UT_StubTableEntry_t: The full struct/union body is needed to detect anonymous structs/unions, compiler-specific packing/align attributes, bitfields with nonstandard widths, or other extension constructs used in the type.\n- Nested Data/Buff types: The buffer fields (BasePtr, TotalSize, Position) might be declared with extensions (anonymous members, GCC extensions, unusual pointer types). Inspecting them is required to confirm standard compliance.\n- ModeFlags type: The |= operation may behave differently if ModeFlags is a bitfield or uses compiler-specific qualifiers; its underlying type must be checked for extensions.\n- UT_GetStubEntry and UtAssert_Abort: Their prototypes/definitions are needed to ensure they don't use nonstandard declarations or calling conventions (e.g. varargs with compiler-specific attributes, __attribute__ annotations) that would imply language extensions relevant to this unit.\n- UT_ENTRYTYPE_*/UT_MODEFLAG_ALLOC_BUF macros or enums: Macros or enum definitions can hide compiler extensions (e.g. use of typeof, statement-expressions, large constant attributes); inspect them to ensure they are standard.\n- bool, size_t, NULL, malloc, memcpy: Confirm these are the standard C library/type definitions (from stdbool.h, stddef.h/stdlib.h/string.h) and not redefined using compiler-specific constructs or macros. If these are redefined in project headers using extensions, that would be a violation.\n\nProviding these symbols (full type and macro definitions and relevant prototypes) lets the next analyst detect any use of language extensions (attributes, compiler-specific keywords, anonymous/extension members, nonstandard typedefs, etc.) that would violate the MISRA rule."
}