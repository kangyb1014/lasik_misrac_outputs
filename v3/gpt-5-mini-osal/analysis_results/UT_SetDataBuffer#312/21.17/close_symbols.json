{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_GetStubEntry",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF",
    "UT_StubTableEntry_t::Data.Buff (BasePtr, TotalSize, Position)",
    "malloc",
    "memcpy",
    "UtAssert_Abort",
    "size_t",
    "bool",
    "UT_DefaultHandler_OS_QueuePut (caller signature)"
  ],
  "explanation": "For checking the <string.h> rule (memcpy must not read/write out-of-bounds) the analyzer needs the following symbols and why:\n\n- UT_StubTableEntry_t\n  - To know the exact layout and types of the stub table entry, in particular the Data union/struct so we can reason about what BasePtr points to and what TotalSize/Position represent (units, valid ranges) and whether BasePtr is owned/allocated or aliasing other objects.\n\n- UT_StubTableEntry_t::Data.Buff (fields BasePtr, TotalSize, Position)\n  - Explicit field definitions are needed to determine the destination buffer type and capacity after allocation (BasePtr type, TotalSize semantics) and whether Position or TotalSize impose constraints that could make memcpy exceed the destination bounds.\n\n- UT_GetStubEntry\n  - Its signature and semantics (when it returns an existing entry vs. a fresh/cleared entry) matter because the returned StubPtr may already contain pointers/metadata that affect ownership/aliasing/size. Also needed to know whether StubPtr->Data was initialized or reused.\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER\n  - The meaning of these constants can affect control flow and interpretation of the entry contents (i.e., whether Data.Buff fields are valid for use and whether any prior content must be preserved), which is important to ensure memcpy writes to a properly sized/owned buffer.\n\n- UT_MODEFLAG_ALLOC_BUF\n  - To know when the code marks ownership of the allocated buffer; ownership/flag semantics affect whether BasePtr points to previously managed memory (possible alias) and whether subsequent code expects a certain buffer size.\n\n- malloc\n  - Prototype and allocation semantics are required to confirm that malloc(BufferSize) returns at least BufferSize bytes (or NULL) and to reason about overflow or unrealistic BufferSize values; also to consider integer-to-size_t conversion and possible allocation failure paths.\n\n- memcpy\n  - Prototype and required semantics (copies exactly n bytes from source to dest; undefined behavior if source or dest do not have at least n bytes or if regions overlap) are the central standard-library rule being checked. The analyzer must know that memcpy does not tolerate overlap and that it requires both pointers to reference objects at least BufferSize bytes long.\n\n- UtAssert_Abort\n  - Its behavior on assertion failure (does it abort/longjmp/terminate or return) matters for control-flow reasoning: if UtAssert_Abort never returns, then the analyzer can assume no further code executes on allocation failure; if it might return, the subsequent state must be considered.\n\n- size_t\n  - To confirm types and integer width/limits for BufferSize and malloc argument/return conversions; to reason about integer overflow or excessively large values that could cause out-of-bounds or allocation issues.\n\n- bool\n  - To know the semantics of AllocateCopy and ensure the conditional path analysis (copy vs. direct aliasing) is correct.\n\n- UT_DefaultHandler_OS_QueuePut (caller signature)\n  - As a known caller (in the static call graph), the caller(s) and their calling convention determine how DataBuffer and BufferSize are passed in practice. The analyzer needs the caller signature and typical/provided buffer provenance to decide whether the source object pointed to by DataBuffer is at least BufferSize bytes long or might alias the destination (overlap) in ways that make memcpy unsafe.\n\nTogether these symbols let the analyzer determine: (1) the destination object size after malloc(BufferSize); (2) whether memcpy is invoked with n = BufferSize and whether the source object (DataBuffer) is guaranteed to be at least BufferSize bytes; (3) whether source and destination can overlap (memcpy requires non-overlap) or alias existing objects; and (4) whether error paths (malloc failure) terminate execution. Without these definitions/semantics you cannot conclude whether the memcpy call conforms to the MISRA rule against out-of-bounds accesses."
}