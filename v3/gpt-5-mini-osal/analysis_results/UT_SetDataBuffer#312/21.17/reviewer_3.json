{
  "user_message": "An agent A claimed that the following UT_SetDataBuffer code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_SetDataBuffer.\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the caller provides a DataBuffer that is smaller than BufferSize (for example: char src[10]; UT_SetDataBuffer(key, src, 20, true);), the function allocates a destination of BufferSize but copies BufferSize bytes from DataBuffer without verifying that DataBuffer actually references at least BufferSize bytes. This can cause an out-of-bounds read of the source buffer (and thus an access beyond the bounds of the object referenced by the source pointer), violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_SetDataBuffer ENTRY: FuncKey=94386132043427 DataBuffer=0x7ffd8da3bff0 BufferSize=48 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55d7fbe136e0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ffd8da3bff0\n   Final stub state: BasePtr=0x7ffd8da3bff0 TotalSize=48 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94347508104533 DataBuffer=0x55cefdb60aa0 BufferSize=32768 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55cefdb716c0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x55cefdb60aa0\n   Final stub state: BasePtr=0x55cefdb60aa0 TotalSize=32768 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94347508105393 DataBuffer=0x55cefdb60aa0 BufferSize=32768 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55cefdb75ec0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x55cefdb60aa0\n   Final stub state: BasePtr=0x55cefdb60aa0 TotalSize=32768 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94347508109457 DataBuffer=0x7fffd2f2cfd0 BufferSize=8 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55cefdb6dd60\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7fffd2f2cfd0\n   Final stub state: BasePtr=0x7fffd2f2cfd0 TotalSize=8 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94347508109457 DataBuffer=0x7fffd2f2cfd0 BufferSize=8 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55cefdb6dd60\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7fffd2f2cfd0\n   Final stub state: BasePtr=0x7fffd2f2cfd0 TotalSize=8 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94259298388867 DataBuffer=0x7ffe28d15880 BufferSize=32 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55ba740173e0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ffe28d15880\n   Final stub state: BasePtr=0x7ffe28d15880 TotalSize=32 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94259298389046 DataBuffer=0x7ffe28d15880 BufferSize=32 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55ba74015d60\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ffe28d15880\n   Final stub state: BasePtr=0x7ffe28d15880 TotalSize=32 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94259298388867 DataBuffer=0x7ffe28d15880 BufferSize=32 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55ba740173e0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ffe28d15880\n   Final stub state: BasePtr=0x7ffe28d15880 TotalSize=32 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94259298387928 DataBuffer=0x7ffe28d15818 BufferSize=4 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55ba7401b2e0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ffe28d15818\n   Final stub state: BasePtr=0x7ffe28d15818 TotalSize=4 Position=0 ModeFlags=0x00000000\nUT_SetDataBuffer ENTRY: FuncKey=94259298387928 DataBuffer=0x7ffe28d15818 BufferSize=4 AllocateCopy=0\n-> DataBuffer non-NULL and BufferSize>0, looking up stub entry...\n   UT_GetStubEntry returned StubPtr=0x55ba7401b2e0\n   Set StubPtr->FuncKey and EntryType to DATA_BUFFER\n   Using provided buffer directly: BasePtr=0x7ff\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_SetDataBuffer:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\n#define UT_MODEFLAG_ALLOC_BUF 0x1U\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. When AllocateCopy is true the function does memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize) but the code never verifies that the object referenced by DataBuffer actually contains at least BufferSize bytes. If a caller passes a smaller source (e.g. char src[10]; BufferSize=20) this will perform an out\u2011of\u2011bounds read of the source, which violates MISRA C 2023 Rule 21.17. (Note: the problem occurs on the AllocateCopy==true path; if there is an external, enforced precondition guaranteeing the source size >= BufferSize that must be documented/verified to satisfy MISRA.)"
}