{
  "user_message": "An agent A claimed that the following OS_unmount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_unmount.\n```c\nint32 OS_unmount(const char *mountpoint)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_STRING(mountpoint, sizeof(filesys->virtual_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)mountpoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /*\n         * FIXED flag should always be unset (these don't support mount/unmount at all)\n         * READY flag should be set (mkfs/initfs must have been called on this FS)\n         * MOUNTED SYSTEM/VIRTUAL should always be unset.\n         *\n         * The FIXED flag is not enforced to support abstraction.\n         */\n        if ((filesys->flags & ~OS_FILESYS_FLAG_IS_FIXED) !=\n            (OS_FILESYS_FLAG_IS_READY | OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL))\n        {\n            /* unmount() cannot be used on this file system at this time */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_FileSysUnmountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* mark as mounted in the local table.\n             * For now this does both sides (system and virtual) */\n            filesys->flags &= ~(OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'ref' is declared as void * (non-const) and is cast to a const-qualified pointer inside the function: const char *target = (const char *)ref; This hides the fact that the referenced data is not intended to be modified. According to MISRA C 2023 Rule 8.13 the parameter should be declared to point to a const-qualified type (e.g. const void *ref) so callers and the API reflect that the data will not be modified. The correct fix is to change the function prototype to take const void *ref and remove the cast.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_unmount ENTRY: mountpoint=0x55c855d15290; mountpoint_str=\"/drive3\"\nOS_unmount: after OS_CHECK_STRING\nOS_unmount: OS_ObjectIdGetBySearch returned -17; token_addr=0x7ffe2fa56d80\nOS_unmount: mapping return_code -17 to OS_ERR_NAME_NOT_FOUND\nOS_unmount EXIT: return_code=-17\nOS_unmount ENTRY: mountpoint=0x55c855d15290; mountpoint_str=\"/drive3\"\nOS_unmount: after OS_CHECK_STRING\nOS_unmount: OS_ObjectIdGetBySearch returned -17; token_addr=0x7ffe2fa56d80\nOS_unmount: mapping return_code -17 to OS_ERR_NAME_NOT_FOUND\nOS_unmount EXIT: return_code=-17\nOS_unmount ENTRY: mountpoint=0x55c855d15290; mountpoint_str=\"/drive3\"\nOS_unmount: after OS_CHECK_STRING\nOS_unmount: OS_ObjectIdGetBySearch returned -17; token_addr=0x7ffe2fa56d80\nOS_unmount: mapping return_code -17 to OS_ERR_NAME_NOT_FOUND\nOS_unmount EXIT: return_code=-17\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_unmount:\n#define OS_CHECK_STRING(str, maxlen, errcode) do{OS_CHECK_POINTER(str);LENGTHCHECK(str,maxlen,errcode);}while(0)\n...\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_filesys_internal_record_t OS_filesys_table[LOCAL_NUM_OBJECTS]\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nbool OS_FileSys_FindVirtMountPoint(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_filesys_internal_record_t *filesys;\n    const char *                  target = (const char *)ref;\n    size_t                        mplen;\n\n    filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL) == 0)\n    {\n        return false;\n    }\n\n    mplen = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n    /*\n     * The virtual_mountpt member should be a substring of the search target.\n     * If this matches a basic substring check then it may be match\n     */\n    if (mplen == 0 || mplen >= sizeof(filesys->virtual_mountpt) ||\n        strncmp(target, filesys->virtual_mountpt, mplen) != 0)\n    {\n        /* not a substring, so not a match */\n        return false;\n    }\n\n    /*\n     * Confirm that the substring ends at either a directory separator\n     * or the end of string  (so exact mount points also match).\n     *\n     * For instance consider a virtual_mountpt of /mnt/abc and searching\n     * for target=/mnt/abcd - this should return false in that case.\n     */\n    return (target[mplen] == '/' || target[mplen] == 0);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A\u2019s report is correct in substance. The code path discards const qualification: OS_unmount has a const char *mountpoint (good), but it calls OS_ObjectIdGetBySearch(..., (void *)mountpoint, ...) \u2014 this casts away const. The match callback is declared as bool OS_FileSys_FindVirtMountPoint(void *ref, ...), and the implementation immediately does const char *target = (const char *)ref; i.e. the parameter is a non-const pointer that is only read. Per MISRA C 2023 Rule 8.13 a pointer that is only used to read data should be declared to point to a const-qualified type whenever possible, so the ideal fix is to preserve constness across the API (change the callback typedef / OS_ObjectIdGetBySearch signature to accept const void *arg and change the callback parameter to const void *ref or const char *ref). If the wider API (OS_ObjectMatchFunc_t / OS_ObjectIdGetBySearch) must remain non-const for compatibility reasons, then this is a justified deviation and should be documented. But absent that constraint, the code as written violates Rule 8.13 (and the cast (void *)mountpoint actively discards const-qualified type)."
}