{
  "user_message": "An agent A claimed that the following OS_TimerGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimerGetInfo.\n```c\nint32 OS_TimerGetInfo(osal_id_t timer_id, OS_timer_prop_t *timer_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timer_prop, 0, sizeof(OS_timer_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TIMECB, timer_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timecb_table, token);\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timecb->timebase_token);\n\n        strncpy(timer_prop->name, record->name_entry, sizeof(timer_prop->name) - 1);\n        timer_prop->creator       = record->creator;\n        timer_prop->interval_time = (uint32)timecb->interval_time;\n        timer_prop->accuracy      = timebase->accuracy_usec;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe declaration uses OS_ArgCallback_t which (as commonly defined) is a function-pointer taking a non-const data pointer. For example, if OS_ArgCallback_t is typedef void (*OS_ArgCallback_t)(void *); then declaring OS_ArgCallback_t callback_ptr permits the callback to take a non-const void * and therefore is not const-qualified. Under MISRA C 2023 Rule 8.13 this is a violation because the pointer (the callback argument) should point to a const-qualified type when modification is not required \u2014 e.g. typedef void (*OS_ArgCallback_t)(const void *);. If, however, OS_ArgCallback_t is already defined to use const for the pointed-to data (or the callback must legitimately modify the data), then there is no violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TimerGetInfo:\ntypedef struct\n{\n    char      name[OS_MAX_API_NAME];\n    osal_id_t creator;\n    uint32    start_time;\n    uint32    interval_time;\n    uint32    accuracy;\n} OS_timer_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\ntypedef struct\n{\n    char              timer_name[OS_MAX_API_NAME];\n    uint32            flags;\n    OS_object_token_t timebase_token;\n    osal_id_t         prev_cb;\n    osal_id_t         next_cb;\n    uint32            backlog_resets;\n    int32             wait_time;\n    int32             interval_time;\n    OS_ArgCallback_t  callback_ptr;\n    void *            callback_arg;\n} OS_timecb_internal_record_t\n...\ntypedef struct\n{\n    char           timebase_name[OS_MAX_API_NAME];\n    OS_TimerSync_t external_sync;\n    uint32         accuracy_usec;\n    osal_id_t      first_cb;\n    uint32         freerun_time;\n    uint32         nominal_start_time;\n    uint32         nominal_interval_time;\n} OS_timebase_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_common_record_t *const OS_global_timecb_table\n...\nOS_timecb_internal_record_t OS_timecb_table[OS_MAX_TIMERS]\n...\nextern OS_timebase_internal_record_t OS_timebase_table[OS_MAX_TIMEBASES]\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 8.13 requires pointers to be const-qualified when they are not used to modify the pointed-to object. In OS_TimerGetInfo the parameter timer_prop is an output buffer: the function calls memset(timer_prop, 0, ...) and writes fields into it, so it must be a non-const pointer \u2014 no violation there. The agent's scenario relies on a typedef OS_ArgCallback_t taking a non-const void * and infers a violation, but that typedef is not part of the OS_TimerGetInfo API and the additional code shows the internal callback pointer/arg are stored in internal records. Whether those internal pointers should be const depends on whether the callback is allowed to modify the argument; there is no evidence here that modification is disallowed. Therefore you cannot conclude a MISRA 8.13 violation from the provided code. If you can show that a pointer is never used to modify the pointed object yet is declared non-const (e.g. callback_arg is documented/read-only everywhere), then a violation might exist, but that proof is not present here."
}