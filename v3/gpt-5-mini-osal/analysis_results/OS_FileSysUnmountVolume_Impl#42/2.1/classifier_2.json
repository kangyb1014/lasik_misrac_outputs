{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileSysUnmountVolume_Impl:\n```c\nint32 OS_FileSysUnmountVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * NOTE: Mounting/Unmounting on POSIX is not implemented.\n     * For backward compatibility this call must return success.\n     *\n     * This is a no-op.  The mount point that was created during\n     * the mount process can stay for the next mount.\n     */\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileSysUnmountVolume_Impl:\nint32 OS_unmount(const char *mountpoint)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_STRING(mountpoint, sizeof(filesys->virtual_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)mountpoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /*\n         * FIXED flag should always be unset (these don't support mount/unmount at all)\n         * READY flag should be set (mkfs/initfs must have been called on this FS)\n         * MOUNTED SYSTEM/VIRTUAL should always be unset.\n         *\n         * The FIXED flag is not enforced to support abstraction.\n         */\n        if ((filesys->flags & ~OS_FILESYS_FLAG_IS_FIXED) !=\n            (OS_FILESYS_FLAG_IS_READY | OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL))\n        {\n            /* unmount() cannot be used on this file system at this time */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_FileSysUnmountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* mark as mounted in the local table.\n             * For now this does both sides (system and virtual) */\n            filesys->flags &= ~(OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n...\nint main(int argc, char *argv[])\n{\n    /*\n     * Initially clear the global objects\n     */\n    memset(&OS_BSP_Global, 0, sizeof(OS_BSP_Global));\n    memset(&OS_BSP_GenericLinuxGlobal, 0, sizeof(OS_BSP_GenericLinuxGlobal));\n\n    /*\n     * Save the argc/argv arguments for future use.\n     * In particular the UT-specific logic uses this\n     * to control verbosity.\n     *\n     * Note that the first argument (0) is the command name.  The\n     * first \"real\" argument is at position 1.\n     *\n     * However this still needs to pass it through as the application\n     * might still want to use library \"getopt\" and this expects the\n     * first parameter to be this way.\n     */\n    OS_BSP_Global.ArgC = argc;\n    OS_BSP_Global.ArgV = argv;\n\n    /*\n     * Only attempt terminal control if the stdout is a TTY\n     * and the TERM environment variable is set\n     */\n    if (getenv(\"TERM\") != NULL)\n    {\n        OS_BSP_GenericLinuxGlobal.EnableTermControl = isatty(STDOUT_FILENO);\n    }\n\n    /*\n     * Perform any other BSP-specific initialization\n     */\n    OS_BSP_Initialize();\n\n    /*\n     * Call application specific entry point.\n     * This should set up all user tasks and resources, then return\n     */\n    OS_Application_Startup();\n\n    /*\n     * OS_Application_Run() implements the background task.\n     * The user application may provide this, or a default implementation\n     * is used which just calls OS_IdleLoop().\n     */\n    OS_Application_Run();\n\n    /* Should typically never get here */\n    return OS_BSP_GetReturnStatus();\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The fragment if (return_code != OS_SUCCESS) { return_code = OS_ERR_NAME_NOT_FOUND; } is reachable whenever return_code is not OS_SUCCESS (for example, if OS_ObjectIdGetBySearch fails or the earlier state-check sets OS_ERR_INCORRECT_OBJ_STATE). It does not create code that can never be executed. Note: the fragment does overwrite earlier non-success codes (masking specific errors as OS_ERR_NAME_NOT_FOUND), which is a logic/diagnostic issue but not an instance of unreachable code under MISRA C 2023 Rule 2.1."
}