{
  "user_message": "Target function code is:\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_ConfigureGenericStubReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_SetDeferredRetcode', 'UT_SetDefaultReturnValue']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_SetDeferredRetcode': {'callees': ['UtAssert_GetContext', 'UT_ConfigureGenericStubReturnValue'], 'callers': []}, 'UT_SetDefaultReturnValue': {'callees': ['UT_ConfigureGenericStubReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StoreRetval",
    "UtAssert_Abort",
    "UT_BSP_DoText",
    "UT_GetStubEntry",
    "UT_StubTableEntry_t",
    "UT_StubTableEntry_t::Data.Rvc.TypeName",
    "UT_StubTableEntry_t::Data.Rvc.Buf",
    "UT_ValueGenre_t",
    "UT_ValueGenre_OPAQUE",
    "UT_EntryType_t",
    "UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED",
    "UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT",
    "UT_ENTRYTYPE_UNUSED",
    "memcmp"
  ],
  "explanation": "Explain why each symbol is required to analyze MISRA rule (memcmp shall not be used to compare null-terminated strings):\n\n- UT_StoreRetval\n  - The target function calls UT_StoreRetval to copy/store non-opaque return values. That function is the most likely place where memcmp (or other byte-wise comparison) could be used on buffers that may actually represent null-terminated strings. Inspecting its implementation is necessary to see whether memcmp is used to compare or validate string return values.\n\n- UtAssert_Abort\n  - The target calls UtAssert_Abort on allocation/slot failure. UtAssert_Abort (and its downstream routines) may perform string operations or diagnostics that use memcmp on messages or stored TypeName fields. Its implementation must be checked for improper memcmp usage on null-terminated strings.\n\n- UT_BSP_DoText\n  - UtAssert_Abort calls UT_BSP_DoText (seen in the call graph). UT_BSP_DoText (or other BSP printing helpers) could contain string-handling code that erroneously uses memcmp on NUL-terminated strings. Include it to inspect any indirect memcmp usage.\n\n- UT_GetStubEntry\n  - The function uses UT_GetStubEntry extensively to locate/allocate stub entries. UT_GetStubEntry might compare keys or type/name fields (e.g., TypeName) and could use memcmp for such comparisons. Its implementation is required to ensure no memcmp-on-strings violations occur there.\n\n- UT_StubTableEntry_t\n  - The struct definition is needed to know the exact types of stored fields (Data.Rvc.TypeName and Buf). Determining whether a field is a NUL-terminated string (and therefore must not be compared with memcmp) requires the struct layout/type information.\n\n- UT_StubTableEntry_t::Data.Rvc.TypeName\n  - This specific field holds TypeName pointers stored by the target function. To decide if memcmp would be incorrectly used on TypeName, the analyzer must know this field's intended semantics (null-terminated C string vs opaque identifier) and search for places where it is compared using memcmp.\n\n- UT_StubTableEntry_t::Data.Rvc.Buf\n  - The buffer object into which return values are copied (by UT_StoreRetval). Its type and semantics (raw byte buffer vs string) determine whether byte-wise comparisons (memcmp) would be inappropriate for string data.\n\n- UT_ValueGenre_t and UT_ValueGenre_OPAQUE\n  - The ValueGenre enum controls whether ValuePtr is treated as opaque (pointer stored directly) or copied into the Buf. Knowing all genre values and semantics is necessary to determine which code paths produce NUL-terminated strings that must not be compared with memcmp.\n\n- UT_EntryType_t and UT_ENTRYTYPE_* constants (UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED / UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT / UT_ENTRYTYPE_UNUSED)\n  - These constants affect control flow and which stub entries are chosen/created. To follow all code paths that might lead to comparisons of TypeName or stored buffers (and thus potential memcmp misuse), the analyzer must understand the entry-type semantics.\n\n- memcmp\n  - The rule being checked specifically concerns memcmp. The symbol is required so the analyzer can search implementations of the above functions/structs for direct uses of memcmp (or wrappers calling it) and determine if any use compares NUL-terminated strings.\n\nNotes:\n- The above list focuses on symbols directly reachable from UT_ConfigureGenericStubReturnValue that could plausibly perform string comparisons. If additional called functions are discovered while inspecting the bodies above (e.g., UT_StoreRetval calls other helpers), those helper symbols should also be included for the same reason."
}