{
  "user_message": "An agent A claimed that the following UT_ConfigureGenericStubReturnValue code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of UT_ConfigureGenericStubReturnValue.\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment 'StubPtr = NULL;' in the Counter > 0 branch is dead code. At function entry StubPtr is already set by UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED). For the deferred case (Counter > 0) the code sets StubPtr to NULL only so that the subsequent 'if (StubPtr == NULL)' forces a re-call to UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED). Since the table is not modified in between, the second call will return an equivalent unused entry as the first call, so removing the assignment would not change program behaviour. Therefore this operation is executed but redundant and violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=94098222618618 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323c220\nConstant branch: UT_GetStubEntry(UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) returned (nil)\nStubPtr is NULL before second unused lookup; calling UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) again\nSecond UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323c220\nObservation: InitialStubPtr (0x5594f323c220) == StubPtr after re-call (0x5594f323c220) -- suggests the assignment 'StubPtr = NULL;' did not change final selection.\nConfiguring stub at 0x5594f323c220: FuncKey=94098222618618 ReqEntryType=9 Counter=0 ValueSize=8\nStored retval buffer via UT_StoreRetval.\nConfiguration complete for stub 0x5594f323c220.\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=94098222615930 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f3243060\nConstant branch: UT_GetStubEntry(UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) returned (nil)\nStubPtr is NULL before second unused lookup; calling UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) again\nSecond UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f3243060\nObservation: InitialStubPtr (0x5594f3243060) == StubPtr after re-call (0x5594f3243060) -- suggests the assignment 'StubPtr = NULL;' did not change final selection.\nConfiguring stub at 0x5594f3243060: FuncKey=94098222615930 ReqEntryType=9 Counter=0 ValueSize=8\nStored retval buffer via UT_StoreRetval.\nConfiguration complete for stub 0x5594f3243060.\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=94098222619585 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323a2a0\nConstant branch: UT_GetStubEntry(UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) returned (nil)\nStubPtr is NULL before second unused lookup; calling UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) again\nSecond UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323a2a0\nObservation: InitialStubPtr (0x5594f323a2a0) == StubPtr after re-call (0x5594f323a2a0) -- suggests the assignment 'StubPtr = NULL;' did not change final selection.\nConfiguring stub at 0x5594f323a2a0: FuncKey=94098222619585 ReqEntryType=9 Counter=0 ValueSize=8\nStored retval buffer via UT_StoreRetval.\nConfiguration complete for stub 0x5594f323a2a0.\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=94098222615833 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323c340\nConstant branch: UT_GetStubEntry(UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) returned (nil)\nStubPtr is NULL before second unused lookup; calling UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) again\nSecond UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323c340\nObservation: InitialStubPtr (0x5594f323c340) == StubPtr after re-call (0x5594f323c340) -- suggests the assignment 'StubPtr = NULL;' did not change final selection.\nConfiguring stub at 0x5594f323c340: FuncKey=94098222615833 ReqEntryType=9 Counter=0 ValueSize=8\nStored retval buffer via UT_StoreRetval.\nConfiguration complete for stub 0x5594f323c340.\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=94098222616064 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323e860\nConstant branch: UT_GetStubEntry(UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) returned (nil)\nStubPtr is NULL before second unused lookup; calling UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) again\nSecond UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x5594f323e860\nObservation: InitialStubPtr (0x5594f323e860) == StubPtr after re-call (0x5594f323e860) -- suggests the assignment 'StubPtr = NULL;' did not change final selection.\nConfiguring stub at 0x5594f323e860: FuncKey=94098222616064 ReqEntryType=9 Counter=0 ValueSize=8\nStored retval buffer via UT_StoreRetval.\nConfiguration complete for stub 0x5594f323e860.\nENTER: UT_ConfigureGenericStubReturnValue FuncKey=93953470107077 Counter=0 ValueSize=8 ValueGenre=1 TypeName=(null)\nInitial UT_GetStubEntry(UT_ENTRYTYPE_UNUSED) returned 0x55733f381\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_ConfigureGenericStubReturnValue:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nbool UT_StoreRetval(UT_RetvalBuf_t *Buf, const void *ValuePtr, size_t ValueSize, UT_ValueGenre_t ValueGenre)\n{\n    /* Copy the value based on width, so it will be properly extended, if applicable:\n     * - all numeric values need to be aligned per endianness of the host\n     * - signed ints must be sign-extended,\n     * - single-precision floating points will be extended to double-precision\n     *\n     * Pointers must all be the expected size, however.\n     */\n    switch (UT_GENRE_SIZE(ValueGenre, ValueSize))\n    {\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int8)):\n            Buf->Integer = *((int8 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int16)):\n            Buf->Integer = *((int16 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int32)):\n            Buf->Integer = *((int32 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int64)):\n            Buf->Integer = *((int64 const *)ValuePtr);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(float)):\n            Buf->FloatingPt = *((float const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(double)):\n            Buf->FloatingPt = *((double const *)ValuePtr);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_POINTER, sizeof(void *)):\n            Buf->Ptr = *((void *const *)ValuePtr);\n            break;\n\n        default:\n            return UtAssert_Failed(\"Cannot store return value - ValueSize not valid\");\n    }\n\n    return true;\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\ntypedef cpuaddr UT_EntryKey_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The assignment StubPtr = NULL; in the Counter > 0 branch is redundant (dead) given the provided code. At function entry StubPtr is already set to the result of UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED). For the deferred case (Counter > 0) the code sets StubPtr = NULL only so the later if (StubPtr == NULL) triggers a second call to UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED). With the shown UT_GetStubEntry implementation that second call will return the same unused table entry as the first call (it does not modify the table, only returns a pointer and updates UT_MaxStubSearchLen). Therefore removing the assignment would not change functional behaviour of the program (at most it would avoid a redundant call that only updates the tracking variable UT_MaxStubSearchLen to the same value). Under these circumstances the assignment constitutes an executed operation whose removal would not affect program behaviour, which meets the definition of dead code in MISRA C 2023 Rule 2.2. (If UT_GetStubEntry had other observable side-effects that could change program behaviour between the two calls, the verdict would differ, but none are present in the supplied implementation.)"
}