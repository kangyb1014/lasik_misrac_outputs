{
  "user_message": "An agent A claimed that the following UT_Stub_CallOnce code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CallOnce.\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strlen(OutputMessage) has no precondition checks for OutputMessage being non-NULL and NUL-terminated. If UT_BSP_DoText is ever called with OutputMessage == NULL or with a pointer to a character array that is not terminated by '\\0' within its allocated bounds (for example a fixed-length buffer filled without a terminator), strlen will read past the object bounds (undefined behavior). Note: the specific call chain from UT_Stub_CallOnce -> UtAssert_Abort passes a string literal (\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\"), which is NUL-terminated and safe, but the UT_BSP_DoText implementation itself does not guarantee safety for all callers.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CallOnce ENTER: Func=0x55de129677e1\nUT_Stub_CallOnce: computed FuncKey=0x55de129677e1, scanning table at 0x55de129816e0\n  iter 0: StubPtr=0x55de129816e0, EntryType=0, FuncKey=(nil)\n    -> Recorded OnceEnt (first unused) = 0x55de129816e0\n  iter 1: StubPtr=0x55de12981800, EntryType=0, FuncKey=(nil)\n  iter 2: StubPtr=0x55de12981920, EntryType=0, FuncKey=(nil)\n  iter 3: StubPtr=0x55de12981a40, EntryType=0, FuncKey=(nil)\n  iter 4: StubPtr=0x55de12981b60, EntryType=0, FuncKey=(nil)\n  iter 5: StubPtr=0x55de12981c80, EntryType=0, FuncKey=(nil)\n  iter 6: StubPtr=0x55de12981da0, EntryType=0, FuncKey=(nil)\n  iter 7: StubPtr=0x55de12981ec0, EntryType=0, FuncKey=(nil)\n  iter 8: StubPtr=0x55de12981fe0, EntryType=0, FuncKey=(nil)\n  iter 9: StubPtr=0x55de12982100, EntryType=0, FuncKey=(nil)\n  iter 10: StubPtr=0x55de12982220, EntryType=0, FuncKey=(nil)\n  iter 11: StubPtr=0x55de12982340, EntryType=0, FuncKey=(nil)\n  iter 12: StubPtr=0x55de12982460, EntryType=0, FuncKey=(nil)\n  iter 13: StubPtr=0x55de12982580, EntryType=0, FuncKey=(nil)\n  iter 14: StubPtr=0x55de129826a0, EntryType=0, FuncKey=(nil)\n  iter 15: StubPtr=0x55de129827c0, EntryType=0, FuncKey=(nil)\n  iter 16: StubPtr=0x55de129828e0, EntryType=0, FuncKey=(nil)\n  iter 17: StubPtr=0x55de12982a00, EntryType=0, FuncKey=(nil)\n  iter 18: StubPtr=0x55de12982b20, EntryType=0, FuncKey=(nil)\n  iter 19: StubPtr=0x55de12982c40, EntryType=0, FuncKey=(nil)\n  iter 20: StubPtr=0x55de12982d60, EntryType=0, FuncKey=(nil)\n  iter 21: StubPtr=0x55de12982e80, EntryType=0, FuncKey=(nil)\n  iter 22: StubPtr=0x55de12982fa0, EntryType=0, FuncKey=(nil)\n  iter 23: StubPtr=0x55de129830c0, EntryType=0, FuncKey=(nil)\n  iter 24: StubPtr=0x55de129831e0, EntryType=0, FuncKey=(nil)\n  iter 25: StubPtr=0x55de12983300, EntryType=0, FuncKey=(nil)\n  iter 26: StubPtr=0x55de12983420, EntryType=0, FuncKey=(nil)\n  iter 27: StubPtr=0x55de12983540, EntryType=0, FuncKey=(nil)\n  iter 28: StubPtr=0x55de12983660, EntryType=0, FuncKey=(nil)\n  iter 29: StubPtr=0x55de12983780, EntryType=0, FuncKey=(nil)\n  iter 30: StubPtr=0x55de129838a0, EntryType=0, FuncKey=(nil)\n  iter 31: StubPtr=0x55de129839c0, EntryType=0, FuncKey=(nil)\n  iter 32: StubPtr=0x55de12983ae0, EntryType=0, FuncKey=(nil)\n  iter 33: StubPtr=0x55de12983c00, EntryType=0, FuncKey=(nil)\n  iter 34: StubPtr=0x55de12983d20, EntryType=0, FuncKey=(nil)\n  iter 35: StubPtr=0x55de12983e40, EntryType=0, FuncKey=(nil)\n  iter 36: StubPtr=0x55de12983f60, EntryType=0, FuncKey=(nil)\n  iter 37: StubPtr=0x55de12984080, EntryType=0, FuncKey=(nil)\n  iter 38: StubPtr=0x55de129841a0, EntryType=0, FuncKey=(nil)\n  iter 39: StubPtr=0x55de129842c0, EntryType=0, FuncKey=(nil)\n  iter 40: StubPtr=0x55de129843e0, EntryType=0, FuncKey=(nil)\n  iter 41: StubPtr=0x55de12984500, EntryType=0, FuncKey=(nil)\n  iter 42: StubPtr=0x55de12984620, EntryType=0, FuncKey=(nil)\n  iter 43: StubPtr=0x55de12984740, EntryType=0, FuncKey=(nil)\n  iter 44: StubPtr=0x55de12984860, EntryType=0, FuncKey=(nil)\n  iter 45: StubPtr=0x55de12984980, EntryType=8, FuncKey=0x55de12968faf\n  iter 46: StubPtr=0x55de12984aa0, EntryType=0, FuncKey=(nil)\n  iter 47: StubPtr=0x55de12984bc0, EntryType=0, FuncKey=(nil)\n  iter 48: StubPtr=0x55de12984ce0, EntryType=0, FuncKey=(nil)\n  iter 49: StubPtr=0x55de12984e00, EntryType=0, FuncKey=(nil)\n  iter 50: StubPtr=0x55de12984f20, EntryType=0, FuncKey=(nil)\n  iter 51: StubPtr=0x55de12985040, EntryType=0, FuncKey=(nil)\n  iter 52: StubPtr=0x55de12985160, EntryType=0, FuncKey=(nil)\n  iter 53: StubPtr=0x55de12985280, EntryType=0, FuncKey=(nil)\n  iter 54: StubPtr=0x55de129853a0, EntryType=0, FuncKey=(nil)\n  iter 55: StubPtr=0x55de129854c0, EntryType=0, FuncKey=(nil)\n  iter 56: StubPtr=0x55de129855e0, EntryType=0, FuncKey=(nil)\n  iter 57: StubPtr=0x55de12985700, EntryType=0, FuncKey=(nil)\n  iter 58: StubPtr=0x55de12985820, EntryType=1, FuncKey=0x55de129681be\n  iter 59: StubPtr=0x55de12985940, EntryType=0, FuncKey=(nil)\n  iter 60: StubPtr=0x55de12985a60, EntryType=0, FuncKey=(nil)\n  iter 61: StubPtr=0x55de12985b80, EntryType=0, FuncKey=(nil)\n  iter 62: StubPtr=0x55de12985ca0, EntryType=0, FuncKey=(nil\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CallOnce:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nstatic UT_StubTableEntry_t UT_StubTable[UT_MAX_FUNC_STUBS] = {{0}}\n...\n#define UT_MAX_FUNC_STUBS 200\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim that UT_Stub_CallOnce violates MISRA C:2023 Rule 21.17 is not correct. Rule 21.17 concerns uses of string.h functions that can read beyond the bounds of the object(s) referenced by their pointer parameters. The only string.h usages shown are inside UT_BSP_DoText: strlen(Buffer) (Buffer is filled by snprintf and therefore NUL-terminated) and strlen(OutputMessage). The specific call chain from UT_Stub_CallOnce -> UtAssert_Abort passes a string literal (\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\"), which is non-NULL and NUL-terminated, so that invocation cannot read out of bounds. Thus UT_Stub_CallOnce itself does not cause a 21.17 violation in the demonstrated path.\n\nThat said, UT_BSP_DoText does call strlen(OutputMessage) without checking OutputMessage for NULL or enforcing a maximum length; if there exist callers that pass NULL or a non-NUL-terminated buffer, then UT_BSP_DoText (not UT_Stub_CallOnce) would be the site of a possible 21.17 violation. In other words, the potential defect is in UT_BSP_DoText's use of strlen without validating its input or documenting a precondition that OutputMessage must be a valid NUL-terminated string. The agent A did not demonstrate any actual caller that violates that precondition, so blaming UT_Stub_CallOnce is incorrect."
}