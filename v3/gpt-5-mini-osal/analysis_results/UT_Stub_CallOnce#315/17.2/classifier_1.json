{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CallOnce:\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CallOnce:\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n...\nosal_id_t UT_AllocStubObjId(osal_objtype_t ObjType)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    uint32             indx;\n    osal_id_t          Result;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    if (ObjType == OS_OBJECT_TYPE_UNDEFINED || ObjType >= OS_OBJECT_TYPE_USER)\n    {\n        /* Code is broken, abort the test\n         * (This signifies an error in the stub code itself hence the abort)\n         */\n        UtAssert_Abort(\"ObjType out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    if (StatePtr->LastIssueNumber < ((8 * sizeof(StatePtr->ValidBits)) - 1))\n    {\n        ++StatePtr->LastIssueNumber;\n    }\n\n    indx = StatePtr->LastIssueNumber;\n\n    ObjMask = 1 << (indx & 0x07);\n    /*\n     * Check for overlap/re-issue - this COULD happen when using\n     * the original (non-opaque) object IDs if a UT creates too many\n     * objects of a certain type.  There is really no way around this\n     * and it means the test needs to be revised to not create so many\n     * objects OR it needs to support opaque object IDs\n     */\n    if ((StatePtr->ValidBits[indx >> 3] & ObjMask) != 0)\n    {\n        UtAssert_Failed(\"OSAPI UT stub object overlap\");\n    }\n    StatePtr->ValidBits[indx >> 3] |= ObjMask;\n\n    /*\n     * Finalize Object ID - put into proper range for type\n     */\n    UT_ObjIdCompose(indx, ObjType, &Result);\n\n    return Result;\n}\n...\nvoid UT_DeleteStubObjId(osal_objtype_t ObjType, osal_id_t ObjId)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    osal_objtype_t     checktype;\n    uint32             checkidx;\n    bool               ObjWasValid;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    UT_ObjIdDecompose(ObjId, &checkidx, &checktype);\n\n    /*\n     * Verify the object type\n     */\n    if (ObjType != checktype)\n    {\n        /* Calling code is broken, abort the test */\n        UtAssert_Failed(\"Object type is not correct\");\n    }\n\n    if (checkidx >= (8 * sizeof(StatePtr->ValidBits)))\n    {\n        /* Calling code is broken */\n        UtAssert_Failed(\"ObjId out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    /* Clear out any bit it could have been */\n    ObjWasValid = false;\n    ObjMask     = 1 << (checkidx & 0x07);\n    if ((StatePtr->ValidBits[checkidx >> 3] & ObjMask) != 0)\n    {\n        ObjWasValid = true;\n        StatePtr->ValidBits[checkidx >> 3] &= ~ObjMask;\n    }\n\n    /* Unfortunately, some code has a habit of just blindly calling \"Delete\"\n     * regardless of whether those entities were created or not.  This is\n     * an issue on the non-opaque OSAL implementations and will produce\n     * thousands of failed test cases, so this can only be verified\n     * on the opaque objid versions.\n     */\n    if (!ObjWasValid)\n    {\n        /*\n         * These stubs can be more strict about the usage patterns.\n         *\n         * In general any app calling delete on an ID they did not create likely\n         * signifies an error in that application.\n         */\n        UtAssert_Failed(\"Deleted object that was never created\");\n    }\n}\n...\nUtAssert_CaseType_t UtAssert_GetContext(void)\n{\n    return DefaultContext;\n}\n...\nvoid UT_ObjIdCompose(uint32 indx, osal_objtype_t objtype, osal_id_t *id)\n{\n    /* note - the OS_ObjectIdFromInteger() is an inline function,\n     * and therefore this uses the real thing and not a stub  */\n    *id = OS_ObjectIdFromInteger((unsigned long)indx | ((0x4000UL | objtype) << 16));\n}\n...\nvoid UT_ObjIdDecompose(osal_id_t id, uint32 *indx, osal_objtype_t *objtype)\n{\n    unsigned long idv = OS_ObjectIdToInteger(id);\n    *indx             = idv & 0xFFFFUL;\n    *objtype          = (idv >> 16) ^ 0x4000UL;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nUT_Stub_CallOnce(UT_ClearAllStubObjects);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call UT_Stub_CallOnce(UT_ClearAllStubObjects) by itself does not constitute recursion. UT_Stub_CallOnce invokes the provided function once, and there is no evidence in the supplied code that UT_ClearAllStubObjects (or any function it calls) calls UT_Stub_CallOnce back. Therefore the fragment does not violate Rule 17.2. (A violating scenario would be if UT_ClearAllStubObjects, or any function it transitively calls, invoked UT_Stub_CallOnce again \u2014 that would create indirect recursion and violate the rule.)"
}