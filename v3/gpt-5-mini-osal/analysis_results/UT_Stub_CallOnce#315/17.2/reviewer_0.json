{
  "user_message": "An agent A claimed that the following UT_Stub_CallOnce code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CallOnce.\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the Func pointer refers to UT_Stub_CallOnce itself (e.g. UT_Stub_CallOnce(UT_Stub_CallOnce)) or to any function that calls UT_Stub_CallOnce, then UT_Stub_CallOnce will invoke Func() and thereby call itself directly or indirectly, producing recursion.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CallOnce ENTER: Func=0x55f51d7da7c1\nUT_Stub_CallOnce: scan idx=0 StubPtr=0x55f51d7f48a0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: Remembered first UNUSED slot OnceEnt=0x55f51d7f48a0\nUT_Stub_CallOnce: scan idx=1 StubPtr=0x55f51d7f49c0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=2 StubPtr=0x55f51d7f4ae0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=3 StubPtr=0x55f51d7f4c00 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=4 StubPtr=0x55f51d7f4d20 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=5 StubPtr=0x55f51d7f4e40 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=6 StubPtr=0x55f51d7f4f60 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=7 StubPtr=0x55f51d7f5080 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=8 StubPtr=0x55f51d7f51a0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=9 StubPtr=0x55f51d7f52c0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=10 StubPtr=0x55f51d7f53e0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=11 StubPtr=0x55f51d7f5500 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=12 StubPtr=0x55f51d7f5620 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=13 StubPtr=0x55f51d7f5740 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=14 StubPtr=0x55f51d7f5860 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=15 StubPtr=0x55f51d7f5980 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=16 StubPtr=0x55f51d7f5aa0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=17 StubPtr=0x55f51d7f5bc0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=18 StubPtr=0x55f51d7f5ce0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=19 StubPtr=0x55f51d7f5e00 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=20 StubPtr=0x55f51d7f5f20 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=21 StubPtr=0x55f51d7f6040 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=22 StubPtr=0x55f51d7f6160 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=23 StubPtr=0x55f51d7f6280 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=24 StubPtr=0x55f51d7f63a0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=25 StubPtr=0x55f51d7f64c0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=26 StubPtr=0x55f51d7f65e0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=27 StubPtr=0x55f51d7f6700 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=28 StubPtr=0x55f51d7f6820 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=29 StubPtr=0x55f51d7f6940 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=30 StubPtr=0x55f51d7f6a60 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=31 StubPtr=0x55f51d7f6b80 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=32 StubPtr=0x55f51d7f6ca0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=33 StubPtr=0x55f51d7f6dc0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=34 StubPtr=0x55f51d7f6ee0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=35 StubPtr=0x55f51d7f7000 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=36 StubPtr=0x55f51d7f7120 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=37 StubPtr=0x55f51d7f7240 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=38 StubPtr=0x55f51d7f7360 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=39 StubPtr=0x55f51d7f7480 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=40 StubPtr=0x55f51d7f75a0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=41 StubPtr=0x55f51d7f76c0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=42 StubPtr=0x55f51d7f77e0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=43 StubPtr=0x55f51d7f7900 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=44 StubPtr=0x55f51d7f7a20 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=45 StubPtr=0x55f51d7f7b40 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=46 StubPtr=0x55f51d7f7c60 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=47 StubPtr=0x55f51d7f7d80 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=48 StubPtr=0x55f51d7f7ea0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=49 StubPtr=0x55f51d7f7fc0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=50 StubPtr=0x55f51d7f80e0 EntryType=0 FuncKey=0x0\nUT_Stub_CallOnce: scan idx=51 StubPtr=0x55f51d7f8200 EntryType=0 \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CallOnce:\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n...\nosal_id_t UT_AllocStubObjId(osal_objtype_t ObjType)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    uint32             indx;\n    osal_id_t          Result;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    if (ObjType == OS_OBJECT_TYPE_UNDEFINED || ObjType >= OS_OBJECT_TYPE_USER)\n    {\n        /* Code is broken, abort the test\n         * (This signifies an error in the stub code itself hence the abort)\n         */\n        UtAssert_Abort(\"ObjType out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    if (StatePtr->LastIssueNumber < ((8 * sizeof(StatePtr->ValidBits)) - 1))\n    {\n        ++StatePtr->LastIssueNumber;\n    }\n\n    indx = StatePtr->LastIssueNumber;\n\n    ObjMask = 1 << (indx & 0x07);\n    /*\n     * Check for overlap/re-issue - this COULD happen when using\n     * the original (non-opaque) object IDs if a UT creates too many\n     * objects of a certain type.  There is really no way around this\n     * and it means the test needs to be revised to not create so many\n     * objects OR it needs to support opaque object IDs\n     */\n    if ((StatePtr->ValidBits[indx >> 3] & ObjMask) != 0)\n    {\n        UtAssert_Failed(\"OSAPI UT stub object overlap\");\n    }\n    StatePtr->ValidBits[indx >> 3] |= ObjMask;\n\n    /*\n     * Finalize Object ID - put into proper range for type\n     */\n    UT_ObjIdCompose(indx, ObjType, &Result);\n\n    return Result;\n}\n...\nvoid UT_DeleteStubObjId(osal_objtype_t ObjType, osal_id_t ObjId)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    osal_objtype_t     checktype;\n    uint32             checkidx;\n    bool               ObjWasValid;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    UT_ObjIdDecompose(ObjId, &checkidx, &checktype);\n\n    /*\n     * Verify the object type\n     */\n    if (ObjType != checktype)\n    {\n        /* Calling code is broken, abort the test */\n        UtAssert_Failed(\"Object type is not correct\");\n    }\n\n    if (checkidx >= (8 * sizeof(StatePtr->ValidBits)))\n    {\n        /* Calling code is broken */\n        UtAssert_Failed(\"ObjId out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    /* Clear out any bit it could have been */\n    ObjWasValid = false;\n    ObjMask     = 1 << (checkidx & 0x07);\n    if ((StatePtr->ValidBits[checkidx >> 3] & ObjMask) != 0)\n    {\n        ObjWasValid = true;\n        StatePtr->ValidBits[checkidx >> 3] &= ~ObjMask;\n    }\n\n    /* Unfortunately, some code has a habit of just blindly calling \"Delete\"\n     * regardless of whether those entities were created or not.  This is\n     * an issue on the non-opaque OSAL implementations and will produce\n     * thousands of failed test cases, so this can only be verified\n     * on the opaque objid versions.\n     */\n    if (!ObjWasValid)\n    {\n        /*\n         * These stubs can be more strict about the usage patterns.\n         *\n         * In general any app calling delete on an ID they did not create likely\n         * signifies an error in that application.\n         */\n        UtAssert_Failed(\"Deleted object that was never created\");\n    }\n}\n...\nUtAssert_CaseType_t UtAssert_GetContext(void)\n{\n    return DefaultContext;\n}\n...\nvoid UT_ObjIdCompose(uint32 indx, osal_objtype_t objtype, osal_id_t *id)\n{\n    /* note - the OS_ObjectIdFromInteger() is an inline function,\n     * and therefore this uses the real thing and not a stub  */\n    *id = OS_ObjectIdFromInteger((unsigned long)indx | ((0x4000UL | objtype) << 16));\n}\n...\nvoid UT_ObjIdDecompose(osal_id_t id, uint32 *indx, osal_objtype_t *objtype)\n{\n    unsigned long idv = OS_ObjectIdToInteger(id);\n    *indx             = idv & 0xFFFFUL;\n    *objtype          = (idv >> 16) ^ 0x4000UL;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function invokes an external function pointer via Func(); there is no check preventing Func from being equal to UT_Stub_CallOnce (or to some other function that in turn calls UT_Stub_CallOnce). If a caller passes UT_Stub_CallOnce (or a function that calls UT_Stub_CallOnce) as the Func argument, that invocation becomes a direct (or indirect) call back into UT_Stub_CallOnce, i.e. recursion, which contravenes MISRA C 2023 Rule 17.2. The source shows no guard against this (only a NULL check), so the code permits self-calls at runtime and therefore violates the rule. A remediation would be to explicitly prevent calling when Func == UT_Stub_CallOnce (or otherwise guard against re-entrancy)."
}