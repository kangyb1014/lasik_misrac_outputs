{
  "user_message": "An agent A claimed that the following OS_QueueGet code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGet.\n```c\nint32 OS_QueueGet(osal_id_t queue_id, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_POINTER(size_copied);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        if (size < queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is potentially too small\n            */\n            *size_copied = 0;\n            return_code  = OS_QUEUE_INVALID_SIZE;\n        }\n        else\n        {\n            return_code = OS_QueueGet_Impl(&token, data, size, size_copied, timeout);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro expands to &OS_queue_table[OS_ObjectIndexFromToken(&token)] and yields a pointer to a non-const table element. In the shown use (OS_QueueGet) the returned pointer is assigned to 'OS_queue_internal_record_t *queue' and only read (queue->max_size). Therefore the pointer could and should be a pointer to const (const OS_queue_internal_record_t *), so the current code violates MISRA C 2023 Rule 8.13 in that usage (the macro enables a non-const pointer where a const-qualified pointer is possible).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_QueueGet - after_checks\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-1\n------------------------\nOS_QueueGet - after_ObjectIdGetById\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-35\n------------------------\nOS_QueueGet - objectid_not_found\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-35\n------------------------\nOS_QueueGet - after_checks\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-1\n------------------------\nOS_QueueGet - after_ObjectIdGetById\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-35\n------------------------\nOS_QueueGet - objectid_not_found\n  token ptr=0x7ffd959be890\n  queue ptr=(nil)\n  requested size=4\n  size_copied ptr=0x7ffd959be8d8\n  return_code=-35\n------------------------\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_QueueGet:\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n...\ntypedef struct\n{\n    char              queue_name[OS_MAX_API_NAME];\n    size_t            max_size;\n    osal_blockcount_t max_depth;\n} OS_queue_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_queue_internal_record_t OS_queue_table[LOCAL_NUM_OBJECTS]\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CHECK_SIZE(val) ARGCHECK((val)>0&&(val)<(UINT32_MAX/2),OS_ERR_INVALID_SIZE)\n...\n#define OS_QUEUE_INVALID_SIZE (-11)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_QueueGet the local variable 'queue' is declared as OS_queue_internal_record_t * but is only used for reading (queue->max_size). MISRA C 2023 Rule 8.13 requires a pointer to be const-qualified when possible; here it is possible to make it const (declare const OS_queue_internal_record_t *queue). The macro OS_OBJECT_TABLE_GET expands to &OS_queue_table[...] (a non-const object), but converting T * to const T * is allowed implicitly, so no cast or other hack is required. Therefore the code as shown does violate Rule 8.13 and should be changed to use a pointer-to-const for this use site."
}