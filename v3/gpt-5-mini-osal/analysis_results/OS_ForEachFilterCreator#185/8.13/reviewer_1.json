{
  "user_message": "An agent A claimed that the following OS_ForEachFilterCreator code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachFilterCreator.\n```c\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'ref' is declared as void * but is only used for read access (assigned to OS_creator_filter_t *filter and only read ->creator_id). According to MISRA C 2023 Rule 8.13, the pointer should be const-qualified when possible. Here the function does not modify the object pointed to by ref, so the signature should use a const-qualified pointer (e.g. const void *ref or const OS_creator_filter_t *ref and const OS_creator_filter_t *filter = ref). The other parameters (token, obj) are already const-qualified and are fine.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachFilterCreator:\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\nstatic inline bool OS_ObjectIdEqual(osal_id_t object_id1, osal_id_t object_id2)\n{\n    return (OS_ObjectIdToInteger(object_id1) == OS_ObjectIdToInteger(object_id2));\n}\n...\nstatic inline bool OS_ObjectIdIsValid(osal_id_t object_id)\n{\n    osal_objtype_t objtype = OS_ObjectIdToType_Impl(object_id);\n    return (objtype > OS_OBJECT_TYPE_UNDEFINED && objtype < OS_OBJECT_TYPE_USER);\n}\n...\n#define OS_OBJECT_CREATOR_ANY OS_OBJECT_ID_UNDEFINED\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct that, in this function body, the object pointed to by 'ref' is only read (filter->creator_id) and therefore the pointer could be const-qualified (e.g. const void *ref or const OS_creator_filter_t *filter). Per MISRA C:2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the current signature is a violation in the general case. Caveat: this can be an acceptable deviation if the function must match an externally imposed callback prototype that requires a void * parameter; in that situation the signature cannot be changed even though the implementation does not modify the object. The report as stated (that the code violates Rule 8.13) is correct absent such an external constraint."
}