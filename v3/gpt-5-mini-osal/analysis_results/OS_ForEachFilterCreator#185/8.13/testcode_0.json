{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe struct contains a non-const pointer member (void *user_arg) and the code that uses the struct (OS_ForEachFilterCreator) takes a non-const void *ref and casts it to OS_creator_filter_t * even though it only reads fields. If the user_arg and the passed ref are intended to be read-only by the OS, they should be declared const (e.g. const void *user_arg, const void *ref and const OS_creator_filter_t *filter). As written, the non-const pointer types violate MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ForEachFilterCreator code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1853.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ForEachFilterCreator as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ForEachFilterCreator:\n```c\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n```\n</target_code>\nPlease provide the modified OS_ForEachFilterCreator code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n/* Minimal stand-in types and helpers so this test code is compilable and\n * executable in isolation. These mimic the real OS types well enough to\n * exercise the OS_ForEachFilterCreator logic and to allow logging of the\n * violation scenario. Do not change the signature of OS_ForEachFilterCreator. */\n\ntypedef uint32_t OS_object_id_t;\n\ntypedef struct\n{\n    OS_object_id_t active_id;\n    OS_object_id_t creator;\n} OS_common_record_t;\n\ntypedef struct\n{\n    OS_object_id_t creator_id;\n    void *user_arg; /* non-const intentionally to reproduce the reported scenario */\n} OS_creator_filter_t;\n\ntypedef struct OS_object_token_t { int dummy; } OS_object_token_t;\n\n/* Sentinel value used by the original code */\nstatic const OS_object_id_t OS_OBJECT_CREATOR_ANY = (OS_object_id_t)0xFFFFFFFFu;\n\n/* Minimal implementations of the object-id helpers used in the original code. */\nstatic bool OS_ObjectIdIsValid(OS_object_id_t id)\n{\n    /* Consider 0 invalid, everything else valid for testing purposes */\n    return (id != (OS_object_id_t)0u);\n}\n\nstatic bool OS_ObjectIdEqual(OS_object_id_t a, OS_object_id_t b)\n{\n    return (a == b);\n}\n\n/* Probe: log control-flow and state information to /tmp/logs/1853.txt. */\nstatic void log_for_each_filter_creator(const char *label,\n                                       void *ref,\n                                       const OS_object_token_t *token,\n                                       const OS_common_record_t *obj,\n                                       const OS_creator_filter_t *filter,\n                                       bool id_valid,\n                                       bool match_any,\n                                       bool match_creator,\n                                       bool result)\n{\n    FILE *f = fopen(\"/tmp/logs/1853.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging fails, do not change program logic \u2014 just return. */\n        return;\n    }\n\n    fprintf(f, \"[%s] OS_ForEachFilterCreator called\\n\", label);\n    fprintf(f, \"[%s] ref (raw) = %p\\n\", label, ref);\n    fprintf(f, \"[%s] token = %p\\n\", label, (const void *)token);\n    if (obj != NULL)\n    {\n        fprintf(f, \"[%s] obj->active_id = %u\\n\", label, (unsigned)obj->active_id);\n        fprintf(f, \"[%s] obj->creator = %u\\n\", label, (unsigned)obj->creator);\n    }\n    else\n    {\n        fprintf(f, \"[%s] obj = NULL\\n\", label);\n    }\n\n    if (filter != NULL)\n    {\n        fprintf(f, \"[%s] filter->creator_id = %u\\n\", label, (unsigned)filter->creator_id);\n        fprintf(f, \"[%s] filter->user_arg (pointer) = %p\\n\", label, filter->user_arg);\n    }\n    else\n    {\n        fprintf(f, \"[%s] filter = NULL\\n\", label);\n    }\n\n    fprintf(f, \"[%s] OS_ObjectIdIsValid(active_id) => %s\\n\", label, id_valid ? \"true\" : \"false\");\n    fprintf(f, \"[%s] filter->creator_id == OS_OBJECT_CREATOR_ANY => %s\\n\", label, match_any ? \"true\" : \"false\");\n    fprintf(f, \"[%s] obj->creator == filter->creator_id => %s\\n\", label, match_creator ? \"true\" : \"false\");\n    fprintf(f, \"[%s] final result => %s\\n\", label, result ? \"true\" : \"false\");\n    fprintf(f, \"[%s] NOTE: 'ref' was passed as a non-const void* and cast to OS_creator_filter_t* in the caller.\\n\", label);\n    fprintf(f, \"[%s] ---\\n\", label);\n\n    fclose(f);\n}\n\n/* The original function (kept as close as possible to the original logic).\n * Logging probes are added but they do not change return semantics. */\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Compute intermediate values so we can log them before returning. */\n    bool id_valid = false;\n    bool match_any = false;\n    bool match_creator = false;\n\n    if (obj != NULL)\n    {\n        id_valid = OS_ObjectIdIsValid(obj->active_id);\n    }\n\n    if (filter != NULL)\n    {\n        match_any = OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY);\n        if (obj != NULL)\n        {\n            match_creator = OS_ObjectIdEqual(obj->creator, filter->creator_id);\n        }\n    }\n\n    bool result = (id_valid && (match_any || match_creator));\n\n    /* Probe logging: record control path and key state to a logfile for\n     * later inspection. This helps reproduce the scenario where a non-const\n     * pointer (ref/user_arg) is used even though the function only reads data. */\n    log_for_each_filter_creator(\"probe\", ref, token, obj, filter, id_valid, match_any, match_creator, result);\n\n    return result;\n}\n"
}