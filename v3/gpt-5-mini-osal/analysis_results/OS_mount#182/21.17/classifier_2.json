{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_mount:\n```c\nint32 OS_mount(const char *devname, const char *mountpoint)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_STRING(devname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(mountpoint, sizeof(filesys->virtual_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /*\n         * READY flag should be set (mkfs/initfs must have been called on this FS)\n         * MOUNTED SYSTEM/VIRTUAL should always be unset.\n         *\n         * FIXED flag _should_ always be unset (these don't support mount/unmount)\n         * but to support abstraction this is not enforced.\n         */\n        if ((filesys->flags & ~OS_FILESYS_FLAG_IS_FIXED) != OS_FILESYS_FLAG_IS_READY)\n        {\n            /* mount() cannot be used on this file system at this time */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if (filesys->system_mountpt[0] == 0)\n        {\n            /*\n             * The system mount point should be a non-empty string.\n             */\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* mark as mounted in the local table.\n             * For now this does both sides (system and virtual) */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n            strncpy(filesys->virtual_mountpt, mountpoint, sizeof(filesys->virtual_mountpt) - 1);\n            filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nfilesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = 0;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: strncpy(filesys->virtual_mountpt, mountpoint, sizeof(filesys->virtual_mountpt) - 1) copies at most N-1 bytes into an array of size N, and the subsequent assignment filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = 0 writes the terminating NUL into the last valid index (N-1). This is within bounds and prevents overruns. (Only caveat: this assumes virtual_mountpt is a fixed-size char array; if it were a flexible array member or otherwise had size 0/unknown, sizeof would not be valid and could lead to problems.)"
}