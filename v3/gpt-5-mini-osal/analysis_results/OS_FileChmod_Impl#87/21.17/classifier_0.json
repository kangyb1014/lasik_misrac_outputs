{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileChmod_Impl:\n```c\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n        }\n    }\n\n    close(fd);\n\n    return status;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileChmod_Impl:\nint32 OS_chmod(const char *path, uint32 access_mode)\n{\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n    int32 return_code;\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileChmod_Impl(local_path, access_mode);\n    }\n\n    return return_code;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown fragment. The code calls strerror(errno) (which returns a pointer to an internal, null-terminated error message) and passes local_path to a logging macro. The snippet itself does not call any of the <string.h> functions listed in MISRA C 2023 Rule 21.17 (memcpy, strcpy, strlen, etc.) with pointer parameters that might access beyond the bounds of the referenced objects."
}