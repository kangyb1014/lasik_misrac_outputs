{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_SocketAddrInit_Impl:\n```c\nint32 OS_SocketAddrInit_Impl(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    sa_family_t             sa_family;\n    socklen_t               addrlen;\n    OS_SockAddr_Accessor_t *Accessor;\n\n    memset(Addr, 0, sizeof(OS_SockAddr_t));\n    Accessor = (OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Domain)\n    {\n        case OS_SocketDomain_INET:\n            sa_family = AF_INET;\n            addrlen   = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            sa_family = AF_INET6;\n            addrlen   = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            sa_family = 0;\n            addrlen   = 0;\n            break;\n    }\n\n    if (addrlen == 0)\n    {\n        return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    Addr->ActualLength     = OSAL_SIZE_C(addrlen);\n    Accessor->sa.sa_family = sa_family;\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_SocketAddrInit_Impl:\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_SocketAddrInit(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    /* Check parameters */\n    OS_CHECK_POINTER(Addr);\n\n    return OS_SocketAddrInit_Impl(Addr, Domain);\n}\n...\nvoid OS_printf(const char *String, ...)\n{\n    va_list va;\n    char    msg_buffer[OS_BUFFER_SIZE];\n    int     actualsz;\n\n    BUGCHECK_VOID(String != NULL)\n\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER)\n    {\n        /*\n         * Catch some historical mis-use of the OS_printf() call.\n         *\n         * Typically OS_printf() should NOT be called before OS_API_Init().\n         *\n         * This was never guaranteed to work, particularly on a VxWorks\n         * deployment where the utility task was enabled.\n         *\n         * However, some PSPs do this, particularly those that used POSIX\n         * where it happened to work (because OS_printf just called printf).\n         *\n         * As a workaround, use the OS_DEBUG facility to dump the message,\n         * along with a clue that this API is being used inappropriately.\n         *\n         * If debugging is not enabled, then this message will be silently\n         * discarded.\n         */\n        OS_DEBUG(\"BUG: OS_printf() called when OSAL not initialized: %s\", String);\n    }\n    else if (OS_SharedGlobalVars.PrintfEnabled)\n    {\n        /* Format and determine the size of string to write */\n        va_start(va, String);\n        actualsz = vsnprintf(msg_buffer, sizeof(msg_buffer), String, va);\n        va_end(va);\n\n        if (actualsz < 0)\n        {\n            /* unlikely: vsnprintf failed */\n            actualsz = 0;\n        }\n        else if (actualsz >= OS_BUFFER_SIZE)\n        {\n            /* truncate */\n            actualsz = OS_BUFFER_SIZE - 1;\n        }\n\n        msg_buffer[actualsz] = 0;\n\n        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer);\n    }\n}\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n...\nint32 OS_SocketAccept_Impl(const OS_object_token_t *sock_token, const OS_object_token_t *conn_token,\n                           OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    uint32                          operation;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *sock_impl;\n    OS_impl_file_internal_record_t *conn_impl;\n\n    sock_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *sock_token);\n    conn_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *conn_token);\n\n    operation = OS_STREAM_STATE_READABLE;\n    if (sock_impl->selectable)\n    {\n        return_code = OS_SelectSingle_Impl(sock_token, &operation, timeout);\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            addrlen       = Addr->ActualLength;\n            conn_impl->fd = accept(sock_impl->fd, (struct sockaddr *)&Addr->AddrData, &addrlen);\n            if (conn_impl->fd < 0)\n            {\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                Addr->ActualLength = addrlen;\n\n                OS_IMPL_SET_SOCKET_FLAGS(conn_token);\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n...\nvoid UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}\n...\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "void UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}\n",
    "int32 OS_SocketAddrInit(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    /* Check parameters */\n    OS_CHECK_POINTER(Addr);\n\n    return OS_SocketAddrInit_Impl(Addr, Domain);\n}\n",
    "void OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n",
    "int32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n",
    "int32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n",
    "int32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n",
    "int32 OS_SocketAccept_Impl(const OS_object_token_t *sock_token, const OS_object_token_t *conn_token,\n                           OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    uint32                          operation;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *sock_impl;\n    OS_impl_file_internal_record_t *conn_impl;\n\n    sock_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *sock_token);\n    conn_impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *conn_token);\n\n    operation = OS_STREAM_STATE_READABLE;\n    if (sock_impl->selectable)\n    {\n        return_code = OS_SelectSingle_Impl(sock_token, &operation, timeout);\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            addrlen       = Addr->ActualLength;\n            conn_impl->fd = accept(sock_impl->fd, (struct sockaddr *)&Addr->AddrData, &addrlen);\n            if (conn_impl->fd < 0)\n            {\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                Addr->ActualLength = addrlen;\n\n                OS_IMPL_SET_SOCKET_FLAGS(conn_token);\n            }\n        }\n    }\n\n    return return_code;\n}\n",
    "void OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n",
    "int32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n",
    "void OS_printf(const char *String, ...)\n{\n    va_list va;\n    char    msg_buffer[OS_BUFFER_SIZE];\n    int     actualsz;\n\n    BUGCHECK_VOID(String != NULL)\n\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER)\n    {\n        /*\n         * Catch some historical mis-use of the OS_printf() call.\n         *\n         * Typically OS_printf() should NOT be called before OS_API_Init().\n         *\n         * This was never guaranteed to work, particularly on a VxWorks\n         * deployment where the utility task was enabled.\n         *\n         * However, some PSPs do this, particularly those that used POSIX\n         * where it happened to work (because OS_printf just called printf).\n         *\n         * As a workaround, use the OS_DEBUG facility to dump the message,\n         * along with a clue that this API is being used inappropriately.\n         *\n         * If debugging is not enabled, then this message will be silently\n         * discarded.\n         */\n        OS_DEBUG(\"BUG: OS_printf() called when OSAL not initialized: %s\", String);\n    }\n    else if (OS_SharedGlobalVars.PrintfEnabled)\n    {\n        /* Format and determine the size of string to write */\n        va_start(va, String);\n        actualsz = vsnprintf(msg_buffer, sizeof(msg_buffer), String, va);\n        va_end(va);\n\n        if (actualsz < 0)\n        {\n            /* unlikely: vsnprintf failed */\n            actualsz = 0;\n        }\n        else if (actualsz >= OS_BUFFER_SIZE)\n        {\n            /* truncate */\n            actualsz = OS_BUFFER_SIZE - 1;\n        }\n\n        msg_buffer[actualsz] = 0;\n\n        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer);\n    }\n}\n",
    "int32 OS_SocketAddrInit_Impl(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    sa_family_t             sa_family;\n    socklen_t               addrlen;\n    OS_SockAddr_Accessor_t *Accessor;\n\n    memset(Addr, 0, sizeof(OS_SockAddr_t));\n    Accessor = (OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Domain)\n    {\n        case OS_SocketDomain_INET:\n            sa_family = AF_INET;\n            addrlen   = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            sa_family = AF_INET6;\n            addrlen   = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            sa_family = 0;\n            addrlen   = 0;\n            break;\n    }\n\n    if (addrlen == 0)\n    {\n        return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    Addr->ActualLength     = OSAL_SIZE_C(addrlen);\n    Accessor->sa.sa_family = sa_family;\n\n    return OS_SUCCESS;\n}\n"
  ],
  "explanation": "Fragments not listed do not need investigation for Rule 17.2 because they either (a) do not call any other functions in the provided code that could lead to indirect cycles, or (b) only call standard library functions (memset, snprintf, vsnprintf, accept, malloc, strcmp, etc.) or simple accessors/inline helpers that do not perform callbacks or call back into the OS API, and thus present no apparent risk of direct or indirect self-calls. Examples of safe/non-suspicious fragments: UT_Stub_RegisterReturnType, UT_Stub_RegisterContextWithMetaData, UT_Stub_GetReturnValuePtr (these manipulate test stub tables and call assert/memory APIs but do not invoke callbacks into the same API set), OS_ObjectIndexFromToken (inline accessor), and OS_printf apart from the OS_DEBUG call site (only OS_printf is added to the suspicious list where it may route to OS_DEBUG). The selected fragments were chosen because they either (1) perform notify/event or handler registration/dispatch (OS_NotifyEvent, UT_DefaultStubImpl, OS_NotifyEvent calls in object allocation/finalize), (2) allocate/finalize object records and explicitly call notification hooks, or (3) are entry points that call other OS_* implementations (wrapper -> impl) and thus could be part of an indirect recursion chain. These should be examined further to determine whether any call chains can lead back to the original caller (directly or indirectly)."
}