{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf UT_StubTableEntry_t::Data.Buff.ContentTypeStr is declared as a plain char * (non-const), then the assignment StubPtr->Data.Buff.ContentTypeStr = TypeName; (where TypeName is const char *) discards the const qualifier and thus violates MISRA C 2023 Rule 8.13. The fix is to declare ContentTypeStr as const char * so the pointer points to a const-qualified type.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_GetStubEntry code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3073.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_GetStubEntry as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_GetStubEntry:\n```c\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n```\n</target_code>\nPlease provide the modified UT_GetStubEntry code.\n",
  "test_code": "#include <stdio.h>\n\n/* Probe function to log control flow and state to /tmp/logs/3073.txt */\nstatic void UT_LogStubState(const char *stage,\n                            UT_StubTableEntry_t *StubPtr,\n                            uint32 Idx,\n                            uint32 SearchLen,\n                            uint32 SearchLimit,\n                            UT_EntryKey_t SearchKey,\n                            UT_EntryType_t TestMode,\n                            UT_EntryKey_t FuncKey)\n{\n    FILE *fp = fopen(\"/tmp/logs/3073.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Print high level information about the current state */\n    (void)fprintf(fp, \"[UT_GetStubEntry] stage=%s Idx=%u SearchLen=%u SearchLimit=%u SearchKey=%lu TestMode=%d FuncKey=%lu StubPtr=%p\\n\",\n                  stage,\n                  (unsigned)Idx,\n                  (unsigned)SearchLen,\n                  (unsigned)SearchLimit,\n                  (unsigned long)SearchKey,\n                  (int)TestMode,\n                  (unsigned long)FuncKey,\n                  (void *)StubPtr);\n\n    if (StubPtr != NULL)\n    {\n        /* Log the stub's entry type and key */\n        (void)fprintf(fp, \"  Stub->EntryType=%d Stub->FuncKey=%lu\\n\",\n                      (int)StubPtr->EntryType,\n                      (unsigned long)StubPtr->FuncKey);\n\n        /* Attempt to log the ContentTypeStr pointer and its string (if present).\n         * This traces the pointer value that is relevant to the const-qualification\n         * scenario described by the reporter. The code only reads the pointer and\n         * prints it; it does not modify any object. */\n        /* Note: Accessing nested fields assumes the UT_StubTableEntry_t layout\n         * contains Data.Buff.ContentTypeStr as in the reported scenario. */\n        const char *contentType = NULL;\n        /* Use a try-style access; if the field exists in the build environment\n         * this will log its value. If not, this line will need adjustment in\n         * the surrounding build context. */\n        contentType = StubPtr->Data.Buff.ContentTypeStr;\n        (void)fprintf(fp, \"  Data.Buff.ContentTypeStr(ptr)=%p\\n\", (void *)contentType);\n        if (contentType != NULL)\n        {\n            /* Print the string contents to provide evidence of what was assigned. */\n            (void)fprintf(fp, \"  Data.Buff.ContentTypeStr(str)=%s\\n\", contentType);\n        }\n    }\n\n    (void)fclose(fp);\n}\n\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* Log initial parameters */\n    UT_LogStubState(\"enter\", NULL, Idx, SearchLen, 0u, 0u, TestMode, FuncKey);\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    UT_LogStubState(\"after_limit_calc\", NULL, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            UT_LogStubState(\"search_exhausted\", StubPtr, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n\n        /* Log each probe of a table entry */\n        UT_LogStubState(\"probe_entry\", StubPtr, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            UT_LogStubState(\"found_match\", StubPtr, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n        UT_LogStubState(\"updated_max_search_len\", StubPtr, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n    }\n\n    UT_LogStubState(\"return\", StubPtr, Idx, SearchLen, SearchLimit, SearchKey, TestMode, FuncKey);\n\n    return StubPtr;\n}\n"
}