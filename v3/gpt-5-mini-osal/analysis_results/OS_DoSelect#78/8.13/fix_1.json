{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/783.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    time_t now = time(NULL);\n    struct tm tmv;\n    if (localtime_r(&now, &tmv) == NULL)\n    {\n        fprintf(f, \"[timestamp:unknown] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tmv) > 0)\n        {\n            fprintf(f, \"[%s] \", buf);\n        }\n        else\n        {\n            fprintf(f, \"[timestamp:fmt_err] \");\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void probe_log_fdset(const char *label, const fd_set *set, int maxfd)\n{\n    /* Dump a modest amount of the fd_set raw bytes plus human-readable FD bits up to maxfd */\n    if (set == NULL)\n    {\n        probe_log(\"%s: <NULL>\", label);\n        return;\n    }\n\n    /* Raw hex dump of first bytes (safe, bounded) */\n    const unsigned char *p = (const unsigned char *)set;\n    size_t to_dump = sizeof(fd_set);\n    if (to_dump > 64) to_dump = 64;\n\n    char hexbuf[3 * 64 + 1];\n    size_t idx = 0;\n    for (size_t i = 0; i < to_dump; ++i)\n    {\n        if (idx + 3 < sizeof(hexbuf))\n        {\n            int n = snprintf(&hexbuf[idx], sizeof(hexbuf) - idx, \"%02X \", p[i]);\n            if (n > 0) idx += (size_t)n;\n        }\n    }\n    hexbuf[idx] = '\\0';\n\n    probe_log(\"%s raw (first %zu bytes): %s\", label, to_dump, hexbuf);\n\n    /* Also log which fds up to maxfd are set (this is higher-level and shows inspection state) */\n    if (maxfd < 0) maxfd = 0;\n    if (maxfd > 1024) maxfd = 1024; /* bound to avoid huge loops */\n\n    /* Build a simple list of set fds */\n    char listbuf[512];\n    size_t pidx = 0;\n    pidx += snprintf(listbuf + pidx, sizeof(listbuf) - pidx, \"set fds:\");\n    for (int fd = 0; fd <= maxfd; ++fd)\n    {\n        /* Use FD_ISSET macro for readability (const-correctness here for logging) */\n        if (FD_ISSET(fd, (fd_set *)set))\n        {\n            if (pidx + 8 < sizeof(listbuf))\n            {\n                pidx += snprintf(listbuf + pidx, sizeof(listbuf) - pidx, \" %d\", fd);\n            }\n        }\n    }\n    if (pidx == 0)\n    {\n        probe_log(\"%s: <no fds reported>\", label);\n    }\n    else\n    {\n        probe_log(\"%s: %s\", label, listbuf);\n    }\n}\n\nstatic int32_t OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32_t msecs)\n{\n    int             os_status;\n    int32_t         return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    /* Log function entry and parameter addresses/values */\n    probe_log(\"ENTER OS_DoSelect: maxfd=%d, msecs=%d, rd_set=%p, wr_set=%p\", maxfd, msecs, (void *)rd_set, (void *)wr_set);\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n\n        probe_log(\"msecs>0: now=(%ld,%ld), end=(%ld,%ld)\", (long)ts_now.tv_sec, (long)ts_now.tv_nsec, (long)ts_end.tv_sec, (long)ts_end.tv_nsec);\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n        probe_log(\"msecs<=0: ts_end cleared\");\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n            probe_log(\"timeout: infinite (tvptr=NULL)\");\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n            probe_log(\"timeout: poll (msecs==0), tv=(%ld,%ld)\", (long)tv.tv_sec, (long)tv.tv_usec);\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                probe_log(\"deadline passed: tv would be negative -> treating as timeout (os_status=0)\");\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n\n            probe_log(\"computed tv for select: tv=(%ld,%ld)\", (long)tv.tv_sec, (long)tv.tv_usec);\n        }\n\n        /* Log fd_set state immediately before select - helps demonstrate how rd_set is used */\n        probe_log_fdset(\"rd_set BEFORE select\", rd_set, maxfd);\n        probe_log_fdset(\"wr_set BEFORE select\", wr_set, maxfd);\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n\n        probe_log(\"select returned: os_status=%d, errno=%d (%s)\", os_status, errno, strerror(errno));\n\n        /* Log fd_set state immediately after select to show any changes by select */\n        probe_log_fdset(\"rd_set AFTER select\", rd_set, maxfd);\n        probe_log_fdset(\"wr_set AFTER select\", wr_set, maxfd);\n\n        if (os_status < 0)\n        {\n            probe_log(\"select error: errno=%d (%s)\", errno, strerror(errno));\n        }\n\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = -1; /* OS_ERROR (preserve original symbolic meaning omitted in this snippet) */\n        probe_log(\"EXIT OS_DoSelect: result=OS_ERROR (%d)\", return_code);\n    }\n    else if (os_status == 0)\n    {\n        return_code = -2; /* OS_ERROR_TIMEOUT */\n        probe_log(\"EXIT OS_DoSelect: result=OS_ERROR_TIMEOUT (%d)\", return_code);\n    }\n    else\n    {\n        return_code = 0; /* OS_SUCCESS */\n        probe_log(\"EXIT OS_DoSelect: result=OS_SUCCESS (%d)\", return_code);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmporzbiw3a/src/src/os/portable/os-impl-bsd-select.c: In function 'probe_log':\n/tmp/tmporzbiw3a/src/src/os/portable/os-impl-bsd-select.c:188:15: error: storage size of 'tmv' isn't known\n  188 |     struct tm tmv;\n      |               ^~~\n/tmp/tmporzbiw3a/src/src/os/portable/os-impl-bsd-select.c:208:22: note: expected '__va_list_tag *' but argument is of type 'OCS_va_list'\n  208 |     vfprintf(f, fmt, ap);\n      |                      ^~\ngmake[2]: *** [unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-bsd-select.dir/build.make:76: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-bsd-select.dir/__/__/os/portable/os-impl-bsd-select.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:2582: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-bsd-select.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_DoSelect as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/783.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    time_t now = time(NULL);\n    struct tm tmv;\n    if (localtime_r(&now, &tmv) == NULL)\n    {\n        fprintf(f, \"[timestamp:unknown] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tmv) > 0)\n        {\n            fprintf(f, \"[%s] \", buf);\n        }\n        else\n        {\n            fprintf(f, \"[timestamp:fmt_err] \");\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast to the library's va_list in case project headers redefine the typedef */\n    vfprintf(f, fmt, (va_list)ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void probe_log_fdset(const char *label, const fd_set *set, int maxfd)\n{\n    /* Dump a modest amount of the fd_set raw bytes plus human-readable FD bits up to maxfd */\n    if (set == NULL)\n    {\n        probe_log(\"%s: <NULL>\", label);\n        return;\n    }\n\n    /* Raw hex dump of first bytes (safe, bounded) */\n    const unsigned char *p = (const unsigned char *)set;\n    size_t to_dump = sizeof(fd_set);\n    if (to_dump > 64) to_dump = 64;\n\n    char hexbuf[3 * 64 + 1];\n    size_t idx = 0;\n    for (size_t i = 0; i < to_dump; ++i)\n    {\n        if (idx + 3 < sizeof(hexbuf))\n        {\n            int n = snprintf(&hexbuf[idx], sizeof(hexbuf) - idx, \"%02X \", p[i]);\n            if (n > 0) idx += (size_t)n;\n        }\n    }\n    hexbuf[idx] = '\\0';\n\n    probe_log(\"%s raw (first %zu bytes): %s\", label, to_dump, hexbuf);\n\n    /* Also log which fds up to maxfd are set (this is higher-level and shows inspection state) */\n    if (maxfd < 0) maxfd = 0;\n    if (maxfd > 1024) maxfd = 1024; /* bound to avoid huge loops */\n\n    /* Build a simple list of set fds */\n    char listbuf[512];\n    size_t pidx = 0;\n    pidx += snprintf(listbuf + pidx, sizeof(listbuf) - pidx, \"set fds:\");\n    for (int fd = 0; fd <= maxfd; ++fd)\n    {\n        /* Use FD_ISSET macro for readability (const-correctness here for logging) */\n        if (FD_ISSET(fd, (fd_set *)set))\n        {\n            if (pidx + 8 < sizeof(listbuf))\n            {\n                pidx += snprintf(listbuf + pidx, sizeof(listbuf) - pidx, \" %d\", fd);\n            }\n        }\n    }\n    if (pidx == 0)\n    {\n        probe_log(\"%s: <no fds reported>\", label);\n    }\n    else\n    {\n        probe_log(\"%s: %s\", label, listbuf);\n    }\n}\n\nstatic int32_t OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32_t msecs)\n{\n    int             os_status;\n    int32_t         return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    /* Log function entry and parameter addresses/values */\n    probe_log(\"ENTER OS_DoSelect: maxfd=%d, msecs=%d, rd_set=%p, wr_set=%p\", maxfd, msecs, (void *)rd_set, (void *)wr_set);\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n\n        probe_log(\"msecs>0: now=(%ld,%ld), end=(%ld,%ld)\", (long)ts_now.tv_sec, (long)ts_now.tv_nsec, (long)ts_end.tv_sec, (long)ts_end.tv_nsec);\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n        probe_log(\"msecs<=0: ts_end cleared\");\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n            probe_log(\"timeout: infinite (tvptr=NULL)\");\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n            probe_log(\"timeout: poll (msecs==0), tv=(%ld,%ld)\", (long)tv.tv_sec, (long)tv.tv_usec);\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                probe_log(\"deadline passed: tv would be negative -> treating as timeout (os_status=0)\");\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n\n            probe_log(\"computed tv for select: tv=(%ld,%ld)\", (long)tv.tv_sec, (long)tv.tv_usec);\n        }\n\n        /* Log fd_set state immediately before select - helps demonstrate how rd_set is used */\n        probe_log_fdset(\"rd_set BEFORE select\", rd_set, maxfd);\n        probe_log_fdset(\"wr_set BEFORE select\", wr_set, maxfd);\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n\n        probe_log(\"select returned: os_status=%d, errno=%d (%s)\", os_status, errno, strerror(errno));\n\n        /* Log fd_set state immediately after select to show any changes by select */\n        probe_log_fdset(\"rd_set AFTER select\", rd_set, maxfd);\n        probe_log_fdset(\"wr_set AFTER select\", wr_set, maxfd);\n\n        if (os_status < 0)\n        {\n            probe_log(\"select error: errno=%d (%s)\", errno, strerror(errno));\n        }\n\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = -1; /* OS_ERROR (preserve original symbolic meaning omitted in this snippet) */\n        probe_log(\"EXIT OS_DoSelect: result=OS_ERROR (%d)\", return_code);\n    }\n    else if (os_status == 0)\n    {\n        return_code = -2; /* OS_ERROR_TIMEOUT */\n        probe_log(\"EXIT OS_DoSelect: result=OS_ERROR_TIMEOUT (%d)\", return_code);\n    }\n    else\n    {\n        return_code = 0; /* OS_SUCCESS */\n        probe_log(\"EXIT OS_DoSelect: result=OS_SUCCESS (%d)\", return_code);\n    }\n\n    return return_code;\n}\n",
  "explanation": "I added the necessary standard headers (time.h, stdarg.h, string.h, sys/select.h, sys/time.h, errno.h, etc.) so struct tm and fd_set are defined. To address the va_list mismatch shown in the build log (project-specific va_list typedefs), I cast the va_list when calling vfprintf: vfprintf(f, fmt, (va_list)ap);. No logic of OS_DoSelect was changed; only header inclusions and the safe cast were added to allow successful compilation."
}