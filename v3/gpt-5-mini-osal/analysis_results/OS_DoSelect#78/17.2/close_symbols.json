{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nFunctions shall not call themselves, either directly or indirectly. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SelectSingle_Impl",
    "OS_SelectMultiple_Impl",
    "OS_ObjectIndexFromToken",
    "OS_FdSet_ConvertIn_Impl",
    "OS_FdSet_ConvertOut_Impl",
    "OS_GenericRead_Impl",
    "OS_GenericWrite_Impl",
    "OS_SocketConnect_Impl",
    "OS_SocketAccept_Impl",
    "OS_SocketRecvFrom_Impl",
    "OS_SelectSingle",
    "OS_SelectMultiple",
    "clock_gettime",
    "select",
    "memset"
  ],
  "explanation": "To determine whether OS_DoSelect is (directly or indirectly) recursive we must examine any functions that could form a call cycle with it and any library calls it makes that might call back into application code. The listed symbols are required for that analysis:\n\n- OS_SelectSingle_Impl, OS_SelectMultiple_Impl: Immediate callers of OS_DoSelect according to the static call graph; necessary to see whether they (or functions they call) call back into OS_DoSelect.\n- OS_ObjectIndexFromToken, OS_FdSet_ConvertIn_Impl, OS_FdSet_ConvertOut_Impl: Callees of the above implementations; these must be inspected to ensure they do not (directly or via further calls) lead back to OS_DoSelect.\n- OS_GenericRead_Impl, OS_GenericWrite_Impl, OS_SocketConnect_Impl, OS_SocketAccept_Impl, OS_SocketRecvFrom_Impl, OS_SelectSingle, OS_SelectMultiple: Callers of OS_SelectSingle_Impl/OS_SelectMultiple_Impl (from the provided graph). These higher-level entry points must be checked for any call chains that could create a cycle returning to OS_DoSelect.\n- clock_gettime, select, memset: Library/system calls invoked by OS_DoSelect. Although unlikely, they must be considered to ensure they do not call into application code (e.g., via callbacks or signal handlers) that could ultimately call OS_DoSelect and produce indirect recursion.\n\nInspecting the bodies (or reliable summaries) of these symbols will allow the next agent to determine whether any path exists from OS_DoSelect back to itself, thereby confirming compliance with the MISRA rule forbidding direct or indirect self-calls."
}