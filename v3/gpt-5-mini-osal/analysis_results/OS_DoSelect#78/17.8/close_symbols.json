{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "select (function prototype)",
    "fd_set (type/typedef definition)",
    "struct timeval (definition)",
    "struct timespec (definition)",
    "clock_gettime (function prototype)",
    "memset (function prototype)",
    "errno (external variable) and macros EINTR, EAGAIN",
    "int32 (typedef/definition)",
    "C language parameter-passing semantics (pointers passed by value)"
  ],
  "explanation": "\u2022 select (function prototype): confirm the parameter types for select (it takes fd_set *readfds, *writefds, etc.). This proves select receives copies of the pointer values (fd_set *) and cannot directly change the caller's pointer variables (only the memory they point to).\n\u2022 fd_set (type/typedef definition): verify that fd_set is not itself a pointer typedef (e.g., typedef SOME_STRUCT *fd_set). If fd_set were a pointer alias, passing fd_set * would be a pointer-to-pointer and could allow called code to modify the function parameter. Knowing the actual fd_set definition ensures rd_set/wr_set are plain pointers to an object and not pointer aliases.\n\u2022 struct timeval (definition): used for the local tv and for the timeout argument to select. Its member types (tv_sec, tv_usec) confirm arithmetic operates on local variables, not on parameters.\n\u2022 struct timespec (definition): used for ts_now/ts_end; confirms these are local objects and that clock_gettime operates on local variables rather than parameters.\n\u2022 clock_gettime (function prototype): shows it takes a struct timespec * and thus only modifies the local ts_now, not any of the function parameters. Confirms no indirect modification of rd_set/wr_set/maxfd/msecs via this call.\n\u2022 memset (function prototype): confirms memset is called on &ts_end (a local object), not on any parameter; ensures memset won't modify parameter variables.\n\u2022 errno (external variable) and macros EINTR, EAGAIN: needed to interpret the loop condition (os_status < 0 && (errno == EINTR || errno == EAGAIN)). They do not affect whether parameters are modified but are part of the control flow; include to fully understand whether code path could assign to parameters under error handling.\n\u2022 int32 (typedef/definition): to confirm that msecs is a plain integer type (passed by value) and cannot be modified indirectly by called functions that take different types.\n\u2022 C language parameter-passing semantics (pointers passed by value): the language-level rule (call-by-value) is required to conclude that passing rd_set and wr_set to select (or other functions) cannot change the pointer variables themselves in the caller unless their addresses (&rd_set) were passed.\n\nTogether these symbols allow verifying that all operations and calls inside OS_DoSelect operate on local objects or on the memory pointed to by pointer parameters, and that no called function can legally modify the pointer parameter variables themselves."
}