{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of UT_DoSetHookFunction:\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function UT_DoSetHookFunction:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\n#define UT_MAX_FUNC_STUBS 200\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (Value.Addr == NULL && StubPtr != NULL)\n{\n    /* Caller wants to delete the entry */\n    UT_ClearStubEntry(StubPtr);\n}\nelse if (StubPtr != NULL && Value.Addr != NULL)\n{\n    /* Caller wants to set the entry */\n    StubPtr->FuncKey             = FuncKey;\n    StubPtr->EntryType           = EntryType;\n    StubPtr->Data.Cb.CallbackArg = UserObj;\n    StubPtr->Data.Cb.Ptr         = Value;\n    StubPtr->Data.Cb.IsVarg      = IsVarg;\n}",
    "while (1)\n{\n    if (SearchLen >= SearchLimit)\n    {\n        StubPtr = NULL;\n        break;\n    }\n    ++SearchLen;\n    StubPtr = &UT_StubTable[Idx];\n    if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n    {\n        break;\n    }\n    ++Idx;\n    if (Idx >= UT_MAX_FUNC_STUBS)\n    {\n        Idx = 0;\n    }\n}",
    "#define UT_MAX_FUNC_STUBS 200",
    "if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n    StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n{\n    free(StubPtr->Data.Buff.BasePtr);\n}\nmemset(StubPtr, 0, sizeof(*StubPtr));",
    "StubPtr = UT_GetStubEntry(FuncKey, EntryType);\nif (StubPtr == NULL && Value.Addr != NULL)\n{\n    /* Creating force fail entry - repeat search and grab any unused slot */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n    }\n}",
    "if (TestMode == UT_ENTRYTYPE_UNUSED)\n{\n    SearchLimit = UT_MAX_FUNC_STUBS;\n    SearchKey   = 0;\n}\nelse\n{\n    SearchLimit = UT_MaxStubSearchLen;\n    SearchKey   = FuncKey;\n}",
    "uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */"
  ],
  "explanation": "I have listed code fragments that warrant investigation for possible unreachable code or logic that can render other code paths unreachable. These items include the initial lookup and fallback in UT_DoSetHookFunction (including the UtAssert_Abort path), the subsequent delete/set conditional block, the hashing/index initialization (Idx calculation), the selection of SearchLimit/SearchKey, the main search loop (which may limit which table slots are ever inspected), the clear/free + memset in UT_ClearStubEntry (which may or may not execute depending on ModeFlags), and the UT_MAX_FUNC_STUBS definition which influences indexing/search coverage.\n\nOther code in the provided snippets was not listed because it is simple, direct data/type definitions or straightforward control flow that does not itself introduce obvious unreachable paths (e.g., union/typedef declarations, simple return statements, the UT_GetStubEntry return/update of UT_MaxStubSearchLen). The investigation should focus on the listed fragments to determine whether the logic makes any code paths or table entries unreachable in practice (for example due to the modulus by UT_MAX_FUNC_STUBS-1, SearchLimit usage, or the conditions that gate the UtAssert_Abort and the clear/set branches)."
}