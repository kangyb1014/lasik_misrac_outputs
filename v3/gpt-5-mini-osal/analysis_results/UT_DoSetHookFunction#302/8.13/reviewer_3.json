{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter UserObj is declared as void * (non-const) and the code stores it into StubPtr->Data.Cb.CallbackArg. If CallbackArg is also a non-const pointer (e.g. void *CallbackArg) and the pointed-to object is not intended to be modified by the stub system, then the pointer types should be const-qualified (const void *) per MISRA C 2023 Rule 8.13. Thus this assignment represents a violation: a pointer is declared/used without const qualification where a const-qualified pointer would be appropriate. (If CallbackArg is already declared as const void * or there is a deliberate need to modify the pointee, then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nStage=entry: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nStage=after_initial_search: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nCreating force-fail entry: initial StubPtr NULL and Value.Addr != NULL (Value.Addr=0x55d4d214c60c)\nStage=after_get_unused_slot: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=0x55d4d2162ba0\n  -> Existing CallbackArg (at stage after_get_unused_slot) = (nil)\nStage=before_set: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=0x55d4d2162ba0\n  -> Existing CallbackArg (at stage before_set) = (nil)\nAssigning CallbackArg: StubPtr=0x55d4d2162ba0, old CallbackArg=(nil), New UserObj=(nil)\nStage=after_set: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=0x55d4d2162ba0\n  -> Existing CallbackArg (at stage after_set) = (nil)\nStage=exit: FuncKey=94372545996127, EntryType=6, Value.Addr=0x55d4d214c60c, UserObj=(nil), IsVarg=0, StubPtr=0x55d4d2162ba0\n  -> Existing CallbackArg (at stage exit) = (nil)\nStage=entry: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nStage=after_initial_search: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nCreating force-fail entry: initial StubPtr NULL and Value.Addr != NULL (Value.Addr=0x559e3b41628f)\nStage=after_get_unused_slot: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d560\n  -> Existing CallbackArg (at stage after_get_unused_slot) = (nil)\nStage=before_set: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d560\n  -> Existing CallbackArg (at stage before_set) = (nil)\nAssigning CallbackArg: StubPtr=0x559e3b43d560, old CallbackArg=(nil), New UserObj=(nil)\nStage=after_set: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d560\n  -> Existing CallbackArg (at stage after_set) = (nil)\nStage=exit: FuncKey=94138087332743, EntryType=6, Value.Addr=0x559e3b41628f, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d560\n  -> Existing CallbackArg (at stage exit) = (nil)\nStage=entry: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nStage=after_initial_search: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nCreating force-fail entry: initial StubPtr NULL and Value.Addr != NULL (Value.Addr=0x559e3b414ef3)\nStage=after_get_unused_slot: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d9e0\n  -> Existing CallbackArg (at stage after_get_unused_slot) = (nil)\nStage=before_set: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d9e0\n  -> Existing CallbackArg (at stage before_set) = (nil)\nAssigning CallbackArg: StubPtr=0x559e3b43d9e0, old CallbackArg=(nil), New UserObj=(nil)\nStage=after_set: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d9e0\n  -> Existing CallbackArg (at stage after_set) = (nil)\nStage=exit: FuncKey=94138087324387, EntryType=6, Value.Addr=0x559e3b414ef3, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43d9e0\n  -> Existing CallbackArg (at stage exit) = (nil)\nStage=entry: FuncKey=94138087313012, EntryType=6, Value.Addr=0x559e3b412f21, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nStage=after_initial_search: FuncKey=94138087313012, EntryType=6, Value.Addr=0x559e3b412f21, UserObj=(nil), IsVarg=0, StubPtr=(nil)\nCreating force-fail entry: initial StubPtr NULL and Value.Addr != NULL (Value.Addr=0x559e3b412f21)\nStage=after_get_unused_slot: FuncKey=94138087313012, EntryType=6, Value.Addr=0x559e3b412f21, UserObj=(nil), IsVarg=0, StubPtr=0x559e3b43b4c0\n  -> Existing CallbackArg (at stage after_get_unuse\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not deterministically correct. MISRA C 2023 R8.13 advises that pointers should point to const-qualified types when the pointed-to object is not modified, but whether a violation exists here depends on the intended semantics and the actual type of CallbackArg. In the shown code UT_DoSetHookFunction simply stores the UserObj pointer into StubPtr->Data.Cb.CallbackArg and does not dereference it. If CallbackArg (and the callbacks that use it) are intended to allow modification of the user-supplied object, then the non-const void * parameter is appropriate and there is no R8.13 violation. If, however, the user object is intended to be treated as read-only, then both UserObj and CallbackArg should be declared as const void * and a MISRA R8.13 issue could be raised. The provided code and symbol definitions do not include the declaration of CallbackArg nor the intended mutability of the pointed-to object, so there is insufficient evidence to conclude a definite R8.13 violation. Recommendation: if the user object is not modified by the stub system, change the types to const void * (or document why mutation is required) to satisfy R8.13."
}