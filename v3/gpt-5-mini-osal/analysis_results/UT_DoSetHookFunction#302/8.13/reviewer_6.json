{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe union member 'void * Addr;' is used merely to hold and compare addresses (e.g. Value.Addr is compared to NULL and stored in stub entries) and is not used to modify the object pointed to. According to MISRA C 2023 Rule 8.13, such pointers should be const-qualified when possible (e.g. 'const void * Addr;'). Because the pointer type is not const-qualified even though the code only observes/stores the address (does not modify the pointee), this is a violation. (Fix: declare the member as 'const void * Addr' where compatible with the rest of the code.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_DoSetHookFunction ENTRY: Value.Addr=0x56397d26060c UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x56397d280600\nBefore final branch: Value.Addr=0x56397d26060c StubPtr=0x56397d280600\nSetting stub entry at 0x56397d280600: UserObj=(nil) Value.Addr=0x56397d26060c IsVarg=0\nStub entry set successfully at 0x56397d280600\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3db28f UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3fcba0\nBefore final branch: Value.Addr=0x560d9b3db28f StubPtr=0x560d9b3fcba0\nSetting stub entry at 0x560d9b3fcba0: UserObj=(nil) Value.Addr=0x560d9b3db28f IsVarg=0\nStub entry set successfully at 0x560d9b3fcba0\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3d9ef3 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3fd020\nBefore final branch: Value.Addr=0x560d9b3d9ef3 StubPtr=0x560d9b3fd020\nSetting stub entry at 0x560d9b3fd020: UserObj=(nil) Value.Addr=0x560d9b3d9ef3 IsVarg=0\nStub entry set successfully at 0x560d9b3fd020\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3d7f21 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3fab00\nBefore final branch: Value.Addr=0x560d9b3d7f21 StubPtr=0x560d9b3fab00\nSetting stub entry at 0x560d9b3fab00: UserObj=(nil) Value.Addr=0x560d9b3d7f21 IsVarg=0\nStub entry set successfully at 0x560d9b3fab00\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3da116 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3f9240\nBefore final branch: Value.Addr=0x560d9b3da116 StubPtr=0x560d9b3f9240\nSetting stub entry at 0x560d9b3f9240: UserObj=(nil) Value.Addr=0x560d9b3da116 IsVarg=0\nStub entry set successfully at 0x560d9b3f9240\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3da331 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3f5b20\nBefore final branch: Value.Addr=0x560d9b3da331 StubPtr=0x560d9b3f5b20\nSetting stub entry at 0x560d9b3f5b20: UserObj=(nil) Value.Addr=0x560d9b3da331 IsVarg=0\nStub entry set successfully at 0x560d9b3f5b20\nUT_DoSetHookFunction ENTRY: Value.Addr=0x560d9b3d9fe3 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x560d9b3fa560\nBefore final branch: Value.Addr=0x560d9b3d9fe3 StubPtr=0x560d9b3fa560\nSetting stub entry at 0x560d9b3fa560: UserObj=(nil) Value.Addr=0x560d9b3d9fe3 IsVarg=0\nStub entry set successfully at 0x560d9b3fa560\nUT_DoSetHookFunction ENTRY: Value.Addr=0x558e64f32533 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x558e64f4bba0\nBefore final branch: Value.Addr=0x558e64f32533 StubPtr=0x558e64f4bba0\nSetting stub entry at 0x558e64f4bba0: UserObj=(nil) Value.Addr=0x558e64f32533 IsVarg=0\nStub entry set successfully at 0x558e64f4bba0\nUT_DoSetHookFunction ENTRY: Value.Addr=0x5603bec17b4a UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil) (looking for FuncKey/EntryType)\nNo existing stub and Value.Addr != NULL -> search for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x5603bec49020\nBefore final branch: Val\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 (\u201ca pointer should point to a const-qualified type whenever possible\u201d) is a general guidance, but the asserted violation is not convincingly applicable here. UT_HookFuncPtr_t is a union that mixes object-pointer-like member (Addr) with several function-pointer types. The code treats the union as a raw holder for callback addresses (compare to NULL, copy the union into the stub entry) rather than dereferencing Addr. Making the Addr member const void * is not necessarily \u201cpossible\u201d without wider changes: it can create qualifier mismatches when the union is used with the other (non-const) function-pointer members or when the union values are assigned/initialized from non-const function-pointer types. Also, conversions/aliases between object pointers and function pointers are a separate portability/standards concern (and can prevent simply changing Addr to const void*). In short, the justification provided by agent A (that Addr is only observed and therefore should be const) ignores the union semantics and cross-use with function-pointer members; therefore the reported MISRA 8.13 violation is not correct as presented."
}