{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe condition tests Value.Addr (declared as void * in UT_HookFuncPtr_t) against NULL. Since Addr is only inspected and copied (not used to modify the pointee), it could/should be declared as const void * and therefore the current non-const declaration violates MISRA C 2023 Rule 8.13. (If Addr is intentionally used to hold pointers to mutable data or to function pointers that must not be const-qualified, then making it const may be inappropriate; but based on the shown usage the non-const pointer is avoidable.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_DoSetHookFunction ENTRY: FuncKey=1716221279 EntryType=6 Value.Addr=0x564b664b960c UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x564b664cf2e0\nBranch: set entry at 0x564b664cf2e0. Setting FuncKey=1716221279 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x564b664b960c IsVarg=0\nAfter set: entry at 0x564b664cf2e0 now has FuncKey=1716221279 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x564b664b960c IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14408583 EntryType=6 Value.Addr=0x55da00dbe28f UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00ddc6c0\nBranch: set entry at 0x55da00ddc6c0. Setting FuncKey=14408583 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbe28f IsVarg=0\nAfter set: entry at 0x55da00ddc6c0 now has FuncKey=14408583 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbe28f IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14400227 EntryType=6 Value.Addr=0x55da00dbcef3 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00ddcb40\nBranch: set entry at 0x55da00ddcb40. Setting FuncKey=14400227 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbcef3 IsVarg=0\nAfter set: entry at 0x55da00ddcb40 now has FuncKey=14400227 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbcef3 IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14388852 EntryType=6 Value.Addr=0x55da00dbaf21 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00dda620\nBranch: set entry at 0x55da00dda620. Setting FuncKey=14388852 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbaf21 IsVarg=0\nAfter set: entry at 0x55da00dda620 now has FuncKey=14388852 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbaf21 IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14404153 EntryType=6 Value.Addr=0x55da00dbd116 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00dd8d60\nBranch: set entry at 0x55da00dd8d60. Setting FuncKey=14404153 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbd116 IsVarg=0\nAfter set: entry at 0x55da00dd8d60 now has FuncKey=14404153 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbd116 IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14402313 EntryType=6 Value.Addr=0x55da00dbd331 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00de3620\nBranch: set entry at 0x55da00de3620. Setting FuncKey=14402313 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbd331 IsVarg=0\nAfter set: entry at 0x55da00de3620 now has FuncKey=14402313 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbd331 IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=14401782 EntryType=6 Value.Addr=0x55da00dbcfe3 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55da00dda080\nBranch: set entry at 0x55da00dda080. Setting FuncKey=14401782 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbcfe3 IsVarg=0\nAfter set: entry at 0x55da00dda080 now has FuncKey=14401782 EntryType=6 CallbackArg=(nil) Ptr.Addr=0x55da00dbcfe3 IsVarg=0\nUT_DoSetHookFunction ENTRY: FuncKey=128213203 EntryType=3 Value.Addr=0x563d07a44533 UserObj=(nil) IsVarg=0\nAfter UT_GetStubEntry(primary): StubPtr=(nil)\nBranch: no existing entry and Value.Addr != NULL -> search for unused slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x563d07a625e0\nBranch: set entry at 0x563d07a625e0. Setting FuncKey=128213203 EntryType=3 CallbackArg=(nil) Ptr.Addr=0x5\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not proven by the snippet. MISRA C:2023 R8.13 does recommend using pointers to const when the pointed-to object is not modified, but you can only call a violation if it is clear that adding const is both correct and feasible across the API/use-sites. In this code the void * member (UT_HookFuncPtr_t::Addr) is part of a union that also carries several function-pointer types. Changing that member to const void * would change the union\u2019s type/ABI and could be incompatible with other code that stores, converts or calls through the other union members. In the shown function Value.Addr is only tested against NULL and the union value is copied into the stub table, but that single use does not prove that const qualification is \u201cpossible\u201d project-wide. Without inspecting all uses of UT_HookFuncPtr_t and how its members are interpreted/called, you cannot conclude a definite MISRA violation. Therefore the report is not correct (insufficient evidence)."
}