{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn UT_GetStubEntry the loop uses while (1) whose controlling expression is the invariant constant 1. This loop is not intended to be an infinite loop (it relies on internal break conditions to terminate when SearchLen >= SearchLimit or when a matching entry is found), so the invariant controlling expression violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: UT_DoSetHookFunction(FuncKey=94145058592063, EntryType=6, Value.Addr=0x559fdac675ec, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x559fdac884e0\nSetting entry at StubPtr=0x559fdac884e0 -> FuncKey=94145058592063, EntryType=6, UserObj=(nil), Value.Addr=0x559fdac675ec, IsVarg=0\nEntry set: StubPtr=0x559fdac884e0\nEXIT: UT_DoSetHookFunction(FuncKey=94145058592063)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481661287, EntryType=6, Value.Addr=0x5624336e126f, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x562433703720\nSetting entry at StubPtr=0x562433703720 -> FuncKey=94713481661287, EntryType=6, UserObj=(nil), Value.Addr=0x5624336e126f, IsVarg=0\nEntry set: StubPtr=0x562433703720\nEXIT: UT_DoSetHookFunction(FuncKey=94713481661287)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481652931, EntryType=6, Value.Addr=0x5624336dfed3, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x562433703ba0\nSetting entry at StubPtr=0x562433703ba0 -> FuncKey=94713481652931, EntryType=6, UserObj=(nil), Value.Addr=0x5624336dfed3, IsVarg=0\nEntry set: StubPtr=0x562433703ba0\nEXIT: UT_DoSetHookFunction(FuncKey=94713481652931)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481641556, EntryType=6, Value.Addr=0x5624336ddf01, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x562433701680\nSetting entry at StubPtr=0x562433701680 -> FuncKey=94713481641556, EntryType=6, UserObj=(nil), Value.Addr=0x5624336ddf01, IsVarg=0\nEntry set: StubPtr=0x562433701680\nEXIT: UT_DoSetHookFunction(FuncKey=94713481641556)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481656857, EntryType=6, Value.Addr=0x5624336e00f6, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x5624336ffdc0\nSetting entry at StubPtr=0x5624336ffdc0 -> FuncKey=94713481656857, EntryType=6, UserObj=(nil), Value.Addr=0x5624336e00f6, IsVarg=0\nEntry set: StubPtr=0x5624336ffdc0\nEXIT: UT_DoSetHookFunction(FuncKey=94713481656857)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481655017, EntryType=6, Value.Addr=0x5624336e0311, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x5624336fc6a0\nSetting entry at StubPtr=0x5624336fc6a0 -> FuncKey=94713481655017, EntryType=6, UserObj=(nil), Value.Addr=0x5624336e0311, IsVarg=0\nEntry set: StubPtr=0x5624336fc6a0\nEXIT: UT_DoSetHookFunction(FuncKey=94713481655017)\nENTRY: UT_DoSetHookFunction(FuncKey=94713481654486, EntryType=6, Value.Addr=0x5624336dffc3, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x5624337010e0\nSetting entry at StubPtr=0x5624337010e0 -> FuncKey=94713481654486, EntryType=6, UserObj=(nil), Value.Addr=0x5624336dffc3, IsVarg=0\nEntry set: StubPtr=0x5624337010e0\nEXIT: UT_DoSetHookFunction(FuncKey=94713481654486)\nENTRY: UT_DoSetHookFunction(FuncKey=94358499889331, EntryType=3, Value.Addr=0x55d18cddf513, UserObj=(nil), IsVarg=0)\nAfter UT_GetStubEntry(initial): StubPtr=(nil)\nNo existing entry and Value.Addr != NULL -> searching for UNUSED slot\nAfter UT_GetStubEntry(UNUSED): StubPtr=0x55d18cdfeee0\nSetting entry at StubPtr=0x55d18cdfeee0 -> FuncKey=94358499889331, EntryType=3, UserObj=(nil), Value.Addr=0x55d18cddf513, IsVarg=0\nEntry set: StubPtr=0x55d18cdfeee0\nEXIT: UT_DoSetHookFunction(FuncKey=94358499889331)\nENTRY: UT_DoSetHookFunction(FuncKey=94296052274844, EntryType=3, Value.A\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct that there is a Rule 14.3 violation in the code invoked by UT_DoSetHookFunction. The loop in UT_GetStubEntry uses the invariant controlling expression while (1). MISRA C 2023 Rule 14.3 disallows invariant controlling expressions except for (a) invariants that are used to create infinite loops or (b) the special do-while false pattern. The while (1) in UT_GetStubEntry is not intended as an infinite loop \u2014 it relies on internal break conditions (SearchLen >= SearchLimit or a matching entry found) to terminate \u2014 so it does not meet the allowed exception. Therefore the report of a violation is correct. Note: UT_DoSetHookFunction itself does not contain the loop; the offending code is in UT_GetStubEntry which UT_DoSetHookFunction calls. A simple fix is to rewrite the loop to use an explicitly conditional loop (for example while (SearchLen < SearchLimit) or an appropriate for loop) so the controlling expression is not invariant."
}