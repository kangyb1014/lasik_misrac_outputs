{
  "user_message": "An agent A claimed that the following OS_SymbolTableDump code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_SymbolTableDump.\n```c\nint32 OS_SymbolTableDump(const char *filename, size_t SizeLimit)\n{\n    int32             return_code;\n    char              translated_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filename);\n\n    /*\n     ** Translate the filename to the Host System\n     */\n    return_code = OS_TranslatePath(filename, translated_path);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Locking the global ensures only one symbol table dump\n     * can be executing.  It also prevents module loading/unloading\n     * while the dump is occurring.\n     *\n     * Because calls to this function are serialized, the\n     * underlying implementation may safely use globals for\n     * state storage.\n     */\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, &token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_SymbolTableDump_Impl(translated_path, SizeLimit);\n\n    OS_ObjectIdTransactionCancel(&token);\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf OS_SymbolTableDump_Impl is declared to take a non-const char * (for example: int32 OS_SymbolTableDump_Impl(char *filename, size_t SizeLimit)) but does not modify the string contents, then this is a violation of MISRA C 2023 Rule 8.13. The pointer parameter should be declared as const char *filename whenever the function does not modify the pointed-to data. (If, instead, OS_SymbolTableDump_Impl is already declared to take const char *, then there is no violation.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SymbolTableDump:\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct in principle. MISRA C 2023 Rule 8.13 requires that pointer parameters be const-qualified when the pointed-to object is not modified by the function. If OS_SymbolTableDump_Impl is declared as taking a non-const char * (e.g. int32 OS_SymbolTableDump_Impl(char *filename, size_t SizeLimit)) but in its implementation it does not modify the pointed-to characters, then that declaration violates Rule 8.13 and should be changed to take const char *filename.\n\nA few clarifications:\n- The violation would be in the declaration/definition of OS_SymbolTableDump_Impl, not in OS_SymbolTableDump itself (translated_path is a mutable char array and can be passed to either char * or const char * parameters).\n- If OS_SymbolTableDump_Impl actually modifies the buffer or needs to call subroutines that require a non-const char *, then declaring it non-const is appropriate and not a violation. Also, there are legitimate interoperability reasons that might prevent adding const, in which case no violation occurs.\n\nGiven the scenario stated (OS_SymbolTableDump_Impl takes non-const char * but does not modify the data), the report of a Rule 8.13 violation is correct."
}