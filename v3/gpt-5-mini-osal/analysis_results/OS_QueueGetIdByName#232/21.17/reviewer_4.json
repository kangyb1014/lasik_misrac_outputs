{
  "user_message": "An agent A claimed that the following OS_QueueGetIdByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGetIdByName.\n```c\nint32 OS_QueueGetIdByName(osal_id_t *queue_id, const char *queue_name)\n{\n    int32 return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_POINTER(queue_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, queue_name, queue_id);\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe LENGTHCHECK(name, OS_MAX_API_NAME, ...) macro likely computes the length of the C string (e.g. via strlen) and compares it to OS_MAX_API_NAME. In OS_QueueGetIdByName only a non-NULL pointer is guaranteed (OS_CHECK_POINTER). If the caller supplies a non-NULL pointer that does not point to a null-terminated string (or points near the end of its containing object), a strlen-based LENGTHCHECK will read past the bounds of the referenced object and thus violate Rule 21.17. For example, if LENGTHCHECK expands to something like\n    if (strlen(name) >= OS_MAX_API_NAME) return OS_ERR_NAME_TOO_LONG;\nand 'name' is not null-terminated within its object, strlen will access memory beyond the object boundary.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_QueueGetIdByName ENTRY: queue_id=0x7ffd883ad20c, queue_name=0x7ffd883ad210\nNOTE: queue_name pointer is non-NULL; caller must ensure it points to a NUL-terminated string. No dereference performed here to avoid UB.\nOS_QueueGetIdByName EXIT: return_code=-13\nOS_QueueGetIdByName ENTRY: queue_id=0x7ffd883ad20c, queue_name=0x560fa22d0f50\nNOTE: queue_name pointer is non-NULL; caller must ensure it points to a NUL-terminated string. No dereference performed here to avoid UB.\nOS_QueueGetIdByName EXIT: return_code=-17\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_QueueGetIdByName:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdGetByName(OS_lock_mode_t lock_mode, osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    return OS_ObjectIdGetBySearch(lock_mode, idtype, OS_ObjectNameMatch, (void *)name, token);\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\nvoid OS_printf(const char *String, ...)\n{\n    va_list va;\n    char    msg_buffer[OS_BUFFER_SIZE];\n    int     actualsz;\n\n    BUGCHECK_VOID(String != NULL)\n\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER)\n    {\n        /*\n         * Catch some historical mis-use of the OS_printf() call.\n         *\n         * Typically OS_printf() should NOT be called before OS_API_Init().\n         *\n         * This was never guaranteed to work, particularly on a VxWorks\n         * deployment where the utility task was enabled.\n         *\n         * However, some PSPs do this, particularly those that used POSIX\n         * where it happened to work (because OS_printf just called printf).\n         *\n         * As a workaround, use the OS_DEBUG facility to dump the message,\n         * along with a clue that this API is being used inappropriately.\n         *\n         * If debugging is not enabled, then this message will be silently\n         * discarded.\n         */\n        OS_DEBUG(\"BUG: OS_printf() called when OSAL not initialized: %s\", String);\n    }\n    else if (OS_SharedGlobalVars.PrintfEnabled)\n    {\n        /* Format and determine the size of string to write */\n        va_start(va, String);\n        actualsz = vsnprintf(msg_buffer, sizeof(msg_buffer), String, va);\n        va_end(va);\n\n        if (actualsz < 0)\n        {\n            /* unlikely: vsnprintf failed */\n            actualsz = 0;\n        }\n        else if (actualsz >= OS_BUFFER_SIZE)\n        {\n            /* truncate */\n            actualsz = OS_BUFFER_SIZE - 1;\n        }\n\n        msg_buffer[actualsz] = 0;\n\n        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer);\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not proven correct. MISRA C 2023 Rule 21.17 targets uses of <string.h> functions that can read past an object boundary (for example an unbounded strlen). The snippet shown for OS_QueueGetIdByName itself does not call any <string.h> functions \u2014 it only checks that the pointer is non-NULL and delegates to OS_ObjectIdFindByName. The only place where a string-length check appears is in OS_ObjectIdFindByName via the LENGTHCHECK macro, but the definition of LENGTHCHECK was not provided. If LENGTHCHECK were implemented using an unbounded strlen(name) (as agent A hypothesised) then there would indeed be a potential Rule 21.17 violation when callers pass a non-NULL pointer that does not point to a NUL-terminated object of sufficient size. However, without the actual macro implementation you cannot conclude the code violates the rule: LENGTHCHECK might use a bounded operation (e.g. strnlen or an explicit loop limited to OS_MAX_API_NAME) or otherwise enforce safety, in which case no violation occurs. In short: the reported violation is only valid if LENGTHCHECK uses an unbounded string function like strlen. Given that definition is not shown, the report is unproven and thus not correct as presented. Recommendation: ensure LENGTHCHECK uses a bounded operation (strnlen/memchr with a max length or explicit bound checking) or document the API precondition that the caller must supply a NUL-terminated string of at most OS_MAX_API_NAME bytes to avoid any Rule 21.17 concerns."
}