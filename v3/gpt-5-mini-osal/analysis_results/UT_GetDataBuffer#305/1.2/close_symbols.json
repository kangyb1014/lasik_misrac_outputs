{
  "user_message": "Target function code is:\n```c\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_GetDataBuffer': {'callees': ['UT_GetStubEntry'], 'callers': ['UT_DefaultHandler_OS_GetVersionString', 'UT_DefaultHandler_OS_GetVersionCodeName']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_DefaultHandler_OS_GetVersionString': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionCodeName': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_StubTableEntry_t",
    "(inner) Buff member type / fields (BasePtr, TotalSize, Position)",
    "UT_EntryKey_t",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "size_t / <stddef.h> typedef"
  ],
  "explanation": "1) UT_GetStubEntry \u2014 provide the function prototype/definition so the analyser can check for any compiler-specific language extensions on the function itself (e.g. __attribute__, __declspec, calling-convention keywords, inline/asm extensions, macros that expand to non-standard constructs). The target calls this symbol, so its declaration may introduce extensions that affect the target.\n\n2) UT_StubTableEntry_t \u2014 provide the complete struct/union definition for the stub table entry. The target dereferences StubPtr and accesses StubPtr->Data.Buff; to determine whether anonymous structs/unions, flexible array members, bit-fields with non-standard sizes, packed/aligned attributes, or other compiler extensions are in use, the full type definition is required.\n\n3) (inner) Buff member type / fields (BasePtr, TotalSize, Position) \u2014 if Buff is a separate typedef/inner struct, provide that definition (types of BasePtr, TotalSize, Position). This lets the analyser check for nonstandard field declarations (e.g. bit-field types, unnamed members, attributes on fields, use of compiler extensions for pointer types).\n\n4) UT_EntryKey_t \u2014 provide the typedef/definition of the key type used as the first parameter so the analyser can detect any extension used in its definition (e.g. compiler-specific integer-sized typedefs, enum declarations with attributes, or macros hiding nonstandard constructs).\n\n5) UT_ENTRYTYPE_DATA_BUFFER \u2014 provide the macro/enum value or definition used here. Macros can expand to expressions that use compiler extensions; enums or macros could embed nonstandard constructs that affect the call.\n\n6) size_t / <stddef.h> typedef \u2014 include the standard definition/source of size_t (or the header used) to ensure it is the standard typedef and not replaced by a compiler extension or nonstandard typedef. This rules out surprises where size_t was redefined with extensions.\n\nIncluding these symbols (prototypes and type definitions) is sufficient to determine whether the target function itself uses any language/compiler extensions (either directly or via the types/callees it relies on)."
}