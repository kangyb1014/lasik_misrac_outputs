{
  "user_message": "An agent A claimed that the following UT_GetDataBuffer code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetDataBuffer.\n```c\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf StubPtr->Data.Buff.Position is greater than StubPtr->Data.Buff.TotalSize (e.g. due to prior corruption or a logic bug), the expression TotalSize - Position will underflow producing a very large ActualCopy. Even though ActualCopy is later limited by MaxSize, the initial underflow can make memcpy() copy more bytes than the destination buffer can hold, causing an out-of-bounds access. There is no explicit check that Position <= TotalSize before the subtraction, so an out-of-bounds write is possible.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- UT_GetDataBuffer probe @ 1756100165 ---\nStubPtr: 0x55b51ed548e0\nResultDataBuffer: 0x55b51ed3dae0\nResultMaxSize: 32768\nResultPosition: 0\nComputed (signed) MaxSize - Position = 32768\nComputed (unsigned) MaxSize - Position = 32768\nWill write to output pointers (DataBuffer/MaxSize/Position) if non-NULL.\n--- end probe ---\n\n--- UT_GetDataBuffer probe @ 1756100165 ---\nStubPtr: 0x55b51ed548e0\nResultDataBuffer: 0x55b51ed3dae0\nResultMaxSize: 32768\nResultPosition: 0\nComputed (signed) MaxSize - Position = 32768\nComputed (unsigned) MaxSize - Position = 32768\nWill write to output pointers (DataBuffer/MaxSize/Position) if non-NULL.\n--- end probe ---\n\n--- UT_GetDataBuffer probe @ 1756100165 ---\nStubPtr: 0x55b51ed4b100\nResultDataBuffer: 0x55b51ed3dae0\nResultMaxSize: 32768\nResultPosition: 0\nComputed (signed) MaxSize - Position = 32768\nComputed (unsigned) MaxSize - Position = 32768\nWill write to output pointers (DataBuffer/MaxSize/Position) if non-NULL.\n--- end probe ---\n\n--- UT_GetDataBuffer probe @ 1756100165 ---\nStubPtr: 0x55b51ed548e0\nResultDataBuffer: 0x55b51ed3dae0\nResultMaxSize: 32768\nResultPosition: 0\nComputed (signed) MaxSize - Position = 32768\nComputed (unsigned) MaxSize - Position = 32768\nWill write to output pointers (DataBuffer/MaxSize/Position) if non-NULL.\n--- end probe ---\n\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_GetDataBuffer:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n...\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n...\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionString(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionString), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionCodeName(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionCodeName), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. UT_GetDataBuffer itself does not call any <string.h> functions (memcpy, etc.) and therefore cannot directly violate MISRA C 2023 Rule 21.17. Agent A\u2019s scenario correctly describes a real class of problem in the codebase \u2014 an underflow when computing ActualCopy = TotalSize - Position followed by an unguarded memcpy can produce out\u2011of\u2011bounds accesses \u2014 but that problem occurs in the functions that actually perform the memcpy (e.g. UT_Stub_CopyFromLocal, UT_Stub_CopyToLocal, UT_Stub_CopyToReturnValue), not in UT_GetDataBuffer. In short: the underlying defect (missing check that Position <= TotalSize before the subtraction) can indeed lead to a Rule 21.17 violation where memcpy is used, but the attribution to UT_GetDataBuffer is incorrect. Recommended remediation: in each function that computes TotalSize - Position, first ensure Position <= TotalSize (or treat Position >= TotalSize as ActualCopy = 0) before performing the subtraction and the subsequent memcpy."
}