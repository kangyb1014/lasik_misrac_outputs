{
  "user_message": "Target function code is:\n```c\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_GetDataBuffer': {'callees': ['UT_GetStubEntry'], 'callers': ['UT_DefaultHandler_OS_GetVersionString', 'UT_DefaultHandler_OS_GetVersionCodeName']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_DefaultHandler_OS_GetVersionString': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionCodeName': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t (definition)",
    "UT_StubTableEntry_t::Data.Buff.BasePtr (declaration/type)",
    "UT_StubTableEntry_t::Data.Buff.TotalSize (declaration/type)",
    "UT_StubTableEntry_t::Data.Buff.Position (declaration/type)",
    "UT_GetStubEntry (prototype/definition)",
    "UT_SetDataBuffer (prototype)",
    "UT_Stub_CopyToReturnValue (prototype)",
    "UT_Stub_CopyFromLocal (prototype)",
    "UT_Stub_CopyToLocal (prototype)",
    "UT_DefaultHandler_OS_GetVersionString (prototype)",
    "UT_DefaultHandler_OS_GetVersionCodeName (prototype)",
    "UT_EntryKey_t (typedef)"
  ],
  "explanation": "For MISRA guidance about adding const where possible we need the declarations that determine whether the buffer pointer is intended to refer to mutable or immutable data and how it is used elsewhere:\n\n- UT_StubTableEntry_t (definition): shows the full stub table layout and whether the Data union/struct and its members are declared with const or not. This is the primary symbol that determines if BasePtr could/should be const-qualified.\n- UT_StubTableEntry_t::Data.Buff.BasePtr (declaration/type): the exact type of BasePtr (void *, const void *, or another pointer type) is essential to judge if a const qualification is missing.\n- UT_StubTableEntry_t::Data.Buff.TotalSize (declaration/type): confirms the semantics/units of the buffer and helps determine whether operations on the buffer mutate contents or just observe length (context for constness).\n- UT_StubTableEntry_t::Data.Buff.Position (declaration/type): shows whether position is tracked separately (helps infer mutability patterns for the buffer contents vs metadata).\n- UT_GetStubEntry (prototype/definition): confirms the return type (pointer vs pointer-to-const) and any const annotations on the returned pointer which influence how callers should treat the pointed data.\n- UT_SetDataBuffer (prototype): this function likely sets BasePtr; its parameter types (const void * vs void *) indicate intended mutability of the stored pointer.\n- UT_Stub_CopyToReturnValue (prototype): used by callers of UT_GetDataBuffer; its parameter constness shows whether copying from the buffer is read-only (supports const) or may modify source data.\n- UT_Stub_CopyFromLocal (prototype): if this writes into the stub buffer, its signature reveals whether the stub buffer is intended to be mutated (implying BasePtr should remain non-const).\n- UT_Stub_CopyToLocal (prototype): same rationale as CopyFromLocal \u2014 shows whether data is read-only or written-to when interacting with the stored buffer.\n- UT_DefaultHandler_OS_GetVersionString (prototype): a caller of UT_GetDataBuffer; its parameter/usage of the returned DataBuffer (const or non-const) indicates whether callers expect to modify the pointed-to data.\n- UT_DefaultHandler_OS_GetVersionCodeName (prototype): same as above \u2014 inspect how that caller treats the buffer to infer intended constness.\n- UT_EntryKey_t (typedef): ensures correct interpretation of the key type (not directly const-related but needed to locate the right stub entry/type and understand usage contexts).\n\nCollecting these symbols lets the analyzer determine (a) the declared constness of the stored pointer, (b) whether setter/getter/copy helpers treat the pointed data as mutable, and (c) whether callers mutate or only read the buffer \u2014 all required to decide if the function should return a pointer-to-const (or accept a const-qualified pointer) to comply with MISRA's \"pointer should point to const whenever possible\" rule."
}