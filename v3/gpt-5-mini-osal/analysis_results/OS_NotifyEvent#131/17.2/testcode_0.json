{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nViolation is possible: OS_ObjectIdAllocateNew calls OS_NotifyEvent, which invokes the function pointer OS_SharedGlobalVars.EventHandler. If that EventHandler implementation calls back into OS_ObjectIdAllocateNew (or any function that eventually calls OS_NotifyEvent again), an indirect recursive cycle occurs (e.g. OS_ObjectIdAllocateNew -> OS_NotifyEvent -> EventHandler -> OS_ObjectIdAllocateNew). Other callers of OS_NotifyEvent (e.g. OS_ObjectIdFinalizeNew, OS_ObjectIdFinalizeDelete, OS_TaskPrepare) create the same potential for indirect recursion if the callback invokes the original caller.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_NotifyEvent code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1316.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_NotifyEvent as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_NotifyEvent:\n```c\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    if (OS_SharedGlobalVars.EventHandler != NULL)\n    {\n        status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    return status;\n}\n```\n</target_code>\nPlease provide the modified OS_NotifyEvent code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n\n/* Probe/logger helper for OS_NotifyEvent.\n * Appends structured logs to /tmp/logs/1316.txt describing control flow\n * and state (event, object_id, data pointer, handler presence/address, status).\n * This preserves original behavior and only records information.\n */\nstatic void OS_NotifyEvent_Log(const char *stage,\n                               OS_Event_t event,\n                               osal_id_t object_id,\n                               void *data,\n                               int handler_present,\n                               unsigned long long handler_addr,\n                               int32 status)\n{\n    FILE *f = fopen(\"/tmp/logs/1316.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t t = time(NULL);\n        /* Print a compact, single-line record for easy parsing by other agents. */\n        fprintf(f, \"%ld %s event=%llu object_id=%llu data=%p handler_present=%d handler_addr=0x%llx status=%d\\n\",\n                (long)t,\n                stage,\n                (unsigned long long)event,\n                (unsigned long long)object_id,\n                data,\n                handler_present,\n                handler_addr,\n                status);\n        fclose(f);\n    }\n}\n\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    /* Capture the handler pointer locally to log its presence/address without\n     * changing the invocation semantics. Do not change the original call path. */\n    int32 (*handler)(OS_Event_t, osal_id_t, void *) = OS_SharedGlobalVars.EventHandler;\n    int handler_present = (handler != NULL) ? 1 : 0;\n    /* Convert function pointer to integer for logging. This is only for diagnostics. */\n    unsigned long long handler_addr = (unsigned long long)(uintptr_t)handler;\n\n    /* Log entry and observed state before invoking the handler. */\n    OS_NotifyEvent_Log(\"ENTRY\", event, object_id, data, handler_present, handler_addr, 0);\n\n    if (handler != NULL)\n    {\n        /* Preserve original behavior: call through the function pointer. */\n        status = handler(event, object_id, data);\n\n        /* Log the result immediately after the handler returns. This helps trace\n         * whether the handler called back into functions that eventually re-enter\n         * OS_NotifyEvent (evidence would show nested ENTRY/AFTER_HANDLER records). */\n        OS_NotifyEvent_Log(\"AFTER_HANDLER\", event, object_id, data, handler_present, handler_addr, status);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n        OS_NotifyEvent_Log(\"NO_HANDLER\", event, object_id, data, handler_present, handler_addr, status);\n    }\n\n    /* Final exit log for this invocation. */\n    OS_NotifyEvent_Log(\"EXIT\", event, object_id, data, handler_present, handler_addr, status);\n\n    return status;\n}\n"
}