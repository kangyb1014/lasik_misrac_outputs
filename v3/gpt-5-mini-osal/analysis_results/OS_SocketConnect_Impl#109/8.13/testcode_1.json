{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe pointer 'impl' is declared as a non-const pointer (OS_impl_file_internal_record_t *impl) but is only used to read members (impl->fd and impl->selectable). It could and should be declared as a pointer to const (const OS_impl_file_internal_record_t *impl) to indicate no modification and satisfy MISRA C 2023 Rule 8.13. Therefore the rule is violated in this code fragment.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SocketConnect_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1093.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SocketConnect_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SocketConnect_Impl:\n```c\nint32 OS_SocketConnect_Impl(const OS_object_token_t *token, const OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    int                             os_status;\n    int                             sockopt;\n    socklen_t                       slen;\n    uint32                          operation;\n    const struct sockaddr *         sa;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    sa = (const struct sockaddr *)&Addr->AddrData;\n    switch (sa->sa_family)\n    {\n        case AF_INET:\n            slen = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            slen = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            slen = 0;\n            break;\n    }\n\n    if (slen != Addr->ActualLength)\n    {\n        return_code = OS_ERR_BAD_ADDRESS;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n        os_status   = connect(impl->fd, sa, slen);\n        if (os_status < 0)\n        {\n            if (errno != EINPROGRESS)\n            {\n                OS_DEBUG(\"connect: %s\\n\", strerror(errno));\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                /*\n                 * If the socket was created in nonblocking mode (O_NONBLOCK flag) then the connect\n                 * runs in the background and connect() returns EINPROGRESS.  In this case we still\n                 * want to provide the \"normal\" (blocking) semantics to the calling app, such that\n                 * when OS_SocketConnect() returns, the socket is ready for use.\n                 *\n                 * To provide consistent behavior to calling apps, this does a select() to wait\n                 * for the socket to become writable, meaning that the remote side is connected.\n                 *\n                 * An important point here is that the calling app can control the timeout.  If the\n                 * normal/blocking connect() was used, the OS/IP stack controls the timeout, and it\n                 * can be quite long.\n                 */\n                operation = OS_STREAM_STATE_WRITABLE;\n                if (impl->selectable)\n                {\n                    return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n                }\n                if (return_code == OS_SUCCESS)\n                {\n                    if ((operation & OS_STREAM_STATE_WRITABLE) == 0)\n                    {\n                        return_code = OS_ERROR_TIMEOUT;\n                    }\n                    else\n                    {\n                        /*\n                         * The SO_ERROR socket flag should also read back zero.\n                         * If not zero, something went wrong during connect\n                         */\n                        sockopt   = 0;\n                        slen      = sizeof(sockopt);\n                        os_status = getsockopt(impl->fd, SOL_SOCKET, SO_ERROR, &sockopt, &slen);\n                        if (os_status < 0 || sockopt != 0)\n                        {\n                            return_code = OS_ERROR;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SocketConnect_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Probe / logging helper. Accepts a const pointer to avoid modifying impl. */\nstatic void OS_SocketConnect_Impl_log_state(const void *impl_void,\n                                            const struct sockaddr *sa,\n                                            socklen_t slen,\n                                            const void *addr_void,\n                                            int os_status,\n                                            int sockopt,\n                                            uint32_t operation,\n                                            int return_code,\n                                            const char *note)\n{\n    FILE *fp = NULL;\n\n    /* Try to ensure the directory exists; ignore errors except EEXIST. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    fp = fopen(\"/tmp/logs/1093.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    {\n        time_t t = time(NULL);\n        char buf[64];\n        struct tm tmv;\n        if (t != (time_t)-1 && localtime_r(&t, &tmv) != NULL)\n        {\n            (void)strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tmv);\n        }\n        else\n        {\n            strncpy(buf, \"unknown-time\", sizeof(buf));\n            buf[sizeof(buf)-1] = '\\0';\n        }\n\n        fprintf(fp, \"[%s] OS_SocketConnect_Impl: %s\\n\", buf, note ? note : \"\");\n        fprintf(fp, \"  impl_ptr=%p, addr_ptr=%p, sa_ptr=%p\\n\", impl_void, addr_void, sa);\n        if (sa != NULL)\n        {\n            fprintf(fp, \"  sa_family=%d, slen=%lu\\n\", (int)sa->sa_family, (unsigned long)slen);\n        }\n        fprintf(fp, \"  os_status=%d, sockopt=%d, operation=0x%08x, return_code=%d\\n\",\n                os_status, sockopt, (unsigned int)operation, return_code);\n        if (errno != 0)\n        {\n            fprintf(fp, \"  errno=%d (%s)\\n\", errno, strerror(errno));\n        }\n        fprintf(fp, \"\\n\");\n    }\n\n    fclose(fp);\n}\n\nint32 OS_SocketConnect_Impl(const OS_object_token_t *token, const OS_SockAddr_t *Addr, int32 timeout)\n{\n    int32                           return_code;\n    int                             os_status;\n    int                             sockopt;\n    socklen_t                       slen;\n    uint32                          operation;\n    const struct sockaddr *         sa;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    sa = (const struct sockaddr *)&Addr->AddrData;\n    switch (sa->sa_family)\n    {\n        case AF_INET:\n            slen = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            slen = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            slen = 0;\n            break;\n    }\n\n    /* Log initial state after determining slen */\n    OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                    0, 0, 0, 0, \"after computing slen\");\n\n    if (slen != Addr->ActualLength)\n    {\n        return_code = OS_ERR_BAD_ADDRESS;\n\n        /* Log the mismatch and early return */\n        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                        0, 0, 0, return_code, \"slen != Addr->ActualLength -> early return\");\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n        /* Log before calling connect */\n        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                        0, 0, 0, return_code, \"about to call connect\");\n\n        os_status   = connect(impl->fd, sa, slen);\n\n        /* Log immediately after connect */\n        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                        os_status, 0, 0, return_code, \"after connect call\");\n\n        if (os_status < 0)\n        {\n            if (errno != EINPROGRESS)\n            {\n                OS_DEBUG(\"connect: %s\\n\", strerror(errno));\n                return_code = OS_ERROR;\n\n                /* Log the error path (connect failed immediately) */\n                OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                os_status, 0, 0, return_code, \"connect failed (not EINPROGRESS)\");\n            }\n            else\n            {\n                /*\n                 * If the socket was created in nonblocking mode (O_NONBLOCK flag) then the connect\n                 * runs in the background and connect() returns EINPROGRESS.  In this case we still\n                 * want to provide the \"normal\" (blocking) semantics to the calling app, such that\n                 * when OS_SocketConnect() returns, the socket is ready for use.\n                 *\n                 * To provide consistent behavior to calling apps, this does a select() to wait\n                 * for the socket to become writable, meaning that the remote side is connected.\n                 *\n                 * An important point here is that the calling app can control the timeout.  If the\n                 * normal/blocking connect() was used, the OS/IP stack controls the timeout, and it\n                 * can be quite long.\n                 */\n                operation = OS_STREAM_STATE_WRITABLE;\n\n                /* Log that we hit EINPROGRESS path and show selectable state */\n                OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                os_status, 0, operation, return_code, \"connect returned EINPROGRESS\");\n\n                if (impl->selectable)\n                {\n                    /* Log before calling select implementation */\n                    OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                    os_status, 0, operation, return_code, \"calling OS_SelectSingle_Impl\");\n\n                    return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n\n                    /* Log after calling select implementation */\n                    OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                    os_status, 0, operation, return_code, \"returned from OS_SelectSingle_Impl\");\n                }\n                if (return_code == OS_SUCCESS)\n                {\n                    if ((operation & OS_STREAM_STATE_WRITABLE) == 0)\n                    {\n                        return_code = OS_ERROR_TIMEOUT;\n\n                        /* Log timeout condition */\n                        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                        os_status, 0, operation, return_code, \"select returned but not writable -> timeout\");\n                    }\n                    else\n                    {\n                        /*\n                         * The SO_ERROR socket flag should also read back zero.\n                         * If not zero, something went wrong during connect\n                         */\n                        sockopt   = 0;\n                        slen      = sizeof(sockopt);\n\n                        /* Log before getsockopt */\n                        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                        os_status, sockopt, operation, return_code, \"about to call getsockopt\");\n\n                        os_status = getsockopt(impl->fd, SOL_SOCKET, SO_ERROR, &sockopt, &slen);\n\n                        /* Log after getsockopt */\n                        OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                        os_status, sockopt, operation, return_code, \"after getsockopt\");\n\n                        if (os_status < 0 || sockopt != 0)\n                        {\n                            return_code = OS_ERROR;\n\n                            /* Log the failure of final socket error check */\n                            OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                                            os_status, sockopt, operation, return_code, \"getsockopt indicated error\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /* Final state log before returning */\n    OS_SocketConnect_Impl_log_state((const void *)impl, sa, slen, (const void *)Addr,\n                                    0, 0, 0, return_code, \"final return\");\n\n    return return_code;\n}\n"
}