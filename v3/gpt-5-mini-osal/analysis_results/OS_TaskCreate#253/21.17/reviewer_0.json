{
  "user_message": "An agent A claimed that the following OS_TaskCreate code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskCreate.\n```c\nint32 OS_TaskCreate(osal_id_t *task_id, const char *task_name, osal_task_entry function_pointer,\n                    osal_stackptr_t stack_pointer, size_t stack_size, osal_priority_t priority, uint32 flags)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /*\n     * Check parameters\n     *\n     * Note \"stack_pointer\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(function_pointer);\n    OS_CHECK_APINAME(task_name);\n    OS_CHECK_SIZE(stack_size);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, task_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, task, task_name, task_name);\n\n        task->stack_size             = stack_size;\n        task->priority               = priority;\n        task->entry_function_pointer = function_pointer;\n        task->stack_pointer          = stack_pointer;\n\n        /* Add default flags */\n        flags |= OS_ADD_TASK_FLAGS;\n\n        /* Now call the OS-specific implementation.  This reads info from the task table. */\n        return_code = OS_TaskCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, task_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nOS_CHECK_APINAME expands to OS_CHECK_STRING(str, OS_MAX_API_NAME, ...). If that macro uses string.h functions unbounded (for example strlen) to check the length, or if the caller passes task_name pointing to a char buffer that is not NUL-terminated within its allocated size, the string function will read past the end of the object. In addition OS_OBJECT_INIT uses strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1) which will copy up to that many bytes from nameval and also can read beyond the source if it is not NUL-terminated. Example violation: caller provides a 20-byte buffer filled with non-zero bytes (no terminating '\\0'); OS_CHECK_APINAME calling strlen(name) will over-read the buffer (and strncpy later may also read out-of-bounds), thus violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01248 | task_name=(nil) | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e11380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e0124c | task_name=0x560b65de5da7 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e19380 | stack_size=0 | priority=111 | flags=0x00000000 | return_code=-1\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01250 | task_name=0x560b66051db0 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e21380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01240 | task_name=0x7ffc8dd971d0 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e01380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd97180 | task_name_ptr=0x7ffc8dd971d0\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x7ffc8dd971d0\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e0125c | task_name=0x560b65de5de3 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e39380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd97180 | task_name_ptr=0x560b65de5de3\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5de3\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01264 | task_name=0x560b65de5e00 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e49380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd97180 | task_name_ptr=0x560b65de5e00\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5e00\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01260 | task_name=0x560b65de5df3 | function_ptr=0x560b65db9868 | stack_ptr=(nil) | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd97180 | task_name_ptr=0x560b65de5df3\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5df3\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e0124c | task_name=0x560b65de5e39 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e19380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd971c0 | task_name_ptr=0x560b65de5e39\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5e39\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01250 | task_name=0x560b65de5eff | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e21380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd971c0 | task_name_ptr=0x560b65de5eff\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5eff\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01244 | task_name=0x560b65de5f5e | function_ptr=0x560b65dbb4ff | stack_ptr=0x560b65e09380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd971a0 | task_name_ptr=0x560b65de5f5e\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5f5e\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01254 | task_name=0x560b65de5fd2 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e29380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd971a0 | task_name_ptr=0x560b65de5fd2\nOS_ObjectIdAllocateNew failed early: return_code=-35 | task_name_ptr=0x560b65de5fd2\nSTAGE=before_OS_CHECK_APINAME | task_id=0x560b65e01248 | task_name=0x560b65de6004 | function_ptr=0x560b65db9868 | stack_ptr=0x560b65e11380 | stack_size=32768 | priority=111 | flags=0x00000000 | return_code=-1\nAfter OS_ObjectIdAllocateNew: return_code=-35 | token_addr=0x7ffc8dd97190 | task_name_ptr=0x560b65\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskCreate:\n#define OS_OBJECT_INIT(tok, ref, namefield, nameval) {memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\ntypedef struct\n{\n    char            task_name[OS_MAX_API_NAME];\n    size_t          stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_task_entry delete_hook_pointer;\n    void *          entry_arg;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t\n...\nOS_task_internal_record_t OS_task_table[LOCAL_NUM_OBJECTS]\n...\n#define OS_CHECK_APINAME(str) OS_CHECK_STRING(str,OS_MAX_API_NAME,OS_ERR_NAME_TOO_LONG)\n...\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n...\nint32 OS_TaskCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    OS_VoidPtrValueWrapper_t        arg;\n    int32                           return_code;\n    OS_impl_task_internal_record_t *impl;\n    OS_task_internal_record_t *     task;\n\n    memset(&arg, 0, sizeof(arg));\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    arg.id = OS_ObjectIdFromToken(token);\n\n    task = OS_OBJECT_TABLE_GET(OS_task_table, *token);\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    return_code = OS_Posix_InternalTaskCreate_Impl(&impl->id, task->priority, task->stack_size, OS_PthreadTaskEntry,\n                                                   arg.opaque_arg);\n\n    return return_code;\n}\n...\n#define OS_MAX_API_NAME 20\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in principle: the shown code can lead to a MISRA C:2023 Rule 21.17 violation unless the prior checks guarantee the source buffer is NUL-terminated within the expected bounds. Concretely:\n\n- OS_OBJECT_INIT invokes strncpy(ref->namefield, nameval, sizeof(ref->namefield) - 1). strncpy will read up to the specified number of bytes from nameval. If nameval does not contain a NUL within that many bytes and/or the actual object referred to by nameval is smaller than that many bytes, the call can read beyond the bounds of the object pointed to by nameval \u2014 exactly the kind of out-of-bounds read that Rule 21.17 forbids.\n\n- The code does call OS_CHECK_APINAME(task_name) beforehand (expanded from OS_CHECK_STRING(...)). Whether that prevents an out-of-bounds read depends entirely on the implementation of OS_CHECK_STRING. If OS_CHECK_STRING uses an unbounded string function such as strlen(name) (or any other unbounded search for NUL), that itself can read past the end of the object and violate Rule 21.17. If OS_CHECK_STRING instead performs a bounded length check (for example using a strnlen-like approach limited to OS_MAX_API_NAME) or otherwise ensures a NUL is present within the allowed length, then the subsequent strncpy is safe and there is no Rule 21.17 violation.\n\nBecause the provided code shows strncpy usage that can over-read unless a safe, bounded check was performed earlier, Agent A's scenario describing a potential MISRA 21.17 violation is valid. The code as shown is therefore potentially non-conforming; compliance depends on the (unseen) implementation of OS_CHECK_STRING/OS_CHECK_APINAME and on the API contract requiring callers to supply a properly-terminated buffer.\n\nRecommendation: Ensure OS_CHECK_STRING is implemented using a bounded NUL search (e.g., strnlen or memchr limited to the maximum allowed length) or otherwise guarantees the source contains a NUL within OS_MAX_API_NAME bytes before any strncpy; alternatively use safer copying that does not read past the source object size (or require a length parameter). Also consider copying exactly sizeof(namefield) and explicitly NUL-terminating the destination to avoid subtle issues."
}