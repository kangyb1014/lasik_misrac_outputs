{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nYes. The macro is defined as 0 and is used in OS_TaskCreate where the code executes flags |= OS_ADD_TASK_FLAGS; since OS_ADD_TASK_FLAGS expands to 0 this is a runtime no-op. The executed operation has no effect and could be removed without changing program behaviour, which constitutes dead code under MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskCreate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2532.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskCreate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskCreate:\n```c\nint32 OS_TaskCreate(osal_id_t *task_id, const char *task_name, osal_task_entry function_pointer,\n                    osal_stackptr_t stack_pointer, size_t stack_size, osal_priority_t priority, uint32 flags)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /*\n     * Check parameters\n     *\n     * Note \"stack_pointer\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(function_pointer);\n    OS_CHECK_APINAME(task_name);\n    OS_CHECK_SIZE(stack_size);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, task_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, task, task_name, task_name);\n\n        task->stack_size             = stack_size;\n        task->priority               = priority;\n        task->entry_function_pointer = function_pointer;\n        task->stack_pointer          = stack_pointer;\n\n        /* Add default flags */\n        flags |= OS_ADD_TASK_FLAGS;\n\n        /* Now call the OS-specific implementation.  This reads info from the task table. */\n        return_code = OS_TaskCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, task_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskCreate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Minimal typedefs and stub implementations so this file is self-contained and compilable.\n   These are stubs only to allow compilation of the modified OS_TaskCreate function and\n   to permit the inserted probes to run in a test harness. They intentionally avoid\n   changing the tested logic in OS_TaskCreate. */\n\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef uint32_t osal_id_t;\ntypedef void (*osal_task_entry)(void);\ntypedef void *osal_stackptr_t;\ntypedef uint32_t osal_priority_t;\n\ntypedef struct\n{\n    uint32 value;\n} OS_object_token_t;\n\ntypedef struct\n{\n    char name[32];\n    size_t stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t;\n\n/* Constants implemented as variables (not macros) to avoid defining macros in this test code. */\nstatic const int LOCAL_OBJID_TYPE = 1;\nstatic const int32 OS_SUCCESS = 0;\nstatic const uint32 OS_ADD_TASK_FLAGS = 0u; /* Simulate the reported scenario where this is effectively zero */\n\n/* Minimal object table for the stubbed OS_OBJECT_TABLE_GET implementation. */\nstatic OS_task_internal_record_t OS_task_table[4];\n\n/* Stub implementations of OS support routines. In a real build these would be provided\n   by the OSAL. They are simplified here to keep the file self-contained. */\nstatic int32 OS_ObjectIdAllocateNew(int type, const char *name, OS_object_token_t *token)\n{\n    (void)type;\n    (void)name;\n    if (token)\n    {\n        token->value = 1u; /* stub token value */\n    }\n    return OS_SUCCESS;\n}\n\nstatic OS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token)\n{\n    (void)token;\n    /* return the first entry for the sake of this test */\n    return &table[0];\n}\n\nstatic void OS_OBJECT_INIT(OS_object_token_t token, OS_task_internal_record_t *task, const char *name1, const char *name2)\n{\n    (void)token;\n    (void)name2;\n    if (task && name1)\n    {\n        strncpy(task->name, name1, sizeof(task->name) - 1);\n        task->name[sizeof(task->name) - 1] = '\\0';\n    }\n}\n\nstatic int32 OS_TaskCreate_Impl(OS_object_token_t *token, uint32 flags)\n{\n    (void)token;\n    (void)flags;\n    /* stub implementation returns success */\n    return OS_SUCCESS;\n}\n\nstatic int32 OS_ObjectIdFinalizeNew(int32 in_rc, OS_object_token_t *token, osal_id_t *task_id)\n{\n    if ((in_rc == OS_SUCCESS) && token && task_id)\n    {\n        *task_id = (osal_id_t)token->value;\n    }\n    return in_rc;\n}\n\n/* API check stubs - real implementations would validate and possibly return error codes.\n   Here they are implemented as no-ops to preserve control flow in this test harness. */\nstatic void OS_CHECK_POINTER(const void *p)\n{\n    (void)p;\n}\nstatic void OS_CHECK_APINAME(const char *name)\n{\n    (void)name;\n}\nstatic void OS_CHECK_SIZE(size_t s)\n{\n    (void)s;\n}\n\n/* Probe/logging utility: append human-readable logs about control flow and key state\n   to the specified file so other agents can reproduce and collect evidence of the\n   reported no-op (dead code) scenario. */\nstatic void OS_TaskCreate_Log(const char *stage, const char *task_name, uint32 flags_before, uint32 flags_after, int32 return_code, OS_object_token_t token)\n{\n    FILE *f = fopen(\"/tmp/logs/2532.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    fprintf(f, \"OS_TaskCreate: stage=%s name=%s token=0x%08x return_code=%d flags_before=0x%08x flags_after=0x%08x\\n\",\n            stage,\n            (task_name != NULL) ? task_name : \"(null)\",\n            (unsigned)token.value,\n            (int)return_code,\n            (unsigned)flags_before,\n            (unsigned)flags_after);\n\n    if (flags_before == flags_after)\n    {\n        fprintf(f, \"Note: flags |= OS_ADD_TASK_FLAGS had no effect (no-op). This is evidence that the operation executed but did not change state.\\n\");\n    }\n\n    fclose(f);\n}\n\n/* Modified OS_TaskCreate with inserted probes/logging. Original logic is preserved as much as\n   possible; only logging calls and a minimal pre/post snapshot around the 'flags |= OS_ADD_TASK_FLAGS' line\n   are added to capture the reported no-op behavior. */\nint32 OS_TaskCreate(osal_id_t *task_id, const char *task_name, osal_task_entry function_pointer,\n                    osal_stackptr_t stack_pointer, size_t stack_size, osal_priority_t priority, uint32 flags)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Check parameters (no-ops in this test harness) */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(function_pointer);\n    OS_CHECK_APINAME(task_name);\n    OS_CHECK_SIZE(stack_size);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, task_name, &token);\n\n    /* Log after allocation attempt */\n    OS_TaskCreate_Log(\"after_allocate\", task_name, flags, flags, return_code, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, task, task_name, task_name);\n\n        task->stack_size             = stack_size;\n        task->priority               = priority;\n        task->entry_function_pointer = function_pointer;\n        task->stack_pointer          = stack_pointer;\n\n        /* Add default flags */\n        uint32 flags_before = flags;\n\n        /* --- PROBE: capture state immediately before the flagged operation --- */\n        OS_TaskCreate_Log(\"before_flags_or\", task_name, flags_before, flags_before, return_code, token);\n\n        flags |= OS_ADD_TASK_FLAGS; /* This is the operation reported to be a runtime no-op */\n\n        uint32 flags_after = flags;\n        /* --- PROBE: capture state immediately after the flagged operation --- */\n        OS_TaskCreate_Log(\"after_flags_or\", task_name, flags_before, flags_after, return_code, token);\n\n        /* Now call the OS-specific implementation.  This reads info from the task table. */\n        return_code = OS_TaskCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, task_id);\n\n        /* Final log before returning */\n        OS_TaskCreate_Log(\"final\", task_name, flags_before, flags_after, return_code, token);\n    }\n\n    return return_code;\n}\n"
}