{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local pointer 'de' is declared as 'struct dirent *de' but is only used for reading the returned directory entry (de->d_name is read and copied); it could be declared as 'const struct dirent *de' and assigned the result of readdir(). Declaring it const would satisfy MISRA C 2023 Rule 8.13. Thus the current declaration violates Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryRead code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1513.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryRead as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryRead:\n```c\nint32 OS_DirectoryRead(osal_id_t dir_id, os_dirent_t *dirent)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dirent);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * Call the underlying implementation to perform the read\n         *\n         * NOTE: This does not map \"virtual mount points\" that\n         * may appear in the dir listing back to the virtualized\n         * name.  For instance, if the (real) /eeprom directory\n         * is virtualized to /cf via the OS_VolumeTable, and one\n         * reads the \"/\" directory, the application will see the\n         * real name (eeprom) and not the virtualized name (cf).\n         */\n        return_code = OS_DirRead_Impl(&token, dirent);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryRead code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n\n/* Probe logging helper - append-only log for reproducing the scenario.\n * Writes timestamps and messages to /tmp/logs/1513.txt\n */\nstatic void OS_ProbeLog(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1513.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n\n    /* Use localtime_r if available for thread-safety; fall back otherwise */\n#if defined(_POSIX_THREAD_SAFE_FUNCTIONS)\n    (void)localtime_r(&t, &tm_buf);\n#else\n    {\n        struct tm *tmp = localtime(&t);\n        if (tmp != NULL)\n        {\n            tm_buf = *tmp;\n        }\n        else\n        {\n            memset(&tm_buf, 0, sizeof(tm_buf));\n        }\n    }\n#endif\n\n    fprintf(fp, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n            tm_buf.tm_year + 1900,\n            tm_buf.tm_mon + 1,\n            tm_buf.tm_mday,\n            tm_buf.tm_hour,\n            tm_buf.tm_min,\n            tm_buf.tm_sec);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\n/* Hex dump helper for a region of memory. Limits to max_bytes to avoid huge logs. */\nstatic void OS_ProbeHexDump(const void *ptr, size_t total_size, size_t max_bytes)\n{\n    const unsigned char *p = (const unsigned char *)ptr;\n    size_t i, bytes = (total_size < max_bytes) ? total_size : max_bytes;\n\n    if (p == NULL)\n    {\n        OS_ProbeLog(\"HexDump: NULL pointer\");\n        return;\n    }\n\n    /* Build a single-line hex representation */\n    char buf[3 * 128 + 1]; /* enough for 128 bytes */\n    size_t pos = 0;\n\n    if (bytes > 128) bytes = 128; /* safety cap for buffer */\n\n    for (i = 0; i < bytes; ++i)\n    {\n        if (pos + 3 >= sizeof(buf)) break;\n        int n = snprintf(&buf[pos], sizeof(buf) - pos, \"%02X \", p[i]);\n        if (n < 0) break;\n        pos += (size_t)n;\n    }\n    buf[pos] = '\\0';\n\n    OS_ProbeLog(\"HexDump (%zu bytes shown): %s\", bytes, buf);\n}\n\n/*\n * Modified OS_DirectoryRead: preserves original logic but inserts probes to log\n * control flow and the state of the dirent buffer before/after the underlying\n * implementation call. This provides evidence that the directory entry is read\n * (i.e. treated as read-only) and supports investigating the MISRA Rule 8.13\n * scenario reported by other agents.\n */\nint32 OS_DirectoryRead(osal_id_t dir_id, os_dirent_t *dirent)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and parameters */\n    OS_ProbeLog(\"OS_DirectoryRead ENTRY: dir_id=%lu dirent_ptr=%p\",\n                (unsigned long)(uintptr_t)dir_id,\n                (void *)dirent);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dirent);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, dir_id, &token);\n    OS_ProbeLog(\"OS_ObjectIdGetById returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token info (address) */\n        OS_ProbeLog(\"Token address: %p\", (void *)&token);\n\n        /* Dump the first bytes of the dirent structure before the impl call.\n         * This helps demonstrate that the buffer is only read from by the\n         * implementation (showing the state transition).\n         */\n        OS_ProbeLog(\"dirent buffer BEFORE OS_DirRead_Impl (snapshot):\");\n        OS_ProbeHexDump((const void *)dirent, sizeof(*dirent), 64);\n\n        /*\n         * Call the underlying implementation to perform the read\n         *\n         * NOTE: This does not map \"virtual mount points\" that\n         * may appear in the dir listing back to the virtualized\n         * name.  For instance, if the (real) /eeprom directory\n         * is virtualized to /cf via the OS_VolumeTable, and one\n         * reads the \"/\" directory, the application will see the\n         * real name (eeprom) and not the virtualized name (cf).\n         */\n        return_code = OS_DirRead_Impl(&token, dirent);\n\n        /* Dump the first bytes of the dirent structure after the impl call.\n         * This shows what the implementation wrote into the buffer; if the\n         * implementation only reads from an internal \"struct dirent *de\"\n         * and copies d_name into this buffer, the logs will show the\n         * populated bytes here and a read-only usage of the internal pointer\n         * can be inferred.\n         */\n        OS_ProbeLog(\"dirent buffer AFTER OS_DirRead_Impl (snapshot): return_code=%d\", (int)return_code);\n        OS_ProbeHexDump((const void *)dirent, sizeof(*dirent), 64);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    OS_ProbeLog(\"OS_DirectoryRead EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n"
}