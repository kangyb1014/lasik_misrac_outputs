{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable 'de' is declared as 'struct dirent *de' but is only read from (used as the source for strncpy). According to Rule 8.13 it should point to a const-qualified type when possible (e.g. 'const struct dirent *de' or 'const char *name = de->d_name') so the source of the copy is const-qualified.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryRead code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1513.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryRead as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryRead:\n```c\nint32 OS_DirectoryRead(osal_id_t dir_id, os_dirent_t *dirent)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dirent);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * Call the underlying implementation to perform the read\n         *\n         * NOTE: This does not map \"virtual mount points\" that\n         * may appear in the dir listing back to the virtualized\n         * name.  For instance, if the (real) /eeprom directory\n         * is virtualized to /cf via the OS_VolumeTable, and one\n         * reads the \"/\" directory, the application will see the\n         * real name (eeprom) and not the virtualized name (cf).\n         */\n        return_code = OS_DirRead_Impl(&token, dirent);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryRead code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Probe helpers: write logs to /tmp/logs/1513.txt. These helpers do not\n * change the behavior of OS_DirectoryRead, they only append diagnostic\n * information for reproducing the reported scenario.\n */\nstatic void OS_DirRead_ProbeLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1513.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Dump up to `len` bytes of the dirent structure (or what caller provided)\n * as hex to aid in determining what fields were set by the implementation.\n */\nstatic void OS_DirRead_ProbeDump(const void *ptr, size_t len)\n{\n    const unsigned char *b = (const unsigned char *)ptr;\n    FILE *f = fopen(\"/tmp/logs/1513.txt\", \"a\");\n    size_t i;\n    if (f == NULL || ptr == NULL)\n    {\n        if (f) fclose(f);\n        return;\n    }\n\n    fprintf(f, \"DUMP %p (%zu bytes):\", ptr, (unsigned long)len);\n    for (i = 0; i < len; ++i)\n    {\n        fprintf(f, \" %02X\", (unsigned int)b[i]);\n        /* limit line length so logs remain readable */\n        if ((i % 16) == 15)\n            fputc('\\n', f);\n    }\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_DirectoryRead(osal_id_t dir_id, os_dirent_t *dirent)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and parameters */\n    OS_DirRead_ProbeLog(\"OS_DirectoryRead ENTER: dir_id=%ld, dirent=%p\", (long)dir_id, (const void *)dirent);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dirent);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, dir_id, &token);\n    OS_DirRead_ProbeLog(\"OS_ObjectIdGetById returned %ld\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token address if possible (token type is opaque here) */\n        OS_DirRead_ProbeLog(\"OS_DirectoryRead: obtained token %p\", (const void *)&token);\n\n        /*\n         * Call the underlying implementation to perform the read\n         *\n         * NOTE: This does not map \"virtual mount points\" that\n         * may appear in the dir listing back to the virtualized\n         * name.  For instance, if the (real) /eeprom directory\n         * is virtualized to /cf via the OS_VolumeTable, and one\n         * reads the \"/\" directory, the application will see the\n         * real name (eeprom) and not the virtualized name (cf).\n         */\n        OS_DirRead_ProbeLog(\"Calling OS_DirRead_Impl with dirent=%p\", (const void *)dirent);\n\n        return_code = OS_DirRead_Impl(&token, dirent);\n\n        OS_DirRead_ProbeLog(\"OS_DirRead_Impl returned %ld\", (long)return_code);\n\n        /* After the implementation call, dump the first bytes of dirent\n         * to capture state that demonstrates whether the structure was\n         * written to (and what bytes were set). This is useful evidence\n         * to determine whether the dirent contents are only read from\n         * by other code (indicating a source pointer could be const).\n         *\n         * Dump a reasonable, bounded amount of memory to avoid large logs.\n         */\n        if (dirent != NULL)\n        {\n            OS_DirRead_ProbeDump((const void *)dirent, 64U);\n        }\n\n        OS_ObjectIdRelease(&token);\n        OS_DirRead_ProbeLog(\"Released token %p\", (const void *)&token);\n    }\n\n    OS_DirRead_ProbeLog(\"OS_DirectoryRead EXIT: return %ld\", (long)return_code);\n\n    return return_code;\n}\n"
}