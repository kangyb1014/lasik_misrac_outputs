{
  "user_message": "An agent A claimed that the following OS_ObjectIdAllocateNew code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdAllocateNew.\n```c\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop uses an invariant controlling expression: while (true). This is not an intended infinite-loop idiom because the loop relies on internal break/return conditions (token->obj_idx >= obj_count and a match) to terminate, so the controlling expression is invariant but not used solely to create an infinite loop. This violates MISRA C 2023 Rule 14.3. Replace with an explicit conditional loop (for example, iterate while token->obj_idx+1 < obj_count or use a for loop) so the controlling expression is not invariant.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[OS_ObjectIdAllocateNew] ENTER: idtype=2, name=0x5600a6313992(Queue A), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] probe_state: stage=After TransactionInit, idtype=2, name=0x5600a6313992(Queue A), token=0x7fff75eb7b60, token->obj_id=0, return_code=-1\n[OS_ObjectIdAllocateNew] TransactionInit failed: return_code=-1 -> returning\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a6313a1e(BinSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] probe_state: stage=After TransactionInit, idtype=4, name=0x5600a6313a1e(BinSem 1), token=0x7fff75eb7b60, token->obj_id=0, return_code=-1\n[OS_ObjectIdAllocateNew] TransactionInit failed: return_code=-1 -> returning\n[OS_ObjectIdAllocateNew] ENTER: idtype=3, name=0x5600a6313a6a(CountSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] probe_state: stage=After TransactionInit, idtype=3, name=0x5600a6313a6a(CountSem 1), token=0x7fff75eb7b60, token->obj_id=0, return_code=-1\n[OS_ObjectIdAllocateNew] TransactionInit failed: return_code=-1 -> returning\n[OS_ObjectIdAllocateNew] ENTER: idtype=5, name=0x5600a6313abe(MutexSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] probe_state: stage=After TransactionInit, idtype=5, name=0x5600a6313abe(MutexSem 1), token=0x7fff75eb7b60, token->obj_id=0, return_code=-1\n[OS_ObjectIdAllocateNew] TransactionInit failed: return_code=-1 -> returning\n[OS_ObjectIdAllocateNew] ENTER: idtype=2, name=0x5600a6313992(Queue A), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a6313a1e(BinSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=3, name=0x5600a6313a6a(CountSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=5, name=0x5600a6313abe(MutexSem 1), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x7fff75eb7b80(BINSEM0), token=0x7fff75eb7ae0\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63131dd(DUPLICATE), token=0x7fff75eb7ae0\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a6313246(Good), token=0x7fff75eb7ae0\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63132e0(DeleteTest), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a631338f(FlushTest), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a631343e(GiveTest), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63134e6(TakeTest), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63135a1(TimedWait), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63135a1(TimedWait), token=0x7fff75eb7b90\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a631370a(GetIDByName), token=0x7fff75eb7b60\n[OS_ObjectIdAllocateNew] Early return: GlobalState indicates shutdown (GlobalState=-1414676258)\n[OS_ObjectIdAllocateNew] ENTER: idtype=4, name=0x5600a63137f8(GetInfo), token=0x7fff75eb7b6\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdAllocateNew:\nextern OS_SharedGlobalVars_t OS_SharedGlobalVars\n...\n#define OS_SHUTDOWN_MAGIC_NUMBER 0xABADC0DE\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_SUCCESS (0)\n...\n#define OS_ERR_INCORRECT_OBJ_STATE (-35)\n...\n#define OS_ERR_NAME_NOT_FOUND (-17)\n...\n#define OS_ERR_NAME_TAKEN (-15)\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    uint32              max_id;\n    uint32              base_id;\n    uint32              local_id = 0;\n    uint32              serial;\n    uint32              i;\n    int32               return_code;\n    OS_common_record_t *obj = NULL;\n    OS_objtype_state_t *objtype_state;\n\n    base_id       = OS_GetBaseForObjectType(token->obj_type);\n    max_id        = OS_GetMaxForObjectType(token->obj_type);\n    objtype_state = &OS_objtype_state[token->obj_type];\n\n    if (max_id == 0)\n    {\n        /* if the max id is zero, then this build of OSAL\n         * does not include any support for that object type.\n         * Return the \"not implemented\" to differentiate between\n         * this case vs. running out of valid slots  */\n        return_code = OS_ERR_NOT_IMPLEMENTED;\n        serial      = 0;\n    }\n    else\n    {\n        return_code = OS_ERR_NO_FREE_IDS;\n        serial      = OS_ObjectIdToSerialNumber_Impl(objtype_state->last_id_issued);\n    }\n\n    for (i = 0; i < max_id; ++i)\n    {\n        local_id = (++serial) % max_id;\n        if (serial >= OS_OBJECT_INDEX_MASK)\n        {\n            /* reset to beginning of ID space */\n            serial = local_id;\n        }\n        obj = &OS_common_table[local_id + base_id];\n        if (!OS_ObjectIdDefined(obj->active_id))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(local_id);\n        OS_ObjectIdCompose_Impl(token->obj_type, serial, &token->obj_id);\n\n        /* Ensure any data in the record has been cleared */\n        obj->active_id  = token->obj_id;\n        obj->name_entry = NULL;\n        obj->creator    = OS_TaskGetId();\n        obj->refcount   = 0;\n\n        /* preemptively update the last id issued */\n        objtype_state->last_id_issued = token->obj_id;\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(-1);\n        token->obj_id  = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Unlock_Global(token);\n        token->lock_mode = OS_LOCK_MODE_NONE;\n    }\n}\n...\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    if (OS_SharedGlobalVars.EventHandler != NULL)\n    {\n        status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    return status;\n}\n...\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. The function OS_ObjectIdAllocateNew itself contains no invariant controlling expression (no while(true) in the posted function). Agent A appears to be pointing at loops in helper functions called by OS_ObjectIdAllocateNew (notably OS_ObjectIdFindNextMatch and OS_ObjectIdConvertToken), which do use while(true) with internal break/return conditions. MISRA C 2023 Rule 14.3 forbids invariant controlling expressions except when they are used to create infinite loops. The while(true) in OS_ObjectIdFindNextMatch (increment obj_idx and break when obj_idx >= obj_count or on match) and the while(true) in OS_ObjectIdConvertToken (retry loop using an attempts counter and breaks) are invariant controlling expressions that are not the intended infinite-loop idiom and therefore would be noncompliant with 14.3. So the underlying concern about invariant while(true) loops is valid, but the original report that OS_ObjectIdAllocateNew itself violates Rule 14.3 is incorrect \u2014 the violation (if any) is in the helper functions, not in OS_ObjectIdAllocateNew. Recommended remediation: rewrite those loops with explicit termination conditions (e.g. for or while with the actual boolean loop condition such as while (token->obj_idx + 1 < obj_count) or while (attempts < MAX_ATTEMPTS) etc.), or otherwise document/structure them as true infinite loops only when that is the intention."
}