{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nCalling strrchr(File, '/') assumes 'File' points to a valid NUL-terminated string. If 'File' is non-NULL but does not refer to a NUL-terminated character array (for example, a filename stored in a fixed-size buffer filled by memcpy without adding a terminating '\\0', or a pointer into a non-string object), strrchr will scan past the end of that object looking for '\\0' and thus access memory beyond the bounds of the referenced object. This is a potential violation of MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_Message code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2889.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_Message as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_Message:\n```c\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n```\n</target_code>\nPlease provide the modified UtAssert_Message code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Provide the same basic integer typedefs used by the original code */\ntypedef uint8_t  uint8;\ntypedef uint32_t uint32;\n\n/* External function used by the original code - left as declaration so this file links as before. */\nextern void UT_BSP_DoText(uint8 MessageType, const char *Message);\n\n/* Helper: append diagnostic lines to /tmp/logs/2889.txt. Attempts to create the directory if needed. */\nstatic void UtAssert_AppendLog(const char *fmt, ...)\n{\n    FILE *f = NULL;\n    /* Ensure directory exists (ignore error if already exists) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/2889.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If unable to open the preferred log file, try a fallback in /tmp */\n        f = fopen(\"/tmp/2889_fallback_2889.txt\", \"a\");\n        if (f == NULL)\n        {\n            return;\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* The original function with probes inserted. All original behavior is preserved. */\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    /* Log entry and the pointer values. Do not dereference File here to avoid new out-of-bounds reads. */\n    UtAssert_AppendLog(\"ENTRY: UtAssert_Message called: MessageType=%u, File=%p, Line=%u, Spec=%p\",\n                       (unsigned)MessageType, (void *)File, (unsigned)Line, (const void *)Spec);\n\n    if (File != NULL)\n    {\n        UtAssert_AppendLog(\"Probe: about to call strrchr(File, '/'). File ptr=%p\", (void *)File);\n\n        /* The original call that may scan the buffer pointed to by File */\n        BaseName = strrchr(File, '/');\n\n        /* Log the result of strrchr without dereferencing the returned pointer. */\n        if (BaseName == NULL)\n        {\n            UtAssert_AppendLog(\"Probe: strrchr returned NULL (no '/' found)\");\n            BaseName = File;\n        }\n        else\n        {\n            /* Compute offset from File to BaseName for diagnostic purposes. This assumes\n               BaseName was obtained from strrchr(File, '/'), so subtraction is valid. */\n            ptrdiff_t offset = BaseName - File;\n            UtAssert_AppendLog(\"Probe: strrchr returned %p (offset=%td). Incrementing to skip '/'.\",\n                               (void *)BaseName, (ptrdiff_t)offset);\n            ++BaseName;\n        }\n\n        /* Build prefix into FinalMessage exactly as original code does. */\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n\n        /* Log the details about the prefix written into FinalMessage. This is safe since FinalMessage\n           is an internal buffer and is NUL-terminated by snprintf. */\n        UtAssert_AppendLog(\"Probe: prefix written to FinalMessage (len=%zu): '%s'\", MsgLen, FinalMessage);\n    }\n    else\n    {\n        UtAssert_AppendLog(\"Probe: File is NULL; skipping strrchr and prefix generation.\");\n        MsgLen = 0;\n    }\n\n    /* Preserve original variadic processing and message formatting */\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    /* Log the fully formatted message prior to passing it on to the BSP layer. */\n    UtAssert_AppendLog(\"EXIT: FinalMessage to be sent (len=%zu): '%s'\", strlen(FinalMessage), FinalMessage);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n"
}