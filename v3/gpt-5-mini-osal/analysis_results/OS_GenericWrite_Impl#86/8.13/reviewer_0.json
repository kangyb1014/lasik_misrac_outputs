{
  "user_message": "An agent A claimed that the following OS_GenericWrite_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_GenericWrite_Impl.\n```c\nint32 OS_GenericWrite_Impl(const OS_object_token_t *token, const void *buffer, size_t nbytes, int32 timeout)\n{\n    int32                           return_code;\n    ssize_t                         os_result;\n    uint32                          operation;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    return_code = OS_SUCCESS;\n\n    if (nbytes > 0)\n    {\n        operation = OS_STREAM_STATE_WRITABLE;\n\n        /*\n         * If filehandle is set with O_NONBLOCK, then must call select() here.\n         *\n         * The \"selectable\" field should be set false for those file handles\n         * which the underlying OS does not support select() on.\n         *\n         * Note that a timeout will not work unless selectable is true.\n         */\n        if (impl->selectable)\n        {\n            return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n        }\n\n        if (return_code == OS_SUCCESS && (operation & OS_STREAM_STATE_WRITABLE) != 0)\n        {\n            /* on some system libraries for which the write() argument is not\n             * qualified correctly, it needs to be case to a void* here */\n            os_result = write(impl->fd, GENERIC_IO_CONST_DATA_CAST buffer, nbytes);\n            if (os_result < 0)\n            {\n                OS_DEBUG(\"write: %s\\n\", strerror(errno));\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                /* type conversion from ssize_t to int32 for return */\n                return_code = (int32)os_result;\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'impl' is declared as 'OS_impl_file_internal_record_t *impl' but the function only reads members (impl->selectable, impl->fd) and does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type when possible. In this function it should be declared as 'const OS_impl_file_internal_record_t *impl' (unless OS_OBJECT_TABLE_GET or other code requires a non-const pointer).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_GenericWrite_Impl:\n#define GENERIC_IO_CONST_DATA_CAST \n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In this function 'impl' is only used to read members (impl->selectable and impl->fd) and is never used to modify the pointed-to object or passed to an API that expects a mutable pointer. MISRA C 2023 Rule 8.13 requires that pointers should point to const-qualified types whenever possible; therefore the local declaration could and should be changed to: const OS_impl_file_internal_record_t *impl. Assigning the result of OS_OBJECT_TABLE_GET (which may yield a non-const pointer) to a const-qualified pointer is allowed in C, so there is no obstacle in the shown code. If other code in this function needed to modify the record, or if the macro requires a non-const lvalue in some different usage, that would be a reason not to make it const\u2014but based on the provided snippet the agent A report is correct."
}