{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf the implementation OS_ConsoleOutput_Impl has the prototype OS_ConsoleOutput_Impl(OS_object_token_t *token) but does not modify the token, then the call OS_ConsoleOutput_Impl(&token) violates MISRA C 2023 Rule 8.13. In that case the parameter should be declared as const OS_object_token_t * to indicate it is not modified. Without the function prototype/implementation it cannot be proven safe; if the function legitimately modifies the token then no violation occurs.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ConsoleWrite code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2263.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ConsoleWrite as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleWrite:\n```c\nint32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /*\n         * The entire string should be put to the ring buffer,\n         * or none of it.  Therefore the WritePos in the table\n         * is not updated until complete success.\n         */\n        PendingWritePos = console->WritePos;\n\n        if (console->device_name[0] != 0)\n        {\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            console->WritePos = PendingWritePos;\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n        }\n\n        /*\n         * Notify the underlying console implementation of new data.\n         * This will forward the data to the actual console device.\n         *\n         * This is done while still locked, so it can support\n         * either a synchronous or asynchronous implementation.\n         */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWakeup_Impl(&token);\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleOutput_Impl(&token);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ConsoleWrite code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <inttypes.h>\n#include <time.h>\n\n/*\n * Probe/helper function to capture control flow and state.\n * Writes human-readable entries to /tmp/logs/2263.txt.\n * Use simple, robust APIs only so this can be linked into the\n * existing build without introducing complex dependencies.\n */\nstatic void OS_ConsoleWrite_Probe(const char *stage,\n                                  uintptr_t console_id_val,\n                                  const char *Str,\n                                  const void *token_addr,\n                                  const void *console_ptr,\n                                  size_t PendingWritePos,\n                                  int32_t return_code,\n                                  const char *note)\n{\n    FILE *f = fopen(\"/tmp/logs/2263.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Best-effort logging only; do not affect original behavior if logging fails */\n        return;\n    }\n\n    time_t now = time(NULL);\n    (void)fprintf(f, \"[%ld] STAGE=%s console_id=0x%08\" PRIxPTR \" Str=%p token_addr=%p console_ptr=%p PendingWritePos=%zu return_code=%d note=%s\\n\",\n                  (long)now,\n                  (stage != NULL) ? stage : \"(null)\",\n                  (uintptr_t)console_id_val,\n                  (const void *)Str,\n                  token_addr,\n                  console_ptr,\n                  PendingWritePos,\n                  (int)return_code,\n                  (note != NULL) ? note : \"\");\n\n    /* Flush immediately so other agents/processes can read logs in real time */\n    (void)fflush(f);\n    (void)fclose(f);\n}\n\nint32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    /* Log entry with initial parameters */\n    OS_ConsoleWrite_Probe(\"entry\",\n                          (uintptr_t)console_id,\n                          Str,\n                          (const void *)&token,\n                          NULL,\n                          0u,\n                          0,\n                          \"call entry\");\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n\n    /* Log result of ObjectIdGetById and token address */\n    OS_ConsoleWrite_Probe(\"after_ObjectIdGetById\",\n                          (uintptr_t)console_id,\n                          Str,\n                          (const void *)&token,\n                          NULL,\n                          0u,\n                          return_code,\n                          \"obtained token (or not)\");\n\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /* Log console pointer and initial write pos */\n        PendingWritePos = console->WritePos;\n        OS_ConsoleWrite_Probe(\"got_console\",\n                              (uintptr_t)console_id,\n                              Str,\n                              (const void *)&token,\n                              (const void *)console,\n                              PendingWritePos,\n                              return_code,\n                              \"console retrieved, logging initial state\");\n\n        if (console->device_name[0] != 0)\n        {\n            OS_ConsoleWrite_Probe(\"before_CopyOut_device\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  console->device_name);\n\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n\n            OS_ConsoleWrite_Probe(\"after_CopyOut_device\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"device name copied out\");\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            OS_ConsoleWrite_Probe(\"before_CopyOut_Str\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"about to copy out user string\");\n\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n\n            OS_ConsoleWrite_Probe(\"after_CopyOut_Str\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"user string copy done\");\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            OS_ConsoleWrite_Probe(\"before_commit\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"committing write position\");\n\n            console->WritePos = PendingWritePos;\n\n            OS_ConsoleWrite_Probe(\"after_commit\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"write position updated\");\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n\n            OS_ConsoleWrite_Probe(\"overflow\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"incremented overflow events\");\n        }\n\n        /* Notify the underlying console implementation of new data. */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWrite_Probe(\"wakeup_impl\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"calling OS_ConsoleWakeup_Impl\");\n\n            OS_ConsoleWakeup_Impl(&token);\n\n            OS_ConsoleWrite_Probe(\"after_wakeup_impl\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"wakeup impl returned\");\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleWrite_Probe(\"output_impl_before\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"calling OS_ConsoleOutput_Impl (potential rule 8.13 site)\");\n\n            OS_ConsoleOutput_Impl(&token);\n\n            OS_ConsoleWrite_Probe(\"output_impl_after\",\n                                  (uintptr_t)console_id,\n                                  Str,\n                                  (const void *)&token,\n                                  (const void *)console,\n                                  PendingWritePos,\n                                  return_code,\n                                  \"returned from OS_ConsoleOutput_Impl\");\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        OS_ConsoleWrite_Probe(\"exit_success\",\n                              (uintptr_t)console_id,\n                              Str,\n                              (const void *)&token,\n                              (const void *)console,\n                              PendingWritePos,\n                              return_code,\n                              \"released token and exiting\");\n    }\n\n    /* Final return (unchanged) */\n    return return_code;\n}\n"
}