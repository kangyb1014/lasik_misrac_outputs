{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe macro OS_CHECK_STRING is not defined in the snippet, so its implementation cannot be proven safe. If OS_CHECK_STRING uses string.h functions such as strlen/strcpy/strncpy/memcpy without proper bounds-limited checks, a violation can occur. Example violation: if OS_CHECK_STRING calls strlen(fsdevname) (or otherwise reads fsdevname past its allocated size) when fsdevname is not NUL-terminated within the provided limit (sizeof(filesys->device_name)), strlen will read beyond the bounds of the object referenced by fsdevname \u2014 violating MISRA C 2023 Rule 21.17. Another possible violation scenario is if the macro attempts to copy into filesys->device_name before filesys is initialized, causing an out-of-bounds/invalid access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_mkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1819.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_mkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_mkfs:\n```c\nint32 OS_mkfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, true);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_mkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Probe logging utility: append logs to /tmp/logs/1819.txt\n * This utility avoids dereferencing incoming pointer parameters to\n * prevent introducing additional out-of-bounds accesses. It logs\n * pointer values and numeric parameters only, so it is safe to use\n * even when string pointers may be non-terminated or otherwise unsafe.\n */\nstatic void os_mkfs_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1819.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Forward declaration of external function (defined elsewhere) */\nint32_t OS_FileSys_Initialize(char *address, const char *devname, const char *volname, size_t blocksize, unsigned long long numblocks, int initialize_flag);\n\n/* Keep the original signature. Use integer types that match project types where possible. */\nint32_t OS_mkfs(char *address, const char *devname, const char *volname, size_t blocksize, unsigned long long numblocks)\n{\n    int32_t return_code;\n\n    /* Log entry and parameter pointer values (do not dereference pointers) */\n    os_mkfs_log(\"OS_mkfs ENTRY: address=%p, devname=%p, volname=%p, blocksize=%zu, numblocks=%llu\",\n                (void *)address, (const void *)devname, (const void *)volname, blocksize, numblocks);\n\n    /* Call the original initialization routine. The final parameter 'true' in the\n     * original code corresponds to an initialization flag; preserve the logic by\n     * passing a non-zero integer (1). */\n    return_code = (int32_t)OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, 1);\n\n    /* Log the immediate return code from OS_FileSys_Initialize */\n    os_mkfs_log(\"OS_FileSys_Initialize returned: %d\", (int)return_code);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /* Log that the historic mapping will be applied */\n        os_mkfs_log(\"Mapping legacy error code: original=%d -> OS_FS_ERR_DEVICE_NOT_FREE\", (int)return_code);\n\n        /* This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    /* Log exit and final return code */\n    os_mkfs_log(\"OS_mkfs EXIT: returning %d\", (int)return_code);\n\n    return return_code;\n}\n"
}