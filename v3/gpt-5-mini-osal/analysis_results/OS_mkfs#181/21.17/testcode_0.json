{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call strncmp(filesys->volume_name, OS_FILESYS_RAMDISK_VOLNAME_PREFIX, sizeof(OS_FILESYS_RAMDISK_VOLNAME_PREFIX) - 1) can read past the end of filesys->volume_name. For example, if OS_FILESYS_RAMDISK_VOLNAME_PREFIX is longer than the storage for filesys->volume_name (so sizeof(prefix)-1 > sizeof(filesys->volume_name)), strncmp will attempt to read more bytes from filesys->volume_name than are present. Also, if filesys->volume_name is not NUL-terminated (possible because strncpy(filesys->volume_name, fsvolname, sizeof(filesys->volume_name)-1) may leave no terminator when the source length equals sizeof(filesys->volume_name)-1), then strncmp will read up to the specified length and may access beyond the object bounds. Both situations violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_mkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1819.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_mkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_mkfs:\n```c\nint32 OS_mkfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, true);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_mkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <inttypes.h>\n\n/* Probe helpers: log to /tmp/logs/1819.txt to capture control flow and state. */\nstatic void os_mkfs_ensure_log_dir(void)\n{\n    /* Try to create the parent directory for logs; ignore errors if it already exists. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n}\n\nstatic void os_mkfs_log_entry(const char *stage, char *address, const char *devname, const char *volname, size_t blocksize, unsigned long long numblocks, int32_t return_code_valid, int32_t return_code)\n{\n    FILE *f = NULL;\n\n    os_mkfs_ensure_log_dir();\n\n    f = fopen(\"/tmp/logs/1819.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log the stage and the pointers/values relevant to reproducing the scenario. */\n    fprintf(f, \"OS_mkfs %s: address=%p devname=%p volname=%p blocksize=%zu numblocks=%llu\\n\",\n            stage, (void *)address, (const void *)devname, (const void *)volname, blocksize, numblocks);\n\n    if (return_code_valid)\n    {\n        fprintf(f, \"OS_mkfs %s: return_code=%d\\n\", stage, return_code);\n    }\n\n    fflush(f);\n    fclose(f);\n}\n\n/*\n * Modified OS_mkfs: preserves original logic but adds probes before and after\n * the call to OS_FileSys_Initialize so callers/agents can observe the\n * parameters and the returned code that affect subsequent behavior.\n *\n * NOTE: This function intentionally does not attempt to read string\n * contents (devname/volname) to avoid introducing additional out-of-bounds\n * string accesses. It logs pointer values and numeric parameters only.\n */\nint32 OS_mkfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    /* Log entry with parameter pointers and sizes. */\n    os_mkfs_log_entry(\"ENTRY\", address, devname, volname, blocksize, (unsigned long long)numblocks, 0, 0);\n\n    /* Call the original initializer (preserve original behavior). */\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, true);\n\n    /* Log the immediate return from OS_FileSys_Initialize. */\n    os_mkfs_log_entry(\"AFTER_Init\", address, devname, volname, blocksize, (unsigned long long)numblocks, 1, (int32_t)return_code);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        os_mkfs_log_entry(\"MAP_to_DEVICE_NOT_FREE\", address, devname, volname, blocksize, (unsigned long long)numblocks, 1, (int32_t)OS_FS_ERR_DEVICE_NOT_FREE);\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    /* Final return: log and return. */\n    os_mkfs_log_entry(\"EXIT\", address, devname, volname, blocksize, (unsigned long long)numblocks, 1, (int32_t)return_code);\n\n    return return_code;\n}\n"
}