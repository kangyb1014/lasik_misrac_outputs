{
  "user_message": "An agent A claimed that the following OS_MutSemGetIdByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemGetIdByName.\n```c\nint32 OS_MutSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_POINTER(sem_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the LENGTHCHECK macro uses an unbounded string function such as strlen(name) to validate the name length (for example: if (strlen(name) >= OS_MAX_API_NAME) ...), and the supplied name pointer does not point to a NUL-terminated array within its accessible bounds, the strlen call can read past the end of the object. That would constitute an out-of-bounds access and thus violate MISRA C 2023 Rule 21.17. A compliant implementation must use a bounded operation (e.g. strnlen with the provided limit) or otherwise ensure the string is NUL-terminated within the known maximum length before calling unbounded string functions.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: OS_MutSemGetIdByName called. sem_id=(nil), sem_name=0x557a1666664c\nENTRY: OS_MutSemGetIdByName called. sem_id=0x7ffe53b5f3cc, sem_name=(nil)\nENTRY: OS_MutSemGetIdByName called. sem_id=0x7ffe53b5f3cc, sem_name=0x7ffe53b5f3d0\nAfter parameter checks: sem_id=0x7ffe53b5f3cc, sem_name=0x7ffe53b5f3d0\nADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro uses an unbounded function (e.g. strlen) on sem_name, it may read past the end of the object if sem_name is not NUL-terminated within its bounds.\nOS_ObjectIdFindByName returned -13 for sem_name=0x7ffe53b5f3d0\nEXIT: OS_MutSemGetIdByName returning -13\nENTRY: OS_MutSemGetIdByName called. sem_id=0x7ffe53b5f3cc, sem_name=0x557a166666d9\nAfter parameter checks: sem_id=0x7ffe53b5f3cc, sem_name=0x557a166666d9\nADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro uses an unbounded function (e.g. strlen) on sem_name, it may read past the end of the object if sem_name is not NUL-terminated within its bounds.\nOS_ObjectIdFindByName returned -17 for sem_name=0x557a166666d9\nEXIT: OS_MutSemGetIdByName returning -17\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_MutSemGetIdByName:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdGetByName(OS_lock_mode_t lock_mode, osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    return OS_ObjectIdGetBySearch(lock_mode, idtype, OS_ObjectNameMatch, (void *)name, token);\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\n#define OS_MAX_API_NAME 20\n...\ntypedef uint32 osal_id_t\n...\n#define OS_INVALID_POINTER (-2)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not definitively correct as written. The OS_MutSemGetIdByName function itself does not call any <string.h> routines; it delegates to OS_ObjectIdFindByName. The potential Rule 21.17 problem depends entirely on the implementation of the LENGTHCHECK macro (and any other macros it expands to). If LENGTHCHECK were implemented with an unbounded string function such as strlen(name) and a caller could supply a pointer to a non\u2011NUL\u2011terminated array (or a pointer whose accessible region does not contain a NUL within OS_MAX_API_NAME bytes), then that use would indeed risk reading out of bounds and would violate MISRA C 2023 Rule 21.17. Conversely, if LENGTHCHECK is implemented using a bounded operation (e.g. strnlen, memchr with the known limit, or explicit checks that guarantee NUL termination within OS_MAX_API_NAME), or if the API contract guarantees the name is NUL\u2011terminated within the known limit, then there is no Rule 21.17 violation. In short: the agent\u2019s scenario describes a valid possible violation, but the claim that OS_MutSemGetIdByName violates Rule 21.17 is conditional on the unspecified LENGTHCHECK implementation \u2014 it is not proven by the code shown alone."
}