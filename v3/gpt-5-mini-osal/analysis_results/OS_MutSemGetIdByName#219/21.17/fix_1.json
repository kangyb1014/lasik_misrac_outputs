{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2199.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_MutSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Log entry and raw pointer state. Do NOT dereference sem_name here. */\n    probe_log(\"ENTRY: OS_MutSemGetIdByName called. sem_id=%p, sem_name=%p\", (void *)sem_id, (void *)sem_name);\n\n    /* Check parameters (preserve original checks) */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_POINTER(sem_name);\n\n    probe_log(\"After parameter checks: sem_id=%p, sem_name=%p\", (void *)sem_id, (void *)sem_name);\n\n    /*\n     * Important: do not call unbounded string functions (e.g. strlen) here\n     * because sem_name may not be NUL-terminated within accessible bounds.\n     * This probe intentionally avoids dereferencing sem_name to prevent\n     * creating a new out-of-bounds access while still recording the\n     * conditions that can lead to the reported MISRA rule violation.\n     *\n     * We log an advisory so investigators know where a LENGTHCHECK that\n     * uses strlen would be problematic.\n     */\n    probe_log(\"ADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro\nuses an unbounded function (e.g. strlen) on sem_name, it may read past the\nend of the object if sem_name is not NUL-terminated within its bounds.\");\n\n    /* Call the original lookup logic and capture return code */\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    probe_log(\"OS_ObjectIdFindByName returned %d for sem_name=%p\", (int)return_code, (void *)sem_name);\n    probe_log(\"EXIT: OS_MutSemGetIdByName returning %d\", (int)return_code);\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c: In function 'OS_MutSemGetIdByName':\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:258:15: error: missing terminating \" character\n  258 |     probe_log(\"ADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro\n      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:259:1: error: 'uses' undeclared (first use in this function)\n  259 | uses an unbounded function (e.g. strlen) on sem_name, it may read past the\n      | ^~~~\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:259:1: note: each undeclared identifier is reported only once for each function it appears in\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:259:5: error: expected ')' before 'an'\n  259 | uses an unbounded function (e.g. strlen) on sem_name, it may read past the\n      |     ^~~\n      |     )\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:258:14: note: to match this '('\n  258 |     probe_log(\"ADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro\n      |              ^\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:260:71: error: missing terminating \" character\n  260 | end of the object if sem_name is not NUL-terminated within its bounds.\");\n      |                                                                       ^~~\n/tmp/tmpbfwowk08/src/src/os/shared/src/osapi-mutex.c:268:24: error: expected ';' before '}' token\n  268 |     return return_code;\n      |                        ^\n      |                        ;\n  269 | }\n      | ~                       \ngmake[2]: *** [CMakeFiles/osal.dir/build.make:244: CMakeFiles/osal.dir/src/os/shared/src/osapi-mutex.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_MutSemGetIdByName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\n\n/* Return codes used by this translation unit (kept minimal) */\nenum\n{\n    OS_SUCCESS = 0,\n    OS_INVALID_POINTER = -1\n};\n\n/* Local object type constant (original used a macro) */\nenum { LOCAL_OBJID_TYPE = 1 };\n\n/* Prototype for the external lookup function (no mock/definition here) */\nint32 OS_ObjectIdFindByName(int type, const char *name, osal_id_t *id);\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2199.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_MutSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Log entry and raw pointer state. Do NOT dereference sem_name here. */\n    probe_log(\"ENTRY: OS_MutSemGetIdByName called. sem_id=%p, sem_name=%p\", (void *)sem_id, (void *)sem_name);\n\n    /* Check parameters (preserve original checks) */\n    if (sem_id == NULL)\n    {\n        return OS_INVALID_POINTER;\n    }\n    if (sem_name == NULL)\n    {\n        return OS_INVALID_POINTER;\n    }\n\n    probe_log(\"After parameter checks: sem_id=%p, sem_name=%p\", (void *)sem_id, (void *)sem_name);\n\n    /*\n     * Important: do not call unbounded string functions (e.g. strlen) here\n     * because sem_name may not be NUL-terminated within accessible bounds.\n     * This probe intentionally avoids dereferencing sem_name to prevent\n     * creating a new out-of-bounds access while still recording the\n     * conditions that can lead to the reported MISRA rule violation.\n     *\n     * We log an advisory so investigators know where a LENGTHCHECK that\n     * uses strlen would be problematic.\n     */\n    probe_log(\"ADVISORY: Not invoking strlen(sem_name) here. If a LENGTHCHECK macro uses an unbounded function (e.g. strlen) on sem_name, it may read past the end of the object if sem_name is not NUL-terminated within its bounds.\");\n\n    /* Call the original lookup logic and capture return code */\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    probe_log(\"OS_ObjectIdFindByName returned %d for sem_name=%p\", (int)return_code, (void *)sem_name);\n    probe_log(\"EXIT: OS_MutSemGetIdByName returning %d\", (int)return_code);\n\n    return return_code;\n}\n",
  "explanation": "The compile error was caused by a multi-line string literal that was split across source lines without proper continuation. I fixed this by replacing the broken multi-line string with a single properly escaped string (no raw line breaks). To make the file self-contained and compilable, I added required headers and simple type/constant declarations (typedefs for int32 and osal_id_t, an enum for LOCAL_OBJID_TYPE, and minimal return codes). I also replaced the OS_CHECK_POINTER macro calls with explicit NULL checks to avoid relying on undefined macros. The original logic and logging behavior of OS_MutSemGetIdByName were preserved."
}