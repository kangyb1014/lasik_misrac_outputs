{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe logging function to capture control flow and state for OS_QueueCreate\n * Writes human-readable trace information to /tmp/logs/2293.txt\n * Uses only read-only access to the queue record (takes a const pointer)\n */\nstatic void OS_QueueCreate_LogProbe(const char *event, const void *queue_ptr, void *token_ptr,\n                                    int32 return_code, uint32 flags)\n{\n    FILE *f = fopen(\"/tmp/logs/2293.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"Event: %s\\n\", event);\n    fprintf(f, \"  token addr: %p\\n\", token_ptr);\n    fprintf(f, \"  queue ptr : %p\\n\", queue_ptr);\n\n    /* The following block attempts to safely print fields if queue_ptr is non-NULL.\n     * Cast to a generic struct pointer to avoid depending on full type here; the\n     * calling code passes an OS_queue_internal_record_t* so these field accesses\n     * are intended to match the real structure layout in the build environment.\n     */\n    if (queue_ptr != NULL)\n    {\n        /* Define a local proxy type matching the fields we read. This avoids\n         * introducing additional dependencies while allowing safe reads of the\n         * expected fields used in the function under test.\n         */\n        struct __probe_queue_proxy\n        {\n            uint64_t max_depth;\n            uint64_t max_size;\n            const char *queue_name;\n        };\n\n        const struct __probe_queue_proxy *q = (const struct __probe_queue_proxy *)queue_ptr;\n\n        fprintf(f, \"  max_depth : %\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_QueueCreate as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe logging function to capture control flow and state for OS_QueueCreate\n * Writes human-readable trace information to /tmp/logs/2293.txt\n * Uses only read-only access to the queue record (takes a const pointer)\n */\nstatic void OS_QueueCreate_LogProbe(const char *event, const void *queue_ptr, void *token_ptr,\n                                    int32_t return_code, uint32_t flags)\n{\n    FILE *f = fopen(\"/tmp/logs/2293.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"Event: %s\\n\", event ? event : \"(null)\");\n    fprintf(f, \"  token addr: %p\\n\", token_ptr);\n    fprintf(f, \"  queue ptr : %p\\n\", queue_ptr);\n\n    /* The following block attempts to safely print fields if queue_ptr is non-NULL.\n     * Cast to a generic struct pointer to avoid depending on full type here; the\n     * calling code passes an OS_queue_internal_record_t* so these field accesses\n     * are intended to match the real structure layout in the build environment.\n     */\n    if (queue_ptr != NULL)\n    {\n        /* Define a local proxy type matching the fields we read. This avoids\n         * introducing additional dependencies while allowing safe reads of the\n         * expected fields used in the function under test.\n         */\n        struct __probe_queue_proxy\n        {\n            uint64_t max_depth;\n            uint64_t max_size;\n            const char *queue_name;\n        };\n\n        const struct __probe_queue_proxy *q = (const struct __probe_queue_proxy *)queue_ptr;\n\n        fprintf(f, \"  max_depth : %\" PRIu64 \"\\n\", q->max_depth);\n        fprintf(f, \"  max_size  : %\" PRIu64 \"\\n\", q->max_size);\n        fprintf(f, \"  queue_name: %p\\n\", (const void *)q->queue_name);\n        if (q->queue_name != NULL)\n        {\n            fprintf(f, \"    name str : %s\\n\", q->queue_name);\n        }\n    }\n\n    fprintf(f, \"  return_code: %\" PRId32 \"\\n\", return_code);\n    fprintf(f, \"  flags      : %\" PRIu32 \"\\n\", flags);\n\n    fclose(f);\n}\n",
  "explanation": "Fixed compilation issues by: 1) replacing nonstandard integer type names (int32 and uint32) with standard int32_t and uint32_t; 2) completing the truncated fprintf call(s) and using the PRIu64/PRId32/PRIu32 macros from <inttypes.h> to print fixed-width integers; 3) adding a null check for event and printing the queue_name pointer and string safely; and 4) ensuring the file is closed with fclose. The original probe-logging logic is preserved."
}