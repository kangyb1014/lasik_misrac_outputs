{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call memset(token, 0, sizeof(*token)) can dereference an invalid pointer if token == NULL (or otherwise points to an object smaller than sizeof(OS_object_token_t)). For example, if a caller invokes OS_ObjectIdTransactionInit(NULL, ...) or if OS_ObjectIdGetById is called with a NULL token parameter, the memset will write sizeof(OS_object_token_t) bytes to an invalid address (e.g. address 0), causing an out-of-bounds access. The function does not validate that token is non-NULL before calling memset, so the use of memset can potentially violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CountSemTimedWait code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1489.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CountSemTimedWait as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CountSemTimedWait:\n```c\nint32 OS_CountSemTimedWait(osal_id_t sem_id, uint32 msecs)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_CountSemTimedWait_Impl(&token, msecs);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CountSemTimedWait code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Probe logging helper for OS_CountSemTimedWait\n * Appends logs to /tmp/logs/1489.txt.\n * This helper is intentionally small and does not change the logic\n * of the function that it's instrumenting. It avoids dereferencing\n * any pointer that could be NULL. */\nstatic void OS_CountSemTimedWait_Log(const char *stage,\n                                     unsigned long long sem_id_val,\n                                     unsigned long long msecs_val,\n                                     void *token_ptr,\n                                     int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1489.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If log file cannot be opened, do not interfere with original logic. */\n        return;\n    }\n\n    /* Print a compact record: stage, sem_id, msecs, token pointer, return_code */\n    fprintf(f, \"stage=%s sem_id=0x%llx msecs=%llu token_ptr=%p return_code=%d\\n\",\n            stage, sem_id_val, msecs_val, token_ptr, return_code);\n\n    /* If token pointer looks valid, also dump up to the first 16 bytes to help\n     * detect whether a memset or similar may have overwritten memory.\n     * Do not dereference if token_ptr is NULL. */\n    if (token_ptr != NULL)\n    {\n        unsigned char *p = (unsigned char *)token_ptr;\n        size_t to_dump = 16;\n        fprintf(f, \"token_bytes=\");\n        for (size_t i = 0; i < to_dump; ++i)\n        {\n            /* We avoid reading beyond reasonable stack/object size here by\n             * only reading a small fixed amount. This preserves original logic\n             * and does not introduce out-of-bounds reads (it assumes the\n             * provided pointer points to at least to_dump bytes, which is\n             * reasonable for stack-allocated token objects in typical builds).\n             */\n            fprintf(f, \"%02x\", (unsigned int)p[i]);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fflush(f);\n    fclose(f);\n}\n\n/* The function below preserves the original logic of OS_CountSemTimedWait\n * and adds logging probes before and after key operations so other agents\n * can reproduce and gather evidence for the reported violation scenario. */\nint32 OS_CountSemTimedWait(osal_id_t sem_id, uint32 msecs)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and the address of the local token object. */\n    OS_CountSemTimedWait_Log(\"enter\", (unsigned long long)sem_id, (unsigned long long)msecs, (void *)&token, 0);\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log result of OS_ObjectIdGetById. If return_code indicates success, token was provided.\n     * If it failed, log with a NULL token_ptr to highlight that the operation did not produce a valid token. */\n    OS_CountSemTimedWait_Log(\"after_OS_ObjectIdGetById\",\n                             (unsigned long long)sem_id,\n                             (unsigned long long)msecs,\n                             (return_code == OS_SUCCESS) ? (void *)&token : NULL,\n                             return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Before invoking the implementation, log the token pointer and a small dump\n         * so any unexpected changes to the token memory are recorded. */\n        OS_CountSemTimedWait_Log(\"before_Impl\", (unsigned long long)sem_id, (unsigned long long)msecs, (void *)&token, 0);\n\n        return_code = OS_CountSemTimedWait_Impl(&token, msecs);\n\n        /* Log the return code from the implementation and token address again. */\n        OS_CountSemTimedWait_Log(\"after_Impl\", (unsigned long long)sem_id, (unsigned long long)msecs, (void *)&token, return_code);\n    }\n    else\n    {\n        /* Log that we are returning an error without calling the Impl. */\n        OS_CountSemTimedWait_Log(\"skip_Impl_return_error\", (unsigned long long)sem_id, (unsigned long long)msecs, NULL, return_code);\n    }\n\n    /* Final exit log. */\n    OS_CountSemTimedWait_Log(\"exit\", (unsigned long long)sem_id, (unsigned long long)msecs, (return_code == OS_SUCCESS) ? (void *)&token : NULL, return_code);\n\n    return return_code;\n}\n"
}