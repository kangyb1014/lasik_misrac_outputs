{
  "user_message": "An agent A claimed that the following UtAssert_StringBufCompare code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_StringBufCompare.\n```c\nbool UtAssert_StringBufCompare(const char *String1, size_t String1Max, const char *String2, size_t String2Max,\n                               UtAssert_Compare_t CompareType, const char *File, uint32 Line)\n{\n    char        ScrubbedString1[256];\n    char        ScrubbedString2[256];\n    const char *EndPtr1;\n    const char *EndPtr2;\n    size_t      FormatLen1;\n    size_t      FormatLen2;\n    bool        Result;\n    int         Compare;\n\n    /* Locate the actual end of both strings */\n    if (String1 == NULL)\n    {\n        EndPtr1 = NULL;\n    }\n    else if (String1Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        /*\n         * NOTE: it is technically undefined behavior to pass a size to memchr()\n         * that is larger than the actual buffer, even if it is known/guaranteed\n         * to find a match within the actual buffer.  Therefore the regular strlen()\n         * is used instead.\n         */\n        EndPtr1 = String1 + strlen(String1);\n    }\n    else\n    {\n        EndPtr1 = memchr(String1, 0, String1Max);\n    }\n\n    if (EndPtr1 != NULL)\n    {\n        FormatLen1 = EndPtr1 - String1;\n    }\n    else\n    {\n        FormatLen1 = String1Max;\n    }\n\n    if (String2 == NULL)\n    {\n        EndPtr2 = NULL;\n    }\n    else if (String2Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        EndPtr2 = String2 + strlen(String2);\n    }\n    else\n    {\n        EndPtr2 = memchr(String2, 0, String2Max);\n    }\n\n    if (EndPtr2 != NULL)\n    {\n        FormatLen2 = EndPtr2 - String2;\n    }\n    else\n    {\n        FormatLen2 = String2Max;\n    }\n\n    if (FormatLen1 == 0 && FormatLen2 == 0)\n    {\n        /* Two empty strings are considered equal */\n        Compare = 0;\n    }\n    else\n    {\n        /* Compare actual content based on the shorter of the two strings */\n        if (FormatLen1 < FormatLen2)\n        {\n            Compare = memcmp(String1, String2, FormatLen1);\n        }\n        else\n        {\n            Compare = memcmp(String1, String2, FormatLen2);\n        }\n\n        /* If initial content was the same, go by whichever is longer */\n        if (Compare == 0)\n        {\n            /*\n             * If String1 is longer, compare should be positive (String1 > String2)\n             * If String2 is longer, compare should be negative (String1 < String2)\n             * If strings are the same length, compare should be 0.\n             */\n            Compare = FormatLen1 - FormatLen2;\n        }\n    }\n\n    switch (CompareType)\n    {\n        case UtAssert_Compare_EQ: /* actual equals reference value */\n            Result = (Compare == 0);\n            break;\n        case UtAssert_Compare_NEQ: /* actual does not non equal reference value */\n            Result = (Compare != 0);\n            break;\n        case UtAssert_Compare_LT: /* actual less than reference (exclusive) */\n            Result = (Compare < 0);\n            break;\n        case UtAssert_Compare_GT: /* actual greater than reference (exclusive)  */\n            Result = (Compare > 0);\n            break;\n        case UtAssert_Compare_LTEQ: /* actual less than or equal to reference (inclusive) */\n            Result = (Compare <= 0);\n            break;\n        case UtAssert_Compare_GTEQ: /* actual greater than reference (inclusive) */\n            Result = (Compare >= 0);\n            break;\n        default: /* should never happen */\n            Result = false;\n            break;\n    }\n\n    /* Now make \"safe\" copies of the strings */\n    /* Check for a newline within the string, and if present, end the string there instead */\n    if (FormatLen1 > 0)\n    {\n        EndPtr1 = memchr(String1, '\\n', FormatLen1);\n        if (EndPtr1 != NULL)\n        {\n            FormatLen1 = EndPtr1 - String1;\n        }\n        memcpy(ScrubbedString1, String1, FormatLen1);\n    }\n    ScrubbedString1[FormatLen1] = 0;\n\n    if (FormatLen2 > 0)\n    {\n        EndPtr2 = memchr(String2, '\\n', FormatLen2);\n        if (EndPtr2 != NULL)\n        {\n            FormatLen2 = EndPtr2 - String2;\n        }\n        memcpy(ScrubbedString2, String2, FormatLen2);\n    }\n    ScrubbedString2[FormatLen2] = 0;\n\n    return UtAssertEx(Result, UTASSERT_CASETYPE_FAILURE, File, Line, \"String: \\'%s\\' == \\'%s\\'\", ScrubbedString1,\n                      ScrubbedString2);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nInside UtAssertEx the parameter 'CaseType' (type UtAssert_CaseType_t) is reassigned: CaseType = UTASSERT_CASETYPE_PASS; this directly modifies a function parameter (not a pointed-to object) and thus violates MISRA C 2023 Rule 17.8. A local copy should be used instead of modifying the parameter.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[STATE] Compare=0, Result=1, FormatLen1=1, FormatLen2=1, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63, Message=\"String: '0' == '0'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=2, FormatLen2=2, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63, Message=\"String: '-1' == '-1'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=10, FormatLen2=10, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63, Message=\"String: '2147483647' == '2147483647'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=11, FormatLen2=11, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-errors.c, Line=63, Message=\"String: '-2147483648' == '-2147483648'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=0, FormatLen2=0, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-file.c, Line=315\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-test-coverage/shared/src/coveragetest-file.c, Line=315, Message=\"String: '' == ''\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=1, FormatLen2=1, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432, Message=\"String: '0' == '0'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=2, FormatLen2=2, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432, Message=\"String: '-1' == '-1'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=10, FormatLen2=10, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432, Message=\"String: '2147483647' == '2147483647'\"\n[POST] UtAssertEx returned: 1\n[STATE] Compare=0, Result=1, FormatLen1=11, FormatLen2=11, CompareType=1\n[CALL] Invoking UtAssertEx with CaseType=2 (UTASSERT_CASETYPE_FAILURE expected), File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432\n[PRE] UtAssertEx call: Result=1, CaseType=2, File=/tmp/tmpo5kyh1m0/src/src/unit-tests/oscore-test/ut_oscore_misc_test.c, Line=432, Message=\"String: '-2147483648' == '-2147483648'\"\n[POST] UtAssertEx returned: 1\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_StringBufCompare:\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n...\n#define UTASSERT_STRINGBUF_NULL_TERM SIZE_MAX\n...\ntypedef enum\n{\n    UtAssert_Compare_NONE,          /**< invalid/not used, always false */\n    UtAssert_Compare_EQ,            /**< actual equals reference value */\n    UtAssert_Compare_NEQ,           /**< actual does not non equal reference value */\n    UtAssert_Compare_LT,            /**< actual less than reference (exclusive) */\n    UtAssert_Compare_GT,            /**< actual greater than reference (exclusive)  */\n    UtAssert_Compare_LTEQ,          /**< actual less than or equal to reference (inclusive) */\n    UtAssert_Compare_GTEQ,          /**< actual greater than reference (inclusive) */\n    UtAssert_Compare_BITMASK_SET,   /**< actual equals reference value */\n    UtAssert_Compare_BITMASK_UNSET, /**< actual equals reference value */\n    UtAssert_Compare_MAX            /**< placeholder, not used */\n} UtAssert_Compare_t\n...\ntypedef uint32_t  uint32\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct that a MISRA C 2023 Rule 17.8 violation exists in the provided code base. The violation is in UtAssertEx, not inside UtAssert_StringBufCompare itself. In UtAssertEx the non\u2011pointer parameter CaseType (type UtAssert_CaseType_t) is directly reassigned: \"if (Expression) { CaseType = UTASSERT_CASETYPE_PASS; }\". Rule 17.8 states that a function parameter shall not be modified (the object referred to by a pointer parameter may be modified, but the pointer itself shall not be). Assigning a new value to the value parameter CaseType is a direct breach of that rule. The execution log also shows behavior consistent with CaseType being changed by UtAssertEx. Recommended remediation: do not modify the parameter; make a local copy (e.g., UtAssert_CaseType_t LocalCaseType = CaseType;) and modify/use the local copy instead, then use that local copy when reporting."
}