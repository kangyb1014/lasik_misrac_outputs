{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strcpy(Local_SegmentName, CurrentSegment) can violate MISRA C 2023 Rule 21.17 if the bounds/termination of CurrentSegment and Local_SegmentName are not guaranteed. Two realistic failure scenarios: (1) If CurrentSegment is not a fixed-size array containing a NUL terminator within its own bounds (i.e. it may lack a terminating '\\0'), strcpy will read past the end of CurrentSegment causing an out\u2011of\u2011bounds access of the source. (2) If CurrentSegment is actually a char * (pointer) rather than an array, sizeof(CurrentSegment) yields the pointer size, making Local_SegmentName too small; copying a longer string then causes writes beyond Local_SegmentName (and possibly reads beyond the source if not NUL-terminated). The comment asserts safety, but the code does not itself enforce or prove the required NUL termination/size guarantees, so the call can violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_GetCaseTypeAbbrev code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2859.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_GetCaseTypeAbbrev as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_GetCaseTypeAbbrev:\n```c\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    return AbbrevStr;\n}\n```\n</target_code>\nPlease provide the modified UtAssert_GetCaseTypeAbbrev code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/*\n * Probe function to log information about calls to UtAssert_GetCaseTypeAbbrev\n * and to provide a helper that can be used by other agents to check and\n * log potential strcpy-style risks when calling strcpy(dest, src).\n *\n * Notes:\n * - Logs are appended to /tmp/logs/2859.txt\n * - The probe that inspects strings requires the caller to provide the\n *   known buffer sizes (dest_size and src_size). This avoids performing\n *   unbounded reads that could themselves cause out-of-bounds accesses.\n */\n\n/* Forward declaration of the enum type used by the original function.\n * The actual definition is expected to be available in the original\n * compilation unit. We only reference it here in function signatures.\n */\n\n/* Probe function: logs case type and returned abbreviation. */\nstatic void UtAssert_Log_CaseInfo(int CaseType, const char *AbbrevStr)\n{\n    FILE *fp = fopen(\"/tmp/logs/2859.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* If logging fails, do not affect original logic */\n    }\n\n    /* AbbrevStr is expected to be a string literal returned by the function\n     * so calling strlen on it here is safe. Log relevant runtime state.\n     */\n    size_t abbrev_len = strlen(AbbrevStr);\n    fprintf(fp, \"UtAssert_GetCaseTypeAbbrev called: CaseType=%d, AbbrevStr_ptr=%p, Abbrev=\\\"%s\\\", AbbrevLen=%zu, PointerSize=%zu\\n\",\n            CaseType, (const void *)AbbrevStr, AbbrevStr, abbrev_len, sizeof(void *));\n\n    fclose(fp);\n}\n\n/* Probe helper to allow external callers to log and check a potential\n * strcpy scenario. Callers MUST provide the actual buffer sizes. If the\n * sizes are unknown, pass 0 for that size; the probe will log that the\n * size is unknown and will not perform unsafe reads.\n *\n * Signature:\n *   void UtAssert_Probe_Strcpy_Safety(char *dest, size_t dest_size,\n *                                     const char *src, size_t src_size)\n *\n * Behavior:\n * - Logs addresses and sizes.\n * - If src_size > 0, searches for NUL within src_size safely using memchr.\n * - If dest_size > 0 and src contains a NUL within src_size, compares\n *   the required copy length versus dest_size and logs a warning if the\n *   destination may be too small.\n */\nvoid UtAssert_Probe_Strcpy_Safety(char *dest, size_t dest_size, const char *src, size_t src_size)\n{\n    FILE *fp = fopen(\"/tmp/logs/2859.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    fprintf(fp, \"Probe_Strcpy_Safety: dest_ptr=%p, dest_size=%zu, src_ptr=%p, src_size=%zu\\n\",\n            (void *)dest, dest_size, (const void *)src, src_size);\n\n    if (src == NULL)\n    {\n        fprintf(fp, \"  WARNING: src is NULL\\n\");\n        fclose(fp);\n        return;\n    }\n\n    if (src_size == 0)\n    {\n        fprintf(fp, \"  INFO: src_size unknown; cannot safely determine NUL termination without risking out-of-bounds reads\\n\");\n        fprintf(fp, \"  ADVICE: Call UtAssert_Probe_Strcpy_Safety with accurate dest_size and src_size to enable safe checks\\n\");\n        fclose(fp);\n        return;\n    }\n\n    /* Search for NUL within the provided src_size only (safe bounded search). */\n    const void *nulpos = memchr(src, '\\0', src_size);\n    if (nulpos == NULL)\n    {\n        fprintf(fp, \"  RISK: No NUL found within the first %zu bytes of src (src may be unterminated)\\n\", src_size);\n        fprintf(fp, \"  CONSEQUENCE: strcpy(src, dest) would read past src bounds; copying would be unsafe\\n\");\n        fclose(fp);\n        return;\n    }\n\n    /* Compute actual source string length (within provided bounds). */\n    size_t src_len = (const char *)nulpos - src; /* number of bytes before NUL */\n    fprintf(fp, \"  INFO: src NUL found at offset %zu (within provided src_size) => src_len=%zu\\n\", src_len, src_len);\n\n    if (dest_size == 0)\n    {\n        fprintf(fp, \"  INFO: dest_size unknown; cannot determine if dest is large enough to hold src (including terminating NUL)\\n\");\n        fclose(fp);\n        return;\n    }\n\n    /* For a safe strcpy, dest_size must be > src_len (space for NUL). */\n    if (dest_size <= src_len)\n    {\n        fprintf(fp, \"  VIOLATION_POSSIBLE: dest_size=%zu <= src_len=%zu; copying src into dest may write out-of-bounds\\n\",\n                dest_size, src_len);\n    }\n    else\n    {\n        fprintf(fp, \"  OK: dest_size=%zu > src_len=%zu; dest appears large enough for a copy (including NUL)\\n\",\n                dest_size, src_len);\n    }\n\n    fclose(fp);\n}\n\n/* Original function with minimal probing added. The logic and return value\n * are preserved exactly; we only add logging after the abbreviation is\n * determined so control flow/state can be observed.\n */\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    /* Log the chosen abbreviation and related state for auditing and to\n     * provide evidence for potential string handling issues elsewhere.\n     */\n    UtAssert_Log_CaseInfo((int)CaseType, AbbrevStr);\n\n    return AbbrevStr;\n}\n"
}