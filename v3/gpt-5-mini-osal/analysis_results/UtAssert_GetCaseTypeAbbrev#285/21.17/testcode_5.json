{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to strrchr(File, '/') only checks that File is non-NULL but does not ensure that the object referenced by File is a null-terminated string or that its bounds are known. strrchr scans until it finds a '\\0', so if File points to a non-terminated buffer (or a pointer not to the start of a valid nul-terminated object) the function can read past the object's bounds, causing undefined behaviour. Example violation: caller passes a char buffer that is not null-terminated (e.g. filled fully without a terminating '\\0'); strrchr will continue reading beyond the buffer until a '\\0' is found, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_GetCaseTypeAbbrev code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2859.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_GetCaseTypeAbbrev as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_GetCaseTypeAbbrev:\n```c\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    return AbbrevStr;\n}\n```\n</target_code>\nPlease provide the modified UtAssert_GetCaseTypeAbbrev code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/*\n * Probe/logging helpers to capture control flow and state information.\n * Logs appended to /tmp/logs/2859.txt.\n * These helpers do not change the logic of UtAssert_GetCaseTypeAbbrev;\n * they only record which branch was taken and additional diagnostic\n * information useful to reproduce string-handling violations elsewhere.\n */\n\nstatic void UtAssert_LogMessage(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2859.txt\", \"a\");\n    if (!fp)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fputs(\"\\n\", fp);\n    fclose(fp);\n}\n\n/*\n * Log the chosen abbreviation and the numeric CaseType value.\n * The CaseType is cast to int for logging so this function can be\n * called without depending on the concrete enum definition.\n */\nstatic void UtAssert_ProbeCaseType(int CaseTypeValue, const char *AbbrevStr)\n{\n    UtAssert_LogMessage(\"[UtAssert] CaseType=%d -> Abbrev='%s'\", CaseTypeValue, AbbrevStr ? AbbrevStr : \"(null)\");\n}\n\n/*\n * Safe probe that simulates behavior of strrchr with an explicit buffer\n * length to detect whether calling strrchr on the given buffer would be\n * unsafe (because the buffer is not null-terminated within the provided\n * length). It logs pointer, length, null-termination status, and the\n * last occurrence index of the requested character (if found safely).\n *\n * This helper intentionally does NOT call any <string.h> functions that\n * might read beyond provided bounds; it scans up to buflen only.\n */\nstatic void UtAssert_ProbeBufferStrrchr(const char *buf, size_t buflen, char ch)\n{\n    if (buf == NULL)\n    {\n        UtAssert_LogMessage(\"[ProbeBuffer] buf=NULL, buflen=%zu, ch='0x%02x'\", buflen, (unsigned)ch);\n        UtAssert_LogMessage(\"[ProbeBuffer] Result: strrchr would be unsafe (NULL pointer)\");\n        return;\n    }\n\n    UtAssert_LogMessage(\"[ProbeBuffer] buf=%p, buflen=%zu, ch='0x%02x'\", (const void *)buf, buflen, (unsigned)ch);\n\n    /* Find the first null terminator within buflen */\n    size_t i;\n    size_t nul_index = (size_t)-1;\n    for (i = 0; i < buflen; ++i)\n    {\n        if (buf[i] == '\\0')\n        {\n            nul_index = i;\n            break;\n        }\n    }\n\n    if (nul_index == (size_t)-1)\n    {\n        /* Not null-terminated within the supplied buffer length */\n        UtAssert_LogMessage(\"[ProbeBuffer] No null-terminator found within buflen=%zu -> calling strrchr would be UNSAFE\", buflen);\n        return;\n    }\n\n    UtAssert_LogMessage(\"[ProbeBuffer] Null-terminator found at index %zu (string length=%zu)\", nul_index, nul_index);\n\n    /* Now find the last occurrence of ch safely within the string length */\n    ssize_t last_idx = -1;\n    for (i = 0; i < nul_index; ++i)\n    {\n        if (buf[i] == ch)\n        {\n            last_idx = (ssize_t)i;\n        }\n    }\n\n    if (last_idx >= 0)\n    {\n        UtAssert_LogMessage(\"[ProbeBuffer] Last occurrence of ch found at index %zd (safe)\", last_idx);\n    }\n    else\n    {\n        UtAssert_LogMessage(\"[ProbeBuffer] Character not found within string (safe)\");\n    }\n}\n\n/*\n * Original function with added probes. The logic/return value is\n * preserved exactly. The probes only record which branch was taken and\n * optionally provide buffer-safety diagnostics when called by test drivers.\n */\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    /* Probe: log the selected abbreviation and case type value. */\n    UtAssert_ProbeCaseType((int)CaseType, AbbrevStr);\n\n    /*\n     * Note: For the strrchr violation scenario reported by another agent,\n     * callers should invoke UtAssert_ProbeBufferStrrchr(buf, buflen, '/')\n     * to log whether a provided buffer is null-terminated within its\n     * known bounds and whether calling strrchr(buf, '/') would be safe.\n     * This helper is intentionally not called automatically here because\n     * the current function has no buffer parameter; it is provided so\n     * reproducer tools can call it with explicit buffer/length info.\n     */\n\n    return AbbrevStr;\n}\n"
}