{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe argument ReadSet is declared as OS_FdSet * in OS_SelectMultiple_Impl but is passed to OS_FdSet_ConvertIn_Impl as input only. If OS_FdSet_ConvertIn_Impl does not modify the pointed-to OS_FdSet, then ReadSet should be const-qualified (const OS_FdSet *ReadSet) and the called function should accept a const pointer. In that case the current code violates MISRA C 2023 Rule 8.13. (Same reasoning applies to WriteSet.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SelectMultiple_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/813.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SelectMultiple_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SelectMultiple_Impl:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SelectMultiple_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/*\n * Probe/logging helpers to record control flow and state relevant to\n * the potential MISRA Rule 8.13 violation. Logs are appended to\n * \"/tmp/logs/813.txt\".\n *\n * These helpers do not alter program logic and only write diagnostic\n * information to the file. They are small and self-contained so they\n * can be compiled in the same translation unit as OS_SelectMultiple_Impl.\n */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/813.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nstatic void probe_dump_bytes(const char *label, const void *ptr, size_t maxbytes)\n{\n    if (ptr == NULL)\n    {\n        probe_log(\"%s: NULL\", label);\n        return;\n    }\n\n    const unsigned char *p = (const unsigned char *)ptr;\n    size_t i;\n    /* Limit the amount of data to avoid excessively large logs */\n    if (maxbytes > 32U)\n    {\n        maxbytes = 32U;\n    }\n\n    /* Open file and write hex bytes inline using probe_log to keep atomicity */\n    {\n        char buf[128];\n        size_t off = 0;\n        off += snprintf(buf + off, sizeof(buf) - off, \"%s: %p bytes[\", label, ptr);\n        for (i = 0U; i < maxbytes && off + 3 < sizeof(buf); ++i)\n        {\n            off += snprintf(buf + off, sizeof(buf) - off, \"%02X\", (unsigned)p[i]);\n            if (i + 1U < maxbytes)\n            {\n                off += snprintf(buf + off, sizeof(buf) - off, \" \");\n            }\n        }\n        off += snprintf(buf + off, sizeof(buf) - off, \"]\");\n        probe_log(\"%s\", buf);\n    }\n}\n\n/*\n * Original function with added probe calls. The logic and flow are\n * preserved; probes only observe and log state. No behavior is\n * modified.\n */\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    probe_log(\"OS_SelectMultiple_Impl: entry ReadSet=%p WriteSet=%p msecs=%d\", (void *)ReadSet, (void *)WriteSet, (int)msecs);\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n\n    probe_log(\"fd_set initialized: rd_set=%p wr_set=%p\", (void *)&rd_set, (void *)&wr_set);\n\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        /* Log that we are about to call ConvertIn for the read set. */\n        probe_log(\"About to call OS_FdSet_ConvertIn_Impl for ReadSet=%p (maxfd=%d)\", (void *)ReadSet, maxfd);\n        /* Dump first bytes of the OS_FdSet to help determine whether the\n         * called function treats it as input-only. This is best-effort\n         * and limited to avoid large logs. */\n        probe_dump_bytes(\"ReadSet pre-ConvertIn\", ReadSet, sizeof(void *) * 4U);\n\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n\n        probe_log(\"OS_FdSet_ConvertIn_Impl returned %d (maxfd=%d) for ReadSet=%p\", return_code, maxfd, (void *)ReadSet);\n        /* Dump rd_set after conversion to capture what was set based on the input. */\n        probe_dump_bytes(\"rd_set post-ConvertIn (partial)\", &rd_set, sizeof(void *) * 4U);\n\n        if (return_code != OS_SUCCESS)\n        {\n            probe_log(\"OS_SelectMultiple_Impl: returning early due to ConvertIn(ReadSet) failure: %d\", return_code);\n            return return_code;\n        }\n    }\n    else\n    {\n        probe_log(\"ReadSet is NULL, skipping OS_FdSet_ConvertIn_Impl for read side\");\n    }\n\n    if (WriteSet != NULL)\n    {\n        /* Log that we are about to call ConvertIn for the write set. */\n        probe_log(\"About to call OS_FdSet_ConvertIn_Impl for WriteSet=%p (maxfd=%d)\", (void *)WriteSet, maxfd);\n        probe_dump_bytes(\"WriteSet pre-ConvertIn\", WriteSet, sizeof(void *) * 4U);\n\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n\n        probe_log(\"OS_FdSet_ConvertIn_Impl returned %d (maxfd=%d) for WriteSet=%p\", return_code, maxfd, (void *)WriteSet);\n        probe_dump_bytes(\"wr_set post-ConvertIn (partial)\", &wr_set, sizeof(void *) * 4U);\n\n        if (return_code != OS_SUCCESS)\n        {\n            probe_log(\"OS_SelectMultiple_Impl: returning early due to ConvertIn(WriteSet) failure: %d\", return_code);\n            return return_code;\n        }\n    }\n    else\n    {\n        probe_log(\"WriteSet is NULL, skipping OS_FdSet_ConvertIn_Impl for write side\");\n    }\n\n    if (maxfd >= 0)\n    {\n        probe_log(\"Calling OS_DoSelect with maxfd=%d\", maxfd);\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n        probe_log(\"OS_DoSelect returned %d\", return_code);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        probe_log(\"No valid file descriptors found (maxfd=%d), setting return_code=OS_ERR_INVALID_ID\", maxfd);\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            probe_log(\"About to call OS_FdSet_ConvertOut_Impl for ReadSet=%p\", (void *)ReadSet);\n            probe_dump_bytes(\"rd_set pre-ConvertOut (partial)\", &rd_set, sizeof(void *) * 4U);\n\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n\n            probe_dump_bytes(\"ReadSet post-ConvertOut\", ReadSet, sizeof(void *) * 4U);\n            probe_log(\"OS_FdSet_ConvertOut_Impl completed for ReadSet=%p\", (void *)ReadSet);\n        }\n        else\n        {\n            probe_log(\"ReadSet is NULL, skipping OS_FdSet_ConvertOut_Impl\");\n        }\n\n        if (WriteSet != NULL)\n        {\n            probe_log(\"About to call OS_FdSet_ConvertOut_Impl for WriteSet=%p\", (void *)WriteSet);\n            probe_dump_bytes(\"wr_set pre-ConvertOut (partial)\", &wr_set, sizeof(void *) * 4U);\n\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n\n            probe_dump_bytes(\"WriteSet post-ConvertOut\", WriteSet, sizeof(void *) * 4U);\n            probe_log(\"OS_FdSet_ConvertOut_Impl completed for WriteSet=%p\", (void *)WriteSet);\n        }\n        else\n        {\n            probe_log(\"WriteSet is NULL, skipping OS_FdSet_ConvertOut_Impl\");\n        }\n    }\n    else\n    {\n        probe_log(\"No ConvertOut calls because return_code != OS_SUCCESS (%d)\", return_code);\n    }\n\n    probe_log(\"OS_SelectMultiple_Impl: exit with return_code=%d\", return_code);\n    return return_code;\n}\n"
}