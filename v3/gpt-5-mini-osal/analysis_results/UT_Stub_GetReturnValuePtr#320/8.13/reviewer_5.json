{
  "user_message": "An agent A claimed that the following UT_Stub_GetReturnValuePtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_GetReturnValuePtr.\n```c\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer StubPtr is declared as UT_StubTableEntry_t * and is only used for read-only access (reading BasePtr, Position, ContentTypeStr) after assigning it from UT_GetStubEntry(FuncKey,...). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible (e.g. const UT_StubTableEntry_t *StubPtr). Because StubPtr is not const-qualified despite only being read, this fragment violates Rule 8.13. (If the design requires modifying the pointed object via StubPtr, then non-const is justified.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffd91b08358\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x561226080260\n  StubPtr->Data.Buff.BasePtr: 0x561242bedcb0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x561242bedcb0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffd91b08358\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x561226080260\n  StubPtr->Data.Buff.BasePtr: 0x561242bedcb0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x561242bedcb0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffd91b08358\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x561226080260\n  StubPtr->Data.Buff.BasePtr: 0x561242bedcb0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x561242bedcb0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffca8b4a968\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x55667382f960\n  StubPtr->Data.Buff.BasePtr: 0x5566793c2a80\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x5566793c2a80\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffca8b4a968\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x55667382f960\n  StubPtr->Data.Buff.BasePtr: 0x5566793c2a80\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x5566793c2a80\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffca8b4a968\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x55667382f960\n  StubPtr->Data.Buff.BasePtr: 0x5566793c2a80\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x5566793c2a80\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffdd7aa7208\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x5647029ece80\n  StubPtr->Data.Buff.BasePtr: 0x56471c092c40\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x56471c092c40\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffdd7aa7208\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x5647029ece80\n  StubPtr->Data.Buff.BasePtr: 0x56471c092c40\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x56471c092c40\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffc3d3dbba8\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x55ee28a350c0\n  StubPtr->Data.Buff.BasePtr: 0x55ee43ae1bd0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x55ee43ae1bd0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffc3d3dbba8\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x55ee28a350c0\n  StubPtr->Data.Buff.BasePtr: 0x55ee43ae1bd0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x55ee43ae1bd0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffdb09a4568\n  Requested ReturnSize: 4\n  Requested TypeName: osal_id_t\n  Obtained StubPtr: 0x557988d372e0\n  StubPtr->Data.Buff.BasePtr: 0x5579930f39a0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: osal_id_t\n  Return value matched expectations\n  Returning pointer: 0x5579930f39a0\nUT_Stub_GetReturnValuePtr ENTER\n  FuncKey: 0x7ffdb09a4548\n  Requested ReturnSize: 4\n  Requested TypeName: int32\n  Obtained StubPtr: 0x557988d37640\n  StubPtr->Data.Buff.BasePtr: 0x5579930f39c0\n  StubPtr->Data.Buff.Position: 4\n  StubPtr->Data.Buff.ContentTypeStr: int32\n  Return value matched expectations\n  Returning pointer: 0x5579930f39c0\nUT_Stub_\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown function StubPtr is only used for read-only access (reading members BasePtr, Position and ContentTypeStr) and therefore can and should be declared as a pointer to const (e.g. const UT_StubTableEntry_t *StubPtr) to satisfy MISRA C 2023 Rule 8.13. Converting the non-const result of UT_GetStubEntry to a pointer-to-const is a valid implicit conversion in C and does not affect the returned mutable BasePtr (ReturnPtr). The only reason not to make StubPtr const would be if the design intentionally requires modifying the pointed object via StubPtr, which is not the case in the provided code. Thus the agent A report is correct."
}