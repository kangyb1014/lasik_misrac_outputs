{
  "user_message": "An agent A claimed that the following UT_Stub_GetReturnValuePtr code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_GetReturnValuePtr.\n```c\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) with no checks that either pointer is non-NULL or that both point to valid NUL-terminated strings. Since ContentTypeStr is assigned directly from the caller in UT_Stub_RegisterReturnType (no copy or termination check), a malicious/erroneous caller could pass NULL, a non-NUL-terminated buffer, or a pointer to storage that has gone out of scope/been freed. In that case strcmp can read past the object bounds (or dereference NULL), violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55b3855f5e20 ReturnSize=4 TypeName_ptr=0x55b3856014d8\n[UT_STUB] StubPtr=0x55b385614d80 BasePtr=0x55b38e85bcb0 Position=4 ContentTypeStr_ptr=0x55b3856014d8\n[UT_STUB] About to compare TypeName_ptr=0x55b3856014d8 with ContentTypeStr_ptr=0x55b3856014d8 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55b38e85bcb0\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55b3855f5e20 ReturnSize=4 TypeName_ptr=0x55b3856014d8\n[UT_STUB] StubPtr=0x55b385614d80 BasePtr=0x55b38e85bcb0 Position=4 ContentTypeStr_ptr=0x55b3856014d8\n[UT_STUB] About to compare TypeName_ptr=0x55b3856014d8 with ContentTypeStr_ptr=0x55b3856014d8 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55b38e85bcb0\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55b3855f5e20 ReturnSize=4 TypeName_ptr=0x55b3856014d8\n[UT_STUB] StubPtr=0x55b385614d80 BasePtr=0x55b38e85bcb0 Position=4 ContentTypeStr_ptr=0x55b3856014d8\n[UT_STUB] About to compare TypeName_ptr=0x55b3856014d8 with ContentTypeStr_ptr=0x55b3856014d8 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55b38e85bcb0\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55c5cc6d355f ReturnSize=4 TypeName_ptr=0x55c5cc6e0425\n[UT_STUB] StubPtr=0x55c5cc6f6ec0 BasePtr=0x55c5cde75a80 Position=4 ContentTypeStr_ptr=0x55c5cc6e0425\n[UT_STUB] About to compare TypeName_ptr=0x55c5cc6e0425 with ContentTypeStr_ptr=0x55c5cc6e0425 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55c5cde75a80\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55c5cc6d355f ReturnSize=4 TypeName_ptr=0x55c5cc6e0425\n[UT_STUB] StubPtr=0x55c5cc6f6ec0 BasePtr=0x55c5cde75a80 Position=4 ContentTypeStr_ptr=0x55c5cc6e0425\n[UT_STUB] About to compare TypeName_ptr=0x55c5cc6e0425 with ContentTypeStr_ptr=0x55c5cc6e0425 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55c5cde75a80\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x55c5cc6d355f ReturnSize=4 TypeName_ptr=0x55c5cc6e0425\n[UT_STUB] StubPtr=0x55c5cc6f6ec0 BasePtr=0x55c5cde75a80 Position=4 ContentTypeStr_ptr=0x55c5cc6e0425\n[UT_STUB] About to compare TypeName_ptr=0x55c5cc6e0425 with ContentTypeStr_ptr=0x55c5cc6e0425 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x55c5cde75a80\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x56463ec1f9c1 ReturnSize=4 TypeName_ptr=0x56463ec2a4c0\n[UT_STUB] StubPtr=0x56463ec421e0 BasePtr=0x564677506c40 Position=4 ContentTypeStr_ptr=0x56463ec2a4c0\n[UT_STUB] About to compare TypeName_ptr=0x56463ec2a4c0 with ContentTypeStr_ptr=0x56463ec2a4c0 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x564677506c40\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x56463ec1f9c1 ReturnSize=4 TypeName_ptr=0x56463ec2a4c0\n[UT_STUB] StubPtr=0x56463ec421e0 BasePtr=0x564677506c40 Position=4 ContentTypeStr_ptr=0x56463ec2a4c0\n[UT_STUB] About to compare TypeName_ptr=0x56463ec2a4c0 with ContentTypeStr_ptr=0x56463ec2a4c0 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x564677506c40\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x5633df6a3f46 ReturnSize=4 TypeName_ptr=0x5633df6ae458\n[UT_STUB] StubPtr=0x5633df6c3cc0 BasePtr=0x56341c0a2bd0 Position=4 ContentTypeStr_ptr=0x5633df6ae458\n[UT_STUB] About to compare TypeName_ptr=0x5633df6ae458 with ContentTypeStr_ptr=0x5633df6ae458 using strcmp\n[UT_STUB] strcmp returned 0\n[UT_STUB] Exiting UT_Stub_GetReturnValuePtr with ReturnPtr=0x56341c0a2bd0\n[UT_STUB] Enter UT_Stub_GetReturnValuePtr: FuncKey=0x5633df6a3f46 ReturnSize=4 TypeName_ptr=0x5633df6ae458\n[UT_STUB] StubPtr=0x5633df6c3cc0 BasePtr=0x56341c0a2bd0 Position=4 ContentTypeStr_ptr=0x5633df6ae458\n[UT_STUB] About to compare TypeName_ptr=0x5633df6ae458 with ContentTypeStr_ptr=0x5633df6ae458 using strcmp\n[UT_STUB] strcmp returned 0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_GetReturnValuePtr:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The call to strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) in UT_Stub_GetReturnValuePtr is not preceded by checks that either pointer is non-NULL or that the pointed-to objects are valid NUL-terminated strings. From the provided code UT_Stub_RegisterReturnType simply stores the caller-supplied TypeName pointer into ContentTypeStr (no copy, no validation), so a malicious or erroneous caller could pass NULL, a non-NUL-terminated buffer, or a pointer to storage that has been freed/out of scope. In those cases strcmp can dereference NULL or read past the object bounds, which is exactly what MISRA C 2023 Rule 21.17 forbids. The runtime logs showing benign behaviour do not prove absence of the defect for all uses. Therefore the reported violation is correct."
}