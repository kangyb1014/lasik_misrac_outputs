{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of UT_DefaultStubImplWithArgs:\n```c\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function UT_DefaultStubImplWithArgs:\nbool UT_Stub_IsValueCompatible(const UT_RetvalConfigEntry_t *Rvc, const char *WantTypeName, UT_ValueGenre_t WantGenre)\n{\n    bool IsCompatible;\n\n    /* If the type names were specified on both sides, and they match, then the value is compatible */\n    if (Rvc->TypeName != NULL && WantTypeName != NULL)\n    {\n        IsCompatible = (strcmp(Rvc->TypeName, WantTypeName) == 0);\n    }\n    else\n    {\n        /* The types are not _directly_ assignable, but it could possibly be coerced */\n        IsCompatible = false;\n    }\n\n    /*\n     * As an alternative/fallback, if the value genre is known for both sides,\n     * check if coercion is a possibility.  For example, this could apply if the\n     * value was int32 on one side and int16 on the other.\n     */\n    if (!IsCompatible && Rvc->Genre != UT_ValueGenre_OPAQUE && Rvc->Genre == WantGenre)\n    {\n        /* Genre match - should be compatible, with a potential size adjustment */\n        IsCompatible = true;\n    }\n\n    return IsCompatible;\n}\n...\nbool UT_LoadRetval(void *ValuePtr, size_t ValueSize, const UT_RetvalBuf_t *Buf, UT_ValueGenre_t ValueGenre)\n{\n    switch (UT_GENRE_SIZE(ValueGenre, ValueSize))\n    {\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int8)):\n            *((int8 *)ValuePtr) = Buf->Integer;\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int16)):\n            *((int16 *)ValuePtr) = Buf->Integer;\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int32)):\n            *((int32 *)ValuePtr) = Buf->Integer;\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int64)):\n            *((int64 *)ValuePtr) = Buf->Integer;\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(float)):\n            *((float *)ValuePtr) = Buf->FloatingPt;\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(double)):\n            *((double *)ValuePtr) = Buf->FloatingPt;\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_POINTER, sizeof(void *)):\n            *((void **)ValuePtr) = Buf->Ptr;\n            break;\n\n        default:\n            return UtAssert_Failed(\"Cannot load return value - ValueSize not valid\");\n    }\n\n    return true;\n}\n...\n#define UtDebug(__VA_ARGS__) UtAssert_Message(UTASSERT_CASETYPE_DEBUG,__FILE__,__LINE__,__VA_ARGS__)\n...\n#define UtAssert_Failed(__VA_ARGS__) UtAssertEx(false,UtAssert_GetContext(),__FILE__,__LINE__,__VA_ARGS__)\n...\nbool IsVarg\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (StubPtr == NULL)\n{\n    UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n}\nelse\n{\n    StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n    StubPtr->FuncKey   = FuncKey;\n    Counter            = StubPtr->Data.Rc.Count;\n    ++StubPtr->Data.Rc.Count;\n    StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n}",
    "StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\nif (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n{\n    /* If a hook function was used, it is expected that this will override any configured retval */\n    if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n    {\n        memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n        StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n    }\n    else if (RvcPtr != NULL)\n    {\n        /*\n         * Opaque values allow for arbitrarily large return values, but size must match exactly\n         * to what is expected, it cannot be truncated or expanded if there is a mismatch\n         * between the test and the stub.  Conversely, numeric values can be size-adjusted\n         * if the test supplied one size but the stub needs a different size, such as 32-bit\n         * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n         * integer return values to be directly configured, so older test cases are likely to\n         * set a 32-bit value even if the return value is a different size.\n         */\n        if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n        {\n            if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n            {\n                UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n            }\n            else\n            {\n                memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n        else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                               RvcPtr->Data.Rvc.Genre))\n        {\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    if (StubPtr->Data.Buff.Position == 0)\n    {\n        /*\n         * This means that no suitable return value was configured for this call.\n         * The final fallback in this case is to zero-fill it.\n         *\n         * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n         * value - signed, unsigned, or float - it should become 0.\n         */\n        memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n        StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n    }\n}",
    "if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n{\n    UT_ClearStubEntry(RvcPtr);\n}",
    "default:\n    return UtAssert_Failed(\"Cannot load return value - ValueSize not valid\");",
    "if (FunctionName != NULL)\n{\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        RetcodeString = \"DEFAULT\";\n    }\n    else\n    {\n        /* Indicate that this invocation got a non-default return code */\n        RetcodeString = \"*SPECIAL*\";\n    }\n\n    UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n}",
    "StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\nif (StubPtr != NULL)\n{\n    if (StubPtr->Data.Cb.IsVarg)\n    {\n        va_copy(ArgListCopy, ArgList);\n        LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n            StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n        va_end(ArgListCopy);\n    }\n    else\n    {\n        LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n            StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n    }\n\n    GotInt32StatusFromHook        = true;\n    LocalContext.Int32StatusIsSet = true;\n}\nelse\n{\n    GotInt32StatusFromHook = false;\n}"
  ],
  "explanation": "Other code fragments were not selected because they are exercised or required for observable program behaviour and cannot be statically determined to be removable without changing runtime semantics:\n\n- Context handling (ContextTblPtr != NULL / memset(&LocalContext,0,...)) initializes LocalContext used throughout the function; removing it would alter return values and buffer handling.\n\n- RvcPtr = UT_Stub_FindRetvalConfig(...) and the subsequent UT_Stub_IsValueCompatible/UT_LoadRetval path populate LocalContext.Int32StatusCode from configured return-value entries; those assignments are read later and affect behaviour.\n\n- Counter manipulation and StubPtr->Data.Rc.Count increment are used to provide per-call counts to hooks/handlers; they affect hook inputs and must remain.\n\n- The final-handler invocation (UT_ENTRYTYPE_FINAL_HANDLER) calls externally-provided callbacks that may have side effects; those calls are externally visible and cannot be considered dead.\n\n- The UT_LoadRetval explicit cases for integer/float/pointer sizes perform actual stores into the caller-provided buffer; they affect function outputs and are therefore not dead.\n\n- The fallback zero-fill of return buffer (memset) is the defined behaviour when no return value is configured and thus cannot be removed without changing observable outputs.\n\n- Many branches depend on runtime configuration (stub table entries, callbacks, return-value configs). Because the presence/absence of those entries is determined at runtime, those branches cannot be statically marked as dead from the snippet alone.\n\nThe fragments reported above are those that appear potentially redundant/logging-only, unreachable/abort path, or contain assertions/returns that may never be hit or may be implemented as no-ops depending on build configuration; they therefore warrant investigation to determine if they constitute dead code under MISRA C 2023 Rule 2.2."
}