{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void UT_Probe_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/3019.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\nstatic void UT_Probe_LogReturnBufferState(const char *tag, const char *FunctionName, void *BasePtr,\n                                           unsigned long TotalSize, unsigned long Position,\n                                           void *RvcIndirectPtr, unsigned long RvcActualSz,\n                                           int RvcGenre, const char *ContentTypeStr, unsigned long Counter,\n                                           int GotInt32StatusFromHook, int32_t LocalInt32StatusCode)\n{\n    UT_Probe_Log(\"[UT_PROBE] %s: Function=%s, Counter=%lu, GotInt32FromHook=%d, LocalInt32=%ld\",\n                 tag, FunctionName ? FunctionName : \"(null)\", Counter, GotInt32FromHook,\n                 (long)LocalInt32StatusCode);\n\n    UT_Probe_Log(\"[UT_PROBE]   BasePtr=%p, TotalSize=%lu, Position=%lu\", BasePtr, TotalSize, Position);\n    UT_Probe_Log(\"[UT_PROBE]   RvcIndirectPtr=%p, RvcActualSz=%lu, RvcGenre=%d, ContentTypeStr=%s\",\n                 RvcIndirectPtr, RvcActualSz, RvcGenre, ContentTypeStr ? ContentTypeStr : \"(null)\");\n\n    if (BasePtr == NULL)\n    {\n        UT_Probe_Log(\"[UT_PROBE-ALERT] BasePtr is NULL -> potential out-of-bounds write if TotalSize > 0\");\n    }\n    if (TotalSize == 0)\n    {\n        UT_Probe_Log(\"[UT_PROBE] TotalSize is 0 (no write expected)\");\n    }\n}\n\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /* Log entry */\n    UT_Probe_Log(\"[UT_PROBE] Enter UT_DefaultStubImplWithArgs: FunctionName=%s, FuncKey=%p, DefaultRc=%ld\",\n                 FunctionName ? FunctionName : \"(null)\", (void *)FuncKey, (long)DefaultRc);\n\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n\n        UT_Probe_Log(\"[UT_PROBE] ContextTblPtr found. LocalContext.Int32StatusIsSet=%d, Int32StatusCode=%ld\",\n                     LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n        UT_Probe_Log(\"[UT_PROBE] No ContextTblPtr found. LocalContext zero-initialized.\");\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n    UT_Probe_Log(\"[UT_PROBE] RvcPtr=%p\", (void *)RvcPtr);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n        UT_Probe_Log(\"[UT_PROBE] Loaded retval from RvcPtr: Int32StatusIsSet=%d, Int32StatusCode=%ld\",\n                     LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n        UT_Probe_Log(\"[UT_PROBE] Using DefaultRc=%ld\", (long)DefaultRc);\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n        UT_Probe_Log(\"[UT_PROBE] UtDebug: %s called (%s,%ld)\", FunctionName, RetcodeString,\n                     (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        UT_Probe_Log(\"[UT_PROBE] Counter entry set: Counter=%lu, NewCount=%lu, Rc.Value=%ld\",\n                     (unsigned long)Counter, (unsigned long)StubPtr->Data.Rc.Count, (long)StubPtr->Data.Rc.Value);\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n\n        UT_Probe_Log(\"[UT_PROBE] Callback hook used. New Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n        UT_Probe_Log(\"[UT_PROBE] No callback hook present.\");\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        UT_Probe_Log(\"[UT_PROBE] Final handler invoked for Function=%s\", FunctionName ? FunctionName : \"(null)\");\n    }\n\n    /*\n     * Handle propagation of return code.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* Log initial state of return buffer */\n        UT_Probe_LogReturnBufferState(\"PRE_OP\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                      (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                      (unsigned long)StubPtr->Data.Buff.Position,\n                                      RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                      RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                      RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                      StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                      GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            UT_Probe_Log(\"[UT_PROBE] About to memcpy (hook-provided int32) BasePtr=%p, Size=%lu\",\n                         StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n\n            /* Probe log just before risky operation */\n            UT_Probe_LogReturnBufferState(\"BEFORE_MEMCPY_HOOK\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                          (unsigned long)StubPtr->Data.Buff.Position,\n                                          RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                          RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                          RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                          StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                          GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            UT_Probe_Log(\"[UT_PROBE] After memcpy (hook-provided int32): Position set to %lu\",\n                         (unsigned long)StubPtr->Data.Buff.Position);\n        }\n        else if (RvcPtr != NULL)\n        {\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                UT_Probe_Log(\"[UT_PROBE] OPAQUE retval path. StubBuf.TotalSize=%lu, Rvc.ActualSz=%lu\",\n                             (unsigned long)StubPtr->Data.Buff.TotalSize, (unsigned long)StubPtr->Data.Rvc.ActualSz);\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    UT_Probe_Log(\"[UT_PROBE] About to memcpy (opaque) BasePtr=%p, Size=%lu, Src=%p\",\n                                 StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                 (void *)StubPtr->Data.Rvc.Buf.IndirectPtr);\n\n                    UT_Probe_LogReturnBufferState(\"BEFORE_MEMCPY_OPAQUE\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                                  (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                                  (unsigned long)StubPtr->Data.Buff.Position,\n                                                  StubPtr->Data.Rvc.Buf.IndirectPtr,\n                                                  (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                                  (int)RvcPtr->Data.Rvc.Genre,\n                                                  StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                                  GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                    UT_Probe_Log(\"[UT_PROBE] After memcpy (opaque): Position set to %lu\",\n                                 (unsigned long)StubPtr->Data.Buff.Position);\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                UT_Probe_Log(\"[UT_PROBE] UT_LoadRetval succeeded. About to set Position to TotalSize=%lu\",\n                             (unsigned long)StubPtr->Data.Buff.TotalSize);\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /* Final fallback: zero-fill */\n            UT_Probe_Log(\"[UT_PROBE] No suitable return value configured. About to memset BasePtr=%p, Size=%lu\",\n                         StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n\n            UT_Probe_LogReturnBufferState(\"BEFORE_MEMSET_ZERO_FILL\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                          (unsigned long)StubPtr->Data.Buff.Position,\n                                          RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                          RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                          RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                          StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                          GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            UT_Probe_Log(\"[UT_PROBE] After memset zero-fill: Position set to %lu\",\n                         (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n        UT_Probe_Log(\"[UT_PROBE] Cleared deferred RvcPtr entry\");\n    }\n\n    UT_Probe_Log(\"[UT_PROBE] Exit UT_DefaultStubImplWithArgs: Returning Int32StatusCode=%ld\",\n                 (long)LocalContext.Int32StatusCode);\n\n    return LocalContext.Int32StatusCode;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpdg1zdgfr/src/ut_assert/src/utstubs.c: In function 'UT_Probe_LogReturnBufferState':\n/tmp/tmpdg1zdgfr/src/ut_assert/src/utstubs.c:1068:72: error: 'GotInt32FromHook' undeclared (first use in this function); did you mean 'GotInt32StatusFromHook'?\n 1068 |                  tag, FunctionName ? FunctionName : \"(null)\", Counter, GotInt32FromHook,\n      |                                                                        ^~~~~~~~~~~~~~~~\n      |                                                                        GotInt32StatusFromHook\n/tmp/tmpdg1zdgfr/src/ut_assert/src/utstubs.c:1068:72: note: each undeclared identifier is reported only once for each function it appears in\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:104: ut_assert/CMakeFiles/ut_assert.dir/src/utstubs.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UT_DefaultStubImplWithArgs as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void UT_Probe_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/3019.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\nstatic void UT_Probe_LogReturnBufferState(const char *tag, const char *FunctionName, void *BasePtr,\n                                           unsigned long TotalSize, unsigned long Position,\n                                           void *RvcIndirectPtr, unsigned long RvcActualSz,\n                                           int RvcGenre, const char *ContentTypeStr, unsigned long Counter,\n                                           int GotInt32FromHook, int32_t LocalInt32StatusCode)\n{\n    UT_Probe_Log(\"[UT_PROBE] %s: Function=%s, Counter=%lu, GotInt32FromHook=%d, LocalInt32=%ld\",\n                 tag, FunctionName ? FunctionName : \"(null)\", Counter, GotInt32FromHook,\n                 (long)LocalInt32StatusCode);\n\n    UT_Probe_Log(\"[UT_PROBE]   BasePtr=%p, TotalSize=%lu, Position=%lu\", BasePtr, TotalSize, Position);\n    UT_Probe_Log(\"[UT_PROBE]   RvcIndirectPtr=%p, RvcActualSz=%lu, RvcGenre=%d, ContentTypeStr=%s\",\n                 RvcIndirectPtr, RvcActualSz, RvcGenre, ContentTypeStr ? ContentTypeStr : \"(null)\");\n\n    if (BasePtr == NULL)\n    {\n        UT_Probe_Log(\"[UT_PROBE-ALERT] BasePtr is NULL -> potential out-of-bounds write if TotalSize > 0\");\n    }\n    if (TotalSize == 0)\n    {\n        UT_Probe_Log(\"[UT_PROBE] TotalSize is 0 (no write expected)\");\n    }\n}\n\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /* Log entry */\n    UT_Probe_Log(\"[UT_PROBE] Enter UT_DefaultStubImplWithArgs: FunctionName=%s, FuncKey=%p, DefaultRc=%ld\",\n                 FunctionName ? FunctionName : \"(null)\", (void *)FuncKey, (long)DefaultRc);\n\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n\n        UT_Probe_Log(\"[UT_PROBE] ContextTblPtr found. LocalContext.Int32StatusIsSet=%d, Int32StatusCode=%ld\",\n                     LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n        UT_Probe_Log(\"[UT_PROBE] No ContextTblPtr found. LocalContext zero-initialized.\");\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n    UT_Probe_Log(\"[UT_PROBE] RvcPtr=%p\", (void *)RvcPtr);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n        UT_Probe_Log(\"[UT_PROBE] Loaded retval from RvcPtr: Int32StatusIsSet=%d, Int32StatusCode=%ld\",\n                     LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n        UT_Probe_Log(\"[UT_PROBE] Using DefaultRc=%ld\", (long)DefaultRc);\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n        UT_Probe_Log(\"[UT_PROBE] UtDebug: %s called (%s,%ld)\", FunctionName, RetcodeString,\n                     (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        UT_Probe_Log(\"[UT_PROBE] Counter entry set: Counter=%lu, NewCount=%lu, Rc.Value=%ld\",\n                     (unsigned long)Counter, (unsigned long)StubPtr->Data.Rc.Count, (long)StubPtr->Data.Rc.Value);\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n\n        UT_Probe_Log(\"[UT_PROBE] Callback hook used. New Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n        UT_Probe_Log(\"[UT_PROBE] No callback hook present.\");\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        UT_Probe_Log(\"[UT_PROBE] Final handler invoked for Function=%s\", FunctionName ? FunctionName : \"(null)\");\n    }\n\n    /*\n     * Handle propagation of return code.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* Log initial state of return buffer */\n        UT_Probe_LogReturnBufferState(\"PRE_OP\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                      (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                      (unsigned long)StubPtr->Data.Buff.Position,\n                                      RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                      RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                      RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                      StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                      GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            UT_Probe_Log(\"[UT_PROBE] About to memcpy (hook-provided int32) BasePtr=%p, Size=%lu\",\n                         StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n\n            /* Probe log just before risky operation */\n            UT_Probe_LogReturnBufferState(\"BEFORE_MEMCPY_HOOK\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                          (unsigned long)StubPtr->Data.Buff.Position,\n                                          RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                          RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                          RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                          StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                          GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            UT_Probe_Log(\"[UT_PROBE] After memcpy (hook-provided int32): Position set to %lu\",\n                         (unsigned long)StubPtr->Data.Buff.Position);\n        }\n        else if (RvcPtr != NULL)\n        {\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                UT_Probe_Log(\"[UT_PROBE] OPAQUE retval path. StubBuf.TotalSize=%lu, Rvc.ActualSz=%lu\",\n                             (unsigned long)StubPtr->Data.Buff.TotalSize, (unsigned long)StubPtr->Data.Rvc.ActualSz);\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    UT_Probe_Log(\"[UT_PROBE] About to memcpy (opaque) BasePtr=%p, Size=%lu, Src=%p\",\n                                 StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                 (void *)StubPtr->Data.Rvc.Buf.IndirectPtr);\n\n                    UT_Probe_LogReturnBufferState(\"BEFORE_MEMCPY_OPAQUE\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                                  (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                                  (unsigned long)StubPtr->Data.Buff.Position,\n                                                  StubPtr->Data.Rvc.Buf.IndirectPtr,\n                                                  (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                                  (int)RvcPtr->Data.Rvc.Genre,\n                                                  StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                                  GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                    UT_Probe_Log(\"[UT_PROBE] After memcpy (opaque): Position set to %lu\",\n                                 (unsigned long)StubPtr->Data.Buff.Position);\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                UT_Probe_Log(\"[UT_PROBE] UT_LoadRetval succeeded. About to set Position to TotalSize=%lu\",\n                             (unsigned long)StubPtr->Data.Buff.TotalSize);\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /* Final fallback: zero-fill */\n            UT_Probe_Log(\"[UT_PROBE] No suitable return value configured. About to memset BasePtr=%p, Size=%lu\",\n                         StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n\n            UT_Probe_LogReturnBufferState(\"BEFORE_MEMSET_ZERO_FILL\", FunctionName, StubPtr->Data.Buff.BasePtr,\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                          (unsigned long)StubPtr->Data.Buff.Position,\n                                          RvcPtr ? RvcPtr->Data.Rvc.Buf.IndirectPtr : NULL,\n                                          RvcPtr ? (unsigned long)RvcPtr->Data.Rvc.ActualSz : 0UL,\n                                          RvcPtr ? (int)RvcPtr->Data.Rvc.Genre : -1,\n                                          StubPtr->Data.Buff.ContentTypeStr, (unsigned long)Counter,\n                                          GotInt32StatusFromHook, LocalContext.Int32StatusCode);\n\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n            UT_Probe_Log(\"[UT_PROBE] After memset zero-fill: Position set to %lu\",\n                         (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n        UT_Probe_Log(\"[UT_PROBE] Cleared deferred RvcPtr entry\");\n    }\n\n    UT_Probe_Log(\"[UT_PROBE] Exit UT_DefaultStubImplWithArgs: Returning Int32StatusCode=%ld\",\n                 (long)LocalContext.Int32StatusCode);\n\n    return LocalContext.Int32StatusCode;\n}\n",
  "explanation": "Fixed an identifier mismatch in UT_Probe_LogReturnBufferState: the function parameter was named GotInt32StatusFromHook but calls and logs used GotInt32FromHook. I renamed the parameter to GotInt32FromHook so the name matches usages. No other logic was changed."
}