{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void UT_DefaultStubImplWithArgs_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/3013.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    UT_DefaultStubImplWithArgs_Log(\"ENTER: UT_DefaultStubImplWithArgs FunctionName=%p FuncKey=%lu DefaultRc=%ld\", (const void *)FunctionName, (unsigned long)FuncKey, (long)DefaultRc);\n    if (FunctionName != NULL)\n    {\n        /* Log the actual function name string if available */\n        UT_DefaultStubImplWithArgs_Log(\"FunctionName str=%s\", FunctionName);\n    }\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    UT_DefaultStubImplWithArgs_Log(\"ContextTblPtr lookup -> %p\", (void *)ContextTblPtr);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_DefaultStubImplWithArgs_Log(\"Clearing context entry at %p\", (void *)ContextTblPtr);\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n        UT_DefaultStubImplWithArgs_Log(\"No context entry found; LocalContext zeroed\");\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n    UT_DefaultStubImplWithArgs_Log(\"RvcPtr lookup -> %p\", (void *)RvcPtr);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        UT_DefaultStubImplWithArgs_Log(\"RvcPtr->Data.Rvc appears compatible with int32; Genre=%d ActualSz=%lu Buf.IndirectPtr=%p\",\n                                      (int)RvcPtr->Data.Rvc.Genre,\n                                      (unsigned long)RvcPtr->Data.Rvc.ActualSz,\n                                      (void *)RvcPtr->Data.Rvc.Buf.IndirectPtr);\n\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n\n        UT_DefaultStubImplWithArgs_Log(\"Loaded retval -> Int32StatusIsSet=%d Int32StatusCode=%ld\",\n                                      (int)LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        UT_DefaultStubImplWithArgs_Log(\"No compatible Rvc retval for int32 or RvcPtr==NULL\");\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n        UT_DefaultStubImplWithArgs_Log(\"Using DefaultRc -> Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"DEBUG: %s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    UT_DefaultStubImplWithArgs_Log(\"Counter StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        UT_DefaultStubImplWithArgs_Log(\"Counter StubPtr unused lookup -> %p\", (void *)StubPtr);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        UT_DefaultStubImplWithArgs_Log(\"Counter assigned -> StubPtr=%p FuncKey=%lu Counter=%lu NewCount=%lu StoredValue=%ld\",\n                                      (void *)StubPtr, (unsigned long)StubPtr->FuncKey,\n                                      (unsigned long)Counter, (unsigned long)StubPtr->Data.Rc.Count,\n                                      (long)StubPtr->Data.Rc.Value);\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    UT_DefaultStubImplWithArgs_Log(\"Hook StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Hook found IsVarg=%d CallbackArg=%p Ptr=%p\",\n                                      (int)StubPtr->Data.Cb.IsVarg,\n                                      (void *)StubPtr->Data.Cb.CallbackArg,\n                                      (void *)StubPtr->Data.Cb.Ptr);\n\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            UT_DefaultStubImplWithArgs_Log(\"Calling VaHook at %p with Counter=%lu Int32StatusCode=%ld\",\n                                          (void *)StubPtr->Data.Cb.Ptr.VaHook, (unsigned long)Counter,\n                                          (long)LocalContext.Int32StatusCode);\n\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Calling SimpleHook at %p with Counter=%lu Int32StatusCode=%ld\",\n                                          (void *)StubPtr->Data.Cb.Ptr.SimpleHook, (unsigned long)Counter,\n                                          (long)LocalContext.Int32StatusCode);\n\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"Hook returned -> Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n        UT_DefaultStubImplWithArgs_Log(\"No hook found; GotInt32StatusFromHook=false\");\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    UT_DefaultStubImplWithArgs_Log(\"Final handler StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Final handler IsVarg=%d Ptr=%p CallbackArg=%p\",\n                                      (int)StubPtr->Data.Cb.IsVarg,\n                                      (void *)StubPtr->Data.Cb.Ptr,\n                                      (void *)StubPtr->Data.Cb.CallbackArg);\n\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"Final handler completed\");\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    UT_DefaultStubImplWithArgs_Log(\"Return buffer StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Return buffer present BasePtr=%p TotalSize=%lu Position=%lu ContentTypeStr=%p\",\n                                      (void *)StubPtr->Data.Buff.BasePtr,\n                                      (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                      (unsigned long)StubPtr->Data.Buff.Position,\n                                      (void *)StubPtr->Data.Buff.ContentTypeStr);\n\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Copying hook-provided Int32StatusCode to return buffer\");\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Attempting to use RvcPtr to populate return buffer; RvcPtr=%p Genre=%d ActualSz=%lu\",\n                                          (void *)RvcPtr, (int)RvcPtr->Data.Rvc.Genre, (unsigned long)RvcPtr->Data.Rvc.ActualSz);\n\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                UT_DefaultStubImplWithArgs_Log(\"Rvc is OPAQUE: StubPtr->Data.Rvc.ActualSz=%lu Buff.TotalSize=%lu ContentTypeStr=%p\",\n                                              (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                              (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                              (void *)StubPtr->Data.Buff.ContentTypeStr);\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UT_DefaultStubImplWithArgs_Log(\"Opaque size mismatch: expected %lu got %lu type=%s\",\n                                                  (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                                  (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                                  StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\");\n\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                    UT_DefaultStubImplWithArgs_Log(\"Opaque copy completed; Position set to %lu\", (unsigned long)StubPtr->Data.Buff.Position);\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                UT_DefaultStubImplWithArgs_Log(\"Loaded retval into buffer via UT_LoadRetval; Position=%lu\",\n                                              (unsigned long)StubPtr->Data.Buff.Position);\n            }\n            else\n            {\n                UT_DefaultStubImplWithArgs_Log(\"Rvc present but UT_LoadRetval failed to populate buffer\");\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            UT_DefaultStubImplWithArgs_Log(\"No return value configured; zero-filling return buffer of size %lu\",\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize);\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Clearing deferred RvcPtr at %p\", (void *)RvcPtr);\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    UT_DefaultStubImplWithArgs_Log(\"EXIT: returning Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    return LocalContext.Int32StatusCode;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp4mr9_m5e/src/ut_assert/src/utstubs.c: In function 'UT_DefaultStubImplWithArgs':\n/tmp/tmp4mr9_m5e/src/ut_assert/src/utstubs.c:1184:39: error: cannot convert to a pointer type\n 1184 |                                       (void *)StubPtr->Data.Cb.Ptr);\n      |                                       ^\n/tmp/tmp4mr9_m5e/src/ut_assert/src/utstubs.c:1223:39: error: cannot convert to a pointer type\n 1223 |                                       (void *)StubPtr->Data.Cb.Ptr,\n      |                                       ^\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:104: ut_assert/CMakeFiles/ut_assert.dir/src/utstubs.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UT_DefaultStubImplWithArgs as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void UT_DefaultStubImplWithArgs_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/3013.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    UT_DefaultStubImplWithArgs_Log(\"ENTER: UT_DefaultStubImplWithArgs FunctionName=%p FuncKey=%lu DefaultRc=%ld\", (const void *)FunctionName, (unsigned long)FuncKey, (long)DefaultRc);\n    if (FunctionName != NULL)\n    {\n        /* Log the actual function name string if available */\n        UT_DefaultStubImplWithArgs_Log(\"FunctionName str=%s\", FunctionName);\n    }\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    UT_DefaultStubImplWithArgs_Log(\"ContextTblPtr lookup -> %p\", (void *)ContextTblPtr);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_DefaultStubImplWithArgs_Log(\"Clearing context entry at %p\", (void *)ContextTblPtr);\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n        UT_DefaultStubImplWithArgs_Log(\"No context entry found; LocalContext zeroed\");\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n    UT_DefaultStubImplWithArgs_Log(\"RvcPtr lookup -> %p\", (void *)RvcPtr);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        UT_DefaultStubImplWithArgs_Log(\"RvcPtr->Data.Rvc appears compatible with int32; Genre=%d ActualSz=%lu Buf.IndirectPtr=%p\",\n                                      (int)RvcPtr->Data.Rvc.Genre,\n                                      (unsigned long)RvcPtr->Data.Rvc.ActualSz,\n                                      (void *)RvcPtr->Data.Rvc.Buf.IndirectPtr);\n\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n\n        UT_DefaultStubImplWithArgs_Log(\"Loaded retval -> Int32StatusIsSet=%d Int32StatusCode=%ld\",\n                                      (int)LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n    }\n    else\n    {\n        UT_DefaultStubImplWithArgs_Log(\"No compatible Rvc retval for int32 or RvcPtr==NULL\");\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n        UT_DefaultStubImplWithArgs_Log(\"Using DefaultRc -> Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"DEBUG: %s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    UT_DefaultStubImplWithArgs_Log(\"Counter StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        UT_DefaultStubImplWithArgs_Log(\"Counter StubPtr unused lookup -> %p\", (void *)StubPtr);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        UT_DefaultStubImplWithArgs_Log(\"Counter assigned -> StubPtr=%p FuncKey=%lu Counter=%lu NewCount=%lu StoredValue=%ld\",\n                                      (void *)StubPtr, (unsigned long)StubPtr->FuncKey,\n                                      (unsigned long)Counter, (unsigned long)StubPtr->Data.Rc.Count,\n                                      (long)StubPtr->Data.Rc.Value);\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    UT_DefaultStubImplWithArgs_Log(\"Hook StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL)\n    {\n        /* Note: printing the address of a function pointer object rather than converting the\n         * function pointer itself to void*.  Direct conversion from a function pointer to\n         * data pointer types is not strictly allowed in C, thus take the address of the\n         * function pointer storage for logging. */\n        UT_DefaultStubImplWithArgs_Log(\"Hook found IsVarg=%d CallbackArg=%p Ptr=%p\",\n                                      (int)StubPtr->Data.Cb.IsVarg,\n                                      (void *)StubPtr->Data.Cb.CallbackArg,\n                                      (const void *)&StubPtr->Data.Cb.Ptr);\n\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            UT_DefaultStubImplWithArgs_Log(\"Calling VaHook at %p with Counter=%lu Int32StatusCode=%ld\",\n                                          (const void *)&StubPtr->Data.Cb.Ptr.VaHook, (unsigned long)Counter,\n                                          (long)LocalContext.Int32StatusCode);\n\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Calling SimpleHook at %p with Counter=%lu Int32StatusCode=%ld\",\n                                          (const void *)&StubPtr->Data.Cb.Ptr.SimpleHook, (unsigned long)Counter,\n                                          (long)LocalContext.Int32StatusCode);\n\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"Hook returned -> Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n        UT_DefaultStubImplWithArgs_Log(\"No hook found; GotInt32StatusFromHook=false\");\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    UT_DefaultStubImplWithArgs_Log(\"Final handler StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Final handler IsVarg=%d Ptr=%p CallbackArg=%p\",\n                                      (int)StubPtr->Data.Cb.IsVarg,\n                                      (const void *)&StubPtr->Data.Cb.Ptr,\n                                      (void *)StubPtr->Data.Cb.CallbackArg);\n\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        UT_DefaultStubImplWithArgs_Log(\"Final handler completed\");\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    UT_DefaultStubImplWithArgs_Log(\"Return buffer StubPtr lookup -> %p\", (void *)StubPtr);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Return buffer present BasePtr=%p TotalSize=%lu Position=%lu ContentTypeStr=%p\",\n                                      (void *)StubPtr->Data.Buff.BasePtr,\n                                      (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                      (unsigned long)StubPtr->Data.Buff.Position,\n                                      (void *)StubPtr->Data.Buff.ContentTypeStr);\n\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Copying hook-provided Int32StatusCode to return buffer\");\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            UT_DefaultStubImplWithArgs_Log(\"Attempting to use RvcPtr to populate return buffer; RvcPtr=%p Genre=%d ActualSz=%lu\",\n                                          (void *)RvcPtr, (int)RvcPtr->Data.Rvc.Genre, (unsigned long)RvcPtr->Data.Rvc.ActualSz);\n\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                UT_DefaultStubImplWithArgs_Log(\"Rvc is OPAQUE: StubPtr->Data.Rvc.ActualSz=%lu Buff.TotalSize=%lu ContentTypeStr=%p\",\n                                              (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                              (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                              (void *)StubPtr->Data.Buff.ContentTypeStr);\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UT_DefaultStubImplWithArgs_Log(\"Opaque size mismatch: expected %lu got %lu type=%s\",\n                                                  (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                                  (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                                  StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\");\n\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                    UT_DefaultStubImplWithArgs_Log(\"Opaque copy completed; Position set to %lu\", (unsigned long)StubPtr->Data.Buff.Position);\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                UT_DefaultStubImplWithArgs_Log(\"Loaded retval into buffer via UT_LoadRetval; Position=%lu\",\n                                              (unsigned long)StubPtr->Data.Buff.Position);\n            }\n            else\n            {\n                UT_DefaultStubImplWithArgs_Log(\"Rvc present but UT_LoadRetval failed to populate buffer\");\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            UT_DefaultStubImplWithArgs_Log(\"No return value configured; zero-filling return buffer of size %lu\",\n                                          (unsigned long)StubPtr->Data.Buff.TotalSize);\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_DefaultStubImplWithArgs_Log(\"Clearing deferred RvcPtr at %p\", (void *)RvcPtr);\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    UT_DefaultStubImplWithArgs_Log(\"EXIT: returning Int32StatusCode=%ld\", (long)LocalContext.Int32StatusCode);\n    return LocalContext.Int32StatusCode;\n}\n",
  "explanation": "The build errors were caused by attempts to cast function pointers to (void *) for logging. Converting a function pointer to a data pointer is not allowed in portable C and some compilers reject it. I changed those log arguments to take the address of the function-pointer storage (e.g., (const void *)&StubPtr->Data.Cb.Ptr.VaHook or (const void *)&StubPtr->Data.Cb.Ptr) so the code prints a pointer to the function-pointer object instead of attempting to convert the function pointer itself. This preserves the original logic while avoiding invalid casts that caused the compilation errors."
}