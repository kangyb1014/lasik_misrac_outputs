{
  "user_message": "Target function code is:\n```c\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_DefaultStubImplWithArgs': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry', 'UT_Stub_FindRetvalConfig', 'UtAssert_Message', 'UtAssert_Abort', 'UtAssert_GetContext'], 'callers': ['UT_DefaultStubImpl', 'UT_ExecuteVaHandler']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_Stub_FindRetvalConfig': {'callees': ['UT_GetStubEntry'], 'callers': ['UT_DefaultStubImplWithArgs']}, 'UtAssert_Message': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_DefaultStubImplWithArgs', 'UT_DefaultHandler_OS_printf']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UtAssert_GetContext': {'callees': [], 'callers': ['UtAssert', 'UT_StoreRetval', 'UT_LoadRetval', 'UT_SetDeferredRetcode', 'UT_Stub_GetReturnValuePtr', 'UT_Hook_GetArgPtr', 'UT_DefaultStubImplWithArgs', 'UtMem2BinFile', 'UtBinFile2Mem', 'UtMem2HexFile', 'UtMem2BinFileCmp', 'UT_AllocStubObjId', 'UT_DeleteStubObjId']}, 'UT_DefaultStubImpl': {'callees': ['UT_DefaultStubImplWithArgs'], 'callers': ['UT_ExecuteBasicHandler', 'dummy_function']}, 'UT_ExecuteVaHandler': {'callees': ['UT_GetStubEntry', 'UT_SetVaHandlerFunction', 'UT_DefaultStubImplWithArgs'], 'callers': ['OS_printf']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "UT_Stub_FindRetvalConfig",
    "UT_Stub_IsValueCompatible",
    "UT_LoadRetval",
    "UT_StubTableEntry_t (type)",
    "UT_StubContext_t (type)",
    "UT_ValueGenre (enum) -- at least UT_ValueGenre_INTEGER and UT_ValueGenre_OPAQUE",
    "UT_ENTRYTYPE_* constants (UT_ENTRYTYPE_CALLBACK_CONTEXT, UT_ENTRYTYPE_COUNTER, UT_ENTRYTYPE_UNUSED, UT_ENTRYTYPE_CALLBACK_HOOK, UT_ENTRYTYPE_FINAL_HANDLER, UT_ENTRYTYPE_RETURN_BUFFER, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)",
    "Definitions of UT_StubTableEntry_t->Data substructures referenced in the code: Rvc (fields: Genre, ActualSz, Buf and Buf.IndirectPtr), Buff (fields: BasePtr, Position, TotalSize, ContentTypeStr), Cb (fields: IsVarg, Ptr.{VaHook,SimpleHook,VaHandler,SimpleHandler}, CallbackArg), Rc (fields: Count, Value), and Context (the UT_StubContext_t stored there)",
    "Prototypes / semantics of hook/handler callbacks (signatures and return types) used via Data.Cb.Ptr (VaHook, SimpleHook, VaHandler, SimpleHandler)",
    "UT_DefaultStubImpl (caller)",
    "UT_ExecuteVaHandler (caller)"
  ],
  "explanation": "Purpose of each symbol and why it is required for MISRA C Rule analysis:\n\n- UT_GetStubEntry\n  - Many controlling expressions compare returned pointer values (e.g., if (ContextTblPtr != NULL), if (StubPtr == NULL), repeated UT_GetStubEntry calls). To decide whether those conditions can be compile-time or analysis-time invariants you must know the semantics of UT_GetStubEntry (when it can return NULL, whether it can be guaranteed non-NULL for a given FuncKey/entry type, side effects, or if it always returns a fixed pointer). Without its behavior you cannot conclude the controlling expressions are constant.\n\n- UT_ClearStubEntry\n  - This function is invoked after obtaining ContextTblPtr; it may alter the state that subsequent conditions depend on. Its semantics (whether it always clears/unregisters entries) affect whether later tests on the same entry could be invariant. To reason about invariance you need to know if UT_ClearStubEntry changes values that appear in controlling expressions.\n\n- UT_Stub_FindRetvalConfig\n  - The code uses RvcPtr = UT_Stub_FindRetvalConfig(FuncKey) and then tests RvcPtr != NULL. Whether that pointer is ever NULL (or always non-NULL) depends on this function. You must inspect it to determine if the controlling expression involving RvcPtr is invariant.\n\n- UT_Stub_IsValueCompatible\n  - Used inside a conjunction with (RvcPtr != NULL) to decide whether to call UT_LoadRetval. Whether UT_Stub_IsValueCompatible can return a constant (always true/always false) for a given Rvc contents affects whether the combined controlling expression is invariant. Its compatibility rules are required to decide if that branch is effectively constant.\n\n- UT_LoadRetval\n  - UT_LoadRetval is used both to set LocalContext.Int32StatusIsSet and later to populate Buff.BasePtr. Its return value (boolean-like) and side effects determine whether conditions like if (!LocalContext.Int32StatusIsSet) and later tests are dependent on runtime data or could be invariant. You need its semantics (when it returns true/false and whether it mutates buffers) to reason correctly.\n\n- UT_StubTableEntry_t (type) and UT_StubContext_t (type)\n  - Several controlling expressions dereference StubPtr or ContextTblPtr, e.g. StubPtr->Data.Cb.IsVarg, StubPtr->Data.Buff.Position == 0, StubPtr->Data.Buff.TotalSize == sizeof(...), RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED. To determine whether these member tests could be invariant you must know the layout and semantics of these types and whether the members are mutable or constant for a given entry. The type definitions (and any invariants implied by them) are required for static analysis.\n\n- UT_ValueGenre enum (UT_ValueGenre_INTEGER, UT_ValueGenre_OPAQUE)\n  - The code branches on RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE and passes UT_ValueGenre_INTEGER to UT_Stub_IsValueCompatible/UT_LoadRetval. The enum values and their meaning are necessary to decide if the genre-related comparisons are invariant for specific Retval configs.\n\n- UT_ENTRYTYPE_* constants (all entry type constants used)\n  - The calls to UT_GetStubEntry pass different entry types (e.g. UT_ENTRYTYPE_CALLBACK_CONTEXT, COUNTER, UNUSED, CALLBACK_HOOK, FINAL_HANDLER, RETURN_BUFFER). Whether UT_GetStubEntry returns different pointers or NULL depends on these constants and their semantics; knowledge of these constants and how the stub-table is indexed by them is needed to decide if the calls and resulting pointer tests are invariant.\n\n- Definitions of substructures under UT_StubTableEntry_t->Data (Rvc, Buff, Cb, Rc, Context)\n  - The code examines many fields: Rvc.Buf/ActualSz/Genre, Buff.Position/TotalSize/BasePtr/ContentTypeStr, Cb.IsVarg and callback pointers, Rc.Count/Value, and Context (Int32StatusCode/Int32StatusIsSet). To determine whether conditions such as (StubPtr->Data.Buff.Position == 0), (StubPtr->Data.Buff.TotalSize == sizeof(...)), (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(...)), or (RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED) are invariant, you must know how these fields are initialized and modified elsewhere (and whether some are constants), so their definitions and lifecycle are required.\n\n- Prototypes / semantics of hook/handler callbacks (VaHook, SimpleHook, VaHandler, SimpleHandler)\n  - The code decides which callback variant to call based on Data.Cb.IsVarg and then uses the return value of VaHook/SimpleHook to set LocalContext.Int32StatusCode and flags. Understanding whether invoking these callbacks can change state that affects subsequent controlling expressions (and whether the callbacks are pure/constant) is necessary to judge invariance of following tests.\n\n- UT_DefaultStubImpl and UT_ExecuteVaHandler (callers)\n  - Whether the parameter FunctionName is ever NULL (the function tests if (FunctionName != NULL)) depends on call sites. To determine if that condition is invariant you must inspect the callers (UT_DefaultStubImpl, UT_ExecuteVaHandler) and how they invoke UT_DefaultStubImplWithArgs (what they pass for FunctionName). If those callers always pass a non-NULL or always pass NULL FunctionName, the controlling expression becomes invariant; thus the callers must be examined.\n\nNote: I focused on symbols that affect the truth values of the controlling expressions present in the function (pointer null checks, boolean flags, enum comparisons and numeric equality tests). Other miscellaneous utility functions (memcpy, memset, va_copy/va_end, UtDebug, UtAssert_* message functions) do not affect whether the controlling expressions are invariant, so they were omitted."
}