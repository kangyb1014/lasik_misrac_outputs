{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_SymbolLookup:\n```c\nint32 OS_SymbolLookup(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32 return_code;\n    int32 staticsym_status;\n\n    /*\n    ** Check parameters\n    */\n    OS_CHECK_POINTER(SymbolAddress);\n    OS_CHECK_POINTER(SymbolName);\n\n    /*\n     * attempt to find the symbol in the symbol table\n     */\n    return_code = OS_SymbolLookup_Impl(SymbolAddress, SymbolName);\n\n    /*\n     * If the OS call did not find the symbol or the loader is\n     * disabled, then check if a static symbol table is present\n     */\n    if (return_code != OS_SUCCESS)\n    {\n        staticsym_status = OS_SymbolLookup_Static(SymbolAddress, SymbolName, NULL);\n\n        /*\n         * Only overwrite the return code if static lookup was successful.\n         * Otherwise keep the error code from the low level implementation.\n         */\n        if (staticsym_status == OS_SUCCESS)\n        {\n            return_code = staticsym_status;\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_SymbolLookup:\nint32 OS_SymbolLookup_Impl(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32            status;\n    int32            local_status;\n    OS_object_iter_t iter;\n\n    /* First search global table */\n    status = OS_GenericSymbolLookup_Impl(OSAL_DLSYM_DEFAULT_HANDLE, SymbolAddress, SymbolName);\n\n    /* If not found iterate through module local symbols and break if found */\n    if (status != OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(OS_OBJECT_TYPE_OS_MODULE, &iter);\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            local_status = OS_ModuleSymbolLookup_Impl(&iter.token, SymbolAddress, SymbolName);\n            if (local_status == OS_SUCCESS)\n            {\n                status = local_status;\n                break;\n            }\n        }\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return status;\n}\n...\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n            return_code = OS_ERROR;\n            break;\n        }\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    return return_code;\n}\n...\nvoid OS_printf(const char *String, ...)\n{\n    va_list va;\n    char    msg_buffer[OS_BUFFER_SIZE];\n    int     actualsz;\n\n    BUGCHECK_VOID(String != NULL)\n\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER)\n    {\n        /*\n         * Catch some historical mis-use of the OS_printf() call.\n         *\n         * Typically OS_printf() should NOT be called before OS_API_Init().\n         *\n         * This was never guaranteed to work, particularly on a VxWorks\n         * deployment where the utility task was enabled.\n         *\n         * However, some PSPs do this, particularly those that used POSIX\n         * where it happened to work (because OS_printf just called printf).\n         *\n         * As a workaround, use the OS_DEBUG facility to dump the message,\n         * along with a clue that this API is being used inappropriately.\n         *\n         * If debugging is not enabled, then this message will be silently\n         * discarded.\n         */\n        OS_DEBUG(\"BUG: OS_printf() called when OSAL not initialized: %s\", String);\n    }\n    else if (OS_SharedGlobalVars.PrintfEnabled)\n    {\n        /* Format and determine the size of string to write */\n        va_start(va, String);\n        actualsz = vsnprintf(msg_buffer, sizeof(msg_buffer), String, va);\n        va_end(va);\n\n        if (actualsz < 0)\n        {\n            /* unlikely: vsnprintf failed */\n            actualsz = 0;\n        }\n        else if (actualsz >= OS_BUFFER_SIZE)\n        {\n            /* truncate */\n            actualsz = OS_BUFFER_SIZE - 1;\n        }\n\n        msg_buffer[actualsz] = 0;\n\n        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer);\n    }\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n...\nvoid UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}\n...\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n...\nint32 OS_GenericSymbolLookup_Impl(void *dl_handle, cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    const char *dlError; /*  Pointer to error string   */\n    void *      Function;\n    int32       status;\n\n    status = OS_ERROR;\n\n    /*\n     * call dlerror() to clear any prior error that might have occurred.\n     */\n    dlerror();\n    Function = dlsym(dl_handle, SymbolName);\n    dlError  = dlerror();\n\n    /*\n     * For the POSIX DL implementation, if the symbol does not exist\n     * then dlerror() is supposed to return non-null.  This is intended\n     * to differentiate between valid symbols which are actually 0/NULL\n     * and invalid symbols that do not exist.\n     *\n     * Some implementations do _not_ implement this detail, and dlerror()\n     * still returns NULL after looking up an invalid symbol name.\n     *\n     * In practice, this is expected to be used for looking up functions\n     * and as such all valid symbols should be non-NULL, so NULL is considered\n     * an error even if the C library doesn't consider this an error.\n     */\n    if (dlError != NULL)\n    {\n        OS_DEBUG(\"Error: %s: %s\\n\", SymbolName, dlError);\n    }\n    else if (Function == NULL)\n    {\n        /* technically not an error per POSIX, but in practice should not happen */\n        OS_DEBUG(\"Error: %s: dlsym() returned NULL\\n\", SymbolName);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    *SymbolAddress = (cpuaddr)Function;\n\n    return status;\n}\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n...\nint32 OS_ModuleSymbolLookup_Impl(const OS_object_token_t *token, cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32                             status;\n    OS_impl_module_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_module_table, *token);\n\n    status = OS_GenericSymbolLookup_Impl(impl->dl_handle, SymbolAddress, SymbolName);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nint32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /*\n         * The entire string should be put to the ring buffer,\n         * or none of it.  Therefore the WritePos in the table\n         * is not updated until complete success.\n         */\n        PendingWritePos = console->WritePos;\n\n        if (console->device_name[0] != 0)\n        {\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            console->WritePos = PendingWritePos;\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n        }\n\n        /*\n         * Notify the underlying console implementation of new data.\n         * This will forward the data to the actual console device.\n         *\n         * This is done while still locked, so it can support\n         * either a synchronous or asynchronous implementation.\n         */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWakeup_Impl(&token);\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleOutput_Impl(&token);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nvoid UT_ExecuteVaHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_VaHandlerFunc_t DefaultHandler,\n                         va_list VaList)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetVaHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImplWithArgs(FunctionName, FuncKey, 0, VaList);\n}\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_SetHandlerFunction(UT_EntryKey_t FuncKey, UT_HandlerFunc_t HandlerFunc, void *UserObj)\n{\n    UT_HookFuncPtr_t Value;\n\n    Value.SimpleHandler = HandlerFunc;\n\n    UT_DoSetHookFunction(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER, Value, UserObj, false);\n}\n...\nint32 UT_DefaultStubImpl(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, ...)\n{\n    int32   Retcode;\n    va_list va;\n\n    va_start(va, DefaultRc);\n    Retcode = UT_DefaultStubImplWithArgs(FunctionName, FuncKey, DefaultRc, va);\n    va_end(va);\n\n    return Retcode;\n}\n...\nUtAssert_CaseType_t UtAssert_GetContext(void)\n{\n    return DefaultContext;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "int32 UT_DefaultStubImpl(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, ...)\n{\n    int32   Retcode;\n    va_list va;\n\n    va_start(va, DefaultRc);\n    Retcode = UT_DefaultStubImplWithArgs(FunctionName, FuncKey, DefaultRc, va);\n    va_end(va);\n\n    return Retcode;\n}",
    "void UT_SetHandlerFunction(UT_EntryKey_t FuncKey, UT_HandlerFunc_t HandlerFunc, void *UserObj)\n{\n    UT_HookFuncPtr_t Value;\n\n    Value.SimpleHandler = HandlerFunc;\n\n    UT_DoSetHookFunction(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER, Value, UserObj, false);\n}",
    "int32 OS_SymbolLookup_Impl(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32            status;\n    int32            local_status;\n    OS_object_iter_t iter;\n\n    /* First search global table */\n    status = OS_GenericSymbolLookup_Impl(OSAL_DLSYM_DEFAULT_HANDLE, SymbolAddress, SymbolName);\n\n    /* If not found iterate through module local symbols and break if found */\n    if (status != OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(OS_OBJECT_TYPE_OS_MODULE, &iter);\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            local_status = OS_ModuleSymbolLookup_Impl(&iter.token, SymbolAddress, SymbolName);\n            if (local_status == OS_SUCCESS)\n            {\n                status = local_status;\n                break;\n            }\n        }\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return status;\n}",
    "void UT_ExecuteVaHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_VaHandlerFunc_t DefaultHandler,\n                         va_list VaList)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetVaHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImplWithArgs(FunctionName, FuncKey, 0, VaList);\n}",
    "void *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}",
    "int32 OS_SymbolLookup(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32 return_code;\n    int32 staticsym_status;\n\n    /*\n    ** Check parameters\n    */\n    OS_CHECK_POINTER(SymbolAddress);\n    OS_CHECK_POINTER(SymbolName);\n\n    /*\n     * attempt to find the symbol in the symbol table\n     */\n    return_code = OS_SymbolLookup_Impl(SymbolAddress, SymbolName);\n\n    /*\n     * If the OS call did not find the symbol or the loader is\n     * disabled, then check if a static symbol table is present\n     */\n    if (return_code != OS_SUCCESS)\n    {\n        staticsym_status = OS_SymbolLookup_Static(SymbolAddress, SymbolName, NULL);\n\n        /*\n         * Only overwrite the return code if static lookup was successful.\n         * Otherwise keep the error code from the low level implementation.\n         */\n        if (staticsym_status == OS_SUCCESS)\n        {\n            return_code = staticsym_status;\n        }\n    }\n\n    return return_code;\n}",
    "void OS_printf(const char *String, ...)\n{\n    va_list va;\n    char    msg_buffer[OS_BUFFER_SIZE];\n    int     actualsz;\n\n    BUGCHECK_VOID(String != NULL)\n\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER)\n    {\n        /*\n         * Catch some historical mis-use of the OS_printf() call.\n         *\n         * Typically OS_printf() should NOT be called before OS_API_Init().\n         *\n         * This was never guaranteed to work, particularly on a VxWorks\n         * deployment where the utility task was enabled.\n         *\n         * However, some PSPs do this, particularly those that used POSIX\n         * where it happened to work (because OS_printf just called printf).\n         *\n         * As a workaround, use the OS_DEBUG facility to dump the message,\n         * along with a clue that this API is being used inappropriately.\n         *\n         * If debugging is not enabled, then this message will be silently\n         * discarded.\n         */\n        OS_DEBUG(\"BUG: OS_printf() called when OSAL not initialized: %s\", String);\n    }\n    else if (OS_SharedGlobalVars.PrintfEnabled)\n    {\n        /* Format and determine the size of string to write */\n        va_start(va, String);\n        actualsz = vsnprintf(msg_buffer, sizeof(msg_buffer), String, va);\n        va_end(va);\n\n        if (actualsz < 0)\n        {\n            /* unlikely: vsnprintf failed */\n            actualsz = 0;\n        }\n        else if (actualsz >= OS_BUFFER_SIZE)\n        {\n            /* truncate */\n            actualsz = OS_BUFFER_SIZE - 1;\n        }\n\n        msg_buffer[actualsz] = 0;\n\n        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer);\n    }\n}",
    "int32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /*\n         * The entire string should be put to the ring buffer,\n         * or none of it.  Therefore the WritePos in the table\n         * is not updated until complete success.\n         */\n        PendingWritePos = console->WritePos;\n\n        if (console->device_name[0] != 0)\n        {\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            console->WritePos = PendingWritePos;\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n        }\n\n        /*\n         * Notify the underlying console implementation of new data.\n         * This will forward the data to the actual console device.\n         *\n         * This is done while still locked, so it can support\n         * either a synchronous or asynchronous implementation.\n         */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWakeup_Impl(&token);\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleOutput_Impl(&token);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}",
    "int32 OS_GenericSymbolLookup_Impl(void *dl_handle, cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    const char *dlError; /*  Pointer to error string   */\n    void *      Function;\n    int32       status;\n\n    status = OS_ERROR;\n\n    /*\n     * call dlerror() to clear any prior error that might have occurred.\n     */\n    dlerror();\n    Function = dlsym(dl_handle, SymbolName);\n    dlError  = dlerror();\n\n    /*\n     * For the POSIX DL implementation, if the symbol does not exist\n     * then dlerror() is supposed to return non-null.  This is intended\n     * to differentiate between valid symbols which are actually 0/NULL\n     * and invalid symbols that do not exist.\n     *\n     * Some implementations do _not_ implement this detail, and dlerror()\n     * still returns NULL after looking up an invalid symbol name.\n     *\n     * In practice, this is expected to be used for looking up functions\n     * and as such all valid symbols should be non-NULL, so NULL is considered\n     * an error even if the C library doesn't consider this an error.\n     */\n    if (dlError != NULL)\n    {\n        OS_DEBUG(\"Error: %s: %s\\n\", SymbolName, dlError);\n    }\n    else if (Function == NULL)\n    {\n        /* technically not an error per POSIX, but in practice should not happen */\n        OS_DEBUG(\"Error: %s: dlsym() returned NULL\\n\", SymbolName);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    *SymbolAddress = (cpuaddr)Function;\n\n    return status;\n}",
    "void UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}"
  ],
  "explanation": "No direct self-calls were found in the provided code fragments (i.e. no function body contains a call to itself). The remaining functions and fragments from the provided files were not included because they do not present an obvious recursion risk from the code shown:\n\n- UT_GetStubEntry, UT_ClearStubEntry, UT_Stub_RegisterReturnType, UT_Stub_RegisterContextWithMetaData, UT_StubTable management functions and related simple helpers only manipulate data structures, memory, or call standard library functions (malloc, free, memset, strcmp) and do not call back into higher-level functions shown here.\n\n- OS_SymbolLookup_Static is a simple linear search over a static table and only calls strcmp; it contains no function-pointer calls or callbacks that could lead to recursion.\n\n- OS_ModuleSymbolLookup_Impl, OS_ObjectIdIterateActive, OS_ObjectIdIteratorDestroy and similar iterator/lookup helpers simply forward to other low-level functions and do not, within the provided bodies, call back into the original callers.\n\n- Utility/assert wrappers (UtAssert_Abort, UtAssert_GetContext) simply call a BSP helper or return a context; the provided bodies do not recurse.\n\n- UT_SetHandlerFunction, UT_DefaultStubImpl and the Execute handlers were included because they install or invoke handler functions (function-pointer callbacks) and call UT_DefaultStubImplWithArgs / handler registration helpers. These are potential sources of indirect recursion if a registered handler or default stub implementation ends up invoking the same API; therefore they were reported for investigation.\n\n- OS_printf, OS_ConsoleWrite and OS_GenericSymbolLookup_Impl were included because they call OS_DEBUG, OS_ConsoleOutput_Impl and other OS_* implementations which in other parts of the system (not shown) may call back to OS_printf or symbol lookup routines (for example debug or console output paths). Those call chains create plausible indirect recursion paths and thus merit investigation.\n\nIf additional implementation bodies (e.g. OS_DEBUG macro, OS_ConsoleOutput_Impl, OS_Console_CopyOut, UT_DoSetHookFunction, UT_DefaultStubImplWithArgs, UT_BSP_DoText, and other lower-level stubs) are available, they should be inspected to confirm whether any of the included fragments form an indirect recursion cycle. The fragments not listed above exhibit only straightforward data manipulation or one-way calls in the provided code, so they were judged not to require investigation for Rule 17.2 based on the evidence shown."
}