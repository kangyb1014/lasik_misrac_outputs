{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function-pointer typedef uses a non-const void * for the user-supplied reference argument: typedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj). The other parameters are const, and the iterator stores and passes a void *arg read-only to the callback (iter->arg is assigned in OS_ObjectIdIteratorInit and passed unchanged in OS_ObjectIdIteratorProcessEntry). If the callback does not need to modify the data pointed to by ref (typical for match predicates), the parameter should be const void *ref (and iter->arg should be const void *). As written, the pointer is not const-qualified and thus violates MISRA C 2023 Rule 8.13 unless there is a justified need to modify the referenced object.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdIteratorInit code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2013.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdIteratorInit as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdIteratorInit:\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdIteratorInit code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    FILE *log = fopen(\"/tmp/logs/2013.txt\", \"a\");\n    if (log)\n    {\n        /* Log entry and basic parameter state. Avoid casting function pointers to data pointers. */\n        fprintf(log, \"OS_ObjectIdIteratorInit: ENTRY\\n\");\n        fprintf(log, \"  matchfunc: %s\\n\", (matchfunc ? \"non-NULL\" : \"NULL\"));\n        fprintf(log, \"  matcharg: %p\\n\", (void *)matcharg);\n        fprintf(log, \"  objtype: %lu\\n\", (unsigned long)objtype);\n        fprintf(log, \"  iter ptr: %p\\n\", (void *)iter);\n    }\n\n    /* Preserve original assignments (minimal change). */\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    if (log)\n    {\n        /* Log iterator state after assignment to capture that the same (non-const) pointer\n         * is stored and passed through the iterator structure (evidence for the violation).\n         */\n        fprintf(log, \"After assignment:\\n\");\n        fprintf(log, \"  iter->match: %s\\n\", (iter->match ? \"non-NULL\" : \"NULL\"));\n        fprintf(log, \"  iter->arg: %p\\n\", (void *)iter->arg);\n        fprintf(log, \"  iter->limit: %ld\\n\", (long)iter->limit);\n        fprintf(log, \"  iter->base: %p\\n\", (void *)iter->base);\n        fprintf(log, \"  &iter->token: %p\\n\", (void *)&iter->token);\n        fflush(log);\n    }\n\n    /* Call the transaction init and log its return value. Keep behavior identical. */\n    int32 status = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n\n    if (log)\n    {\n        fprintf(log, \"OS_ObjectIdTransactionInit returned: %ld\\n\", (long)status);\n        fprintf(log, \"EXIT\\n\\n\");\n        fclose(log);\n    }\n\n    return status;\n}\n"
}