{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorInit code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorInit.\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function-pointer typedef uses a non-const void * for the user-supplied reference argument: typedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj). The other parameters are const, and the iterator stores and passes a void *arg read-only to the callback (iter->arg is assigned in OS_ObjectIdIteratorInit and passed unchanged in OS_ObjectIdIteratorProcessEntry). If the callback does not need to modify the data pointed to by ref (typical for match predicates), the parameter should be const void *ref (and iter->arg should be const void *). As written, the pointer is not const-qualified and thus violates MISRA C 2023 Rule 8.13 unless there is a justified need to modify the referenced object.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5f0\n  objtype: 9\n  iter ptr: 0x7ffecbcbe610\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5f0\n  iter->limit: 10\n  iter->base: 0x558abfdcb9c8\n  &iter->token: 0x7ffecbcbe62c\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5f0\n  objtype: 8\n  iter ptr: 0x7ffecbcbe610\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5f0\n  iter->limit: 5\n  iter->base: 0x558abfdcb950\n  &iter->token: 0x7ffecbcbe62c\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5f0\n  objtype: 1\n  iter ptr: 0x7ffecbcbe610\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5f0\n  iter->limit: 64\n  iter->base: 0x558abfdca2a0\n  &iter->token: 0x7ffecbcbe62c\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 0\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 0\n  iter->base: 0x558abfdca2a0\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 1\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 64\n  iter->base: 0x558abfdca2a0\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 2\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 64\n  iter->base: 0x558abfdca8a0\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 3\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 20\n  iter->base: 0x558abfdcb080\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 4\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 20\n  iter->base: 0x558abfdcaea0\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 5\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 20\n  iter->base: 0x558abfdcb260\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 6\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 50\n  iter->base: 0x558abfdcb440\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 7\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 4\n  iter->base: 0x558abfdcb8f0\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 8\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 5\n  iter->base: 0x558abfdcb950\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_ObjectIdIteratorInit: ENTRY\n  matchfunc: non-NULL\n  matcharg: 0x7ffecbcbe5b0\n  objtype: 9\n  iter ptr: 0x7ffecbcbe5d0\nAfter assignment:\n  iter->match: non-NULL\n  iter->arg: 0x7ffecbcbe5b0\n  iter->limit: 10\n  iter->base: 0x558abfdcb9c8\n  &iter->token: 0x7ffecbcbe5ec\nOS_ObjectIdTransactionInit returned: -35\nEXIT\n\nOS_Ob\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdIteratorInit:\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n...\nstatic OS_common_record_t OS_common_table[OS_MAX_TOTAL_RECORDS]\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nuint32 OS_GetBaseForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_TASK_BASE;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_QUEUE_BASE;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_BINSEM_BASE;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_COUNTSEM_BASE;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MUTEX_BASE;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_STREAM_BASE;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_DIR_BASE;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_TIMEBASE_BASE;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_TIMECB_BASE;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MODULE_BASE;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_FILESYS_BASE;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_CONSOLE_BASE;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_CONDVAR_BASE;\n        default:\n            return 0;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s observation (that the user-supplied context pointer is not const-qualified) is technically true, but that alone is not sufficient to declare a MISRA 8.13 violation in this codebase. Rule 8.13 requires pointers to point to const-qualified types whenever that is possible. Here, iter->arg is declared as void * and is later passed (unchanged) to OS_ObjectIdIteratorProcessEntry, which invokes a user-supplied handler with the signature int32 (*func)(osal_id_t, void *). That handler expects a non-const void *; if iter->arg were changed to const void * (or the match func parameter changed to const void *), it would require changing every call-site and API that currently takes a non-const void * (or introduce casts), so it is not \u201cpossible\u201d in the current API without broader changes. In short: the code is intentionally using a non-const context pointer as part of its public/internal API, and the surrounding usage (ProcessEntry passing iter->arg to a function taking void *) demonstrates that making it const is not a safe local refactor. Therefore the claim of a standalone MISRA 8.13 violation for OS_ObjectIdIteratorInit (or the typedef) is not supported by the provided evidence. If, however, after full project-wide analysis it is proven that no consumer ever mutates the referenced object and all call-sites could be updated, then the API could be tightened to const and satisfy 8.13 \u2014 but that is a larger design/API change, not an immediate violation in the current code."
}