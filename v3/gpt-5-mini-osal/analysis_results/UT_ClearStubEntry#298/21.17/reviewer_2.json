{
  "user_message": "An agent A claimed that the following UT_ClearStubEntry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_ClearStubEntry.\n```c\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe memcpy source length is computed as ActualCopy = TotalSize - Position without validating that Position <= TotalSize and without checking BasePtr != NULL. If Position > TotalSize (e.g. TotalSize = 10, Position = 20) the subtraction underflows to a huge size_t value; if MaxSize does not constrain this to a safe value, memcpy(LocalBuffer, &BasePtr[Position], ActualCopy) will read beyond the allocated BasePtr (out-of-bounds). Also if BasePtr is NULL there is no null check before indexing. This can result in accesses beyond the bounds of the objects passed to memcpy, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_ClearStubEntry called: StubPtr=0x55fbac1dac60\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dac60 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dad80\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dad80 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1daea0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1daea0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dafc0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dafc0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db0e0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db0e0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db200\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db200 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db320\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db320 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db440\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db440 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db560\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db560 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db680\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db680 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db7a0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db7a0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db8c0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db8c0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1db9e0\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1db9e0 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dbb00\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dbb00 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dbc20\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dbc20 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dbd40\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dbd40 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dbe60\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr=0x55fbac1dbe60 (sizeof=*StubPtr=288)\nUT_ClearStubEntry exit\n\nUT_ClearStubEntry called: StubPtr=0x55fbac1dbf80\n  Condition false -> free not called\n    EntryType=0x0\n    ModeFlags=0x0\n    BasePtr=(nil)\n  memset performed on StubPtr\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_ClearStubEntry:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\n#define UT_MODEFLAG_ALLOC_BUF 0x1U\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UT_ResetState(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    int32                i;\n\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (FuncKey == 0 || StubPtr->FuncKey == FuncKey)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n        ++StubPtr;\n    }\n    if (FuncKey == 0)\n    {\n        UT_MaxStubSearchLen = 0;\n    }\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n...\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim that UT_ClearStubEntry violates MISRA C:2023 Rule 21.17 is not correct. UT_ClearStubEntry only calls free() (guarded by BasePtr != NULL and the ALLOC flag) and then does memset(StubPtr, 0, sizeof(*StubPtr)). That memset writes exactly the size of the object pointed to by StubPtr and therefore does not cause an out\u2011of\u2011bounds access on the object referenced by that pointer.\n\nThe scenario described by agent A (underflowing TotalSize - Position and indexing BasePtr when BasePtr is NULL) actually points to a potential violation in UT_Stub_CopyToLocal / UT_Stub_CopyFromLocal, not in UT_ClearStubEntry. Those functions compute ActualCopy = TotalSize - Position without explicitly validating Position <= TotalSize and then call memcpy using &BasePtr[Position] (and do not check BasePtr != NULL at that call site). If Position > TotalSize or BasePtr is NULL this could lead to out\u2011of\u2011bounds accesses via memcpy and would be a valid concern under Rule 21.17. \n\nSo the reported violation is targeted at the wrong function: UT_ClearStubEntry is fine, but the memcpy callers should validate Position and BasePtr (or otherwise ensure they cannot be out of range) to satisfy MISRA 21.17."
}