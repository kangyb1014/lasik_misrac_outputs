{
  "user_message": "An agent A claimed that the following OS_BinSemGetInfo_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGetInfo_Impl.\n```c\nint32 OS_BinSemGetInfo_Impl(const OS_object_token_t *token, OS_bin_sem_prop_t *sem_prop)\n{\n    OS_impl_binsem_internal_record_t *sem;\n\n    sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n\n    /* put the info into the structure */\n    sem_prop->value = sem->current_value;\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'sem' is declared as a mutable pointer (OS_impl_binsem_internal_record_t *sem) but is only used for reading (sem->current_value). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. In this case the code should declare the pointer as const OS_impl_binsem_internal_record_t *sem (or const-qualified appropriately) and then assign sem = OS_OBJECT_TABLE_GET(...). Assigning a non-const object pointer to a pointer-to-const is allowed, so this change is applicable and would satisfy the rule.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BinSemGetInfo_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_binsem_internal_record_t OS_impl_bin_sem_table[OS_MAX_BIN_SEMAPHORES]\n...\ntypedef struct\n{\n    pthread_mutex_t       id;\n    pthread_cond_t        cv;\n    volatile sig_atomic_t flush_request;\n    volatile sig_atomic_t current_value;\n} OS_impl_binsem_internal_record_t\n...\ntypedef struct\n{\n    char      name[OS_MAX_API_NAME];\n    osal_id_t creator;\n    int32     value;\n} OS_bin_sem_prop_t\n...\ntypedef struct OS_object_token OS_object_token_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In OS_BinSemGetInfo_Impl the local pointer sem is only used to read sem->current_value, so it can and should be declared to point to a const-qualified type (e.g. const OS_impl_binsem_internal_record_t *sem) to satisfy MISRA C:2023 Rule 8.13. The macro yields an OS_impl_binsem_internal_record_t * but converting that to a pointer-to-const is allowed, and the presence of the volatile qualifier on members is compatible with adding the const qualification to the enclosing pointer. The change is applicable and would not break the read-only usage in this function (only if the function later needed to modify the object would const be inappropriate)."
}