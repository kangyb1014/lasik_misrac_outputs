{
  "user_message": "An agent A claimed that the following UT_Stub_RegisterContextWithMetaData code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_RegisterContextWithMetaData.\n```c\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nParamPtr is declared as 'const void *' but ArgPtr is (non-const) 'void *' so the assignment StubPtr->Data.Context.ArgPtr[...] = ParamPtr discards the const qualifier. This violates MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nStage: enter\n FuncKey: 94473175592448\n StubPtr: (nil)\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_first_lookup\n FuncKey: 94473175592448\n StubPtr: (nil)\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_second_lookup\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: before_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: final_before_increment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: final_after_increment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: enter\n FuncKey: 94473175592448\n StubPtr: (nil)\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_first_lookup\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: after_second_lookup\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: before_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: after_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: final_before_increment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 1\n-----------------------------\nStage: final_after_increment\n FuncKey: 94473175592448\n StubPtr: 0x55ec401431e0\n ParamPtr (value): 0x7ffd85695d70\n ParamSize: 8\n Name: ticks\n ParamType (int): 2\n ArgIndex (expected ArgCount): 2\n-----------------------------\nStage: enter\n FuncKey: 94473175592448\n StubPtr: (nil)\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_first_lookup\n FuncKey: 94473175592448\n StubPtr: (nil)\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_second_lookup\n FuncKey: 94473175592448\n StubPtr: 0x55ec40143300\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: before_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec40143300\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n Name: milli_seconds\n ParamType (int): 2\n ArgIndex (expected ArgCount): 0\n-----------------------------\nStage: after_assignment\n FuncKey: 94473175592448\n StubPtr: 0x55ec40143300\n ParamPtr (value): 0x7ffd85695d7c\n ParamSize: 4\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_RegisterContextWithMetaData:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n...\ntypedef enum\n{\n    UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED = 0,\n    UT_STUBCONTEXT_ARG_TYPE_DIRECT,  /**< Indicates \"ArgPtr\" is a direct copy of the actual parameter value */\n    UT_STUBCONTEXT_ARG_TYPE_INDIRECT /**< Indicates \"ArgPtr\" is a pointer to the argument value on the stack */\n} UT_StubContext_Arg_Type_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\n#define UT_STUBCONTEXT_MAXSIZE 8\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function parameter ParamPtr is declared as const void * but it is stored into StubPtr->Data.Context.ArgPtr[...] which is a (non-const) void * (i.e. the array element type is non-const). That assignment effectively discards the const qualifier and means the storage is a pointer to a non-const type even though the incoming pointer is const-qualified \u2014 precisely the situation Rule 8.13 warns about (pointers should point to const-qualified types whenever possible). To fix this to conform with the intent of MISRA 8.13, the ArgPtr member should be declared as const void * (or the incoming parameter should not be const if mutation is intended); alternatively an explicit rationale/cast would be required if the discard is unavoidable and documented per the project's deviation policy."
}