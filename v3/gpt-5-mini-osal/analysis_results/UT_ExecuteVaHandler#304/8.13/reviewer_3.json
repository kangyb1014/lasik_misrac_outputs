{
  "user_message": "An agent A claimed that the following UT_ExecuteVaHandler code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_ExecuteVaHandler.\n```c\nvoid UT_ExecuteVaHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_VaHandlerFunc_t DefaultHandler,\n                         va_list VaList)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetVaHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImplWithArgs(FunctionName, FuncKey, 0, VaList);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe memcpy call reads from StubPtr->Data.Rvc.Buf.IndirectPtr but that member is typically declared as a non-const pointer (e.g. void *IndirectPtr). Since the buffer is only being read here, the pointer should be const-qualified (const void *IndirectPtr). Passing a non-const pointer where a const-qualified pointer is appropriate violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UT_ExecuteVaHandler: FunctionName=OS_printf, FuncKey=0x562400b42db1, DefaultHandler=0x562400b42fb4\nBefore_GetStubEntry_va_list: va_list address=0x7ffea0c24090\nBefore_GetStubEntry_va_list: va_list[00]=0xe0\nBefore_GetStubEntry_va_list: va_list[01]=0x40\nBefore_GetStubEntry_va_list: va_list[02]=0xc2\nBefore_GetStubEntry_va_list: va_list[03]=0xa0\nBefore_GetStubEntry_va_list: va_list[04]=0xfe\nBefore_GetStubEntry_va_list: va_list[05]=0x7f\nBefore_GetStubEntry_va_list: va_list[06]=0x00\nBefore_GetStubEntry_va_list: va_list[07]=0x00\nBefore_GetStubEntry_va_list: va_list[08]=0xb4\nBefore_GetStubEntry_va_list: va_list[09]=0x2f\nBefore_GetStubEntry_va_list: va_list[10]=0xb4\nBefore_GetStubEntry_va_list: va_list[11]=0x00\nBefore_GetStubEntry_va_list: va_list[12]=0x24\nBefore_GetStubEntry_va_list: va_list[13]=0x56\nBefore_GetStubEntry_va_list: va_list[14]=0x00\nBefore_GetStubEntry_va_list: va_list[15]=0x00\nBefore_GetStubEntry_va_list: va_list[16]=0xcf\nBefore_GetStubEntry_va_list: va_list[17]=0xdc\nBefore_GetStubEntry_va_list: va_list[18]=0xb4\nBefore_GetStubEntry_va_list: va_list[19]=0x00\nBefore_GetStubEntry_va_list: va_list[20]=0x24\nBefore_GetStubEntry_va_list: va_list[21]=0x56\nBefore_GetStubEntry_va_list: va_list[22]=0x00\nBefore_GetStubEntry_va_list: va_list[23]=0x00\nUT_GetStubEntry returned NULL for FuncKey=0x562400b42db1\nSetting VaHandlerFunction for FuncKey=0x562400b42db1 with DefaultHandler=0x562400b42fb4\nUT_SetVaHandlerFunction returned for FuncKey=0x562400b42db1\nCalling UT_DefaultStubImplWithArgs: FunctionName=OS_printf, FuncKey=0x562400b42db1, argCount=0, VaList=0x7ffea0c24090\nBefore_DefaultStubImpl_va_list: va_list address=0x7ffea0c24090\nBefore_DefaultStubImpl_va_list: va_list[00]=0xe0\nBefore_DefaultStubImpl_va_list: va_list[01]=0x40\nBefore_DefaultStubImpl_va_list: va_list[02]=0xc2\nBefore_DefaultStubImpl_va_list: va_list[03]=0xa0\nBefore_DefaultStubImpl_va_list: va_list[04]=0xfe\nBefore_DefaultStubImpl_va_list: va_list[05]=0x7f\nBefore_DefaultStubImpl_va_list: va_list[06]=0x00\nBefore_DefaultStubImpl_va_list: va_list[07]=0x00\nBefore_DefaultStubImpl_va_list: va_list[08]=0xb4\nBefore_DefaultStubImpl_va_list: va_list[09]=0x2f\nBefore_DefaultStubImpl_va_list: va_list[10]=0xb4\nBefore_DefaultStubImpl_va_list: va_list[11]=0x00\nBefore_DefaultStubImpl_va_list: va_list[12]=0x24\nBefore_DefaultStubImpl_va_list: va_list[13]=0x56\nBefore_DefaultStubImpl_va_list: va_list[14]=0x00\nBefore_DefaultStubImpl_va_list: va_list[15]=0x00\nBefore_DefaultStubImpl_va_list: va_list[16]=0xcf\nBefore_DefaultStubImpl_va_list: va_list[17]=0xdc\nBefore_DefaultStubImpl_va_list: va_list[18]=0xb4\nBefore_DefaultStubImpl_va_list: va_list[19]=0x00\nBefore_DefaultStubImpl_va_list: va_list[20]=0x24\nBefore_DefaultStubImpl_va_list: va_list[21]=0x56\nBefore_DefaultStubImpl_va_list: va_list[22]=0x00\nBefore_DefaultStubImpl_va_list: va_list[23]=0x00\nEXIT: UT_ExecuteVaHandler: FunctionName=OS_printf, FuncKey=0x562400b42db1\nENTER: UT_ExecuteVaHandler: FunctionName=OS_printf, FuncKey=0x562400b42db1, DefaultHandler=0x562400b42fb4\nBefore_GetStubEntry_va_list: va_list address=0x7ffea0c24090\nBefore_GetStubEntry_va_list: va_list[00]=0xe0\nBefore_GetStubEntry_va_list: va_list[01]=0x40\nBefore_GetStubEntry_va_list: va_list[02]=0xc2\nBefore_GetStubEntry_va_list: va_list[03]=0xa0\nBefore_GetStubEntry_va_list: va_list[04]=0xfe\nBefore_GetStubEntry_va_list: va_list[05]=0x7f\nBefore_GetStubEntry_va_list: va_list[06]=0x00\nBefore_GetStubEntry_va_list: va_list[07]=0x00\nBefore_GetStubEntry_va_list: va_list[08]=0xb4\nBefore_GetStubEntry_va_list: va_list[09]=0x2f\nBefore_GetStubEntry_va_list: va_list[10]=0xb4\nBefore_GetStubEntry_va_list: va_list[11]=0x00\nBefore_GetStubEntry_va_list: va_list[12]=0x24\nBefore_GetStubEntry_va_list: va_list[13]=0x56\nBefore_GetStubEntry_va_list: va_list[14]=0x00\nBefore_GetStubEntry_va_list: va_list[15]=0x00\nBefore_GetStubEntry_va_list: va_list[16]=0xcf\nBefore_GetStubEntry_va_list: va_list[17]=0xdc\nBefore_GetStubEntry_va_list: va_list[18]=0xb4\nBefore_GetStubEntry_va_list: va_list[19]=0x00\nBefore_GetStubEntry_va_list: va_list[20]=0x24\nBefore_GetStubEntry_va_list: va_list[21]=0x56\nBefore_GetSt\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_ExecuteVaHandler:\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef void (*UT_VaHandlerFunc_t)(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context, va_list va)\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UT_SetVaHandlerFunction(UT_EntryKey_t FuncKey, UT_VaHandlerFunc_t HandlerFunc, void *UserObj)\n{\n    UT_HookFuncPtr_t Value;\n\n    Value.VaHandler = HandlerFunc;\n\n    UT_DoSetHookFunction(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER, Value, UserObj, true);\n}\n...\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not supported by the provided code. The alleged problematic memcpy source is in UT_DefaultStubImplWithArgs (not UT_ExecuteVaHandler). memcpy's prototype takes a const void * for the source, and passing a void * (e.g. IndirectPtr) to it is a permitted implicit conversion \u2014 that alone is not a language violation. MISRA C:2023 Rule 8.13 requires that pointer types be qualified const where possible in their declarations; to establish a true rule violation you must show that the declaration of IndirectPtr (and all its uses) could safely be const-qualified (i.e. it is never used to modify the pointee). That evidence is not present here. Without the full declaration/usage set for Rvc.Buf.IndirectPtr, you cannot conclude it is safe to change its type to const void * or that the current code contravenes MISRA 8.13. Also, the target function UT_ExecuteVaHandler itself contains no pointer that is clearly missing a const qualifier. Therefore the report is not correct."
}