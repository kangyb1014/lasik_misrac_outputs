{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_TaskFindIdBySystemData:\n```c\nint32 OS_TaskFindIdBySystemData(osal_id_t *task_id, const void *sysdata, size_t sysdata_size)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_id);\n\n    /* The \"sysdata\" and \"sysdata_size\" must be passed to the underlying impl for validation */\n    return_code = OS_TaskValidateSystemData_Impl(sysdata, sysdata_size);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_TaskIdMatchSystemData_Impl,\n                                         (void *)sysdata, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *task_id = OS_ObjectIdFromToken(&token);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskFindIdBySystemData:\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nbool OS_TaskIdMatchSystemData_Impl(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    const pthread_t *               target = (const pthread_t *)ref;\n    OS_impl_task_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    return (pthread_equal(*target, impl->id) != 0);\n}\n...\nint32 OS_TaskValidateSystemData_Impl(const void *sysdata, size_t sysdata_size)\n{\n    if (sysdata == NULL || sysdata_size != sizeof(pthread_t))\n    {\n        return OS_INVALID_POINTER;\n    }\n    return OS_SUCCESS;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "OS_ObjectIdGetBySearch takes a parameter 'void *arg' but is used with a const pointer: OS_TaskFindIdBySystemData passes (void *)sysdata where sysdata is 'const void *'. The match function OS_TaskIdMatchSystemData_Impl treats the argument as const (casts to 'const pthread_t *' and does not modify it). Casting away const in the caller and declaring the parameter non-const means the pointer does not point to a const-qualified type when it could, violating MISRA C 2023 Rule 8.13. The signature should be changed to accept 'const void *arg' (and the OS_ObjectMatchFunc_t prototype adjusted accordingly) to avoid discarding the const qualifier."
}