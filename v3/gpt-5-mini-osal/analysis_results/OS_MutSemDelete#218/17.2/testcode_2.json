{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nIndirect recursion can occur if the EventHandler function pointer is set to OS_NotifyEvent (or to any function that eventually calls OS_NotifyEvent). In that case OS_NotifyEvent calls OS_SharedGlobalVars.EventHandler which invokes OS_NotifyEvent again, causing indirect self-call/recursion and thus violating Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_MutSemDelete code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2186.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_MutSemDelete as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_MutSemDelete:\n```c\nint32 OS_MutSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_MutSemDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_MutSemDelete code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe helper: append a line to the log file describing control flow/state. */\nstatic void OS_DebugLog_Probe(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2186.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\n\n/* Forward declarations of external functions/types used by the original code. */\nextern int32_t OS_ObjectIdGetById(int lock_mode, int obj_type, uintptr_t id, void *token);\nextern int32_t OS_MutSemDelete_Impl(void *token);\nextern int32_t OS_ObjectIdFinalizeDelete(int32_t prev_return_code, void *token);\n\n/* Keep the original signature and logic; add logging probes around calls. */\nint32_t OS_MutSemDelete(uintptr_t sem_id)\n{\n    /* Note: types mirrored from original snippet but using portable integer types for logging. */\n    void *token; /* OS_object_token_t token; (opaque here) */\n    int32_t return_code;\n\n    OS_DebugLog_Probe(\"ENTER: OS_MutSemDelete(sem_id=0x%08\" PRIxPTR \")\", (uintptr_t)sem_id);\n\n    return_code = OS_ObjectIdGetById(/* OS_LOCK_MODE_EXCLUSIVE */ 1, /* LOCAL_OBJID_TYPE */ 1, sem_id, &token);\n    OS_DebugLog_Probe(\"After OS_ObjectIdGetById: return_code=%d, token_addr=%p\", return_code, (void *)&token);\n\n    if (return_code == 0) /* OS_SUCCESS == 0 (assumed) */\n    {\n        OS_DebugLog_Probe(\"Calling OS_MutSemDelete_Impl: impl_addr=%p\", (void *)OS_MutSemDelete_Impl);\n        return_code = OS_MutSemDelete_Impl(&token);\n        OS_DebugLog_Probe(\"Returned from OS_MutSemDelete_Impl: return_code=%d\", return_code);\n\n        /* Complete the operation via the common routine */\n        OS_DebugLog_Probe(\"Calling OS_ObjectIdFinalizeDelete: finalize_addr=%p\", (void *)OS_ObjectIdFinalizeDelete);\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        OS_DebugLog_Probe(\"Returned from OS_ObjectIdFinalizeDelete: final_return_code=%d\", return_code);\n    }\n    else\n    {\n        OS_DebugLog_Probe(\"Skipping delete implementation since ObjectIdGetById returned %d\", return_code);\n    }\n\n    OS_DebugLog_Probe(\"EXIT: OS_MutSemDelete -> %d\", return_code);\n    return return_code;\n}\n"
}