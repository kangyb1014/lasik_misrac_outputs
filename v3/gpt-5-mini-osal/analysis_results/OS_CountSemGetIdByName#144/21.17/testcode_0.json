{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf LENGTHCHECK expands to use standard string functions that assume null-termination (e.g. strlen(name) or strcpy-style checks) then passing a buffer of size OS_MAX_API_NAME that is not null-terminated will cause the string function to read past the buffer bounds. In this code sem_name is only checked for NULL (OS_CHECK_POINTER) and not for guaranteed termination or size, so a non-terminated input would trigger an out-of-bounds access (e.g. strlen(name) iterating past the object).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CountSemGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1449.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CountSemGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CountSemGetIdByName:\n```c\nint32 OS_CountSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_POINTER(sem_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CountSemGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/*\n * Probe helper: append a single log line to /tmp/logs/1449.txt.\n * Keep the helper minimal and do not dereference sem_name to avoid\n * introducing any potential out-of-bounds reads.\n */\nstatic void probe_log(const char *stage, const void *sem_id_ptr, const void *sem_name_ptr, long return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1449.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* stage: textual indicator of where we are in the control flow\n         * sem_id_ptr and sem_name_ptr: pointer values (do not dereference)\n         * return_code: -1 if not yet available\n         */\n        fprintf(f, \"%s: sem_id=%p sem_name=%p return_code=%ld\\n\", stage, sem_id_ptr, sem_name_ptr, return_code);\n        fclose(f);\n    }\n}\n\n/*\n * Original function preserved as much as possible. Added probes to log\n * control flow and state to /tmp/logs/1449.txt. Note: we intentionally\n * avoid reading *sem_name to prevent any accidental out-of-bounds access\n * (this is the scenario under investigation).\n */\nint32 OS_CountSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Log entry and raw pointer values (do not dereference sem_name) */\n    probe_log(\"ENTRY\", (const void *)sem_id, (const void *)sem_name, -1);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_POINTER(sem_name);\n\n    /* Log after pointer checks (still not dereferencing sem_name) */\n    probe_log(\"AFTER_POINTER_CHECKS\", (const void *)sem_id, (const void *)sem_name, -1);\n\n    /* Call original lookup logic */\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    /* Log result and pointers */\n    probe_log(\"AFTER_LOOKUP\", (const void *)sem_id, (const void *)sem_name, (long)return_code);\n\n    return return_code;\n}\n"
}