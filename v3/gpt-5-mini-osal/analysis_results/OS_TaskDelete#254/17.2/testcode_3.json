{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nYes. OS_ObjectIdFinalizeDelete calls OS_NotifyEvent which invokes a user-supplied EventHandler. If that handler calls an OS API that leads to the same finalize/delete path (for example, EventHandler calls OS_TaskDelete which calls OS_ObjectIdFinalizeDelete), this produces indirect recursion: OS_ObjectIdFinalizeDelete -> OS_NotifyEvent -> EventHandler -> OS_TaskDelete -> OS_ObjectIdFinalizeDelete. Therefore the rule is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2546.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete:\n```c\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        return_code = OS_TaskDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        delete_hook();\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdint.h>\n\n/*\n * Probe logging helper. Appends timestamped messages to /tmp/logs/2546.txt.\n * Kept standalone so it does not alter original OS_TaskDelete logic.\n */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2546.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    if (localtime_r(&t, &tm_buf) == NULL)\n    {\n        /* Fallback to writing without timestamp */\n        fprintf(f, \"[no-time] pid=%d: \", (int)getpid());\n    }\n    else\n    {\n        fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] pid=%d: \",\n                tm_buf.tm_year + 1900, tm_buf.tm_mon + 1, tm_buf.tm_mday,\n                tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec, (int)getpid());\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    /* Log entry and input state */\n    probe_log(\"Enter OS_TaskDelete: task_id=%llu\", (unsigned long long)task_id);\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n\n    probe_log(\"OS_ObjectIdGetById returned %ld for task_id=%llu; token address=%p\",\n              (long)return_code, (unsigned long long)task_id, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        /* Log the resolved task record and delete hook pointer */\n        probe_log(\"Resolved task record at %p; delete_hook_pointer=%p\",\n                  (void *)task,\n                  (void *)(uintptr_t)delete_hook);\n\n        probe_log(\"Calling OS_TaskDelete_Impl with token=%p\", (void *)&token);\n        return_code = OS_TaskDelete_Impl(&token);\n        probe_log(\"OS_TaskDelete_Impl returned %ld for token=%p\", (long)return_code, (void *)&token);\n\n        /* Complete the operation via the common routine */\n        probe_log(\"Calling OS_ObjectIdFinalizeDelete(return_code=%ld, token=%p)\", (long)return_code, (void *)&token);\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        probe_log(\"OS_ObjectIdFinalizeDelete returned %ld for token=%p\", (long)return_code, (void *)&token);\n    }\n    else\n    {\n        probe_log(\"OS_TaskDelete: OS_ObjectIdGetById failed with %ld; skipping delete flow\", (long)return_code);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        probe_log(\"About to call delete_hook=%p for task_id=%llu\", (void *)(uintptr_t)delete_hook, (unsigned long long)task_id);\n\n        /* Call the user-supplied delete hook. This is intentionally performed\n         * after the object-finalize so that the lock state matches original behavior.\n         */\n        delete_hook();\n\n        probe_log(\"Returned from delete_hook=%p for task_id=%llu\", (void *)(uintptr_t)delete_hook, (unsigned long long)task_id);\n    }\n\n    probe_log(\"Exit OS_TaskDelete: return_code=%ld for task_id=%llu\", (long)return_code, (unsigned long long)task_id);\n\n    return return_code;\n}\n"
}