{
  "user_message": "An agent A claimed that the following OS_TaskDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskDelete.\n```c\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        return_code = OS_TaskDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        delete_hook();\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'task' is declared as OS_task_internal_record_t * and is initialized from OS_OBJECT_TABLE_GET(OS_task_table, token), which yields a non-const pointer to the global OS_task_table. In the shown code 'task' is only used for read access (reading task->delete_hook_pointer) and is not modified. According to MISRA C 2023 Rule 8.13, the pointer should instead point to a const-qualified type (e.g. const OS_task_internal_record_t *task) so the intent of read-only access is enforced. Additionally, the OS_OBJECT_TABLE_GET macro returns a non-const pointer, which prevents const propagation \u2014 either the pointer or the macro result should be const-qualified to comply.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=ObjectIdGetById_failed task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=exit task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete: stage=entry task_id=0 token_ptr=(nil) task_ptr=(nil) delete_hook_present=0 return_code=0\nOS_TaskDelete: stage=after_ObjectIdGetById task_id=0 token_ptr=0x7ffcea32b4e0 task_ptr=(nil) delete_hook_present=0 return_code=-16\nOS_TaskDelete\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskDelete:\ntypedef osal_task((*osal_task_entry)(void))\n...\ntypedef struct\n{\n    char            task_name[OS_MAX_API_NAME];\n    size_t          stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_task_entry delete_hook_pointer;\n    void *          entry_arg;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_task_internal_record_t OS_task_table[LOCAL_NUM_OBJECTS]\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    osal_id_t final_id;\n\n    /* Clear the OSAL ID if successful - this returns the record to the pool */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n    else\n    {\n        /* this restores the original ID */\n        final_id = token->obj_id;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n    }\n\n    return operation_status;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent's core claim is correct: the local pointer 'task' is declared as a non-const OS_task_internal_record_t * but is only used for read access (reading task->delete_hook_pointer), so it violates the intent of MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible). Declaring it as const OS_task_internal_record_t *task would express the read-only intent and satisfy the guideline.\n\nHowever, the agent's additional assertion that the OS_OBJECT_TABLE_GET macro \u201cprevents const propagation\u201d is not accurate. Assigning a non-const OS_task_internal_record_t * (the macro result) to a const OS_task_internal_record_t * is allowed (adding const is permitted), so the macro does not prevent making the local pointer const. No cast or macro change is required \u2014 simply declare the local pointer const. Therefore the report is essentially correct about the rule violation, but the justification about the macro preventing const propagation is mistaken."
}