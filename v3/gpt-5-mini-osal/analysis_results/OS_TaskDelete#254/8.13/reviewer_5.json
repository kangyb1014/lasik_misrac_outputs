{
  "user_message": "An agent A claimed that the following OS_TaskDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskDelete.\n```c\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        return_code = OS_TaskDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        delete_hook();\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn OS_TaskDelete_Impl the local variable 'impl' is declared as a non-const pointer (OS_impl_task_internal_record_t *impl) but is only used for read-only access (impl->id used with pthread_cancel/pthread_join). Therefore the pointer could and should be declared to point to a const-qualified type (const OS_impl_task_internal_record_t *impl). As written this fails to qualify the pointer as const when possible, violating MISRA C 2023 Rule 8.13. A minimal fix is to change the declaration to 'const OS_impl_task_internal_record_t *impl;'.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete EXIT return_code=-16\nOS_TaskDelete ENTRY: task_id=0\nOS_ObjectIdGetById returned -16\nOS_TaskDelete E\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskDelete:\ntypedef osal_task((*osal_task_entry)(void))\n...\ntypedef struct\n{\n    char            task_name[OS_MAX_API_NAME];\n    size_t          stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_task_entry delete_hook_pointer;\n    void *          entry_arg;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_task_internal_record_t OS_task_table[LOCAL_NUM_OBJECTS]\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    osal_id_t final_id;\n\n    /* Clear the OSAL ID if successful - this returns the record to the pool */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n    else\n    {\n        /* this restores the original ID */\n        final_id = token->obj_id;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n    }\n\n    return operation_status;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_TaskDelete_Impl the variable impl is only used for read-only access (impl->id used as an argument to pthread_cancel/pthread_join) and there are no writes through impl in the shown code. Per MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible, so declaring it as const OS_impl_task_internal_record_t *impl is appropriate. Assigning the address produced by OS_OBJECT_TABLE_GET (a non-const pointer) to a pointer-to-const is allowed, and it does not change semantics of the function. (The only caveat would be if other code not shown actually wrote via impl or passed impl to APIs requiring a non-const pointer; in that case const would not be possible. Given the provided implementation, the minimal fix suggested by agent A is valid.)"
}