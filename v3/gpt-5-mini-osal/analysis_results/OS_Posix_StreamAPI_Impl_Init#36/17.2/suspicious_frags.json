{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_Posix_StreamAPI_Impl_Init:\n```c\nint32 OS_Posix_StreamAPI_Impl_Init(void)\n{\n    osal_index_t local_id;\n\n    /*\n     * init all filehandles to -1, which is always invalid.\n     * this isn't strictly necessary but helps when debugging.\n     */\n    for (local_id = 0; local_id < OS_MAX_NUM_OPEN_FILES; ++local_id)\n    {\n        OS_impl_filehandle_table[local_id].fd = -1;\n    }\n\n    OS_IMPL_SELF_EUID = geteuid();\n    OS_IMPL_SELF_EGID = getegid();\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_Posix_StreamAPI_Impl_Init:\nint32 OS_API_Impl_Init(osal_objtype_t idtype)\n{\n    int32 return_code;\n\n    return_code = OS_Posix_TableMutex_Init(idtype);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return_code = OS_Posix_TaskAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return_code = OS_Posix_QueueAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return_code = OS_Posix_BinSemAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return_code = OS_Posix_CountSemAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return_code = OS_Posix_MutexAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return_code = OS_Posix_ModuleAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return_code = OS_Posix_TimeBaseAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return_code = OS_Posix_StreamAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return_code = OS_Posix_DirAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return_code = OS_Posix_FileSysAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return_code = OS_Posix_CondVarAPI_Impl_Init();\n            break;\n        default:\n            break;\n    }\n\n    return return_code;\n}\n...\nint32 OS_API_Init(void)\n{\n    int32          return_code = OS_SUCCESS;\n    osal_objtype_t idtype;\n    uint32         microSecPerSec;\n\n    /*\n     * If OSAL is already initialized, not really a big issue, just return.\n     * This is not typically expected though, so its worth a debug statement.\n     *\n     * However this can validly occur when running tests on some platforms\n     * without a reset/reload between invocations.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_INIT_MAGIC_NUMBER)\n    {\n        OS_DEBUG(\"NOTE: ignored redundant OS_API_Init() call\\n\");\n        return OS_SUCCESS;\n    }\n\n    /* Wipe global state structure to be sure everything is clean */\n    memset(&OS_SharedGlobalVars, 0, sizeof(OS_SharedGlobalVars));\n\n    /* Reset debug to default level if enabled */\n#if defined(OSAL_CONFIG_DEBUG_PRINTF)\n    OS_SharedGlobalVars.DebugLevel = 1;\n#endif\n\n    /* Set flag that says OSAL has been initialized */\n    OS_SharedGlobalVars.GlobalState = OS_INIT_MAGIC_NUMBER;\n\n    /* Initialize the common table that everything shares */\n    return_code = OS_ObjectIdInit();\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    for (idtype = 0; idtype < OS_OBJECT_TYPE_USER; ++idtype)\n    {\n        /* Initialize the implementation first, as the shared layer depends on it */\n        return_code = OS_API_Impl_Init(idtype);\n        if (return_code != OS_SUCCESS)\n        {\n            OS_DEBUG(\"OS_API_Impl_Init(0x%x) failed to initialize: %d\\n\", (unsigned int)idtype, (int)return_code);\n            break;\n        }\n\n        switch (idtype)\n        {\n            case OS_OBJECT_TYPE_OS_TASK:\n                return_code = OS_TaskAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_QUEUE:\n                return_code = OS_QueueAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_BINSEM:\n                return_code = OS_BinSemAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_COUNTSEM:\n                return_code = OS_CountSemAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_MUTEX:\n                return_code = OS_MutexAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_MODULE:\n                return_code = OS_ModuleAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_TIMEBASE:\n                return_code = OS_TimeBaseAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_TIMECB:\n                return_code = OS_TimerCbAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_STREAM:\n                return_code = OS_FileAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_DIR:\n                return_code = OS_DirAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_FILESYS:\n                return_code = OS_FileSysAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_CONSOLE:\n                return_code = OS_ConsoleAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_CONDVAR:\n                return_code = OS_CondVarAPI_Init();\n                break;\n            default:\n                break;\n        }\n        if (return_code != OS_SUCCESS)\n        {\n            OS_DEBUG(\"ID type 0x%x shared layer failed to initialize: %d\\n\", (unsigned int)idtype, (int)return_code);\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_NetworkAPI_Init();\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_SocketAPI_Init();\n    }\n\n    /*\n     * Confirm that somewhere during initialization,\n     * the time variables got set to something valid\n     */\n    if (return_code == OS_SUCCESS &&\n        (OS_SharedGlobalVars.MicroSecPerTick == 0 || OS_SharedGlobalVars.TicksPerSecond == 0))\n    {\n        OS_DEBUG(\"Implementation failed to initialize tick time globals\\n\");\n        return_code = OS_ERROR;\n    }\n\n    microSecPerSec = OS_SharedGlobalVars.MicroSecPerTick * OS_SharedGlobalVars.TicksPerSecond;\n\n    if (microSecPerSec != 1000000)\n    {\n        OS_DEBUG(\"Warning: Microsecs per sec value of %lu does not equal 1000000 (MicroSecPerTick: %ld   \"\n                 \"TicksPerSecond: %ld)\\n\",\n                 (unsigned long)microSecPerSec, (long)OS_SharedGlobalVars.MicroSecPerTick,\n                 (long)OS_SharedGlobalVars.TicksPerSecond);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /*\n         * Some part of init failed, so set global flag that says OSAL is in shutdown state.\n         *\n         * In particular if certain internal resources (such as the console utility task)\n         * were created, this should cause those tasks to self-exit such that the system\n         * is ultimately returned to the same state it started in.\n         */\n        OS_SharedGlobalVars.GlobalState = OS_SHUTDOWN_MAGIC_NUMBER;\n    }\n\n    return return_code;\n}\n...\nint32 OS_Posix_TableMutex_Init(osal_objtype_t idtype)\n{\n    int                     ret;\n    int32                   return_code = OS_SUCCESS;\n    pthread_mutexattr_t     mutex_attr;\n    OS_impl_objtype_lock_t *impl;\n\n    impl = OS_impl_objtype_lock_table[idtype];\n    if (impl == NULL)\n    {\n        return OS_SUCCESS;\n    }\n\n    do\n    {\n        /*\n         * initialize the pthread mutex attribute structure with default values\n         */\n        ret = pthread_mutexattr_init(&mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(ret));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n         * Allow the mutex to use priority inheritance\n         */\n        ret = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(ret));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n         * Use normal (faster/non-recursive) mutex implementation\n         * There should not be any instances of OSAL locking its own table more than once.\n         */\n        ret = pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_NORMAL);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_settype failed: %s\\n\", strerror(ret));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        ret = pthread_mutex_init(&impl->mutex, &mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutex_init failed: %s\\n\", strerror(ret));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /* create a condition variable with default attributes.\n         * This will be broadcast every time the object table changes */\n        ret = pthread_cond_init(&impl->cond, NULL);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_cond_init failed: %s\\n\", strerror(ret));\n            return_code = OS_ERROR;\n            break;\n        }\n    } while (0);\n\n    return return_code;\n}\n...\nint32 OS_Posix_TaskAPI_Impl_Init(void)\n{\n    int                    ret;\n    long                   ret_long;\n    int                    sig;\n    struct sched_param     sched_param;\n    int                    sched_policy;\n    POSIX_PriorityLimits_t sched_fifo_limits;\n    bool                   sched_fifo_valid;\n    POSIX_PriorityLimits_t sched_rr_limits;\n    bool                   sched_rr_valid;\n\n    /* Initialize Local Tables */\n    memset(OS_impl_task_table, 0, sizeof(OS_impl_task_table));\n\n    /* Clear the \"limits\" structs otherwise the compiler may warn\n     * about possibly being used uninitialized (false warning)\n     */\n    memset(&sched_fifo_limits, 0, sizeof(sched_fifo_limits));\n    memset(&sched_rr_limits, 0, sizeof(sched_rr_limits));\n\n    /*\n     * Create the key used to store OSAL task IDs\n     */\n    ret = pthread_key_create(&POSIX_GlobalVars.ThreadKey, NULL);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"Error creating thread key: %s (%d)\\n\", strerror(ret), ret);\n        return OS_ERROR;\n    }\n\n    /*\n    ** Disable Signals to parent thread and therefore all\n    ** child threads create will block all signals\n    ** Note: Timers will not work in the application unless\n    **       threads are spawned in OS_Application_Startup.\n    */\n    sigfillset(&POSIX_GlobalVars.MaximumSigMask);\n\n    /*\n     * Keep these signals unblocked so the process can be interrupted\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGINT);  /* CTRL+C */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGABRT); /* Abort */\n\n    /*\n     * One should not typically block ANY of the synchronous error\n     * signals, i.e. SIGSEGV, SIGFPE, SIGILL, SIGBUS\n     *\n     * The kernel generates these signals in response to hardware events\n     * and they get routed to the _specific thread_ that was executing when\n     * the problem occurred.\n     *\n     * While it is technically possible to block these signals, the result is\n     * undefined, and it makes debugging _REALLY_ hard.  If the kernel ever does\n     * send one it means there really is a major problem, best to listen to it,\n     * and not ignore it.\n     */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGSEGV); /* Segfault */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGILL);  /* Illegal instruction */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGBUS);  /* Bus Error */\n    sigdelset(&POSIX_GlobalVars.MaximumSigMask, SIGFPE);  /* Floating Point Exception */\n\n    /*\n     * Set the mask and store the original (default) mask in the POSIX_GlobalVars.NormalSigMask\n     */\n    sigprocmask(SIG_SETMASK, &POSIX_GlobalVars.MaximumSigMask, &POSIX_GlobalVars.NormalSigMask);\n\n    /*\n     * Add all \"RT\" signals into the POSIX_GlobalVars.NormalSigMask\n     * This will be used for the signal mask of the main thread\n     * (This way it will end up as the default/original signal mask plus all RT sigs)\n     */\n    for (sig = SIGRTMIN; sig <= SIGRTMAX; ++sig)\n    {\n        sigaddset(&POSIX_GlobalVars.NormalSigMask, sig);\n    }\n\n    /*\n     * SIGHUP is used to wake up the main thread when necessary,\n     * so make sure it is NOT in the set.\n     */\n    sigdelset(&POSIX_GlobalVars.NormalSigMask, SIGHUP);\n\n    /*\n    ** Install noop as the signal handler for SIGUP.\n    */\n    signal(SIGHUP, OS_NoopSigHandler);\n\n    /*\n    ** Raise the priority of the current (main) thread so that subsequent\n    ** application initialization will complete.  This had previously been\n    ** done by the BSP and but it is moved here.\n    **\n    ** This will only work if the user owning this process has permission\n    ** to create real time threads.  Otherwise, the default priority will\n    ** be retained.  Typically this is only the root user, but finer grained\n    ** permission controls are out there.  So if it works, great, but if\n    ** a permission denied error is generated, that is OK too - this allows\n    ** easily debugging code as a normal user.\n    */\n    ret = pthread_getschedparam(pthread_self(), &sched_policy, &sched_param);\n    if (ret == 0)\n    {\n        POSIX_GlobalVars.SelectedRtScheduler = sched_policy; /* Fallback/default */\n        do\n        {\n            sched_fifo_valid = OS_Posix_GetSchedulerParams(SCHED_FIFO, &sched_fifo_limits);\n            sched_rr_valid   = OS_Posix_GetSchedulerParams(SCHED_RR, &sched_rr_limits);\n\n            /*\n             * If both policies are valid, choose the best. In general, FIFO is preferred\n             * since it is simpler.\n             *\n             * But, RR is preferred if mapping several OSAL priority levels into the\n             * same local priority level. For instance, if 2 OSAL tasks are created at priorities\n             * \"2\" and \"1\", both may get mapped to local priority 98, and if using FIFO then the\n             * task at priority \"2\" could run indefinitely, never letting priority \"1\" execute.\n             *\n             * This violates the original intent, which would be to have priority \"1\" preempt\n             * priority \"2\" tasks.  RR is less bad since it at least guarantees both tasks some\n             * CPU time,\n             */\n            if (sched_fifo_valid && sched_rr_valid)\n            {\n                /*\n                 * If the spread from min->max is greater than what OSAL actually needs,\n                 * then FIFO is the preferred scheduler.  Must take into account one extra level\n                 * for the root task.\n                 */\n                if ((sched_fifo_limits.PriorityMax - sched_fifo_limits.PriorityMin) > OS_MAX_TASK_PRIORITY)\n                {\n                    sched_policy               = SCHED_FIFO;\n                    POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n                }\n                else\n                {\n                    sched_policy               = SCHED_RR;\n                    POSIX_GlobalVars.PriLimits = sched_rr_limits;\n                }\n            }\n            else if (sched_fifo_valid)\n            {\n                /* only FIFO is available */\n                sched_policy               = SCHED_FIFO;\n                POSIX_GlobalVars.PriLimits = sched_fifo_limits;\n            }\n            else if (sched_rr_valid)\n            {\n                /* only RR is available */\n                sched_policy               = SCHED_RR;\n                POSIX_GlobalVars.PriLimits = sched_rr_limits;\n            }\n            else\n            {\n                /* Nothing is valid, use default */\n                break;\n            }\n\n            /*\n             * This OSAL POSIX implementation will reserve the absolute highest priority\n             * for the root thread, which ultimately will just pend in sigsuspend() so\n             * it will not actually DO anything, except if sent a signal.  This way,\n             * that thread will still be able to preempt a high-priority user thread that\n             * has gone awry (i.e. using 100% cpu in FIFO mode).\n             */\n            sched_param.sched_priority = POSIX_GlobalVars.PriLimits.PriorityMax;\n            --POSIX_GlobalVars.PriLimits.PriorityMax;\n\n            OS_DEBUG(\"Selected policy %d for RT tasks, root task = %d\\n\", sched_policy,\n                     (int)sched_param.sched_priority);\n\n            /*\n             * If the spread from min->max is greater than what OSAL actually needs,\n             * then truncate it at the number of OSAL priorities.  This will end up mapping 1:1.\n             * and leaving the highest priority numbers unused.\n             */\n            if ((POSIX_GlobalVars.PriLimits.PriorityMax - POSIX_GlobalVars.PriLimits.PriorityMin) >\n                OS_MAX_TASK_PRIORITY)\n            {\n                POSIX_GlobalVars.PriLimits.PriorityMax = POSIX_GlobalVars.PriLimits.PriorityMin + OS_MAX_TASK_PRIORITY;\n            }\n\n            ret = pthread_setschedparam(pthread_self(), sched_policy, &sched_param);\n            if (ret != 0)\n            {\n                OS_DEBUG(\"Could not setschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n                break;\n            }\n\n            /*\n             * Set the boolean to indicate that \"setschedparam\" worked --\n             * This means that it is also expected to work for future calls.\n             */\n            POSIX_GlobalVars.SelectedRtScheduler  = sched_policy;\n            POSIX_GlobalVars.EnableTaskPriorities = true;\n        } while (0);\n    }\n    else\n    {\n        OS_DEBUG(\"Could not getschedparam in main thread: %s (%d)\\n\", strerror(ret), ret);\n    }\n\n#if !defined(OSAL_CONFIG_DEBUG_PERMISSIVE_MODE)\n    /*\n     * In strict (non-permissive) mode, if the task priority setting did not work, fail with an error.\n     * This would be used on a real target where it needs to be ensured that priorities are active\n     * and the \"silent fallback\" of debug mode operation is not desired.\n     */\n    if (!POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        return OS_ERROR;\n    }\n#endif\n\n    ret_long = sysconf(_SC_PAGESIZE);\n    if (ret_long < 0)\n    {\n        OS_DEBUG(\"Could not get page size via sysconf: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n    POSIX_GlobalVars.PageSize = ret_long;\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_QueueAPI_Impl_Init(void)\n{\n    memset(OS_impl_queue_table, 0, sizeof(OS_impl_queue_table));\n\n    /*\n     * Automatic truncation is dependent on the OSAL_CONFIG_DEBUG_PERMISSIVE_MODE compile-time define - so\n     * creating a too-large message queue on a target without OSAL_CONFIG_DEBUG_PERMISSIVE_MODE will fail\n     * with an OS error as intended.\n     */\n#ifdef OSAL_CONFIG_DEBUG_PERMISSIVE_MODE\n    /*\n     * Use the BSP-provided limit\n     */\n    POSIX_GlobalVars.TruncateQueueDepth = OS_BSP_Global.MaxQueueDepth;\n#else\n    /*\n     * Initialize this to zero to indicate no limit\n     */\n    POSIX_GlobalVars.TruncateQueueDepth = OSAL_BLOCKCOUNT_C(0);\n#endif\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_BinSemAPI_Impl_Init(void)\n{\n    memset(OS_impl_bin_sem_table, 0, sizeof(OS_impl_bin_sem_table));\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_CountSemAPI_Impl_Init(void)\n{\n    memset(OS_impl_count_sem_table, 0, sizeof(OS_impl_count_sem_table));\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_MutexAPI_Impl_Init(void)\n{\n    memset(OS_impl_mutex_table, 0, sizeof(OS_impl_mutex_table));\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_ModuleAPI_Impl_Init(void)\n{\n    memset(OS_impl_module_table, 0, sizeof(OS_impl_module_table));\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_TimeBaseAPI_Impl_Init(void)\n{\n    int                 status;\n    osal_index_t        idx;\n    pthread_mutexattr_t mutex_attr;\n    struct timespec     clock_resolution;\n    int32               return_code;\n\n    return_code = OS_SUCCESS;\n\n    do\n    {\n        /*\n        ** Mark all timers as available\n        */\n        memset(OS_impl_timebase_table, 0, sizeof(OS_impl_timebase_table));\n\n        /*\n        ** get the resolution of the selected clock\n        */\n        status = clock_getres(OS_PREFERRED_CLOCK, &clock_resolution);\n        if (status != 0)\n        {\n            OS_DEBUG(\"failed in clock_getres: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Convert to microseconds\n        ** Note that the resolution MUST be in the sub-second range, if not then\n        ** it looks like the POSIX timer API in the C library is broken.\n        ** Note for any flavor of RTOS we would expect <= 1ms.  Even a \"desktop\"\n        ** linux or development system should be <= 100ms absolute worst-case.\n        */\n        if (clock_resolution.tv_sec > 0)\n        {\n            return_code = OS_TIMER_ERR_INTERNAL;\n            break;\n        }\n\n        /* Round to the nearest microsecond */\n        POSIX_GlobalVars.ClockAccuracyNsec = (uint32)(clock_resolution.tv_nsec);\n\n        /*\n        ** initialize the attribute with default values\n        */\n        status = pthread_mutexattr_init(&mutex_attr);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Allow the mutex to use priority inheritance\n        */\n        status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            /*\n            ** create the timebase sync mutex\n            ** This gives a mechanism to synchronize updates to the timer chain with the\n            ** expiration of the timer and processing the chain.\n            */\n            status = pthread_mutex_init(&OS_impl_timebase_table[idx].handler_mutex, &mutex_attr);\n            if (status != 0)\n            {\n                OS_DEBUG(\"Error: Mutex could not be created: %s\\n\", strerror(status));\n                return_code = OS_ERROR;\n                break;\n            }\n        }\n\n        /*\n         * Pre-calculate the clock tick to microsecond conversion factor.\n         */\n        OS_SharedGlobalVars.TicksPerSecond = sysconf(_SC_CLK_TCK);\n        if (OS_SharedGlobalVars.TicksPerSecond <= 0)\n        {\n            OS_DEBUG(\"Error: Unable to determine OS ticks per second: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n         * Calculate microseconds per tick\n         *  - If the ratio is not an integer, this will round to the nearest integer value\n         *  - This is used internally for reporting accuracy,\n         *  - TicksPerSecond values over 2M will return zero\n         */\n        OS_SharedGlobalVars.MicroSecPerTick =\n            (1000000 + (OS_SharedGlobalVars.TicksPerSecond / 2)) / OS_SharedGlobalVars.TicksPerSecond;\n    } while (0);\n\n    return return_code;\n}\n...\nint32 OS_Posix_DirAPI_Impl_Init(void)\n{\n    memset(OS_impl_dir_table, 0, sizeof(OS_impl_dir_table));\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_FileSysAPI_Impl_Init(void)\n{\n    return OS_SUCCESS;\n}\n...\nint32 OS_Posix_CondVarAPI_Impl_Init(void)\n{\n    memset(OS_impl_condvar_table, 0, sizeof(OS_impl_condvar_table));\n    return OS_SUCCESS;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "int32 OS_API_Impl_Init(osal_objtype_t idtype)\n{\n    int32 return_code;\n\n    return_code = OS_Posix_TableMutex_Init(idtype);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return_code = OS_Posix_TaskAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return_code = OS_Posix_QueueAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return_code = OS_Posix_BinSemAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return_code = OS_Posix_CountSemAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return_code = OS_Posix_MutexAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return_code = OS_Posix_ModuleAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return_code = OS_Posix_TimeBaseAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return_code = OS_Posix_StreamAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return_code = OS_Posix_DirAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return_code = OS_Posix_FileSysAPI_Impl_Init();\n            break;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return_code = OS_Posix_CondVarAPI_Impl_Init();\n            break;\n        default:\n            break;\n    }\n\n    return return_code;\n}",
    "int32 OS_API_Init(void)\n{\n    int32          return_code = OS_SUCCESS;\n    osal_objtype_t idtype;\n    uint32         microSecPerSec;\n\n    /*\n     * If OSAL is already initialized, not really a big issue, just return.\n     * This is not typically expected though, so its worth a debug statement.\n     *\n     * However this can validly occur when running tests on some platforms\n     * without a reset/reload between invocations.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_INIT_MAGIC_NUMBER)\n    {\n        OS_DEBUG(\"NOTE: ignored redundant OS_API_Init() call\\n\");\n        return OS_SUCCESS;\n    }\n\n    /* Wipe global state structure to be sure everything is clean */\n    memset(&OS_SharedGlobalVars, 0, sizeof(OS_SharedGlobalVars));\n\n    /* Reset debug to default level if enabled */\n#if defined(OSAL_CONFIG_DEBUG_PRINTF)\n    OS_SharedGlobalVars.DebugLevel = 1;\n#endif\n\n    /* Set flag that says OSAL has been initialized */\n    OS_SharedGlobalVars.GlobalState = OS_INIT_MAGIC_NUMBER;\n\n    /* Initialize the common table that everything shares */\n    return_code = OS_ObjectIdInit();\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    for (idtype = 0; idtype < OS_OBJECT_TYPE_USER; ++idtype)\n    {\n        /* Initialize the implementation first, as the shared layer depends on it */\n        return_code = OS_API_Impl_Init(idtype);\n        if (return_code != OS_SUCCESS)\n        {\n            OS_DEBUG(\"OS_API_Impl_Init(0x%x) failed to initialize: %d\\n\", (unsigned int)idtype, (int)return_code);\n            break;\n        }\n\n        switch (idtype)\n        {\n            case OS_OBJECT_TYPE_OS_TASK:\n                return_code = OS_TaskAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_QUEUE:\n                return_code = OS_QueueAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_BINSEM:\n                return_code = OS_BinSemAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_COUNTSEM:\n                return_code = OS_CountSemAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_MUTEX:\n                return_code = OS_MutexAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_MODULE:\n                return_code = OS_ModuleAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_TIMEBASE:\n                return_code = OS_TimeBaseAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_TIMECB:\n                return_code = OS_TimerCbAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_STREAM:\n                return_code = OS_FileAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_DIR:\n                return_code = OS_DirAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_FILESYS:\n                return_code = OS_FileSysAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_CONSOLE:\n                return_code = OS_ConsoleAPI_Init();\n                break;\n            case OS_OBJECT_TYPE_OS_CONDVAR:\n                return_code = OS_CondVarAPI_Init();\n                break;\n            default:\n                break;\n        }\n        if (return_code != OS_SUCCESS)\n        {\n            OS_DEBUG(\"ID type 0x%x shared layer failed to initialize: %d\\n\", (unsigned int)idtype, (int)return_code);\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_NetworkAPI_Init();\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_SocketAPI_Init();\n    }\n\n    /*\n     * Confirm that somewhere during initialization,\n     * the time variables got set to something valid\n     */\n    if (return_code == OS_SUCCESS &&\n        (OS_SharedGlobalVars.MicroSecPerTick == 0 || OS_SharedGlobalVars.TicksPerSecond == 0))\n    {\n        OS_DEBUG(\"Implementation failed to initialize tick time globals\\n\");\n        return_code = OS_ERROR;\n    }\n\n    microSecPerSec = OS_SharedGlobalVars.MicroSecPerTick * OS_SharedGlobalVars.TicksPerSecond;\n\n    if (microSecPerSec != 1000000)\n    {\n        OS_DEBUG(\"Warning: Microsecs per sec value of %lu does not equal 1000000 (MicroSecPerTick: %ld   \"\n                 \"TicksPerSecond: %ld)\\n\",\n                 (unsigned long)microSecPerSec, (long)OS_SharedGlobalVars.MicroSecPerTick,\n                 (long)OS_SharedGlobalVars.TicksPerSecond);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /*\n         * Some part of init failed, so set global flag that says OSAL is in shutdown state.\n         *\n         * In particular if certain internal resources (such as the console utility task)\n         * were created, this should cause those tasks to self-exit such that the system\n         * is ultimately returned to the same state it started in.\n         */\n        OS_SharedGlobalVars.GlobalState = OS_SHUTDOWN_MAGIC_NUMBER;\n    }\n\n    return return_code;\n}",
    "int32 OS_Posix_StreamAPI_Impl_Init(void)\n{\n    osal_index_t local_id;\n\n    /*\n     * init all filehandles to -1, which is always invalid.\n     * this isn't strictly necessary but helps when debugging.\n     */\n    for (local_id = 0; local_id < OS_MAX_NUM_OPEN_FILES; ++local_id)\n    {\n        OS_impl_filehandle_table[local_id].fd = -1;\n    }\n\n    OS_IMPL_SELF_EUID = geteuid();\n    OS_IMPL_SELF_EGID = getegid();\n\n    return OS_SUCCESS;\n}"
  ],
  "explanation": "The functions selected form the initialization call graph and therefore must be inspected for potential direct or indirect recursion: OS_API_Init calls OS_API_Impl_Init in a loop, and OS_API_Impl_Init dispatches to multiple OS_Posix_*Impl_Init functions including OS_Posix_StreamAPI_Impl_Init. These three fragments show the call sites and are therefore the primary places to investigate for recursion.\n\nOther fragments in the provided code do not need investigation for Rule 17.2 because they do not invoke the init dispatcher or call back into the API init functions:\n\n- All OS_Posix_*Impl_Init functions that are simple initializers (e.g., OS_Posix_QueueAPI_Impl_Init, OS_Posix_BinSemAPI_Impl_Init, OS_Posix_CountSemAPI_Impl_Init, OS_Posix_MutexAPI_Impl_Init, OS_Posix_ModuleAPI_Impl_Init, OS_Posix_DirAPI_Impl_Init, OS_Posix_FileSysAPI_Impl_Init, OS_Posix_CondVarAPI_Impl_Init) consist only of memset or trivial returns and contain no calls to other init functions, so they cannot create recursion.\n\n- OS_Posix_TableMutex_Init performs pthread attribute/mutex/cond initialization and returns; it does not call any of the OS_API_Init/OS_API_Impl_Init or other implementation init functions.\n\n- OS_Posix_TaskAPI_Impl_Init and OS_Posix_TimeBaseAPI_Impl_Init call POSIX APIs (pthread_key_create, sigprocmask, pthread_setschedparam, sysconf, pthread_mutex_init, clock_getres, etc.) but do not call back into OS_API_Init or OS_API_Impl_Init or other implementation init dispatchers in the provided code, so they do not introduce recursion based on the shown code.\n\n- The target OS_Posix_StreamAPI_Impl_Init itself does not call any OS init functions (only geteuid/getegid and table initialization).\n\nGiven the above, only the initialization dispatchers and the Stream impl function (as the target of a dispatch) require examination to ensure no direct or indirect self-calls occur. Other shown functions are safe with respect to Rule 17.2 based on their bodies as provided."
}