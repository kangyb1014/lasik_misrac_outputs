{
  "user_message": "An agent A claimed that the following UtAssert_DoReport code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_DoReport.\n```c\nvoid UtAssert_DoReport(const char *File, uint32 LineNum, uint32 SegmentNum, uint32 TestSeq, uint8 MessageType,\n                       const char *SubsysName, const char *ShortDesc)\n{\n    uint32      FileLen;\n    const char *BasePtr;\n    char        ReportBuffer[320];\n\n    FileLen = strlen(File);\n    BasePtr = File + FileLen;\n    while (FileLen > 0)\n    {\n        --BasePtr;\n        --FileLen;\n        if (*BasePtr == '/' || *BasePtr == '\\\\')\n        {\n            ++BasePtr;\n            break;\n        }\n    }\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u.%03u %s:%u - %s\", (unsigned int)SegmentNum,\n             (unsigned int)TestSeq, BasePtr, (unsigned int)LineNum, ShortDesc);\n\n    UT_BSP_DoText(MessageType, ReportBuffer);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf UtAssert_DoReport is called with File == NULL (or with File pointing to a non-NUL-terminated buffer), the call to strlen(File) will dereference NULL or scan past the buffer end and read beyond the object bounds (e.g., calling UtAssert_DoReport(NULL, ...) leads to undefined behavior).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 42, SegmentNum: 1, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bb00\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 01.001 coveragetest-binsem.c:42 - UT_Call_OS_VxWorks_BinSemAPI_Impl_Init() (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 53, SegmentNum: 2, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 02.001 coveragetest-binsem.c:53 - OS_BinSemCreate_Impl(&token, 0, 0) (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 56, SegmentNum: 2, TestSeq: 2, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 02.002 coveragetest-binsem.c:56 - OS_BinSemCreate_Impl(&token, 0, 0) (-6) == OS_SEM_FAILURE (-6)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 67, SegmentNum: 3, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 03.001 coveragetest-binsem.c:67 - OS_BinSemDelete_Impl(&token) (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 78, SegmentNum: 4, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 04.001 coveragetest-binsem.c:78 - OS_BinSemGive_Impl(&token) (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 81, SegmentNum: 4, TestSeq: 2, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 04.002 coveragetest-binsem.c:81 - OS_BinSemGive_Impl(&token) (-6) == OS_SEM_FAILURE (-6)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 92, SegmentNum: 5, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 05.001 coveragetest-binsem.c:92 - OS_BinSemFlush_Impl(&token) (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 95, SegmentNum: 5, TestSeq: 2, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 05.002 coveragetest-binsem.c:95 - OS_BinSemFlush_Impl(&token) (-6) == OS_SEM_FAILURE (-6)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 106, SegmentNum: 6, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bae0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 06.001 coveragetest-binsem.c:106 - OS_BinSemTake_Impl(&token) (0) == OS_SUCCESS (0)\nUtAssert_DoReport EXIT\n\nUtAssert_DoReport ENTER\n  File pointer: 0x56171b5bd048\n  LineNum: 117, SegmentNum: 7, TestSeq: 1, MessageType: 11\n  SubsysName pointer: 0x56171b5c7760, ShortDesc pointer: 0x7ffd1076bad0\n  About to call strlen(File) - this is the location that can crash if File == NULL or not NUL-terminated\n  ReportBuffer: 07.001 coveragetes\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_DoReport:\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strlen(File) requires File to point to a valid NUL-terminated array; the function does not check File for NULL nor enforce/verify NUL-termination before calling strlen. If UtAssert_DoReport is called with File == NULL it will dereference NULL, and if File does not point to a NUL-terminated buffer strlen may read beyond the object bounds \u2014 both are undefined behavior and violate MISRA C 2023 Rule 21.17. (In practice many call sites pass __FILE__, which is NUL-terminated, but MISRA requires the code to ensure the preconditions or document/enforce them; as written the code is potentially noncompliant.)"
}