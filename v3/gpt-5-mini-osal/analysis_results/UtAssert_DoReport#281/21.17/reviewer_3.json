{
  "user_message": "An agent A claimed that the following UtAssert_DoReport code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_DoReport.\n```c\nvoid UtAssert_DoReport(const char *File, uint32 LineNum, uint32 SegmentNum, uint32 TestSeq, uint8 MessageType,\n                       const char *SubsysName, const char *ShortDesc)\n{\n    uint32      FileLen;\n    const char *BasePtr;\n    char        ReportBuffer[320];\n\n    FileLen = strlen(File);\n    BasePtr = File + FileLen;\n    while (FileLen > 0)\n    {\n        --BasePtr;\n        --FileLen;\n        if (*BasePtr == '/' || *BasePtr == '\\\\')\n        {\n            ++BasePtr;\n            break;\n        }\n    }\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u.%03u %s:%u - %s\", (unsigned int)SegmentNum,\n             (unsigned int)TestSeq, BasePtr, (unsigned int)LineNum, ShortDesc);\n\n    UT_BSP_DoText(MessageType, ReportBuffer);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nUtAssert_DoReport calls strlen(File) without validating that File points to a valid, null-terminated buffer. UtAssertEx forwards its File parameter to UtAssert_DoReport unchanged and does not check for NULL. If a caller passes File == NULL (or a non\u2013null-terminated buffer), strlen(File) will access memory beyond the bounds of the referenced object, violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UtAssert_DoReport\n  Params: File=0x561013d8b048, LineNum=42, SegmentNum=1, TestSeq=1, MessageType=11\n  Pointers: SubsysName=0x561013d95760, ShortDesc=0x7ffe44508b00\n  After strlen(): FileLen=77\n    Loop: BasePtr=0x561013d8b094, *BasePtr='c', RemainingLen=76\n    Loop: BasePtr=0x561013d8b093, *BasePtr='.', RemainingLen=75\n    Loop: BasePtr=0x561013d8b092, *BasePtr='m', RemainingLen=74\n    Loop: BasePtr=0x561013d8b091, *BasePtr='e', RemainingLen=73\n    Loop: BasePtr=0x561013d8b090, *BasePtr='s', RemainingLen=72\n    Loop: BasePtr=0x561013d8b08f, *BasePtr='n', RemainingLen=71\n    Loop: BasePtr=0x561013d8b08e, *BasePtr='i', RemainingLen=70\n    Loop: BasePtr=0x561013d8b08d, *BasePtr='b', RemainingLen=69\n    Loop: BasePtr=0x561013d8b08c, *BasePtr='-', RemainingLen=68\n    Loop: BasePtr=0x561013d8b08b, *BasePtr='t', RemainingLen=67\n    Loop: BasePtr=0x561013d8b08a, *BasePtr='s', RemainingLen=66\n    Loop: BasePtr=0x561013d8b089, *BasePtr='e', RemainingLen=65\n    Loop: BasePtr=0x561013d8b088, *BasePtr='t', RemainingLen=64\n    Loop: BasePtr=0x561013d8b087, *BasePtr='e', RemainingLen=63\n    Loop: BasePtr=0x561013d8b086, *BasePtr='g', RemainingLen=62\n    Loop: BasePtr=0x561013d8b085, *BasePtr='a', RemainingLen=61\n    Loop: BasePtr=0x561013d8b084, *BasePtr='r', RemainingLen=60\n    Loop: BasePtr=0x561013d8b083, *BasePtr='e', RemainingLen=59\n    Loop: BasePtr=0x561013d8b082, *BasePtr='v', RemainingLen=58\n    Loop: BasePtr=0x561013d8b081, *BasePtr='o', RemainingLen=57\n    Loop: BasePtr=0x561013d8b080, *BasePtr='c', RemainingLen=56\n    Loop: BasePtr=0x561013d8b07f, *BasePtr='/', RemainingLen=55\n    Found separator, final BasePtr=0x561013d8b080\n  ReportBuffer: 01.001 coveragetest-binsem.c:42 - UT_Call_OS_VxWorks_BinSemAPI_Impl_Init() (0) == OS_SUCCESS (0)\nEXIT: UtAssert_DoReport\n\nENTER: UtAssert_DoReport\n  Params: File=0x561013d8b048, LineNum=53, SegmentNum=2, TestSeq=1, MessageType=11\n  Pointers: SubsysName=0x561013d95760, ShortDesc=0x7ffe44508ae0\n  After strlen(): FileLen=77\n    Loop: BasePtr=0x561013d8b094, *BasePtr='c', RemainingLen=76\n    Loop: BasePtr=0x561013d8b093, *BasePtr='.', RemainingLen=75\n    Loop: BasePtr=0x561013d8b092, *BasePtr='m', RemainingLen=74\n    Loop: BasePtr=0x561013d8b091, *BasePtr='e', RemainingLen=73\n    Loop: BasePtr=0x561013d8b090, *BasePtr='s', RemainingLen=72\n    Loop: BasePtr=0x561013d8b08f, *BasePtr='n', RemainingLen=71\n    Loop: BasePtr=0x561013d8b08e, *BasePtr='i', RemainingLen=70\n    Loop: BasePtr=0x561013d8b08d, *BasePtr='b', RemainingLen=69\n    Loop: BasePtr=0x561013d8b08c, *BasePtr='-', RemainingLen=68\n    Loop: BasePtr=0x561013d8b08b, *BasePtr='t', RemainingLen=67\n    Loop: BasePtr=0x561013d8b08a, *BasePtr='s', RemainingLen=66\n    Loop: BasePtr=0x561013d8b089, *BasePtr='e', RemainingLen=65\n    Loop: BasePtr=0x561013d8b088, *BasePtr='t', RemainingLen=64\n    Loop: BasePtr=0x561013d8b087, *BasePtr='e', RemainingLen=63\n    Loop: BasePtr=0x561013d8b086, *BasePtr='g', RemainingLen=62\n    Loop: BasePtr=0x561013d8b085, *BasePtr='a', RemainingLen=61\n    Loop: BasePtr=0x561013d8b084, *BasePtr='r', RemainingLen=60\n    Loop: BasePtr=0x561013d8b083, *BasePtr='e', RemainingLen=59\n    Loop: BasePtr=0x561013d8b082, *BasePtr='v', RemainingLen=58\n    Loop: BasePtr=0x561013d8b081, *BasePtr='o', RemainingLen=57\n    Loop: BasePtr=0x561013d8b080, *BasePtr='c', RemainingLen=56\n    Loop: BasePtr=0x561013d8b07f, *BasePtr='/', RemainingLen=55\n    Found separator, final BasePtr=0x561013d8b080\n  ReportBuffer: 02.001 coveragetest-binsem.c:53 - OS_BinSemCreate_Impl(&token, 0, 0) (0) == OS_SUCCESS (0)\nEXIT: UtAssert_DoReport\n\nENTER: UtAssert_DoReport\n  Params: File=0x561013d8b048, LineNum=56, SegmentNum=2, TestSeq=2, MessageType=11\n  Pointers: SubsysName=0x561013d95760, ShortDesc=0x7ffe44508ae0\n  After strlen(): FileLen=77\n    Loop: BasePtr=0x561013d8b094, *BasePtr='c', RemainingLen=76\n    Loop: BasePtr=0x561013d8b093, *BasePtr='.', RemainingLen=75\n    Loop: BasePtr=0x561013d8b092, *BasePtr='m', RemainingLen=74\n    Loop: BasePtr=0x561013d8b091, *BasePtr='e', RemainingLen=73\n    Loop: BasePtr=0x561013d8b090, *BasePtr='s', Rem\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_DoReport:\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UtAssert_DoReport calls strlen(File) without validating that File is non-NULL and points to a valid null-terminated array. strlen requires a valid pointer to a null-terminated string; if File == NULL (or if File is not null-terminated) the call invokes undefined behavior and may read beyond the bounds of the referenced object, which is exactly what MISRA C 2023 Rule 21.17 prohibits. UtAssertEx simply forwards its File parameter to UtAssert_DoReport unchanged and performs no NULL or bounds validation, so there is a realistic call path that could violate the rule. (The execution log only shows safe runtime examples and does not prove the absence of the problematic case.) To comply, the code should ensure File is non-NULL and refers to a valid null-terminated string before calling strlen (or otherwise document and enforce a non-NULL precondition)."
}