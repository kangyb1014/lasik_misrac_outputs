{
  "user_message": "An agent A claimed that the following UtAssert_DoReport code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_DoReport.\n```c\nvoid UtAssert_DoReport(const char *File, uint32 LineNum, uint32 SegmentNum, uint32 TestSeq, uint8 MessageType,\n                       const char *SubsysName, const char *ShortDesc)\n{\n    uint32      FileLen;\n    const char *BasePtr;\n    char        ReportBuffer[320];\n\n    FileLen = strlen(File);\n    BasePtr = File + FileLen;\n    while (FileLen > 0)\n    {\n        --BasePtr;\n        --FileLen;\n        if (*BasePtr == '/' || *BasePtr == '\\\\')\n        {\n            ++BasePtr;\n            break;\n        }\n    }\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u.%03u %s:%u - %s\", (unsigned int)SegmentNum,\n             (unsigned int)TestSeq, BasePtr, (unsigned int)LineNum, ShortDesc);\n\n    UT_BSP_DoText(MessageType, ReportBuffer);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strlen(File) can access memory beyond the bounds of the object referenced by File if File is NULL or not NUL-terminated. The subsequent loop uses BasePtr derived from that strlen result, but the actual string.h call (strlen) already risks out-of-bounds/undefined behavior. For example, if the caller passes File == NULL or a non-terminated buffer, strlen(File) will dereference invalid memory and violate Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtAssert_DoReport ENTRY: File=0x561051311048, LineNum=42, SegmentNum=1, TestSeq=1, MessageType=11, SubsysName=0x56105131b760, ShortDesc=0x7ffd0daebfb0\nAbout to call strlen(File)\nstrlen returned FileLen=77, File=0x561051311048, BasePtr=0x561051311095\nLoop iter: FileLen=76, BasePtr=0x561051311094, Char=0x63\nLoop iter: FileLen=75, BasePtr=0x561051311093, Char=0x2E\nLoop iter: FileLen=74, BasePtr=0x561051311092, Char=0x6D\nLoop iter: FileLen=73, BasePtr=0x561051311091, Char=0x65\nLoop iter: FileLen=72, BasePtr=0x561051311090, Char=0x73\nLoop iter: FileLen=71, BasePtr=0x56105131108f, Char=0x6E\nLoop iter: FileLen=70, BasePtr=0x56105131108e, Char=0x69\nLoop iter: FileLen=69, BasePtr=0x56105131108d, Char=0x62\nLoop iter: FileLen=68, BasePtr=0x56105131108c, Char=0x2D\nLoop iter: FileLen=67, BasePtr=0x56105131108b, Char=0x74\nLoop iter: FileLen=66, BasePtr=0x56105131108a, Char=0x73\nLoop iter: FileLen=65, BasePtr=0x561051311089, Char=0x65\nLoop iter: FileLen=64, BasePtr=0x561051311088, Char=0x74\nLoop iter: FileLen=63, BasePtr=0x561051311087, Char=0x65\nLoop iter: FileLen=62, BasePtr=0x561051311086, Char=0x67\nLoop iter: FileLen=61, BasePtr=0x561051311085, Char=0x61\nLoop iter: FileLen=60, BasePtr=0x561051311084, Char=0x72\nLoop iter: FileLen=59, BasePtr=0x561051311083, Char=0x65\nLoop iter: FileLen=58, BasePtr=0x561051311082, Char=0x76\nLoop iter: FileLen=57, BasePtr=0x561051311081, Char=0x6F\nLoop iter: FileLen=56, BasePtr=0x561051311080, Char=0x63\nLoop iter: FileLen=55, BasePtr=0x56105131107f, Char=0x2F\nReport sent: 01.001 coveragetest-binsem.c:42 - UT_Call_OS_VxWorks_BinSemAPI_Impl_Init() (0) == OS_SUCCESS (0)\nUtAssert_DoReport ENTRY: File=0x561051311048, LineNum=53, SegmentNum=2, TestSeq=1, MessageType=11, SubsysName=0x56105131b760, ShortDesc=0x7ffd0daebf90\nAbout to call strlen(File)\nstrlen returned FileLen=77, File=0x561051311048, BasePtr=0x561051311095\nLoop iter: FileLen=76, BasePtr=0x561051311094, Char=0x63\nLoop iter: FileLen=75, BasePtr=0x561051311093, Char=0x2E\nLoop iter: FileLen=74, BasePtr=0x561051311092, Char=0x6D\nLoop iter: FileLen=73, BasePtr=0x561051311091, Char=0x65\nLoop iter: FileLen=72, BasePtr=0x561051311090, Char=0x73\nLoop iter: FileLen=71, BasePtr=0x56105131108f, Char=0x6E\nLoop iter: FileLen=70, BasePtr=0x56105131108e, Char=0x69\nLoop iter: FileLen=69, BasePtr=0x56105131108d, Char=0x62\nLoop iter: FileLen=68, BasePtr=0x56105131108c, Char=0x2D\nLoop iter: FileLen=67, BasePtr=0x56105131108b, Char=0x74\nLoop iter: FileLen=66, BasePtr=0x56105131108a, Char=0x73\nLoop iter: FileLen=65, BasePtr=0x561051311089, Char=0x65\nLoop iter: FileLen=64, BasePtr=0x561051311088, Char=0x74\nLoop iter: FileLen=63, BasePtr=0x561051311087, Char=0x65\nLoop iter: FileLen=62, BasePtr=0x561051311086, Char=0x67\nLoop iter: FileLen=61, BasePtr=0x561051311085, Char=0x61\nLoop iter: FileLen=60, BasePtr=0x561051311084, Char=0x72\nLoop iter: FileLen=59, BasePtr=0x561051311083, Char=0x65\nLoop iter: FileLen=58, BasePtr=0x561051311082, Char=0x76\nLoop iter: FileLen=57, BasePtr=0x561051311081, Char=0x6F\nLoop iter: FileLen=56, BasePtr=0x561051311080, Char=0x63\nLoop iter: FileLen=55, BasePtr=0x56105131107f, Char=0x2F\nReport sent: 02.001 coveragetest-binsem.c:53 - OS_BinSemCreate_Impl(&token, 0, 0) (0) == OS_SUCCESS (0)\nUtAssert_DoReport ENTRY: File=0x561051311048, LineNum=56, SegmentNum=2, TestSeq=2, MessageType=11, SubsysName=0x56105131b760, ShortDesc=0x7ffd0daebf90\nAbout to call strlen(File)\nstrlen returned FileLen=77, File=0x561051311048, BasePtr=0x561051311095\nLoop iter: FileLen=76, BasePtr=0x561051311094, Char=0x63\nLoop iter: FileLen=75, BasePtr=0x561051311093, Char=0x2E\nLoop iter: FileLen=74, BasePtr=0x561051311092, Char=0x6D\nLoop iter: FileLen=73, BasePtr=0x561051311091, Char=0x65\nLoop iter: FileLen=72, BasePtr=0x561051311090, Char=0x73\nLoop iter: FileLen=71, BasePtr=0x56105131108f, Char=0x6E\nLoop iter: FileLen=70, BasePtr=0x56105131108e, Char=0x69\nLoop iter: FileLen=69, BasePtr=0x56105131108d, Char=0x62\nLoop iter: FileLen=68, BasePtr=0x56105131108c, Char=0x2D\nLoop iter: FileLen=67, BasePtr=0x56105131108b, Char=0x74\nLoop iter: FileLen=66, BasePtr=0x56105131108a, Char=0x\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_DoReport:\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 21.17 requires that calls to the <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. strlen(File) reads bytes until it finds a NUL terminator, so it requires that File points to a valid, NUL-terminated object and is not NULL. UtAssert_DoReport contains an unguarded call to strlen(File) with no check that File != NULL or that the buffer is NUL-terminated. From the provided code, File is forwarded from callers (e.g. UtAssertEx) and there is no static guarantee in the shown code that File cannot be NULL or non-terminated, so the strlen call can potentially access out-of-bounds memory or dereference NULL and therefore violates Rule 21.17. (Note: in practice callers often pass the __FILE__ literal which is NUL-terminated, but MISRA requires the code to ensure the precondition or perform a defensive check.) Recommended fixes: validate File != NULL before calling strlen, or use a bounded-length routine (e.g. strnlen with an explicit maximum) and handle the NULL case appropriately, or document and enforce a contract that File is always a valid NUL-terminated string and provide a static justification.)"
}