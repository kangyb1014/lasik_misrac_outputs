{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call memset(token, 0, sizeof(*token)) will write sizeof(OS_object_token_t) bytes at the address in token. If OS_ObjectIdTransactionInit is ever called with token == NULL (or with a pointer to a buffer smaller than sizeof(OS_object_token_t)), this will perform writes outside the bounds of the referenced object (e.g. memset(NULL,0,sizeof(*token)) is undefined). The function does not validate token before the memset, so callers that pass NULL or an undersized buffer will trigger an out-of-bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SocketListen code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2489.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SocketListen as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SocketListen:\n```c\nint32 OS_SocketListen(osal_id_t sock_id)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* This call is only applicable to stream sockets */\n        if (stream->socket_domain == OS_SocketDomain_INVALID || stream->socket_type != OS_SocketType_STREAM)\n        {\n            /* Not a stream socket */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((stream->stream_state & OS_STREAM_STATE_BOUND) == 0)\n        {\n            /* Socket must be bound to an address already */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_LISTENING | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither listening nor connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_SocketListen_Impl(&token);\n\n            if (return_code == OS_SUCCESS)\n            {\n                stream->stream_state |= OS_STREAM_STATE_LISTENING;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SocketListen code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe logging helper - appends human-readable control flow and state info\n * to /tmp/logs/2489.txt. Does not modify program state. */\nstatic void OS_SocketListen_Log(const char *stage,\n                                unsigned long long sock_id_val,\n                                int return_code,\n                                const void *token_ptr,\n                                const void *stream_ptr,\n                                int socket_domain,\n                                int socket_type,\n                                unsigned int stream_state)\n{\n    FILE *f = fopen(\"/tmp/logs/2489.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    fprintf(f, \"[OS_SocketListen] stage=%s sock_id=%llu return_code=%d token_ptr=%p stream_ptr=%p\\n\",\n            stage, sock_id_val, return_code, token_ptr, stream_ptr);\n\n    if (stream_ptr != NULL)\n    {\n        fprintf(f, \"  stream->socket_domain=%d stream->socket_type=%d stream->stream_state=0x%08x\\n\",\n                socket_domain, socket_type, stream_state);\n    }\n\n    fclose(f);\n}\n\nint32 OS_SocketListen(osal_id_t sock_id)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Log entry and input param */\n    OS_SocketListen_Log(\"entry\", (unsigned long long)sock_id, -1, NULL, NULL, 0, 0, 0);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n\n    /* Log result of lookup and the address of the token supplied to the lookup */\n    OS_SocketListen_Log(\"after_ObjectIdGetById\", (unsigned long long)sock_id, return_code, (const void *)&token, NULL, 0, 0, 0);\n\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Log stream pointer and (if available) some of its fields to capture state */\n        if (stream != NULL)\n        {\n            OS_SocketListen_Log(\"have_stream\", (unsigned long long)sock_id, return_code, (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n        }\n        else\n        {\n            OS_SocketListen_Log(\"null_stream\", (unsigned long long)sock_id, return_code, (const void *)&token, NULL, 0, 0, 0);\n        }\n\n        /* This call is only applicable to stream sockets */\n        if (stream->socket_domain == OS_SocketDomain_INVALID || stream->socket_type != OS_SocketType_STREAM)\n        {\n            /* Not a stream socket */\n            OS_SocketListen_Log(\"not_stream_socket\", (unsigned long long)sock_id, OS_ERR_INCORRECT_OBJ_TYPE, (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((stream->stream_state & OS_STREAM_STATE_BOUND) == 0)\n        {\n            /* Socket must be bound to an address already */\n            OS_SocketListen_Log(\"not_bound\", (unsigned long long)sock_id, OS_ERR_INCORRECT_OBJ_STATE, (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_LISTENING | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither listening nor connected */\n            OS_SocketListen_Log(\"already_listening_or_connected\", (unsigned long long)sock_id, OS_ERR_INCORRECT_OBJ_STATE,\n                                (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            OS_SocketListen_Log(\"before_Impl\", (unsigned long long)sock_id, return_code, (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n\n            return_code = OS_SocketListen_Impl(&token);\n\n            OS_SocketListen_Log(\"after_Impl\", (unsigned long long)sock_id, return_code, (const void *)&token,\n                                (const void *)stream,\n                                (int)stream->socket_domain,\n                                (int)stream->socket_type,\n                                (unsigned int)stream->stream_state);\n\n            if (return_code == OS_SUCCESS)\n            {\n                stream->stream_state |= OS_STREAM_STATE_LISTENING;\n\n                OS_SocketListen_Log(\"set_listening\", (unsigned long long)sock_id, return_code, (const void *)&token,\n                                    (const void *)stream,\n                                    (int)stream->socket_domain,\n                                    (int)stream->socket_type,\n                                    (unsigned int)stream->stream_state);\n            }\n        }\n\n        /* Log before releasing the token */\n        OS_SocketListen_Log(\"before_release\", (unsigned long long)sock_id, return_code, (const void *)&token, (const void *)stream,\n                            stream ? (int)stream->socket_domain : 0,\n                            stream ? (int)stream->socket_type : 0,\n                            stream ? (unsigned int)stream->stream_state : 0);\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after release (token address still logged for traceability) */\n        OS_SocketListen_Log(\"after_release\", (unsigned long long)sock_id, return_code, (const void *)&token, (const void *)stream,\n                            stream ? (int)stream->socket_domain : 0,\n                            stream ? (int)stream->socket_type : 0,\n                            stream ? (unsigned int)stream->stream_state : 0);\n    }\n\n    /* Final return value */\n    OS_SocketListen_Log(\"exit\", (unsigned long long)sock_id, return_code, NULL, NULL, 0, 0, 0);\n\n    return return_code;\n}\n"
}