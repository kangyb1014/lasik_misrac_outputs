{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe macro OS_CHECK_PATHNAME(name) expands to OS_CHECK_STRING(name, OS_MAX_PATH_LEN, ...). If that macro uses string.h functions such as strlen/strnlen/strncmp with the limit OS_MAX_PATH_LEN, then a call like OS_CHECK_PATHNAME(name) can read up to OS_MAX_PATH_LEN bytes from the pointer. If the caller supplies a char buffer that is shorter than OS_MAX_PATH_LEN and not NUL-terminated (or otherwise the actual object lifetime/size is < OS_MAX_PATH_LEN), the string functions will access bytes beyond the bounds of the object. Example: passing a non-NUL-terminated char array of length 8 as name while OS_MAX_PATH_LEN is 64; a strnlen(name, 64) or similar will read past the 8-byte object \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_chkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1799.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_chkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_chkfs:\n```c\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_chkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n\n/* Probe logging for OS_chkfs to capture control flow and state for debugging.\n * Logs are appended to /tmp/logs/1799.txt. This file is intended to help\n * reproduce string/bounds-related issues originating from OS_CHECK_PATHNAME.\n *\n * This instrumentation preserves the original control flow and does not\n * attempt to read the contents of the 'name' pointer (to avoid introducing\n * additional out-of-bounds accesses). It only logs pointer values and return\n * codes surrounding the places where a potential violation can occur.\n */\n\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n    FILE             *logf = NULL;\n\n    /* Entry log */\n    logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_chkfs ENTER: name=%p, repair=%d\\n\", (const void *)name, repair);\n        fflush(logf);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    /* Log just before the parameter-checking macro which may invoke string.h functions.\n     * Note: We intentionally do not dereference 'name' or call any string functions here.\n     */\n    logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_chkfs: about to invoke OS_CHECK_PATHNAME(name) with name=%p\\n\", (const void *)name);\n        fflush(logf);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Log immediately after the macro -- if the macro performed any out-of-bounds\n     * reads, tools like ASAN or a runtime monitor will report them; this log entry\n     * helps correlate that event to the call site.\n     */\n    logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_chkfs: returned from OS_CHECK_PATHNAME(name) for name=%p\\n\", (const void *)name);\n        fflush(logf);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_chkfs: OS_ObjectIdGetBySearch returned %ld for name=%p; token_addr=%p\\n\",\n                (long)return_code, (const void *)name, (void *)&token);\n        fflush(logf);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_chkfs: calling OS_FileSysCheckVolume_Impl with token_addr=%p, repair=%d\\n\",\n                    (void *)&token, repair);\n            fflush(logf);\n            fclose(logf);\n            logf = NULL;\n        }\n\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_chkfs: OS_FileSysCheckVolume_Impl returned %ld for token_addr=%p\\n\",\n                    (long)return_code, (void *)&token);\n            fflush(logf);\n            fclose(logf);\n            logf = NULL;\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_chkfs: OS_ObjectIdRelease called for token_addr=%p\\n\", (void *)&token);\n            fflush(logf);\n            fclose(logf);\n            logf = NULL;\n        }\n    }\n\n    /* Exit log */\n    logf = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_chkfs EXIT: return_code=%ld for name=%p\\n\", (long)return_code, (const void *)name);\n        fflush(logf);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    return return_code;\n}\n"
}