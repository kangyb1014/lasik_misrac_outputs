{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf filesys->virtual_mountpt has length mplen > 0 and mplen < sizeof(filesys->virtual_mountpt) (so a terminator exists in the filesys buffer) but the search target string is shorter than mplen, the call strncmp(target, filesys->virtual_mountpt, mplen) will read target[0..mplen-1], accessing bytes past the end of the target string/object. This can result in an out-of-bounds read of the target buffer (undefined behavior). The code does not ensure the target has at least mplen bytes accessible before calling strncmp, so Rule 21.17 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_chkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1799.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_chkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_chkfs:\n```c\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_chkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <time.h>\n#include <stdbool.h>\n\n/*\n * Probes and logging helpers to gather evidence for a potential\n * out-of-bounds read when the filesystem search compares a target\n * string against a stored virtual_mountpt using a length derived\n * from the stored buffer.\n *\n * Logs are appended to /tmp/logs/1799.txt. These helpers are designed\n * to avoid changing the original control flow or logic of OS_chkfs.\n */\n\nstatic void probe_ensure_logdir(void)\n{\n    /* Try to create the directory, ignore errors if it already exists */\n    (void)mkdir(\"/tmp/logs\", 0777);\n}\n\nstatic void probe_logf(const char *fmt, ...)\n{\n    probe_ensure_logdir();\n    FILE *f = fopen(\"/tmp/logs/1799.txt\", \"a\");\n    if (!f)\n        return;\n\n    time_t t = time(NULL);\n    struct tm tmv;\n    if (localtime_r(&t, &tmv) != NULL)\n    {\n        char timestr[64];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tmv))\n        {\n            fprintf(f, \"%s \", timestr);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Safely examine a C string up to a sensible maximum and log its content\n * in both ASCII (safe-print) and hexadecimal for byte-level analysis.\n * This avoids unbounded reads by limiting the scan to max_scan bytes.\n */\nstatic void probe_dump_cstring(const char *label, const char *s)\n{\n    if (s == NULL)\n    {\n        probe_logf(\"%s: NULL\", label);\n        return;\n    }\n\n    const size_t max_scan = 512; /* reasonable upper bound for logging */\n    size_t len = 0;\n    while (len < max_scan && s[len] != '\\0')\n        ++len;\n\n    probe_logf(\"%s: ptr=%p, scanned_len=%zu%s\", label, (const void *)s, len, (len == max_scan ? \" (truncated)\" : \"\"));\n\n    /* ASCII-safe print: replace non-printables with '.' */\n    char asafe[513];\n    size_t i;\n    for (i = 0; i < len && i < 512; ++i)\n    {\n        unsigned char c = (unsigned char)s[i];\n        asafe[i] = (c >= 0x20 && c <= 0x7e) ? (char)c : '.';\n    }\n    asafe[i] = '\\0';\n    if (len > 0)\n        probe_logf(\"%s (ascii): '%s'\", label, asafe);\n\n    /* Hex dump (limited) */\n    char hexbuf[3 * 256 + 1];\n    size_t hx = 0;\n    size_t limit = (len < 256) ? len : 256;\n    for (i = 0; i < limit; ++i)\n    {\n        int n = snprintf(&hexbuf[hx], sizeof(hexbuf) > hx ? sizeof(hexbuf) - hx : 0, \"%02X%s\",\n                         (unsigned char)s[i], (i + 1 < limit) ? \" \" : \"\");\n        if (n < 0)\n            break;\n        hx += (size_t)n;\n        if (hx >= sizeof(hexbuf))\n            break;\n    }\n    hexbuf[(hx < sizeof(hexbuf)) ? hx : (sizeof(hexbuf) - 1)] = '\\0';\n    if (limit > 0)\n        probe_logf(\"%s (hex, up to 256 bytes): %s\", label, hexbuf);\n}\n\n/* The original function, augmented with logging probes. The original\n * control flow and semantics are preserved; only non-invasive logging\n * is inserted to capture key state and control path information.\n */\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and inspect the provided name safely */\n    probe_logf(\"OS_chkfs: entry\");\n    probe_dump_cstring(\"name\", name);\n    probe_logf(\"repair=%d\", (int)repair);\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    probe_logf(\"Calling OS_ObjectIdGetBySearch with search callback OS_FileSys_FindVirtMountPoint\");\n    probe_logf(\"-> name ptr=%p\", (const void *)name);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    probe_logf(\"OS_ObjectIdGetBySearch returned %d\", (int)return_code);\n    probe_logf(\"token (stack addr) = %p\", (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_logf(\"About to call OS_FileSysCheckVolume_Impl with token\");\n\n        /* If possible, dump a small memory snapshot of the token for debugging.\n         * Note: token size/representation is platform dependent. We only\n         * log the bytes up to a safe limit to avoid side effects. */\n        size_t token_bytes = sizeof(token) > 0 ? sizeof(token) : 0;\n        if (token_bytes > 0)\n        {\n            size_t dump_len = token_bytes > 64 ? 64 : token_bytes;\n            unsigned char buf[64];\n            /* Copy the token bytes safely into a local buffer for hex logging. */\n            memcpy(buf, &token, dump_len);\n            char thex[3 * 64 + 1];\n            size_t hx = 0;\n            for (size_t i = 0; i < dump_len; ++i)\n            {\n                int n = snprintf(&thex[hx], sizeof(thex) > hx ? sizeof(thex) - hx : 0, \"%02X%s\",\n                                 buf[i], (i + 1 < dump_len) ? \" \" : \"\");\n                if (n < 0) break;\n                hx += (size_t)n;\n                if (hx >= sizeof(thex)) break;\n            }\n            thex[(hx < sizeof(thex)) ? hx : (sizeof(thex) - 1)] = '\\0';\n            probe_logf(\"token bytes (hex, up to 64): %s\", thex);\n        }\n\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        probe_logf(\"OS_FileSysCheckVolume_Impl returned %d\", (int)return_code);\n\n        OS_ObjectIdRelease(&token);\n        probe_logf(\"OS_ObjectIdRelease called\");\n    }\n\n    probe_logf(\"OS_chkfs: exit returning %d\", (int)return_code);\n    return return_code;\n}\n"
}