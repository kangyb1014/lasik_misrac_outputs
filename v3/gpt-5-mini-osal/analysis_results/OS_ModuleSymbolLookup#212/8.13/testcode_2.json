{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe macro OS_OBJECT_TABLE_GET expands to take the address of a table element and returns a non-const pointer to it (&tbl[...]). In OS_ModuleSymbolLookup this is used as\n    record = OS_OBJECT_TABLE_GET(OS_global_module_table, token);\nbut record is only read (record->name_entry is passed to OS_SymbolLookup_Static) and never modified. Therefore the pointer could and should be const-qualified (e.g. const OS_common_record_t *record), but the macro forces a non-const pointer. This violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ModuleSymbolLookup code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2123.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ModuleSymbolLookup as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ModuleSymbolLookup:\n```c\nint32 OS_ModuleSymbolLookup(osal_id_t module_id, cpuaddr *symbol_address, const char *symbol_name)\n{\n    int32               return_code;\n    int32               staticsym_status;\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n\n    /*\n    ** Check parameters\n    */\n    OS_CHECK_POINTER(symbol_address);\n    OS_CHECK_POINTER(symbol_name);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, module_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_module_table, token);\n\n        return_code = OS_ModuleSymbolLookup_Impl(&token, symbol_address, symbol_name);\n        if (return_code != OS_SUCCESS)\n        {\n            /* look for a static symbol that also matches this module name */\n            staticsym_status = OS_SymbolLookup_Static(symbol_address, symbol_name, record->name_entry);\n\n            /*\n             * Only overwrite the return code if static lookup was successful.\n             * Otherwise keep the error code from the low level implementation.\n             */\n            if (staticsym_status == OS_SUCCESS)\n            {\n                return_code = staticsym_status;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ModuleSymbolLookup code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <string.h>\n#include <inttypes.h>\n\n/* Minimal typedefs and types to make the test harness self-contained */\ntypedef uint32_t osal_id_t;\ntypedef uintptr_t cpuaddr;\ntypedef int32_t int32;\ntypedef uint32_t OS_object_token_t;\n\n/* Return codes and constants (as variables to avoid macros per constraints) */\nstatic const int32 OS_SUCCESS = 0;\nstatic const int32 OS_ERROR_GENERAL = -1;\nstatic const size_t OS_GLOBAL_TABLE_SIZE = 8U;\n\n/* A simplified common record that mirrors the real structure sufficiently for logging */\ntypedef struct\n{\n    char *name_entry;\n    /* other fields not needed for this test harness */\n} OS_common_record_t;\n\n/* Global module table used by the OS_OBJECT_TABLE_GET function */\nstatic OS_common_record_t OS_global_module_table[8] =\n{\n    { \"mod0\" },\n    { \"mod1\" },\n    { \"mod2\" },\n    { \"mod3\" },\n    { \"mod4\" },\n    { \"mod5\" },\n    { \"mod6\" },\n    { \"mod7\" }\n};\n\n/* Probe logging helper: appends diagnostic lines to /tmp/logs/2123.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2123.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging is unavailable, silently continue to preserve original logic */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n/* Replacement for the macro that returns the address of a table element.\n * The original macro behavior (taking the address of an element) is preserved.\n * Implemented as a function here so no macros are introduced. */\nstatic OS_common_record_t *OS_OBJECT_TABLE_GET(OS_common_record_t *table, OS_object_token_t token)\n{\n    if (table == NULL)\n    {\n        probe_log(\"OS_OBJECT_TABLE_GET: NULL table passed\");\n        return NULL;\n    }\n\n    /* Bound check to avoid undefined behavior in the test harness */\n    if ((size_t)token >= OS_GLOBAL_TABLE_SIZE)\n    {\n        probe_log(\"OS_OBJECT_TABLE_GET: token out of range: %u\", (unsigned)token);\n        return NULL;\n    }\n\n    OS_common_record_t *rec = &table[token];\n    probe_log(\"OS_OBJECT_TABLE_GET: table=%p token=%u -> record=%p (name_entry=%p, name=\\\"%s\\\")\",\n              (void *)table, (unsigned)token, (void *)rec, (void *)rec->name_entry,\n              (rec->name_entry != NULL) ? rec->name_entry : \"(null)\");\n    return rec;\n}\n\n/* Minimal stubs for OSAL functions used by OS_ModuleSymbolLookup. These stubs\n * are designed to reproduce the control flow in the violation scenario and to\n * log relevant state. */\nstatic void OS_CHECK_POINTER(const void *ptr)\n{\n    /* Original macro might have returned on error; for probe purposes we log and continue. */\n    if (ptr == NULL)\n    {\n        probe_log(\"OS_CHECK_POINTER: NULL pointer detected\");\n    }\n    else\n    {\n        probe_log(\"OS_CHECK_POINTER: pointer=%p\", ptr);\n    }\n}\n\nstatic int32 OS_ObjectIdGetById(int32 lock_mode, int32 objtype, osal_id_t module_id, OS_object_token_t *token)\n{\n    (void)lock_mode;\n    (void)objtype;\n\n    if (token == NULL)\n    {\n        probe_log(\"OS_ObjectIdGetById: NULL token pointer\");\n        return OS_ERROR_GENERAL;\n    }\n\n    /* Map module_id into a token for the table (wrap around if necessary) */\n    *token = (OS_object_token_t)(module_id % (osal_id_t)OS_GLOBAL_TABLE_SIZE);\n    probe_log(\"OS_ObjectIdGetById: module_id=%"
}