{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nOS_printf calls OS_DEBUG. If OS_DEBUG is implemented (directly or as a macro) to call OS_printf (e.g. OS_DEBUG -> OS_printf), this creates an indirect recursive call chain OS_printf -> OS_DEBUG -> OS_printf, violating MISRA C 2023 Rule 17.2 (functions shall not call themselves directly or indirectly).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ModuleSymbolLookup code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2126.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ModuleSymbolLookup as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ModuleSymbolLookup:\n```c\nint32 OS_ModuleSymbolLookup(osal_id_t module_id, cpuaddr *symbol_address, const char *symbol_name)\n{\n    int32               return_code;\n    int32               staticsym_status;\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n\n    /*\n    ** Check parameters\n    */\n    OS_CHECK_POINTER(symbol_address);\n    OS_CHECK_POINTER(symbol_name);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, module_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_module_table, token);\n\n        return_code = OS_ModuleSymbolLookup_Impl(&token, symbol_address, symbol_name);\n        if (return_code != OS_SUCCESS)\n        {\n            /* look for a static symbol that also matches this module name */\n            staticsym_status = OS_SymbolLookup_Static(symbol_address, symbol_name, record->name_entry);\n\n            /*\n             * Only overwrite the return code if static lookup was successful.\n             * Otherwise keep the error code from the low level implementation.\n             */\n            if (staticsym_status == OS_SUCCESS)\n            {\n                return_code = staticsym_status;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ModuleSymbolLookup code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe helper: append a line to the log file with a simple message. */\nstatic void OS_ModuleSymbolLookup_log_simple(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/2126.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\n\n/* Probe helper: formatted log line (keeps implementation minimal to avoid varargs complexity). */\nstatic void OS_ModuleSymbolLookup_log_fmt(const char *prefix, unsigned long v1,\n                                          const void *p1, int v2)\n{\n    char buf[512];\n\n    /* Compose a compact status line with up to one integer, one pointer and one int. */\n    snprintf(buf, sizeof(buf), \"%s: val=%lu ptr=%p code=%d\", prefix, v1, p1, v2);\n    OS_ModuleSymbolLookup_log_simple(buf);\n}\n\nint32 OS_ModuleSymbolLookup(osal_id_t module_id, cpuaddr *symbol_address, const char *symbol_name)\n{\n    int32               return_code;\n    int32               staticsym_status;\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n\n    /* Log entry with key parameters */\n    {\n        char buf[512];\n        snprintf(buf, sizeof(buf), \"ENTRY: OS_ModuleSymbolLookup module_id=%lu symbol_name=%s symbol_address=%p\",\n                 (unsigned long)module_id,\n                 (symbol_name != NULL) ? symbol_name : \"(null)\",\n                 (void *)symbol_address);\n        OS_ModuleSymbolLookup_log_simple(buf);\n    }\n\n    /*\n    ** Check parameters\n    */\n    OS_CHECK_POINTER(symbol_address);\n    OS_CHECK_POINTER(symbol_name);\n\n    /* Log after parameter checks */\n    OS_ModuleSymbolLookup_log_simple(\"After parameter checks\");\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of ObjectIdGetById */\n    OS_ModuleSymbolLookup_log_fmt(\"After OS_ObjectIdGetById\", (unsigned long)module_id, (void *)&token, (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_module_table, token);\n\n        /* Log before low-level implementation call */\n        {\n            char buf[512];\n            snprintf(buf, sizeof(buf), \"Calling OS_ModuleSymbolLookup_Impl for module '%s' (module_id=%lu)\",\n                     (record && record->name_entry) ? record->name_entry : \"(unknown)\",\n                     (unsigned long)module_id);\n            OS_ModuleSymbolLookup_log_simple(buf);\n        }\n\n        return_code = OS_ModuleSymbolLookup_Impl(&token, symbol_address, symbol_name);\n\n        /* Log return from low-level implementation */\n        OS_ModuleSymbolLookup_log_fmt(\"After OS_ModuleSymbolLookup_Impl\", (unsigned long)module_id, (void *)symbol_address, (int)return_code);\n\n        if (return_code != OS_SUCCESS)\n        {\n            /* look for a static symbol that also matches this module name */\n            OS_ModuleSymbolLookup_log_simple(\"OS_ModuleSymbolLookup_Impl failed, attempting OS_SymbolLookup_Static\");\n\n            staticsym_status = OS_SymbolLookup_Static(symbol_address, symbol_name, record->name_entry);\n\n            /* Log result of static lookup */\n            OS_ModuleSymbolLookup_log_fmt(\"After OS_SymbolLookup_Static\", (unsigned long)module_id, (void *)symbol_address, (int)staticsym_status);\n\n            /*\n             * Only overwrite the return code if static lookup was successful.\n             * Otherwise keep the error code from the low level implementation.\n             */\n            if (staticsym_status == OS_SUCCESS)\n            {\n                return_code = staticsym_status;\n                OS_ModuleSymbolLookup_log_simple(\"Static symbol lookup succeeded, overwriting return_code\");\n            }\n            else\n            {\n                OS_ModuleSymbolLookup_log_simple(\"Static symbol lookup failed, keeping original return_code\");\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log release of token */\n        OS_ModuleSymbolLookup_log_fmt(\"Released token\", (unsigned long)module_id, (void *)&token, (int)return_code);\n    }\n    else\n    {\n        /* Log failure to get object id */\n        OS_ModuleSymbolLookup_log_fmt(\"OS_ObjectIdGetById failed\", (unsigned long)module_id, (void *)&token, (int)return_code);\n    }\n\n    /* Final return value log */\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"EXIT: OS_ModuleSymbolLookup module_id=%lu return_code=%d\",\n                 (unsigned long)module_id, (int)return_code);\n        OS_ModuleSymbolLookup_log_simple(buf);\n    }\n\n    return return_code;\n}\n"
}