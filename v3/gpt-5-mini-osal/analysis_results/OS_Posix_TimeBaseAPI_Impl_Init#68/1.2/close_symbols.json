{
  "user_message": "Target function code is:\n```c\nint32 OS_Posix_TimeBaseAPI_Impl_Init(void)\n{\n    int                 status;\n    osal_index_t        idx;\n    pthread_mutexattr_t mutex_attr;\n    struct timespec     clock_resolution;\n    int32               return_code;\n\n    return_code = OS_SUCCESS;\n\n    do\n    {\n        /*\n        ** Mark all timers as available\n        */\n        memset(OS_impl_timebase_table, 0, sizeof(OS_impl_timebase_table));\n\n        /*\n        ** get the resolution of the selected clock\n        */\n        status = clock_getres(OS_PREFERRED_CLOCK, &clock_resolution);\n        if (status != 0)\n        {\n            OS_DEBUG(\"failed in clock_getres: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Convert to microseconds\n        ** Note that the resolution MUST be in the sub-second range, if not then\n        ** it looks like the POSIX timer API in the C library is broken.\n        ** Note for any flavor of RTOS we would expect <= 1ms.  Even a \"desktop\"\n        ** linux or development system should be <= 100ms absolute worst-case.\n        */\n        if (clock_resolution.tv_sec > 0)\n        {\n            return_code = OS_TIMER_ERR_INTERNAL;\n            break;\n        }\n\n        /* Round to the nearest microsecond */\n        POSIX_GlobalVars.ClockAccuracyNsec = (uint32)(clock_resolution.tv_nsec);\n\n        /*\n        ** initialize the attribute with default values\n        */\n        status = pthread_mutexattr_init(&mutex_attr);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Allow the mutex to use priority inheritance\n        */\n        status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            /*\n            ** create the timebase sync mutex\n            ** This gives a mechanism to synchronize updates to the timer chain with the\n            ** expiration of the timer and processing the chain.\n            */\n            status = pthread_mutex_init(&OS_impl_timebase_table[idx].handler_mutex, &mutex_attr);\n            if (status != 0)\n            {\n                OS_DEBUG(\"Error: Mutex could not be created: %s\\n\", strerror(status));\n                return_code = OS_ERROR;\n                break;\n            }\n        }\n\n        /*\n         * Pre-calculate the clock tick to microsecond conversion factor.\n         */\n        OS_SharedGlobalVars.TicksPerSecond = sysconf(_SC_CLK_TCK);\n        if (OS_SharedGlobalVars.TicksPerSecond <= 0)\n        {\n            OS_DEBUG(\"Error: Unable to determine OS ticks per second: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n         * Calculate microseconds per tick\n         *  - If the ratio is not an integer, this will round to the nearest integer value\n         *  - This is used internally for reporting accuracy,\n         *  - TicksPerSecond values over 2M will return zero\n         */\n        OS_SharedGlobalVars.MicroSecPerTick =\n            (1000000 + (OS_SharedGlobalVars.TicksPerSecond / 2)) / OS_SharedGlobalVars.TicksPerSecond;\n    } while (0);\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_Posix_TimeBaseAPI_Impl_Init': {'callees': [], 'callers': ['OS_API_Impl_Init']}, 'OS_API_Impl_Init': {'callees': ['OS_Posix_TableMutex_Init', 'OS_Posix_TaskAPI_Impl_Init', 'OS_Posix_QueueAPI_Impl_Init', 'OS_Posix_BinSemAPI_Impl_Init', 'OS_Posix_CountSemAPI_Impl_Init', 'OS_Posix_MutexAPI_Impl_Init', 'OS_Posix_ModuleAPI_Impl_Init', 'OS_Posix_TimeBaseAPI_Impl_Init', 'OS_Posix_StreamAPI_Impl_Init', 'OS_Posix_DirAPI_Impl_Init', 'OS_Posix_FileSysAPI_Impl_Init', 'OS_Posix_CondVarAPI_Impl_Init'], 'callers': ['OS_API_Init']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_impl_timebase_table",
    "OS_MAX_TIMEBASES",
    "osal_index_t",
    "int32",
    "uint32",
    "POSIX_GlobalVars",
    "POSIX_GlobalVars.ClockAccuracyNsec",
    "OS_SharedGlobalVars",
    "OS_SharedGlobalVars.TicksPerSecond",
    "OS_SharedGlobalVars.MicroSecPerTick",
    "OS_SUCCESS",
    "OS_ERROR",
    "OS_TIMER_ERR_INTERNAL",
    "OS_DEBUG",
    "OS_PREFERRED_CLOCK",
    "memset",
    "clock_getres",
    "struct timespec",
    "clock_resolution.tv_sec",
    "clock_resolution.tv_nsec",
    "strerror",
    "errno",
    "pthread_mutexattr_t",
    "pthread_mutexattr_init",
    "pthread_mutexattr_setprotocol",
    "pthread_mutex_init",
    "PTHREAD_PRIO_INHERIT",
    "sysconf",
    "_SC_CLK_TCK"
  ],
  "explanation": "Each listed symbol is referenced directly in the target function and must be inspected to determine whether its declaration/definition uses any compiler-specific language extensions (the subject of the MISRA check). Brief reasons: \n\n- OS_impl_timebase_table: global object used by memset and pthread_mutex_init; its type/definition could use compiler extensions (attributes, packed/section, nonstandard qualifiers).\n- OS_MAX_TIMEBASES: compile-time constant controlling a loop; may be a macro or enum defined via extensions.\n- osal_index_t: typedef for the loop index; might be an implementation-defined type or use extension keywords.\n- int32: typedef/alias for return type; could be a nonstandard typedef or implemented with compiler-specific integer types.\n- uint32: typedef used for assignment; definition must be checked for extensions.\n- POSIX_GlobalVars: global struct; its definition/members might use compiler attributes or nonstandard extensions.\n- POSIX_GlobalVars.ClockAccuracyNsec: member written in the function; its type/definition must be inspected for extensions.\n- OS_SharedGlobalVars: global struct used for tick calculation; definition could include attributes or extensions.\n- OS_SharedGlobalVars.TicksPerSecond: member read/written by function; its type may hide extensions.\n- OS_SharedGlobalVars.MicroSecPerTick: member written; need to confirm its type/definition.\n- OS_SUCCESS, OS_ERROR, OS_TIMER_ERR_INTERNAL: status macros/enums used as return codes; could be implemented using compiler-specific constructs.\n- OS_DEBUG: debugging macro; macros often hide compiler extensions (variadic macro usage, statement expressions, __attribute__, GCC builtins) so its definition must be checked.\n- OS_PREFERRED_CLOCK: macro/constant passed to clock_getres; could be defined via nonstandard constructs.\n- memset: standard C function, but include to verify it is the standard library symbol and not replaced by a compiler intrinsic or extension macro in this project.\n- clock_getres: POSIX function; included to confirm it is standard POSIX usage (not a wrapped macro using extensions).\n- struct timespec: type from <time.h>; its definition and use (tv_sec/tv_nsec) should be checked to ensure no nonstandard modifications.\n- clock_resolution.tv_sec, clock_resolution.tv_nsec: struct members used in checks and assignments; ensure their definitions are standard.\n- strerror: standard library function; include to ensure no project-specific extension macros alter its semantics.\n- errno: macro (possibly thread-local); its definition can be implementation-specific (macro returning function), so check for extensions.\n- pthread_mutexattr_t: POSIX type; its definition or typedef could involve compiler extensions on some platforms.\n- pthread_mutexattr_init, pthread_mutexattr_setprotocol, pthread_mutex_init: POSIX functions; include to confirm calls are to standard APIs and not macros/wrappers that use extensions.\n- PTHREAD_PRIO_INHERIT: POSIX macro constant used with pthread mutex attributes; check definition for any extensions.\n- sysconf: POSIX/sysconf function; include to ensure constant _SC_CLK_TCK and usage are standard.\n- _SC_CLK_TCK: compile-time constant macro; its definition may vary by platform and could be an extension.\n\nIn short: to determine whether the target function uses any compiler-specific language extensions you must inspect the declarations/definitions of all referenced typedefs, macros, global variables, and any project-wrapped/library functions (the symbols above) because those definitions are where nonstandard/extension constructs would appear (e.g., GCC statement-expressions, __attribute__ annotated definitions, compiler-specific integer types or builtins, nonstandard macro expansions)."
}