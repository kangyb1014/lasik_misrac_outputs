{
  "user_message": "An agent A claimed that the following UT_BSP_Setup code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_Setup.\n```c\nvoid UT_BSP_Setup(void)\n{\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV;\n\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    UserShift = UTASSERT_CASETYPE_NONE;\n    ArgC      = OS_BSP_GetArgC();\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UserShift = strtoul(ArgV[1], NULL, 0);\n                ++ArgV;\n            }\n\n            ++ArgV;\n        }\n    }\n\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2 << UserShift) - 1;\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nArgV is declared as char *const *ArgV (pointer to a const pointer to non-const char). In the fragment ArgV[1] is passed to strtoul(const char *), and the pointed-to characters are not modified by the code. Therefore the pointed-to type could and should be const-qualified (e.g. const char * const *ArgV). This means the pointer does not point to a const-qualified type when possible \u2014 violating MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7ffe34bdd618\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-binsem-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7ffe34bdd618, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-binsem-testrunner\nAdvance ArgV to 0x7ffe34bdd620\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7ffe49d27678\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-common-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7ffe49d27678, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-common-testrunner\nAdvance ArgV to 0x7ffe49d27680\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7ffc84894988\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-console-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7ffc84894988, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-console-testrunner\nAdvance ArgV to 0x7ffc84894990\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7fff560cbbf8\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-countsem-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7fff560cbbf8, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-countsem-testrunner\nAdvance ArgV to 0x7fff560cbc00\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7ffe600dd3c8\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-dirs-globals-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7ffe600dd3c8, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-dirs-globals-testrunner\nAdvance ArgV to 0x7ffe600dd3d0\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7fff38a0f5a8\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-files-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7fff38a0f5a8, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-files-testrunner\nAdvance ArgV to 0x7fff38a0f5b0\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7ffee54f5768\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-filesys-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7ffee54f5768, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-filesys-testrunner\nAdvance ArgV to 0x7ffee54f5770\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_Setup: Entry. ArgC=1\nUT_BSP_Setup: Got ArgV pointer=0x7fffbbc7b338\nUT_BSP_Setup: ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-idmap-testrunner\nLoop start: remaining ArgC=0, ArgV=0x7fffbbc7b338, ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-idmap-testrunner\nAdvance ArgV to 0x7fffbbc7b340\nUserShift out of range or none; defaulting to PASS. Current UserShift=0\nFinal UserShift=11, CurrVerbosity=4095\nUT_BSP_Setup: Exit (UT_BSP_DoText called)\nUT_BSP_S\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 encourages pointers to point to const-qualified objects when that is feasible, but it must be interpreted in the context of the interfaces used. In this function ArgV is declared as char *const * (a pointer to const pointer-to-char). The code only reads the pointed-to characters, so from a pure const-correctness viewpoint the pointed-to characters could be const (i.e. const char *const *). However ArgV is assigned from OS_BSP_GetArgV(), and if that API returns char *const * (the common historical signature for argv-style APIs) then you cannot change the local declaration to const char *const * without either changing the external API or performing an explicit cast. MISRA\u2019s \u201cwhenever possible\u201d wording does not require you to add unsafe casts or to break compatibility with the called API. Also, passing ArgV[1] (char *) to strtoul(const char *) is allowed (adding const at the callee level). Therefore, unless the OS_BSP_GetArgV prototype is known and already returns non-const pointers, this snippet by itself is not an unambiguous violation. If OS_BSP_GetArgV can be changed to return const char *const * (or already does), then ArgV should be declared const char *const *; otherwise the report is not correct for the code as shown."
}