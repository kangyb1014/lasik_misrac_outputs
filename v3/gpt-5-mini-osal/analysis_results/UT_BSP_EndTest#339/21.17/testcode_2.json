{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes \u2014 strlen(OutputMessage) can read beyond the bounds if OutputMessage does not point to a NUL-terminated C string. For example: char buf[10]; memcpy(buf, src, 10); /* no terminating '\\0' */ UT_BSP_DoText(UTASSERT_CASETYPE_INFO, buf); strlen(buf) will scan past buf and may access out-of-bounds memory. The same happens if OutputMessage is NULL \u2014 strlen(NULL) is undefined. Unless every caller is guaranteed to pass a valid NUL-terminated string, this use can violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_BSP_EndTest code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3399.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_BSP_EndTest as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_BSP_EndTest:\n```c\nvoid UT_BSP_EndTest(const UtAssert_TestCounter_t *TestCounters)\n{\n    char Message[128];\n\n    /*\n     * Only output a \"summary\" if there is more than one test Segment.\n     * Otherwise it is a duplicate of the report already given.\n     */\n    if (TestCounters->TestSegmentCount > 1)\n    {\n        UtAssert_DoTestSegmentReport(\"SUMMARY\", TestCounters);\n    }\n\n    snprintf(Message, sizeof(Message), \"COMPLETE: %u tests Segment(s) executed\\n\\n\",\n             (unsigned int)TestCounters->TestSegmentCount);\n\n    UT_BSP_Lock();\n    OS_BSP_ConsoleOutput_Impl(Message, strlen(Message));\n    UT_BSP_Unlock();\n\n    if ((TestCounters->CaseCount[UTASSERT_CASETYPE_FAILURE] > 0) ||\n        (TestCounters->CaseCount[UTASSERT_CASETYPE_TSF] > 0) || (TestCounters->CaseCount[UTASSERT_CASETYPE_TTF] > 0))\n    {\n        OS_BSP_SetExitCode(OS_ERROR);\n    }\n    else\n    {\n        OS_BSP_SetExitCode(OS_SUCCESS);\n    }\n}\n```\n</target_code>\nPlease provide the modified UT_BSP_EndTest code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Helper: scan up to max_len bytes to find NUL without invoking strlen on possibly unterminated buffers */\nstatic size_t safe_strlen_limited(const char *s, size_t max_len)\n{\n    size_t i;\n    if (s == NULL)\n    {\n        return (size_t)-1; /* indicate NULL pointer */\n    }\n    for (i = 0; i < max_len; ++i)\n    {\n        if (s[i] == '\\0')\n        {\n            return i; /* found NUL within bounds */\n        }\n    }\n    return max_len; /* NUL not found within max_len */\n}\n\n/* Helper: append probe information to the log file */\nstatic void write_probe_log(const char *stage, const char *buf, size_t buf_size, unsigned int seg_count)\n{\n    FILE *f = fopen(\"/tmp/logs/3399.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only; do not change program behavior */\n    }\n\n    fprintf(f, \"---- UT_BSP_EndTest probe (%s) ----\\n\", stage);\n    fprintf(f, \"TestSegmentCount = %u\\n\", seg_count);\n    fprintf(f, \"Buffer address = %p, buffer_size = %zu\\n\", (const void *)buf, buf_size);\n\n    if (buf == NULL)\n    {\n        fprintf(f, \"Buffer pointer is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    size_t safe_len = safe_strlen_limited(buf, buf_size);\n\n    if (safe_len == (size_t)-1)\n    {\n        fprintf(f, \"Buffer pointer is NULL (detected in safe_strlen_limited)\\n\");\n        fclose(f);\n        return;\n    }\n\n    if (safe_len < buf_size)\n    {\n        /* There is a NUL within the buffer bounds. It's safe to call strlen. */\n        size_t real_len = strlen(buf);\n        fprintf(f, \"NUL found at offset %zu (within buffer). strlen() = %zu\\n\", safe_len, real_len);\n        fprintf(f, \"Buffer contents (as string): '%s'\\n\", buf);\n    }\n    else\n    {\n        /* No NUL within the provided buffer size -- record raw bytes to help reproduce */\n        fprintf(f, \"No NUL found within first %zu bytes -> potential out-of-bounds read if strlen() is called.\\n\", buf_size);\n        fprintf(f, \"Hex dump of first %zu bytes:\\n\", buf_size);\n        for (size_t i = 0; i < buf_size; ++i)\n        {\n            fprintf(f, \"%02X \", (unsigned char)buf[i]);\n            if ((i + 1) % 16 == 0)\n            {\n                fprintf(f, \"\\n\");\n            }\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fprintf(f, \"---- end probe (%s) ----\\n\\n\", stage);\n    fclose(f);\n}\n\nvoid UT_BSP_EndTest(const UtAssert_TestCounter_t *TestCounters)\n{\n    char Message[128];\n\n    /*\n     * Only output a \"summary\" if there is more than one test Segment.\n     * Otherwise it is a duplicate of the report already given.\n     */\n    if (TestCounters->TestSegmentCount > 1)\n    {\n        UtAssert_DoTestSegmentReport(\"SUMMARY\", TestCounters);\n    }\n\n    snprintf(Message, sizeof(Message), \"COMPLETE: %u tests Segment(s) executed\\n\\n\",\n             (unsigned int)TestCounters->TestSegmentCount);\n\n    /* Probe: log state immediately after formatting the Message buffer */\n    write_probe_log(\"after_snprintf\", Message, sizeof(Message), (unsigned int)TestCounters->TestSegmentCount);\n\n    UT_BSP_Lock();\n\n    /* Probe: log state just before calling ConsoleOutput_Impl (to capture length used and buffer state) */\n    write_probe_log(\"before_console_output\", Message, sizeof(Message), (unsigned int)TestCounters->TestSegmentCount);\n\n    /* Original call preserved */\n    OS_BSP_ConsoleOutput_Impl(Message, strlen(Message));\n\n    UT_BSP_Unlock();\n\n    if ((TestCounters->CaseCount[UTASSERT_CASETYPE_FAILURE] > 0) ||\n        (TestCounters->CaseCount[UTASSERT_CASETYPE_TSF] > 0) || (TestCounters->CaseCount[UTASSERT_CASETYPE_TTF] > 0))\n    {\n        OS_BSP_SetExitCode(OS_ERROR);\n    }\n    else\n    {\n        OS_BSP_SetExitCode(OS_SUCCESS);\n    }\n\n    /* Final probe: record exit code decision and a last snapshot of Message */\n    write_probe_log(\"end_of_function\", Message, sizeof(Message), (unsigned int)TestCounters->TestSegmentCount);\n}\n"
}