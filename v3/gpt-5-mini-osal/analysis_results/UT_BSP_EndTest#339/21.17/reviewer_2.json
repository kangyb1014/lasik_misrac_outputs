{
  "user_message": "An agent A claimed that the following UT_BSP_EndTest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_EndTest.\n```c\nvoid UT_BSP_EndTest(const UtAssert_TestCounter_t *TestCounters)\n{\n    char Message[128];\n\n    /*\n     * Only output a \"summary\" if there is more than one test Segment.\n     * Otherwise it is a duplicate of the report already given.\n     */\n    if (TestCounters->TestSegmentCount > 1)\n    {\n        UtAssert_DoTestSegmentReport(\"SUMMARY\", TestCounters);\n    }\n\n    snprintf(Message, sizeof(Message), \"COMPLETE: %u tests Segment(s) executed\\n\\n\",\n             (unsigned int)TestCounters->TestSegmentCount);\n\n    UT_BSP_Lock();\n    OS_BSP_ConsoleOutput_Impl(Message, strlen(Message));\n    UT_BSP_Unlock();\n\n    if ((TestCounters->CaseCount[UTASSERT_CASETYPE_FAILURE] > 0) ||\n        (TestCounters->CaseCount[UTASSERT_CASETYPE_TSF] > 0) || (TestCounters->CaseCount[UTASSERT_CASETYPE_TTF] > 0))\n    {\n        OS_BSP_SetExitCode(OS_ERROR);\n    }\n    else\n    {\n        OS_BSP_SetExitCode(OS_SUCCESS);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 strlen(OutputMessage) can read beyond the bounds if OutputMessage does not point to a NUL-terminated C string. For example: char buf[10]; memcpy(buf, src, 10); /* no terminating '\\0' */ UT_BSP_DoText(UTASSERT_CASETYPE_INFO, buf); strlen(buf) will scan past buf and may access out-of-bounds memory. The same happens if OutputMessage is NULL \u2014 strlen(NULL) is undefined. Unless every caller is guaranteed to pass a valid NUL-terminated string, this use can violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n---- UT_BSP_EndTest probe (after_snprintf) ----\nTestSegmentCount = 8\nBuffer address = 0x7ffd34475fb0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 8 tests Segment(s) executed\n\n'\n---- end probe (after_snprintf) ----\n\n---- UT_BSP_EndTest probe (before_console_output) ----\nTestSegmentCount = 8\nBuffer address = 0x7ffd34475fb0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 8 tests Segment(s) executed\n\n'\n---- end probe (before_console_output) ----\n\n---- UT_BSP_EndTest probe (end_of_function) ----\nTestSegmentCount = 8\nBuffer address = 0x7ffd34475fb0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 8 tests Segment(s) executed\n\n'\n---- end probe (end_of_function) ----\n\n---- UT_BSP_EndTest probe (after_snprintf) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffedb866210, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (after_snprintf) ----\n\n---- UT_BSP_EndTest probe (before_console_output) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffedb866210, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (before_console_output) ----\n\n---- UT_BSP_EndTest probe (end_of_function) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffedb866210, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (end_of_function) ----\n\n---- UT_BSP_EndTest probe (after_snprintf) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffdfb5a7be0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (after_snprintf) ----\n\n---- UT_BSP_EndTest probe (before_console_output) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffdfb5a7be0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (before_console_output) ----\n\n---- UT_BSP_EndTest probe (end_of_function) ----\nTestSegmentCount = 3\nBuffer address = 0x7ffdfb5a7be0, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 3 tests Segment(s) executed\n\n'\n---- end probe (end_of_function) ----\n\n---- UT_BSP_EndTest probe (after_snprintf) ----\nTestSegmentCount = 7\nBuffer address = 0x7ffc93414e60, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 7 tests Segment(s) executed\n\n'\n---- end probe (after_snprintf) ----\n\n---- UT_BSP_EndTest probe (before_console_output) ----\nTestSegmentCount = 7\nBuffer address = 0x7ffc93414e60, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 7 tests Segment(s) executed\n\n'\n---- end probe (before_console_output) ----\n\n---- UT_BSP_EndTest probe (end_of_function) ----\nTestSegmentCount = 7\nBuffer address = 0x7ffc93414e60, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 7 tests Segment(s) executed\n\n'\n---- end probe (end_of_function) ----\n\n---- UT_BSP_EndTest probe (after_snprintf) ----\nTestSegmentCount = 1\nBuffer address = 0x7ffc0cb9b900, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 1 tests Segment(s) executed\n\n'\n---- end probe (after_snprintf) ----\n\n---- UT_BSP_EndTest probe (before_console_output) ----\nTestSegmentCount = 1\nBuffer address = 0x7ffc0cb9b900, buffer_size = 128\nNUL found at offset 39 (within buffer). strlen() = 39\nBuffer contents (as string): 'COMPLETE: 1 tests Segment(s) executed\n\n'\n---- end probe (before_console_output) ----\n\n---- UT_BSP_EndTest probe (end_of_function) ----\nTestSeg\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_BSP_EndTest:\ntypedef struct\n{\n    uint32 TestSegmentCount;\n    uint32 TotalTestCases;\n    uint32 CaseCount[UTASSERT_CASETYPE_MAX];\n} UtAssert_TestCounter_t\n...\nvoid OS_BSP_ConsoleOutput_Impl(const char *Str, size_t DataLen)\n{\n    ssize_t WriteLen;\n\n    while (DataLen > 0)\n    {\n        /* writes the raw data directly to STDOUT_FILENO (unbuffered) */\n        WriteLen = write(STDOUT_FILENO, Str, DataLen);\n        if (WriteLen <= 0)\n        {\n            /* no recourse if this fails, just stop. */\n            break;\n        }\n        Str += WriteLen;\n        DataLen -= WriteLen;\n    }\n}\n...\nvoid UtAssert_DoTestSegmentReport(const char *SegmentName, const UtAssert_TestCounter_t *TestCounters)\n{\n    char ReportBuffer[144];\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer),\n             \"%-22s ABORT::%-4u  WARN::%-4u  FLOW::%-4u  DEBUG::%-4u  N/A::%-4u\",\n             \"\",\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_ABORT],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_WARN],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_FLOW],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_DEBUG],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_NA]);\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_INFO, ReportBuffer);\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer),\n             \"%02u %-20s TOTAL::%-4u  PASS::%-4u  FAIL::%-4u  MIR::%-4u  TSF::%-4u  TTF::%-4u\",\n             (unsigned int)TestCounters->TestSegmentCount, SegmentName, (unsigned int)TestCounters->TotalTestCases,\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_PASS],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_FAILURE],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_MIR],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_TSF],\n             (unsigned int)TestCounters->CaseCount[UTASSERT_CASETYPE_TTF]);\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_END, ReportBuffer);\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for UT_BSP_EndTest. In UT_BSP_EndTest the code calls strlen(Message) immediately after filling Message via snprintf(Message, sizeof(Message), ...). snprintf with a non-zero size guarantees NUL-termination of the destination buffer, so strlen(Message) will only scan up to that NUL and cannot read past Message's bounds. The provided execution logs also show a NUL within the buffer (offset 39), confirming the actual runs. Therefore UT_BSP_EndTest does not violate MISRA C 2023 Rule 21.17.\n\nNote: UT_BSP_DoText does call strlen(OutputMessage) on a caller-supplied pointer; if callers can pass a non-NUL-terminated buffer or NULL, that would be a potential Rule 21.17 violation. In the supplied code paths UT_BSP_DoText is invoked with snprintf-formed buffers or string literals (which are NUL-terminated), so those calls are safe. If UT_BSP_DoText is part of a public API, it would be prudent to either require/document that callers provide NUL-terminated strings (and non-NULL pointers) or change the API to take an explicit length to eliminate potential violations."
}