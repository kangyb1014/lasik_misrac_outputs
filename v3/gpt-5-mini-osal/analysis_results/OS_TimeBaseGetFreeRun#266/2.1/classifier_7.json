{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_TimeBaseGetFreeRun:\n```c\nint32 OS_TimeBaseGetFreeRun(osal_id_t timebase_id, uint32 *freerun_val)\n{\n    int32                          return_code;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(freerun_val);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        *freerun_val = timebase->freerun_time;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TimeBaseGetFreeRun:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\n#define OS_SUCCESS (0)\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nOS_timebase_internal_record_t OS_timebase_table[OS_MAX_TIMEBASES]\n...\ntypedef struct\n{\n    char           timebase_name[OS_MAX_API_NAME];\n    OS_TimerSync_t external_sync;\n    uint32         accuracy_usec;\n    osal_id_t      first_cb;\n    uint32         freerun_time;\n    uint32         nominal_start_time;\n    uint32         nominal_interval_time;\n} OS_timebase_internal_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The macro expands to BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER), i.e. a runtime check conditioned on the pointer value; it does not make the following code unreachable in general. A true MISRA 2.1 violation would require code that can never be executed under any possible program flow (for example if BUGCHECK were expanded unconditionally to a non-returning infinite loop/abort or if the checked expression were provably constant such that subsequent statements are never reachable). None of those conditions are evidenced by the provided fragment, so Rule 2.1 is not violated."
}