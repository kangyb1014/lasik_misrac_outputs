{
  "user_message": "An agent A claimed that the following UT_Stub_CopyToLocal code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyToLocal.\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn UT_SetDataBuffer the parameter DataBuffer is declared as void * but is only read and used as the source argument to memcpy: memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize); DataBuffer should be declared const void * since it is not modified. This violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CopyToLocal ENTRY: FuncKey=94852422309215, LocalBuffer=0x7ffc9ef673c0, MaxSize=20\nNo stub entry found for FuncKey=94852422309215 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94852422309215, LocalBuffer=0x7ffc9ef673c0, MaxSize=20\nNo stub entry found for FuncKey=94852422309215 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934087208, LocalBuffer=0x7fff223a40e0, MaxSize=24\nNo stub entry found for FuncKey=94547934087208 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934087208, LocalBuffer=0x7fff223a40e0, MaxSize=24\nNo stub entry found for FuncKey=94547934087208 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934086819, LocalBuffer=0x7fff223a4080, MaxSize=48\nNo stub entry found for FuncKey=94547934086819 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934086819, LocalBuffer=0x7fff223a4080, MaxSize=48\nNo stub entry found for FuncKey=94547934086819 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934086819, LocalBuffer=0x7fff223a4080, MaxSize=48\nNo stub entry found for FuncKey=94547934086819 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94547934086819, LocalBuffer=0x7fff223a4080, MaxSize=48\nFound StubPtr=0x55fda8086880: TotalSize=48, Position=0\nComputed remaining bytes (before limit) = 48\nAbout to memcpy: dest=0x7fff223a4080, src=0x7fff223a4120, n=48\nAfter memcpy: Position updated to 48 (TotalSize=48)\nBuffer fully consumed, calling UT_ClearStubEntry on 0x55fda8086880\nUT_Stub_CopyToLocal EXIT: ActualCopy=48\nUT_Stub_CopyToLocal ENTRY: FuncKey=94452121864499, LocalBuffer=0x7ffd8ade1970, MaxSize=48\nNo stub entry found for FuncKey=94452121864499 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94677252767348, LocalBuffer=0x7fffcf60de40, MaxSize=20\nNo stub entry found for FuncKey=94677252767348 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94677252767348, LocalBuffer=0x7fffcf60de40, MaxSize=20\nNo stub entry found for FuncKey=94677252767348 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94187238003052, LocalBuffer=0x7ffe60669260, MaxSize=24\nNo stub entry found for FuncKey=94187238003052 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94187238003052, LocalBuffer=0x7ffe60669230, MaxSize=24\nNo stub entry found for FuncKey=94187238003052 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94645435093137, LocalBuffer=0x7ffd5575b910, MaxSize=8\nFound StubPtr=0x56145b8bdec0: TotalSize=8, Position=0\nComputed remaining bytes (before limit) = 8\nAbout to memcpy: dest=0x7ffd5575b910, src=0x7ffd5575b970, n=8\nAfter memcpy: Position updated to 8 (TotalSize=8)\nBuffer fully consumed, calling UT_ClearStubEntry on 0x56145b8bdec0\nUT_Stub_CopyToLocal EXIT: ActualCopy=8\nUT_Stub_CopyToLocal ENTRY: FuncKey=94645435093137, LocalBuffer=0x7ffd5575b910, MaxSize=8\nFound StubPtr=0x56145b8bdec0: TotalSize=8, Position=0\nComputed remaining bytes (before limit) = 8\nAbout to memcpy: dest=0x7ffd5575b910, src=0x7ffd5575b970, n=8\nAfter memcpy: Position updated to 8 (TotalSize=8)\nBuffer fully consumed, calling UT_ClearStubEntry on 0x56145b8bdec0\nUT_Stub_CopyToLocal EXIT: ActualCopy=8\nUT_Stub_CopyToLocal ENTRY: FuncKey=94566914058710, LocalBuffer=0x7ffe6df915e0, MaxSize=20\nNo stub entry found for FuncKey=94566914058710 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94566914058710, LocalBuffer=0x7ffe6df91610, MaxSize=20\nNo stub entry found for FuncKey=94566914058710 (StubPtr is NULL)\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94566914058710, LocalBuffer=0x7ffe6df91610, MaxSize=20\nNo stub entry found for FuncKey=94566914058710 (StubPtr is NULL)\nUT_\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyToLocal:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. While the AllocateCopy path in UT_SetDataBuffer uses DataBuffer only as the source to memcpy, the function also supports a non-allocate path where it stores DataBuffer directly into StubPtr->Data.Buff.BasePtr. That buffer is later used as a destination in UT_Stub_CopyFromLocal (memcpy(&StubPtr->Data.Buff.BasePtr[...], LocalBuffer, ...)), i.e. the buffer can be modified. Because the stored pointer may refer to a mutable buffer, the parameter cannot be const void * without changing the API/semantics. Therefore Rule 8.13 is not violated in this code as written\u2014the non-const qualifier is required by usage."
}