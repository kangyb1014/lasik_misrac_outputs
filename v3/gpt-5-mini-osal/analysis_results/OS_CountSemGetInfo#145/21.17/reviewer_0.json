{
  "user_message": "An agent A claimed that the following OS_CountSemGetInfo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_CountSemGetInfo.\n```c\nint32 OS_CountSemGetInfo(osal_id_t sem_id, OS_count_sem_prop_t *count_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(count_prop);\n\n    memset(count_prop, 0, sizeof(OS_count_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_count_sem_table, token);\n\n        strncpy(count_prop->name, record->name_entry, sizeof(count_prop->name) - 1);\n        count_prop->creator = record->creator;\n\n        return_code = OS_CountSemGetInfo_Impl(&token, count_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strncpy(count_prop->name, record->name_entry, sizeof(count_prop->name) - 1) can read up to (sizeof(count_prop->name)-1) bytes from record->name_entry. If record->name_entry does not have at least that many addressable bytes (for example, record->name_entry is char name_entry[8] but OS_MAX_API_NAME is 16, or record->name_entry is a pointer to a shorter/unterminated buffer), strncpy may read beyond the bounds of record->name_entry and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[OS_CountSemGetInfo] entry (after pointer check): sem_id=3735928559 count_prop=0x7ffcad2f7e20 return_code=0\n  token_ptr=(nil) record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] after memset: sem_id=3735928559 count_prop=0x7ffcad2f7e20 return_code=0\n  token_ptr=(nil) record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] after ObjectIdGetById: sem_id=3735928559 count_prop=0x7ffcad2f7e20 return_code=-35\n  token_ptr=0x7ffcad2f7dd0 record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] exit: sem_id=3735928559 count_prop=0x7ffcad2f7e20 return_code=-35\n  token_ptr=0x7ffcad2f7dd0 record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] entry (after pointer check): sem_id=0 count_prop=0x7ffcad2f7e20 return_code=0\n  token_ptr=(nil) record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] after memset: sem_id=0 count_prop=0x7ffcad2f7e20 return_code=0\n  token_ptr=(nil) record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] after ObjectIdGetById: sem_id=0 count_prop=0x7ffcad2f7e20 return_code=-35\n  token_ptr=0x7ffcad2f7dd0 record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n[OS_CountSemGetInfo] exit: sem_id=0 count_prop=0x7ffcad2f7e20 return_code=-35\n  token_ptr=0x7ffcad2f7dd0 record_ptr=(nil) name_entry_ptr=(nil) sizeof(count_prop->name)=20 copy_len=19\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CountSemGetInfo:\ntypedef struct\n{\n    char      name[OS_MAX_API_NAME];\n    osal_id_t creator;\n    int32     value;\n} OS_count_sem_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_common_record_t *const OS_global_count_sem_table\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_CountSemGetInfo_Impl(const OS_object_token_t *token, OS_count_sem_prop_t *count_prop)\n{\n    int                                 sval;\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n\n    if (sem_getvalue(&impl->id, &sval) < 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    /* put the info into the structure */\n    count_prop->value = sval;\n    return OS_SUCCESS;\n}\n...\n#define OS_SUCCESS (0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation depends entirely on the (missing) definition of record->name_entry. MISRA\u201121.17 is only violated if the strncpy call can read past the end of the source object. In the OSAL codebase this is normally not the case: OS_count_sem_prop_t::name is declared as char[OS_MAX_API_NAME], and the common record structures in the OS object table use a name_entry field sized to OS_MAX_API_NAME as well. Given that convention, strncpy(count_prop->name, record->name_entry, sizeof(count_prop->name) - 1) will never read beyond the bounds of record->name_entry and therefore does not violate 21.17.\n\nIf, however, OS_common_record_t actually declared name_entry as a pointer to a smaller/externally allocated buffer (or some other type with a smaller object lifetime/size), then the agent\u2019s scenario would be valid and the use of strncpy could read out of bounds. The source code shown does not demonstrate that case, so the claim as stated is not supported by the provided code.\n\nConclusion: with the usual/expected definitions in this codebase (name_entry sized OS_MAX_API_NAME), the report is not correct. If the reviewer cannot verify the definition of OS_common_record_t::name_entry, then a precautionary review should confirm that name_entry has at least sizeof(count_prop->name)-1 bytes to guarantee MISRA compliance."
}