{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_BinSemTimedWait_Impl:\n```c\nint32 OS_BinSemTimedWait_Impl(const OS_object_token_t *token, uint32 msecs)\n{\n    struct timespec ts;\n\n    /*\n     ** Compute an absolute time for the delay\n     */\n    OS_Posix_CompAbsDelayTime(msecs, &ts);\n\n    return (OS_GenericBinSemTake_Impl(token, &ts));\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_BinSemTimedWait_Impl:\nvoid OS_Posix_CompAbsDelayTime(uint32 msecs, struct timespec *tm)\n{\n    clock_gettime(CLOCK_REALTIME, tm);\n\n    /* add the delay to the current time */\n    tm->tv_sec += (time_t)(msecs / 1000);\n    /* convert residue ( msecs )  to nanoseconds */\n    tm->tv_nsec += (msecs % 1000) * 1000000L;\n\n    if (tm->tv_nsec >= 1000000000L)\n    {\n        tm->tv_nsec -= 1000000000L;\n        tm->tv_sec++;\n    }\n}\n...\nstatic int32 OS_GenericBinSemTake_Impl(const OS_object_token_t *token, const struct timespec *timeout)\n{\n    sig_atomic_t                      flush_count;\n    int32                             return_code;\n    OS_impl_binsem_internal_record_t *sem;\n\n    sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n\n    /*\n     * Note - this lock should be quickly available - should not delay here.\n     * The main delay is in the pthread_cond_wait() below.\n     */\n    /* Lock the mutex ( not the table! ) */\n    if (OS_Posix_BinSemAcquireMutex(&sem->id) != OS_SUCCESS)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    /* because pthread_cond_wait() is also a cancellation point,\n     * this uses a cleanup handler to ensure that if canceled during this call,\n     * the mutex is also released */\n    pthread_cleanup_push(OS_Posix_BinSemReleaseMutex, &sem->id);\n\n    return_code = OS_SUCCESS;\n\n    /*\n     * Note that for vxWorks compatibility, we need to stop pending on the semaphore\n     * and return from this function under two possible circumstances:\n     *\n     *  a) the semaphore count was nonzero (may be pre-existing or due to a give)\n     *     this is the normal case, we should decrement the count by 1 and return.\n     *  b) the semaphore got \"flushed\"\n     *     in this case ALL tasks are un-blocked and we do NOT decrement the count.\n     */\n\n    /*\n     * first take a local snapshot of the flush request counter,\n     * if it changes, we know that someone else called SemFlush.\n     */\n    flush_count = sem->flush_request;\n\n    /* Note - the condition must be checked in a while loop because\n     * even if pthread_cond_wait() returns, it does NOT guarantee that\n     * the condition we are looking for has been met.\n     *\n     * Also if the current_value is already nonzero we will not wait.\n     */\n    while (sem->current_value == 0 && sem->flush_request == flush_count)\n    {\n        /* Must pend until something changes */\n        if (timeout == NULL)\n        {\n            /* wait forever */\n            pthread_cond_wait(&(sem->cv), &(sem->id));\n        }\n        else if (pthread_cond_timedwait(&(sem->cv), &(sem->id), timeout) == ETIMEDOUT)\n        {\n            return_code = OS_SEM_TIMEOUT;\n            break;\n        }\n    }\n\n    /* If the flush counter did not change, set the value to zero */\n    if (return_code == OS_SUCCESS && sem->flush_request == flush_count)\n    {\n        sem->current_value = 0;\n    }\n\n    /*\n     * Pop the cleanup handler.\n     * Passing \"true\" means it will be executed, which\n     * handles releasing the mutex.\n     */\n    pthread_cleanup_pop(true);\n\n    return return_code;\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nint32 OS_Posix_BinSemAcquireMutex(pthread_mutex_t *mut)\n{\n    struct timespec timeout;\n\n    if (clock_gettime(CLOCK_REALTIME, &timeout) != 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    timeout.tv_sec += OS_POSIX_BINSEM_MAX_WAIT_SECONDS;\n\n    if (pthread_mutex_timedlock(mut, &timeout) != 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    return OS_SUCCESS;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no code fragments that are clearly unreachable in the supplied code. Reasoning by function:\n\n- OS_BinSemTimedWait_Impl: Straight-line code \u2014 it computes an absolute time then immediately returns the result of OS_GenericBinSemTake_Impl. No code follows the return, and there are no conditional branches that would make any statements unreachable.\n\n- OS_Posix_CompAbsDelayTime: All statements in the function can be reached for appropriate inputs (clock_gettime populates tm, the additions to tv_sec and tv_nsec are always executed, and the final if adjusts overflowed nanoseconds). There are no early returns or mutually exclusive branches that would leave any statement unreachable.\n\n- OS_GenericBinSemTake_Impl: Control flow is explicit and all code is reachable:\n  - The early return on mutex-acquire failure is before the pthread_cleanup_push, so it does not create unreachable code inside the push/pop region.\n  - The pthread_cleanup_push and pthread_cleanup_pop(true) are balanced in the same lexical scope; no return occurs between them, so the code between push and pop is reachable and will always reach the pop on normal execution.\n  - The while loop has reachable alternative paths: (a) if current_value != 0 the loop is skipped; (b) if timeout==NULL pthread_cond_wait() is called; (c) if timeout provided and timedwait returns ETIMEDOUT the code sets return_code and breaks. There is no code after a return that would be unreachable. The conditional after the loop that clears sem->current_value is conditioned on return_code and flush_request and is reachable in appropriate cases.\n\n- OS_Posix_BinSemAcquireMutex and OS_ObjectIndexFromToken: Both are simple functions with straight-line execution and no unreachable statements.\n\nAdditional notes checked for potential macro pitfalls: pthread_cleanup_push/pop are used in proper paired fashion in the same function and no returns occur between them, so the macros do not introduce unreachable code in this snippet. The code uses macros (e.g., OS_OBJECT_TABLE_GET) whose definitions are not shown, but their typical usage here does not imply unreachable code; if those macros include internal returns or conditionals, that would need separate review, but nothing in the provided code makes any branch unreachable.\n\nTherefore, based on the provided source, there are no obvious instances of unreachable code to investigate for MISRA C Rule 2.1."
}