{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe iterator argument is passed and used read\u2011only but is not const\u2011qualified. Specifically, OS_ForEachObjectOfType passes &filter (type OS_creator_filter_t *) to OS_ObjectIdIteratorInit which stores it in OS_object_iter_t.arg (void *). The match function OS_ForEachFilterCreator and the processing function OS_ForEachDoCallback both take a void *ref and only read from it. Similarly, the user callback type OS_ArgCallback_t uses void *arg. All of these pointers could be declared as pointers to const (const void * or const OS_creator_filter_t *) since they are not modified, so the code violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[OS_ForEachObjectOfType] Init: idtype=9, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=8, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=1, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=0, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=1, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=2, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=3, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=4, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=5, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=6, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=7, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=8, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=9, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=10, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=11, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=12, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=13, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=14, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=15, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=9, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=8, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=1, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18fa10\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOfType] Init: idtype=0, creator_id=0, user_callback=0x55744b512988, user_arg=0x7ffeff18fa80, filter_addr=0x7ffeff18f9d0\n[OS_ForEachObjectOfType] Init result: 0\n[OS_ForEachObjectOf\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachObjectOfType:\ntypedef void (*OS_ArgCallback_t)(osal_id_t object_id, void *arg)\n...\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n...\nint32 OS_ForEachDoCallback(osal_id_t obj_id, void *ref)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Just invoke the user callback */\n    filter->user_callback(obj_id, filter->user_arg);\n    return OS_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s observation is correct in spirit: the data passed through iter->arg and into the two handler functions (OS_ForEachFilterCreator and OS_ForEachDoCallback) is only read and therefore the local pointers could and should be const\u2011qualified to conform to MISRA C:2023 Rule 8.13. Concretely, the functions currently do\n    OS_creator_filter_t *filter = ref;\nbut could (and should) use\n    const OS_creator_filter_t *filter = (const OS_creator_filter_t *)ref;\nso the pointer in the function points to a const-qualified type. The root of the reason this pattern appears is the generic iterator API uses void * (iter->arg and the callback typedefs) so the public API is non-const; changing those API-level typedefs/fields to const void * would be a broader compatibility change. If the public API cannot be changed, the recommended fix to satisfy Rule 8.13 is to const\u2011qualify the local pointer views of the argument (with an explicit cast from void * to const T *). Given the current code does not do that, the report that it violates Rule 8.13 is correct."
}