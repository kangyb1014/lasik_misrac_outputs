{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe field 'base' is declared as 'OS_common_record_t * base' but the iterator only reads records (e.g. OS_ObjectIdIteratorGetNext passes the record to match as a const OS_common_record_t *). Therefore 'base' can and should be declared as 'const OS_common_record_t * base' to prevent accidental modification. The current non-const declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[ENTRY] OS_ForEachObjectOfType idtype=9 creator_id=0 callback_ptr=0x5577bf1679a8 callback_arg=0x7ffd17af4560\n[INIT] Iterator initialized idtype=9 iter_ptr=0x7ffd17af4520 base_ptr=0x5577db64cff0 count=4\n[ITER] Stage=after_init base_ptr=0x5577db64cff0 index=0 count=4 current=(nil)\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[ENTRY] Iterator initialized successfully\n[NEXT] Advancing iterator: new index=1 current_ptr=0x5577db64cff0\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=1 count=4 current=0x5577db64cff0\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64cff0\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64cff0\n[NEXT] Advancing iterator: new index=2 current_ptr=0x5577db64d008\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=2 count=4 current=0x5577db64d008\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64d008\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64d008\n[NEXT] Advancing iterator: new index=3 current_ptr=0x5577db64d020\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=3 count=4 current=0x5577db64d020\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64d020\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64d020\n[NEXT] Advancing iterator: new index=4 current_ptr=0x5577db64d038\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=4 count=4 current=0x5577db64d038\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64d038\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64d038\n[NEXT] Iterator exhausted (index=4 count=4)\n[EXIT] Finished iterating, destroying iterator\n[DESTROY] Destroying iterator iter_ptr=0x7ffd17af4520 base_ptr=0x5577db64cff0 count=4\n[EXIT] OS_ForEachObjectOfType complete\n[ENTRY] OS_ForEachObjectOfType idtype=8 creator_id=0 callback_ptr=0x5577bf1679a8 callback_arg=0x7ffd17af4560\n[INIT] Iterator initialized idtype=8 iter_ptr=0x7ffd17af4520 base_ptr=0x5577db64cff0 count=4\n[ITER] Stage=after_init base_ptr=0x5577db64cff0 index=0 count=4 current=(nil)\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[ENTRY] Iterator initialized successfully\n[NEXT] Advancing iterator: new index=1 current_ptr=0x5577db64cff0\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=1 count=4 current=0x5577db64cff0\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64cff0\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64cff0\n[NEXT] Advancing iterator: new index=2 current_ptr=0x5577db64d008\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=2 count=4 current=0x5577db64d008\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64d008\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64d008\n[NEXT] Advancing iterator: new index=3 current_ptr=0x5577db64d020\n[ITER] Stage=after_getnext base_ptr=0x5577db64cff0 index=3 count=4 current=0x5577db64d020\n[ITER] base[0] ptr=0x5577db64cff0\n[ITER] base[1] ptr=0x5577db64d008\n[ITER] base[2] ptr=0x5577db64d020\n[LOOP] Got next entry, invoking ProcessEntry\n[PROCESS] Processing entry current_ptr=0x5577db64d020\n[CALLBACK] OS_ForEachDoCallback invoked: current_ptr=0x5577db64d020\n[NEXT] Advancing iterator: new index=4 current_ptr=0x5577\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachObjectOfType:\ntypedef void (*OS_ArgCallback_t)(osal_id_t object_id, void *arg)\n...\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n...\nint32 OS_ForEachDoCallback(osal_id_t obj_id, void *ref)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Just invoke the user callback */\n    filter->user_callback(obj_id, filter->user_arg);\n    return OS_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown code the iterator\u2019s base pointer is declared as OS_common_record_t *base but it is only used for reading: OS_ObjectIdIteratorGetNext reads records (and passes them to match functions that take const OS_common_record_t *), the match callback used (OS_ForEachFilterCreator) takes a const OS_common_record_t * and there are no writes through iter->base in the provided functions. Therefore base can be const-qualified (const OS_common_record_t *), which would improve type safety and satisfy MISRA C 2023 Rule 8.13. Note: converting base to const is compatible with assigning &OS_common_table[...] (a non-const object address can be assigned to a pointer-to-const). If other code (not shown) actually writes through iter->base then const would be inappropriate, but based on the provided code and logs there is no evidence of such writes, so the reported violation stands."
}