{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer iter->arg (declared as void *) is passed to func(...) in the fragment. iter->arg is assigned from the match argument (&filter) and is only read by the match callback (OS_ForEachFilterCreator) and the do-callback (OS_ForEachDoCallback). Therefore iter->arg and the callback parameter could be declared as pointing to a const-qualified type (e.g. const void * and int32 (*func)(osal_id_t, const void *)). Because the current declarations use non-const pointers, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachObjectOfType:\ntypedef void (*OS_ArgCallback_t)(osal_id_t object_id, void *arg)\n...\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n...\nint32 OS_ForEachDoCallback(osal_id_t obj_id, void *ref)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Just invoke the user callback */\n    filter->user_callback(obj_id, filter->user_arg);\n    return OS_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA 8.13 recommends using const when the pointed-to object is not modified, but that applies to the declarations/types, not to a single call-site. The iterator and callback types here are generic/public (iter->arg is a field of OS_object_iter_t, OS_ObjectIdIteratorInit takes a void *matcharg and stores it into iter->arg, and the callbacks use the typedef OS_ArgCallback_t which is void *(non-const)). Those types must allow callers that legitimately want to mutate the referenced data (for example user callbacks that modify their context). Although in this particular use the filter object is only read, you cannot safely change the shared declarations to const without changing the API and potentially breaking other callers. Therefore the report that this code violates MISRA C:2023 Rule 8.13 is not correct."
}