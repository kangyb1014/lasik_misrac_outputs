{
  "user_message": "An agent A claimed that the following UtTest_AddCommon code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_AddCommon.\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe 'if (status < 0)' branch is unreachable. POSIX pthread_mutex_unlock returns 0 on success or a positive error number on failure (never negative), so the condition status < 0 can never be true and the BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status)); path is unreachable.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[UtTest_AddCommon] Enter: TestName='OS_VxWorks_BinSemAPI_Impl_Init', EntryType=2, Test=0x559222f3c8d9, Setup=0x559222f3d54d, Teardown=0x559222f3d5d3\n[UtTest_AddCommon] Probe before UT_BSP_Lock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe while BSP lock is held\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe after UT_BSP_Unlock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Exit\n[UtTest_AddCommon] Enter: TestName='OS_BinSemCreate_Impl', EntryType=2, Test=0x559222f3c9a1, Setup=0x559222f3d54d, Teardown=0x559222f3d5d3\n[UtTest_AddCommon] Probe before UT_BSP_Lock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe while BSP lock is held\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe after UT_BSP_Unlock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Exit\n[UtTest_AddCommon] Enter: TestName='OS_BinSemDelete_Impl', EntryType=2, Test=0x559222f3cb91, Setup=0x559222f3d54d, Teardown=0x559222f3d5d3\n[UtTest_AddCommon] Probe before UT_BSP_Lock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe while BSP lock is held\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe after UT_BSP_Unlock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Exit\n[UtTest_AddCommon] Enter: TestName='OS_BinSemGive_Impl', EntryType=2, Test=0x559222f3cca1, Setup=0x559222f3d54d, Teardown=0x559222f3d5d3\n[UtTest_AddCommon] Probe before UT_BSP_Lock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe while BSP lock is held\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe after UT_BSP_Unlock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Exit\n[UtTest_AddCommon] Enter: TestName='OS_BinSemFlush_Impl', EntryType=2, Test=0x559222f3ce7d, Setup=0x559222f3d54d, Teardown=0x559222f3d5d3\n[UtTest_AddCommon] Probe before UT_BSP_Lock\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior probe\n[UtTest_AddCommon] Probe while BSP lock is held\n[Probe] Starting pthread_mutex_unlock behavior probe\n[Probe] unlock after lock: status=0 (OK)\n[Probe] unlock without lock: status=0 (OK)\n[Probe] Finished pthread_mutex_unlock behavior prob\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtTest_AddCommon:\nvoid UT_BSP_Lock(void)\n{\n    OS_BSP_Lock_Impl();\n}\n...\nvoid OS_BSP_Lock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_lock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_lock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /*\n         * Temporarily Disable/Defer thread cancellation.\n         * Note that OS_BSP_ConsoleOutput_Impl() calls write() which is a cancellation point.\n         * So if this calling task is canceled, it risks leaving the BSP locked.\n         */\n        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &OS_BSP_GenericLinuxGlobal.AccessCancelState);\n    }\n}\n...\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n...\nvoid UT_BSP_Unlock(void)\n{\n    OS_BSP_Unlock_Impl();\n}\n...\nvoid OS_BSP_Unlock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_unlock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /* Restore previous cancellability state */\n        pthread_setcancelstate(OS_BSP_GenericLinuxGlobal.AccessCancelState, NULL);\n    }\n}\n...\ntypedef struct\n{\n    void (*Test)(void);\n    void (*Setup)(void);\n    void (*Teardown)(void);\n\n    /* Note - the name entry should be long enough to support a GroupName.TestName pattern,\n     * hence why it uses double the OS_MAX_API_NAME length */\n    char TestName[OS_MAX_API_NAME * 2];\n} UtTestDataBaseEntry_t\n...\nUtAssert_Global_t UtAssert_Global\n...\nvoid UtTest_Add(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(Test, Setup, Teardown, SequenceName, UTASSERT_GROUP_TEST);\n}\n...\nvoid UtTest_AddSetup(void (*Setup)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(NULL, Setup, NULL, SequenceName, UTASSERT_GROUP_SETUP);\n}\n...\nvoid UtTest_AddTeardown(void (*Teardown)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(NULL, NULL, Teardown, SequenceName, UTASSERT_GROUP_TEARDOWN);\n}\n...\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The submitted UtTest_AddCommon function contains no \"if (status < 0)\" test or any other obviously unreachable branch \u2014 it simply zeroes a local structure, copies pointers/name if non-NULL, locks, adds the entry, and unlocks. The branch agent A points to (if (status < 0)) appears in OS_BSP_Lock_Impl / OS_BSP_Unlock_Impl, not in UtTest_AddCommon. Regarding the reachability of that branch: POSIX pthread_mutex_lock/unlock return 0 on success and non\u2011zero (positive) error codes on failure, so status < 0 would normally be unreachable on a POSIX-conforming implementation; however that is a property of the underlying platform/library, not of UtTest_AddCommon itself. Thus agent A has misattributed the issue to UtTest_AddCommon and the claim that UtTest_AddCommon violates MISRA C 2023 Rule 2.1 is incorrect."
}