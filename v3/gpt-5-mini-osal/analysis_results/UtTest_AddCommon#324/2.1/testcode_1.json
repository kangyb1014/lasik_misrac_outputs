{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nThe 'if (status < 0)' branch is unreachable. POSIX pthread_mutex_unlock returns 0 on success or a positive error number on failure (never negative), so the condition status < 0 can never be true and the BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status)); path is unreachable.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtTest_AddCommon code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3241.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtTest_AddCommon as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtTest_AddCommon:\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n</target_code>\nPlease provide the modified UtTest_AddCommon code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <stdint.h>\n\n/* Probe helper: append a message to the log file. */\nstatic void Probe_LogMessage(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/3241.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Try to create the directory then retry once. */\n        (void)mkdir(\"/tmp/logs\", 0755);\n        f = fopen(\"/tmp/logs/3241.txt\", \"a\");\n    }\n    if (f != NULL)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\n\n/* Probe helper: log a formatted message with an error code and its strerror. */\nstatic void Probe_LogErr(const char *prefix, int status)\n{\n    char buf[256];\n    if (status == 0)\n    {\n        snprintf(buf, sizeof(buf), \"%s: status=0 (OK)\", prefix);\n    }\n    else\n    {\n        /* strerror expects non-negative error numbers; guard negative just in case. */\n        int errnum = (status < 0) ? -status : status;\n        snprintf(buf, sizeof(buf), \"%s: status=%d, strerror='%s'\", prefix, status, strerror(errnum));\n    }\n    Probe_LogMessage(buf);\n}\n\n/* Probe that demonstrates pthread_mutex_unlock return behaviors under controlled scenarios.\n   This does not alter the state used by the caller (uses local mutexes). */\nstatic void Probe_PthreadUnlockBehavior(void)\n{\n    pthread_mutex_t mtx;\n    pthread_mutexattr_t attr;\n    int status;\n\n    Probe_LogMessage(\"[Probe] Starting pthread_mutex_unlock behavior probe\");\n\n    /* Initialize a normal mutex and perform expected lock/unlock -> should return 0 on unlock. */\n    if (pthread_mutexattr_init(&attr) == 0)\n    {\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n        if (pthread_mutex_init(&mtx, &attr) == 0)\n        {\n            if (pthread_mutex_lock(&mtx) == 0)\n            {\n                status = pthread_mutex_unlock(&mtx);\n                Probe_LogErr(\"[Probe] unlock after lock\", status);\n            }\n            else\n            {\n                Probe_LogMessage(\"[Probe] pthread_mutex_lock failed\");\n            }\n            (void)pthread_mutex_destroy(&mtx);\n        }\n        else\n        {\n            Probe_LogMessage(\"[Probe] pthread_mutex_init failed\");\n        }\n        (void)pthread_mutexattr_destroy(&attr);\n    }\n    else\n    {\n        Probe_LogMessage(\"[Probe] pthread_mutexattr_init failed\");\n    }\n\n    /* Initialize another mutex but attempt to unlock it without locking first -> should return error (positive). */\n    if (pthread_mutex_init(&mtx, NULL) == 0)\n    {\n        status = pthread_mutex_unlock(&mtx);\n        Probe_LogErr(\"[Probe] unlock without lock\", status);\n        (void)pthread_mutex_destroy(&mtx);\n    }\n    else\n    {\n        Probe_LogMessage(\"[Probe] pthread_mutex_init (second) failed\");\n    }\n\n    Probe_LogMessage(\"[Probe] Finished pthread_mutex_unlock behavior probe\");\n}\n\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    /* Log entering the function and the test name to aid reproducing control flow. */\n    if (TestName != NULL)\n    {\n        char buf[512];\n        snprintf(buf, sizeof(buf), \"[UtTest_AddCommon] Enter: TestName='%s', EntryType=%u, Test=%p, Setup=%p, Teardown=%p\",\n                 TestName, (unsigned)EntryType, (void *)Test, (void *)Setup, (void *)Teardown);\n        Probe_LogMessage(buf);\n    }\n    else\n    {\n        Probe_LogMessage(\"[UtTest_AddCommon] Enter: TestName=NULL\");\n    }\n\n    /* Probe before acquiring BSP lock to capture baseline behavior. */\n    Probe_LogMessage(\"[UtTest_AddCommon] Probe before UT_BSP_Lock\");\n    Probe_PthreadUnlockBehavior();\n\n    UT_BSP_Lock();\n\n    /* Probe while holding BSP lock to capture behavior that might differ while locked. */\n    Probe_LogMessage(\"[UtTest_AddCommon] Probe while BSP lock is held\");\n    Probe_PthreadUnlockBehavior();\n\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n\n    UT_BSP_Unlock();\n\n    /* Probe after unlocking to show behavior after unlock and to provide evidence about return codes. */\n    Probe_LogMessage(\"[UtTest_AddCommon] Probe after UT_BSP_Unlock\");\n    Probe_PthreadUnlockBehavior();\n\n    Probe_LogMessage(\"[UtTest_AddCommon] Exit\");\n}\n"
}