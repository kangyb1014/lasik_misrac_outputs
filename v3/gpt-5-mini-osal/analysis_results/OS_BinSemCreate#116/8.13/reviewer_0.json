{
  "user_message": "An agent A claimed that the following OS_BinSemCreate code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemCreate.\n```c\nint32 OS_BinSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_bin_sem_internal_record_t *binsem;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        binsem = OS_OBJECT_TABLE_GET(OS_bin_sem_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, binsem, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_BinSemCreate_Impl(&token, sem_initial_value, options);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call casts away const: OS_ObjectIdFindNextMatch has a parameter of type void * (non-const), but the variable name is const char *name. The code does (void *)name which removes the const qualifier from the pointer. This discards const and therefore violates MISRA C 2023 Rule 8.13. A compliant fix is to change the callee to take a const void * (or otherwise preserve const) and remove the cast.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=params_validated sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=0x7ffc9b36e630\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=0x7ffc9b36e630\nstage=return sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=0x7ffc9b36e630\nstage=params_validated sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e630\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e630\nstage=return sem_id_ptr=0x7ffc9b36e68c sem_name=BinSem 1 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e630\nstage=params_validated sem_id_ptr=0x7ffc9b36e5f0 sem_name=BINSEM0 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=BINSEM0 sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=BINSEM0 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e5f0 sem_name=BINSEM0 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=return sem_id_ptr=0x7ffc9b36e5f0 sem_name=BINSEM0 sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=params_validated sem_id_ptr=0x7ffc9b36e5f0 sem_name=DUPLICATE sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=DUPLICATE sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=DUPLICATE sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e5f0 sem_name=DUPLICATE sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=return sem_id_ptr=0x7ffc9b36e5f0 sem_name=DUPLICATE sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=params_validated sem_id_ptr=0x7ffc9b36e5f0 sem_name=Good sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=Good sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e5f0 sem_name=Good sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e5f0 sem_name=Good sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=return sem_id_ptr=0x7ffc9b36e5f0 sem_name=Good sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e5b0\nstage=params_validated sem_id_ptr=0x7ffc9b36e694 sem_name=DeleteTest sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e694 sem_name=DeleteTest sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=after_allocate sem_id_ptr=0x7ffc9b36e694 sem_name=DeleteTest sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e660\nstage=allocate_failed sem_id_ptr=0x7ffc9b36e694 sem_name=DeleteTest sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e660\nstage=return sem_id_ptr=0x7ffc9b36e694 sem_name=DeleteTest sem_initial_value=1 options=0 return_code=-35 token_ptr=0x7ffc9b36e660\nstage=params_validated sem_id_ptr=0x7ffc9b36e694 sem_name=FlushTest sem_initial_value=1 options=0 return_code=-1 token_ptr=(nil)\nstage=before_allocate sem_id_ptr=0x7ffc9b36e\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BinSemCreate:\ntypedef uint32 osal_id_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    char obj_name[OS_MAX_API_NAME];\n} OS_bin_sem_internal_record_t\n...\n#define OS_OBJECT_INIT(tok, ref, namefield, nameval) {memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_bin_sem_internal_record_t OS_bin_sem_table[LOCAL_NUM_OBJECTS]\n...\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n...\nint32 OS_BinSemCreate_Impl(const OS_object_token_t *token, uint32 initial_value, uint32 options)\n{\n    int                               ret;\n    int                               attr_created;\n    int                               mutex_created;\n    int                               cond_created;\n    int32                             return_code;\n    pthread_mutexattr_t               mutex_attr;\n    OS_impl_binsem_internal_record_t *sem;\n\n    /*\n     * This preserves a bit of pre-existing functionality that was particular to binary sems:\n     * if the initial value is greater than 1 it just silently used 1 without error.\n     * (by contrast the counting semaphore will return an error)\n     */\n    if (initial_value > 1)\n    {\n        initial_value = 1;\n    }\n\n    attr_created  = 0;\n    mutex_created = 0;\n    cond_created  = 0;\n    sem           = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n    memset(sem, 0, sizeof(*sem));\n\n    do\n    {\n        /*\n         ** Initialize the pthread mutex attribute structure with default values\n         */\n        ret = pthread_mutexattr_init(&mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /* After this point, the attr object should be destroyed before return */\n        attr_created = 1;\n\n        /*\n         ** Use priority inheritance\n         */\n        ret = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /*\n         ** Initialize the mutex that is used with the condition variable\n         */\n        ret = pthread_mutex_init(&(sem->id), &mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutex_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        mutex_created = 1;\n\n        /*\n         ** Initialize the condition variable\n         */\n        ret = pthread_cond_init(&(sem->cv), NULL);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_cond_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        cond_created = 1;\n\n        /*\n         * Check sem call, avoids unreachable destroy logic\n         */\n        ret = pthread_cond_signal(&(sem->cv));\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: initial pthread_cond_signal failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /*\n         ** fill out the proper OSAL table fields\n         */\n\n        sem->current_value = initial_value;\n\n        return_code = OS_SUCCESS;\n    } while (0);\n\n    /* Clean up resources if the operation failed */\n    if (return_code != OS_SUCCESS)\n    {\n        if (mutex_created)\n        {\n            pthread_mutex_destroy(&(sem->id));\n        }\n        if (cond_created)\n        {\n            pthread_cond_destroy(&(sem->cv));\n        }\n    }\n\n    if (attr_created)\n    {\n        /* Done with the attribute object -\n         * this call is a no-op in linux - but for other implementations if\n         * the create call allocated something this should free it\n         */\n        pthread_mutexattr_destroy(&mutex_attr);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CHECK_APINAME(str) OS_CHECK_STRING(str,OS_MAX_API_NAME,OS_ERR_NAME_TOO_LONG)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In OS_ObjectIdAllocateNew the code does: return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token); where name is declared const char * but is cast to void * (dropping the const qualifier). MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types where possible; the cast discards a const qualifier and indicates the called API does not use a const-qualified parameter when it should. The proper fix is to change the callee/prototype (and any function-pointer types) to accept a const void * (or otherwise propagate const) so no cast is needed and the const is preserved. Alternatively, make the API semantics require a mutable pointer and avoid passing const data, but the correct, MISRA-compliant choice is to add the const to the parameter. Therefore the report of a Rule 8.13 violation is correct."
}