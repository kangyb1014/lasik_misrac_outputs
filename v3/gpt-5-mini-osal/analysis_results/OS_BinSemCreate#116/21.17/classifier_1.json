{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_BinSemCreate:\n```c\nint32 OS_BinSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_bin_sem_internal_record_t *binsem;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        binsem = OS_OBJECT_TABLE_GET(OS_bin_sem_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, binsem, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_BinSemCreate_Impl(&token, sem_initial_value, options);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_CHECK_APINAME(sem_name);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated as shown: the fragment OS_CHECK_APINAME(sem_name) itself does not call any <string.h> functions, so from this snippet alone Rule 21.17 is not violated. However a violation can occur if the macro expands to unsafe string handling. Example violating scenario: OS_CHECK_APINAME copies sem_name into a fixed-size buffer (e.g. obj_name[]) using strcpy or memcpy without checking sem_name length, or uses strlen on a non\u2013null-terminated sem_name \u2014 this can read or write past object bounds and would breach MISRA C 2023 Rule 21.17."
}