{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_Probe_Log(const char *fmt, ...)\n{\n    /* Append-only logging for probes. Non-fatal if logging fails. */\n    FILE *f = fopen(\"/tmp/logs/1739.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void OS_Probe_DumpSrc(const char *label, const char *src, size_t max_check)\n{\n    /* Inspect memory for a NUL within max_check bytes and log safe information only.\n       Do not read beyond the NUL (if present) or beyond max_check. */\n    const void *nulpos = memchr(src, 0, max_check);\n    if (nulpos != NULL)\n    {\n        size_t len = (const char *)nulpos - src;\n        OS_Probe_Log(\"PROBE %s: ptr=%p NUL_within=%zu bytes (max_checked=%zu)\", label, (const void *)src, len, max_check);\n\n        /* Hex-dump the bytes up to the NUL in a concise form. */\n        {\n            size_t i;\n            char buf[128];\n            size_t bufi = 0;\n            for (i = 0; i < len && bufi + 3 < sizeof(buf); ++i)\n            {\n                int n = snprintf(&buf[bufi], sizeof(buf) - bufi, \"%02X\", (unsigned char)src[i]);\n                if (n <= 0) break;\n                bufi += (size_t)n;\n                if (i + 1 < len && bufi + 1 < sizeof(buf))\n                {\n                    buf[bufi++] = ' ';\n                }\n            }\n            buf[bufi] = '\\0';\n            OS_Probe_Log(\"PROBE %s: data_hex(%zu)=%s\", label, len, buf);\n        }\n    }\n    else\n    {\n        OS_Probe_Log(\"PROBE %s: ptr=%p NUL_not_found within max_check=%zu bytes --> potential unterminated source\", label, (const void *)src, max_check);\n    }\n}\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /* Log entry and pointers */\n    OS_Probe_Log(\"ENTRY OS_FileSysAddFixedMap: filesys_id=%p phys_path=%p virt_path=%p\", (void *)filesys_id, (const void *)phys_path, (const void *)virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    /* Probe dev_name for NUL within the bound used by later code. */\n    OS_Probe_DumpSrc(\"dev_name\", dev_name, sizeof(((OS_filesys_internal_record_t *)0)->volume_name));\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        OS_Probe_Log(\"DEVNAME_CHECK: memchr(dev_name,0,sizeof(volume_name)) returned NULL -> returning OS_ERR_NAME_TOO_LONG\");\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    OS_Probe_Log(\"ObjectIdAllocateNew returned %ld (token=%lu)\", (long)return_code, (unsigned long)token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        /* Probe sources used for strncpy to capture their state before copy */\n        OS_Probe_Log(\"ABOUT_TO_STRNCPY: volume_name_size=%zu system_mountpt_size=%zu virtual_mountpt_size=%zu\",\n                     sizeof(filesys->volume_name), sizeof(filesys->system_mountpt), sizeof(filesys->virtual_mountpt));\n\n        OS_Probe_DumpSrc(\"dev_name_for_volume_name\", dev_name, sizeof(filesys->volume_name) - 1);\n        OS_Probe_DumpSrc(\"phys_path_for_system_mountpt\", phys_path, sizeof(filesys->system_mountpt) - 1);\n        OS_Probe_DumpSrc(\"virt_path_for_virtual_mountpt\", virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /* Original copies preserved exactly */\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /* Probe after copy: log first few bytes of destination safely (NUL search within dest size) */\n        OS_Probe_DumpSrc(\"filesys->volume_name_after\", filesys->volume_name, sizeof(filesys->volume_name));\n        OS_Probe_DumpSrc(\"filesys->system_mountpt_after\", filesys->system_mountpt, sizeof(filesys->system_mountpt));\n        OS_Probe_DumpSrc(\"filesys->virtual_mountpt_after\", filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n        OS_Probe_Log(\"OS_FileSysStartVolume_Impl returned %ld\", (long)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n            OS_Probe_Log(\"OS_FileSysMountVolume_Impl returned %ld\", (long)return_code);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n        OS_Probe_Log(\"OS_ObjectIdFinalizeNew returned %ld final_return=%ld\", (long)return_code, (long)return_code);\n    }\n\n    OS_Probe_Log(\"EXIT OS_FileSysAddFixedMap returning %ld\", (long)return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpkh5ohv9s/src/src/os/shared/src/osapi-filesys.c: In function 'OS_FileSysAddFixedMap':\n/tmp/tmpkh5ohv9s/src/src/os/shared/src/osapi-filesys.c:339:5: error: aggregate value used where an integer was expected\n  339 |     OS_Probe_Log(\"ObjectIdAllocateNew returned %ld (token=%lu)\", (long)return_code, (unsigned long)token);\n      |     ^~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:188: CMakeFiles/osal.dir/src/os/shared/src/osapi-filesys.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_FileSysAddFixedMap as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void OS_Probe_Log(const char *fmt, ...)\n{\n    /* Append-only logging for probes. Non-fatal if logging fails. */\n    FILE *f = fopen(\"/tmp/logs/1739.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void OS_Probe_DumpSrc(const char *label, const char *src, size_t max_check)\n{\n    /* Inspect memory for a NUL within max_check bytes and log safe information only.\n       Do not read beyond the NUL (if present) or beyond max_check. */\n    const void *nulpos = memchr(src, 0, max_check);\n    if (nulpos != NULL)\n    {\n        size_t len = (const char *)nulpos - src;\n        OS_Probe_Log(\"PROBE %s: ptr=%p NUL_within=%zu bytes (max_checked=%zu)\", label, (const void *)src, len, max_check);\n\n        /* Hex-dump the bytes up to the NUL in a concise form. */\n        {\n            size_t i;\n            char buf[128];\n            size_t bufi = 0;\n            for (i = 0; i < len && bufi + 3 < sizeof(buf); ++i)\n            {\n                int n = snprintf(&buf[bufi], sizeof(buf) - bufi, \"%02X\", (unsigned char)src[i]);\n                if (n <= 0) break;\n                bufi += (size_t)n;\n                if (i + 1 < len && bufi + 1 < sizeof(buf))\n                {\n                    buf[bufi++] = ' ';\n                }\n            }\n            buf[bufi] = '\\0';\n            OS_Probe_Log(\"PROBE %s: data_hex(%zu)=%s\", label, len, buf);\n        }\n    }\n    else\n    {\n        OS_Probe_Log(\"PROBE %s: ptr=%p NUL_not_found within max_check=%zu bytes --> potential unterminated source\", label, (const void *)src, max_check);\n    }\n}\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /* Log entry and pointers */\n    OS_Probe_Log(\"ENTRY OS_FileSysAddFixedMap: filesys_id=%p phys_path=%p virt_path=%p\", (void *)filesys_id, (const void *)phys_path, (const void *)virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    /* Probe dev_name for NUL within the bound used by later code. */\n    OS_Probe_DumpSrc(\"dev_name\", dev_name, sizeof(((OS_filesys_internal_record_t *)0)->volume_name));\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        OS_Probe_Log(\"DEVNAME_CHECK: memchr(dev_name,0,sizeof(volume_name)) returned NULL -> returning OS_ERR_NAME_TOO_LONG\");\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    /* token may be an aggregate type; printing its address is safe and avoids treating it as an integer */\n    OS_Probe_Log(\"ObjectIdAllocateNew returned %ld (token=%p)\", (long)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        /* Probe sources used for strncpy to capture their state before copy */\n        OS_Probe_Log(\"ABOUT_TO_STRNCPY: volume_name_size=%zu system_mountpt_size=%zu virtual_mountpt_size=%zu\",\n                     sizeof(filesys->volume_name), sizeof(filesys->system_mountpt), sizeof(filesys->virtual_mountpt));\n\n        OS_Probe_DumpSrc(\"dev_name_for_volume_name\", dev_name, sizeof(filesys->volume_name) - 1);\n        OS_Probe_DumpSrc(\"phys_path_for_system_mountpt\", phys_path, sizeof(filesys->system_mountpt) - 1);\n        OS_Probe_DumpSrc(\"virt_path_for_virtual_mountpt\", virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /* Original copies preserved exactly */\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /* Probe after copy: log first few bytes of destination safely (NUL search within dest size) */\n        OS_Probe_DumpSrc(\"filesys->volume_name_after\", filesys->volume_name, sizeof(filesys->volume_name));\n        OS_Probe_DumpSrc(\"filesys->system_mountpt_after\", filesys->system_mountpt, sizeof(filesys->system_mountpt));\n        OS_Probe_DumpSrc(\"filesys->virtual_mountpt_after\", filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n        OS_Probe_Log(\"OS_FileSysStartVolume_Impl returned %ld\", (long)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n            OS_Probe_Log(\"OS_FileSysMountVolume_Impl returned %ld\", (long)return_code);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n        OS_Probe_Log(\"OS_ObjectIdFinalizeNew returned %ld final_return=%ld\", (long)return_code, (long)return_code);\n    }\n\n    OS_Probe_Log(\"EXIT OS_FileSysAddFixedMap returning %ld\", (long)return_code);\n    return return_code;\n}\n",
  "explanation": "The compiler error came from treating 'token' (an aggregate OS_object_token_t) as an integer when using the %lu format specifier. I changed the log to print the address of token with %p and (void *)&token, which is safe regardless of whether token is an integer or an aggregate. No other logic was changed."
}