{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_FileSys_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1736.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /* Log entry and parameter state (avoid dereferencing NULL pointers) */\n    OS_FileSys_LogProbe(\"OS_FileSysAddFixedMap ENTRY: filesys_id=%p, phys_path=%p, virt_path=%p\",\n                        (void *)filesys_id, (void *)phys_path, (void *)virt_path);\n    if (phys_path != NULL)\n    {\n        OS_FileSys_LogProbe(\"  phys_path='%s'\", phys_path);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  phys_path=<NULL>\");\n    }\n    if (virt_path != NULL)\n    {\n        OS_FileSys_LogProbe(\"  virt_path='%s'\", virt_path);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  virt_path=<NULL>\");\n    }\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    OS_FileSys_LogProbe(\"  Computed dev_name='%s' (ptr=%p)\", dev_name, (void *)dev_name);\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        OS_FileSys_LogProbe(\"  Name too long: dev_name does not contain terminator within %zu bytes\", sizeof(filesys->volume_name));\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    OS_FileSys_LogProbe(\"  Calling OS_ObjectIdAllocateNew with name='%s'\", dev_name);\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    OS_FileSys_LogProbe(\"  OS_ObjectIdAllocateNew returned %ld, token=%u\", (long)return_code, (unsigned)token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n        OS_FileSys_LogProbe(\"  Allocated filesys record at %p\", (void *)filesys);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n        OS_FileSys_LogProbe(\"  OS_OBJECT_INIT done (device_name set to '%s')\", dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        filesys->volume_name[sizeof(filesys->volume_name) - 1] = '\\0';\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        filesys->system_mountpt[sizeof(filesys->system_mountpt) - 1] = '\\0';\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n        filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = '\\0';\n\n        OS_FileSys_LogProbe(\"  Stored volume_name='%s', system_mountpt='%s', virtual_mountpt='%s'\",\n                            filesys->volume_name, filesys->system_mountpt, filesys->virtual_mountpt);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n        OS_FileSys_LogProbe(\"  Marked as fixed disk: fstype=%d, flags=0x%08x\",\n                            (int)filesys->fstype, (unsigned)filesys->flags);\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        OS_FileSys_LogProbe(\"  Calling OS_FileSysStartVolume_Impl with token=%u\", (unsigned)token);\n        return_code = OS_FileSysStartVolume_Impl(&token);\n        OS_FileSys_LogProbe(\"  OS_FileSysStartVolume_Impl returned %ld\", (long)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            OS_FileSys_LogProbe(\"  Marked IS_READY; flags=0x%08x\", (unsigned)filesys->flags);\n            return_code = OS_FileSysMountVolume_Impl(&token);\n            OS_FileSys_LogProbe(\"  OS_FileSysMountVolume_Impl returned %ld\", (long)return_code);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n            OS_FileSys_LogProbe(\"  Marked IS_MOUNTED_SYSTEM and IS_MOUNTED_VIRTUAL; flags=0x%08x\",\n                                (unsigned)filesys->flags);\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        OS_FileSys_LogProbe(\"  Calling OS_ObjectIdFinalizeNew with return_code=%ld\", (long)return_code);\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n        OS_FileSys_LogProbe(\"  OS_ObjectIdFinalizeNew returned %ld, filesys_id=%p\", (long)return_code, (void *)filesys_id);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  Allocation failed, skipping initialization\");\n    }\n\n    OS_FileSys_LogProbe(\"OS_FileSysAddFixedMap EXIT: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpfxji4lo2/src/src/os/shared/src/osapi-filesys.c: In function 'OS_FileSysAddFixedMap':\n/tmp/tmpfxji4lo2/src/src/os/shared/src/osapi-filesys.c:325:5: error: aggregate value used where an integer was expected\n  325 |     OS_FileSys_LogProbe(\"  OS_ObjectIdAllocateNew returned %ld, token=%u\", (long)return_code, (unsigned)token);\n      |     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpfxji4lo2/src/src/os/shared/src/osapi-filesys.c:358:9: error: aggregate value used where an integer was expected\n  358 |         OS_FileSys_LogProbe(\"  Calling OS_FileSysStartVolume_Impl with token=%u\", (unsigned)token);\n      |         ^~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:188: CMakeFiles/osal.dir/src/os/shared/src/osapi-filesys.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_FileSysAddFixedMap as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void OS_FileSys_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1736.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /* Log entry and parameter state (avoid dereferencing NULL pointers) */\n    OS_FileSys_LogProbe(\"OS_FileSysAddFixedMap ENTRY: filesys_id=%p, phys_path=%p, virt_path=%p\",\n                        (void *)filesys_id, (void *)phys_path, (void *)virt_path);\n    if (phys_path != NULL)\n    {\n        OS_FileSys_LogProbe(\"  phys_path='%s'\", phys_path);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  phys_path=<NULL>\");\n    }\n    if (virt_path != NULL)\n    {\n        OS_FileSys_LogProbe(\"  virt_path='%s'\", virt_path);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  virt_path=<NULL>\");\n    }\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    OS_FileSys_LogProbe(\"  Computed dev_name='%s' (ptr=%p)\", dev_name, (void *)dev_name);\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        OS_FileSys_LogProbe(\"  Name too long: dev_name does not contain terminator within %zu bytes\", sizeof(filesys->volume_name));\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    OS_FileSys_LogProbe(\"  Calling OS_ObjectIdAllocateNew with name='%s'\", dev_name);\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    /* token may be an aggregate type; print its address rather than casting it to an integer */\n    OS_FileSys_LogProbe(\"  OS_ObjectIdAllocateNew returned %ld, token=%p\", (long)return_code, (const void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n        OS_FileSys_LogProbe(\"  Allocated filesys record at %p\", (void *)filesys);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n        OS_FileSys_LogProbe(\"  OS_OBJECT_INIT done (device_name set to '%s')\", dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        filesys->volume_name[sizeof(filesys->volume_name) - 1] = '\\0';\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        filesys->system_mountpt[sizeof(filesys->system_mountpt) - 1] = '\\0';\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n        filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = '\\0';\n\n        OS_FileSys_LogProbe(\"  Stored volume_name='%s', system_mountpt='%s', virtual_mountpt='%s'\",\n                            filesys->volume_name, filesys->system_mountpt, filesys->virtual_mountpt);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n        OS_FileSys_LogProbe(\"  Marked as fixed disk: fstype=%d, flags=0x%08x\",\n                            (int)filesys->fstype, (unsigned)filesys->flags);\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        OS_FileSys_LogProbe(\"  Calling OS_FileSysStartVolume_Impl with token=%p\", (const void *)&token);\n        return_code = OS_FileSysStartVolume_Impl(&token);\n        OS_FileSys_LogProbe(\"  OS_FileSysStartVolume_Impl returned %ld\", (long)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            OS_FileSys_LogProbe(\"  Marked IS_READY; flags=0x%08x\", (unsigned)filesys->flags);\n            return_code = OS_FileSysMountVolume_Impl(&token);\n            OS_FileSys_LogProbe(\"  OS_FileSysMountVolume_Impl returned %ld\", (long)return_code);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n            OS_FileSys_LogProbe(\"  Marked IS_MOUNTED_SYSTEM and IS_MOUNTED_VIRTUAL; flags=0x%08x\",\n                                (unsigned)filesys->flags);\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        OS_FileSys_LogProbe(\"  Calling OS_ObjectIdFinalizeNew with return_code=%ld\", (long)return_code);\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n        OS_FileSys_LogProbe(\"  OS_ObjectIdFinalizeNew returned %ld, filesys_id=%p\", (long)return_code, (void *)filesys_id);\n    }\n    else\n    {\n        OS_FileSys_LogProbe(\"  Allocation failed, skipping initialization\");\n    }\n\n    OS_FileSys_LogProbe(\"OS_FileSysAddFixedMap EXIT: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n",
  "explanation": "The build errors occurred because OS_object_token_t is an aggregate type, so casting it to an integer (unsigned) caused a compile error. I changed the LogProbe calls that attempted to print the token as an unsigned integer to instead print the address of the token using the %p specifier and (const void *)&token. This avoids casting an aggregate to an integer while preserving the intent to log the token value/location. No other logic was modified."
}