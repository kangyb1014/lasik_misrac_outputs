{
  "user_message": "An agent A claimed that the following OS_TranslatePath code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TranslatePath.\n```c\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nOS_strnlen uses memchr(s, 0, maxlen). Calling OS_TranslatePath with a VirtualPath that does not have at least OS_MAX_PATH_LEN bytes accessible (for example: char small[8] = \"abc\"; OS_TranslatePath(small, ...)) causes memchr(VirtualPath, 0, OS_MAX_PATH_LEN) to read past the bounds of the small buffer (it may attempt to read up to 64 bytes). This is an out-of-bounds access and therefore violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nSTAGE=entry\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=0\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nAbout to call OS_strnlen with VirtualPath=0x561b36d192b8, max=64\nSTAGE=after_strnlen\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nSTAGE=after_strrchr\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192bf\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nCALLING memchr: s=0x561b36d192c0, c=0, n=20\nSTAGE=after_mount_lookup\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=exit\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=entry\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=0\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nAbout to call OS_strnlen with VirtualPath=0x561b36d192b8, max=64\nSTAGE=after_strnlen\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nSTAGE=after_strrchr\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192bf\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nCALLING memchr: s=0x561b36d192c0, c=0, n=20\nSTAGE=after_mount_lookup\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=exit\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=entry\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=0\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nAbout to call OS_strnlen with VirtualPath=0x561b36d192b8, max=64\nSTAGE=after_strnlen\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nSTAGE=after_strrchr\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192bf\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nCALLING memchr: s=0x561b36d192c0, c=0, n=20\nSTAGE=after_mount_lookup\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=exit\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=entry\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=0\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nAbout to call OS_strnlen with VirtualPath=0x561b36d192b8, max=64\nSTAGE=after_strnlen\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nSTAGE=after_strrchr\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192bf\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nCALLING memchr: s=0x561b36d192c0, c=0, n=20\nSTAGE=after_mount_lookup\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=exit\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=entry\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=0\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nAbout to call OS_strnlen with VirtualPath=0x561b36d192b8, max=64\nSTAGE=after_strnlen\n  VirtualPath=0x561b36d192b8\n  name_ptr=(nil)\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nSTAGE=after_strrchr\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192bf\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=0\n  return_code=0\nCALLING memchr: s=0x561b36d192c0, c=0, n=20\nSTAGE=after_mount_lookup\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_code=-108\nSTAGE=exit\n  VirtualPath=0x561b36d192b8\n  name_ptr=0x561b36d192c0\n  VirtPathLen=23\n  SysMountPointLen=0\n  VirtPathBegin=23\n  return_c\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TranslatePath:\n#define OS_MAX_PATH_LEN 64\n...\n#define OS_MAX_FILE_NAME 20\n...\n#define OS_MAX_LOCAL_PATH_LEN (OS_MAX_PATH_LEN+OS_FS_PHYS_NAME_LEN)\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n...\n#define OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM 0x10\n...\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\nOS_filesys_internal_record_t OS_filesys_table[LOCAL_NUM_OBJECTS]\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nbool OS_FileSys_FindVirtMountPoint(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_filesys_internal_record_t *filesys;\n    const char *                  target = (const char *)ref;\n    size_t                        mplen;\n\n    filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL) == 0)\n    {\n        return false;\n    }\n\n    mplen = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n    /*\n     * The virtual_mountpt member should be a substring of the search target.\n     * If this matches a basic substring check then it may be match\n     */\n    if (mplen == 0 || mplen >= sizeof(filesys->virtual_mountpt) ||\n        strncmp(target, filesys->virtual_mountpt, mplen) != 0)\n    {\n        /* not a substring, so not a match */\n        return false;\n    }\n\n    /*\n     * Confirm that the substring ends at either a directory separator\n     * or the end of string  (so exact mount points also match).\n     *\n     * For instance consider a virtual_mountpt of /mnt/abc and searching\n     * for target=/mnt/abcd - this should return false in that case.\n     */\n    return (target[mplen] == '/' || target[mplen] == 0);\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\n#define OS_SUCCESS (0)\n...\n#define OS_FS_ERR_PATH_TOO_LONG (-103)\n...\n#define OS_FS_ERR_PATH_INVALID (-108)\n...\n#define OS_FS_ERR_NAME_TOO_LONG (-104)\n...\n#define OS_ERR_INCORRECT_OBJ_STATE (-35)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. OS_strnlen is implemented as a wrapper around memchr(s, 0, maxlen). OS_TranslatePath calls OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) (and later memchr(name_ptr, 0, OS_MAX_FILE_NAME)). There is no guarantee in OS_TranslatePath that the object pointed to by VirtualPath (or name_ptr) actually has OS_MAX_PATH_LEN (or OS_MAX_FILE_NAME) bytes accessible. If a caller passes a shorter buffer (for example a local array of length 8 containing \"abc\"), memchr may attempt to read up to maxlen bytes starting at that pointer and thus can read beyond the bounds of the object, producing undefined behaviour. This directly conflicts with MISRA C 2023 Rule 21.17, which forbids use of <string.h> functions that can access beyond the bounds of the referenced objects. \n\nPossible mitigations are to (a) document and enforce a precondition that VirtualPath points to an object with at least OS_MAX_PATH_LEN accessible bytes (not generally desirable), (b) change the API to accept an explicit buffer length from the caller, or (c) redesign the routine to avoid calling string.h functions with an unconstrained max length (e.g. use a safe interface such as strnlen_s where available or perform checks based on an explicit length)."
}