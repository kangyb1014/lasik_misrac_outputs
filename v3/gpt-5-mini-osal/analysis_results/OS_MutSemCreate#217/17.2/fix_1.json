{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_ProbeLog(const char *fmt, ...)\n{\n    char buf[1024];\n    int fd;\n    ssize_t res;\n    va_list ap;\n\n    fd = open(\"/tmp/logs/2176.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (fd < 0)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    va_start(ap, fmt);\n    /* Prepend a small prefix with pid and thread id for context */\n    {\n        pid_t pid = getpid();\n        unsigned long tid = (unsigned long)pthread_self();\n        int n = snprintf(buf, sizeof(buf), \"[pid=%d tid=%lu] \", (int)pid, tid);\n        if (n < 0)\n        {\n            n = 0;\n        }\n        if ((size_t)n < sizeof(buf))\n        {\n            vsnprintf(buf + n, sizeof(buf) - (size_t)n, fmt, ap);\n        }\n    }\n    va_end(ap);\n\n    /* Ensure newline */\n    size_t len = strnlen(buf, sizeof(buf));\n    if (len == 0 || buf[len-1] != '\\n')\n    {\n        if (len + 1 < sizeof(buf))\n        {\n            buf[len++] = '\\n';\n            buf[len] = '\\0';\n        }\n    }\n\n    /* Best-effort write; ignore partial-write handling for brevity */\n    res = write(fd, buf, strlen(buf));\n    (void)res;\n    close(fd);\n}\n\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n\n    /* Log entry and parameters. Avoid calling any OS logging API. */\n    OS_ProbeLog(\"ENTER OS_MutSemCreate: sem_id_ptr=%p sem_name=%s options=0x%08x\",\n                (void *)sem_id,\n                (sem_name != NULL) ? sem_name : \"(null)\",\n                (unsigned int)options);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    OS_ProbeLog(\"After OS_ObjectIdAllocateNew: return_code=%d token_addr=%p\",\n                (int)return_code,\n                (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n        OS_ProbeLog(\"After OS_OBJECT_INIT: token_addr=%p mutex_addr=%p obj_name=%s\",\n                    (void *)&token,\n                    (void *)mutex,\n                    (sem_name != NULL) ? sem_name : \"(null)\");\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        OS_ProbeLog(\"Before OS_MutSemCreate_Impl: token_addr=%p options=0x%08x\",\n                    (void *)&token,\n                    (unsigned int)options);\n\n        return_code = OS_MutSemCreate_Impl(&token, options);\n\n        OS_ProbeLog(\"After OS_MutSemCreate_Impl: return_code=%d token_addr=%p\",\n                    (int)return_code,\n                    (void *)&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        /* Capture sem_id value if set by finalize (best-effort) */\n        uintptr_t sem_id_val = 0;\n        if (sem_id != NULL)\n        {\n            /* The value might be uninitialized until finalize sets it; still record whatever it is. */\n            sem_id_val = (uintptr_t)(*sem_id);\n        }\n\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n\n        OS_ProbeLog(\"After OS_ObjectIdFinalizeNew: return_code=%d sem_id_ptr=%p sem_id_value=0x%lx\",\n                    (int)return_code,\n                    (void *)sem_id,\n                    (unsigned long)sem_id_val);\n    }\n    else\n    {\n        OS_ProbeLog(\"OS_ObjectIdAllocateNew failed: return_code=%d\", (int)return_code);\n    }\n\n    OS_ProbeLog(\"EXIT OS_MutSemCreate: return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c: In function 'OS_ProbeLog':\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c:105:5: error: unknown type name 'ssize_t'; did you mean 'size_t'?\n  105 |     ssize_t res;\n      |     ^~~~~~~\n      |     size_t\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c:108:48: error: 'O_APPEND' undeclared (first use in this function)\n  108 |     fd = open(\"/tmp/logs/2176.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n      |                                                ^~~~~~~~\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c:108:48: note: each undeclared identifier is reported only once for each function it appears in\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c:117:9: error: unknown type name 'pid_t'\n  117 |         pid_t pid = getpid();\n      |         ^~~~~\n/tmp/tmpgx9d1e1u/src/src/os/shared/src/osapi-mutex.c:118:9: error: aggregate value used where an integer was expected\n  118 |         unsigned long tid = (unsigned long)pthread_self();\n      |         ^~~~~~~~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-mutex.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-mutex.dir/__/__/os/shared/src/osapi-mutex.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:3911: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-mutex.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_MutSemCreate as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <stdint.h>\n\nstatic void OS_ProbeLog(const char *fmt, ...)\n{\n    char buf[1024];\n    ssize_t res;\n    int fd;\n    va_list ap;\n\n    fd = open(\"/tmp/logs/2176.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (fd < 0)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    va_start(ap, fmt);\n    /* Prepend a small prefix with pid and thread id for context */\n    {\n        pid_t pid = getpid();\n        /* pthread_t may be an opaque type (structure) on some platforms; avoid casting directly.\n         * Copy its bytes into an unsigned long for best-effort printable representation. */\n        pthread_t self = pthread_self();\n        unsigned long tid = 0;\n        size_t copy_sz = sizeof(tid) < sizeof(self) ? sizeof(tid) : sizeof(self);\n        memcpy(&tid, &self, copy_sz);\n\n        int n = snprintf(buf, sizeof(buf), \"[pid=%d tid=%lu] \", (int)pid, tid);\n        if (n < 0)\n        {\n            n = 0;\n        }\n        if ((size_t)n < sizeof(buf))\n        {\n            vsnprintf(buf + n, sizeof(buf) - (size_t)n, fmt, ap);\n        }\n    }\n    va_end(ap);\n\n    /* Ensure newline */\n    size_t len = strnlen(buf, sizeof(buf));\n    if (len == 0 || buf[len-1] != '\\n')\n    {\n        if (len + 1 < sizeof(buf))\n        {\n            buf[len++] = '\\n';\n            buf[len] = '\\0';\n        }\n    }\n\n    /* Best-effort write; ignore partial-write handling for brevity */\n    res = write(fd, buf, strlen(buf));\n    (void)res;\n    close(fd);\n}\n\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n\n    /* Log entry and parameters. Avoid calling any OS logging API. */\n    OS_ProbeLog(\"ENTER OS_MutSemCreate: sem_id_ptr=%p sem_name=%s options=0x%08x\",\n                (void *)sem_id,\n                (sem_name != NULL) ? sem_name : \"(null)\",\n                (unsigned int)options);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    OS_ProbeLog(\"After OS_ObjectIdAllocateNew: return_code=%d token_addr=%p\",\n                (int)return_code,\n                (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n        OS_ProbeLog(\"After OS_OBJECT_INIT: token_addr=%p mutex_addr=%p obj_name=%s\",\n                    (void *)&token,\n                    (void *)mutex,\n                    (sem_name != NULL) ? sem_name : \"(null)\");\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        OS_ProbeLog(\"Before OS_MutSemCreate_Impl: token_addr=%p options=0x%08x\",\n                    (void *)&token,\n                    (unsigned int)options);\n\n        return_code = OS_MutSemCreate_Impl(&token, options);\n\n        OS_ProbeLog(\"After OS_MutSemCreate_Impl: return_code=%d token_addr=%p\",\n                    (int)return_code,\n                    (void *)&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        /* Capture sem_id value if set by finalize (best-effort) */\n        uintptr_t sem_id_val = 0;\n        if (sem_id != NULL)\n        {\n            /* The value might be uninitialized until finalize sets it; still record whatever it is. */\n            sem_id_val = (uintptr_t)(*sem_id);\n        }\n\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n\n        OS_ProbeLog(\"After OS_ObjectIdFinalizeNew: return_code=%d sem_id_ptr=%p sem_id_value=0x%lx\",\n                    (int)return_code,\n                    (void *)sem_id,\n                    (unsigned long)sem_id_val);\n    }\n    else\n    {\n        OS_ProbeLog(\"OS_ObjectIdAllocateNew failed: return_code=%d\", (int)return_code);\n    }\n\n    OS_ProbeLog(\"EXIT OS_MutSemCreate: return_code=%d\", (int)return_code);\n    return return_code;\n}\n",
  "explanation": "I added the necessary standard headers so types and functions used in OS_ProbeLog are declared: <stdarg.h>, <stdio.h>, <string.h>, <unistd.h>, <sys/types.h>, <sys/stat.h>, <fcntl.h>, <pthread.h>, and <stdint.h>. This resolves errors for ssize_t, O_APPEND, pid_t, getpid, open, write, close, etc. \n\nTo avoid an invalid cast of pthread_t to an integer on platforms where pthread_t may be an opaque struct, I capture pthread_self() into a pthread_t and memcpy its bytes into an unsigned long tid for a best-effort printable thread identifier. This preserves the original intent (including pid and a thread identifier) while being portable and preventing the \"aggregate value used where an integer was expected\" compile error. \n\nNo project-specific logic was changed; only portability and header issues were fixed so the code compiles successfully."
}