{
  "user_message": "An agent A claimed that the following OS_TaskSetPriority_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskSetPriority_Impl.\n```c\nint32 OS_TaskSetPriority_Impl(const OS_object_token_t *token, osal_priority_t new_priority)\n{\n    int os_priority;\n    int ret;\n\n    OS_impl_task_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /* Change OSAL priority into a priority that will work for this OS */\n        os_priority = OS_PriorityRemap(new_priority);\n\n        /*\n        ** Set priority\n        */\n        ret = pthread_setschedprio(impl->id, os_priority);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_setschedprio: Task ID = %lu, prio = %d, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), os_priority, strerror(ret));\n            return OS_ERROR;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'impl' is declared as a non-const pointer (OS_impl_task_internal_record_t *impl;) but in the shown function it is only used for read access (e.g. impl->id is read for pthread_setschedprio) and there are no writes to the pointed object. The address is obtained from a global table via OS_OBJECT_TABLE_GET, and it is valid to use a pointer to const here. According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible (e.g. const OS_impl_task_internal_record_t *impl;).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskSetPriority_Impl:\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_task_internal_record_t OS_impl_task_table[OS_MAX_TASKS]\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_TaskSetPriority_Impl the local pointer 'impl' is only used for read access (impl->id) and there are no writes through that pointer in the function. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types where possible. Declaring the local variable as const OS_impl_task_internal_record_t *impl would satisfy the rule; assigning the address of the non-const global array element to a pointer-to-const is allowed in C. The only reason not to qualify it const would be if the function needed to modify the pointed object, which it does not. Therefore the reported violation is valid."
}