{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 memset(AllocNode, 0, sizeof(union NodeAllocator)) can write out of the allocated block in some real-world cases. AllocNode is obtained with malloc(sizeof(union NodeAllocator) + DataSize) but the code does not check the return value of malloc (malloc may return NULL \u2192 calling memset with a NULL pointer and non\u2011zero size is an invalid access). Also the size expression can overflow/wrap (e.g. very large DataSize) so malloc may allocate less than sizeof(union NodeAllocator); the subsequent memset of sizeof(union NodeAllocator) would then access beyond the allocated object. Both situations cause accesses beyond the bounds of the object referenced by the pointer parameter, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240e930 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240e930)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240e9a0 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240e9a0)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240ea10 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240ea10)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240ea80 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240ea80)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240eaf0 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240eaf0)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240eb60 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240eb60)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240ebd0 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240ebd0)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x55bf2240e890 Data=0x7fffd328ba70 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x55bf2240e8e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x55bf2240ec40 for Data=0x7fffd328ba70 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x55bf2240e8e0, NewNode=0x55bf2240ec40)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x555a30b89890 Data=0x7ffda7193130 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x555a30b898e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x555a30b89930 for Data=0x7ffda7193130 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x555a30b898e0, NewNode=0x555a30b89930)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList_Add called: ListHead=0x555a30b89890 Data=0x7ffda7193130 DataSize=64 Tag=2\nUtList_GetHead returned TagHead=0x555a30b898e0 for Tag=2\nTagHead != NULL, preparing to allocate new node with DataSize=64\nUtList_NewNode returned NewNode=0x555a30b899a0 for Data=0x7ffda7193130 DataSize=64\nCalling UtList_Insert_Before(TagHead=0x555a30b898e0, NewNode=0x555a30b899a0)\nUtList_Insert_Before returned\nUtList_Add exit\nUtList\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Add:\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 concerns the standard string/memory functions (memset/memcpy/etc.) not being allowed to access out-of-bounds memory. UtList_NewNode calls malloc(sizeof(union NodeAllocator) + DataSize) and then immediately does memset(AllocNode, 0, sizeof(union NodeAllocator)) and memcpy(AllocNode->Node.Data, Data, DataSize) without checking the return of malloc and without guarding against integer overflow of sizeof(union)+DataSize. If malloc returns NULL the subsequent memset/memcpy invoke undefined behaviour (access via a NULL pointer). If sizeof(union)+DataSize overflows/wraps, malloc may allocate less than expected and the memset/memcpy can write past the allocated block. Both scenarios can cause the string/memory functions to access beyond the bounds of the objects referenced by their pointer parameters, violating MISRA C 2023 Rule 21.17. (Also note memcpy can read beyond the source Data if the caller provides an incorrect DataSize.)"
}