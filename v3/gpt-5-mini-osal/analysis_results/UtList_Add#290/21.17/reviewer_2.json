{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nAllocNode is not checked for NULL after malloc. If malloc fails (AllocNode == NULL), the expression &AllocNode[1] dereferences a NULL pointer and the subsequent memcpy(AllocNode->Node.Data, Data, DataSize) will attempt to write through an invalid pointer \u2014 resulting in an access beyond the bounds of the object referenced by the destination pointer parameter of memcpy (violation of MISRA C 2023 Rule 21.17).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410930 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410930 Tag=2\nInserted NewNode 0x55c8f2410930 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f24109a0 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f24109a0 Tag=2\nInserted NewNode 0x55c8f24109a0 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410a10 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410a10 Tag=2\nInserted NewNode 0x55c8f2410a10 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410a80 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410a80 Tag=2\nInserted NewNode 0x55c8f2410a80 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410af0 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410af0 Tag=2\nInserted NewNode 0x55c8f2410af0 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410b60 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410b60 Tag=2\nInserted NewNode 0x55c8f2410b60 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410bd0 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410bd0 Tag=2\nInserted NewNode 0x55c8f2410bd0 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55c8f2410890 Data=0x7ffe8d691120 DataSize=64 Tag=2\nTagHead returned: 0x55c8f24108e0\nUtList_NewNode returned: 0x55c8f2410c40 (Data=0x7ffe8d691120 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55c8f2410c40 Tag=2\nInserted NewNode 0x55c8f2410c40 before TagHead 0x55c8f24108e0\nEXIT: UtList_Add ListHead=0x55c8f2410890\nENTER: UtList_Add ListHead=0x55a3d48b3890 Data=0x7fff1f6c3300 DataSize=64 Tag=2\nTagHead returned: 0x55a3d48b38e0\nUtList_NewNode returned: 0x55a3d48b3930 (Data=0x7fff1f6c3300 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55a3d48b3930 Tag=2\nInserted NewNode 0x55a3d48b3930 before TagHead 0x55a3d48b38e0\nEXIT: UtList_Add ListHead=0x55a3d48b3890\nENTER: UtList_Add ListHead=0x55a3d48b3890 Data=0x7fff1f6c3300 DataSize=64 Tag=2\nTagHead returned: 0x55a3d48b38e0\nUtList_NewNode returned: 0x55a3d48b39a0 (Data=0x7fff1f6c3300 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55a3d48b39a0 Tag=2\nInserted NewNode 0x55a3d48b39a0 before TagHead 0x55a3d48b38e0\nEXIT: UtList_Add ListHead=0x55a3d48b3890\nENTER: UtList_Add ListHead=0x55a3d48b3890 Data=0x7fff1f6c3300 DataSize=64 Tag=2\nTagHead returned: 0x55a3d48b38e0\nUtList_NewNode returned: 0x55a3d48b3a10 (Data=0x7fff1f6c3300 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55a3d48b3a10 Tag=2\nInserted NewNode 0x55a3d48b3a10 before TagHead 0x55a3d48b38e0\nEXIT: UtList_Add ListHead=0x55a3d48b3890\nENTER: UtList_Add ListHead=0x55a3d48b3890 Data=0x7fff1f6c3300 DataSize=64 Tag=2\nTagHead returned: 0x55a3d48b38e0\nUtList_NewNode returned: 0x55a3d48b3a80 (Data=0x7fff1f6c3300 DataSize=64)\nAbout to set NewNode->Tag; NewNode=0x55a3d48b3a80 Tag=2\nInserted NewNode 0x55a3d48b3a80 before TagHead \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Add:\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In UtList_NewNode the code does not check the result of malloc():\n\n  AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n  memset(AllocNode, 0, sizeof(union NodeAllocator));\n  AllocNode->Node.Data = &AllocNode[1];\n  memcpy(AllocNode->Node.Data, Data, DataSize);\n\nIf malloc returns NULL, the subsequent memset and the use of &AllocNode[1] and memcpy will dereference a NULL pointer and pass invalid destination pointers to the standard string functions. That can cause accesses through pointers that do not reference valid objects (effectively out-of-bounds/invalid accesses) and therefore violates MISRA C 2023 Rule 21.17. The execution log only shows successful allocations at runtime, but the potential for malloc to fail makes the code non-compliant. The remedy is to check AllocNode for NULL after malloc and handle the allocation failure (e.g. return NULL or otherwise avoid calling memset/memcpy with an invalid pointer)."
}