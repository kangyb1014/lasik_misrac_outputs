{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation occurs if the function-pointer type iter->match is declared to accept non-const pointers (for example: bool (*match)(void *arg, OS_object_token_t *token, OS_common_record_t *record)). In that case the call iter->match(iter->arg, &iter->token, record) passes pointers to objects that are not intended to be modified, so the parameters should be const-qualified (const OS_object_token_t * and const OS_common_record_t *) and Rule 8.13 is violated.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct as stated. MISRA 8.13 concerns pointer declarations that should be const-qualified when the pointed-to object is not modified. The snippet shown only shows a call through iter->match; whether a rule violation exists depends on the declaration/definition of the match function pointer and whether the callback is intended to modify the token or record. If the match prototype is indeed declared without const but the callback does not (and is not intended to) modify the token/record, then that declaration would be a violation of 8.13. However, that is a deficiency in the function-pointer type declaration, not demonstrable from the call site alone. Because the provided code and scenario do not prove that the parameters cannot be const, the report as applied to this snippet is not correct."
}