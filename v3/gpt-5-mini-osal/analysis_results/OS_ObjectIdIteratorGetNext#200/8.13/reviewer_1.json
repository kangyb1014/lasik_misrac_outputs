{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe variable 'record' is only used for read-only access (record->active_id) and passed to a matcher function; it could be declared as const OS_common_record_t *record. Declaring it as a non-const pointer when no modification is performed violates MISRA C 2023 Rule 8.13, which requires pointers to point to const-qualified types whenever possible. (If, however, OS_OBJECT_TABLE_GET or iter->match require a non-const pointer, making it const may be infeasible.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not verifiable from the snippet alone and therefore is not a confirmed MISRA 8.13 violation. Rule 8.13 indeed recommends that pointers should point to const-qualified types when possible, and in this function the local variable record is only read, so syntactically it could be declared const. However, whether that change is feasible depends on the rest of the program: the type returned by OS_OBJECT_TABLE_GET and the prototype of iter->match. If either of those expect a non-const OS_common_record_t * (or if the macro expands in a way that requires a non-const lvalue), you cannot safely change record to const without other changes (or casts), and leaving it non-const would be acceptable. Agent A did not show the definitions/signatures of OS_OBJECT_TABLE_GET or iter->match, so their assertion that this is a rule violation is incomplete. Consequently the report is not correct as presented."
}