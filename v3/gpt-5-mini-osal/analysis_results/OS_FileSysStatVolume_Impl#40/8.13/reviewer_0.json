{
  "user_message": "An agent A claimed that the following OS_FileSysStatVolume_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStatVolume_Impl.\n```c\nint32 OS_FileSysStatVolume_Impl(const OS_object_token_t *token, OS_statvfs_t *result)\n{\n    OS_filesys_internal_record_t *local;\n    struct statvfs                stat_buf;\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if (statvfs(local->system_mountpt, &stat_buf) != 0)\n    {\n        return OS_ERROR;\n    }\n\n    result->block_size   = OSAL_SIZE_C(stat_buf.f_bsize);\n    result->blocks_free  = OSAL_BLOCKCOUNT_C(stat_buf.f_bfree);\n    result->total_blocks = OSAL_BLOCKCOUNT_C(stat_buf.f_blocks);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'local' is declared as a mutable pointer (OS_filesys_internal_record_t *local) but is only used for read-only access (e.g. passing local->system_mountpt to statvfs). Per MISRA C 2023 Rule 8.13 it should be const-qualified, e.g. 'const OS_filesys_internal_record_t *local;'. Assigning the table element (&tbl[index]) to a pointer-to-const is allowed, so the current non-const declaration violates the rule.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileSysStatVolume_Impl:\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    size_t            block_size;   /**< Block size of underlying FS */\n    osal_blockcount_t total_blocks; /**< Total blocks in underlying FS */\n    osal_blockcount_t blocks_free;  /**< Available blocks in underlying FS */\n} OS_statvfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 8.13 prefers that pointers point to const-qualified types when the pointee is not modified through that pointer. In the shown function, the local variable 'local' is only used for read-only access (local->system_mountpt is read and passed to statvfs; no writes through 'local' occur). Therefore 'local' can and should be declared as a pointer to const, e.g.:\n\nconst OS_filesys_internal_record_t *local;\n\nAssigning the address of a non-const table element (&tbl[index]) to a pointer-to-const is allowed (qualification is being added), so there is no obstacle to making this change. Given the provided code, the agent A report is correct: the current non-const declaration violates the intent of Rule 8.13 and should be changed to a const-qualified pointer unless there is a subsequent write through that pointer elsewhere in the function/translation unit (which is not shown)."
}