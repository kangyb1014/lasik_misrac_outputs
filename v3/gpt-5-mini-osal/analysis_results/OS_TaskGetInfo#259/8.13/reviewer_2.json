{
  "user_message": "An agent A claimed that the following OS_TaskGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskGetInfo.\n```c\nint32 OS_TaskGetInfo(osal_id_t task_id, OS_task_prop_t *task_prop)\n{\n    OS_common_record_t *       record;\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_prop);\n\n    memset(task_prop, 0, sizeof(OS_task_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_task_table, token);\n        task   = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(task_prop->name, record->name_entry, sizeof(task_prop->name) - 1);\n            task_prop->name[sizeof(task_prop->name) - 1] = 0;\n        }\n        task_prop->creator    = record->creator;\n        task_prop->stack_size = task->stack_size;\n        task_prop->priority   = task->priority;\n\n        return_code = OS_TaskGetInfo_Impl(&token, task_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe declaration extern OS_common_record_t *const OS_global_task_table provides a const pointer to a mutable OS_common_record_t. In OS_TaskGetInfo the code uses record = OS_OBJECT_TABLE_GET(OS_global_task_table, token) and only reads fields (name_entry, creator), so the pointer could/should be to a const-qualified type (e.g. extern const OS_common_record_t *const OS_global_task_table). Therefore this declaration violates MISRA C 2023 Rule 8.13 unless there is a justified need elsewhere in the code to modify the records via this pointer.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskGetInfo:\ntypedef struct\n{\n    char            name[OS_MAX_API_NAME];\n    osal_id_t       creator;\n    size_t          stack_size;\n    osal_priority_t priority;\n} OS_task_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\ntypedef struct\n{\n    char            task_name[OS_MAX_API_NAME];\n    size_t          stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_task_entry delete_hook_pointer;\n    void *          entry_arg;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_TaskGetInfo_Impl(const OS_object_token_t *token, OS_task_prop_t *task_prop)\n{\n    return OS_SUCCESS;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\nextern OS_common_record_t *const OS_global_task_table\n...\nOS_task_internal_record_t OS_task_table[LOCAL_NUM_OBJECTS]\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Summary: Agent A points out that OS_global_task_table is declared as extern OS_common_record_t *const (a const pointer to a mutable OS_common_record_t) and argues it should be extern const OS_common_record_t *const if the records are only read. MISRA C 2023 Rule 8.13 indeed recommends that pointers should point to const-qualified types whenever possible. In the shown OS_TaskGetInfo implementation the code only reads fields from the common record, so from this function alone a const-qualified pointee would be preferable.\n\nWhy the report as stated is not provably correct: The rule requires making the pointee const whenever possible, but \u201cpossible\u201d depends on whether the object is ever modified through that pointer elsewhere in the code base. The provided snippets show only reads; they do not show whether other code writes to the records via OS_global_task_table (or reinitializes/assigns it). Because OS_global_task_table is declared extern, its definition and uses may reside elsewhere and could legitimately perform modifications. Without evidence that the table and its elements are never modified through that pointer, you cannot conclude a definite MISRA violation. In other words, the code in OS_TaskGetInfo by itself does not prove a breach of Rule 8.13 \u2014 the global declaration might be justified.\n\nRecommendation: Inspect the whole translation unit(s) to see whether any code writes to the common records via OS_global_task_table or assigns to that pointer. If no write access exists, change the declaration to extern const OS_common_record_t *const OS_global_task_table (and propagate const through OS_OBJECT_TABLE_GET and any callers) or provide a documented justification for not qualifying the pointee const as required by MISRA.\n\nConclusion: The report is not conclusively correct based on the supplied code; it is potentially correct but requires whole-program evidence. If no writes occur, it is a true violation; otherwise it is not."
}