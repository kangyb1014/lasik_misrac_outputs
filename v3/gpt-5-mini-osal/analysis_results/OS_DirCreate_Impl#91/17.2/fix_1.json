{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_write(const char *buf, size_t len)\n{\n    int fd = open(\"/tmp/logs/916.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (fd >= 0)\n    {\n        /* best-effort write; ignore errors */\n        (void)write(fd, buf, len);\n        (void)close(fd);\n    }\n}\nstatic void probe_log(const char *fmt, ...)\n{\n    char buffer[512];\n    va_list ap;\n    va_start(ap, fmt);\n    /* format into local buffer, ensure null termination */\n    int n = vsnprintf(buffer, sizeof(buffer), fmt, ap);\n    va_end(ap);\n\n    if (n > 0)\n    {\n        size_t len = (size_t)((n < (int)sizeof(buffer)) ? n : (int)sizeof(buffer) - 1);\n        probe_write(buffer, len);\n        probe_write(\"\\n\", 1);\n    }\n}\n\nint32 OS_DirCreate_Impl(const char *local_path, uint32 access)\n{\n    struct stat st;\n    int32       return_code;\n\n    probe_log(\"OS_DirCreate_Impl ENTRY: path=\\\"%s\\\", access=%u, pid=%d\", local_path ? local_path : \"(null)\", (unsigned)access, (int)getpid());\n\n    if (mkdir(local_path, S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO) < 0)\n    {\n        /* Capture errno immediately to avoid subsequent calls (e.g. logging) overwriting it */\n        int saved_errno = errno;\n\n        probe_log(\"mkdir FAILED: path=\\\"%s\\\", errno=%d (%s)\", local_path ? local_path : \"(null)\", saved_errno, strerror(saved_errno));\n\n        return_code = OS_ERROR;\n\n        if (saved_errno == EEXIST)\n        {\n            /* Success if already exists and is a directory */\n            int stat_ret = stat(local_path, &st);\n            probe_log(\"stat called for existing path=\\\"%s\\\": stat_ret=%d, stat_errno=%d\", local_path ? local_path : \"(null)\", stat_ret, stat_ret ? errno : 0);\n\n            if (stat_ret == 0)\n            {\n                probe_log(\"stat.st_mode=0%o, S_ISDIR=%d\", (unsigned)st.st_mode, S_ISDIR(st.st_mode) ? 1 : 0);\n\n                if (S_ISDIR(st.st_mode))\n                {\n                    return_code = OS_SUCCESS;\n                    probe_log(\"Existing path is a directory: returning OS_SUCCESS\");\n                }\n                else\n                {\n                    probe_log(\"Existing path is NOT a directory: returning OS_ERROR\");\n                }\n            }\n            else\n            {\n                probe_log(\"stat failed on existing path: errno=%d (%s)\", errno, strerror(errno));\n            }\n        }\n        else\n        {\n            probe_log(\"mkdir failed with non-EEXIST errno: %d (%s)\", saved_errno, strerror(saved_errno));\n        }\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n        probe_log(\"mkdir SUCCEEDED: path=\\\"%s\\\", returning OS_SUCCESS\", local_path ? local_path : \"(null)\");\n    }\n\n    probe_log(\"OS_DirCreate_Impl EXIT: path=\\\"%s\\\", return_code=%d\", local_path ? local_path : \"(null)\", (int)return_code);\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpoiki_yg_/src/src/os/portable/os-impl-posix-dirs.c: In function 'probe_write':\n/tmp/tmpoiki_yg_/src/src/os/portable/os-impl-posix-dirs.c:85:61: error: 'O_APPEND' undeclared (first use in this function)\n   85 |     int fd = open(\"/tmp/logs/916.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                                             ^~~~~~~~\n/tmp/tmpoiki_yg_/src/src/os/portable/os-impl-posix-dirs.c:85:61: note: each undeclared identifier is reported only once for each function it appears in\ngmake[2]: *** [unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-dirs.dir/build.make:76: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-dirs.dir/__/__/os/portable/os-impl-posix-dirs.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:2456: unit-test-coverage/vxworks/CMakeFiles/utobj_coverage-vxworks-posix-dirs.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_DirCreate_Impl as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed test code: adds necessary includes and minimal type/constant definitions so it compiles standalone */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdint.h>\n\n/* Minimal compatibility types/constants so this file can compile standalone\n   (these would normally come from the larger project headers). */\ntypedef int32_t int32;\nenum { OS_SUCCESS = 0, OS_ERROR = -1 };\n\nstatic void probe_write(const char *buf, size_t len)\n{\n    int fd = open(\"/tmp/logs/916.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (fd >= 0)\n    {\n        /* best-effort write; ignore errors */\n        (void)write(fd, buf, len);\n        (void)close(fd);\n    }\n}\n\nstatic void probe_log(const char *fmt, ...)\n{\n    char buffer[512];\n    va_list ap;\n    va_start(ap, fmt);\n    /* format into local buffer, ensure null termination */\n    int n = vsnprintf(buffer, sizeof(buffer), fmt, ap);\n    va_end(ap);\n\n    if (n > 0)\n    {\n        size_t len = (size_t)((n < (int)sizeof(buffer)) ? n : (int)sizeof(buffer) - 1);\n        probe_write(buffer, len);\n        probe_write(\"\\n\", 1);\n    }\n}\n\nint32 OS_DirCreate_Impl(const char *local_path, uint32_t access)\n{\n    struct stat st;\n    int32       return_code;\n\n    probe_log(\"OS_DirCreate_Impl ENTRY: path=\\\"%s\\\", access=%u, pid=%d\", local_path ? local_path : \"(null)\", (unsigned)access, (int)getpid());\n\n    if (mkdir(local_path, S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO) < 0)\n    {\n        /* Capture errno immediately to avoid subsequent calls (e.g. logging) overwriting it */\n        int saved_errno = errno;\n\n        probe_log(\"mkdir FAILED: path=\\\"%s\\\", errno=%d (%s)\", local_path ? local_path : \"(null)\", saved_errno, strerror(saved_errno));\n\n        return_code = OS_ERROR;\n\n        if (saved_errno == EEXIST)\n        {\n            /* Success if already exists and is a directory */\n            int stat_ret = stat(local_path, &st);\n            probe_log(\"stat called for existing path=\\\"%s\\\": stat_ret=%d, stat_errno=%d\", local_path ? local_path : \"(null)\", stat_ret, stat_ret ? errno : 0);\n\n            if (stat_ret == 0)\n            {\n                probe_log(\"stat.st_mode=0%o, S_ISDIR=%d\", (unsigned)st.st_mode, S_ISDIR(st.st_mode) ? 1 : 0);\n\n                if (S_ISDIR(st.st_mode))\n                {\n                    return_code = OS_SUCCESS;\n                    probe_log(\"Existing path is a directory: returning OS_SUCCESS\");\n                }\n                else\n                {\n                    probe_log(\"Existing path is NOT a directory: returning OS_ERROR\");\n                }\n            }\n            else\n            {\n                probe_log(\"stat failed on existing path: errno=%d (%s)\", errno, strerror(errno));\n            }\n        }\n        else\n        {\n            probe_log(\"mkdir failed with non-EEXIST errno: %d (%s)\", saved_errno, strerror(saved_errno));\n        }\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n        probe_log(\"mkdir SUCCEEDED: path=\\\"%s\\\", returning OS_SUCCESS\", local_path ? local_path : \"(null)\");\n    }\n\n    probe_log(\"OS_DirCreate_Impl EXIT: path=\\\"%s\\\", return_code=%d\", local_path ? local_path : \"(null)\", (int)return_code);\n\n    return return_code;\n}\n",
  "explanation": "I added the necessary POSIX and C headers (fcntl.h, unistd.h, stdarg.h, stdio.h, string.h, errno.h, sys/stat.h, sys/types.h, stdint.h) so symbols like O_APPEND, open, write, close, vsnprintf, va_list, stat, strerror, errno, and getpid are declared. I also provided minimal project-local type/constant definitions (typedef int32 and enum values for OS_SUCCESS/OS_ERROR) so the file compiles standalone while preserving the original logic. No macros, main(), or mock functions were added."
}