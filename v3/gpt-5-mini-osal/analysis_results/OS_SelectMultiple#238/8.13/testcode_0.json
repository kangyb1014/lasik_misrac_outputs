{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nOS_SelectMultiple takes parameters as non-const (OS_FdSet *ReadSet, OS_FdSet *WriteSet) and forwards them unchanged to OS_SelectMultiple_Impl. If neither OS_SelectMultiple nor OS_SelectMultiple_Impl modify the fd sets (i.e. they only read them), then the pointers should be declared const (const OS_FdSet *). In that case the current code (passing non-const pointers and using non-const parameter types) violates MISRA C 2023 Rule 8.13. (If the implementations do modify the sets, then non-const is required and there is no violation.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SelectMultiple code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2383.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SelectMultiple as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SelectMultiple:\n```c\nint32 OS_SelectMultiple(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    int32 return_code;\n\n    /*\n     * Check parameters\n     *\n     * Note \"ReadSet\" and \"WriteSet\" are not checked, because in certain configurations they can be validly null.\n     */\n\n    /*\n     * This does not currently increment any refcounts.\n     * That means a file/socket can be closed while actively inside a\n     * OS_SelectMultiple() call in another thread.\n     */\n    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SelectMultiple code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <time.h>\n\n/*\n * Declarations for external types and implementation function.\n * These are assumed to be provided elsewhere in the build, as in the\n * original code base. We do not redefine them here.\n */\nextern int32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs);\n\n/*\n * Probe/logging helpers. They only read the fdset memory and write\n * information to a log file. They do not modify any of the parameters\n * or global state used by the original function.\n */\nstatic void probe_append_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2383.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging, do not affect program flow */\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fclose(f);\n}\n\n/*\n * Simple checksum over the raw bytes of the OS_FdSet structure to detect\n * whether the contents changed across the call. If OS_FdSet is an\n * incomplete type at this point in compilation this will fail; in the\n * intended build environment OS_FdSet is a complete type as in the\n * original codebase.\n */\nstatic unsigned long probe_checksum_fdset(const OS_FdSet *set)\n{\n    if (set == NULL)\n    {\n        return 0UL;\n    }\n\n    const unsigned char *p = (const unsigned char *)set;\n    size_t n = sizeof(*set);\n    unsigned long sum = 1469598103934665603UL; /* FNV-1a offset basis (64-bit truncated)\n                                              used as a simple rolling mix */\n    for (size_t i = 0; i < n; ++i)\n    {\n        sum ^= (unsigned long)p[i];\n        sum *= 1099511628211UL; /* FNV-1a prime */\n    }\n    return sum;\n}\n\nstatic void probe_log_fdset_state(const char *stage, const OS_FdSet *readSet, const OS_FdSet *writeSet, int32 msecs)\n{\n    time_t now = time(NULL);\n    unsigned long chk_r = probe_checksum_fdset(readSet);\n    unsigned long chk_w = probe_checksum_fdset(writeSet);\n\n    probe_append_log(\"%s: time=%ld stage=%s ReadSet=%p ReadChk=0x%08lx WriteSet=%p WriteChk=0x%08lx msecs=%d\\n\",\n                     __func__, (long)now, stage, (const void *)readSet, chk_r, (const void *)writeSet, chk_w, (int)msecs);\n}\n\nint32 OS_SelectMultiple(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    int32 return_code;\n\n    /*\n     * Check parameters\n     *\n     * Note \"ReadSet\" and \"WriteSet\" are not checked, because in certain configurations they can be validly null.\n     */\n\n    /*\n     * Log pre-call state (addresses and a checksum of the contents).\n     * This helps determine whether the fd sets are treated as read-only\n     * by the implementation.\n     */\n    probe_log_fdset_state(\"pre\", ReadSet, WriteSet, msecs);\n\n    /*\n     * This does not currently increment any refcounts.\n     * That means a file/socket can be closed while actively inside a\n     * OS_SelectMultiple() call in another thread.\n     */\n    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);\n\n    /*\n     * Log post-call state and return code. If the checksum of either\n     * fd set differs between the pre and post logs, that indicates the\n     * implementation modified the set(s) (and thus using const would be\n     * inappropriate). If the checksums are identical, that supports the\n     * claim that the parameters could be const-qualified.\n     */\n    probe_log_fdset_state(\"post\", ReadSet, WriteSet, msecs);\n\n    probe_append_log(\"%s: return_code=%d\\n\", __func__, (int)return_code);\n\n    return return_code;\n}\n"
}