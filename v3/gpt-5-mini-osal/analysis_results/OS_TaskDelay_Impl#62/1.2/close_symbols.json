{
  "user_message": "Target function code is:\n```c\nint32 OS_TaskDelay_Impl(uint32 millisecond)\n{\n    struct timespec sleep_end;\n    int             status;\n\n    clock_gettime(CLOCK_MONOTONIC, &sleep_end);\n    sleep_end.tv_sec += millisecond / 1000;\n    sleep_end.tv_nsec += 1000000 * (millisecond % 1000);\n\n    if (sleep_end.tv_nsec >= 1000000000)\n    {\n        sleep_end.tv_nsec -= 1000000000;\n        ++sleep_end.tv_sec;\n    }\n\n    do\n    {\n        status = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &sleep_end, NULL);\n    } while (status == EINTR);\n\n    if (status != 0)\n    {\n        return OS_ERROR;\n    }\n    else\n    {\n        return OS_SUCCESS;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_TaskDelay_Impl': {'callees': [], 'callers': ['OS_TaskDelay', 'OS_TimeBase_CallbackThread']}, 'OS_TaskDelay': {'callees': ['OS_TaskDelay_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': ['OS_DeleteAllObjects']}, 'OS_TimeBase_CallbackThread': {'callees': ['OS_TaskRegister_Impl', 'OS_ObjectIdGetById', 'OS_ObjectIndexFromToken', 'OS_ObjectIdRelease', 'OS_TaskDelay_Impl', 'OS_TimeBaseLock_Impl', 'OS_ObjectIdEqual', 'OS_TimeBaseUnlock_Impl', 'OS_ObjectIdFromToken'], 'callers': ['OS_TimeBasePthreadEntry']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "int32",
    "uint32",
    "struct timespec",
    "time_t",
    "clock_gettime",
    "clock_nanosleep",
    "CLOCK_MONOTONIC",
    "TIMER_ABSTIME",
    "EINTR",
    "OS_ERROR",
    "OS_SUCCESS",
    "prototype/declaration (and any attributes/macros) for OS_TaskDelay_Impl"
  ],
  "explanation": "For each symbol below we need its actual definition/declaration (from the headers or project sources) so the next analyzer can determine whether any compiler- or platform-specific language extensions are being used in or through that symbol:\n\n- int32: This typedef/definition of the parameter return type could be a plain standard typedef (e.g. int32_t) or implemented with a compiler-specific extension (e.g. __int32 or other non\u2011standard typedef). Must inspect to ensure no language extensions are used.\n\n- uint32: Same rationale as int32; verify it is a standard typedef and not a compiler-specific extension.\n\n- struct timespec: Needed to confirm its exact layout and member types (tv_sec, tv_nsec). The struct could be provided by headers where implementation uses non\u2011standard language extensions or attributes; check its definition for extensions.\n\n- time_t: tv_sec is usually time_t; the actual typedef may be platform-specific. Check its definition to ensure it is not a compiler extension.\n\n- clock_gettime: Provide the declaration (or macro) so we can see whether it is a plain function prototype or a macro/inline that uses compiler extensions or attributes (e.g. __attribute__, inline asm, statement expressions).\n\n- clock_nanosleep: Same as clock_gettime \u2014 need its declaration or macro expansion to check for use of non\u2011standard constructs or attributes (and verify return/error semantics used by the code are standard POSIX, not implemented via extensions).\n\n- CLOCK_MONOTONIC: Macro/constant definition may be simple enum/int, or could be implemented through header tricks. Inspect to ensure no compiler-specific constructs are used in its definition.\n\n- TIMER_ABSTIME: As above, check its definition \u2014 it might be a constant or macro; ensure no language extensions are involved.\n\n- EINTR: errno constant macro; include its definition to ensure it is the standard macro and not shadowed by an extension or exotic implementation.\n\n- OS_ERROR and OS_SUCCESS: These project-level macros/enum values are used for return codes. Their definitions must be checked to ensure they are standard macros/enum constants and not created using compiler extensions (e.g. weird attributes or asm labels).\n\n- prototype/declaration (and any attributes/macros) for OS_TaskDelay_Impl: Check the function's prototype or any attributes (linkage, visibility, compiler attributes) applied at declaration time. Attributes or macros attached to the function declaration/definition could themselves be compiler extensions and must be flagged.\n\nCollecting these symbols (definitions/declarations/macros) lets the next analyzer determine whether any of the used types, macros, or functions are implemented using compiler- or platform-specific language extensions (attributes, builtin types, asm, statement expressions, typeof, etc.), which is required to decide MISRA conformance for the \"no language extensions\" rule."
}