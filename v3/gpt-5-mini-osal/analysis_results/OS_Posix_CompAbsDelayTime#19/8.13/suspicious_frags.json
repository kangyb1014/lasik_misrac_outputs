{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_Posix_CompAbsDelayTime:\n```c\nvoid OS_Posix_CompAbsDelayTime(uint32 msecs, struct timespec *tm)\n{\n    clock_gettime(CLOCK_REALTIME, tm);\n\n    /* add the delay to the current time */\n    tm->tv_sec += (time_t)(msecs / 1000);\n    /* convert residue ( msecs )  to nanoseconds */\n    tm->tv_nsec += (msecs % 1000) * 1000000L;\n\n    if (tm->tv_nsec >= 1000000000L)\n    {\n        tm->tv_nsec -= 1000000000L;\n        tm->tv_sec++;\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_Posix_CompAbsDelayTime:\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "sizeCopied = mq_receive(impl->id, data, size, NULL);",
    "sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);",
    "impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);",
    "OS_impl_queue_internal_record_t *impl;"
  ],
  "explanation": "Other pointer-related fragments do not need investigation for MISRA C 2023 Rule 8.13: - The function parameter 'const OS_object_token_t *token' is already const-qualified. - The 'data' parameter (void *data) is used as an output buffer (written by mq_receive/mq_timedreceive), so it must not be const. - The 'size_t *size_copied' parameter is an output parameter (written to), so it must not be const. - The 'struct timespec *tm' parameter of OS_Posix_CompAbsDelayTime is explicitly modified (clock_gettime and subsequent updates), so it cannot be const. - Passing a non-const object address to a callee that accepts a const-pointer parameter (e.g., &ts to mq_timedreceive) is allowed; that does not by itself indicate a missing const qualification in the local declaration. Therefore these fragments are not flagged for Rule 8.13."
}