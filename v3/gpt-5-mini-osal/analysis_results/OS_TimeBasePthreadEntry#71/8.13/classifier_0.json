{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_TimeBasePthreadEntry:\n```c\nstatic void *OS_TimeBasePthreadEntry(void *arg)\n{\n    OS_VoidPtrValueWrapper_t local_arg;\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    local_arg.opaque_arg = arg;\n    OS_TimeBase_CallbackThread(local_arg.id);\n\n    return NULL;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nlocal_arg.opaque_arg = arg;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the pthread entry point must use the POSIX prototype void *(*)(void *), so the parameter arg cannot be const-qualified. Assigning this non-const void * to the union member (opaque_arg) does not itself breach Rule 8.13. (If opaque_arg were non-const while the data is only read and could be declared const, that would be an opportunity to add const, but the pthread API prevents changing the function parameter to const.)"
}