{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SocketBind:\n```c\nint32 OS_SocketBind(osal_id_t sock_id, const OS_SockAddr_t *Addr)\n{\n    int32 return_code;\n\n    return_code = OS_SocketBindAddress(sock_id, Addr);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_SocketListen(sock_id);\n        if (return_code == OS_ERR_INCORRECT_OBJ_TYPE)\n        {\n            /* This one is OK, it happens if the socket is a datagram/connectionless\n             * type that does not need to listen().  For backward compatibility, report\n             * success to the caller.\n             */\n            return_code = OS_SUCCESS;\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SocketBind:\nint32 OS_SocketListen_Impl(const OS_object_token_t *token)\n{\n    int                             os_result;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    os_result = listen(impl->fd, 10);\n    if (os_result < 0)\n    {\n        OS_DEBUG(\"listen: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_SocketBindAddress_Impl(const OS_object_token_t *token, const OS_SockAddr_t *Addr)\n{\n    int                             os_result;\n    socklen_t                       addrlen;\n    const struct sockaddr *         sa;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    sa = (const struct sockaddr *)&Addr->AddrData;\n\n    switch (sa->sa_family)\n    {\n        case AF_INET:\n            addrlen = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrlen = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            addrlen = 0;\n            break;\n    }\n\n    if (addrlen == 0)\n    {\n        return OS_ERR_BAD_ADDRESS;\n    }\n\n    os_result = bind(impl->fd, sa, addrlen);\n    if (os_result < 0)\n    {\n        OS_DEBUG(\"bind: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_SocketListen(osal_id_t sock_id)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* This call is only applicable to stream sockets */\n        if (stream->socket_domain == OS_SocketDomain_INVALID || stream->socket_type != OS_SocketType_STREAM)\n        {\n            /* Not a stream socket */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((stream->stream_state & OS_STREAM_STATE_BOUND) == 0)\n        {\n            /* Socket must be bound to an address already */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_LISTENING | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither listening nor connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_SocketListen_Impl(&token);\n\n            if (return_code == OS_SUCCESS)\n            {\n                stream->stream_state |= OS_STREAM_STATE_LISTENING;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_SocketBindAddress(osal_id_t sock_id, const OS_SockAddr_t *Addr)\n{\n    OS_common_record_t *         record;\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            /* Not a socket */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither bound nor connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_SocketBindAddress_Impl(&token, Addr);\n\n            if (return_code == OS_SUCCESS)\n            {\n                OS_CreateSocketName(&token, Addr, NULL);\n                record->name_entry = stream->stream_name;\n                stream->stream_state |= OS_STREAM_STATE_BOUND;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\n#define OS_SUCCESS (0)\n...\n#define OS_ERR_INCORRECT_OBJ_TYPE (-36)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_CHECK_POINTER(Addr);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "OS_CHECK_POINTER(Addr) is a runtime null-pointer validation macro; its presence can cause the function to return an error or trigger an error-handling path if Addr is NULL. Removing it would change program behaviour (possible null dereference later), so it is not dead code. (Only if the macro were defined as a compile-time no-op in all builds would it constitute dead code, but no such definition is provided here.)"
}