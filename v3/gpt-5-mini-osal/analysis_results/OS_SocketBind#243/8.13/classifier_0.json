{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SocketBind:\n```c\nint32 OS_SocketBind(osal_id_t sock_id, const OS_SockAddr_t *Addr)\n{\n    int32 return_code;\n\n    return_code = OS_SocketBindAddress(sock_id, Addr);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_SocketListen(sock_id);\n        if (return_code == OS_ERR_INCORRECT_OBJ_TYPE)\n        {\n            /* This one is OK, it happens if the socket is a datagram/connectionless\n             * type that does not need to listen().  For backward compatibility, report\n             * success to the caller.\n             */\n            return_code = OS_SUCCESS;\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nreturn_code = OS_SocketBindAddress(sock_id, Addr);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown fragment as written: OS_SocketBind receives a pointer to a const-qualified type (const OS_SockAddr_t *Addr) and passes Addr to OS_SocketBindAddress without discarding const. This complies with Rule 8.13 provided that OS_SocketBindAddress is declared to accept a pointer to const (e.g. const OS_SockAddr_t *). Specific violation scenario: if OS_SocketBindAddress is declared to take a non-const pointer (OS_SockAddr_t *), then passing Addr would discard the const qualifier and would violate Rule 8.13 \u2014 the correct fix is to change OS_SocketBindAddress to accept a const OS_SockAddr_t * (or otherwise avoid discarding const)."
}