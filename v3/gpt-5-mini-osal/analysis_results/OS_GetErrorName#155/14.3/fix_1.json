{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic inline void OS_CHECK_POINTER(const void *p)\n{\n    /* Intentionally a no-op in this test harness to preserve control flow for logging. */\n    (void)p;\n}\nstatic void log_to_file(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1555.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_GetErrorName(int32 error_num, os_err_name_t *err_name)\n{\n    int32                        return_code;\n    const OS_ErrorTable_Entry_t *Error;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(err_name);\n\n    log_to_file(\"ENTER OS_GetErrorName: error_num=%d, err_name_ptr=%p\", (int)error_num, (void *)err_name);\n\n    Error = OS_GLOBAL_ERROR_NAME_TABLE;\n    log_to_file(\"Searching GLOBAL table at %p, first entry: Number=%d, Name=%p\",\n                (void *)Error,\n                (int)Error[0].Number,\n                (void *)Error[0].Name);\n\n    /* Log evaluation of the controlling expression before entering the loop */\n    log_to_file(\"Evaluate GLOBAL while condition: (Error->Name != NULL)=%s, (Error->Number != error_num)=%s\",\n                (Error->Name != NULL) ? \"true\" : \"false\",\n                (Error->Number != error_num) ? \"true\" : \"false\");\n\n    while (Error->Name != NULL && Error->Number != error_num)\n    {\n        log_to_file(\"GLOBAL loop iterate: current entry addr=%p, Number=%d, Name=%s\",\n                    (void *)Error, (int)Error->Number, (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n        ++Error;\n        log_to_file(\"GLOBAL loop advanced to addr=%p, Number=%d, Name=%p\",\n                    (void *)Error, (int)Error->Number, (void *)Error->Name);\n    }\n\n    log_to_file(\"After GLOBAL search: entry addr=%p, Number=%d, Name=%p\",\n                (void *)Error, (int)Error->Number, (void *)Error->Name);\n\n    if (Error->Number != error_num)\n    {\n        log_to_file(\"Not found in GLOBAL table (expected %d). Switching to IMPL table.\", (int)error_num);\n        Error = OS_IMPL_ERROR_NAME_TABLE;\n        log_to_file(\"Searching IMPL table at %p, first entry: Number=%d, Name=%p\",\n                    (void *)Error,\n                    (int)Error[0].Number,\n                    (void *)Error[0].Name);\n\n        /* Log evaluation of the controlling expression before entering the loop */\n        log_to_file(\"Evaluate IMPL while condition: (Error->Name != NULL)=%s, (Error->Number != error_num)=%s\",\n                    (Error->Name != NULL) ? \"true\" : \"false\",\n                    (Error->Number != error_num) ? \"true\" : \"false\");\n\n        while (Error->Name != NULL && Error->Number != error_num)\n        {\n            log_to_file(\"IMPL loop iterate: current entry addr=%p, Number=%d, Name=%s\",\n                        (void *)Error, (int)Error->Number, (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n            ++Error;\n            log_to_file(\"IMPL loop advanced to addr=%p, Number=%d, Name=%p\",\n                        (void *)Error, (int)Error->Number, (void *)Error->Name);\n        }\n\n        log_to_file(\"After IMPL search: entry addr=%p, Number=%d, Name=%p\",\n                    (void *)Error, (int)Error->Number, (void *)Error->Name);\n    }\n    else\n    {\n        log_to_file(\"Found in GLOBAL table: Number=%d, Name=%s\",\n                    (int)Error->Number,\n                    (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n    }\n\n    if (Error->Number == error_num && Error->Name != NULL)\n    {\n        log_to_file(\"Match found: copying name '%s' into provided buffer\", Error->Name);\n        strncpy(*err_name, Error->Name, sizeof(*err_name) - 1);\n        *err_name[sizeof(*err_name) - 1] = 0;\n        return_code                      = 0; /* OS_SUCCESS */\n    }\n    else\n    {\n        log_to_file(\"No match found. Writing unknown string for error %d\", (int)error_num);\n        snprintf(*err_name, OS_ERROR_NAME_LENGTH, \"OS_UNKNOWN(%d)\", (int)error_num);\n        return_code = -1; /* OS_ERROR */\n    }\n\n    (*err_name)[OS_ERROR_NAME_LENGTH - 1] = '\\0';\n\n    log_to_file(\"EXIT OS_GetErrorName: return_code=%d, resulting_name='%s'\", (int)return_code, (*err_name));\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from /tmp/tmprgd86bny/src/src/os/shared/inc/os-shared-globaldefs.h:37,\n                 from /tmp/tmprgd86bny/src/src/os/shared/inc/os-shared-errors.h:29,\n                 from /tmp/tmprgd86bny/src/src/os/shared/src/osapi-errors.c:47:\n/tmp/tmprgd86bny/src/src/os/inc/osapi-macros.h:106:5: error: expected identifier or '(' before 'if'\n  106 |     if (!(cond))                                                                                            \\\n      |     ^~\n/tmp/tmprgd86bny/src/src/os/shared/inc/os-shared-globaldefs.h:107:31: note: in expansion of macro 'BUGCHECK'\n  107 | #define OS_CHECK_POINTER(ptr) BUGCHECK((ptr) != NULL, OS_INVALID_POINTER)\n      |                               ^~~~~~~~\n/tmp/tmprgd86bny/src/src/os/shared/src/osapi-errors.c:134:20: note: in expansion of macro 'OS_CHECK_POINTER'\n  134 | static inline void OS_CHECK_POINTER(const void *p)\n      |                    ^~~~~~~~~~~~~~~~\n/tmp/tmprgd86bny/src/src/os/shared/src/osapi-errors.c:135:1: error: expected identifier or '(' before '{' token\n  135 | {\n      | ^\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:160: CMakeFiles/osal.dir/src/os/shared/src/osapi-errors.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_GetErrorName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/*\n * Renamed the inline no-op to avoid colliding with the existing OS_CHECK_POINTER macro\n * (which is defined elsewhere as a macro). We must not redefine that macro here;\n * instead use a different name and call it where the original code used OS_CHECK_POINTER.\n */\nstatic inline void OS_Check_Pointer_Local(const void *p)\n{\n    /* Intentionally a no-op in this test harness to preserve control flow for logging. */\n    (void)p;\n}\nstatic void log_to_file(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1555.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_GetErrorName(int32 error_num, os_err_name_t *err_name)\n{\n    int32                        return_code;\n    const OS_ErrorTable_Entry_t *Error;\n\n    /* Check parameters - call the local no-op instead of the macro to avoid redefinition */\n    OS_Check_Pointer_Local(err_name);\n\n    log_to_file(\"ENTER OS_GetErrorName: error_num=%d, err_name_ptr=%p\", (int)error_num, (void *)err_name);\n\n    Error = OS_GLOBAL_ERROR_NAME_TABLE;\n    log_to_file(\"Searching GLOBAL table at %p, first entry: Number=%d, Name=%p\",\n                (void *)Error,\n                (int)Error[0].Number,\n                (void *)Error[0].Name);\n\n    /* Log evaluation of the controlling expression before entering the loop */\n    log_to_file(\"Evaluate GLOBAL while condition: (Error->Name != NULL)=%s, (Error->Number != error_num)=%s\",\n                (Error->Name != NULL) ? \"true\" : \"false\",\n                (Error->Number != error_num) ? \"true\" : \"false\");\n\n    while (Error->Name != NULL && Error->Number != error_num)\n    {\n        log_to_file(\"GLOBAL loop iterate: current entry addr=%p, Number=%d, Name=%s\",\n                    (void *)Error, (int)Error->Number, (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n        ++Error;\n        log_to_file(\"GLOBAL loop advanced to addr=%p, Number=%d, Name=%p\",\n                    (void *)Error, (int)Error->Number, (void *)Error->Name);\n    }\n\n    log_to_file(\"After GLOBAL search: entry addr=%p, Number=%d, Name=%p\",\n                (void *)Error, (int)Error->Number, (void *)Error->Name);\n\n    if (Error->Number != error_num)\n    {\n        log_to_file(\"Not found in GLOBAL table (expected %d). Switching to IMPL table.\", (int)error_num);\n        Error = OS_IMPL_ERROR_NAME_TABLE;\n        log_to_file(\"Searching IMPL table at %p, first entry: Number=%d, Name=%p\",\n                    (void *)Error,\n                    (int)Error[0].Number,\n                    (void *)Error[0].Name);\n\n        /* Log evaluation of the controlling expression before entering the loop */\n        log_to_file(\"Evaluate IMPL while condition: (Error->Name != NULL)=%s, (Error->Number != error_num)=%s\",\n                    (Error->Name != NULL) ? \"true\" : \"false\",\n                    (Error->Number != error_num) ? \"true\" : \"false\");\n\n        while (Error->Name != NULL && Error->Number != error_num)\n        {\n            log_to_file(\"IMPL loop iterate: current entry addr=%p, Number=%d, Name=%s\",\n                        (void *)Error, (int)Error->Number, (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n            ++Error;\n            log_to_file(\"IMPL loop advanced to addr=%p, Number=%d, Name=%p\",\n                        (void *)Error, (int)Error->Number, (void *)Error->Name);\n        }\n\n        log_to_file(\"After IMPL search: entry addr=%p, Number=%d, Name=%p\",\n                    (void *)Error, (int)Error->Number, (void *)Error->Name);\n    }\n    else\n    {\n        log_to_file(\"Found in GLOBAL table: Number=%d, Name=%s\",\n                    (int)Error->Number,\n                    (Error->Name != NULL) ? Error->Name : \"(NULL)\");\n    }\n\n    if (Error->Number == error_num && Error->Name != NULL)\n    {\n        log_to_file(\"Match found: copying name '%s' into provided buffer\", Error->Name);\n        strncpy(*err_name, Error->Name, sizeof(*err_name) - 1);\n        /* Fix precedence: ensure we index into the array pointed to by err_name */\n        (*err_name)[sizeof(*err_name) - 1] = '\\0';\n        return_code                      = 0; /* OS_SUCCESS */\n    }\n    else\n    {\n        log_to_file(\"No match found. Writing unknown string for error %d\", (int)error_num);\n        snprintf(*err_name, OS_ERROR_NAME_LENGTH, \"OS_UNKNOWN(%d)\", (int)error_num);\n        return_code = -1; /* OS_ERROR */\n    }\n\n    (*err_name)[OS_ERROR_NAME_LENGTH - 1] = '\\0';\n\n    log_to_file(\"EXIT OS_GetErrorName: return_code=%d, resulting_name='%s'\", (int)return_code, (*err_name));\n\n    return return_code;\n}\n",
  "explanation": "The compilation error was caused by a name collision with an existing OS_CHECK_POINTER macro. I avoided redefining that symbol by renaming the local no-op function to OS_Check_Pointer_Local and calling it where the original code used OS_CHECK_POINTER. I also fixed a precedence/ indexing bug: the line that wrote the terminator into the buffer used *err_name[...], which parses incorrectly; I changed it to (*err_name)[...] = '\\0'. No macros were defined, no main was added, and the original OS_GetErrorName logic is preserved."
}