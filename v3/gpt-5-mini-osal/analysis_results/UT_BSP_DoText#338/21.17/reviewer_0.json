{
  "user_message": "An agent A claimed that the following UT_BSP_DoText code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_DoText.\n```c\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling snprintf with the %s format on SegmentName can read past the end of the SegmentName object if that string is not NUL-terminated (or otherwise shorter than expected). For example, if SegmentName points to a fixed-length buffer that was filled without adding a terminating '\\0' (or is derived from non-terminated data), snprintf will keep reading until it finds a NUL elsewhere, resulting in an out-of-bounds read of the object referenced by SegmentName.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n---- UT_BSP_DoText ENTER (MessageType=8) ----\nInitial MsgEnabled=15, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8aa\nsnprintf returned=7\nBuffer (as string) = \"[BEGIN]\"\nBuffer bytes: 5B 42 45 47 49 4E 5D 00 01 00 00 00 04 00 00 00\nOutputMessage ptr=0x5582a113fee9, MsgLen=9\nOutputMessage bytes: 55 4E 49 54 20 54 45 53 54\n---- UT_BSP_DoText EXIT (MessageType=8) ----\n\n---- UT_BSP_DoText ENTER (MessageType=8) ----\nInitial MsgEnabled=15, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8aa\nsnprintf returned=7\nBuffer (as string) = \"[BEGIN]\"\nBuffer bytes: 5B 42 45 47 49 4E 5D 00 E8 3A 14 A1 82 55 00 00\nOutputMessage ptr=0x7ffcb56bbef0, MsgLen=8\nOutputMessage bytes: 30 31 20 53 45 54 55 50\n---- UT_BSP_DoText EXIT (MessageType=8) ----\n\n---- UT_BSP_DoText ENTER (MessageType=9) ----\nInitial MsgEnabled=7, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8b0\nsnprintf returned=7\nBuffer (as string) = \"[  END]\"\nBuffer bytes: 5B 20 20 45 4E 44 5D 00 C5 9B 13 A1 00 00 00 00\nOutputMessage ptr=0x5582a113f878, MsgLen=14\nOutputMessage bytes: 4E 6F 20 74 65 73 74 20 63 61 73 65 73 0A\n---- UT_BSP_DoText EXIT (MessageType=9) ----\n\n---- UT_BSP_DoText ENTER (MessageType=8) ----\nInitial MsgEnabled=15, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8aa\nsnprintf returned=7\nBuffer (as string) = \"[BEGIN]\"\nBuffer bytes: 5B 42 45 47 49 4E 5D 00 29 AE 13 A1 82 55 00 00\nOutputMessage ptr=0x7ffcb56bbec0, MsgLen=33\nOutputMessage bytes: 30 31 20 4F 53 5F 56 78 57 6F 72 6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 6C 5F 49 6E 69 74\n---- UT_BSP_DoText EXIT (MessageType=8) ----\n\n---- UT_BSP_DoText ENTER (MessageType=11) ----\nInitial MsgEnabled=1, Initial TermModeBits=0x0\nPost-switch TermModeBits=0xA\nCaseTypeAbbrev ptr=0x5582a113f8b4\nsnprintf returned=7\nBuffer (as string) = \"[ PASS]\"\nBuffer bytes: 5B 20 50 41 53 53 5D 00 00 86 25 2E 87 2C DA 2C\nOutputMessage ptr=0x7ffcb56bbbc0, MsgLen=96\nOutputMessage bytes: 30 31 2E 30 30 31 20 63 6F 76 65 72 61 67 65 74 65 73 74 2D 62 69 6E 73 65 6D 2E 63 3A 34 32 20 2D 20 55 54 5F 43 61 6C 6C 5F 4F 53 5F 56 78 57 6F 72 6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 ... (truncated)\n---- UT_BSP_DoText EXIT (MessageType=11) ----\n\n---- UT_BSP_DoText ENTER (MessageType=10) ----\nInitial MsgEnabled=3, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8b9\nsnprintf returned=7\nBuffer (as string) = \"[ INFO]\"\nBuffer bytes: 5B 20 49 4E 46 4F 5D 00 61 4F 13 A1 82 55 00 00\nOutputMessage ptr=0x7ffcb56bbe30, MsgLen=82\nOutputMessage bytes: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 41 42 4F 52 54 3A 3A 30 20 20 20 20 20 57 41 52 4E 3A 3A 30 20 20 20 20 20 46 4C 4F 57 3A 3A 30 20 20 20 20 20 44 45 42 55 ... (truncated)\n---- UT_BSP_DoText EXIT (MessageType=10) ----\n\n---- UT_BSP_DoText ENTER (MessageType=9) ----\nInitial MsgEnabled=7, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8b0\nsnprintf returned=7\nBuffer (as string) = \"[  END]\"\nBuffer bytes: 5B 20 20 45 4E 44 5D 00 00 00 00 00 00 00 00 00\nOutputMessage ptr=0x7ffcb56bbe30, MsgLen=102\nOutputMessage bytes: 30 31 20 4F 53 5F 56 78 57 6F 72 6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 6C 5F 49 6E 69 74 20 54 4F 54 41 4C 3A 3A 31 20 20 20 20 20 50 41 53 53 3A 3A 31 20 20 20 20 20 46 41 49 4C 3A ... (truncated)\n---- UT_BSP_DoText EXIT (MessageType=9) ----\n\n---- UT_BSP_DoText ENTER (MessageType=8) ----\nInitial MsgEnabled=15, Initial TermModeBits=0x0\nPost-switch TermModeBits=0x0\nCaseTypeAbbrev ptr=0x5582a113f8aa\nsnprintf returned=7\nBuffer (as string) = \"[BEGIN]\"\nBuffer bytes: 5B 42 45 47 49 4E 5D 00 20 20 20 20 20 54 54 46\nOutputMessage ptr=0x7ffcb56bbec0, MsgLen=23\nOutputMessage bytes: 30 32 20 4F 53 5F 42 69 6E 53 65 6D 43 72 65 61 74 65 5F 49 6D 70 6C\n---- UT_BSP_DoText EXIT (MessageType=8) ----\n\n---- UT_BSP_DoText ENTER (MessageType=11) ----\nInitial MsgEnabled=1, Initial TermModeBits=0x0\nPost-switch TermModeBits=0xA\nCaseTypeAbbrev ptr=0x5582a113f8b4\nsnprint\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_BSP_DoText:\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    return AbbrevStr;\n}\n...\nvoid UT_BSP_StartTestSegment(uint32 SegmentNumber, const char *SegmentName)\n{\n    char ReportBuffer[128];\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u %s\", (unsigned int)SegmentNumber, SegmentName);\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, ReportBuffer);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. The specific snprintf that Agent A points to (with \"%s\" on SegmentName) is in UT_BSP_StartTestSegment, not in UT_BSP_DoText. In UT_BSP_DoText the snprintf call uses UtAssert_GetCaseTypeAbbrev(), which returns string literals (always NUL-terminated), so that snprintf cannot overrun the source string. The strlen(OutputMessage) in UT_BSP_DoText would only read out-of-bounds if a caller passed a non-NUL-terminated OutputMessage; however the provided caller UT_BSP_StartTestSegment builds ReportBuffer with snprintf (which guarantees NUL-termination), so in the shown call chain the runtime evidence demonstrates the strings are NUL-terminated. If there is concern about untrusted callers, the real risk is the snprintf(\"%s\") in UT_BSP_StartTestSegment when SegmentName might not be NUL-terminated \u2014 that would be the location of a potential Rule 21.17 violation, not UT_BSP_DoText itself. To be fully defensive, either ensure all callers guarantee NUL-terminated strings or use length-limited formatting (e.g. \"%.*s\") or pass explicit lengths; but as written UT_BSP_DoText does not itself violate 21.17 in the given context."
}