{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic const int32 OS_SUCCESS = 0;\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1683.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging is not possible, fail silently to avoid changing behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', fp);\n    fflush(fp);\n    fclose(fp);\n}\nstatic void probe_log_str_snippet(FILE *fp, const char *label, const char *s)\n{\n    (void)fp; /* silence unused when not used by callers that prefer probe_log only */\n    if (s == NULL)\n    {\n        probe_log(\"%s: (null)\", label);\n        return;\n    }\n\n    /* Print up to 64 characters or until NUL, whichever comes first */\n    char buf[65];\n    size_t len = strnlen(s, sizeof(buf) - 1);\n    if (len > 0)\n    {\n        memcpy(buf, s, len);\n    }\n    buf[len] = '\\0';\n\n    probe_log(\"%s: '%s' (addr=%p, len=%zu)\", label, buf, (const void *)s, (size_t)len);\n}\n\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* Log entry and parameter state */\n    probe_log(\"OS_mv: entered\");\n    probe_log_str_snippet(NULL, \"src\", src);\n    probe_log_str_snippet(NULL, \"dest\", dest);\n    probe_log(\"Note: OS_mv parameters are const-qualified. If the target OS_cp prototype\\n\" \n              \"does not use const (for example: int32 OS_cp(char *src, char *dest);),\\n\"\n              \"then passing these const-qualified pointers would discard the const\\n\"\n              \"qualification at the call site, which is a violation of MISRA C 2023 Rule 8.13.\");\n\n    /* First try rename - this only works if it is on the same filesystem */\n    probe_log(\"OS_mv: calling OS_rename(src, dest)\");\n    return_code = OS_rename(src, dest);\n    probe_log(\"OS_mv: OS_rename returned %d\", (int)return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"OS_mv: OS_rename failed -> will call OS_cp(src, dest)\");\n\n        /* Log the act of calling OS_cp and the state that could show a const-discard\n           if OS_cp were declared without const in its prototype. */\n        probe_log(\"OS_mv: about to call OS_cp with parameters (const-qualified in this translation unit)\");\n        probe_log(\"OS_mv: src addr=%p, dest addr=%p\", (const void *)src, (const void *)dest);\n\n        return_code = OS_cp(src, dest);\n        probe_log(\"OS_mv: OS_cp returned %d\", (int)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            probe_log(\"OS_mv: OS_cp succeeded -> will call OS_remove(src)\");\n            /* Preserve original behavior: remove source after successful copy */\n            OS_remove(src);\n            probe_log(\"OS_mv: OS_remove(src) called (no result captured)\");\n        }\n    }\n\n    probe_log(\"OS_mv: exiting with return_code = %d\", (int)return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from /tmp/tmp6mlxu8d8/src/src/os/shared/inc/os-shared-globaldefs.h:36,\n                 from /tmp/tmp6mlxu8d8/src/src/os/shared/inc/os-shared-file.h:30,\n                 from /tmp/tmp6mlxu8d8/src/src/os/shared/src/osapi-file.c:48:\n/tmp/tmp6mlxu8d8/src/src/os/inc/osapi-error.h:96:41: error: expected identifier or '(' before numeric constant\n   96 | #define OS_SUCCESS                     (0)   /**< @brief Successful execution */\n      |                                         ^\n/tmp/tmp6mlxu8d8/src/src/os/shared/src/osapi-file.c:465:20: note: in expansion of macro 'OS_SUCCESS'\n  465 | static const int32 OS_SUCCESS = 0;\n      |                    ^~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_mv as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1683.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging is not possible, fail silently to avoid changing behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', fp);\n    fflush(fp);\n    fclose(fp);\n}\nstatic void probe_log_str_snippet(FILE *fp, const char *label, const char *s)\n{\n    (void)fp; /* silence unused when not used by callers that prefer probe_log only */\n    if (s == NULL)\n    {\n        probe_log(\"%s: (null)\", label);\n        return;\n    }\n\n    /* Print up to 64 characters or until NUL, whichever comes first */\n    char buf[65];\n    size_t len = strnlen(s, sizeof(buf) - 1);\n    if (len > 0)\n    {\n        memcpy(buf, s, len);\n    }\n    buf[len] = '\\0';\n\n    probe_log(\"%s: '%s' (addr=%p, len=%zu)\", label, buf, (const void *)s, (size_t)len);\n}\n\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* Log entry and parameter state */\n    probe_log(\"OS_mv: entered\");\n    probe_log_str_snippet(NULL, \"src\", src);\n    probe_log_str_snippet(NULL, \"dest\", dest);\n    probe_log(\"Note: OS_mv parameters are const-qualified. If the target OS_cp prototype\\n\" \n              \"does not use const (for example: int32 OS_cp(char *src, char *dest);),\\n\"\n              \"then passing these const-qualified pointers would discard the const\\n\"\n              \"qualification at the call site, which is a violation of MISRA C 2023 Rule 8.13.\");\n\n    /* First try rename - this only works if it is on the same filesystem */\n    probe_log(\"OS_mv: calling OS_rename(src, dest)\");\n    return_code = OS_rename(src, dest);\n    probe_log(\"OS_mv: OS_rename returned %d\", (int)return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"OS_mv: OS_rename failed -> will call OS_cp(src, dest)\");\n\n        /* Log the act of calling OS_cp and the state that could show a const-discard\n           if OS_cp were declared without const in its prototype. */\n        probe_log(\"OS_mv: about to call OS_cp with parameters (const-qualified in this translation unit)\");\n        probe_log(\"OS_mv: src addr=%p, dest addr=%p\", (const void *)src, (const void *)dest);\n\n        return_code = OS_cp(src, dest);\n        probe_log(\"OS_mv: OS_cp returned %d\", (int)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            probe_log(\"OS_mv: OS_cp succeeded -> will call OS_remove(src)\");\n            /* Preserve original behavior: remove source after successful copy */\n            OS_remove(src);\n            probe_log(\"OS_mv: OS_remove(src) called (no result captured)\");\n        }\n    }\n\n    probe_log(\"OS_mv: exiting with return_code = %d\", (int)return_code);\n    return return_code;\n}\n",
  "explanation": "The compilation error was caused by a duplicate definition of OS_SUCCESS in this translation unit while OS_SUCCESS is already defined as a macro in included headers. I removed the conflicting line \"static const int32 OS_SUCCESS = 0;\" so the code uses the existing OS_SUCCESS macro from the project's headers. No other logic was changed; the behavior of OS_mv and the logging helpers is preserved."
}