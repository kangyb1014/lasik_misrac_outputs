{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1689.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(__STDC_LIB_EXT1__)\n    /* Use safer localtime_s if available */\n    localtime_s(&tm_buf, &t);\n#else\n    /* Fallback - this is used only for logging */\n    struct tm *tmp = localtime(&t);\n    if (tmp != NULL)\n    {\n        tm_buf = *tmp;\n    }\n    else\n    {\n        memset(&tm_buf, 0, sizeof(tm_buf));\n    }\n#endif\n\n    fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n            tm_buf.tm_year + 1900,\n            tm_buf.tm_mon + 1,\n            tm_buf.tm_mday,\n            tm_buf.tm_hour,\n            tm_buf.tm_min,\n            tm_buf.tm_sec);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic size_t safe_strnlen(const char *s, size_t max_scan)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n\n    const void *p = memchr(s, 0, max_scan);\n    if (p == NULL)\n    {\n        /* Null not found within max_scan; report max_scan to indicate\n         * a potentially unterminated or longer string (useful for\n         * reproducing out-of-bounds scan scenarios). */\n        return max_scan;\n    }\n\n    return (size_t)((const char *)p - s);\n}\n\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* Log entry and basic state of inputs. We log pointer values and a\n     * conservative bounded length/sample of the strings so other agents\n     * can reason about possible out-of-bounds scans in downstream code. */\n    log_probe(\"OS_mv ENTER: src=%p dest=%p\", (void *)src, (void *)dest);\n\n    /* Use a conservative scan limit for logging to avoid overly-large\n     * reads while still providing useful evidence. */\n    const size_t LOG_SCAN_LIMIT = 1024U;\n    size_t src_len = safe_strnlen(src, LOG_SCAN_LIMIT);\n    size_t dest_len = safe_strnlen(dest, LOG_SCAN_LIMIT);\n\n    /* Log lengths discovered (or the scan limit if the NUL wasn't found).\n     * Also log a short sample of the content for easier reproduction. */\n    log_probe(\"OS_mv INPUTS: src_len=%zu dest_len=%zu\", src_len, dest_len);\n\n    /* Log up to 64 characters of each string (or the full discovered\n     * length if smaller). This helps reproduce cases where the separator\n     * '/' location and subsequent pointer arithmetic might lead to\n     * out-of-bounds memchr scans in other functions. */\n    {\n        char sample[65];\n        size_t n = (src_len < 64U) ? src_len : 64U;\n        if (src != NULL && n > 0)\n        {\n            memcpy(sample, src, n);\n        }\n        sample[n] = '\\0';\n        log_probe(\"OS_mv SRC_SAMPLE(len=%zu): %s\", n, sample);\n\n        n = (dest_len < 64U) ? dest_len : 64U;\n        if (dest != NULL && n > 0)\n        {\n            memcpy(sample, dest, n);\n        }\n        sample[n] = '\\0';\n        log_probe(\"OS_mv DEST_SAMPLE(len=%zu): %s\", n, sample);\n    }\n\n    /* First try rename - this only works if it is on the same filesystem */\n    return_code = OS_rename(src, dest);\n    log_probe(\"OS_mv: OS_rename returned %d\", (int)return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        log_probe(\"OS_mv: rename failed, attempting copy (OS_cp)\");\n\n        return_code = OS_cp(src, dest);\n        log_probe(\"OS_mv: OS_cp returned %d\", (int)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            log_probe(\"OS_mv: copy succeeded, calling OS_remove on src=%p\", (void *)src);\n            OS_remove(src);\n            log_probe(\"OS_mv: OS_remove called for src=%p\", (void *)src);\n        }\n        else\n        {\n            log_probe(\"OS_mv: copy failed; src=%p dest=%p\", (void *)src, (void *)dest);\n        }\n    }\n    else\n    {\n        log_probe(\"OS_mv: rename succeeded; no copy/remove necessary\");\n    }\n\n    log_probe(\"OS_mv EXIT: return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpq1mzzqep/src/src/os/shared/src/osapi-file.c: In function 'log_probe':\n/tmp/tmpq1mzzqep/src/src/os/shared/src/osapi-file.c:475:15: error: storage size of 'tm_buf' isn't known\n  475 |     struct tm tm_buf;\n      |               ^~~~~~\n/tmp/tmpq1mzzqep/src/src/os/shared/src/osapi-file.c:484:18: error: invalid use of undefined type 'struct tm'\n  484 |         tm_buf = *tmp;\n      |                  ^\n/tmp/tmpq1mzzqep/src/src/os/shared/src/osapi-file.c:502:22: note: expected '__va_list_tag *' but argument is of type 'OCS_va_list'\n  502 |     vfprintf(f, fmt, ap);\n      |                      ^~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-file.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-file.dir/__/__/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:3601: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-file.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_mv as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Minimal type and constant declarations so this translation unit compiles.\n * These are declarations only (no mock implementations), preserving the\n * original logic which expects these symbols to be provided elsewhere. */\ntypedef int32_t int32;\nint32 OS_rename(const char *src, const char *dest);\nint32 OS_cp(const char *src, const char *dest);\nint32 OS_remove(const char *path);\n\n/* Provide a compile-time constant for success so code can compare to it. */\nenum { OS_SUCCESS = 0 };\n\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1689.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(__STDC_LIB_EXT1__)\n    /* Use safer localtime_s if available */\n    localtime_s(&tm_buf, &t);\n#else\n    /* Fallback - this is used only for logging */\n    struct tm *tmp = localtime(&t);\n    if (tmp != NULL)\n    {\n        tm_buf = *tmp;\n    }\n    else\n    {\n        memset(&tm_buf, 0, sizeof(tm_buf));\n    }\n#endif\n\n    fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \",\n            tm_buf.tm_year + 1900,\n            tm_buf.tm_mon + 1,\n            tm_buf.tm_mday,\n            tm_buf.tm_hour,\n            tm_buf.tm_min,\n            tm_buf.tm_sec);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic size_t safe_strnlen(const char *s, size_t max_scan)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n\n    const void *p = memchr(s, 0, max_scan);\n    if (p == NULL)\n    {\n        /* Null not found within max_scan; report max_scan to indicate\n         * a potentially unterminated or longer string (useful for\n         * reproducing out-of-bounds scan scenarios). */\n        return max_scan;\n    }\n\n    return (size_t)((const char *)p - s);\n}\n\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* Log entry and basic state of inputs. We log pointer values and a\n     * conservative bounded length/sample of the strings so other agents\n     * can reason about possible out-of-bounds scans in downstream code. */\n    log_probe(\"OS_mv ENTER: src=%p dest=%p\", (void *)src, (void *)dest);\n\n    /* Use a conservative scan limit for logging to avoid overly-large\n     * reads while still providing useful evidence. */\n    const size_t LOG_SCAN_LIMIT = 1024U;\n    size_t src_len = safe_strnlen(src, LOG_SCAN_LIMIT);\n    size_t dest_len = safe_strnlen(dest, LOG_SCAN_LIMIT);\n\n    /* Log lengths discovered (or the scan limit if the NUL wasn't found).\n     * Also log a short sample of the content for easier reproduction. */\n    log_probe(\"OS_mv INPUTS: src_len=%zu dest_len=%zu\", src_len, dest_len);\n\n    /* Log up to 64 characters of each string (or the full discovered\n     * length if smaller). This helps reproduce cases where the separator\n     * '/' location and subsequent pointer arithmetic might lead to\n     * out-of-bounds memchr scans in other functions. */\n    {\n        char sample[65];\n        size_t n = (src_len < 64U) ? src_len : 64U;\n        if (src != NULL && n > 0)\n        {\n            memcpy(sample, src, n);\n        }\n        sample[n] = '\\0';\n        log_probe(\"OS_mv SRC_SAMPLE(len=%zu): %s\", n, sample);\n\n        n = (dest_len < 64U) ? dest_len : 64U;\n        if (dest != NULL && n > 0)\n        {\n            memcpy(sample, dest, n);\n        }\n        sample[n] = '\\0';\n        log_probe(\"OS_mv DEST_SAMPLE(len=%zu): %s\", n, sample);\n    }\n\n    /* First try rename - this only works if it is on the same filesystem */\n    return_code = OS_rename(src, dest);\n    log_probe(\"OS_mv: OS_rename returned %d\", (int)return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        log_probe(\"OS_mv: rename failed, attempting copy (OS_cp)\");\n\n        return_code = OS_cp(src, dest);\n        log_probe(\"OS_mv: OS_cp returned %d\", (int)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            log_probe(\"OS_mv: copy succeeded, calling OS_remove on src=%p\", (void *)src);\n            OS_remove(src);\n            log_probe(\"OS_mv: OS_remove called for src=%p\", (void *)src);\n        }\n        else\n        {\n            log_probe(\"OS_mv: copy failed; src=%p dest=%p\", (void *)src, (void *)dest);\n        }\n    }\n    else\n    {\n        log_probe(\"OS_mv: rename succeeded; no copy/remove necessary\");\n    }\n\n    log_probe(\"OS_mv EXIT: return_code=%d\", (int)return_code);\n    return return_code;\n}\n",
  "explanation": "Fixed by adding the necessary standard headers (<stdio.h>, <stdarg.h>, <time.h>, <string.h>, <stdint.h>, <stddef.h>) so struct tm and va_list are fully defined. Declared the external OS_* functions and an int32 typedef (matching common usage) so the unit compiles without providing mock implementations. Provided an enum constant OS_SUCCESS so comparisons compile. No logic of OS_mv was changed."
}