{
  "user_message": "An agent A claimed that the following OS_mv code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_mv.\n```c\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* First try rename - this only works if it is on the same filesystem */\n    return_code = OS_rename(src, dest);\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_cp(src, dest);\n        if (return_code == OS_SUCCESS)\n        {\n            OS_remove(src);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nOS_TranslatePath calls OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) after only checking that VirtualPath is non-NULL. If a caller passes a pointer to a char object that is smaller than OS_MAX_PATH_LEN and does not contain a NUL within that object (e.g. a two\u2011byte buffer with no terminator), OS_strnlen may attempt to read up to OS_MAX_PATH_LEN bytes and thus access memory beyond the bounds of the object. Example: char *p = malloc(2); p[0]='a'; /* no NUL */ OS_TranslatePath(p, buf); \u2014 OS_strnlen will scan past the allocated 2 bytes and can read out-of-bounds.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_mv:\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n...\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n    }\n\n    return return_code;\n}\n...\nint32 OS_remove(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRemove_Impl(local_path);\n    }\n\n    return return_code;\n}\n...\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_FileRename_Impl(const char *old_path, const char *new_path)\n{\n    if (rename(old_path, new_path) < 0)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_FileRemove_Impl(const char *local_path)\n{\n    if (remove(local_path) < 0)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_read(osal_id_t filedes, void *buffer, size_t nbytes)\n{\n    return OS_TimedRead(filedes, buffer, nbytes, OS_PEND);\n}\n...\nint32 OS_write(osal_id_t filedes, const void *buffer, size_t nbytes)\n{\n    return OS_TimedWrite(filedes, buffer, nbytes, OS_PEND);\n}\n...\nint32 OS_close(osal_id_t filedes)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_GenericClose_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n...\nstatic inline bool OS_ObjectIdDefined(osal_id_t object_id)\n{\n    return (OS_ObjectIdToInteger(object_id) != 0);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. OS_mv itself does not call any string.h functions, but it calls OS_rename/OS_remove/OS_OpenCreate which call OS_TranslatePath. OS_TranslatePath calls OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) (and later memchr(name_ptr, 0, OS_MAX_FILE_NAME) and memcpy using lengths derived from those results) after only checking that VirtualPath is non-NULL. If a caller passes a pointer to a character object that is smaller than OS_MAX_PATH_LEN and that object does not contain a NUL within its bounds (for example a two\u2011byte buffer with no terminator), OS_strnlen may attempt to read up to OS_MAX_PATH_LEN bytes and thus read past the bounds of the object. That is exactly the kind of out\u2011of\u2011bounds access MISRA C 2023 Rule 21.17 is intended to forbid, so the reported violation is valid."
}