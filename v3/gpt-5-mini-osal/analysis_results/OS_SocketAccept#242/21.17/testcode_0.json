{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe function calls memchr(s, 0, maxlen) which may read up to maxlen bytes from s. If a caller passes a maxlen larger than the actual size of the object pointed to by s (e.g. char buf[10]; but OS_strnlen(buf, 20) and the buffer contains no '\\0' in the first 10 bytes), memchr will read past the end of buf and thus access beyond the bounds of the object.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SocketAccept code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2429.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SocketAccept as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SocketAccept:\n```c\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SocketAccept code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\nstatic void OS_Accept_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f)\n        return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Entry log */\n    OS_Accept_Log(\"OS_SocketAccept ENTRY: sock_id=%llu, connsock_id_ptr=%p, Addr_ptr=%p, timeout=%d\",\n                  (unsigned long long)sock_id, (void *)connsock_id, (void *)Addr, (int)timeout);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    OS_Accept_Log(\"OS_ObjectIdGetById returned %d (sock_id=%llu)\", return_code, (unsigned long long)sock_id);\n\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        /* Log key state values read from the socket record */\n        OS_Accept_Log(\"Got sock_record=%p, sock=%p, sock->socket_type=%d, sock->socket_domain=%d, sock->stream_state=0x%08x\",\n                      (void *)sock_record, (void *)sock,\n                      (int)(sock ? sock->socket_type : -1),\n                      (int)(sock ? sock->socket_domain : -1),\n                      (unsigned int)(sock ? sock->stream_state : 0));\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            OS_Accept_Log(\"Socket type incorrect: expected STREAM, got %d\", (int)sock->socket_type);\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            OS_Accept_Log(\"Socket state incorrect: stream_state=0x%08x\", (unsigned int)sock->stream_state);\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            OS_Accept_Log(\"OS_ObjectIdAllocateNew returned %d\", return_code);\n\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                /* Log after initializing connection record */\n                OS_Accept_Log(\"Allocated conn_record=%p, conn=%p, assigned conn->socket_domain=%d, conn->socket_type=%d\",\n                              (void *)conn_record, (void *)conn,\n                              (int)conn->socket_domain, (int)conn->socket_type);\n\n                /* Log that Addr is about to be initialized by the implementation. Do not dereference Addr contents to avoid accidental OOB reads. */\n                OS_Accept_Log(\"Calling OS_SocketAddrInit_Impl with Addr_ptr=%p, socket_domain=%d\",\n                              (void *)Addr, (int)sock->socket_domain);\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                OS_Accept_Log(\"Returned from OS_SocketAddrInit_Impl; now calling OS_SocketAccept_Impl\");\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n                OS_Accept_Log(\"OS_SocketAccept_Impl returned %d\", return_code);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_Accept_Log(\"OS_SocketAccept_Impl succeeded; creating socket name\");\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n\n                    OS_Accept_Log(\"After accept: conn_record=%p, conn->stream_name=%p, conn->stream_state=0x%08x\",\n                                  (void *)conn_record, (void *)conn->stream_name, (unsigned int)conn->stream_state);\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n                OS_Accept_Log(\"OS_ObjectIdFinalizeNew returned %d, connsock_id_ptr=%p\", return_code, (void *)connsock_id);\n\n                if (return_code == OS_SUCCESS && connsock_id != NULL)\n                {\n                    OS_Accept_Log(\"Final connsock_id=%llu\", (unsigned long long)*connsock_id);\n                }\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n        OS_Accept_Log(\"Released sock token\");\n    }\n\n    OS_Accept_Log(\"OS_SocketAccept EXIT: return_code=%d\", return_code);\n\n    return return_code;\n}\n"
}