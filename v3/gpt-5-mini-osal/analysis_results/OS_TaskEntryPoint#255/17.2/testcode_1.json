{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nThe call uses a function pointer (OS_SharedGlobalVars.EventHandler). If this pointer is set to point to OS_NotifyEvent itself (or the supplied handler calls back into OS_NotifyEvent), the call becomes an indirect recursive call (OS_NotifyEvent -> EventHandler -> OS_NotifyEvent), violating MISRA C 2023 Rule 17.2. For example, if an application registers OS_SharedGlobalVars.EventHandler = OS_NotifyEvent or implements EventHandler to call OS_NotifyEvent, infinite indirect recursion can occur.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskEntryPoint code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2556.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskEntryPoint as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskEntryPoint:\n```c\nvoid OS_TaskEntryPoint(osal_id_t task_id)\n{\n    osal_task_entry task_entry;\n\n    if (OS_TaskPrepare(task_id, &task_entry) == OS_SUCCESS)\n    {\n        if (task_entry != NULL)\n        {\n            (*task_entry)();\n        }\n    }\n\n    /* If the function returns, treat as a normal exit and do the proper cleanup */\n    OS_TaskExit();\n}\n```\n</target_code>\nPlease provide the modified OS_TaskEntryPoint code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <time.h>\n\n/* Probe logging helper: append human-readable messages to /tmp/logs/2556.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2556.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* don't interfere with normal operation if logging fails */\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_MSC_VER)\n    localtime_s(&tm_buf, &t);\n#else\n    localtime_r(&t, &tm_buf);\n#endif\n    char timebuf[64];\n    if (strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", &tm_buf) == 0)\n    {\n        timebuf[0] = '\\0';\n    }\n\n    fprintf(f, \"%s - \", timebuf);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\n/*\n * Modified OS_TaskEntryPoint with probes. The original control flow is preserved.\n * Logs:\n *  - entry/exit of OS_TaskEntryPoint\n *  - re-entry detection (possible indirect recursion)\n *  - result of OS_TaskPrepare and the value of task_entry pointer\n *  - before/after calling the task entry function\n */\nvoid OS_TaskEntryPoint(osal_id_t task_id)\n{\n    static int s_reentry_count = 0; /* simple guard to detect recursive re-entry */\n\n    /* Mark entry and detect recursion */\n    s_reentry_count++;\n    probe_log(\"OS_TaskEntryPoint ENTER (reentry_count=%d, task_id_addr=%p)\", s_reentry_count, (void *)&task_id);\n    if (s_reentry_count > 1)\n    {\n        probe_log(\"WARNING: OS_TaskEntryPoint re-entered (possible indirect recursion)\");\n    }\n\n    osal_task_entry task_entry;\n\n    if (OS_TaskPrepare(task_id, &task_entry) == OS_SUCCESS)\n    {\n        probe_log(\"OS_TaskPrepare returned OS_SUCCESS; task_entry ptr=%p\", (void *)task_entry);\n\n        if (task_entry != NULL)\n        {\n            probe_log(\"About to call task_entry() at %p\", (void *)task_entry);\n\n            /* Call the real task entry. Preserve original behavior. */\n            (*task_entry)();\n\n            probe_log(\"Returned from task_entry() at %p\", (void *)task_entry);\n        }\n        else\n        {\n            probe_log(\"task_entry is NULL; no call made\");\n        }\n    }\n    else\n    {\n        probe_log(\"OS_TaskPrepare did not return OS_SUCCESS\");\n    }\n\n    /* Decrement re-entry counter before cleanup/exit so logs remain consistent. */\n    s_reentry_count--;\n    probe_log(\"OS_TaskEntryPoint EXIT (reentry_count=%d)\", s_reentry_count);\n\n    /* If the function returns, treat as a normal exit and do the proper cleanup */\n    OS_TaskExit();\n}\n"
}