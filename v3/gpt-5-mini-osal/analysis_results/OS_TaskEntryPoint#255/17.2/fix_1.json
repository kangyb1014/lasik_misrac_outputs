{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2556.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* don't interfere with normal operation if logging fails */\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_MSC_VER)\n    localtime_s(&tm_buf, &t);\n#else\n    localtime_r(&t, &tm_buf);\n#endif\n    char timebuf[64];\n    if (strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", &tm_buf) == 0)\n    {\n        timebuf[0] = '\\0';\n    }\n\n    fprintf(f, \"%s - \", timebuf);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nvoid OS_TaskEntryPoint(osal_id_t task_id)\n{\n    static int s_reentry_count = 0; /* simple guard to detect recursive re-entry */\n\n    /* Mark entry and detect recursion */\n    s_reentry_count++;\n    probe_log(\"OS_TaskEntryPoint ENTER (reentry_count=%d, task_id_addr=%p)\", s_reentry_count, (void *)&task_id);\n    if (s_reentry_count > 1)\n    {\n        probe_log(\"WARNING: OS_TaskEntryPoint re-entered (possible indirect recursion)\");\n    }\n\n    osal_task_entry task_entry;\n\n    if (OS_TaskPrepare(task_id, &task_entry) == OS_SUCCESS)\n    {\n        probe_log(\"OS_TaskPrepare returned OS_SUCCESS; task_entry ptr=%p\", (void *)task_entry);\n\n        if (task_entry != NULL)\n        {\n            probe_log(\"About to call task_entry() at %p\", (void *)task_entry);\n\n            /* Call the real task entry. Preserve original behavior. */\n            (*task_entry)();\n\n            probe_log(\"Returned from task_entry() at %p\", (void *)task_entry);\n        }\n        else\n        {\n            probe_log(\"task_entry is NULL; no call made\");\n        }\n    }\n    else\n    {\n        probe_log(\"OS_TaskPrepare did not return OS_SUCCESS\");\n    }\n\n    /* Decrement re-entry counter before cleanup/exit so logs remain consistent. */\n    s_reentry_count--;\n    probe_log(\"OS_TaskEntryPoint EXIT (reentry_count=%d)\", s_reentry_count);\n\n    /* If the function returns, treat as a normal exit and do the proper cleanup */\n    OS_TaskExit();\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp5p51_6c_/src/src/os/shared/src/osapi-task.c: In function 'probe_log':\n/tmp/tmp5p51_6c_/src/src/os/shared/src/osapi-task.c:143:15: error: storage size of 'tm_buf' isn't known\n  143 |     struct tm tm_buf;\n      |               ^~~~~~\n/tmp/tmp5p51_6c_/src/src/os/shared/src/osapi-task.c:159:22: note: expected '__va_list_tag *' but argument is of type 'OCS_va_list'\n  159 |     vfprintf(f, fmt, ap);\n      |                      ^~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/__/__/os/shared/src/osapi-task.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:4283: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-task.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_TaskEntryPoint as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n\n/*\n * probe_log: lightweight logging used only inside this compilation unit.\n * Uses compiler builtins for va_list to avoid potential typedef mismatches\n * that can occur in some build environments which replace the va_list name.\n */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2556.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* don't interfere with normal operation if logging fails */\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_MSC_VER)\n    localtime_s(&tm_buf, &t);\n#else\n    localtime_r(&t, &tm_buf);\n#endif\n    char timebuf[64];\n    if (strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", &tm_buf) == 0)\n    {\n        timebuf[0] = '\\0';\n    }\n\n    fprintf(f, \"%s - \", timebuf);\n\n    /* Use GCC/Clang builtin va_list type and builtin va_start/va_end to avoid\n     * mismatches with project-specific typedefs of \"va_list\". */\n    __builtin_va_list ap;\n    __builtin_va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    __builtin_va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nvoid OS_TaskEntryPoint(osal_id_t task_id)\n{\n    static int s_reentry_count = 0; /* simple guard to detect recursive re-entry */\n\n    /* Mark entry and detect recursion */\n    s_reentry_count++;\n    probe_log(\"OS_TaskEntryPoint ENTER (reentry_count=%d, task_id_addr=%p)\", s_reentry_count, (void *)&task_id);\n    if (s_reentry_count > 1)\n    {\n        probe_log(\"WARNING: OS_TaskEntryPoint re-entered (possible indirect recursion)\");\n    }\n\n    osal_task_entry task_entry;\n\n    if (OS_TaskPrepare(task_id, &task_entry) == OS_SUCCESS)\n    {\n        probe_log(\"OS_TaskPrepare returned OS_SUCCESS; task_entry ptr=%p\", (void *)task_entry);\n\n        if (task_entry != NULL)\n        {\n            probe_log(\"About to call task_entry() at %p\", (void *)task_entry);\n\n            /* Call the real task entry. Preserve original behavior. */\n            (*task_entry)();\n\n            probe_log(\"Returned from task_entry() at %p\", (void *)task_entry);\n        }\n        else\n        {\n            probe_log(\"task_entry is NULL; no call made\");\n        }\n    }\n    else\n    {\n        probe_log(\"OS_TaskPrepare did not return OS_SUCCESS\");\n    }\n\n    /* Decrement re-entry counter before cleanup/exit so logs remain consistent. */\n    s_reentry_count--;\n    probe_log(\"OS_TaskEntryPoint EXIT (reentry_count=%d)\", s_reentry_count);\n\n    /* If the function returns, treat as a normal exit and do the proper cleanup */\n    OS_TaskExit();\n}\n",
  "explanation": "1) Added necessary standard includes (<stdio.h>, <time.h>, <stdarg.h>) so struct tm and file/time functions are known.\n2) Replaced the plain 'va_list' usage with the compiler builtin '__builtin_va_list' and used '__builtin_va_start' / '__builtin_va_end' to avoid type mismatches in build environments where 'va_list' may be redefined (e.g., to 'OCS_va_list'). This preserves the original logging behavior while ensuring the va_list passed to vfprintf has the expected internal representation.\n3) Kept the original logic of OS_TaskEntryPoint intact (re-entry guarding, calls to OS_TaskPrepare, invoking task_entry, logging, and calling OS_TaskExit)."
}