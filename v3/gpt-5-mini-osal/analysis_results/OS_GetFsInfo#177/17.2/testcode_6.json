{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nIndirect recursion via OS_DEBUG: OS_printf calls OS_DEBUG(\"BUG: ...\", String). If OS_DEBUG is implemented as a wrapper that calls OS_printf (a common implementation), this yields an indirect recursive call path OS_printf -> OS_DEBUG -> OS_printf, violating Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_GetFsInfo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1776.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_GetFsInfo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_GetFsInfo:\n```c\nint32 OS_GetFsInfo(os_fsinfo_t *filesys_info)\n{\n    OS_object_iter_t iter;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filesys_info);\n\n    memset(filesys_info, 0, sizeof(*filesys_info));\n\n    filesys_info->MaxFds     = OS_MAX_NUM_OPEN_FILES;\n    filesys_info->MaxVolumes = OS_MAX_FILE_SYSTEMS;\n\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_STREAM, &iter);\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeFds;\n    }\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_FILESYS, &iter);\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeVolumes;\n    }\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_GetFsInfo code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Probe logging helpers - write diagnostic logs to /tmp/logs/1776.txt */\nstatic FILE *probe_file(void)\n{\n    static FILE *f = NULL;\n    if (f != NULL) return f;\n\n    /* Ensure directory exists (ignore errors) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/1776.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* line buffered to increase chance logs are flushed on abnormal termination */\n        (void)setvbuf(f, NULL, _IOLBF, 0);\n    }\n    return f;\n}\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = probe_file();\n    if (f == NULL) return;\n\n    time_t t = time(NULL);\n    struct tm tmv;\n    (void)localtime_r(&t, &tmv);\n    char timestr[64];\n    (void)strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tmv);\n\n    fprintf(f, \"%s - \", timestr);\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n}\n\n/* Original function preserved, augmented with non-intrusive probes */\nint32 OS_GetFsInfo(os_fsinfo_t *filesys_info)\n{\n    OS_object_iter_t iter;\n\n    probe_log(\"OS_GetFsInfo: entry - filesys_info=%p\", (void *)filesys_info);\n\n    /* Check parameters */\n    probe_log(\"About to call OS_CHECK_POINTER(filesys_info)\");\n    OS_CHECK_POINTER(filesys_info);\n    probe_log(\"Returned from OS_CHECK_POINTER(filesys_info)\");\n\n    memset(filesys_info, 0, sizeof(*filesys_info));\n    probe_log(\"After memset: zeroed filesys_info (size=%zu)\", sizeof(*filesys_info));\n\n    filesys_info->MaxFds     = OS_MAX_NUM_OPEN_FILES;\n    filesys_info->MaxVolumes = OS_MAX_FILE_SYSTEMS;\n    probe_log(\"Set MaxFds=%d MaxVolumes=%d\", (int)filesys_info->MaxFds, (int)filesys_info->MaxVolumes);\n\n    probe_log(\"Initializing iterator for OS_OBJECT_TYPE_OS_STREAM\");\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_STREAM, &iter);\n    probe_log(\"Iterator initialized for streams. Beginning iteration.\");\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeFds;\n        probe_log(\"Iterator stream: incremented FreeFds -> %d\", (int)filesys_info->FreeFds);\n    }\n    probe_log(\"Stream iteration complete. FreeFds=%d\", (int)filesys_info->FreeFds);\n    OS_ObjectIdIteratorDestroy(&iter);\n    probe_log(\"Destroyed stream iterator\");\n\n    probe_log(\"Initializing iterator for OS_OBJECT_TYPE_OS_FILESYS\");\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_FILESYS, &iter);\n    probe_log(\"Iterator initialized for filesystems. Beginning iteration.\");\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeVolumes;\n        probe_log(\"Iterator filesystem: incremented FreeVolumes -> %d\", (int)filesys_info->FreeVolumes);\n    }\n    probe_log(\"Filesystem iteration complete. FreeVolumes=%d\", (int)filesys_info->FreeVolumes);\n    OS_ObjectIdIteratorDestroy(&iter);\n    probe_log(\"Destroyed filesystem iterator\");\n\n    probe_log(\"OS_GetFsInfo: exit - returning OS_SUCCESS (filesys_info=%p, MaxFds=%d, MaxVolumes=%d, FreeFds=%d, FreeVolumes=%d)\",\n              (void *)filesys_info,\n              (int)filesys_info->MaxFds,\n              (int)filesys_info->MaxVolumes,\n              (int)filesys_info->FreeFds,\n              (int)filesys_info->FreeVolumes);\n\n    return OS_SUCCESS;\n}\n"
}