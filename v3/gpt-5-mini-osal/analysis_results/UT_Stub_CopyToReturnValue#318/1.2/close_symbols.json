{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyToReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_GenericReadStub', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_lseek', 'UT_DefaultHandler_OS_IdentifyObject', 'UT_DefaultHandler_OS_QueueGet', 'UT_DefaultHandler_OS_SocketRecvFrom', 'UT_DefaultHandler_OS_SocketSendTo', 'UT_DefaultHandler_OS_TaskGetId', 'UT_DefaultHandler_OS_GetVersionString', 'UT_DefaultHandler_OS_GetVersionCodeName']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_GenericReadStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_read', 'UT_DefaultHandler_OS_TimedRead']}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_lseek': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_IdentifyObject': {'callees': ['UT_Hook_GetArgPtr', 'UT_ObjIdDecompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGet': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'OS_ObjectIdToInteger', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketRecvFrom': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_TaskGetId': {'callees': ['UT_ObjIdCompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionString': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionCodeName': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t",
    "UT_StubTableEntry_t (including nested Data.Buff: TotalSize, BasePtr, Position)",
    "UT_GetStubEntry (declaration/definition)",
    "UT_ENTRYTYPE_RETURN_BUFFER",
    "UtAssert_Abort (declaration/definition)",
    "memcpy (declaration, e.g. <string.h>)",
    "size_t (definition, e.g. <stddef.h>)",
    "NULL (macro definition)"
  ],
  "explanation": "For checking MISRA rule about language extensions we must inspect each symbol that could hide compiler-specific extensions (attributes, asm, __extension__, nonstandard storage-class specifiers, exotic macros, packed/bitfield pragmas, etc.) used by the target function:\n\n- UT_EntryKey_t: The function takes this type as an argument. Its typedef/definition must be checked for any compiler-specific extensions (e.g. unusual qualifiers, nonstandard attributes, packed/aligned macros).\n\n- UT_StubTableEntry_t (including nested Data.Buff: TotalSize, BasePtr, Position): The code dereferences StubPtr and uses members TotalSize, BasePtr and Position. The struct/union definition must be inspected to ensure its member types and any annotations do not use language/compiler extensions (bit-fields with nonstandard widths, packed attributes, compiler-specific annotations on members or the type itself).\n\n- UT_GetStubEntry (declaration/definition): This function is called to obtain the StubPtr. Its prototype/definition must be checked for any nonstandard function attributes or calling-convention extensions (e.g. __attribute__, __stdcall, inline extensions, varargs-like nonstandard declarations) that would violate the MISRA prohibition on language extensions.\n\n- UT_ENTRYTYPE_RETURN_BUFFER: This macro/enum value is passed to UT_GetStubEntry. Its definition may be a macro that expands to compiler-specific tokens or uses extension constructs; confirm it is a simple constant/enumerator.\n\n- UtAssert_Abort (declaration/definition): This is called when sizes mismatch. Inspect its prototype/definition for compiler-specific extensions or macros that expand to extensions (attributes, noreturn annotations using compiler-specific keywords, inline assembly, or nonstandard function signatures).\n\n- memcpy (declaration, e.g. <string.h>): Although a standard library call, its declaration in the available headers could include vendor-specific annotations or attributes. Verify the actual declaration used in the build does not use compiler extensions.\n\n- size_t (definition, e.g. <stddef.h>): Confirm the typedef for size_t in the used headers is a standard typedef and does not employ extensions.\n\n- NULL (macro definition): The code compares StubPtr to NULL. The NULL macro in system headers sometimes uses compiler-specific constructs; check it to ensure no language extension is used.\n\nThese symbols and their definitions cover all types, macros and called functions the target function depends on; examining them will reveal any usage of compiler/language extensions that would cause violation of the MISRA rule."
}