{
  "user_message": "Target function code is:\n```c\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UtTest_AddSubTest': {'callees': ['UtTest_AddCommon'], 'callers': []}, 'UtTest_AddCommon': {'callees': ['UT_BSP_Lock', 'UtList_Add', 'UT_BSP_Unlock'], 'callers': ['UtTest_Add', 'UtTest_AddSetup', 'UtTest_AddTeardown', 'UtTest_AddSubTest']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UtTest_AddCommon",
    "UTASSERT_GROUP_TEST",
    "snprintf",
    "strncmp",
    "UT_BSP_Lock",
    "UtList_Add",
    "UT_BSP_Unlock",
    "<stdio.h>",
    "<string.h>",
    "unit-test framework headers that declare UtTest_AddCommon/UTASSERT_GROUP_TEST"
  ],
  "explanation": "To determine whether the target function uses any compiler language extensions you must inspect any identifiers/macros and declarations that are expanded or referenced in the translation unit: \n\n- UtTest_AddCommon: its prototype/definition (in the unit-test headers/source) may carry compiler-specific attributes or use extensions (e.g. __attribute__, __inline__, __asm__, typeof, extension macros). The caller sees the prototype so any extension in that declaration is relevant. \n\n- UTASSERT_GROUP_TEST: this is a macro/constant passed into the function call. Macros can expand to code that uses compiler extensions; you must inspect its definition to ensure it does not use extensions. \n\n- snprintf and strncmp: these standard-library identifiers are declared in <stdio.h> and <string.h> respectively. In some toolchains they can be implemented as macros or inline wrappers that use compiler-specific extensions (builtins, attributes). Check their declarations/headers in the target environment for any non\u2011standard extensions. \n\n- UT_BSP_Lock, UtList_Add, UT_BSP_Unlock: these are callees of UtTest_AddCommon (from the static call graph). Their declarations/definitions may include extensions (attributes, inline/asm, compiler-specific macros) that can affect compliance; because UtTest_AddCommon is invoked here, any extension in the transitive declarations may be relevant to the compilation unit. \n\n- <stdio.h> and <string.h> (and the unit-test framework headers that declare UtTest_AddCommon/UTASSERT_GROUP_TEST): include the actual declarations and macro definitions that the compiler sees. You must review these header definitions in the target build environment to be sure no language extensions are used.\n\nInspecting these symbols/headers will allow the next agent to determine whether any non\u2011standard compiler extensions are being used (directly in the target function via macros/expanded tokens or indirectly via declarations it relies upon)."
}