{
  "user_message": "An agent A claimed that the following UT_GetStubRetcodeAndCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubRetcodeAndCount.\n```c\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n        Result   = true;\n    }\n    else\n    {\n        Result = false;\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer StubPtr is only used to read fields (StubPtr->Data.Rc.Count and StubPtr->Data.Rc.Value) and is not modified; it should therefore be declared as pointing to a const-qualified type (const UT_StubTableEntry_t *StubPtr). Declaring it as a non-const pointer when no modification is performed violates MISRA C 2023 Rule 8.13. (If the intent is to modify the pointed object later, a non-const pointer would be appropriate; in this snippet it is read-only.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent's claim is correct in the context shown. In this function StubPtr is only used to read fields (no writes to *StubPtr occur), so it can be declared as pointing to a const-qualified type (const UT_StubTableEntry_t *StubPtr). MISRA C 2023 Rule 8.13 recommends that pointers point to const-qualified types whenever possible, so failing to qualify StubPtr as pointer-to-const here is a breach of that guidance.\n\nCaveat: if elsewhere in the surrounding code or API the object pointed to must be modified via this pointer (or the function passes StubPtr to APIs that require a non-const pointer), then declaring it const would be inappropriate; but based solely on the snippet shown, making StubPtr a pointer-to-const is both allowed and preferable (assigning a non-const UT_StubTableEntry_t * to a const UT_StubTableEntry_t * is permitted)."
}