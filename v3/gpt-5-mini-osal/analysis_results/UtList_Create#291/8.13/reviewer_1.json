{
  "user_message": "An agent A claimed that the following UtList_Create code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Create.\n```c\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n    NewList    = (struct ListAllocator *)malloc(ActualSize);\n\n    memset(NewList, 0, ActualSize);\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n    }\n\n    return &NewList->Head;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe member 'Data' is declared as 'void *Data;' which permits modification of the pointed-to object. If the list stores pointers to data that are not intended to be modified through the list (for example pointers to read-only buffers, string literals, or externally-owned objects accessed read-only), then the pointer should be declared as 'const void *Data;'. In that common usage scenario the current declaration violates MISRA C 2023 Rule 8.13 because the pointer is not const-qualified when it could and should be.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x56458f8118a0 ActualSize=144\nUtList_Create: after memset NewList=0x56458f8118a0\nUtList_Create: Head.Tags=0x56458f8118b0 Head.NumberOfTags=4\nUtList_Create: initializing index=0 TagHead=0x56458f8118b0\nUtList_Create: index=0 set Tag=0 Next=0x56458f8118b0 Prev=0x56458f8118b0\nUtList_Create: initializing index=1 TagHead=0x56458f8118d0\nUtList_Create: index=1 set Tag=1 Next=0x56458f8118d0 Prev=0x56458f8118d0\nUtList_Create: initializing index=2 TagHead=0x56458f8118f0\nUtList_Create: index=2 set Tag=2 Next=0x56458f8118f0 Prev=0x56458f8118f0\nUtList_Create: initializing index=3 TagHead=0x56458f811910\nUtList_Create: index=3 set Tag=3 Next=0x56458f811910 Prev=0x56458f811910\nUtList_Create: returning Head=0x56458f8118a0\n\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x5647179698a0 ActualSize=144\nUtList_Create: after memset NewList=0x5647179698a0\nUtList_Create: Head.Tags=0x5647179698b0 Head.NumberOfTags=4\nUtList_Create: initializing index=0 TagHead=0x5647179698b0\nUtList_Create: index=0 set Tag=0 Next=0x5647179698b0 Prev=0x5647179698b0\nUtList_Create: initializing index=1 TagHead=0x5647179698d0\nUtList_Create: index=1 set Tag=1 Next=0x5647179698d0 Prev=0x5647179698d0\nUtList_Create: initializing index=2 TagHead=0x5647179698f0\nUtList_Create: index=2 set Tag=2 Next=0x5647179698f0 Prev=0x5647179698f0\nUtList_Create: initializing index=3 TagHead=0x564717969910\nUtList_Create: index=3 set Tag=3 Next=0x564717969910 Prev=0x564717969910\nUtList_Create: returning Head=0x5647179698a0\n\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x5638204478a0 ActualSize=144\nUtList_Create: after memset NewList=0x5638204478a0\nUtList_Create: Head.Tags=0x5638204478b0 Head.NumberOfTags=4\nUtList_Create: initializing index=0 TagHead=0x5638204478b0\nUtList_Create: index=0 set Tag=0 Next=0x5638204478b0 Prev=0x5638204478b0\nUtList_Create: initializing index=1 TagHead=0x5638204478d0\nUtList_Create: index=1 set Tag=1 Next=0x5638204478d0 Prev=0x5638204478d0\nUtList_Create: initializing index=2 TagHead=0x5638204478f0\nUtList_Create: index=2 set Tag=2 Next=0x5638204478f0 Prev=0x5638204478f0\nUtList_Create: initializing index=3 TagHead=0x563820447910\nUtList_Create: index=3 set Tag=3 Next=0x563820447910 Prev=0x563820447910\nUtList_Create: returning Head=0x5638204478a0\n\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x55ee6e1d38a0 ActualSize=144\nUtList_Create: after memset NewList=0x55ee6e1d38a0\nUtList_Create: Head.Tags=0x55ee6e1d38b0 Head.NumberOfTags=4\nUtList_Create: initializing index=0 TagHead=0x55ee6e1d38b0\nUtList_Create: index=0 set Tag=0 Next=0x55ee6e1d38b0 Prev=0x55ee6e1d38b0\nUtList_Create: initializing index=1 TagHead=0x55ee6e1d38d0\nUtList_Create: index=1 set Tag=1 Next=0x55ee6e1d38d0 Prev=0x55ee6e1d38d0\nUtList_Create: initializing index=2 TagHead=0x55ee6e1d38f0\nUtList_Create: index=2 set Tag=2 Next=0x55ee6e1d38f0 Prev=0x55ee6e1d38f0\nUtList_Create: initializing index=3 TagHead=0x55ee6e1d3910\nUtList_Create: index=3 set Tag=3 Next=0x55ee6e1d3910 Prev=0x55ee6e1d3910\nUtList_Create: returning Head=0x55ee6e1d38a0\n\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x55cecb6528a0 ActualSize=144\nUtList_Create: after memset NewList=0x55cecb6528a0\nUtList_Create: Head.Tags=0x55cecb6528b0 Head.NumberOfTags=4\nUtList_Create: initializing index=0 TagHead=0x55cecb6528b0\nUtList_Create: index=0 set Tag=0 Next=0x55cecb6528b0 Prev=0x55cecb6528b0\nUtList_Create: initializing index=1 TagHead=0x55cecb6528d0\nUtList_Create: index=1 set Tag=1 Next=0x55cecb6528d0 Prev=0x55cecb6528d0\nUtList_Create: initializing index=2 TagHead=0x55cecb6528f0\nUtList_Create: index=2 set Tag=2 Next=0x55cecb6528f0 Prev=0x55cecb6528f0\nUtList_Create: initializing index=3 TagHead=0x55cecb652910\nUtList_Create: index=3 set Tag=3 Next=0x55cecb652910 Prev=0x55cecb652910\nUtList_Create: returning Head=0x55cecb6528a0\n\nUtList_Create: enter NumTags=4\nUtList_Create: allocated NewList=0x5573b5cd68a0 ActualSize=144\nUtList_Create: after memset NewList=0x5573b5cd68a0\nUtList_Create: Head.Tags=0x5573b5cd68b0 Head.NumberOfTag\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Create:\ntypedef struct\n{\n    UtListNode_t *Tags;\n    uint32        NumberOfTags;\n} UtListHead_t\n...\ntypedef struct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    void *                Data;\n    uint32                DataSize;\n    uint32                Tag;\n} UtListNode_t\n...\ntypedef uint32_t  uint32\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A points to UtListNode_t::Data being declared as void * and argues it should be const void * per MISRA C:2023 Rule 8.13. The UtList_Create implementation itself never touches the Data member, but that alone is insufficient to show a rule violation. To claim a breach of 8.13 you must demonstrate that the pointer could be const-qualified across the whole program (i.e. that no code ever modifies the pointed-to object via that pointer). No evidence is provided that Data is only used for read-only access; it may be intended to reference mutable objects and other code may store/modifiy through Data. Therefore the report is not supported by the supplied code and logs. If, in your project, Data is only ever used read\u2011only, then changing it to const void * would satisfy 8.13, but that is a design/visibility decision and not provable from the shown snippets."
}