{
  "user_message": "An agent A claimed that the following UtList_Create code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Create.\n```c\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n    NewList    = (struct ListAllocator *)malloc(ActualSize);\n\n    memset(NewList, 0, ActualSize);\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n    }\n\n    return &NewList->Head;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf malloc fails and returns NULL while ActualSize > 0, the subsequent call memset(NewList, 0, ActualSize) will attempt to write through a NULL pointer (an invalid object), causing an out\u2011of\u2011bounds access of the pointer parameter to memset. The code does not check the return value of malloc before calling memset, so this scenario violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x557a3ab208a0\nCalling memset(ptr=0x557a3ab208a0, size=144)\nAfter memset: NewList=0x557a3ab208a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x5650441d68a0\nCalling memset(ptr=0x5650441d68a0, size=144)\nAfter memset: NewList=0x5650441d68a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55ab841368a0\nCalling memset(ptr=0x55ab841368a0, size=144)\nAfter memset: NewList=0x55ab841368a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55c936fab8a0\nCalling memset(ptr=0x55c936fab8a0, size=144)\nAfter memset: NewList=0x55c936fab8a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55aa2db358a0\nCalling memset(ptr=0x55aa2db358a0, size=144)\nAfter memset: NewList=0x55aa2db358a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55a9e99cb8a0\nCalling memset(ptr=0x55a9e99cb8a0, size=144)\nAfter memset: NewList=0x55a9e99cb8a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x5585f20498a0\nCalling memset(ptr=0x5585f20498a0, size=144)\nAfter memset: NewList=0x5585f20498a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x562a03c918a0\nCalling memset(ptr=0x562a03c918a0, size=144)\nAfter memset: NewList=0x562a03c918a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55c1c1c6f8a0\nCalling memset(ptr=0x55c1c1c6f8a0, size=144)\nAfter memset: NewList=0x55c1c1c6f8a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x555b9dd628a0\nCalling memset(ptr=0x555b9dd628a0, size=144)\nAfter memset: NewList=0x555b9dd628a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55602e2428a0\nCalling memset(ptr=0x55602e2428a0, size=144)\nAfter memset: NewList=0x55602e2428a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x5623de2a08a0\nCalling memset(ptr=0x5623de2a08a0, size=144)\nAfter memset: NewList=0x5623de2a08a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x5640233948a0\nCalling memset(ptr=0x5640233948a0, size=144)\nAfter memset: NewList=0x5640233948a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x559f2ef858a0\nCalling memset(ptr=0x559f2ef858a0, size=144)\nAfter memset: NewList=0x559f2ef858a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x56546d9f28a0\nCalling memset(ptr=0x56546d9f28a0, size=144)\nAfter memset: NewList=0x56546d9f28a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x564f0c68f8a0\nCalling memset(ptr=0x564f0c68f8a0, size=144)\nAfter memset: NewList=0x564f0c68f8a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x5624631248a0\nCalling memset(ptr=0x5624631248a0, size=144)\nAfter memset: NewList=0x5624631248a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x55a0abbf98a0\nCalling memset(ptr=0x55a0abbf98a0, size=144)\nAfter memset: NewList=0x55a0abbf98a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x56262afba8a0\nCalling memset(ptr=0x56262afba8a0, size=144)\nAfter memset: NewList=0x56262afba8a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x56472a1e88a0\nCalling memset(ptr=0x56472a1e88a0, size=144)\nAfter memset: NewList=0x56472a1e88a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nmalloc returned: 0x555da3a968a0\nCalling memset(ptr=0x555da3a968a0, size=144)\nAfter memset: NewList=0x555da3a968a0, Head.Tags=(nil), Head.NumberOfTags=0\nUtList_Create: NumTags=4, ActualSize=144\nma\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Create:\ntypedef struct\n{\n    UtListNode_t *Tags;\n    uint32        NumberOfTags;\n} UtListHead_t\n...\ntypedef struct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    void *                Data;\n    uint32                DataSize;\n    uint32                Tag;\n} UtListNode_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call memset(NewList, 0, ActualSize) can invoke a string.h function with a pointer that may be NULL if malloc fails (malloc can return NULL even when ActualSize > 0). Calling memset with a NULL pointer and a non\u2011zero size is undefined (it attempts to access memory through an invalid pointer) and therefore violates MISRA C 2023 Rule 21.17. To fix this, check the result of malloc before calling memset (or use calloc and still check its return), e.g. if (NewList == NULL) return NULL; or: NewList = calloc(1, ActualSize); if (NewList == NULL) return NULL;"
}