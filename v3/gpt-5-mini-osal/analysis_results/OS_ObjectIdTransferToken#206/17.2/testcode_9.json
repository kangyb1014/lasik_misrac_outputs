{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nPotential indirect recursion via event callbacks: OS_ObjectIdFinalizeNew calls OS_ObjectIdTransactionFinish(...) and then OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED,...). If a registered event handler invoked by OS_NotifyEvent calls an OS API that allocates/deletes objects (e.g. OS_ObjectIdAllocateNew/OS_ObjectIdFinalizeNew or other routine that ultimately calls OS_ObjectIdFinalizeNew), the call chain would be: OS_ObjectIdFinalizeNew -> OS_NotifyEvent -> user_event_handler -> OS_ObjectIdAllocateNew -> OS_ObjectIdFinalizeNew, creating an indirect recursive call to OS_ObjectIdFinalizeNew and thus violating Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdTransferToken code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2066.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdTransferToken as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdTransferToken:\n```c\nvoid OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* start with a simple copy */\n    *token_to = *token_from;\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdTransferToken code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n\n/* Probe logging helper. Appends information to /tmp/logs/2066.txt. */\nstatic void OS_ObjectIdTransferToken_log_probe(const char *stage, const void *token_from, const void *token_to, unsigned long lock_from, unsigned long lock_to)\n{\n    FILE *f = fopen(\"/tmp/logs/2066.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Best-effort logging; fail silently if log can't be opened. */\n        return;\n    }\n\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] %s\\n\", (long)t, stage);\n    fprintf(f, \"  token_from=%p, token_to=%p\\n\", token_from, token_to);\n    fprintf(f, \"  token_from->lock_mode=%lu, token_to->lock_mode=%lu\\n\", lock_from, lock_to);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* Log entry state (do not dereference if pointers are NULL) */\n    unsigned long lock_from_before = 0UL;\n    unsigned long lock_to_before = 0UL;\n\n    if (token_from)\n    {\n        /* read lock_mode for logging only */\n        lock_from_before = (unsigned long)token_from->lock_mode;\n    }\n    if (token_to)\n    {\n        lock_to_before = (unsigned long)token_to->lock_mode;\n    }\n    OS_ObjectIdTransferToken_log_probe(\"ENTER OS_ObjectIdTransferToken - before copy\", (const void *)token_from, (const void *)token_to, lock_from_before, lock_to_before);\n\n    /* start with a simple copy */\n    *token_to = *token_from;\n\n    /* Log after copy, before nullify */\n    unsigned long lock_from_after_copy = 0UL;\n    unsigned long lock_to_after_copy = 0UL;\n    if (token_from)\n    {\n        lock_from_after_copy = (unsigned long)token_from->lock_mode;\n    }\n    if (token_to)\n    {\n        lock_to_after_copy = (unsigned long)token_to->lock_mode;\n    }\n    OS_ObjectIdTransferToken_log_probe(\"AFTER COPY - before nullify\", (const void *)token_from, (const void *)token_to, lock_from_after_copy, lock_to_after_copy);\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n\n    /* Final state logging */\n    unsigned long lock_from_final = 0UL;\n    unsigned long lock_to_final = 0UL;\n    if (token_from)\n    {\n        lock_from_final = (unsigned long)token_from->lock_mode;\n    }\n    if (token_to)\n    {\n        lock_to_final = (unsigned long)token_to->lock_mode;\n    }\n    OS_ObjectIdTransferToken_log_probe(\"EXIT OS_ObjectIdTransferToken - after nullify\", (const void *)token_from, (const void *)token_to, lock_from_final, lock_to_final);\n}\n"
}