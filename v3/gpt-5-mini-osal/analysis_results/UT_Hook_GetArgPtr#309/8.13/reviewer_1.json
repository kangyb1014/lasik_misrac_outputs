{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn the UT_STUBCONTEXT_ARG_TYPE_DIRECT branch the code does Result = &ContextPtr->ArgPtr[i]; ArgPtr is declared as const void * ArgPtr[] so &ContextPtr->ArgPtr[i] has type const void ** (a pointer to the array element, i.e. a pointer to a non-const pointer). That address is being used as a const void * result (losing a level of indirection and referring to an object that itself is not const-qualified). Because the pointer produced points at a non-const-qualified object (the ArgPtr element) instead of a const-qualified target, this violates MISRA C 2023 Rule 8.13. Note also that there is an incompatible pointer type/implicit conversion (const void ** -> const void *) in this assignment.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[UT_Hook_GetArgPtr] stage=entry Context=0x7ffcc348d1a0 i=0 Name=lock_mode ExpectedTypeSize=4\n  MetaPtr=(null)\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=0 Name=lock_mode ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d1f0 Meta.Name=lock_mode Meta.Size=4 Meta.Type=2\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=match_indirect_before_assign Context=0x7ffcc348d1a0 i=0 Name=lock_mode ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d1f0 Meta.Name=lock_mode Meta.Size=4 Meta.Type=2\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=0x7ffcc348d44c\n[UT_Hook_GetArgPtr] stage=match_indirect_after_assign Context=0x7ffcc348d1a0 i=0 Name=lock_mode ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d1f0 Meta.Name=lock_mode Meta.Size=4 Meta.Type=2\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=0x7ffcc348d44c\n[UT_Hook_GetArgPtr] stage=exit Context=0x7ffcc348d1a0 i=0 Name=lock_mode ExpectedTypeSize=4\n  MetaPtr=(null)\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=0x7ffcc348d44c\n[UT_Hook_GetArgPtr] stage=entry Context=0x7ffcc348d1a0 i=0 Name=idtype ExpectedTypeSize=4\n  MetaPtr=(null)\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=0 Name=idtype ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d1f0 Meta.Name=lock_mode Meta.Size=4 Meta.Type=2\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=1 Name=idtype ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d208 Meta.Name=idtype Meta.Size=4 Meta.Type=2\n  ArgPtr[1] value=0x7ffcc348d448 address_of_slot=0x7ffcc348d1b8\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=match_indirect_before_assign Context=0x7ffcc348d1a0 i=1 Name=idtype ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d208 Meta.Name=idtype Meta.Size=4 Meta.Type=2\n  ArgPtr[1] value=0x7ffcc348d448 address_of_slot=0x7ffcc348d1b8\n  ResultCandidate=0x7ffcc348d448\n[UT_Hook_GetArgPtr] stage=match_indirect_after_assign Context=0x7ffcc348d1a0 i=1 Name=idtype ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d208 Meta.Name=idtype Meta.Size=4 Meta.Type=2\n  ArgPtr[1] value=0x7ffcc348d448 address_of_slot=0x7ffcc348d1b8\n  ResultCandidate=0x7ffcc348d448\n[UT_Hook_GetArgPtr] stage=exit Context=0x7ffcc348d1a0 i=0 Name=idtype ExpectedTypeSize=4\n  MetaPtr=(null)\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=0x7ffcc348d448\n[UT_Hook_GetArgPtr] stage=entry Context=0x7ffcc348d1a0 i=0 Name=id ExpectedTypeSize=4\n  MetaPtr=(null)\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=0 Name=id ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d1f0 Meta.Name=lock_mode Meta.Size=4 Meta.Type=2\n  ArgPtr[0] value=0x7ffcc348d44c address_of_slot=0x7ffcc348d1b0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=1 Name=id ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d208 Meta.Name=idtype Meta.Size=4 Meta.Type=2\n  ArgPtr[1] value=0x7ffcc348d448 address_of_slot=0x7ffcc348d1b8\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=iter Context=0x7ffcc348d1a0 i=2 Name=id ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d220 Meta.Name=id Meta.Size=4 Meta.Type=2\n  ArgPtr[2] value=0x7ffcc348d444 address_of_slot=0x7ffcc348d1c0\n  ResultCandidate=(null)\n[UT_Hook_GetArgPtr] stage=match_indirect_before_assign Context=0x7ffcc348d1a0 i=2 Name=id ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d220 Meta.Name=id Meta.Size=4 Meta.Type=2\n  ArgPtr[2] value=0x7ffcc348d444 address_of_slot=0x7ffcc348d1c0\n  ResultCandidate=0x7ffcc348d444\n[UT_Hook_GetArgPtr] stage=match_indirect_after_assign Context=0x7ffcc348d1a0 i=2 Name=id ExpectedTypeSize=4\n  MetaPtr=0x7ffcc348d220 Meta.Name=id Meta.Size=4 Meta.Type=2\n  ArgPtr[2] value=0x7ffcc348d444 address_of_slot=0x7ffcc348d1c0\n  ResultCandidate=0x7ffc\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Hook_GetArgPtr:\ntypedef struct\n{\n    int32                Int32StatusCode;\n    bool                 Int32StatusIsSet;\n    uint32               ArgCount;\n    const void *         ArgPtr[UT_STUBCONTEXT_MAXSIZE];\n    UT_StubArgMetaData_t Meta[UT_STUBCONTEXT_MAXSIZE];\n} UT_StubContext_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's reasoning conflates an incompatible pointer conversion with the intent of MISRA C 2023 Rule 8.13. Rule 8.13 says that pointer types (the type the pointer points at) should be const-qualified where possible. In this code the function result is declared as const void * (i.e. a pointer to const), and the array elements are declared as const void * (i.e. pointers to const). So the declaration-level const-qualification that 8.13 targets is already present.\n\nWhat actually happens in the DIRECT branch is that &ContextPtr->ArgPtr[i] has type const void ** (pointer to an array element whose type is const void *). That expression is being assigned to Result (const void *), which is a mismatched level-of-indirection conversion (const void ** -> const void *). That is an incompatible pointer-type conversion and would be a violation of MISRA rules governing pointer conversions/incompatible pointer types, not of Rule 8.13. In short: the code exhibits an incorrect pointer conversion (and likely violates the MISRA rule(s) about incompatible pointer conversions), but it does not violate Rule 8.13 as claimed by agent A.\n\nRecommendation: fix the incorrect assignment (e.g. return ContextPtr->ArgPtr[i] for the direct case if that is intended, or adjust types and const-qualifiers so the address-of expression has a compatible type) to address the actual MISRA pointer-conversion violation."
}