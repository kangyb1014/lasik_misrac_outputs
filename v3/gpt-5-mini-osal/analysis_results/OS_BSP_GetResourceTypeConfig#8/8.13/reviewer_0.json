{
  "user_message": "An agent A claimed that the following OS_BSP_GetResourceTypeConfig code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_BSP_GetResourceTypeConfig.\n```c\nuint32 OS_BSP_GetResourceTypeConfig(uint32 ResourceType)\n{\n    uint32 ConfigOptionValue;\n\n    if (ResourceType < OS_OBJECT_TYPE_USER)\n    {\n        ConfigOptionValue = OS_BSP_Global.ResoureConfig[ResourceType];\n    }\n    else\n    {\n        ConfigOptionValue = 0;\n    }\n\n    return ConfigOptionValue;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation occurs if OS_BSP_Global.ResoureConfig is declared as a pointer to a non-const type (for example: uint32 *ResoureConfig). In this function the array elements are only read, so the pointer should be to a const-qualified type (const uint32 *ResoureConfig or const uint32 ResoureConfig[]). If ResoureConfig is instead an array of non-const uint32 (i.e. a non-pointer member) or already const-qualified, then Rule 8.13 would not be violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\nENTER: OS_BSP_GetResourceTypeConfig(ResourceType=1)\nOS_OBJECT_TYPE_USER=100\nResoureConfig pointer=0x560a64bbf3a0\nPath: ResourceType < OS_OBJECT_TYPE_USER -> read from ResoureConfig[ResourceType]\nRead: index=1, value=0\nNeighbor[-1] value=0\nNeighbor[+1] value=0\nEXIT: OS_BSP_GetResourceTypeConfig -> return 0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BSP_GetResourceTypeConfig:\nextern OS_BSP_GlobalData_t OS_BSP_Global\n...\ntypedef uint32_t  uint32\n...\n#define OS_OBJECT_TYPE_USER 0x10\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A\u2019s observation is conceptually correct but incomplete. MISRA C 2023 Rule 8.13 concerns pointer declarations: a pointer should point to a const-qualified type whenever possible. The function OS_BSP_GetResourceTypeConfig only reads elements of OS_BSP_Global.ResoureConfig, so there is no reason to require a non-const access here. If OS_BSP_Global.ResoureConfig is declared as a pointer to a non-const type (e.g. uint32 *ResoureConfig) and the pointees are never modified elsewhere, then the declaration could/should be changed to point to const (const uint32 * or const uint32[]), and a static MISRA check would flag the non-const pointer declaration as a Rule 8.13 issue. However, whether a violation actually exists depends on the declaration and the rest of the program: if ResoureConfig is already const-qualified, or if it is an array member (not a pointer), or if the data are legitimately modified elsewhere, then no Rule 8.13 violation applies. Since the provided snippet alone does not show the declaration or usage context, you cannot conclusively say the code violates Rule 8.13. In other words: the agent\u2019s conditional scenario is correct, but you cannot confirm a violation from the shown function alone."
}