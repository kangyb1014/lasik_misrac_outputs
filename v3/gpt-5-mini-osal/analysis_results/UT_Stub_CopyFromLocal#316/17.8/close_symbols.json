{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t (complete struct definition, including Data and Data.Buff sub-structure: BasePtr, Position, TotalSize)",
    "UT_GetStubEntry (prototype/signature and description of side-effects/aliasing, returns UT_StubTableEntry_t *)",
    "UT_ClearStubEntry (prototype/signature and description of side-effects/aliasing)",
    "memcpy (prototype from <string.h>)",
    "UT_EntryKey_t (typedef/underlying type)",
    "UT_ENTRYTYPE_DATA_BUFFER (macro/enum value used as argument)",
    "size_t (typedef from <stddef.h> / underlying type)"
  ],
  "explanation": "For checking the MISRA rule 'A function parameter should not be modified' we need the surrounding type and API information to be sure the code does not alter any parameter variables (not just objects they point to) or rely on hidden aliasing. Explanations:\n\n- UT_StubTableEntry_t: The function writes into fields accessed through the returned StubPtr (e.g., Buff.BasePtr[], Buff.Position, Buff.TotalSize). Knowing the exact struct layout and types (especially whether BasePtr is a pointer, and the types of Position and TotalSize) is necessary to confirm these writes modify the stub table memory, not any function parameter (e.g., not aliasing FuncKey or LocalBuffer). It also shows whether Position/TotalSize are scalars (so increment modifies struct members, not parameters).\n\n- UT_GetStubEntry: The call returns the StubPtr used for subsequent writes. Its prototype and documentation confirm it does not take LocalBuffer or MaxSize as parameters and does not alias or modify those function parameters. That rules out indirect modification of the function parameters via UT_GetStubEntry's behavior.\n\n- UT_ClearStubEntry: The call is provided StubPtr; its prototype/documentation ensures it operates on the stub entry and does not modify any of the UT_Stub_CopyFromLocal parameters (FuncKey, LocalBuffer, MaxSize) via aliasing or side effects.\n\n- memcpy: Knowing the standard prototype (void *memcpy(void *dest, const void *src, size_t n)) confirms that memcpy will not modify the source buffer (LocalBuffer is passed as src) and that it does not change the src pointer value. This helps show that the LocalBuffer object is not modified by memcpy and that the pointer parameter LocalBuffer itself is not being assigned to.\n\n- UT_EntryKey_t: Knowing whether FuncKey is an integer, enum, or pointer type is needed to ensure there is no hidden aliasing or that FuncKey is not a pointer that could be modified indirectly. The function does not assign to FuncKey; confirming its underlying type helps prove compliance.\n\n- UT_ENTRYTYPE_DATA_BUFFER: The literal passed to UT_GetStubEntry helps confirm which entry is returned and that this choice cannot cause aliasing to function parameters.\n\n- size_t: Confirming the type of MaxSize/TotalSize (standard size_t) ensures arithmetic and comparisons operate on ordinary scalar types and that no hidden aliasing or unusual semantics exist.\n\nTogether, these symbols let an analyst determine whether any assignment or side-effect in UT_Stub_CopyFromLocal (direct or via callees) modifies the value of any function parameter (the pointer variables FuncKey, LocalBuffer, MaxSize) rather than only modifying objects they point to or other non-parameter state."
}