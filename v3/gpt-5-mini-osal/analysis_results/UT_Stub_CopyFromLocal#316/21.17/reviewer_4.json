{
  "user_message": "An agent A claimed that the following UT_Stub_CopyFromLocal code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyFromLocal.\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code can underflow and produce a very large ActualCopy, leading memcpy to write beyond the destination buffer. Example: StubPtr->Data.Buff.TotalSize == 100, StubPtr->Data.Buff.Position == 200 (Position > TotalSize), and MaxSize == 500. The subtraction yields ActualCopy = (size_t)(100 - 200) -> very large value; the subsequent if (MaxSize < ActualCopy) sets ActualCopy = 500, then memcpy(&BasePtr[200], LocalBuffer, 500) writes far past the allocated 100-byte buffer. Thus accesses beyond object bounds can occur.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x00005646b71fcb83\nStubPtr: 0x00005646b721db20\nTotalSize: 32\nPosition: 0\nPreliminary ActualCopy (TotalSize - Position): 32\nMaxSize: 32\nBasePtr: 0x00007fff7d00a3a0\nDestination address (&BasePtr[Position]): 0x00007fff7d00a3a0\nLocalBuffer pointer: 0x00007fff7d00a2f0\nAbout to memcpy dest=0x00007fff7d00a3a0 src=0x00007fff7d00a2f0 size=32\nAfter memcpy: ActualCopy used=32\nNew Position: 32\nPosition >= TotalSize => calling UT_ClearStubEntry(StubPtr=0x00005646b721db20)\nUT_ClearStubEntry returned for StubPtr=0x00005646b721db20\n-- UT_Stub_CopyFromLocal exit (ActualCopy=32) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x00005646b71fcb83\nStubPtr: 0x00005646b721db20\nTotalSize: 32\nPosition: 0\nPreliminary ActualCopy (TotalSize - Position): 32\nMaxSize: 32\nBasePtr: 0x00007fff7d00a3a0\nDestination address (&BasePtr[Position]): 0x00007fff7d00a3a0\nLocalBuffer pointer: 0x00007fff7d00a2f0\nAbout to memcpy dest=0x00007fff7d00a3a0 src=0x00007fff7d00a2f0 size=32\nAfter memcpy: ActualCopy used=32\nNew Position: 32\nPosition >= TotalSize => calling UT_ClearStubEntry(StubPtr=0x00005646b721db20)\nUT_ClearStubEntry returned for StubPtr=0x00005646b721db20\n-- UT_Stub_CopyFromLocal exit (ActualCopy=32) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x00005631d4131f2e\nStubPtr: 0x00005631d4152640\nTotalSize: 13\nPosition: 0\nPreliminary ActualCopy (TotalSize - Position): 13\nMaxSize: 13\nBasePtr: 0x00007ffd4c55f0eb\nDestination address (&BasePtr[Position]): 0x00007ffd4c55f0eb\nLocalBuffer pointer: 0x00007ffd4c55f0de\nAbout to memcpy dest=0x00007ffd4c55f0eb src=0x00007ffd4c55f0de size=13\nAfter memcpy: ActualCopy used=13\nNew Position: 13\nPosition >= TotalSize => calling UT_ClearStubEntry(StubPtr=0x00005631d4152640)\nUT_ClearStubEntry returned for StubPtr=0x00005631d4152640\n-- UT_Stub_CopyFromLocal exit (ActualCopy=13) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x00005631d4131f2e\nStubPtr: 0x00005631d4152640\nTotalSize: 13\nPosition: 0\nPreliminary ActualCopy (TotalSize - Position): 13\nMaxSize: 13\nBasePtr: 0x00007ffd4c55f0eb\nDestination address (&BasePtr[Position]): 0x00007ffd4c55f0eb\nLocalBuffer pointer: 0x00007ffd4c55f0de\nAbout to memcpy dest=0x00007ffd4c55f0eb src=0x00007ffd4c55f0de size=13\nAfter memcpy: ActualCopy used=13\nNew Position: 13\nPosition >= TotalSize => calling UT_ClearStubEntry(StubPtr=0x00005631d4152640)\nUT_ClearStubEntry returned for StubPtr=0x00005631d4152640\n-- UT_Stub_CopyFromLocal exit (ActualCopy=13) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x0000558aa75b5dc9\nStubPtr: 0x0000558aa75cde60\nTotalSize: 32\nPosition: 0\nPreliminary ActualCopy (TotalSize - Position): 32\nMaxSize: 4\nBasePtr: 0x00007fff280724d0\nDestination address (&BasePtr[Position]): 0x00007fff280724d0\nLocalBuffer pointer: 0x00007fff280724c0\nMaxSize < ActualCopy: capping ActualCopy from 32 to 4\nAbout to memcpy dest=0x00007fff280724d0 src=0x00007fff280724c0 size=4\nAfter memcpy: ActualCopy used=4\nNew Position: 4\n-- UT_Stub_CopyFromLocal exit (ActualCopy=4) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x0000558aa75b5dc9\nStubPtr: 0x0000558aa75cde60\nTotalSize: 32\nPosition: 4\nPreliminary ActualCopy (TotalSize - Position): 28\nMaxSize: 12\nBasePtr: 0x00007fff280724d0\nDestination address (&BasePtr[Position]): 0x00007fff280724d4\nLocalBuffer pointer: 0x00007fff280724c4\nMaxSize < ActualCopy: capping ActualCopy from 28 to 12\nAbout to memcpy dest=0x00007fff280724d4 src=0x00007fff280724c4 size=12\nAfter memcpy: ActualCopy used=12\nNew Position: 16\n-- UT_Stub_CopyFromLocal exit (ActualCopy=12) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x0000558aa75b5dc9\nStubPtr: 0x0000558aa75cde60\nTotalSize: 32\nPosition: 16\nPreliminary ActualCopy (TotalSize - Position): 16\nMaxSize: 2\nBasePtr: 0x00007fff280724d0\nDestination address (&BasePtr[Position]): 0x00007fff280724e0\nLocalBuffer pointer: 0x00007fff280724c0\nMaxSize < ActualCopy: capping ActualCopy from 16 to 2\nAbout to memcpy dest=0x00007fff280724e0 src=0x00007fff280724c0 size=2\nAfter memcpy: ActualCopy used=2\nNew Position: 18\n-- UT_Stub_CopyFromLocal exit (ActualCopy=2) --\n\n-- UT_Stub_CopyFromLocal entry --\nFuncKey: 0x00\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyFromLocal:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UT_Stub_CopyFromLocal computes ActualCopy as StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position using size_t (unsigned). If Position > TotalSize this subtraction underflows to a very large value. The code only caps ActualCopy against MaxSize, which may still be larger than the remaining space in the destination buffer, so memcpy(&BasePtr[Position], LocalBuffer, ActualCopy) can copy past the allocated buffer and thus violate MISRA C 2023 Rule 21.17. The function lacks a check that Position <= TotalSize (or otherwise guards against the unsigned underflow) before using the result as the memcpy size. A simple fix is to ensure ActualCopy is set to 0 when Position >= TotalSize (or to compute ActualCopy only when Position < TotalSize), or to otherwise validate/cap ActualCopy against the actual remaining buffer size before calling memcpy."
}