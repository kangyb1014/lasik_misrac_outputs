{
  "user_message": "An agent A claimed that the following UT_Stub_CopyFromLocal code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyFromLocal.\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. If StubPtr->Data.Buff.Position is greater than StubPtr->Data.Buff.TotalSize (for example due to corruption or lack of prior validation), the subtraction ActualCopy = TotalSize - Position will underflow (size_t wrap) producing a very large value. If MaxSize is smaller than that large value, ActualCopy becomes MaxSize which can still exceed the actual remaining space in BasePtr, so the subsequent memcpy(&BasePtr[Position], LocalBuffer, ActualCopy) can write past the bounds of BasePtr. The following update StubPtr->Data.Buff.Position += ActualCopy can also overflow/wrap and leave Position beyond the buffer bounds. Therefore the use of memcpy in this sequence can result in accesses beyond the bounds of the object and violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94167064496729, LocalBuffer=0x55a4fa6ea008, MaxSize=7\nNo stub entry found for FuncKey=94167064496729\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94167064496729, LocalBuffer=0x55a4fa6ea008, MaxSize=7\nNo stub entry found for FuncKey=94167064496729\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94704697376562, LocalBuffer=0x7ffdf08251d0, MaxSize=72\nNo stub entry found for FuncKey=94704697376562\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94704697376562, LocalBuffer=0x7ffdf08251d0, MaxSize=72\nNo stub entry found for FuncKey=94704697376562\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94704697376562, LocalBuffer=0x7ffdf0824e90, MaxSize=72\nNo stub entry found for FuncKey=94704697376562\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94578038856611, LocalBuffer=0x7ffc9f5010d0, MaxSize=32\nStub found: BasePtr=0x7ffc9f501180, Position=0, TotalSize=32\nComputed ActualCopy (before clamp) = 32\nActualCopy remains = 32\nAbout to memcpy dest=0x7ffc9f501180, src=0x7ffc9f5010d0, n=32; BufferBase=0x7ffc9f501180, Position=0, TotalSize=32\nmemcpy completed: wrote 32 bytes to BasePtr at offset 0\nUpdated Position = 32 (after adding 32)\nPosition >= TotalSize (32 >= 32): clearing stub entry\nUT_Stub_CopyFromLocal EXIT: ActualCopy=32\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94578038856611, LocalBuffer=0x7ffc9f5010d0, MaxSize=32\nStub found: BasePtr=0x7ffc9f501180, Position=0, TotalSize=32\nComputed ActualCopy (before clamp) = 32\nActualCopy remains = 32\nAbout to memcpy dest=0x7ffc9f501180, src=0x7ffc9f5010d0, n=32; BufferBase=0x7ffc9f501180, Position=0, TotalSize=32\nmemcpy completed: wrote 32 bytes to BasePtr at offset 0\nUpdated Position = 32 (after adding 32)\nPosition >= TotalSize (32 >= 32): clearing stub entry\nUT_Stub_CopyFromLocal EXIT: ActualCopy=32\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94578038856611, LocalBuffer=0x7ffc9f501130, MaxSize=32\nNo stub entry found for FuncKey=94578038856611\nUT_Stub_CopyFromLocal EXIT: ActualCopy=0\nUT_Stub_CopyFromLocal ENTRY: FuncKey=93949947416398, LocalBuffer=0x7ffe85b38b4e, MaxSize=13\nStub found: BasePtr=0x7ffe85b38b5b, Position=0, TotalSize=13\nComputed ActualCopy (before clamp) = 13\nActualCopy remains = 13\nAbout to memcpy dest=0x7ffe85b38b5b, src=0x7ffe85b38b4e, n=13; BufferBase=0x7ffe85b38b5b, Position=0, TotalSize=13\nmemcpy completed: wrote 13 bytes to BasePtr at offset 0\nUpdated Position = 13 (after adding 13)\nPosition >= TotalSize (13 >= 13): clearing stub entry\nUT_Stub_CopyFromLocal EXIT: ActualCopy=13\nUT_Stub_CopyFromLocal ENTRY: FuncKey=93949947416398, LocalBuffer=0x7ffe85b38b4e, MaxSize=13\nStub found: BasePtr=0x7ffe85b38b5b, Position=0, TotalSize=13\nComputed ActualCopy (before clamp) = 13\nActualCopy remains = 13\nAbout to memcpy dest=0x7ffe85b38b5b, src=0x7ffe85b38b4e, n=13; BufferBase=0x7ffe85b38b5b, Position=0, TotalSize=13\nmemcpy completed: wrote 13 bytes to BasePtr at offset 0\nUpdated Position = 13 (after adding 13)\nPosition >= TotalSize (13 >= 13): clearing stub entry\nUT_Stub_CopyFromLocal EXIT: ActualCopy=13\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94411311345129, LocalBuffer=0x7fff47fa49c0, MaxSize=4\nStub found: BasePtr=0x7fff47fa49d0, Position=0, TotalSize=32\nComputed ActualCopy (before clamp) = 32\nClamped ActualCopy to MaxSize = 4\nAbout to memcpy dest=0x7fff47fa49d0, src=0x7fff47fa49c0, n=4; BufferBase=0x7fff47fa49d0, Position=0, TotalSize=32\nmemcpy completed: wrote 4 bytes to BasePtr at offset 0\nUpdated Position = 4 (after adding 4)\nPosition < TotalSize (4 < 32): leaving stub entry intact\nUT_Stub_CopyFromLocal EXIT: ActualCopy=4\nUT_Stub_CopyFromLocal ENTRY: FuncKey=94411311345129, LocalBuffer=0x7fff47fa49c4, MaxSize=12\nStub found: BasePtr=0x7fff47fa49d0, Position=4, TotalSize=32\nComputed ActualCopy (before clamp) = 28\nClamped ActualCopy to MaxSize = 12\nAbout to memcpy dest=0x7fff47fa49d4, src=0x7fff47fa49c4, n=12; BufferBase=0x7fff47fa49d0, Position=4, TotalSize=32\nmemcpy completed: wrote 12 bytes to BasePtr at o\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyFromLocal:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function assumes StubPtr->Data.Buff.Position <= StubPtr->Data.Buff.TotalSize, but there is no check enforcing that invariant in this function. If Position > TotalSize then the subtraction TotalSize - Position (both size_t) underflows producing a very large ActualCopy. Even though ActualCopy may then be clamped to MaxSize, the destination pointer &BasePtr[Position] is already computed from an out-of-range index. If Position is greater than the allocated buffer length, memcpy with a non\u2011zero n will attempt to write starting at an address beyond the bounds of BasePtr, which violates MISRA C 2023 Rule 21.17. The execution log only shows normal (valid) runs and does not prove absence of the problematic condition. To comply with 21.17 the code must validate (e.g.) BasePtr != NULL and that Position <= TotalSize before computing the remaining size, compute remaining = (Position < TotalSize) ? TotalSize - Position : 0, then clamp remaining by MaxSize and only call memcpy when remaining > 0. That prevents underflow and out\u2011of\u2011bounds accesses."
}