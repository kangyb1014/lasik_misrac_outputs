{
  "user_message": "An agent A claimed that the following UT_Stub_CopyFromLocal code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyFromLocal.\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf StubPtr->Data.Buff.Position > StubPtr->Data.Buff.TotalSize the subtraction ActualCopy = TotalSize - Position will underflow (size_t wraparound) producing a very large ActualCopy. The subsequent clamp (if (MaxSize < ActualCopy) ActualCopy = MaxSize;) can still leave ActualCopy larger than the actual remaining space (which is zero when Position > TotalSize). That value is then passed to memcpy, causing writes beyond the destination buffer bounds. Therefore the fragment does not guarantee prevention of out\u2011of\u2011bounds access and can violate Rule 21.17 in this scenario.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CopyFromLocal called: FuncKey=94892383824441, LocalBuffer=0x564ddad54008, MaxSize=7, StubPtr=(nil)\nNo stub entry found for FuncKey=94892383824441\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=94892383824441, LocalBuffer=0x564ddad54008, MaxSize=7, StubPtr=(nil)\nNo stub entry found for FuncKey=94892383824441\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=94517511024402, LocalBuffer=0x7ffdc265ba30, MaxSize=72, StubPtr=(nil)\nNo stub entry found for FuncKey=94517511024402\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=94517511024402, LocalBuffer=0x7ffdc265ba30, MaxSize=72, StubPtr=(nil)\nNo stub entry found for FuncKey=94517511024402\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=94517511024402, LocalBuffer=0x7ffdc265b6f0, MaxSize=72, StubPtr=(nil)\nNo stub entry found for FuncKey=94517511024402\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=93890873019267, LocalBuffer=0x7ffe2cf0a0c0, MaxSize=32, StubPtr=0x5564ac249940\nStub found: TotalSize=32, Position=0, BasePtr=0x7ffe2cf0a170\nAfter subtraction: ActualCopy=32 (TotalSize=32 - Position=0)\nNo clamping required: MaxSize=32, ActualCopy=32\nAbout to memcpy: dest=0x7ffe2cf0a170, src=0x7ffe2cf0a0c0, ActualCopy=32\nmemcpy completed (requested 32 bytes)\nPosition (32) >= TotalSize (32): clearing stub entry\nUT_Stub_CopyFromLocal returning ActualCopy=32\nUT_Stub_CopyFromLocal called: FuncKey=93890873019267, LocalBuffer=0x7ffe2cf0a0c0, MaxSize=32, StubPtr=0x5564ac249940\nStub found: TotalSize=32, Position=0, BasePtr=0x7ffe2cf0a170\nAfter subtraction: ActualCopy=32 (TotalSize=32 - Position=0)\nNo clamping required: MaxSize=32, ActualCopy=32\nAbout to memcpy: dest=0x7ffe2cf0a170, src=0x7ffe2cf0a0c0, ActualCopy=32\nmemcpy completed (requested 32 bytes)\nPosition (32) >= TotalSize (32): clearing stub entry\nUT_Stub_CopyFromLocal returning ActualCopy=32\nUT_Stub_CopyFromLocal called: FuncKey=93890873019267, LocalBuffer=0x7ffe2cf0a120, MaxSize=32, StubPtr=(nil)\nNo stub entry found for FuncKey=93890873019267\nUT_Stub_CopyFromLocal returning ActualCopy=0\nUT_Stub_CopyFromLocal called: FuncKey=93928840666926, LocalBuffer=0x7fffdf2593be, MaxSize=13, StubPtr=0x556d8330bf40\nStub found: TotalSize=13, Position=0, BasePtr=0x7fffdf2593cb\nAfter subtraction: ActualCopy=13 (TotalSize=13 - Position=0)\nNo clamping required: MaxSize=13, ActualCopy=13\nAbout to memcpy: dest=0x7fffdf2593cb, src=0x7fffdf2593be, ActualCopy=13\nmemcpy completed (requested 13 bytes)\nPosition (13) >= TotalSize (13): clearing stub entry\nUT_Stub_CopyFromLocal returning ActualCopy=13\nUT_Stub_CopyFromLocal called: FuncKey=93928840666926, LocalBuffer=0x7fffdf2593be, MaxSize=13, StubPtr=0x556d8330bf40\nStub found: TotalSize=13, Position=0, BasePtr=0x7fffdf2593cb\nAfter subtraction: ActualCopy=13 (TotalSize=13 - Position=0)\nNo clamping required: MaxSize=13, ActualCopy=13\nAbout to memcpy: dest=0x7fffdf2593cb, src=0x7fffdf2593be, ActualCopy=13\nmemcpy completed (requested 13 bytes)\nPosition (13) >= TotalSize (13): clearing stub entry\nUT_Stub_CopyFromLocal returning ActualCopy=13\nUT_Stub_CopyFromLocal called: FuncKey=94522968456649, LocalBuffer=0x7ffe874ef780, MaxSize=4, StubPtr=0x55f7d7f6bea0\nStub found: TotalSize=32, Position=0, BasePtr=0x7ffe874ef790\nAfter subtraction: ActualCopy=32 (TotalSize=32 - Position=0)\nClamping: MaxSize (4) < ActualCopy (32). Setting ActualCopy = MaxSize\nAbout to memcpy: dest=0x7ffe874ef790, src=0x7ffe874ef780, ActualCopy=4\nmemcpy completed (requested 4 bytes)\nPosition after copy: 4 (TotalSize=32)\nUT_Stub_CopyFromLocal returning ActualCopy=4\nUT_Stub_CopyFromLocal called: FuncKey=94522968456649, LocalBuffer=0x7ffe874ef784, MaxSize=12, StubPtr=0x55f7d7f6bea0\nStub found: TotalSize=32, Position=4, BasePtr=0x7ffe874ef790\nAfter subtraction: ActualCopy=28 (TotalSize=32 - Position=4)\nClamping: MaxSize (12) < ActualCopy (28). Setting ActualCopy = MaxSize\nAbout to memcpy: dest=0x7ffe874ef794, src=0x7ffe874ef784, ActualCopy=12\nmemcpy completed (requested 12 by\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyFromLocal:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes ActualCopy = TotalSize - Position without ensuring Position <= TotalSize. If Position > TotalSize the subtraction underflows (size_t wraparound) yielding a very large ActualCopy. The subsequent clamp only limits ActualCopy to MaxSize when MaxSize < ActualCopy, but that does not address the fact that the destination pointer is BasePtr + Position (which already points past the buffer end). For example, TotalSize=10, Position=20 -> ActualCopy becomes (size_t)-10 (huge). If MaxSize=5, ActualCopy is set to 5, and memcpy(BasePtr+20, LocalBuffer, 5) will write beyond the buffer bounds. Therefore the function can cause out-of-bounds accesses via memcpy and violates MISRA C 2023 Rule 21.17. A fix is to ensure Position is validated (e.g., if Position >= TotalSize then set ActualCopy = 0 / skip memcpy) before computing or using ActualCopy."
}