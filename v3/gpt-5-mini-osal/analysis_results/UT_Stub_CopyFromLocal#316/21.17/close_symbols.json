{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_StubTableEntry_t::Data.Buff.BasePtr (type/ownership)",
    "UT_StubTableEntry_t::Data.Buff.Position (type/units)",
    "UT_StubTableEntry_t::Data.Buff.TotalSize (type/units)",
    "memcpy (prototype/semantics)",
    "Contract for LocalBuffer/MaxSize (caller-supplied buffer length in bytes)"
  ],
  "explanation": "For verifying the memcpy usage against the MISRA string-handling bounds rule, the analyzer needs the following symbols and why:\n\n- UT_StubTableEntry_t\n  - The full struct definition is required to know layout, member types and how Buffer data are represented.\n\n- UT_GetStubEntry\n  - Prototype and semantic behavior (what it returns for UT_ENTRYTYPE_DATA_BUFFER, lifetime/validity guarantees of the returned pointer) are needed to know whether StubPtr can be NULL and whether the pointed-to Stub entry and its buffer are valid for access.\n\n- UT_ClearStubEntry\n  - Prototype/semantics are needed to confirm it does not alter or free the destination buffer prior to the memcpy in this function (affects reasoning about memory lifetime). Even though it is called after memcpy here, its semantics help static analysis of entry lifecycle.\n\n- UT_ENTRYTYPE_DATA_BUFFER\n  - The constant/enum value is required to understand the semantics of the GetStubEntry lookup (i.e., that the returned entry is expected to contain a data buffer and which fields are meaningful).\n\n- UT_StubTableEntry_t::Data.Buff.BasePtr (type/ownership)\n  - The element type of BasePtr (char *, uint8_t *, void *, or other) and ownership/allocation information are essential to determine whether indexing BasePtr[Position] is byte-indexing or element-indexing and to compute the destination address for memcpy correctly.\n\n- UT_StubTableEntry_t::Data.Buff.Position (type/units)\n  - The type (e.g., size_t, uint32_t) and the unit/meaning (is it a byte offset, element index, etc.) are required to check that Position is within bounds and to compute remaining space.\n\n- UT_StubTableEntry_t::Data.Buff.TotalSize (type/units)\n  - The type and unit semantics (total number of bytes or number of elements) are needed to evaluate the subtraction TotalSize - Position and to ensure ActualCopy represents a byte count appropriate for memcpy.\n\n- memcpy (prototype/semantics)\n  - Confirmation that memcpy interprets its length argument as a number of bytes and its pointer arithmetic rules are necessary to map the struct members' units to memcpy's byte count.\n\n- Contract for LocalBuffer/MaxSize (caller-supplied buffer length in bytes)\n  - The meaning of MaxSize (is it the number of bytes available at LocalBuffer?) and any preconditions on LocalBuffer are required to ensure the code's cap (ActualCopy = min(available_in_stub, MaxSize)) prevents reading beyond LocalBuffer.\n\nWith these symbols (struct fields and their units/types, function semantics and buffer contracts) an analyst can determine whether the destination address &BasePtr[Position] plus the byte count ActualCopy can legally be accessed and whether the source LocalBuffer is large enough \u2014 thus deciding compliance with the MISRA rule about bounds for string-handling functions."
}