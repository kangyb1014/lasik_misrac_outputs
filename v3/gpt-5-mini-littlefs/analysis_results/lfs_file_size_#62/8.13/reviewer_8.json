{
  "user_message": "An agent A claimed that the following lfs_file_size_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_size_.\n```c\nstatic lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file) {\n    (void)lfs;\n\n#ifndef LFS_READONLY\n    if (file->flags & LFS_F_WRITING) {\n        return lfs_max(file->pos, file->ctz.size);\n    }\n#endif\n\n    return file->ctz.size;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function lfs_file_size_ takes a non-const pointer parameter (lfs_t *lfs) but never uses or modifies the pointed-to object (the code only does (void)lfs; to silence an unused-parameter warning). The pointer could and should be declared as pointing to a const-qualified type (e.g. const lfs_t *lfs). Therefore Rule 8.13 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nexit: readonly-or-closed: lfs=0x7fffab487858 file=0x7fffab4877f0\n  flags=0x00100001 pos=0 ctz.size=10\nenter: lfs=0x7fffab487458 file=0x7fffab4873f0\n  flags=0x00000102 pos=502032 ctz.size=502032\nexit: readonly-or-closed: lfs=0x7fffab487458 file=0x7fffab4873f0\n  flags=0x00000102 pos=502032 ctz.size=502032\nenter: lfs=0x7fffab487458 file=0x7fffab4873f0\n  flags=0x00000102 pos=502032 ctz.size=502032\nexit: readonly-or-closed: lfs=0x7fffab487458 file=0x7fffab4873f0\n  flags=0x00000102 pos=502032 ctz.si\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_size_:\ntypedef int32_t  lfs_soff_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_file {\n    struct lfs_file *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    struct lfs_ctz {\n        lfs_block_t head;\n        lfs_size_t size;\n    } ctz;\n\n    uint32_t flags;\n    lfs_off_t pos;\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_cache_t cache;\n\n    const struct lfs_file_config *cfg;\n} lfs_file_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown definition lfs_file_size_ does not modify the object pointed to by lfs and only uses (void)lfs; to suppress an unused-parameter warning. According to MISRA C 2023 Rule 8.13, a pointer parameter that does not allow modification of the pointed-to object should be const-qualified. Making the parameter const lfs_t *lfs would satisfy the rule and is safe for callers (an lfs_t * can be implicitly converted to const lfs_t *). Note: there may be legitimate reasons to keep the non-const signature (API consistency with other functions, planned future modification, or conditional builds where lfs is used), in which case a justified deviation is required. Absent such justification, the current code violates Rule 8.13. (As an aside, the file parameter is also only read and could likewise be const-qualified.)"
}