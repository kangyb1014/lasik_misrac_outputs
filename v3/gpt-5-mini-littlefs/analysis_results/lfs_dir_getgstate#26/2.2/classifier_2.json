{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_getgstate:\n```c\nstatic int lfs_dir_getgstate(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_gstate_t *gstate) {\n    lfs_gstate_t temp;\n    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),\n            LFS_MKTAG(LFS_TYPE_MOVESTATE, 0, sizeof(temp)), &temp);\n    if (res < 0 && res != LFS_ERR_NOENT) {\n        return res;\n    }\n\n    if (res != LFS_ERR_NOENT) {\n        // xor together to find resulting gstate\n        lfs_gstate_fromle32(&temp);\n        lfs_gstate_xor(gstate, &temp);\n    }\n\n    return 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_getgstate:\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic inline void lfs_gstate_fromle32(lfs_gstate_t *a) {\n    a->tag     = lfs_fromle32(a->tag);\n    a->pair[0] = lfs_fromle32(a->pair[0]);\n    a->pair[1] = lfs_fromle32(a->pair[1]);\n}\n...\nstatic inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {\n    a->tag ^= b->tag;\n    a->pair[0] ^= b->pair[0];\n    a->pair[1] ^= b->pair[1];\n}\n...\ntypedef struct lfs_gstate {\n    uint32_t tag;\n    lfs_block_t pair[2];\n} lfs_gstate_t\n...\n#define LFS_MKTAG(type, id, size) (((lfs_tag_t)(type)<<20)|((lfs_tag_t)(id)<<10)|(lfs_tag_t)(size))\n...\nstatic int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {\n    // steal state\n    int err = lfs_dir_getgstate(lfs, tail, &lfs->gdelta);\n    if (err) {\n        return err;\n    }\n\n    // steal tail\n    lfs_pair_tole32(tail->tail);\n    err = lfs_dir_commit(lfs, dir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_TAIL + tail->split, 0x3ff, 8), tail->tail}));\n    lfs_pair_fromle32(tail->tail);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n...\nstatic int lfs_dir_compact(lfs_t *lfs,\n        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *source, uint16_t begin, uint16_t end) {\n    // save some state in case block is bad\n    bool relocated = false;\n    bool tired = lfs_dir_needsrelocation(lfs, dir);\n\n    // increment revision count\n    dir->rev += 1;\n\n    // do not proactively relocate blocks during migrations, this\n    // can cause a number of failure states such: clobbering the\n    // v1 superblock if we relocate root, and invalidating directory\n    // pointers if we relocate the head of a directory. On top of\n    // this, relocations increase the overall complexity of\n    // lfs_migration, which is already a delicate operation.\n#ifdef LFS_MIGRATE\n    if (lfs->lfs1) {\n        tired = false;\n    }\n#endif\n\n    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {\n        // we're writing too much, time to relocate\n        goto relocate;\n    }\n\n    // begin loop to commit compaction to blocks until a compact sticks\n    while (true) {\n        {\n            // setup commit state\n            struct lfs_commit commit = {\n                .block = dir->pair[1],\n                .off = 0,\n                .ptag = 0xffffffff,\n                .crc = 0xffffffff,\n\n                .begin = 0,\n                .end = (lfs->cfg->metadata_max ?\n                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,\n            };\n\n            // erase block to write to\n            int err = lfs_bd_erase(lfs, dir->pair[1]);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // write out header\n            dir->rev = lfs_tole32(dir->rev);\n            err = lfs_dir_commitprog(lfs, &commit,\n                    &dir->rev, sizeof(dir->rev));\n            dir->rev = lfs_fromle32(dir->rev);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // traverse the directory, this time writing out all unique tags\n            err = lfs_dir_traverse(lfs,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS_MKTAG(0x400, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),\n                    begin, end, -begin,\n                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){\n                        lfs, &commit});\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // commit tail, which may be new after last size check\n            if (!lfs_pair_isnull(dir->tail)) {\n                lfs_pair_tole32(dir->tail);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail);\n                lfs_pair_fromle32(dir->tail);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // bring over gstate?\n            lfs_gstate_t delta = {0};\n            if (!relocated) {\n                lfs_gstate_xor(&delta, &lfs->gdisk);\n                lfs_gstate_xor(&delta, &lfs->gstate);\n            }\n            lfs_gstate_xor(&delta, &lfs->gdelta);\n            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);\n\n            err = lfs_dir_getgstate(lfs, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            if (!lfs_gstate_iszero(&delta)) {\n                lfs_gstate_tole32(&delta);\n                err = lfs_dir_commitattr(lfs, &commit,\n                        LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,\n                            sizeof(delta)), &delta);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            // complete commit with crc\n            err = lfs_dir_commitcrc(lfs, &commit);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            // successful compaction, swap dir pair to indicate most recent\n            LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);\n            lfs_pair_swap(dir->pair);\n            dir->count = end - begin;\n            dir->off = commit.off;\n            dir->etag = commit.ptag;\n            // update gstate\n            lfs->gdelta = (lfs_gstate_t){0};\n            if (!relocated) {\n                lfs->gdisk = lfs->gstate;\n            }\n        }\n        break;\n\nrelocate:\n        // commit was corrupted, drop caches and prepare to relocate block\n        relocated = true;\n        lfs_cache_drop(lfs, &lfs->pcache);\n        if (!tired) {\n            LFS_DEBUG(\"Bad block at 0x%\"PRIx32, dir->pair[1]);\n        }\n\n        // can't relocate superblock, filesystem is now frozen\n        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {\n            LFS_WARN(\"Superblock 0x%\"PRIx32\" has become unwritable\",\n                    dir->pair[1]);\n            return LFS_ERR_NOSPC;\n        }\n\n        // relocate half of pair\n        int err = lfs_alloc(lfs, &dir->pair[1]);\n        if (err && (err != LFS_ERR_NOSPC || !tired)) {\n            return err;\n        }\n\n        tired = false;\n        continue;\n    }\n\n    return relocated ? LFS_OK_RELOCATED : 0;\n}\n...\nstatic int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,\n        const lfs_block_t pair[2],\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_mdir_t *pdir) {\n    int state = 0;\n\n    // calculate changes to the directory\n    bool hasdelete = false;\n    for (int i = 0; i < attrcount; i++) {\n        if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {\n            dir->count += 1;\n        } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE) {\n            LFS_ASSERT(dir->count > 0);\n            dir->count -= 1;\n            hasdelete = true;\n        } else if (lfs_tag_type1(attrs[i].tag) == LFS_TYPE_TAIL) {\n            dir->tail[0] = ((lfs_block_t*)attrs[i].buffer)[0];\n            dir->tail[1] = ((lfs_block_t*)attrs[i].buffer)[1];\n            dir->split = (lfs_tag_chunk(attrs[i].tag) & 1);\n            lfs_pair_fromle32(dir->tail);\n        }\n    }\n\n    // should we actually drop the directory block?\n    if (hasdelete && dir->count == 0) {\n        LFS_ASSERT(pdir);\n        int err = lfs_fs_pred(lfs, dir->pair, pdir);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n\n        if (err != LFS_ERR_NOENT && pdir->split) {\n            state = LFS_OK_DROPPED;\n            goto fixmlist;\n        }\n    }\n\n    if (dir->erased) {\n        // try to commit\n        struct lfs_commit commit = {\n            .block = dir->pair[0],\n            .off = dir->off,\n            .ptag = dir->etag,\n            .crc = 0xffffffff,\n\n            .begin = dir->off,\n            .end = (lfs->cfg->metadata_max ?\n                lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,\n        };\n\n        // traverse attrs that need to be written out\n        lfs_pair_tole32(dir->tail);\n        int err = lfs_dir_traverse(lfs,\n                dir, dir->off, dir->etag, attrs, attrcount,\n                0, 0, 0, 0, 0,\n                lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){\n                    lfs, &commit});\n        lfs_pair_fromle32(dir->tail);\n        if (err) {\n            if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {\n                goto compact;\n            }\n            return err;\n        }\n\n        // commit any global diffs if we have any\n        lfs_gstate_t delta = {0};\n        lfs_gstate_xor(&delta, &lfs->gstate);\n        lfs_gstate_xor(&delta, &lfs->gdisk);\n        lfs_gstate_xor(&delta, &lfs->gdelta);\n        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);\n        if (!lfs_gstate_iszero(&delta)) {\n            err = lfs_dir_getgstate(lfs, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            lfs_gstate_tole32(&delta);\n            err = lfs_dir_commitattr(lfs, &commit,\n                    LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,\n                        sizeof(delta)), &delta);\n            if (err) {\n                if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {\n                    goto compact;\n                }\n                return err;\n            }\n        }\n\n        // finalize commit with the crc\n        err = lfs_dir_commitcrc(lfs, &commit);\n        if (err) {\n            if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {\n                goto compact;\n            }\n            return err;\n        }\n\n        // successful commit, update dir\n        LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);\n        dir->off = commit.off;\n        dir->etag = commit.ptag;\n        // and update gstate\n        lfs->gdisk = lfs->gstate;\n        lfs->gdelta = (lfs_gstate_t){0};\n\n        goto fixmlist;\n    }\n\ncompact:\n    // fall back to compaction\n    lfs_cache_drop(lfs, &lfs->pcache);\n\n    state = lfs_dir_splittingcompact(lfs, dir, attrs, attrcount,\n            dir, 0, dir->count);\n    if (state < 0) {\n        return state;\n    }\n\n    goto fixmlist;\n\nfixmlist:;\n    // this complicated bit of logic is for fixing up any active\n    // metadata-pairs that we may have affected\n    //\n    // note we have to make two passes since the mdir passed to\n    // lfs_dir_commit could also be in this list, and even then\n    // we need to copy the pair so they don't get clobbered if we refetch\n    // our mdir.\n    lfs_block_t oldpair[2] = {pair[0], pair[1]};\n    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {\n        if (lfs_pair_cmp(d->m.pair, oldpair) == 0) {\n            d->m = *dir;\n            if (d->m.pair != pair) {\n                for (int i = 0; i < attrcount; i++) {\n                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&\n                            d->id == lfs_tag_id(attrs[i].tag) &&\n                            d->type != LFS_TYPE_DIR) {\n                        d->m.pair[0] = LFS_BLOCK_NULL;\n                        d->m.pair[1] = LFS_BLOCK_NULL;\n                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&\n                            d->id > lfs_tag_id(attrs[i].tag)) {\n                        d->id -= 1;\n                        if (d->type == LFS_TYPE_DIR) {\n                            ((lfs_dir_t*)d)->pos -= 1;\n                        }\n                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&\n                            d->id >= lfs_tag_id(attrs[i].tag)) {\n                        d->id += 1;\n                        if (d->type == LFS_TYPE_DIR) {\n                            ((lfs_dir_t*)d)->pos += 1;\n                        }\n                    }\n                }\n            }\n\n            while (d->id >= d->m.count && d->m.split) {\n                // we split and id is on tail now\n                if (lfs_pair_cmp(d->m.tail, lfs->root) != 0) {\n                    d->id -= d->m.count;\n                }\n                int err = lfs_dir_fetch(lfs, &d->m, d->m.tail);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n    }\n\n    return state;\n}\n...\nstatic int lfs_dir_orphaningcommit(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount) {\n    // check for any inline files that aren't RAM backed and\n    // forcefully evict them, needed for filesystem consistency\n    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {\n        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&\n                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&\n                f->ctz.size > lfs->cfg->cache_size) {\n            int err = lfs_file_outline(lfs, f);\n            if (err) {\n                return err;\n            }\n\n            err = lfs_file_flush(lfs, f);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    lfs_block_t lpair[2] = {dir->pair[0], dir->pair[1]};\n    lfs_mdir_t ldir = *dir;\n    lfs_mdir_t pdir;\n    int state = lfs_dir_relocatingcommit(lfs, &ldir, dir->pair,\n            attrs, attrcount, &pdir);\n    if (state < 0) {\n        return state;\n    }\n\n    // update if we're not in mlist, note we may have already been\n    // updated if we are in mlist\n    if (lfs_pair_cmp(dir->pair, lpair) == 0) {\n        *dir = ldir;\n    }\n\n    // commit was successful, but may require other changes in the\n    // filesystem, these would normally be tail recursive, but we have\n    // flattened them here avoid unbounded stack usage\n\n    // need to drop?\n    if (state == LFS_OK_DROPPED) {\n        // steal state\n        int err = lfs_dir_getgstate(lfs, dir, &lfs->gdelta);\n        if (err) {\n            return err;\n        }\n\n        // steal tail, note that this can't create a recursive drop\n        lpair[0] = pdir.pair[0];\n        lpair[1] = pdir.pair[1];\n        lfs_pair_tole32(dir->tail);\n        state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(\n                    {LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail}),\n                NULL);\n        lfs_pair_fromle32(dir->tail);\n        if (state < 0) {\n            return state;\n        }\n\n        ldir = pdir;\n    }\n\n    // need to relocate?\n    bool orphans = false;\n    while (state == LFS_OK_RELOCATED) {\n        LFS_DEBUG(\"Relocating {0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                    \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                lpair[0], lpair[1], ldir.pair[0], ldir.pair[1]);\n        state = 0;\n\n        // update internal root\n        if (lfs_pair_cmp(lpair, lfs->root) == 0) {\n            lfs->root[0] = ldir.pair[0];\n            lfs->root[1] = ldir.pair[1];\n        }\n\n        // update internally tracked dirs\n        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {\n            if (lfs_pair_cmp(lpair, d->m.pair) == 0) {\n                d->m.pair[0] = ldir.pair[0];\n                d->m.pair[1] = ldir.pair[1];\n            }\n\n            if (d->type == LFS_TYPE_DIR &&\n                    lfs_pair_cmp(lpair, ((lfs_dir_t*)d)->head) == 0) {\n                ((lfs_dir_t*)d)->head[0] = ldir.pair[0];\n                ((lfs_dir_t*)d)->head[1] = ldir.pair[1];\n            }\n        }\n\n        // find parent\n        lfs_stag_t tag = lfs_fs_parent(lfs, lpair, &pdir);\n        if (tag < 0 && tag != LFS_ERR_NOENT) {\n            return tag;\n        }\n\n        bool hasparent = (tag != LFS_ERR_NOENT);\n        if (tag != LFS_ERR_NOENT) {\n            // note that if we have a parent, we must have a pred, so this will\n            // always create an orphan\n            int err = lfs_fs_preporphans(lfs, +1);\n            if (err) {\n                return err;\n            }\n\n            // fix pending move in this pair? this looks like an optimization but\n            // is in fact _required_ since relocating may outdate the move.\n            uint16_t moveid = 0x3ff;\n            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                moveid = lfs_tag_id(lfs->gstate.tag);\n                LFS_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs_fs_prepmove(lfs, 0x3ff, NULL);\n                if (moveid < lfs_tag_id(tag)) {\n                    tag -= LFS_MKTAG(0, 1, 0);\n                }\n            }\n\n            lfs_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};\n            lfs_pair_tole32(ldir.pair);\n            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(\n                        {LFS_MKTAG_IF(moveid != 0x3ff,\n                            LFS_TYPE_DELETE, moveid, 0), NULL},\n                        {tag, ldir.pair}),\n                    NULL);\n            lfs_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            if (state == LFS_OK_RELOCATED) {\n                lpair[0] = ppair[0];\n                lpair[1] = ppair[1];\n                ldir = pdir;\n                orphans = true;\n                continue;\n            }\n        }\n\n        // find pred\n        int err = lfs_fs_pred(lfs, lpair, &pdir);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n        LFS_ASSERT(!(hasparent && err == LFS_ERR_NOENT));\n\n        // if we can't find dir, it must be new\n        if (err != LFS_ERR_NOENT) {\n            if (lfs_gstate_hasorphans(&lfs->gstate)) {\n                // next step, clean up orphans\n                err = lfs_fs_preporphans(lfs, -(int8_t)hasparent);\n                if (err) {\n                    return err;\n                }\n            }\n\n            // fix pending move in this pair? this looks like an optimization\n            // but is in fact _required_ since relocating may outdate the move.\n            uint16_t moveid = 0x3ff;\n            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                moveid = lfs_tag_id(lfs->gstate.tag);\n                LFS_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs_fs_prepmove(lfs, 0x3ff, NULL);\n            }\n\n            // replace bad pair, either we clean up desync, or no desync occured\n            lpair[0] = pdir.pair[0];\n            lpair[1] = pdir.pair[1];\n            lfs_pair_tole32(ldir.pair);\n            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(\n                        {LFS_MKTAG_IF(moveid != 0x3ff,\n                            LFS_TYPE_DELETE, moveid, 0), NULL},\n                        {LFS_MKTAG(LFS_TYPE_TAIL + pdir.split, 0x3ff, 8),\n                            ldir.pair}),\n                    NULL);\n            lfs_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            ldir = pdir;\n        }\n    }\n\n    return orphans ? LFS_OK_ORPHANED : 0;\n}\n...\nstatic int lfs_mount_(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = lfs_init(lfs, cfg);\n    if (err) {\n        return err;\n    }\n\n    // scan directory blocks for superblock and any global updates\n    lfs_mdir_t dir = {.tail = {0, 1}};\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    while (!lfs_pair_isnull(dir.tail)) {\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        if (err < 0) {\n            goto cleanup;\n        }\n\n        // fetch next block in tail list\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,\n                LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),\n                NULL,\n                lfs_dir_find_match, &(struct lfs_dir_find_match){\n                    lfs, \"littlefs\", 8});\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n\n        // has superblock?\n        if (tag && !lfs_tag_isdelete(tag)) {\n            // update root\n            lfs->root[0] = dir.pair[0];\n            lfs->root[1] = dir.pair[1];\n\n            // grab superblock\n            lfs_superblock_t superblock;\n            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock);\n            if (tag < 0) {\n                err = tag;\n                goto cleanup;\n            }\n            lfs_superblock_fromle32(&superblock);\n\n            // check version\n            uint16_t major_version = (0xffff & (superblock.version >> 16));\n            uint16_t minor_version = (0xffff & (superblock.version >>  0));\n            if (major_version != lfs_fs_disk_version_major(lfs)\n                    || minor_version > lfs_fs_disk_version_minor(lfs)) {\n                LFS_ERROR(\"Invalid version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" != v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            // found older minor version? set an in-device only bit in the\n            // gstate so we know we need to rewrite the superblock before\n            // the first write\n            bool needssuperblock = false;\n            if (minor_version < lfs_fs_disk_version_minor(lfs)) {\n                LFS_DEBUG(\"Found older minor version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" < v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                needssuperblock = true;\n            }\n            // note this bit is reserved on disk, so fetching more gstate\n            // will not interfere here\n            lfs_fs_prepsuperblock(lfs, needssuperblock);\n\n            // check superblock configuration\n            if (superblock.name_max) {\n                if (superblock.name_max > lfs->name_max) {\n                    LFS_ERROR(\"Unsupported name_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.name_max, lfs->name_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->name_max = superblock.name_max;\n            }\n\n            if (superblock.file_max) {\n                if (superblock.file_max > lfs->file_max) {\n                    LFS_ERROR(\"Unsupported file_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.file_max, lfs->file_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->file_max = superblock.file_max;\n            }\n\n            if (superblock.attr_max) {\n                if (superblock.attr_max > lfs->attr_max) {\n                    LFS_ERROR(\"Unsupported attr_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.attr_max, lfs->attr_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->attr_max = superblock.attr_max;\n\n                // we also need to update inline_max in case attr_max changed\n                lfs->inline_max = lfs_min(lfs->inline_max, lfs->attr_max);\n            }\n\n            // this is where we get the block_count from disk if block_count=0\n            if (lfs->cfg->block_count\n                    && superblock.block_count != lfs->cfg->block_count) {\n                LFS_ERROR(\"Invalid block count (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_count, lfs->cfg->block_count);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            lfs->block_count = superblock.block_count;\n\n            if (superblock.block_size != lfs->cfg->block_size) {\n                LFS_ERROR(\"Invalid block size (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_size, lfs->cfg->block_size);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n        }\n\n        // has gstate?\n        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);\n        if (err) {\n            goto cleanup;\n        }\n    }\n\n    // update littlefs with gstate\n    if (!lfs_gstate_iszero(&lfs->gstate)) {\n        LFS_DEBUG(\"Found pending gstate 0x%08\"PRIx32\"%08\"PRIx32\"%08\"PRIx32,\n                lfs->gstate.tag,\n                lfs->gstate.pair[0],\n                lfs->gstate.pair[1]);\n    }\n    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);\n    lfs->gdisk = lfs->gstate;\n\n    // setup free lookahead, to distribute allocations uniformly across\n    // boots, we start the allocator at a random location\n    lfs->lookahead.start = lfs->seed % lfs->block_count;\n    lfs_alloc_drop(lfs);\n\n    return 0;\n\ncleanup:\n    lfs_unmount_(lfs);\n    return err;\n}\n...\nstatic int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {\n    if (!lfs_gstate_hasorphans(&lfs->gstate)) {\n        return 0;\n    }\n\n    // Check for orphans in two separate passes:\n    // - 1 for half-orphans (relocations)\n    // - 2 for full-orphans (removes/renames)\n    //\n    // Two separate passes are needed as half-orphans can contain outdated\n    // references to full-orphans, effectively hiding them from the deorphan\n    // search.\n    //\n    int pass = 0;\n    while (pass < 2) {\n        // Fix any orphans\n        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};\n        lfs_mdir_t dir;\n        bool moreorphans = false;\n\n        // iterate over all directory directory entries\n        while (!lfs_pair_isnull(pdir.tail)) {\n            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);\n            if (err) {\n                return err;\n            }\n\n            // check head blocks for orphans\n            if (!pdir.split) {\n                // check if we have a parent\n                lfs_mdir_t parent;\n                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);\n                if (tag < 0 && tag != LFS_ERR_NOENT) {\n                    return tag;\n                }\n\n                if (pass == 0 && tag != LFS_ERR_NOENT) {\n                    lfs_block_t pair[2];\n                    lfs_stag_t state = lfs_dir_get(lfs, &parent,\n                            LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);\n                    if (state < 0) {\n                        return state;\n                    }\n                    lfs_pair_fromle32(pair);\n\n                    if (!lfs_pair_issync(pair, pdir.tail)) {\n                        // we have desynced\n                        LFS_DEBUG(\"Fixing half-orphan \"\n                                \"{0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                                \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);\n\n                        // fix pending move in this pair? this looks like an\n                        // optimization but is in fact _required_ since\n                        // relocating may outdate the move.\n                        uint16_t moveid = 0x3ff;\n                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {\n                            moveid = lfs_tag_id(lfs->gstate.tag);\n                            LFS_DEBUG(\"Fixing move while fixing orphans \"\n                                    \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                                    pdir.pair[0], pdir.pair[1], moveid);\n                            lfs_fs_prepmove(lfs, 0x3ff, NULL);\n                        }\n\n                        lfs_pair_tole32(pair);\n                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                                {LFS_MKTAG_IF(moveid != 0x3ff,\n                                    LFS_TYPE_DELETE, moveid, 0), NULL},\n                                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8),\n                                    pair}));\n                        lfs_pair_fromle32(pair);\n                        if (state < 0) {\n                            return state;\n                        }\n\n                        // did our commit create more orphans?\n                        if (state == LFS_OK_ORPHANED) {\n                            moreorphans = true;\n                        }\n\n                        // refetch tail\n                        continue;\n                    }\n                }\n\n                // note we only check for full orphans if we may have had a\n                // power-loss, otherwise orphans are created intentionally\n                // during operations such as lfs_mkdir\n                if (pass == 1 && tag == LFS_ERR_NOENT && powerloss) {\n                    // we are an orphan\n                    LFS_DEBUG(\"Fixing orphan {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                            pdir.tail[0], pdir.tail[1]);\n\n                    // steal state\n                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);\n                    if (err) {\n                        return err;\n                    }\n\n                    // steal tail\n                    lfs_pair_tole32(dir.tail);\n                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(\n                            {LFS_MKTAG(LFS_TYPE_TAIL + dir.split, 0x3ff, 8),\n                                dir.tail}));\n                    lfs_pair_fromle32(dir.tail);\n                    if (state < 0) {\n                        return state;\n                    }\n\n                    // did our commit create more orphans?\n                    if (state == LFS_OK_ORPHANED) {\n                        moreorphans = true;\n                    }\n\n                    // refetch tail\n                    continue;\n                }\n            }\n\n            pdir = dir;\n        }\n\n        pass = moreorphans ? 0 : pass+1;\n    }\n\n    // mark orphans as fixed\n    return lfs_fs_preporphans(lfs, -lfs_gstate_getorphans(&lfs->gstate));\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nlfs_gstate_t delta = {0};\n        lfs_gstate_xor(&delta, &lfs->gstate);\n        lfs_gstate_xor(&delta, &lfs->gdisk);\n        lfs_gstate_xor(&delta, &lfs->gdelta);\n        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);\n        if (!lfs_gstate_iszero(&delta)) {\n            err = lfs_dir_getgstate(lfs, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            lfs_gstate_tole32(&delta);\n            err = lfs_dir_commitattr(lfs, &commit,\n                    LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,\n                        sizeof(delta)), &delta);\n            if (err) {\n                if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {\n                    goto compact;\n                }\n                return err;\n            }\n        }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No. The operations in the fragment are not dead. The code builds a delta by XORing runtime gstate fields, masks out the chunk bits, tests for non-zero, then (if non-zero) fetches any on-disk MOVESTATE to include (lfs_dir_getgstate), converts to little-endian (lfs_gstate_tole32) and writes it out (lfs_dir_commitattr). Each statement can affect program behaviour: the XORs compute the delta, the mask changes which tag bits are considered, lfs_dir_getgstate can further change delta based on on-disk state, tole32 is required for correct on-disk representation, and the conditional prevents unnecessary commits. Removing any of these operations would change behaviour, so this fragment does not violate MISRA C 2023 Rule 2.2."
}