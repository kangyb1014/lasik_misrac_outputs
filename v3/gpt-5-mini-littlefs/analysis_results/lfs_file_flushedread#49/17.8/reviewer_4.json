{
  "user_message": "An agent A claimed that the following lfs_file_flushedread code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_flushedread.\n```c\nstatic lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    if (file->pos >= file->ctz.size) {\n        // eof if past end\n        return 0;\n    }\n\n    size = lfs_min(size, file->ctz.size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_READING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                        file->ctz.head, file->ctz.size,\n                        file->pos, &file->block, &file->off);\n                if (err) {\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS_F_READING;\n        }\n\n        // read as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        if (file->flags & LFS_F_INLINE) {\n            int err = lfs_dir_getread(lfs, &file->m,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    LFS_MKTAG(0xfff, 0x1ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                    file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        } else {\n            int err = lfs_bd_read(lfs,\n                    NULL, &file->cache, lfs->cfg->block_size,\n                    file->block, file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n    }\n\n    return size;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn lfs_bd_read and lfs_dir_getread the scalar parameters 'off' and 'size' are modified inside the function (e.g. off += diff; size -= diff;). The shown fragment shows memcpy(data, ...); data += diff; off += diff; size -= diff; \u2014 where 'data' is a local pointer (initialized from the parameter 'buffer') but 'off' and 'size' are function parameters being changed. This violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=0, file->off=0, file->ctz.size=343060, flags=0x01, block=0\nBefore clamp: size=5, file->ctz.size-file->pos=343060\nAfter clamp: size=5, nsize=5\nCalling lfs_ctz_find: pos=0, ctz.size=343060, ctz.head=1965\nPost-block-setup: block=1283, off=0, flags=0x40001\nAbout to read: inline=0, block=1283, off(before)=0, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=0, file->off(before)=0, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=5, file->off=5, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=5, file->off=5, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343055\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=5, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=5, file->off(before)=5, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=10, file->off=10, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=10, file->off=10, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343050\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=10, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=10, file->off(before)=10, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=15, file->off=15, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=15, file->off=15, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343045\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=15, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=15, file->off(before)=15, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=20, file->off=20, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=20, file->off=20, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343040\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=20, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=20, file->off(before)=20, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=25, file->off=25, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=25, file->off=25, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343035\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=25, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=25, file->off(before)=25, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=30, file->off=30, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=30, file->off=30, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-file->pos=343030\nAfter clamp: size=5, nsize=5\nAbout to read: inline=0, block=1283, off(before)=30, diff=5, data=0x7fff99d95a28\nAfter read call: file->pos(before)=30, file->off(before)=30, data=0x7fff99d95a28, nsize(before)=5\nAfter local update: file->pos=35, file->off=35, data=0x7fff99d95a2d, nsize=0, remaining size parameter=5\nEXIT lfs_file_flushedread: returning size=5\nENTER lfs_file_flushedread: buffer=0x7fff99d95a28, size=5, file->pos=35, file->off=35, file->ctz.size=343060, flags=0x40001, block=1283\nBefore clamp: size=5, file->ctz.size-f\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_flushedread:\nstatic int lfs_ctz_find(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_block_t head, lfs_size_t size,\n        lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {\n    if (size == 0) {\n        *block = LFS_BLOCK_NULL;\n        *off = 0;\n        return 0;\n    }\n\n    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});\n    lfs_off_t target = lfs_ctz_index(lfs, &pos);\n\n    while (current > target) {\n        lfs_size_t skip = lfs_min(\n                lfs_npw2(current-target+1) - 1,\n                lfs_ctz(current));\n\n        int err = lfs_bd_read(lfs,\n                pcache, rcache, sizeof(head),\n                head, 4*skip, &head, sizeof(head));\n        head = lfs_fromle32(head);\n        if (err) {\n            return err;\n        }\n\n        current -= 1 << skip;\n    }\n\n    *block = head;\n    *off = pos;\n    return 0;\n}\n...\nstatic int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t off, void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && pcache->block == LFS_BLOCK_INLINE &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (rcache->block == LFS_BLOCK_INLINE &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        // load to cache, first condition can no longer fail\n        rcache->block = LFS_BLOCK_INLINE;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),\n                lfs->cfg->cache_size);\n        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,\n                rcache->off, rcache->buffer, rcache->size);\n        if (err < 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size\n            || (lfs->block_count && block >= lfs->block_count)) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs->cfg->read_size == 0 &&\n                size >= lfs->cfg->read_size) {\n            // bypass cache?\n            diff = lfs_aligndown(diff, lfs->cfg->read_size);\n            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        // load to cache, first condition can no longer fail\n        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);\n        rcache->block = block;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(\n                lfs_min(\n                    lfs_alignup(off+hint, lfs->cfg->read_size),\n                    lfs->cfg->block_size)\n                - rcache->off,\n                lfs->cfg->cache_size);\n        int err = lfs->cfg->read(lfs->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\ntypedef struct lfs_file {\n    struct lfs_file *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    struct lfs_ctz {\n        lfs_block_t head;\n        lfs_size_t size;\n    } ctz;\n\n    uint32_t flags;\n    lfs_off_t pos;\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_cache_t cache;\n\n    const struct lfs_file_config *cfg;\n} lfs_file_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef uint32_t lfs_size_t\n...\ntypedef int32_t  lfs_ssize_t\n...\n#define LFS_BLOCK_INLINE ((lfs_block_t)-2)\n...\n#define LFS_MKTAG(type, id, size) (((lfs_tag_t)(type)<<20)|((lfs_tag_t)(id)<<10)|(lfs_tag_t)(size))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameter variables. In lfs_file_flushedread the parameter 'size' is assigned to (size = lfs_min(...); and later returned), which is a direct modification of a scalar parameter and therefore a violation. (The local pointer 'data' is initialized from the pointer parameter 'buffer' and modified locally \u2014 that is allowed because the pointer parameter itself is not modified.) Additionally, the callee functions lfs_bd_read and lfs_dir_getread also modify their scalar parameters 'off' and 'size' internally (off += diff; size -= diff;), which likewise violates Rule 17.8. The correct remediation is to use local copies for values that need to be updated instead of assigning to the parameter variables.)"
}