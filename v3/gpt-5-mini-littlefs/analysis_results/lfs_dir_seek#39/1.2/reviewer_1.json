{
  "user_message": "An agent A claimed that the following lfs_dir_seek code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_seek.\n```c\nint lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_seek(%p, %p, %\"PRIu32\")\",\n            (void*)lfs, (void*)dir, off);\n\n    err = lfs_dir_seek_(lfs, dir, off);\n\n    LFS_TRACE(\"lfs_dir_seek -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro is defined as #define LFS_TRACE(__VA_ARGS__) using __VA_ARGS__ in the macro parameter list. The use of __VA_ARGS__ in the macro header (instead of the standard C99 form using an ellipsis '...') is a compiler-specific extension rather than standard C. This therefore constitutes use of a language extension and violates MISRA C 2023 Rule 1.2. (The compliant form would be #define LFS_TRACE(...) for a C99/C11 variadic macro, or avoid variadic macros if targeting pre-C99 compilers.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=4)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=4)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=4)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=4)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=5)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=5)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=5)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=5)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=6)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=6)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=6)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=6)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=2)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_TRACE (exit) unlocking and returning 0\nlfs_dir_seek: LFS_LOCK returned 0 (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: before LFS_TRACE (lfs=0x7fffd31ef910 dir=0x7fffd31ef8d8 off=3)\nlfs_dir_seek: after LFS_TRACE, about to call lfs_dir_seek_\nlfs_dir_seek: lfs_dir_seek_ returned 0\nlfs_dir_seek: after LFS_T\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_seek:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_dir {\n    struct lfs_dir *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    lfs_off_t pos;\n    lfs_block_t head[2];\n} lfs_dir_t\n...\ntypedef uint32_t lfs_off_t\n...\nstatic int lfs_dir_seek_(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {\n    // simply walk from head dir\n    int err = lfs_dir_rewind_(lfs, dir);\n    if (err) {\n        return err;\n    }\n\n    // first two for ./..\n    dir->pos = lfs_min(2, off);\n    off -= dir->pos;\n\n    // skip superblock entry\n    dir->id = (off > 0 && lfs_pair_cmp(dir->head, lfs->root) == 0);\n\n    while (off > 0) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return LFS_ERR_INVAL;\n            }\n\n            err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int diff = lfs_min(dir->m.count - dir->id, off);\n        dir->id += diff;\n        dir->pos += diff;\n        off -= diff;\n    }\n\n    return 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code shows #define LFS_TRACE(__VA_ARGS__) which places the token __VA_ARGS__ in the macro parameter list. The C standard (C99/C11/C17) specifies variadic macros using an ellipsis in the parameter list (e.g. #define LFS_TRACE(...) ) and the special identifier __VA_ARGS__ is used inside the replacement list to expand the arguments. Using a named parameter of the form (__VA_ARGS__) in the macro header is a compiler-specific (GNU) extension accepted by some preprocessors (GCC/Clang in GNU mode), not standard C. MISRA C 2023 Rule 1.2 prohibits use of language extensions, so this usage should be reported as a violation. A compliant fix is to use the standard form #define LFS_TRACE(...) or avoid variadic macros altogether."
}