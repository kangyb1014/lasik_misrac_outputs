{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes the address of a structure member (&lfs->gdisk) to lfs_gstate_hasmove. If the function lfs_gstate_hasmove is declared to take a non-const pointer (e.g. bool lfs_gstate_hasmove(lfs_gstate_t *g)) but only inspects the structure (does not modify it), then the pointer parameter should instead be const-qualified (bool lfs_gstate_hasmove(const lfs_gstate_t *g)). In that case this use violates MISRA C 2023 Rule 8.13. If, however, lfs_gstate_hasmove is declared to take a pointer-to-const (or it genuinely modifies the gdisk), then there is no violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_fs_demove code that contains useful probe functions that print useful logs to a file \"/tmp/logs/723.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_fs_demove as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_fs_demove:\n```c\nstatic int lfs_fs_demove(lfs_t *lfs) {\n    if (!lfs_gstate_hasmove(&lfs->gdisk)) {\n        return 0;\n    }\n\n    // Fix bad moves\n    LFS_DEBUG(\"Fixing move {0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16,\n            lfs->gdisk.pair[0],\n            lfs->gdisk.pair[1],\n            lfs_tag_id(lfs->gdisk.tag));\n\n    // no other gstate is supported at this time, so if we found something else\n    // something most likely went wrong in gstate calculation\n    LFS_ASSERT(lfs_tag_type3(lfs->gdisk.tag) == LFS_TYPE_DELETE);\n\n    // fetch and delete the moved entry\n    lfs_mdir_t movedir;\n    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);\n    if (err) {\n        return err;\n    }\n\n    // prep gstate and delete move id\n    uint16_t moveid = lfs_tag_id(lfs->gdisk.tag);\n    lfs_fs_prepmove(lfs, 0x3ff, NULL);\n    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_DELETE, moveid, 0), NULL}));\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_fs_demove code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe logging helper for lfs_fs_demove. Writes append-only logs to /tmp/logs/723.txt. */\nstatic void lfs_fs_demove_log(const char *phase, const void *lfs_ptr, const void *extra)\n{\n    FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"lfs_fs_demove: %s\\n\", phase ? phase : \"(null)\");\n    fprintf(f, \"  lfs ptr: %p\\n\", lfs_ptr);\n    if (extra) {\n        fprintf(f, \"  extra ptr: %p\\n\", extra);\n    }\n    fflush(f);\n    fclose(f);\n}\n\n/* Modified function: preserved original logic, with probes inserted. */\nstatic int lfs_fs_demove(lfs_t *lfs) {\n    /* Log entry and gdisk pointer/state */\n    lfs_fs_demove_log(\"entry\", (const void*)lfs, NULL);\n    if (lfs) {\n        /* Log basic gdisk fields that are relevant to the gstate check */\n        FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"  gdisk ptr: %p\\n\", (void*)&lfs->gdisk);\n            fprintf(f, \"  gdisk.pair[0]: %llu\\n\", (unsigned long long)lfs->gdisk.pair[0]);\n            fprintf(f, \"  gdisk.pair[1]: %llu\\n\", (unsigned long long)lfs->gdisk.pair[1]);\n            fprintf(f, \"  gdisk.tag: 0x%04x\\n\", (unsigned)lfs->gdisk.tag);\n            fclose(f);\n        }\n    }\n\n    /* Probe before calling lfs_gstate_hasmove to capture the pointer passed */\n    lfs_fs_demove_log(\"before lfs_gstate_hasmove (about to call with &lfs->gdisk)\", (const void*)lfs, (const void*)&lfs->gdisk);\n\n    if (!lfs_gstate_hasmove(&lfs->gdisk)) {\n        /* Log negative result */\n        lfs_fs_demove_log(\"lfs_gstate_hasmove returned false -> no move\", (const void*)lfs, (const void*)&lfs->gdisk);\n        return 0;\n    }\n\n    /* Log that we are fixing a move and the identifying information */\n    {\n        FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"Fixing move: pair[0]=%llu, pair[1]=%llu, tag=0x%04x, id=%u\\n\",\n                    (unsigned long long)lfs->gdisk.pair[0],\n                    (unsigned long long)lfs->gdisk.pair[1],\n                    (unsigned)lfs->gdisk.tag,\n                    (unsigned)lfs_tag_id(lfs->gdisk.tag));\n            fclose(f);\n        }\n    }\n\n    // no other gstate is supported at this time, so if we found something else\n    // something most likely went wrong in gstate calculation\n    LFS_ASSERT(lfs_tag_type3(lfs->gdisk.tag) == LFS_TYPE_DELETE);\n\n    // fetch and delete the moved entry\n    lfs_mdir_t movedir;\n    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);\n    if (err) {\n        /* Log fetch error */\n        FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"lfs_dir_fetch returned err=%d\\n\", err);\n            fclose(f);\n        }\n        return err;\n    }\n\n    // prep gstate and delete move id\n    uint16_t moveid = lfs_tag_id(lfs->gdisk.tag);\n    lfs_fs_prepmove(lfs, 0x3ff, NULL);\n\n    /* Log before commit (including move id) */\n    {\n        FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"About to commit delete for move id=%u\\n\", (unsigned)moveid);\n            fclose(f);\n        }\n    }\n\n    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_DELETE, moveid, 0), NULL}));\n    if (err) {\n        /* Log commit error */\n        FILE *f = fopen(\"/tmp/logs/723.txt\", \"a\");\n        if (f) {\n            fprintf(f, \"lfs_dir_commit returned err=%d\\n\", err);\n            fclose(f);\n        }\n        return err;\n    }\n\n    /* Log successful completion */\n    lfs_fs_demove_log(\"completed successfully\", (const void*)lfs, (const void*)&lfs->gdisk);\n\n    return 0;\n}\n"
}