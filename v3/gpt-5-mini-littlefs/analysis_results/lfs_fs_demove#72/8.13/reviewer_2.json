{
  "user_message": "An agent A claimed that the following lfs_fs_demove code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_demove.\n```c\nstatic int lfs_fs_demove(lfs_t *lfs) {\n    if (!lfs_gstate_hasmove(&lfs->gdisk)) {\n        return 0;\n    }\n\n    // Fix bad moves\n    LFS_DEBUG(\"Fixing move {0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16,\n            lfs->gdisk.pair[0],\n            lfs->gdisk.pair[1],\n            lfs_tag_id(lfs->gdisk.tag));\n\n    // no other gstate is supported at this time, so if we found something else\n    // something most likely went wrong in gstate calculation\n    LFS_ASSERT(lfs_tag_type3(lfs->gdisk.tag) == LFS_TYPE_DELETE);\n\n    // fetch and delete the moved entry\n    lfs_mdir_t movedir;\n    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);\n    if (err) {\n        return err;\n    }\n\n    // prep gstate and delete move id\n    uint16_t moveid = lfs_tag_id(lfs->gdisk.tag);\n    lfs_fs_prepmove(lfs, 0x3ff, NULL);\n    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(\n            {LFS_MKTAG(LFS_TYPE_DELETE, moveid, 0), NULL}));\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes the address of a structure member (&lfs->gdisk) to lfs_gstate_hasmove. If the function lfs_gstate_hasmove is declared to take a non-const pointer (e.g. bool lfs_gstate_hasmove(lfs_gstate_t *g)) but only inspects the structure (does not modify it), then the pointer parameter should instead be const-qualified (bool lfs_gstate_hasmove(const lfs_gstate_t *g)). In that case this use violates MISRA C 2023 Rule 8.13. If, however, lfs_gstate_hasmove is declared to take a pointer-to-const (or it genuinely modifies the gdisk), then there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: entry\n  lfs ptr: 0x7ffd0df97c78\n  gdisk ptr: 0x7ffd0df97cc8\n  gdisk.pair[0]: 0\n  gdisk.pair[1]: 0\n  gdisk.tag: 0x0000\nlfs_fs_demove: before lfs_gstate_hasmove (about to call with &lfs->gdisk)\n  lfs ptr: 0x7ffd0df97c78\n  extra ptr: 0x7ffd0df97cc8\nlfs_fs_demove: lfs_gstate_hasmove returned false -> no move\n  lfs ptr: 0x7ffd0df97c78\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_demove:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\nstatic int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount) {\n    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);\n    if (orphans < 0) {\n        return orphans;\n    }\n\n    if (orphans) {\n        // make sure we've removed all orphans, this is a noop if there\n        // are none, but if we had nested blocks failures we may have\n        // created some\n        int err = lfs_fs_deorphan(lfs, false);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "You cannot conclude from the provided snippet that lfs_fs_demove violates MISRA C:2023 Rule 8.13. The reported issue depends entirely on the declaration and implementation of lfs_gstate_hasmove, which was not provided.\n\nFacts:\n- The call &lfs->gdisk yields a value of type lfs_gstate_t *. That by itself is not a MISRA violation.\n- MISRA R8.13 requires pointers to point to const-qualified types whenever possible. For function parameters, that means a function that only inspects (does not modify) the pointee should be declared to take a pointer-to-const.\n\nAssessment of the agent A scenario:\n- If lfs_gstate_hasmove is declared as bool lfs_gstate_hasmove(lfs_gstate_t *g) but its implementation only reads from *g (never modifies it), then the function signature should be changed to bool lfs_gstate_hasmove(const lfs_gstate_t *g) to satisfy R8.13. In that case the agent A report would be correct (there is a violation in the function declaration, not in the call site). \n- If lfs_gstate_hasmove is already declared as taking const lfs_gstate_t * or if it legitimately modifies the gdisk state, then there is no violation.\n\nConclusion and recommendation:\n- The report as stated is conditional and cannot be confirmed with the given code. Marking the report as not proven/correct. To resolve, inspect the prototype and implementation of lfs_gstate_hasmove. If it does not modify its argument, change the parameter to pointer-to-const (or justify why it cannot be const)."
}