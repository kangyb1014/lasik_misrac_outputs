{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nmemcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size) can overflow either operand if their actual buffer sizes are smaller than lfs->cfg->cache_size. For example, if file->cache.buffer points to a smaller per-file buffer (or is NULL/uninitialized) or lfs->pcache.buffer is smaller than cfg->cache_size, the memcpy will read or write beyond the bounds of the source or destination. The fragment contains no checks that the two buffers are at least cfg->cache_size bytes, so the use of memcpy can result in out-of-bounds accesses.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_relocate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/579.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_relocate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_relocate:\n```c\nstatic int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {\n    while (true) {\n        // just relocate what exists into new block\n        lfs_block_t nblock;\n        int err = lfs_alloc(lfs, &nblock);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_bd_erase(lfs, nblock);\n        if (err) {\n            if (err == LFS_ERR_CORRUPT) {\n                goto relocate;\n            }\n            return err;\n        }\n\n        // either read from dirty cache or disk\n        for (lfs_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS_F_INLINE) {\n                err = lfs_dir_getread(lfs, &file->m,\n                        // note we evict inline files before they can be dirty\n                        NULL, &file->cache, file->off-i,\n                        LFS_MKTAG(0xfff, 0x1ff, 0),\n                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            } else {\n                err = lfs_bd_read(lfs,\n                        &file->cache, &lfs->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            }\n\n            err = lfs_bd_prog(lfs,\n                    &lfs->pcache, &lfs->rcache, true,\n                    nblock, i, &data, 1);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n        }\n\n        // copy over new state of file\n        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);\n        file->cache.block = lfs->pcache.block;\n        file->cache.off = lfs->pcache.off;\n        file->cache.size = lfs->pcache.size;\n        lfs_cache_zero(lfs, &lfs->pcache);\n\n        file->block = nblock;\n        file->flags |= LFS_F_WRITING;\n        return 0;\n\nrelocate:\n        LFS_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n\n        // just clear cache and try a new block\n        lfs_cache_drop(lfs, &lfs->pcache);\n    }\n}\n```\n</target_code>\nPlease provide the modified lfs_file_relocate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n/* Probe logger: append human-readable logs to /tmp/logs/579.txt */\nstatic void lfs_log_probe(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/579.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {\n    lfs_log_probe(\"lfs_file_relocate ENTER: lfs=%p, file=%p, file->off=%llu, file->flags=0x%08x\",\n            (void*)lfs, (void*)file,\n            (unsigned long long)file->off, (unsigned)file->flags);\n\n    while (true) {\n        // just relocate what exists into new block\n        lfs_block_t nblock;\n        int err = lfs_alloc(lfs, &nblock);\n        lfs_log_probe(\"lfs_alloc returned %d, nblock=0x%\" PRIx32, err, nblock);\n        if (err) {\n            lfs_log_probe(\"lfs_file_relocate EXIT (alloc err): %d\", err);\n            return err;\n        }\n\n        err = lfs_bd_erase(lfs, nblock);\n        lfs_log_probe(\"lfs_bd_erase returned %d for nblock=0x%\" PRIx32, err, nblock);\n        if (err) {\n            if (err == LFS_ERR_CORRUPT) {\n                lfs_log_probe(\"lfs_bd_erase reported CORRUPT, goto relocate (nblock=0x%\" PRIx32 \")\", nblock);\n                goto relocate;\n            }\n            lfs_log_probe(\"lfs_file_relocate EXIT (erase err): %d\", err);\n            return err;\n        }\n\n        // either read from dirty cache or disk\n        for (lfs_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS_F_INLINE) {\n                err = lfs_dir_getread(lfs, &file->m,\n                        // note we evict inline files before they can be dirty\n                        NULL, &file->cache, file->off-i,\n                        LFS_MKTAG(0xfff, 0x1ff, 0),\n                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n                lfs_log_probe(\"lfs_dir_getread returned %d at i=%llu\", err, (unsigned long long)i);\n                if (err) {\n                    lfs_log_probe(\"lfs_file_relocate EXIT (getread err): %d\", err);\n                    return err;\n                }\n            } else {\n                err = lfs_bd_read(lfs,\n                        &file->cache, &lfs->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                lfs_log_probe(\"lfs_bd_read returned %d at i=%llu\", err, (unsigned long long)i);\n                if (err) {\n                    lfs_log_probe(\"lfs_file_relocate EXIT (bd_read err): %d\", err);\n                    return err;\n                }\n            }\n\n            err = lfs_bd_prog(lfs,\n                    &lfs->pcache, &lfs->rcache, true,\n                    nblock, i, &data, 1);\n            lfs_log_probe(\"lfs_bd_prog returned %d at i=%llu\", err, (unsigned long long)i);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    lfs_log_probe(\"lfs_bd_prog reported CORRUPT, goto relocate (nblock=0x%\" PRIx32 \")\", nblock);\n                    goto relocate;\n                }\n                lfs_log_probe(\"lfs_file_relocate EXIT (bd_prog err): %d\", err);\n                return err;\n            }\n        }\n\n        /* Probe before memcpy: record pointers and sizes that are relevant to potential overflow */\n        lfs_log_probe(\"ABOUT TO memcpy: dest=%p, src=%p, cfg_cache_size=%llu, dest.size=%llu, src.size=%llu\",\n                (void*)file->cache.buffer, (void*)lfs->pcache.buffer,\n                (unsigned long long)lfs->cfg->cache_size,\n                (unsigned long long)file->cache.size,\n                (unsigned long long)lfs->pcache.size);\n\n        if (file->cache.buffer == NULL) {\n            lfs_log_probe(\"WARNING: file->cache.buffer is NULL\");\n        }\n        if (lfs->pcache.buffer == NULL) {\n            lfs_log_probe(\"WARNING: lfs->pcache.buffer is NULL\");\n        }\n\n        /* copy over new state of file */\n        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);\n        lfs_log_probe(\"memcpy completed: copied %llu bytes\", (unsigned long long)lfs->cfg->cache_size);\n\n        file->cache.block = lfs->pcache.block;\n        file->cache.off = lfs->pcache.off;\n        file->cache.size = lfs->pcache.size;\n        lfs_log_probe(\"cache updated: block=0x%\" PRIx32 \", off=%llu, size=%llu\",\n                file->cache.block, (unsigned long long)file->cache.off, (unsigned long long)file->cache.size);\n\n        lfs_cache_zero(lfs, &lfs->pcache);\n        lfs_log_probe(\"pcache zeroed\");\n\n        file->block = nblock;\n        file->flags |= LFS_F_WRITING;\n        lfs_log_probe(\"lfs_file_relocate EXIT (success): file->block=0x%\" PRIx32 \", flags=0x%08x\",\n                file->block, (unsigned)file->flags);\n        return 0;\n\nrelocate:\n        lfs_log_probe(\"relocate: bad block at 0x%\" PRIx32, nblock);\n\n        LFS_DEBUG(\"Bad block at 0x%\" PRIx32, nblock);\n\n        // just clear cache and try a new block\n        lfs_cache_drop(lfs, &lfs->pcache);\n    }\n}\n"
}