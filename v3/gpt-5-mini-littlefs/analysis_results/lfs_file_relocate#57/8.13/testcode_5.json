{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes non-const pointers where const could reasonably be used. In particular &file->m (type lfs_mdir_t *) and &file->cache (type lfs_cache_t *) are passed to lfs_dir_getread in the inline-file path even though the comment indicates inline files are evicted and thus the function will only read these structures. If lfs_dir_getread does not modify these objects, its parameters (and therefore the pointers passed here) should be const-qualified. As written this usage can violate MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_relocate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/573.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_relocate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_relocate:\n```c\nstatic int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {\n    while (true) {\n        // just relocate what exists into new block\n        lfs_block_t nblock;\n        int err = lfs_alloc(lfs, &nblock);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_bd_erase(lfs, nblock);\n        if (err) {\n            if (err == LFS_ERR_CORRUPT) {\n                goto relocate;\n            }\n            return err;\n        }\n\n        // either read from dirty cache or disk\n        for (lfs_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS_F_INLINE) {\n                err = lfs_dir_getread(lfs, &file->m,\n                        // note we evict inline files before they can be dirty\n                        NULL, &file->cache, file->off-i,\n                        LFS_MKTAG(0xfff, 0x1ff, 0),\n                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            } else {\n                err = lfs_bd_read(lfs,\n                        &file->cache, &lfs->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            }\n\n            err = lfs_bd_prog(lfs,\n                    &lfs->pcache, &lfs->rcache, true,\n                    nblock, i, &data, 1);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n        }\n\n        // copy over new state of file\n        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);\n        file->cache.block = lfs->pcache.block;\n        file->cache.off = lfs->pcache.off;\n        file->cache.size = lfs->pcache.size;\n        lfs_cache_zero(lfs, &lfs->pcache);\n\n        file->block = nblock;\n        file->flags |= LFS_F_WRITING;\n        return 0;\n\nrelocate:\n        LFS_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n\n        // just clear cache and try a new block\n        lfs_cache_drop(lfs, &lfs->pcache);\n    }\n}\n```\n</target_code>\nPlease provide the modified lfs_file_relocate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\nstatic void lfs_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/573.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nstatic void lfs_probe_dump_file_state(const char *stage, lfs_t *lfs, lfs_file_t *file, lfs_block_t nblock)\n{\n    /* Log salient state useful to reproduce the violation scenario. */\n    lfs_probe_log(\"[%s] lfs=%p, file=%p, file->id=%u, file->off=%lld, file->flags=0x%02x, file->block=%lu, nblock=%lu\",\n            stage, (void*)lfs, (void*)file,\n            (unsigned)file->id, (long long)file->off, (unsigned)file->flags,\n            (unsigned long)file->block, (unsigned long)nblock);\n    /* Log addresses of structures that are passed as non-const pointers */\n    lfs_probe_log(\"[%s] &file->m=%p, &file->cache=%p, &lfs->pcache=%p, &lfs->rcache=%p\",\n            stage, (void*)&file->m, (void*)&file->cache, (void*)&lfs->pcache, (void*)&lfs->rcache);\n}\n\nstatic int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {\n    while (true) {\n        // just relocate what exists into new block\n        lfs_block_t nblock;\n        lfs_probe_dump_file_state(\"entry_alloc\", lfs, file, (lfs_block_t)0);\n\n        int err = lfs_alloc(lfs, &nblock);\n        lfs_probe_log(\"after lfs_alloc: err=%d, nblock=%lu\", err, (unsigned long)nblock);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_bd_erase(lfs, nblock);\n        lfs_probe_log(\"after lfs_bd_erase: err=%d, nblock=%lu\", err, (unsigned long)nblock);\n        if (err) {\n            if (err == LFS_ERR_CORRUPT) {\n                lfs_probe_log(\"lfs_bd_erase returned LFS_ERR_CORRUPT, relocating (nblock=%lu)\", (unsigned long)nblock);\n                goto relocate;\n            }\n            return err;\n        }\n\n        /* either read from dirty cache or disk */\n        for (lfs_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS_F_INLINE) {\n                /* Probe: record that we are taking the inline path and the\n                   exact addresses of the non-const pointers being passed. */\n                lfs_probe_log(\"inline path: iter i=%lld, file->off=%lld\", (long long)i, (long long)file->off);\n                lfs_probe_log(\"inline path: &file->m=%p, &file->cache=%p, offset=(file->off - i)=%lld, id=%u\",\n                        (void*)&file->m, (void*)&file->cache, (long long)(file->off - i), (unsigned)file->id);\n\n                err = lfs_dir_getread(lfs, &file->m,\n                        /* note we evict inline files before they can be dirty */\n                        NULL, &file->cache, file->off-i,\n                        LFS_MKTAG(0xfff, 0x1ff, 0),\n                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n\n                lfs_probe_log(\"after lfs_dir_getread: err=%d, data=0x%02x\", err, (unsigned)data);\n                if (err) {\n                    lfs_probe_log(\"lfs_dir_getread returned err=%d, aborting relocate\", err);\n                    return err;\n                }\n            } else {\n                lfs_probe_log(\"bd_read path: iter i=%lld, file->off=%lld, &file->cache=%p, &lfs->rcache=%p, file->block=%lu\",\n                        (long long)i, (long long)file->off, (void*)&file->cache, (void*)&lfs->rcache, (unsigned long)file->block);\n\n                err = lfs_bd_read(lfs,\n                        &file->cache, &lfs->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                lfs_probe_log(\"after lfs_bd_read: err=%d, data=0x%02x\", err, (unsigned)data);\n                if (err) {\n                    lfs_probe_log(\"lfs_bd_read returned err=%d, aborting relocate\", err);\n                    return err;\n                }\n            }\n\n            err = lfs_bd_prog(lfs,\n                    &lfs->pcache, &lfs->rcache, true,\n                    nblock, i, &data, 1);\n            lfs_probe_log(\"after lfs_bd_prog: err=%d, prog to nblock=%lu, i=%lld, data=0x%02x\",\n                    err, (unsigned long)nblock, (long long)i, (unsigned)data);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    lfs_probe_log(\"lfs_bd_prog returned LFS_ERR_CORRUPT, going to relocate (nblock=%lu)\", (unsigned long)nblock);\n                    goto relocate;\n                }\n                return err;\n            }\n        }\n\n        /* copy over new state of file */\n        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);\n        file->cache.block = lfs->pcache.block;\n        file->cache.off = lfs->pcache.off;\n        file->cache.size = lfs->pcache.size;\n        lfs_cache_zero(lfs, &lfs->pcache);\n\n        file->block = nblock;\n        file->flags |= LFS_F_WRITING;\n\n        lfs_probe_dump_file_state(\"success_exit\", lfs, file, nblock);\n        return 0;\n\nrelocate:\n        LFS_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n        lfs_probe_log(\"relocate: bad block at %lu, dropping pcache and retrying\", (unsigned long)nblock);\n\n        /* just clear cache and try a new block */\n        lfs_cache_drop(lfs, &lfs->pcache);\n    }\n}\n"
}