{
  "user_message": "An agent A claimed that the following lfs_getattr_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_getattr_.\n```c\nstatic lfs_ssize_t lfs_getattr_(lfs_t *lfs, const char *path,\n        uint8_t type, void *buffer, lfs_size_t size) {\n    lfs_mdir_t cwd;\n    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    uint16_t id = lfs_tag_id(tag);\n    if (id == 0x3ff) {\n        // special case for root\n        id = 0;\n        int err = lfs_dir_fetch(lfs, &cwd, lfs->root);\n        if (err) {\n            return err;\n        }\n    }\n\n    tag = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x7ff, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_USERATTR + type,\n                id, lfs_min(size, lfs->attr_max)),\n            buffer);\n    if (tag < 0) {\n        if (tag == LFS_ERR_NOENT) {\n            return LFS_ERR_NOATTR;\n        }\n\n        return tag;\n    }\n\n    return lfs_tag_size(tag);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: lfs_getattr_ passes the address of its parameter 'path' to lfs_dir_find (lfs_dir_find(lfs, &cwd, &path, NULL)). Inside lfs_dir_find the code assigns to *path (e.g. '*path = name;'), which modifies the value of the parameter 'path' in lfs_getattr_. This modifies the pointer parameter itself and therefore violates MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=873464836, requested_type=833, id=1, requested_size=4\nEXIT lfs_getattr_: returning size=4\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=874513414, requested_type=834, id=1, requested_size=6\nEXIT lfs_getattr_: returning size=6\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=875561989, requested_type=835, id=1, requested_size=5\nEXIT lfs_getattr_: returning size=5\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=873464836, requested_type=833, id=1, requested_size=4\nEXIT lfs_getattr_: returning size=4\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=874513408, requested_type=834, id=1, requested_size=6\nEXIT lfs_getattr_: returning size=0\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=875561989, requested_type=835, id=1, requested_size=5\nEXIT lfs_getattr_: returning size=5\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=873464836, requested_type=833, id=1, requested_size=4\nEXIT lfs_getattr_: returning size=4\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=-2, requested_type=834, id=1, requested_size=6\nlfs_getattr_: attribute not found (NOENT), returning LFS_ERR_NOATTR\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=875561989, requested_type=835, id=1, requested_size=5\nEXIT lfs_getattr_: returning size=5\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=873464836, requested_type=833, id=1, requested_size=4\nEXIT lfs_getattr_: returning size=4\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=874513414, requested_type=834, id=1, requested_size=6\nEXIT lfs_getattr_: returning size=6\nENTER lfs_getattr_: lfs=0x7fffde99d2e8, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nAFTER lfs_dir_find: tag=2098181, &path=0x7fffde99d1f0, path=0x55e49e42ed12, path_str=hello\nlfs_getattr_: initial id=1 (from tag)\nAFTER lfs_dir_get: tag=875561989, requested_type=835, id=1, requested_size=5\nEXIT lfs_getattr_: returnin\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_getattr_:\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C:2023 Rule 17.8 forbids modifying a function parameter itself (the pointer), although the object it points to may be modified. lfs_getattr_ passes &path (the address of its parameter variable) to lfs_dir_find. The implementation of lfs_dir_find assigns to *path (e.g. \"*path = name;\"), which writes to the lfs_getattr_ parameter variable and therefore modifies the pointer parameter. That violates Rule 17.8. Note that even if in observed runs the pointer value happens to stay the same, the code performs an assignment to the parameter (via the calle), which is what MISRA prohibits. A typical fix is to make a local copy (e.g. const char *local_path = path;) and pass &local_path to lfs_dir_find so the original parameter is not modified."
}