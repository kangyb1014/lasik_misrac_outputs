{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe callback parameter 'data' is declared as a non-const void* but is only read from (cast to struct lfs_dir_find_match* and not modified). According to Rule 8.13 this pointer should be to a const-qualified type (e.g. const void *data or const struct lfs_dir_find_match *), so the current declaration violates the rule unless constrained by an external API requiring the non-const signature.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_mount_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/983.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_mount_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_mount_:\n```c\nstatic int lfs_mount_(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = lfs_init(lfs, cfg);\n    if (err) {\n        return err;\n    }\n\n    // scan directory blocks for superblock and any global updates\n    lfs_mdir_t dir = {.tail = {0, 1}};\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    while (!lfs_pair_isnull(dir.tail)) {\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        if (err < 0) {\n            goto cleanup;\n        }\n\n        // fetch next block in tail list\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,\n                LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),\n                NULL,\n                lfs_dir_find_match, &(struct lfs_dir_find_match){\n                    lfs, \"littlefs\", 8});\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n\n        // has superblock?\n        if (tag && !lfs_tag_isdelete(tag)) {\n            // update root\n            lfs->root[0] = dir.pair[0];\n            lfs->root[1] = dir.pair[1];\n\n            // grab superblock\n            lfs_superblock_t superblock;\n            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock);\n            if (tag < 0) {\n                err = tag;\n                goto cleanup;\n            }\n            lfs_superblock_fromle32(&superblock);\n\n            // check version\n            uint16_t major_version = (0xffff & (superblock.version >> 16));\n            uint16_t minor_version = (0xffff & (superblock.version >>  0));\n            if (major_version != lfs_fs_disk_version_major(lfs)\n                    || minor_version > lfs_fs_disk_version_minor(lfs)) {\n                LFS_ERROR(\"Invalid version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" != v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            // found older minor version? set an in-device only bit in the\n            // gstate so we know we need to rewrite the superblock before\n            // the first write\n            bool needssuperblock = false;\n            if (minor_version < lfs_fs_disk_version_minor(lfs)) {\n                LFS_DEBUG(\"Found older minor version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" < v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                needssuperblock = true;\n            }\n            // note this bit is reserved on disk, so fetching more gstate\n            // will not interfere here\n            lfs_fs_prepsuperblock(lfs, needssuperblock);\n\n            // check superblock configuration\n            if (superblock.name_max) {\n                if (superblock.name_max > lfs->name_max) {\n                    LFS_ERROR(\"Unsupported name_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.name_max, lfs->name_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->name_max = superblock.name_max;\n            }\n\n            if (superblock.file_max) {\n                if (superblock.file_max > lfs->file_max) {\n                    LFS_ERROR(\"Unsupported file_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.file_max, lfs->file_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->file_max = superblock.file_max;\n            }\n\n            if (superblock.attr_max) {\n                if (superblock.attr_max > lfs->attr_max) {\n                    LFS_ERROR(\"Unsupported attr_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.attr_max, lfs->attr_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->attr_max = superblock.attr_max;\n\n                // we also need to update inline_max in case attr_max changed\n                lfs->inline_max = lfs_min(lfs->inline_max, lfs->attr_max);\n            }\n\n            // this is where we get the block_count from disk if block_count=0\n            if (lfs->cfg->block_count\n                    && superblock.block_count != lfs->cfg->block_count) {\n                LFS_ERROR(\"Invalid block count (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_count, lfs->cfg->block_count);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            lfs->block_count = superblock.block_count;\n\n            if (superblock.block_size != lfs->cfg->block_size) {\n                LFS_ERROR(\"Invalid block size (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_size, lfs->cfg->block_size);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n        }\n\n        // has gstate?\n        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);\n        if (err) {\n            goto cleanup;\n        }\n    }\n\n    // update littlefs with gstate\n    if (!lfs_gstate_iszero(&lfs->gstate)) {\n        LFS_DEBUG(\"Found pending gstate 0x%08\"PRIx32\"%08\"PRIx32\"%08\"PRIx32,\n                lfs->gstate.tag,\n                lfs->gstate.pair[0],\n                lfs->gstate.pair[1]);\n    }\n    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);\n    lfs->gdisk = lfs->gstate;\n\n    // setup free lookahead, to distribute allocations uniformly across\n    // boots, we start the allocator at a random location\n    lfs->lookahead.start = lfs->seed % lfs->block_count;\n    lfs_alloc_drop(lfs);\n\n    return 0;\n\ncleanup:\n    lfs_unmount_(lfs);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_mount_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n\n/* Probe logging helpers for reproducing the Rule 8.13 scenario. */\nstatic void lfs_mount_logf(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/983.txt\", \"a\");\n    if (!f) return;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void lfs_mount_log_header(const char *stage, const void *lfs, const void *cfg)\n{\n    lfs_mount_logf(\"[lfs_mount_] stage=%s lfs=%p cfg=%p\", stage, lfs, cfg);\n}\n\nstatic void lfs_mount_log_dir_tail(const lfs_mdir_t *dir)\n{\n    lfs_mount_logf(\"[lfs_mount_] dir.tail pair=[%\" PRIu32 \", %\" PRIu32 \"]\", dir->tail[0], dir->tail[1]);\n}\n\nstatic void lfs_mount_log_tortoise(const struct lfs_tortoise_t *t)\n{\n    lfs_mount_logf(\"[lfs_mount_] tortoise.pair=[%\" PRIu32 \", %\" PRIu32 \"] i=%u period=%u\",\n            t->pair[0], t->pair[1], (unsigned)t->i, (unsigned)t->period);\n}\n\n/* Modified lfs_mount_ with probes inserted to log control flow and state. */\nstatic int lfs_mount_(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = lfs_init(lfs, cfg);\n    lfs_mount_log_header(\"after_lfs_init\", lfs, cfg);\n    if (err) {\n        lfs_mount_logf(\"[lfs_mount_] lfs_init failed err=%d\", err);\n        return err;\n    }\n\n    // scan directory blocks for superblock and any global updates\n    lfs_mdir_t dir = {.tail = {0, 1}};\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    while (!lfs_pair_isnull(dir.tail)) {\n        lfs_mount_logf(\"[lfs_mount_] loop start\");\n        lfs_mount_log_dir_tail(&dir);\n        lfs_mount_log_tortoise(&tortoise);\n\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        lfs_mount_logf(\"[lfs_mount_] lfs_tortoise_detectcycles returned %d\", err);\n        if (err < 0) {\n            lfs_mount_logf(\"[lfs_mount_] error from tortoise_detectcycles, goto cleanup\");\n            goto cleanup;\n        }\n\n        // create match structure locally so we can log its address and contents\n        struct lfs_dir_find_match match = { lfs, \"littlefs\", 8 };\n        lfs_mount_logf(\"[lfs_mount_] calling lfs_dir_fetchmatch with match=%p match.lfs=%p match.name=%p match.name_len=%u\",\n                (void*)&match, (void*)match.lfs, (void*)match.name, (unsigned)match.name_len);\n        lfs_mount_logf(\"[lfs_mount_] match.name string=\\\"%s\\\"\", match.name ? match.name : \"(null)\");\n\n        // fetch next block in tail list\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,\n                LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),\n                NULL,\n                lfs_dir_find_match, &match);\n        lfs_mount_logf(\"[lfs_mount_] lfs_dir_fetchmatch returned tag=%d\", (int)tag);\n        if (tag < 0) {\n            err = tag;\n            lfs_mount_logf(\"[lfs_mount_] lfs_dir_fetchmatch error err=%d, goto cleanup\", err);\n            goto cleanup;\n        }\n\n        // has superblock?\n        if (tag && !lfs_tag_isdelete(tag)) {\n            lfs_mount_logf(\"[lfs_mount_] found superblock tag=%d\", (int)tag);\n            // update root\n            lfs->root[0] = dir.pair[0];\n            lfs->root[1] = dir.pair[1];\n            lfs_mount_logf(\"[lfs_mount_] updated root to [%\" PRIu32 \", %\" PRIu32 \"]\",\n                    lfs->root[0], lfs->root[1]);\n\n            // grab superblock\n            lfs_superblock_t superblock;\n            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock);\n            lfs_mount_logf(\"[lfs_mount_] lfs_dir_get returned tag=%d\", (int)tag);\n            if (tag < 0) {\n                err = tag;\n                lfs_mount_logf(\"[lfs_mount_] lfs_dir_get error err=%d, goto cleanup\", err);\n                goto cleanup;\n            }\n            lfs_superblock_fromle32(&superblock);\n\n            // check version\n            uint16_t major_version = (0xffff & (superblock.version >> 16));\n            uint16_t minor_version = (0xffff & (superblock.version >>  0));\n            lfs_mount_logf(\"[lfs_mount_] superblock.version=0x%08\" PRIx32 \" major=%\" PRIu16 \" minor=%\" PRIu16,\n                    superblock.version, major_version, minor_version);\n            if (major_version != lfs_fs_disk_version_major(lfs)\n                    || minor_version > lfs_fs_disk_version_minor(lfs)) {\n                LFS_ERROR(\"Invalid version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" != v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                lfs_mount_logf(\"[lfs_mount_] invalid version, goto cleanup\");\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            // found older minor version? set an in-device only bit in the\n            // gstate so we know we need to rewrite the superblock before\n            // the first write\n            bool needssuperblock = false;\n            if (minor_version < lfs_fs_disk_version_minor(lfs)) {\n                LFS_DEBUG(\"Found older minor version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" < v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                needssuperblock = true;\n                lfs_mount_logf(\"[lfs_mount_] older minor version detected: needssuperblock=true\");\n            }\n            // note this bit is reserved on disk, so fetching more gstate\n            // will not interfere here\n            lfs_fs_prepsuperblock(lfs, needssuperblock);\n\n            // check superblock configuration\n            if (superblock.name_max) {\n                if (superblock.name_max > lfs->name_max) {\n                    LFS_ERROR(\"Unsupported name_max (%%\"PRIu32\" > %%\"PRIu32\")\",\n                            superblock.name_max, lfs->name_max);\n                    err = LFS_ERR_INVAL;\n                    lfs_mount_logf(\"[lfs_mount_] Unsupported name_max, goto cleanup\");\n                    goto cleanup;\n                }\n\n                lfs->name_max = superblock.name_max;\n                lfs_mount_logf(\"[lfs_mount_] updated name_max=%\" PRIu32, lfs->name_max);\n            }\n\n            if (superblock.file_max) {\n                if (superblock.file_max > lfs->file_max) {\n                    LFS_ERROR(\"Unsupported file_max (%%\"PRIu32\" > %%\"PRIu32\")\",\n                            superblock.file_max, lfs->file_max);\n                    err = LFS_ERR_INVAL;\n                    lfs_mount_logf(\"[lfs_mount_] Unsupported file_max, goto cleanup\");\n                    goto cleanup;\n                }\n\n                lfs->file_max = superblock.file_max;\n                lfs_mount_logf(\"[lfs_mount_] updated file_max=%\" PRIu32, lfs->file_max);\n            }\n\n            if (superblock.attr_max) {\n                if (superblock.attr_max > lfs->attr_max) {\n                    LFS_ERROR(\"Unsupported attr_max (%%\"PRIu32\" > %%\"PRIu32\")\",\n                            superblock.attr_max, lfs->attr_max);\n                    err = LFS_ERR_INVAL;\n                    lfs_mount_logf(\"[lfs_mount_] Unsupported attr_max, goto cleanup\");\n                    goto cleanup;\n                }\n\n                lfs->attr_max = superblock.attr_max;\n                lfs->inline_max = lfs_min(lfs->inline_max, lfs->attr_max);\n                lfs_mount_logf(\"[lfs_mount_] updated attr_max=%\" PRIu32 \" inline_max=%\" PRIu32,\n                        lfs->attr_max, lfs->inline_max);\n            }\n\n            // this is where we get the block_count from disk if block_count=0\n            if (lfs->cfg->block_count\n                    && superblock.block_count != lfs->cfg->block_count) {\n                LFS_ERROR(\"Invalid block count (%%\"PRIu32\" != %%\"PRIu32\")\",\n                        superblock.block_count, lfs->cfg->block_count);\n                err = LFS_ERR_INVAL;\n                lfs_mount_logf(\"[lfs_mount_] Invalid block count, goto cleanup\");\n                goto cleanup;\n            }\n\n            lfs->block_count = superblock.block_count;\n            lfs_mount_logf(\"[lfs_mount_] set block_count=%\" PRIu32, lfs->block_count);\n\n            if (superblock.block_size != lfs->cfg->block_size) {\n                LFS_ERROR(\"Invalid block size (%%\"PRIu32\" != %%\"PRIu32\")\",\n                        superblock.block_size, lfs->cfg->block_size);\n                err = LFS_ERR_INVAL;\n                lfs_mount_logf(\"[lfs_mount_] Invalid block size, goto cleanup\");\n                goto cleanup;\n            }\n        }\n\n        // has gstate?\n        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);\n        lfs_mount_logf(\"[lfs_mount_] lfs_dir_getgstate returned err=%d\", err);\n        if (err) {\n            lfs_mount_logf(\"[lfs_mount_] error from lfs_dir_getgstate, goto cleanup\");\n            goto cleanup;\n        }\n    }\n\n    // update littlefs with gstate\n    if (!lfs_gstate_iszero(&lfs->gstate)) {\n        LFS_DEBUG(\"Found pending gstate 0x%08\"PRIx32\"%08\"PRIx32\"%08\"PRIx32,\n                lfs->gstate.tag,\n                lfs->gstate.pair[0],\n                lfs->gstate.pair[1]);\n        lfs_mount_logf(\"[lfs_mount_] Found pending gstate tag=0x%08\" PRIx32 \" pair=[%\" PRIu32 \", %\" PRIu32 \"]\",\n                lfs->gstate.tag, lfs->gstate.pair[0], lfs->gstate.pair[1]);\n    }\n    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);\n    lfs->gdisk = lfs->gstate;\n    lfs_mount_logf(\"[lfs_mount_] finalized gstate.tag=0x%08\" PRIx32, lfs->gstate.tag);\n\n    // setup free lookahead, to distribute allocations uniformly across\n    // boots, we start the allocator at a random location\n    lfs->lookahead.start = lfs->seed % lfs->block_count;\n    lfs_mount_logf(\"[lfs_mount_] lookahead.start=%\" PRIu32 \" seed=%\" PRIu32 \" block_count=%\" PRIu32,\n            lfs->lookahead.start, lfs->seed, lfs->block_count);\n    lfs_alloc_drop(lfs);\n\n    lfs_mount_logf(\"[lfs_mount_] mount completed successfully\");\n    return 0;\n\ncleanup:\n    lfs_mount_logf(\"[lfs_mount_] cleanup: calling lfs_unmount_ and returning err=%d\", err);\n    lfs_unmount_(lfs);\n    return err;\n}\n"
}