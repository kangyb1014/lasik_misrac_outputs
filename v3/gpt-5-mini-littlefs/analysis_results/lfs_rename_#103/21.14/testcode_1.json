{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nIn lfs_dir_find the code compares a path component against the literal \"..\" using memcmp(suffix, \"..\", 2) (also similar uses for \".\" elsewhere). This uses memcmp to compare a C string literal (null\u2011terminated string) against a path substring and therefore violates MISRA C 2023 Rule 21.14. Replace with strncmp(suffix, \"..\", 2) or an explicit character comparison (e.g. suffix[0]=='.' && suffix[1]=='.') to comply.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_rename_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1038.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_rename_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_rename_:\n```c\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        // if we're a file, don't allow trailing slashes\n        if (lfs_path_isdir(newpath)\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        if (nlen > lfs->name_max) {\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            newoldid += 1;\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        if (err) {\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        if (err) {\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    if (err) {\n        lfs->mlist = prevdir.next;\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        // prep gstate and delete move id\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        if (err) {\n            lfs->mlist = prevdir.next;\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_rename_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n/* Probe logging helper: append formatted logs to /tmp/logs/1038.txt */\nstatic void log_probe(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/1038.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fclose(f);\n}\n\nstatic int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {\n    log_probe(\"ENTER lfs_rename_: lfs=%p oldpath='%s' newpath='%s'\\n\",\n            (void*)lfs, (oldpath ? oldpath : \"(null)\"), (newpath ? newpath : \"(null)\"));\n\n    // deorphan if we haven't yet, needed at most once after poweron\n    int err = lfs_fs_forceconsistency(lfs);\n    log_probe(\"after lfs_fs_forceconsistency: err=%d\\n\", err);\n    if (err) {\n        log_probe(\"EXIT lfs_rename_ early (forceconsistency error): %d\\n\", err);\n        return err;\n    }\n\n    // find old entry\n    lfs_mdir_t oldcwd;\n    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);\n    log_probe(\"after lfs_dir_find (old): oldtag=%lld oldpath='%s'\\n\",\n            (long long)oldtag, (oldpath ? oldpath : \"(null)\"));\n    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {\n        int r = (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;\n        log_probe(\"EXIT lfs_rename_ early (old entry invalid): oldtag=%lld tag_id=%u return=%d\\n\",\n                (long long)oldtag, (unsigned)lfs_tag_id(oldtag), r);\n        return r;\n    }\n\n    // find new entry\n    lfs_mdir_t newcwd;\n    uint16_t newid;\n    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);\n    log_probe(\"after lfs_dir_find (new): prevtag=%lld newid=%u newpath='%s'\\n\",\n            (long long)prevtag, (unsigned)newid, (newpath ? newpath : \"(null)\"));\n    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {\n        int r = (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;\n        log_probe(\"EXIT lfs_rename_ early (new entry invalid): prevtag=%lld tag_id=%u return=%d\\n\",\n                (long long)prevtag, (unsigned)lfs_tag_id(prevtag), r);\n        return r;\n    }\n\n    // if we're in the same pair there's a few special cases...\n    bool samepair = (lfs_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs_tag_id(oldtag);\n    log_probe(\"computed samepair=%d newoldid=%u newid=%u\\n\",\n            samepair ? 1 : 0, (unsigned)newoldid, (unsigned)newid);\n\n    struct lfs_mlist prevdir;\n    prevdir.next = lfs->mlist;\n    if (prevtag == LFS_ERR_NOENT) {\n        log_probe(\"prevtag == LFS_ERR_NOENT: newpath='%s'\\n\", (newpath ? newpath : \"(null)\"));\n        // if we're a file, don't allow trailing slashes\n        if (lfs_path_isdir(newpath)\n                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {\n            log_probe(\"EXIT lfs_rename_ (not a dir): newpath is dir but oldtag type is not dir\\n\");\n            return LFS_ERR_NOTDIR;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(newpath);\n        log_probe(\"name length nlen=%llu name_max=%u\\n\", (unsigned long long)nlen, (unsigned)lfs->name_max);\n        if (nlen > lfs->name_max) {\n            log_probe(\"EXIT lfs_rename_ (nametoolong): nlen=%llu > name_max=%u\\n\",\n                    (unsigned long long)nlen, (unsigned)lfs->name_max);\n            return LFS_ERR_NAMETOOLONG;\n        }\n\n        // there is a small chance we are being renamed in the same\n        // directory/ to an id less than our old id, the global update\n        // to handle this is a bit messy\n        if (samepair && newid <= newoldid) {\n            log_probe(\"adjusting newoldid: before=%u newid=%u\\n\", (unsigned)newoldid, (unsigned)newid);\n            newoldid += 1;\n            log_probe(\"adjusting newoldid: after=%u\\n\", (unsigned)newoldid);\n        }\n    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {\n        log_probe(\"EXIT lfs_rename_ (type mismatch): prevtype=%u oldtype=%u\\n\",\n                (unsigned)lfs_tag_type3(prevtag), (unsigned)lfs_tag_type3(oldtag));\n        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)\n                ? LFS_ERR_ISDIR\n                : LFS_ERR_NOTDIR;\n    } else if (samepair && newid == newoldid) {\n        // we're renaming to ourselves??\n        log_probe(\"EXIT lfs_rename_ (rename to self): samepair=1 newid==newoldid=%u\\n\", (unsigned)newid);\n        return 0;\n    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {\n        log_probe(\"prevtag refers to dir: need to check emptiness, newid=%u\\n\", (unsigned)newid);\n        // must be empty before removal\n        lfs_block_t prevpair[2];\n        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);\n        log_probe(\"after lfs_dir_get: res=%lld\\n\", (long long)res);\n        if (res < 0) {\n            log_probe(\"EXIT lfs_rename_ (dir_get error): res=%lld\\n\", (long long)res);\n            return (int)res;\n        }\n        lfs_pair_fromle32(prevpair);\n\n        // must be empty before removal\n        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);\n        log_probe(\"after lfs_dir_fetch: err=%d prevdir.count=%u prevdir.split=%d\\n\",\n                err, (unsigned)prevdir.m.count, prevdir.m.split ? 1 : 0);\n        if (err) {\n            log_probe(\"EXIT lfs_rename_ (dir_fetch error): %d\\n\", err);\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            log_probe(\"EXIT lfs_rename_ (not empty): count=%u split=%d\\n\",\n                    (unsigned)prevdir.m.count, prevdir.m.split ? 1 : 0);\n            return LFS_ERR_NOTEMPTY;\n        }\n\n        // mark fs as orphaned\n        err = lfs_fs_preporphans(lfs, +1);\n        log_probe(\"after lfs_fs_preporphans(+1): err=%d\\n\", err);\n        if (err) {\n            log_probe(\"EXIT lfs_rename_ (preporphans +1 error): %d\\n\", err);\n            return err;\n        }\n\n        // I know it's crazy but yes, dir can be changed by our parent's\n        // commit (if predecessor is child)\n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs->mlist = &prevdir;\n        log_probe(\"set lfs->mlist to prevdir (for orphan handling)\\n\");\n    }\n\n    if (!samepair) {\n        log_probe(\"calling lfs_fs_prepmove: newoldid=%u oldcwd.pair=%p\\n\",\n                (unsigned)newoldid, (void*)oldcwd.pair);\n        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);\n    }\n\n    // move over all attributes\n    log_probe(\"about to call lfs_dir_commit (move attrs): samepair=%d newid=%u newoldid=%u\\n\",\n            samepair ? 1 : 0, (unsigned)newid, (unsigned)newoldid);\n    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(\n            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,\n                LFS_TYPE_DELETE, newid, 0), NULL},\n            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},\n            {LFS_MKTAG(lfs_tag_type3(oldtag),\n                newid, lfs_path_namelen(newpath)), newpath},\n            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},\n            {LFS_MKTAG_IF(samepair,\n                LFS_TYPE_DELETE, newoldid, 0), NULL}));\n    log_probe(\"after lfs_dir_commit (move attrs): err=%d\\n\", err);\n    if (err) {\n        lfs->mlist = prevdir.next;\n        log_probe(\"EXIT lfs_rename_ (commit error, rollback mlist): err=%d\\n\", err);\n        return err;\n    }\n\n    // let commit clean up after move (if we're different! otherwise move\n    // logic already fixed it for us)\n    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {\n        log_probe(\"post-commit: handling global move cleanup\\n\");\n        // prep gstate and delete move id\n        lfs_fs_prepmove(lfs, 0x3ff, NULL);\n        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));\n        log_probe(\"after cleanup lfs_dir_commit: err=%d\\n\", err);\n        if (err) {\n            lfs->mlist = prevdir.next;\n            log_probe(\"EXIT lfs_rename_ (cleanup commit error, rollback mlist): err=%d\\n\", err);\n            return err;\n        }\n    }\n\n    lfs->mlist = prevdir.next;\n    log_probe(\"restored lfs->mlist to prevdir.next, checking orphans state\\n\");\n    if (lfs_gstate_hasorphans(&lfs->gstate)) {\n        LFS_ASSERT(prevtag != LFS_ERR_NOENT\n                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);\n\n        // fix orphan\n        err = lfs_fs_preporphans(lfs, -1);\n        log_probe(\"after lfs_fs_preporphans(-1): err=%d\\n\", err);\n        if (err) {\n            log_probe(\"EXIT lfs_rename_ (preporphans -1 error): %d\\n\", err);\n            return err;\n        }\n\n        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);\n        log_probe(\"after lfs_fs_pred: err=%d\\n\", err);\n        if (err) {\n            log_probe(\"EXIT lfs_rename_ (fs_pred error): %d\\n\", err);\n            return err;\n        }\n\n        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);\n        log_probe(\"after lfs_dir_drop: err=%d\\n\", err);\n        if (err) {\n            log_probe(\"EXIT lfs_rename_ (dir_drop error): %d\\n\", err);\n            return err;\n        }\n    }\n\n    log_probe(\"EXIT lfs_rename_ success: return=0\\n\");\n    return 0;\n}\n"
}