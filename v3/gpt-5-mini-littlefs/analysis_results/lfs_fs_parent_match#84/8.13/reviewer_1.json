{
  "user_message": "An agent A claimed that the following lfs_fs_parent_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_parent_match.\n```c\nstatic int lfs_fs_parent_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_fs_parent_match *find = data;\n    lfs_t *lfs = find->lfs;\n    const struct lfs_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs_block_t child[2];\n    int err = lfs_bd_read(lfs,\n            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs_pair_fromle32(child);\n    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'data' is declared as void * and is assigned to 'struct lfs_fs_parent_match *find'. The function only reads from 'find' (accesses find->lfs and find->pair) and does not modify it, so the pointer should be to a const-qualified type. Correct form would be e.g. const struct lfs_fs_parent_match *find = data; with the parameter changed to const void *data (or the cast used accordingly).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=2 child[1]=3\nchild after le32: child[0]=2 child[1]=3\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536870920\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=4 child[1]=5\nchild after le32: child[0]=4 child[1]=5\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=7 child[1]=8\nchild after le32: child[0]=7 child[1]=8\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536870920\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=10 child[1]=11\nchild after le32: child[0]=10 child[1]=11\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=15 child[1]=16\nchild after le32: child[0]=15 child[1]=16\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536872968\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=18 child[1]=19\nchild after le32: child[0]=18 child[1]=19\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536873992\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=23 child[1]=24\nchild after le32: child[0]=23 child[1]=24\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=28 child[1]=29\nchild after le32: child[0]=28 child[1]=29\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536870920\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=30 child[1]=31\nchild after le32: child[0]=30 child[1]=31\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=33 child[1]=34\nchild after le32: child[0]=33 child[1]=34\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536870920\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=36 child[1]=37\nchild after le32: child[0]=36 child[1]=37\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d910, tag=536871944\ncalling lfs_bd_read: block_size=512\nlfs_bd_read returned err=0\nchild before le32: child[0]=41 child[1]=42\nchild after le32: child[0]=41 child[1]=42\nlfs_pair_cmp -> returning 1\nlfs_fs_parent_match: entry data=0x7ffcc5f3d988 find=0x7ffcc5f3d988\nfind->lfs=0x7ffcc5f3dcc0, &find->pair=0x7ffcc5f3d990\ndisk=0x7ffcc5f3d\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_parent_match:\ntypedef uint32_t lfs_block_t\n...\nstruct lfs_diskoff {\n    lfs_block_t block;\n    lfs_off_t off;\n}\n...\ntypedef uint32_t lfs_tag_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is plausible (the function only reads through the passed-in context), but it is not necessarily a MISRA 8.13 violation in this spot. Rule 8.13 asks that pointers point to const-qualified types when that is possible; however whether it is \"possible\" depends on the required function prototype and how this callback is used. lfs_fs_parent_match has the conventional callback form (void *data, lfs_tag_t, const void *buffer). If that prototype is mandated by the caller (i.e. the callback type expects a void *context), you cannot change the parameter to const void * without breaking the required signature. In that case the non-const void * is intentional and appropriate, and no violation is caused here. Conversely, if this function is not constrained by an external callback type and the context is known never to be modified, then making the parameter and the derived pointer const would satisfy 8.13. Given the provided code and no evidence that the function signature can be changed (and given the common callback pattern), the agent\u2019s report is not necessarily correct."
}