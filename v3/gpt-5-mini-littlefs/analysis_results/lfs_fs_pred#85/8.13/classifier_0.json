{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_fs_pred:\n```c\nstatic int lfs_fs_pred(lfs_t *lfs,\n        const lfs_block_t pair[2], lfs_mdir_t *pdir) {\n    // iterate over all directory directory entries\n    pdir->tail[0] = 0;\n    pdir->tail[1] = 1;\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(pdir->tail)) {\n        err = lfs_tortoise_detectcycles(pdir, &tortoise);\n        if (err < 0) {\n            return LFS_ERR_CORRUPT;\n        }\n\n        if (lfs_pair_cmp(pdir->tail, pair) == 0) {\n            return 0;\n        }\n\n        int err = lfs_dir_fetch(lfs, pdir, pdir->tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_pred:\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef uint32_t lfs_block_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\nstruct lfs_tortoise_t {\n    lfs_block_t pair[2];\n    lfs_size_t i;\n    lfs_size_t period;\n}\n...\n#define LFS_BLOCK_NULL ((lfs_block_t)-1)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic int lfs_fs_pred(lfs_t *lfs,\n        const lfs_block_t pair[2], lfs_mdir_t *pdir) {\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the pointer parameters are correctly qualified. The array parameter pair is declared const (const lfs_block_t pair[2]). The lfs_t *lfs and lfs_mdir_t *pdir parameters must be non-const because the function and called helpers modify state (pdir->tail is assigned in this function and pdir is passed to lfs_dir_fetch/lfs_tortoise_detectcycles which operate on/modify the directory structure; lfs is passed to lfs_dir_fetch which typically mutates filesystem state). Therefore no additional const qualification is possible here."
}