{
  "user_message": "An agent A claimed that the following lfs_dir_find code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_find.\n```c\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls memcmp(name, \".\", 1) to compare against the null\u2011terminated string literal \".\". MISRA C 2023 Rule 21.14 prohibits using memcmp to compare null\u2011terminated strings; even though a length of 1 is given, a null\u2011terminated string literal is being used as the comparison operand, so this usage violates the rule. (Similar occurrences: memcmp(suffix, \"..\", 2).)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_dir_find: name_ptr=0x562aa3ae506a full_name=\"breakfast\"\nTAG is DIR: tag=3144704, skipping leading slashes at name_ptr=0x562aa3ae506a\nAfter skip slashes name_ptr=0x562aa3ae506a nextchars=\"breakfast\"\nComputed namelen=9 for name_ptr=0x562aa3ae506a (next 9 chars=\"breakfast\")\nSuffix scan ended (no more components). depth=1 suffix_ptr=0x562aa3ae5073\nUpdated path pointer to name_ptr=0x562aa3ae506a remaining=\"breakfast\"\nCalling lfs_dir_fetchmatch for name_ptr=0x562aa3ae506a namelen=9\nlfs_dir_fetchmatch returned tag=0\nNo match and not split -> LFS_ERR_NOENT\nENTER lfs_dir_find: name_ptr=0x7fff583ae8e8 full_name=\"breakfast/bacon\"\nTAG is DIR: tag=3144704, skipping leading slashes at name_ptr=0x7fff583ae8e8\nAfter skip slashes name_ptr=0x7fff583ae8e8 nextchars=\"breakfast/bacon\"\nComputed namelen=9 for name_ptr=0x7fff583ae8e8 (next 9 chars=\"breakfast\")\nSuffix normal component at ptr=0x7fff583ae8f2 len=5 -> incrementing depth from 1 to 2\nSuffix scan ended (no more components). depth=2 suffix_ptr=0x7fff583ae8f7\nUpdated path pointer to name_ptr=0x7fff583ae8e8 remaining=\"breakfast/bacon\"\nCalling lfs_dir_fetchmatch for name_ptr=0x7fff583ae8e8 namelen=9\nlfs_dir_fetchmatch returned tag=2098185\nFound matching entry: tag=2098185 id=1\nAdvancing to next name component, new name_ptr=0x7fff583ae8f1 nextchars=\"/bacon\"\nTAG is DIR: tag=2098185, skipping leading slashes at name_ptr=0x7fff583ae8f1\nAfter skip slashes name_ptr=0x7fff583ae8f2 nextchars=\"bacon\"\nComputed namelen=5 for name_ptr=0x7fff583ae8f2 (next 5 chars=\"bacon\")\nSuffix scan ended (no more components). depth=1 suffix_ptr=0x7fff583ae8f7\nUpdated path pointer to name_ptr=0x7fff583ae8f2 remaining=\"bacon\"\nFetching entry data for tag_id=1\nlfs_dir_get returned 536871944\nCalling lfs_dir_fetchmatch for name_ptr=0x7fff583ae8f2 namelen=5\nlfs_dir_fetchmatch returned tag=0\nNo match and not split -> LFS_ERR_NOENT\nENTER lfs_dir_find: name_ptr=0x7fff583ae8e8 full_name=\"breakfast/eggs\"\nTAG is DIR: tag=3144704, skipping leading slashes at name_ptr=0x7fff583ae8e8\nAfter skip slashes name_ptr=0x7fff583ae8e8 nextchars=\"breakfast/eggs\"\nComputed namelen=9 for name_ptr=0x7fff583ae8e8 (next 9 chars=\"breakfast\")\nSuffix normal component at ptr=0x7fff583ae8f2 len=4 -> incrementing depth from 1 to 2\nSuffix scan ended (no more components). depth=2 suffix_ptr=0x7fff583ae8f6\nUpdated path pointer to name_ptr=0x7fff583ae8e8 remaining=\"breakfast/eggs\"\nCalling lfs_dir_fetchmatch for name_ptr=0x7fff583ae8e8 namelen=9\nlfs_dir_fetchmatch returned tag=2098185\nFound matching entry: tag=2098185 id=1\nAdvancing to next name component, new name_ptr=0x7fff583ae8f1 nextchars=\"/eggs\"\nTAG is DIR: tag=2098185, skipping leading slashes at name_ptr=0x7fff583ae8f1\nAfter skip slashes name_ptr=0x7fff583ae8f2 nextchars=\"eggs\"\nComputed namelen=4 for name_ptr=0x7fff583ae8f2 (next 4 chars=\"eggs\")\nSuffix scan ended (no more components). depth=1 suffix_ptr=0x7fff583ae8f6\nUpdated path pointer to name_ptr=0x7fff583ae8f2 remaining=\"eggs\"\nFetching entry data for tag_id=1\nlfs_dir_get returned 536871944\nCalling lfs_dir_fetchmatch for name_ptr=0x7fff583ae8f2 namelen=4\nlfs_dir_fetchmatch returned tag=0\nNo match and not split -> LFS_ERR_NOENT\nENTER lfs_dir_find: name_ptr=0x7fff583ae8e8 full_name=\"breakfast/pancakes\"\nTAG is DIR: tag=3144704, skipping leading slashes at name_ptr=0x7fff583ae8e8\nAfter skip slashes name_ptr=0x7fff583ae8e8 nextchars=\"breakfast/pancakes\"\nComputed namelen=9 for name_ptr=0x7fff583ae8e8 (next 9 chars=\"breakfast\")\nSuffix normal component at ptr=0x7fff583ae8f2 len=8 -> incrementing depth from 1 to 2\nSuffix scan ended (no more components). depth=2 suffix_ptr=0x7fff583ae8fa\nUpdated path pointer to name_ptr=0x7fff583ae8e8 remaining=\"breakfast/pancakes\"\nCalling lfs_dir_fetchmatch for name_ptr=0x7fff583ae8e8 namelen=9\nlfs_dir_fetchmatch returned tag=2098185\nFound matching entry: tag=2098185 id=1\nAdvancing to next name component, new name_ptr=0x7fff583ae8f1 nextchars=\"/pancakes\"\nTAG is DIR: tag=2098185, skipping leading slashes at name_ptr=0x7fff583ae8f1\nAfter skip slashes name_ptr=0x7fff583ae8f2 nextchars=\"pancakes\"\nComputed namelen=8\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C:2023 Rule 21.14 states that memcmp shall not be used to compare null\u2011terminated strings. In the snippet memcmp(name, \".\", 1) and memcmp(name, \"..\", 2) are comparing against string literals \".\" and \"..\" which are null\u2011terminated objects. Even though a fixed length (1 or 2) is supplied and the code is operating on path components (namelen), the use of memcmp with a null\u2011terminated string literal falls squarely under the prohibition in R.21.14. Recommended fixes are to use character comparisons (e.g. namelen==1 && name[0]=='.', namelen==2 && name[0]=='.' && name[1]=='.') or the appropriate string function such as strncmp with proper length checks, rather than memcmp."
}