{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_getinfo:\n```c\nstatic int lfs_dir_getinfo(lfs_t *lfs, lfs_mdir_t *dir,\n        uint16_t id, struct lfs_info *info) {\n    if (id == 0x3ff) {\n        // special case for root\n        strcpy(info->name, \"/\");\n        info->type = LFS_TYPE_DIR;\n        return 0;\n    }\n\n    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    info->type = lfs_tag_type3(tag);\n\n    struct lfs_ctz ctz;\n    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n    if (tag < 0) {\n        return (int)tag;\n    }\n    lfs_ctz_fromle32(&ctz);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {\n        info->size = ctz.size;\n    } else if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        info->size = lfs_tag_size(tag);\n    }\n\n    return 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_getinfo:\nstruct lfs_info {\n    // Type of the file, either LFS_TYPE_REG or LFS_TYPE_DIR\n    uint8_t type;\n\n    // Size of the file, only valid for REG files. Limited to 32-bits.\n    lfs_size_t size;\n\n    // Name of the file stored as a null-terminated string. Limited to\n    // LFS_NAME_MAX+1, which can be changed by redefining LFS_NAME_MAX to\n    // reduce RAM. LFS_NAME_MAX is stored in superblock and must be\n    // respected by other littlefs drivers.\n    char name[LFS_NAME_MAX+1];\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic int lfs_dir_read_(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    memset(info, 0, sizeof(*info));\n\n    // special offset for '.' and '..'\n    if (dir->pos == 0) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \".\");\n        dir->pos += 1;\n        return true;\n    } else if (dir->pos == 1) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \"..\");\n        dir->pos += 1;\n        return true;\n    }\n\n    while (true) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return false;\n            }\n\n            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n\n        dir->id += 1;\n        if (err != LFS_ERR_NOENT) {\n            break;\n        }\n    }\n\n    dir->pos += 1;\n    return true;\n}\n...\nstatic int lfs_stat_(lfs_t *lfs, const char *path, struct lfs_info *info) {\n    lfs_mdir_t cwd;\n    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    // only allow trailing slashes on dirs\n    if (strchr(path, '/') != NULL\n            && lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n        return LFS_ERR_NOTDIR;\n    }\n\n    return lfs_dir_getinfo(lfs, &cwd, lfs_tag_id(tag), info);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nlfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The call passes info->name (size LFS_NAME_MAX+1) with a length of lfs->name_max+1. If lfs->name_max > LFS_NAME_MAX (e.g. due to a corrupted or malicious superblock, or lack of runtime check), lfs_dir_get will copy lfs->name_max+1 bytes into info->name, overflowing the buffer. This is a direct way a string/memory copy used by lfs_dir_get can access beyond the bounds of info->name."
}