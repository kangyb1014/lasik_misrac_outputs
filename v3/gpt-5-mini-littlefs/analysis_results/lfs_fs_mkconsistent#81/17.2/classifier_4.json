{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_fs_mkconsistent:\n```c\nint lfs_fs_mkconsistent(lfs_t *lfs) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_fs_mkconsistent(%p)\", (void*)lfs);\n\n    err = lfs_fs_mkconsistent_(lfs);\n\n    LFS_TRACE(\"lfs_fs_mkconsistent -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_mkconsistent:\nstatic int lfs_fs_mkconsistent_(lfs_t *lfs) {\n    // lfs_fs_forceconsistency does most of the work here\n    int err = lfs_fs_forceconsistency(lfs);\n    if (err) {\n        return err;\n    }\n\n    // do we have any pending gstate?\n    lfs_gstate_t delta = {0};\n    lfs_gstate_xor(&delta, &lfs->gdisk);\n    lfs_gstate_xor(&delta, &lfs->gstate);\n    if (!lfs_gstate_iszero(&delta)) {\n        // lfs_dir_commit will implicitly write out any pending gstate\n        lfs_mdir_t root;\n        err = lfs_dir_fetch(lfs, &root, lfs->root);\n        if (err) {\n            return err;\n        }\n\n        err = lfs_dir_commit(lfs, &root, NULL, 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n...\nstatic int lfs_fs_forceconsistency(lfs_t *lfs) {\n    int err = lfs_fs_desuperblock(lfs);\n    if (err) {\n        return err;\n    }\n\n    err = lfs_fs_demove(lfs);\n    if (err) {\n        return err;\n    }\n\n    err = lfs_fs_deorphan(lfs, true);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n...\nstatic inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {\n    a->tag ^= b->tag;\n    a->pair[0] ^= b->pair[0];\n    a->pair[1] ^= b->pair[1];\n}\n...\nstatic inline bool lfs_gstate_iszero(const lfs_gstate_t *a) {\n    return a->tag == 0\n            && a->pair[0] == 0\n            && a->pair[1] == 0;\n}\n...\nstatic int lfs_dir_fetch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2]) {\n    // note, mask=-1, tag=-1 can never match a tag since this\n    // pattern has the invalid bit set\n    return (int)lfs_dir_fetchmatch(lfs, dir, pair,\n            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);\n}\n...\nstatic int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,\n        const struct lfs_mattr *attrs, int attrcount) {\n    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);\n    if (orphans < 0) {\n        return orphans;\n    }\n\n    if (orphans) {\n        // make sure we've removed all orphans, this is a noop if there\n        // are none, but if we had nested blocks failures we may have\n        // created some\n        int err = lfs_fs_deorphan(lfs, false);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nint err = lfs_fs_deorphan(lfs, false);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "In the provided code there is no evidence of lfs_dir_commit or lfs_fs_deorphan calling each other back into the original caller, so the call int err = lfs_fs_deorphan(lfs, false); does not create direct or indirect recursion. A violation would occur only if lfs_fs_deorphan (not shown) called lfs_dir_commit or lfs_fs_mkconsistent (directly or via other functions), creating a cycle such as lfs_dir_commit -> lfs_fs_deorphan -> ... -> lfs_dir_commit (or any path back to lfs_fs_mkconsistent)."
}