{
  "user_message": "An agent A claimed that the following lfs_fs_parent code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_parent.\n```c\nstatic lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],\n        lfs_mdir_t *parent) {\n    // use fetchmatch with callback to find pairs\n    parent->tail[0] = 0;\n    parent->tail[1] = 1;\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(parent->tail)) {\n        err = lfs_tortoise_detectcycles(parent, &tortoise);\n        if (err < 0) {\n            return err;\n        }\n\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,\n                LFS_MKTAG(0x7ff, 0, 0x3ff),\n                LFS_MKTAG(LFS_TYPE_DIRSTRUCT, 0, 8),\n                NULL,\n                lfs_fs_parent_match, &(struct lfs_fs_parent_match){\n                    lfs, {pair[0], pair[1]}});\n        if (tag && tag != LFS_ERR_NOENT) {\n            return tag;\n        }\n    }\n\n    return LFS_ERR_NOENT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe address of a non-const compound literal is passed as a plain (non-const) void* to the fetch/match machinery, even though the callback only reads the data. Concretely: &(struct lfs_fs_parent_match){ lfs, {pair[0], pair[1]} } is passed to lfs_dir_fetchmatch and later interpreted in lfs_fs_parent_match as a read-only struct. The pointer therefore could and should point to a const-qualified type (for example pass a const struct lfs_fs_parent_match* or change the callback/data parameter to const void*), so the current usage violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_parent:\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef uint32_t lfs_block_t\n...\nstruct lfs_tortoise_t {\n    lfs_block_t pair[2];\n    lfs_size_t i;\n    lfs_size_t period;\n}\n...\nstatic int lfs_fs_parent_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_fs_parent_match *find = data;\n    lfs_t *lfs = find->lfs;\n    const struct lfs_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs_block_t child[2];\n    int err = lfs_bd_read(lfs,\n            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs_pair_fromle32(child);\n    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In lfs_fs_parent_match the callback parameter is declared as void *data but the function only reads from the struct (struct lfs_fs_parent_match *find = data; and no modifications). Per MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so this parameter (and the fetch/match data parameter it propagates through) should be const-qualified (for example const void *data and const struct lfs_fs_parent_match *find). The compound literal passed (&(struct lfs_fs_parent_match){ ... }) is used read-only, so the API and callback could/should accept a pointer-to-const; as written the code does not use const where it could, which violates Rule 8.13. Note: if the lfs_dir_fetchmatch API must permit callbacks that modify data for other callers, the API would need broader change; but as pertains to this callback and usage, the report of a Rule 8.13 violation is correct."
}