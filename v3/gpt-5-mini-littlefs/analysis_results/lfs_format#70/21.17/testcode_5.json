{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nlfs_cache_zero very likely calls a string.h function (e.g. memset) to zero the cache using lfs->cfg->cache_size. lfs_init sets lfs->rcache.buffer = cfg->read_buffer when the user supplies a buffer but does not verify that the supplied object has at least cache_size bytes. If a caller supplies a smaller read_buffer (or misinitializes cfg->cache_size), memset in lfs_cache_zero will write past the end of the supplied buffer, causing an out\u2011of\u2011bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_format code that contains useful probe functions that print useful logs to a file \"/tmp/logs/709.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_format as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_format:\n```c\nint lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = LFS_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_format(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRId32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"})\",\n            (void*)lfs, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    err = lfs_format_(lfs, cfg);\n\n    LFS_TRACE(\"lfs_format -> %d\", err);\n    LFS_UNLOCK(cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_format code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe helper: append logging information to /tmp/logs/709.txt.\n   We intentionally avoid dereferencing any pointers that could be invalid\n   (we only print pointer values and size fields) to prevent introducing\n   new out-of-bounds accesses. */\nstatic void lfs_format_probe_enter(const void *lfs, const void *cfg) {\n    FILE *f = fopen(\"/tmp/logs/709.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"---- lfs_format ENTER ----\\n\");\n    fprintf(f, \"lfs=%p cfg=%p\\n\", lfs, cfg);\n\n    /* We can't assume the full definition of struct lfs_config is visible here,\n       but the original code uses many fields. To be robust, cast cfg to a\n       pointer to a type-agnostic byte pointer and print known offsets if\n       needed. However, to avoid adding UB we only print the fields by\n       accessing through the declared layout used by callers. If this file\n       already has the struct definition visible, the casts below will work.\n    */\n    /* Best-effort: attempt to print typical fields used by lfs_format.\n       Use the same casts as the original LFS_TRACE to avoid warnings. */\n    /* Note: we don't dereference pointers beyond reading scalar fields from\n       cfg; this avoids reading user-provided buffers that may be undersized. */\n\n    /* Try to print common config fields if available. */\n    /* We use helper casts to silence incompatible-pointer warnings similar to\n       the original code. If the surrounding translation unit has the struct\n       defined, these accesses will be valid; otherwise, these lines still\n       compile because we only cast and print pointers/sizes. */\n    struct lfs_config_dummy {\n        void *context;\n        void *read;\n        void *prog;\n        void *erase;\n        void *sync;\n        uint32_t read_size;\n        uint32_t prog_size;\n        uint32_t block_size;\n        uint32_t block_count;\n        int32_t  block_cycles;\n        uint32_t cache_size;\n        uint32_t lookahead_size;\n        void *read_buffer;\n        void *prog_buffer;\n        void *lookahead_buffer;\n        uint32_t name_max;\n        uint32_t file_max;\n        uint32_t attr_max;\n    };\n\n    /* Cast cfg to dummy type pointer to read the expected fields. This is\n       only for logging; if the real struct has a different layout it may be\n       incorrect, but it will not cause memory writes. */\n    const struct lfs_config_dummy *d = (const struct lfs_config_dummy*)cfg;\n    fprintf(f, \"cfg->context=%p, read=%p, prog=%p, erase=%p, sync=%p\\n\",\n            d->context, (void*)(uintptr_t)d->read, (void*)(uintptr_t)d->prog,\n            (void*)(uintptr_t)d->erase, (void*)(uintptr_t)d->sync);\n\n    fprintf(f, \"sizes: read_size=%\" PRIu32 \", prog_size=%\" PRIu32 \", block_size=%\" PRIu32 \", block_count=%\" PRIu32 \"\\n\",\n            d->read_size, d->prog_size, d->block_size, d->block_count);\n\n    fprintf(f, \"cache_size=%\" PRIu32 \", lookahead_size=%\" PRIu32 \"\\n\",\n            d->cache_size, d->lookahead_size);\n\n    fprintf(f, \"buffers: read_buffer=%p, prog_buffer=%p, lookahead_buffer=%p\\n\",\n            d->read_buffer, d->prog_buffer, d->lookahead_buffer);\n\n    fprintf(f, \"limits: name_max=%\" PRIu32 \", file_max=%\" PRIu32 \", attr_max=%\" PRIu32 \"\\n\",\n            d->name_max, d->file_max, d->attr_max);\n\n    /* Additional note to help reproduce the violation scenario. */\n    fprintf(f, \"NOTE: To reproduce potential OOB with memset/memcpy, check that cfg->cache_size (%\" PRIu32 \") <= size of object pointed to by cfg->read_buffer (%p)\\n\",\n            d->cache_size, d->read_buffer);\n\n    fprintf(f, \"--------------------------\\n\");\n    fclose(f);\n}\n\nstatic void lfs_format_probe_exit(const void *lfs, const void *cfg, int err) {\n    FILE *f = fopen(\"/tmp/logs/709.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"---- lfs_format EXIT ----\\n\");\n    fprintf(f, \"lfs=%p cfg=%p return=%d\\n\", lfs, cfg, err);\n    fprintf(f, \"-------------------------\\n\");\n    fclose(f);\n}\n\nint lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = LFS_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n\n    /* Original trace retained for backward compatibility. */\n    LFS_TRACE(\"lfs_format(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRId32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"}\",\n            (void*)lfs, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    /* Insert probe logging at entry to capture configuration used by callers.\n       This helps reproduce scenarios where cfg->cache_size is larger than the\n       object provided in cfg->read_buffer. */\n    lfs_format_probe_enter(lfs, cfg);\n\n    err = lfs_format_(lfs, cfg);\n\n    /* Probe at exit to capture return value and final state. */\n    lfs_format_probe_exit(lfs, cfg, err);\n\n    LFS_TRACE(\"lfs_format -> %d\", err);\n    LFS_UNLOCK(cfg);\n    return err;\n}\n"
}