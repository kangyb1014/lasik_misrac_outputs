{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe parameter lfs_t *lfs is not const-qualified even though the function only reads through it (accesses lfs->cfg members) and does not modify the lfs object. pcache and dir are already const as appropriate; buffer and rcache must remain non-const because they are written. Therefore lfs could be declared const lfs_t *lfs, so the current prototype violates Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_dir_getread code that contains useful probe functions that print useful logs to a file \"/tmp/logs/283.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_dir_getread as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_dir_getread:\n```c\nstatic int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t off, void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs->cfg->block_size) {\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        if (pcache && pcache->block == LFS_BLOCK_INLINE &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                // is already in pcache?\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // pcache takes priority\n            diff = lfs_min(diff, pcache->off-off);\n        }\n\n        if (rcache->block == LFS_BLOCK_INLINE &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                // is already in rcache?\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            // rcache takes priority\n            diff = lfs_min(diff, rcache->off-off);\n        }\n\n        // load to cache, first condition can no longer fail\n        rcache->block = LFS_BLOCK_INLINE;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),\n                lfs->cfg->cache_size);\n        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,\n                rcache->off, rcache->buffer, rcache->size);\n        if (err < 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n```\n</target_code>\nPlease provide the modified lfs_dir_getread code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Probe logging utility */\nstatic void lfs_log_probe(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/283.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,\n        lfs_tag_t gmask, lfs_tag_t gtag,\n        lfs_off_t off, void *buffer, lfs_size_t size) {\n    uint8_t *data = buffer;\n\n    /* Entry probe: record pointers and config values read from lfs */\n    if (lfs && lfs->cfg) {\n        lfs_log_probe(\"ENTER lfs_dir_getread: lfs=%p, lfs->cfg=%p, block_size=%llu, read_size=%llu, cache_size=%llu, hint=%llu, gmask=%llu, gtag=%llu, off=%llu, size=%llu, buffer=%p, pcache=%p, rcache=%p, dir=%p\",\n                (void *)lfs, (void *)lfs->cfg,\n                (unsigned long long)lfs->cfg->block_size,\n                (unsigned long long)lfs->cfg->read_size,\n                (unsigned long long)lfs->cfg->cache_size,\n                (unsigned long long)hint,\n                (unsigned long long)gmask,\n                (unsigned long long)gtag,\n                (unsigned long long)off,\n                (unsigned long long)size,\n                buffer, (const void *)pcache, (void *)rcache, (const void *)dir);\n    } else {\n        lfs_log_probe(\"ENTER lfs_dir_getread: lfs=%p, lfs->cfg=%p, off=%llu, size=%llu, buffer=%p\",\n                (void *)lfs, (lfs && lfs->cfg) ? (void *)lfs->cfg : (void *)NULL,\n                (unsigned long long)off, (unsigned long long)size, buffer);\n    }\n\n    if (off+size > lfs->cfg->block_size) {\n        lfs_log_probe(\"ERROR: requested range off+size > block_size (%llu > %llu). Returning LFS_ERR_CORRUPT.\",\n                (unsigned long long)(off+size), (unsigned long long)lfs->cfg->block_size);\n        return LFS_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs_size_t diff = size;\n\n        lfs_log_probe(\"LOOP: off=%llu, size=%llu, diff(start)=%llu\",\n                (unsigned long long)off, (unsigned long long)size, (unsigned long long)diff);\n\n        if (pcache && pcache->block == LFS_BLOCK_INLINE &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                /* is already in pcache? */\n                diff = lfs_min(diff, pcache->size - (off-pcache->off));\n                lfs_log_probe(\"PCACHE HIT: pcache=%p, pcache->off=%llu, pcache->size=%llu, using diff=%llu, copy src offset=%llu\",\n                        (const void *)pcache,\n                        (unsigned long long)pcache->off,\n                        (unsigned long long)pcache->size,\n                        (unsigned long long)diff,\n                        (unsigned long long)(off-pcache->off));\n\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n\n                lfs_log_probe(\"AFTER PCACHE COPY: new off=%llu, new size=%llu\",\n                        (unsigned long long)off, (unsigned long long)size);\n                continue;\n            }\n\n            /* pcache takes priority */\n            diff = lfs_min(diff, pcache->off-off);\n            lfs_log_probe(\"PCACHE PRIORITY: pcache->off=%llu, adjusted diff=%llu\",\n                    (unsigned long long)pcache->off, (unsigned long long)diff);\n        }\n\n        if (rcache->block == LFS_BLOCK_INLINE &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                /* is already in rcache? */\n                diff = lfs_min(diff, rcache->size - (off-rcache->off));\n                lfs_log_probe(\"RCACHE HIT: rcache=%p, rcache->off=%llu, rcache->size=%llu, using diff=%llu, copy src offset=%llu\",\n                        (void *)rcache,\n                        (unsigned long long)rcache->off,\n                        (unsigned long long)rcache->size,\n                        (unsigned long long)diff,\n                        (unsigned long long)(off-rcache->off));\n\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n\n                lfs_log_probe(\"AFTER RCACHE COPY: new off=%llu, new size=%llu\",\n                        (unsigned long long)off, (unsigned long long)size);\n                continue;\n            }\n\n            /* rcache takes priority */\n            diff = lfs_min(diff, rcache->off-off);\n            lfs_log_probe(\"RCACHE PRIORITY: rcache->off=%llu, adjusted diff=%llu\",\n                    (unsigned long long)rcache->off, (unsigned long long)diff);\n        }\n\n        /* load to cache, first condition can no longer fail */\n        rcache->block = LFS_BLOCK_INLINE;\n        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);\n        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),\n                lfs->cfg->cache_size);\n\n        lfs_log_probe(\"LOAD RCACHE: set rcache->block=LFS_BLOCK_INLINE, rcache->off=%llu, rcache->size=%llu, read_size=%llu, cache_size=%llu\",\n                (unsigned long long)rcache->off,\n                (unsigned long long)rcache->size,\n                (unsigned long long)lfs->cfg->read_size,\n                (unsigned long long)lfs->cfg->cache_size);\n\n        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,\n                rcache->off, rcache->buffer, rcache->size);\n        lfs_log_probe(\"CALL lfs_dir_getslice: returned err=%d (rcache->off=%llu, rcache->size=%llu)\",\n                err, (unsigned long long)rcache->off, (unsigned long long)rcache->size);\n        if (err < 0) {\n            lfs_log_probe(\"ERROR: lfs_dir_getslice failed with %d. Returning this error.\", err);\n            return err;\n        }\n    }\n\n    lfs_log_probe(\"EXIT lfs_dir_getread: success (returned 0)\");\n    return 0;\n}\n"
}