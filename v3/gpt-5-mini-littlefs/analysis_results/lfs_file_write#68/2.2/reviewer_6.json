{
  "user_message": "An agent A claimed that the following lfs_file_write code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_write.\n```c\nlfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_write(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs, (void*)file, buffer, size);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_ssize_t res = lfs_file_write_(lfs, file, buffer, size);\n\n    LFS_TRACE(\"lfs_file_write -> %\"PRId32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe LFS_LOCK macro is defined as ((void)cfg,0), so int err = LFS_LOCK(lfs->cfg); always yields err == 0. The subsequent if (err) { return err; } branch can never be taken (the return is unreachable) and the assignment/check have no effect in this build \u2014 removing them would not change program behaviour. This constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); returning res=5\nENTER lfs_file_write: lfs=0x7fff21cc2338 file=0x7fff21cc20d0 buffer=0x56309c07c058 size=5\nLFS_LOCK returned err=0 (cfg=0x7fff21cc2240)\nCalling lfs_file_write_ (payload write)\nlfs_file_write_: result=5\nLFS_UNLOCK called (cfg=0x7fff21cc2240); \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_write:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\n#define LFS_ASSERT(test) assert(test)\n...\nstatic bool lfs_mlist_isopen(struct lfs_mlist *head,\n        struct lfs_mlist *node) {\n    for (struct lfs_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n...\nstatic lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (file->flags & LFS_F_READING) {\n        // drop any reads\n        int err = lfs_file_flush(lfs, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs->file_max) {\n        // Larger than file limit?\n        return LFS_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {\n        // fill with zeros\n        lfs_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        while (file->pos < pos) {\n            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);\n    if (nsize < 0) {\n        return nsize;\n    }\n\n    file->flags &= ~LFS_F_ERRED;\n    return nsize;\n}\n...\nstatic int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {\n    if (file->flags & LFS_F_READING) {\n        if (!(file->flags & LFS_F_INLINE)) {\n            lfs_cache_drop(lfs, &file->cache);\n        }\n        file->flags &= ~LFS_F_READING;\n    }\n\n#ifndef LFS_READONLY\n    if (file->flags & LFS_F_WRITING) {\n        lfs_off_t pos = file->pos;\n\n        if (!(file->flags & LFS_F_INLINE)) {\n            // copy over anything after current branch\n            lfs_file_t orig = {\n                .ctz.head = file->ctz.head,\n                .ctz.size = file->ctz.size,\n                .flags = LFS_O_RDONLY,\n                .pos = file->pos,\n                .cache = lfs->rcache,\n            };\n            lfs_cache_drop(lfs, &lfs->rcache);\n\n            while (file->pos < file->ctz.size) {\n                // copy over a byte at a time, leave it up to caching\n                // to make this efficient\n                uint8_t data;\n                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                res = lfs_file_flushedwrite(lfs, file, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                // keep our reference to the rcache in sync\n                if (lfs->rcache.block != LFS_BLOCK_NULL) {\n                    lfs_cache_drop(lfs, &orig.cache);\n                    lfs_cache_drop(lfs, &lfs->rcache);\n                }\n            }\n\n            // write out what we have\n            while (true) {\n                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);\n                if (err) {\n                    if (err == LFS_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                break;\n\nrelocate:\n                LFS_DEBUG(\"Bad block at 0x%\"PRIx32, file->block);\n                err = lfs_file_relocate(lfs, file);\n                if (err) {\n                    return err;\n                }\n            }\n        } else {\n            file->pos = lfs_max(file->pos, file->ctz.size);\n        }\n\n        // actual file updates\n        file->ctz.head = file->block;\n        file->ctz.size = file->pos;\n        file->flags &= ~LFS_F_WRITING;\n        file->flags |= LFS_F_DIRTY;\n\n        file->pos = pos;\n    }\n#endif\n\n    return 0;\n}\n...\nstatic lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    lfs_size_t nsize = size;\n\n    if ((file->flags & LFS_F_INLINE) &&\n            lfs_max(file->pos+nsize, file->ctz.size) > lfs->inline_max) {\n        // inline file doesn't fit anymore\n        int err = lfs_file_outline(lfs, file);\n        if (err) {\n            file->flags |= LFS_F_ERRED;\n            return err;\n        }\n    }\n\n    while (nsize > 0) {\n        // check if we need a new block\n        if (!(file->flags & LFS_F_WRITING) ||\n                file->off == lfs->cfg->block_size) {\n            if (!(file->flags & LFS_F_INLINE)) {\n                if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {\n                    // find out which block we're extending from\n                    int err = lfs_ctz_find(lfs, NULL, &file->cache,\n                            file->ctz.head, file->ctz.size,\n                            file->pos-1, &file->block, &(lfs_off_t){0});\n                    if (err) {\n                        file->flags |= LFS_F_ERRED;\n                        return err;\n                    }\n\n                    // mark cache as dirty since we may have read data into it\n                    lfs_cache_zero(lfs, &file->cache);\n                }\n\n                // extend file with new blocks\n                lfs_alloc_ckpoint(lfs);\n                int err = lfs_ctz_extend(lfs, &file->cache, &lfs->rcache,\n                        file->block, file->pos,\n                        &file->block, &file->off);\n                if (err) {\n                    file->flags |= LFS_F_ERRED;\n                    return err;\n                }\n            } else {\n                file->block = LFS_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS_F_WRITING;\n        }\n\n        // program as much as we can in current block\n        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);\n        while (true) {\n            int err = lfs_bd_prog(lfs, &file->cache, &lfs->rcache, true,\n                    file->block, file->off, data, diff);\n            if (err) {\n                if (err == LFS_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                file->flags |= LFS_F_ERRED;\n                return err;\n            }\n\n            break;\nrelocate:\n            err = lfs_file_relocate(lfs, file);\n            if (err) {\n                file->flags |= LFS_F_ERRED;\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n\n        lfs_alloc_ckpoint(lfs);\n    }\n\n    return size;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.2 forbids dead code (operations that are executed but whose removal would not affect program behaviour). In the supplied code the if (err) { return err; } body can never be taken when LFS_LOCK(cfg) expands to ((void)cfg,0) \u2014 that makes the return statement unreachable. Note 2 of the rule explicitly distinguishes unreachable code from dead code (unreachable code is not dead code because it cannot be executed). More importantly, LFS_LOCK is a platform/configuration abstraction: in other build configurations it may perform real locking and can return non\u2011zero error codes. The presence of the check protects behaviour in those configurations; removing the locking/checking now would change behaviour in those other builds. Thus, in the intended multi\u2011configuration project the code is not dead and does not violate Rule 2.2. If, however, you really have a project configuration where LFS_LOCK is guaranteed to be a no\u2011op everywhere in the project and never has side effects, a static analysis could report this as redundant; such a situation should be resolved by conditional compilation or a documented justification. But given the macro is a configurable hook, the agent\u2019s claim that Rule 2.2 is violated is not correct."
}