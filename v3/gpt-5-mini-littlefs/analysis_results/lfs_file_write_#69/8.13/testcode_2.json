{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nPassing the address of a non-const compound literal &(uint8_t){0} to a function that takes a pointer-to-const (const void *). The object being pointed at is not const-qualified even though it is not modified, so the pointer does not point to a const-qualified type as required by the rule. Use &(const uint8_t){0} or a named const uint8_t zero = 0; &zero instead.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_write_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/693.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_write_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_write_:\n```c\nstatic lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (file->flags & LFS_F_READING) {\n        // drop any reads\n        int err = lfs_file_flush(lfs, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs->file_max) {\n        // Larger than file limit?\n        return LFS_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {\n        // fill with zeros\n        lfs_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        while (file->pos < pos) {\n            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);\n    if (nsize < 0) {\n        return nsize;\n    }\n\n    file->flags &= ~LFS_F_ERRED;\n    return nsize;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_write_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/* Probe logging utility: append human-readable logs to /tmp/logs/693.txt\n   This preserves program logic and helps reproduce the scenario where a\n   non-const compound literal &(uint8_t){0} is passed to a function that\n   takes a pointer-to-const. */\nstatic void lfs_probe_log(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/693.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\nstatic lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,\n        const void *buffer, lfs_size_t size) {\n    /* Log entry state */\n    lfs_probe_log(\"ENTRY: lfs_file_write_: file=%p flags=0x%X pos=%lld ctz.size=%lld file_max=%lld size=%llu\",\n        (void *)file, (unsigned)file->flags,\n        (long long)file->pos, (long long)file->ctz.size,\n        (long long)lfs->file_max, (unsigned long long)size);\n\n    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);\n\n    if (file->flags & LFS_F_READING) {\n        // drop any reads\n        lfs_probe_log(\"BRANCH: F_READING set -> calling lfs_file_flush\");\n        int err = lfs_file_flush(lfs, file);\n        lfs_probe_log(\"lfs_file_flush returned %d\", err);\n        if (err) {\n            lfs_probe_log(\"EXIT: lfs_file_write_ (flush err) -> %d\", err);\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {\n        lfs_probe_log(\"BRANCH: O_APPEND and pos < ctz.size -> shifting pos %lld -> %lld\",\n            (long long)file->pos, (long long)file->ctz.size);\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs->file_max) {\n        // Larger than file limit?\n        lfs_probe_log(\"EXIT: size would exceed file_max (%lld + %llu > %lld) -> LFS_ERR_FBIG\",\n            (long long)file->pos, (unsigned long long)size, (long long)lfs->file_max);\n        return LFS_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {\n        /* fill with zeros */\n        lfs_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        lfs_probe_log(\"BRANCH: need to fill with zeros: target_pos=%lld current_pos=%lld\",\n            (long long)pos, (long long)file->pos);\n\n        while (file->pos < pos) {\n            lfs_probe_log(\"LOOP: fill zeros: before flushedwrite pos=%lld remaining=%lld\",\n                (long long)file->pos, (long long)(pos - file->pos));\n\n            /* Violation scenario: passing address of non-const compound literal */\n            lfs_probe_log(\"ACTION: calling lfs_file_flushedwrite with &(uint8_t){0} (non-const compound literal) to write one zero byte\");\n            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);\n            lfs_probe_log(\"RESULT: lfs_file_flushedwrite returned %lld\", (long long)res);\n\n            if (res < 0) {\n                lfs_probe_log(\"EXIT: lfs_file_write_ (flushedwrite err) -> %lld\", (long long)res);\n                return res;\n            }\n        }\n    }\n\n    lfs_probe_log(\"ACTION: final write: buffer=%p size=%llu pos=%lld\",\n        buffer, (unsigned long long)size, (long long)file->pos);\n\n    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);\n    lfs_probe_log(\"RESULT: final lfs_file_flushedwrite returned %lld\", (long long)nsize);\n    if (nsize < 0) {\n        lfs_probe_log(\"EXIT: lfs_file_write_ (final write err) -> %lld\", (long long)nsize);\n        return nsize;\n    }\n\n    file->flags &= ~LFS_F_ERRED;\n    lfs_probe_log(\"EXIT: lfs_file_write_ success -> %lld (cleared F_ERRED)\", (long long)nsize);\n    return nsize;\n}\n"
}