{
  "user_message": "An agent A claimed that the following lfs_file_close code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_close.\n```c\nint lfs_file_close(lfs_t *lfs, lfs_file_t *file) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_close(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_close_(lfs, file);\n\n    LFS_TRACE(\"lfs_file_close -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro LFS_UNLOCK(cfg) expands to ((void)cfg), so the call LFS_UNLOCK(lfs->cfg); in lfs_file_close executes a no-op expression that has no effect on program state. Removing that statement would not change program behaviour, therefore it constitutes dead code.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca641b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca64218 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca64280 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_close_: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nbefore_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_unlock: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nreturn: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nenter: lfs=0x7ffdeca64418 file=0x7ffdeca643b0 err=0\nafter_lock: lfs=0x7ffdeca64418 file=0x7ffdec\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_close:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\n#define LFS_ASSERT(test) assert(test)\n...\nstatic bool lfs_mlist_isopen(struct lfs_mlist *head,\n        struct lfs_mlist *node) {\n    for (struct lfs_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n...\nstatic int lfs_file_close_(lfs_t *lfs, lfs_file_t *file) {\n#ifndef LFS_READONLY\n    int err = lfs_file_sync_(lfs, file);\n#else\n    int err = 0;\n#endif\n\n    // remove from list of mdirs\n    lfs_mlist_remove(lfs, (struct lfs_mlist*)file);\n\n    // clean up memory\n    if (!file->cfg->buffer) {\n        lfs_free(file->cache.buffer);\n    }\n\n    return err;\n}\n...\nstatic int lfs_file_sync_(lfs_t *lfs, lfs_file_t *file) {\n    if (file->flags & LFS_F_ERRED) {\n        // it's not safe to do anything if our file errored\n        return 0;\n    }\n\n    int err = lfs_file_flush(lfs, file);\n    if (err) {\n        file->flags |= LFS_F_ERRED;\n        return err;\n    }\n\n\n    if ((file->flags & LFS_F_DIRTY) &&\n            !lfs_pair_isnull(file->m.pair)) {\n        // before we commit metadata, we need sync the disk to make sure\n        // data writes don't complete after metadata writes\n        if (!(file->flags & LFS_F_INLINE)) {\n            err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);\n            if (err) {\n                return err;\n            }\n        }\n\n        // update dir entry\n        uint16_t type;\n        const void *buffer;\n        lfs_size_t size;\n        struct lfs_ctz ctz;\n        if (file->flags & LFS_F_INLINE) {\n            // inline the whole file\n            type = LFS_TYPE_INLINESTRUCT;\n            buffer = file->cache.buffer;\n            size = file->ctz.size;\n        } else {\n            // update the ctz reference\n            type = LFS_TYPE_CTZSTRUCT;\n            // copy ctz so alloc will work during a relocate\n            ctz = file->ctz;\n            lfs_ctz_tole32(&ctz);\n            buffer = &ctz;\n            size = sizeof(ctz);\n        }\n\n        // commit file data and attributes\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(type, file->id, size), buffer},\n                {LFS_MKTAG(LFS_FROM_USERATTRS, file->id,\n                    file->cfg->attr_count), file->cfg->attrs}));\n        if (err) {\n            file->flags |= LFS_F_ERRED;\n            return err;\n        }\n\n        file->flags &= ~LFS_F_DIRTY;\n    }\n\n    return 0;\n}\n...\nstatic void lfs_mlist_remove(lfs_t *lfs, struct lfs_mlist *mlist) {\n    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {\n        if (*p == mlist) {\n            *p = (*p)->next;\n            break;\n        }\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Given the provided macro definitions LFS_UNLOCK(cfg) expands to ((void)cfg), the statement LFS_UNLOCK(lfs->cfg); in lfs_file_close is an evaluated expression with no side effects (it merely casts the pointer to void and discards it). Removing that statement would not change program behaviour for the shown build configuration, which meets MISRA C 2023 Rule 2.2\u2019s definition of dead code. Note: if the macro is defined differently in another project build (e.g. to actually perform unlocking), the statement would not be dead in that build \u2014 MISRA 2.2 must be considered with respect to the actual project configuration. With the provided definitions, however, the report of a Rule 2.2 violation is correct."
}