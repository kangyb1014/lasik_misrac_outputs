{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_fs_stat_:\n```c\nstatic int lfs_fs_stat_(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {\n    // if the superblock is up-to-date, we must be on the most recent\n    // minor version of littlefs\n    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {\n        fsinfo->disk_version = lfs_fs_disk_version(lfs);\n\n    // otherwise we need to read the minor version on disk\n    } else {\n        // fetch the superblock\n        lfs_mdir_t dir;\n        int err = lfs_dir_fetch(lfs, &dir, lfs->root);\n        if (err) {\n            return err;\n        }\n\n        lfs_superblock_t superblock;\n        lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n        if (tag < 0) {\n            return tag;\n        }\n        lfs_superblock_fromle32(&superblock);\n\n        // read the on-disk version\n        fsinfo->disk_version = superblock.version;\n    }\n\n    // filesystem geometry\n    fsinfo->block_size = lfs->cfg->block_size;\n    fsinfo->block_count = lfs->block_count;\n\n    // other on-disk configuration, we cache all of these for internal use\n    fsinfo->name_max = lfs->name_max;\n    fsinfo->file_max = lfs->file_max;\n    fsinfo->attr_max = lfs->attr_max;\n\n    return 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_stat_:\nstruct lfs_fsinfo {\n    // On-disk version.\n    uint32_t disk_version;\n\n    // Size of a logical block in bytes.\n    lfs_size_t block_size;\n\n    // Number of logical blocks in filesystem.\n    lfs_size_t block_count;\n\n    // Upper limit on the length of file names in bytes.\n    lfs_size_t name_max;\n\n    // Upper limit on the size of files in bytes.\n    lfs_size_t file_max;\n\n    // Upper limit on the size of custom attributes in bytes.\n    lfs_size_t attr_max;\n}\n...\ntypedef struct lfs_mdir {\n    lfs_block_t pair[2];\n    uint32_t rev;\n    lfs_off_t off;\n    uint32_t etag;\n    uint16_t count;\n    bool erased;\n    bool split;\n    lfs_block_t tail[2];\n} lfs_mdir_t\n...\ntypedef int32_t lfs_stag_t\n...\ntypedef struct lfs_superblock {\n    uint32_t version;\n    lfs_size_t block_size;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n} lfs_superblock_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nfsinfo->name_max = lfs->name_max;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the fragment copies an integer member (lfs->name_max) into fsinfo->name_max and does not introduce or use a pointer-to-non-const. MISRA C 2023 Rule 8.13 concerns pointer declarations that should be const-qualified when possible; this single assignment does not violate that. (Note: if the lfs parameter were never modified anywhere and could be declared as const lfs_t *lfs, then the non-const pointer declaration would be a separate potential 8.13 violation, but that is not demonstrated by this assignment alone.)"
}