{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_dir_seek_:\n```c\nstatic int lfs_dir_seek_(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {\n    // simply walk from head dir\n    int err = lfs_dir_rewind_(lfs, dir);\n    if (err) {\n        return err;\n    }\n\n    // first two for ./..\n    dir->pos = lfs_min(2, off);\n    off -= dir->pos;\n\n    // skip superblock entry\n    dir->id = (off > 0 && lfs_pair_cmp(dir->head, lfs->root) == 0);\n\n    while (off > 0) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return LFS_ERR_INVAL;\n            }\n\n            err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int diff = lfs_min(dir->m.count - dir->id, off);\n        dir->id += diff;\n        dir->pos += diff;\n        off -= diff;\n    }\n\n    return 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_seek_:\ntypedef struct lfs_dir {\n    struct lfs_dir *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    lfs_off_t pos;\n    lfs_block_t head[2];\n} lfs_dir_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\ntypedef uint32_t lfs_off_t\n...\nstatic int lfs_dir_rewind_(lfs_t *lfs, lfs_dir_t *dir) {\n    // reload the head dir\n    int err = lfs_dir_fetch(lfs, &dir->m, dir->head);\n    if (err) {\n        return err;\n    }\n\n    dir->id = 0;\n    dir->pos = 0;\n    return 0;\n}\n...\nstatic int lfs_dir_fetch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2]) {\n    // note, mask=-1, tag=-1 can never match a tag since this\n    // pattern has the invalid bit set\n    return (int)lfs_dir_fetchmatch(lfs, dir, pair,\n            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);\n}\n...\nstatic inline int lfs_pair_cmp(\n        const lfs_block_t paira[2],\n        const lfs_block_t pairb[2]) {\n    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||\n             paira[0] == pairb[1] || paira[1] == pairb[0]);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic int lfs_dir_rewind_(lfs_t *lfs, lfs_dir_t *dir) {\n    // reload the head dir\n    int err = lfs_dir_fetch(lfs, &dir->m, dir->head);\n    if (err) {\n        return err;\n    }\n\n    dir->id = 0;\n    dir->pos = 0;\n    return 0;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the dir pointer is used to modify dir->id and dir->pos so it cannot be const-qualified. The lfs pointer is passed to lfs_dir_fetch which accepts a non-const lfs_t* (and may modify lfs), so it cannot be made const here. The dir->head array is passed to a const parameter (const lfs_block_t pair[2]) which is allowed. Therefore Rule 8.13 is not violated in this fragment."
}