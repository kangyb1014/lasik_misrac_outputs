{
  "user_message": "An agent A claimed that the following lfs_dir_find_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_find_match.\n```c\nstatic int lfs_dir_find_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_dir_find_match *name = data;\n    lfs_t *lfs = name->lfs;\n    const struct lfs_diskoff *disk = buffer;\n\n    // compare with disk\n    lfs_size_t diff = lfs_min(name->size, lfs_tag_size(tag));\n    int res = lfs_bd_cmp(lfs,\n            NULL, &lfs->rcache, diff,\n            disk->block, disk->off, name->name, diff);\n    if (res != LFS_CMP_EQ) {\n        return res;\n    }\n\n    // only equal if our size is still the same\n    if (name->size != lfs_tag_size(tag)) {\n        return (name->size < lfs_tag_size(tag)) ? LFS_CMP_LT : LFS_CMP_GT;\n    }\n\n    // found a match!\n    return LFS_CMP_EQ;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'data' is declared as void * but is only read inside the function (it is immediately assigned to struct lfs_dir_find_match *name and only inspected). It should be declared as const void *data (or const struct lfs_dir_find_match *data) to express that the pointed-to object is not modified. Declaring it as non-const when modification is not needed violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=pre_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=-1\nstage=post_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=return_eq data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=pre_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=-1\nstage=post_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=return_eq data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=return_eq data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=return_eq data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=4 tag_size=5 diff=4 disk_block=1672 disk_off=40 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=4 tag_size=5 diff=4 disk_block=1672 disk_off=40 res=1\nstage=return_ne data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=4 tag_size=5 diff=4 disk_block=1672 disk_off=40 res=1\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=return_eq data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=5 diff=5 disk_block=1672 disk_off=40 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=5 diff=5 disk_block=1672 disk_off=40 res=1\nstage=return_ne data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=5 diff=5 disk_block=1672 disk_off=40 res=1\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=4 diff=4 disk_block=1672 disk_off=88 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=4 diff=4 disk_block=1672 disk_off=88 res=1\nstage=return_ne data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=8 tag_size=4 diff=4 disk_block=1672 disk_off=88 res=1\nstage=pre_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=-1\nstage=post_cmp data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=return_eq data=0x7ffe6b666498 name=0x7ffe6b666498 lfs=0x7ffe6b6667a8 name->size=8 tag_size=8 diff=8 disk_block=1 disk_off=8 res=0\nstage=pre_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=-1\nstage=post_cmp data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_off=72 res=0\nstage=return_eq data=0x7ffe6b666410 name=0x7ffe6b666410 lfs=0x7ffe6b6667a8 name->size=9 tag_size=9 diff=9 disk_block=1 disk_o\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_find_match:\nstruct lfs_diskoff {\n    lfs_block_t block;\n    lfs_off_t off;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct in principle: lfs_dir_find_match does not modify the object pointed to by data (it only reads fields via the name pointer), so by MISRA C:2023 Rule 8.13 the parameter should be declared as pointing to a const-qualified type (e.g. const void *data or const struct lfs_dir_find_match *data). That would better express intent and satisfy the rule.\n\nOne caveat: if this function must exactly match a required callback prototype (a function-pointer type elsewhere that is declared as taking void *), then the signature cannot be changed without breaking compatibility; in that case keeping void * is a necessary constraint and can be considered a justified exception. The provided code/execution log gives no evidence of such a constraint, so the report that the current declaration violates Rule 8.13 is valid."
}