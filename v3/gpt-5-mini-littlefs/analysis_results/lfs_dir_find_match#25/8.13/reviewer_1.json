{
  "user_message": "An agent A claimed that the following lfs_dir_find_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_find_match.\n```c\nstatic int lfs_dir_find_match(void *data,\n        lfs_tag_t tag, const void *buffer) {\n    struct lfs_dir_find_match *name = data;\n    lfs_t *lfs = name->lfs;\n    const struct lfs_diskoff *disk = buffer;\n\n    // compare with disk\n    lfs_size_t diff = lfs_min(name->size, lfs_tag_size(tag));\n    int res = lfs_bd_cmp(lfs,\n            NULL, &lfs->rcache, diff,\n            disk->block, disk->off, name->name, diff);\n    if (res != LFS_CMP_EQ) {\n        return res;\n    }\n\n    // only equal if our size is still the same\n    if (name->size != lfs_tag_size(tag)) {\n        return (name->size < lfs_tag_size(tag)) ? LFS_CMP_LT : LFS_CMP_GT;\n    }\n\n    // found a match!\n    return LFS_CMP_EQ;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function lfs_dir_find_match takes a non-const void *data and immediately treats it read-only (struct lfs_dir_find_match *name = data) and then passes name->name into lfs_bd_cmp. Neither the parameter 'data' nor 'name' (and likely the member name->name) are const-qualified even though they are only read. According to MISRA C 2023 Rule 8.13, these pointers should be const-qualified when possible (e.g. const void *data, const struct lfs_dir_find_match *name, and a const-qualified type for name->name).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b438 name=0x7fff7bb4b438 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b3b0 disk=0x7fff7bb4b3b0\n  name->size=8 tag_size=8\n  disk->block=1 disk->off=8\n  name->name_ptr=0x5557447abbd9\n  name->name_hex[:8]=6C6974746C656673\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=8\n  calling lfs_bd_cmp with name->name=0x5557447abbd9\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=0 (expected LFS_CMP_EQ=0)\n  name->size=8 tag_sz=8\n  Found a match -> returning LFS_CMP_EQ=0\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b438 name=0x7fff7bb4b438 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b3b0 disk=0x7fff7bb4b3b0\n  name->size=8 tag_size=8\n  disk->block=1 disk->off=8\n  name->name_ptr=0x5557447abbd9\n  name->name_hex[:8]=6C6974746C656673\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=8\n  calling lfs_bd_cmp with name->name=0x5557447abbd9\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=0 (expected LFS_CMP_EQ=0)\n  name->size=8 tag_sz=8\n  Found a match -> returning LFS_CMP_EQ=0\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=9 tag_size=9\n  disk->block=1 disk->off=72\n  name->name_ptr=0x7fff7bb4bbe8\n  name->name_hex[:9]=627265616B66617374\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=9\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbe8\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=0 (expected LFS_CMP_EQ=0)\n  name->size=9 tag_sz=9\n  Found a match -> returning LFS_CMP_EQ=0\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=9 tag_size=9\n  disk->block=1 disk->off=72\n  name->name_ptr=0x7fff7bb4bbe8\n  name->name_hex[:9]=627265616B66617374\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=9\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbe8\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=0 (expected LFS_CMP_EQ=0)\n  name->size=9 tag_sz=9\n  Found a match -> returning LFS_CMP_EQ=0\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=4 tag_size=5\n  disk->block=1672 disk->off=40\n  name->name_ptr=0x7fff7bb4bbf2\n  name->name_hex[:4]=65676773\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=4\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbf2\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=1 (expected LFS_CMP_EQ=0)\n  Returning (cmp mismatch) res=1\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=9 tag_size=9\n  disk->block=1 disk->off=72\n  name->name_ptr=0x7fff7bb4bbe8\n  name->name_hex[:9]=627265616B66617374\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=9\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbe8\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=0 (expected LFS_CMP_EQ=0)\n  name->size=9 tag_sz=9\n  Found a match -> returning LFS_CMP_EQ=0\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=8 tag_size=5\n  disk->block=1672 disk->off=40\n  name->name_ptr=0x7fff7bb4bbf2\n  name->name_hex[:8]=70616E63616B6573\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=5\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbf2\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=1 (expected LFS_CMP_EQ=0)\n  Returning (cmp mismatch) res=1\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b3b0 name=0x7fff7bb4b3b0 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b310 disk=0x7fff7bb4b310\n  name->size=8 tag_size=4\n  disk->block=1672 disk->off=88\n  name->name_ptr=0x7fff7bb4bbf2\n  name->name_hex[:8]=70616E63616B6573\nlfs_dir_find_match: BEFORE lfs_bd_cmp\n  diff=4\n  calling lfs_bd_cmp with name->name=0x7fff7bb4bbf2\nlfs_dir_find_match: AFTER lfs_bd_cmp\n  res=1 (expected LFS_CMP_EQ=0)\n  Returning (cmp mismatch) res=1\nlfs_dir_find_match: ENTRY\n  data=0x7fff7bb4b438 name=0x7fff7bb4b438 lfs=0x7fff7bb4b748 buffer=0x7fff7bb4b3b0 disk=0x7fff7bb4b3b0\n  name->size=8 tag_size=8\n  disk->block=1 disk->off=8\n  name->name_ptr=0x5557447abbd9\n  name->name_hex[:8]=6C6974746C656673\nlfs_dir_find_match: BEFORE lfs_bd\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_find_match:\nstruct lfs_diskoff {\n    lfs_block_t block;\n    lfs_off_t off;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s observation is essentially correct: in the body of lfs_dir_find_match the parameter data is not modified and is only used for read-only access (it is immediately interpreted as a struct lfs_dir_find_match * and only read from). By MISRA C:2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the parameter could sensibly be declared const void *data (and the local pointer const struct lfs_dir_find_match *name). That would remove the non-const pointer-to-readonly-data situation flagged by the agent.\n\nCaveat: this is only a violation if the function signature can be changed. If lfs_dir_find_match is required to match a pre-existing callback type that specifies void *data (non-const) then the function must keep that signature and the non-const parameter is unavoidable; in that case you should document the reason (or use a constrained cast) to satisfy MISRA justification requirements. Also, whether name->name should be const depends on the definition of struct lfs_dir_find_match (not shown) and the prototype of lfs_bd_cmp; if name->name is passed to an API that expects a const pointer then that member could/should be const as well.\n\nConclusion: the report is correct in principle (the code could/should use const where it only reads), but it may be a false positive if the signature is forced by an external API/callback requirement."
}