{
  "user_message": "An agent A claimed that the following lfs_bd_prog code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_bd_prog.\n```c\nstatic int lfs_bd_prog(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate,\n        lfs_block_t block, lfs_off_t off,\n        const void *buffer, lfs_size_t size) {\n    const uint8_t *data = buffer;\n    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);\n    LFS_ASSERT(off + size <= lfs->cfg->block_size);\n\n    while (size > 0) {\n        if (block == pcache->block &&\n                off >= pcache->off &&\n                off < pcache->off + lfs->cfg->cache_size) {\n            // already fits in pcache?\n            lfs_size_t diff = lfs_min(size,\n                    lfs->cfg->cache_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            pcache->size = lfs_max(pcache->size, off - pcache->off);\n            if (pcache->size == lfs->cfg->cache_size) {\n                // eagerly flush out pcache if we fill up\n                int err = lfs_bd_flush(lfs, pcache, rcache, validate);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        // pcache must have been flushed, either by programming and\n        // entire block or manually flushing the pcache\n        LFS_ASSERT(pcache->block == LFS_BLOCK_NULL);\n\n        // prepare pcache, first condition can no longer fail\n        pcache->block = block;\n        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);\n        pcache->size = 0;\n    }\n\n    return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'off' (lfs_off_t off) is modified by the statement 'off += diff;' inside lfs_bd_prog. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the rule only permits modifying the object referred to by a pointer parameter, not scalar parameters themselves).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER lfs_bd_prog: block=0, off=0, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286f0f0\nprepared pcache: pcache->block=0, pcache->off=0, pcache->size=0 (after prepare)\npcache branch: block=0, pcache->block=0, off(before)=0, pcache->off=0, size(before)=4, diff=4, data_ptr=0x7ffea286f0f0\nabout to modify parameter 'off': off(before)=0, diff=4\nafter modifying 'off': off(after)=4\npcache->size updated: pcache->size=4, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=4, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286ece4\npcache branch: block=0, pcache->block=0, off(before)=4, pcache->off=0, size(before)=4, diff=4, data_ptr=0x7ffea286ece4\nabout to modify parameter 'off': off(before)=4, diff=4\nafter modifying 'off': off(after)=8\npcache->size updated: pcache->size=8, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=8, size=8, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x555fe3d24bd9\npcache branch: block=0, pcache->block=0, off(before)=8, pcache->off=0, size(before)=8, diff=8, data_ptr=0x555fe3d24bd9\nabout to modify parameter 'off': off(before)=8, diff=8\nafter modifying 'off': off(after)=16\npcache->size updated: pcache->size=16, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=16, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286ece4\npcache branch: block=0, pcache->block=0, off(before)=16, pcache->off=0, size(before)=4, diff=4, data_ptr=0x7ffea286ece4\nabout to modify parameter 'off': off(before)=16, diff=4\nafter modifying 'off': off(after)=20\npcache->size updated: pcache->size=20, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=20, size=24, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286f1a0\npcache branch: block=0, pcache->block=0, off(before)=20, pcache->off=0, size(before)=24, diff=24, data_ptr=0x7ffea286f1a0\nabout to modify parameter 'off': off(before)=20, diff=24\nafter modifying 'off': off(after)=44\npcache->size updated: pcache->size=44, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=44, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286ee04\npcache branch: block=0, pcache->block=0, off(before)=44, pcache->off=0, size(before)=4, diff=4, data_ptr=0x7ffea286ee04\nabout to modify parameter 'off': off(before)=44, diff=4\nafter modifying 'off': off(after)=48\npcache->size updated: pcache->size=48, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=48, size=8, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286ee70\npcache branch: block=0, pcache->block=0, off(before)=48, pcache->off=0, size(before)=8, diff=8, data_ptr=0x7ffea286ee70\nabout to modify parameter 'off': off(before)=48, diff=8\nafter modifying 'off': off(after)=56\npcache->size updated: pcache->size=56, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=0, off=56, size=8, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286ee70\npcache branch: block=0, pcache->block=0, off(before)=56, pcache->off=0, size(before)=8, diff=8, data_ptr=0x7ffea286ee70\nabout to modify parameter 'off': off(before)=56, diff=8\nafter modifying 'off': off(after)=64\npcache->size updated: pcache->size=64, pcache->off=0\npcache full, calling lfs_bd_flush: pcache->block=0, pcache->off=0, pcache->size=64\nlfs_bd_flush returned err=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=1, off=0, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buffer=0x7ffea286f0f0\nprepared pcache: pcache->block=1, pcache->off=0, pcache->size=0 (after prepare)\npcache branch: block=1, pcache->block=1, off(before)=0, pcache->off=0, size(before)=4, diff=4, data_ptr=0x7ffea286f0f0\nabout to modify parameter 'off': off(before)=0, diff=4\nafter modifying 'off': off(after)=4\npcache->size updated: pcache->size=4, pcache->off=0\nEXIT lfs_bd_prog success\nENTER lfs_bd_prog: block=1, off=4, size=4, validate=0, pcache=0x7ffea286f4d0, rcache=0x7ffea286f4b8, buf\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_bd_prog:\ntypedef uint32_t lfs_off_t\n...\ntypedef uint32_t lfs_size_t\n...\ntypedef uint32_t lfs_block_t\n...\ntypedef struct lfs_cache {\n    lfs_block_t block;\n    lfs_off_t off;\n    lfs_size_t size;\n    uint8_t *buffer;\n} lfs_cache_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\n#define LFS_BLOCK_INLINE ((lfs_block_t)-2)\n...\n#define LFS_BLOCK_NULL ((lfs_block_t)-1)\n...\n#define LFS_ASSERT(test) assert(test)\n...\nstatic int lfs_bd_flush(lfs_t *lfs,\n        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {\n    if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {\n        LFS_ASSERT(pcache->block < lfs->block_count);\n        lfs_size_t diff = lfs_alignup(pcache->size, lfs->cfg->prog_size);\n        int err = lfs->cfg->prog(lfs->cfg, pcache->block,\n                pcache->off, pcache->buffer, diff);\n        LFS_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n\n        if (validate) {\n            // check data on disk\n            lfs_cache_drop(lfs, rcache);\n            int res = lfs_bd_cmp(lfs,\n                    NULL, rcache, diff,\n                    pcache->block, pcache->off, pcache->buffer, diff);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res != LFS_CMP_EQ) {\n                return LFS_ERR_CORRUPT;\n            }\n        }\n\n        lfs_cache_zero(lfs, pcache);\n    }\n\n    return 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified (the only exception described is for the object referred to by a pointer parameter, not for non\u2011pointer/signed scalar parameters). In lfs_bd_prog the parameter off (type lfs_off_t, an integer typedef) is incremented (off += diff; and off = lfs_aligndown(off, ...)), which modifies the parameter variable itself. That violates Rule 17.8. To comply, introduce a local copy (e.g. lfs_off_t pos = off;) and modify the local variable instead."
}