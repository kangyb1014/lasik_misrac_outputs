{
  "user_message": "An agent A claimed that the following OS_DirRead_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_DirRead_Impl.\n```c\nint32 OS_DirRead_Impl(const OS_object_token_t *token, os_dirent_t *dirent)\n{\n    struct dirent *                de;\n    OS_impl_dir_internal_record_t *impl;\n    impl = OS_OBJECT_TABLE_GET(OS_impl_dir_table, *token);\n\n    /* NOTE - the readdir() call is non-reentrant ....\n     * However, this is performed while the global dir table lock is taken.\n     * Therefore this ensures that only one such call can occur at any given time.\n     *\n     * Static analysis tools may warn about this because they do not know\n     * this function is externally serialized via the global lock.\n     */\n    /* cppcheck-suppress readdirCalled */\n    /* cppcheck-suppress nonreentrantFunctionsreaddir */\n    de = readdir(impl->dp);\n    if (de == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    strncpy(dirent->FileName, de->d_name, sizeof(dirent->FileName) - 1);\n    dirent->FileName[sizeof(dirent->FileName) - 1] = 0;\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'de' is declared as 'struct dirent *de' but is only used for reading (de->d_name is passed to strncpy). According to MISRA C 2023 Rule 8.13, the pointer should be const-qualified when possible (e.g. 'const struct dirent *de' or use 'const char *src = de->d_name'). Therefore the code as written violates the rule.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 8.13 expects pointer types to be const\u2011qualified when they are not used to modify the pointed\u2011to object. In the shown function 'de' is only used for reading (de->d_name is passed to strncpy) and there is no write through 'de' in the snippet. Therefore 'de' should be declared with a const\u2011qualified target type (for example: 'const struct dirent *de;') or the code could use a separate 'const char *src = de->d_name;'. Assigning the result of readdir (which returns 'struct dirent *') to a 'const struct dirent *' is allowed and is the appropriate corrective action. If the pointer is later used to modify the object, const cannot be used, but given the snippet as shown the rule is violated and the fix is to add the const qualification."
}