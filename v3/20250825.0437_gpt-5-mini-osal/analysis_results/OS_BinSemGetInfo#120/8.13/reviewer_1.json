{
  "user_message": "An agent A claimed that the following OS_BinSemGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGetInfo.\n```c\nint32 OS_BinSemGetInfo(osal_id_t sem_id, OS_bin_sem_prop_t *bin_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(bin_prop);\n\n    memset(bin_prop, 0, sizeof(OS_bin_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_bin_sem_table, token);\n\n        strncpy(bin_prop->name, record->name_entry, sizeof(bin_prop->name) - 1);\n        bin_prop->creator = record->creator;\n        return_code       = OS_BinSemGetInfo_Impl(&token, bin_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe symbol is declared as 'extern OS_common_record_t *const OS_global_bin_sem_table' \u2014 a const pointer to a non-const OS_common_record_t. In functions such as OS_BinSemGetInfo the table is only read (record is used for read-only accesses), so the pointed-to type could and should be const-qualified (e.g. 'extern const OS_common_record_t *const OS_global_bin_sem_table') to prevent accidental modification. Because the pointed-to type is not const-qualified here, this violates MISRA C 2023 Rule 8.13 unless there is a justified need to mutate the table entries.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nPhase: ENTRY\n  sem_id=3735928559 token_addr=0x7ffcbfc2dbb0 return_code=0\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: AFTER_MEMSET\n  sem_id=3735928559 token_addr=0x7ffcbfc2dbb0 return_code=0\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: AFTER_ObjectIdGetById\n  sem_id=3735928559 token_addr=0x7ffcbfc2dbb0 return_code=-35\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: RETURN\n  sem_id=3735928559 token_addr=0x7ffcbfc2dbb0 return_code=-35\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: ENTRY\n  sem_id=0 token_addr=0x7ffcbfc2dbb0 return_code=0\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: AFTER_MEMSET\n  sem_id=0 token_addr=0x7ffcbfc2dbb0 return_code=0\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: AFTER_ObjectIdGetById\n  sem_id=0 token_addr=0x7ffcbfc2dbb0 return_code=-35\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\nPhase: RETURN\n  sem_id=0 token_addr=0x7ffcbfc2dbb0 return_code=-35\n  record_ptr=NULL\n  bin_prop_ptr=0x7ffcbfc2dc00\n-------------------------------\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BinSemGetInfo:\ntypedef struct\n{\n    char      name[OS_MAX_API_NAME];\n    osal_id_t creator;\n    int32     value;\n} OS_bin_sem_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_BinSemGetInfo_Impl(const OS_object_token_t *token, OS_bin_sem_prop_t *sem_prop)\n{\n    OS_impl_binsem_internal_record_t *sem;\n\n    sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n\n    /* put the info into the structure */\n    sem_prop->value = sem->current_value;\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_common_record_t *const OS_global_bin_sem_table\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_SUCCESS (0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. Rule 8.13 asks that pointers point to const-qualified types where possible, but that must be judged at the point(s) where the object is actually used across the whole codebase. The global OS_global_bin_sem_table is declared as extern OS_common_record_t *const OS_global_bin_sem_table (a const pointer to mutable records). Making the pointed-to type const (extern const OS_common_record_t *const ...) would only be correct if no code anywhere in the system ever modifies the table entries. From the provided additional code it is clear that other implementation functions (e.g. the implementation table access in OS_BinSemGetInfo_Impl which assigns a non-const pointer OS_impl_binsem_internal_record_t *sem) expect mutable entries, so the global table must be mutable. Therefore changing the global to point-to-const is not generally possible and the claim of a violation of 8.13 for the global declaration is not supported.\n\nThat said, for this specific function it would be appropriate to use a const-qualified local pointer (e.g. const OS_common_record_t *record) since OS_BinSemGetInfo only performs read accesses; that satisfies the intent of 8.13 locally without forcing a global API change. But the agent\u2019s assertion that the global symbol as declared necessarily violates MISRA 8.13 is incorrect unless you can prove the table is never modified anywhere in the codebase."
}