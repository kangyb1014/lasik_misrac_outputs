{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic const int32 OS_SUCCESS = 0;\nOS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token);\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2543.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", f);\n    fclose(f);\n}\nOS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token)\n{\n    /* Return the address of the record referenced by the token. */\n    OS_task_internal_record_t *rec = &table[token.id];\n    probe_log(\"OS_OBJECT_TABLE_GET: token.id=%u -> record_addr=%p\", (unsigned)token.id, (void *)rec);\n    return rec;\n}\n\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    /* Initialize delete_hook to NULL as in original code */\n    delete_hook = NULL;\n\n    probe_log(\"OS_TaskDelete: entry task_id=%u\", (unsigned)task_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    probe_log(\"OS_TaskDelete: OS_ObjectIdGetById returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n        probe_log(\"OS_TaskDelete: task pointer assigned -> %p\", (void *)task);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n        probe_log(\"OS_TaskDelete: saved delete_hook pointer -> %p\", (void *)delete_hook);\n\n        /* Note about const qualification: the pointer 'task' is non-const here.\n         * This probe records that the pointer is used only for read access in\n         * this function. */\n        probe_log(\"OS_TaskDelete: task is a mutable pointer in this scope (testing for MISRA 8.13). Read-only usage observed so far.\");\n\n        return_code = OS_TaskDelete_Impl(&token);\n        probe_log(\"OS_TaskDelete: OS_TaskDelete_Impl returned %d\", return_code);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        probe_log(\"OS_TaskDelete: OS_ObjectIdFinalizeDelete returned %d\", return_code);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        probe_log(\"OS_TaskDelete: calling delete_hook at %p\", (void *)delete_hook);\n        delete_hook();\n        probe_log(\"OS_TaskDelete: delete_hook returned\");\n    }\n    else\n    {\n        probe_log(\"OS_TaskDelete: no delete_hook to call or return_code=%d\", return_code);\n    }\n\n    probe_log(\"OS_TaskDelete: exit return_code=%d\", return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from /tmp/tmpthn53e6u/src/src/os/shared/inc/os-shared-globaldefs.h:36,\n                 from /tmp/tmpthn53e6u/src/src/os/shared/inc/os-shared-task.h:30,\n                 from /tmp/tmpthn53e6u/src/src/os/shared/src/osapi-task.c:52:\n/tmp/tmpthn53e6u/src/src/os/inc/osapi-error.h:96:41: error: expected identifier or '(' before numeric constant\n   96 | #define OS_SUCCESS                     (0)   /**< @brief Successful execution */\n      |                                         ^\n/tmp/tmpthn53e6u/src/src/os/shared/src/osapi-task.c:222:20: note: in expansion of macro 'OS_SUCCESS'\n  222 | static const int32 OS_SUCCESS = 0;\n      |                    ^~~~~~~~~~\nIn file included from /tmp/tmpthn53e6u/src/src/os/shared/src/osapi-task.c:54:\n/tmp/tmpthn53e6u/src/src/os/shared/inc/os-shared-idmap.h:100:40: error: expected identifier or '(' before '&' token\n  100 | #define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n      |                                        ^\n/tmp/tmpthn53e6u/src/src/os/shared/src/osapi-task.c:223:28: note: in expansion of macro 'OS_OBJECT_TABLE_GET'\n  223 | OS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token);\n      |                            ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpthn53e6u/src/src/os/shared/inc/os-shared-idmap.h:100:40: error: expected identifier or '(' before '&' token\n  100 | #define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n      |                                        ^\n/tmp/tmpthn53e6u/src/src/os/shared/src/osapi-task.c:240:28: note: in expansion of macro 'OS_OBJECT_TABLE_GET'\n  240 | OS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token)\n      |                            ^~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:342: CMakeFiles/osal.dir/src/os/shared/src/osapi-task.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_TaskDelete as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Basic integer typedef to match original code's int32 */\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef uint32_t osal_id_t;\n\n/* Emulate minimal tokens and record structures used by the function */\ntypedef struct\n{\n    uint32 id;\n} OS_object_token_t;\n\ntypedef void (*osal_task_entry)(void);\n\ntypedef struct\n{\n    /* Only the delete_hook_pointer is used by OS_TaskDelete */\n    osal_task_entry delete_hook_pointer;\n} OS_task_internal_record_t;\n\n/* The actual project uses macros for these; use enum constants here (not macros) */\nenum\n{\n    OS_LOCK_MODE_EXCLUSIVE = 1,\n    LOCAL_OBJID_TYPE = 1,\n};\n\n/* Prototypes for external functions used by OS_TaskDelete. These are declared\n * but not defined here so this translation unit compiles; linking is not\n * performed in this test. */\nextern int32 OS_ObjectIdGetById(int lock_mode, int obj_type, osal_id_t id, OS_object_token_t *token);\nextern int32 OS_TaskDelete_Impl(const OS_object_token_t *token);\nextern int32 OS_ObjectIdFinalizeDelete(int32 status, const OS_object_token_t *token);\n\n/* The global task table is normally defined elsewhere in the project. Declare it extern. */\nextern OS_task_internal_record_t OS_task_table[];\n\n/* Simple probe logging helper (keeps original behavior) */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2543.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\n/* Provide a named function (not a macro) to obtain a table entry by token. The\n * original code used a macro named OS_OBJECT_TABLE_GET; declaring a function\n * with that same name conflicts with the project's macro. Use a different name\n * here to avoid that conflict while preserving the lookup logic. */\nstatic OS_task_internal_record_t *OS_object_table_get(OS_task_internal_record_t *table, OS_object_token_t token)\n{\n    /* Return the address of the record referenced by the token. */\n    OS_task_internal_record_t *rec = &table[token.id];\n    probe_log(\"OS_object_table_get: token.id=%u -> record_addr=%p\", (unsigned)token.id, (void *)rec);\n    return rec;\n}\n\n/* Use a local success constant (do not define a symbol that could collide with\n * the project's OS_SUCCESS macro). */\nstatic const int32 LOCAL_OS_SUCCESS = 0;\n\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    /* Initialize delete_hook to NULL as in original code */\n    delete_hook = NULL;\n\n    probe_log(\"OS_TaskDelete: entry task_id=%u\", (unsigned)task_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    probe_log(\"OS_TaskDelete: OS_ObjectIdGetById returned %d\", return_code);\n\n    if (return_code == LOCAL_OS_SUCCESS)\n    {\n        /* Use the function wrapper instead of the macro to get the table entry */\n        task = OS_object_table_get(OS_task_table, token);\n        probe_log(\"OS_TaskDelete: task pointer assigned -> %p\", (void *)task);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n        probe_log(\"OS_TaskDelete: saved delete_hook pointer -> %p\", (void *)delete_hook);\n\n        /* Note about const qualification: the pointer 'task' is non-const here.\n         * This probe records that the pointer is used only for read access in\n         * this function. */\n        probe_log(\"OS_TaskDelete: task is a mutable pointer in this scope (testing for MISRA 8.13). Read-only usage observed so far.\");\n\n        return_code = OS_TaskDelete_Impl(&token);\n        probe_log(\"OS_TaskDelete: OS_TaskDelete_Impl returned %d\", return_code);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        probe_log(\"OS_TaskDelete: OS_ObjectIdFinalizeDelete returned %d\", return_code);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == LOCAL_OS_SUCCESS && delete_hook != NULL)\n    {\n        probe_log(\"OS_TaskDelete: calling delete_hook at %p\", (void *)delete_hook);\n        delete_hook();\n        probe_log(\"OS_TaskDelete: delete_hook returned\");\n    }\n    else\n    {\n        probe_log(\"OS_TaskDelete: no delete_hook to call or return_code=%d\", return_code);\n    }\n\n    probe_log(\"OS_TaskDelete: exit return_code=%d\", return_code);\n    return return_code;\n}\n",
  "explanation": "Two name collisions with project macros caused the original build errors: a local symbol named OS_SUCCESS and function declarations named OS_OBJECT_TABLE_GET conflicted with macros from included headers. To fix this while preserving the logic:\n\n- Removed the local symbol that used the OS_SUCCESS name and replaced it with LOCAL_OS_SUCCESS, avoiding a name collision with the project's OS_SUCCESS macro.\n- Replaced the conflicting function name OS_OBJECT_TABLE_GET with OS_object_table_get (a function wrapper) to avoid colliding with the macro of the same name. The wrapper implements the same table-lookup logic.\n- Provided minimal typedefs and extern declarations for types and external functions/variables used by OS_TaskDelete so the file compiles as a standalone translation unit (no mock function implementations were added).  \n\nThese changes prevent macro expansion conflicts while keeping the original control flow and behavior of OS_TaskDelete."
}