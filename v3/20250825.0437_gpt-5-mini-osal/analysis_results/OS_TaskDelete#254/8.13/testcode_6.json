{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local pointer 'task' is declared as a mutable pointer (OS_task_internal_record_t *task;) but is only used to read fields (task->delete_hook_pointer) and never used to modify the record. According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. In this function it could be declared as 'const OS_task_internal_record_t *task' (assigning the non-const return of OS_OBJECT_TABLE_GET to a pointer-to-const is permitted) to prevent accidental modification and comply with the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2543.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete:\n```c\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        return_code = OS_TaskDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        delete_hook();\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Minimal type definitions and constants to allow standalone compilation. */\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\n\ntypedef void (*osal_task_entry)(void);\n\n/* Token type used by the OS object APIs in this test harness. */\ntypedef struct\n{\n    uint32_t id;\n} OS_object_token_t;\n\n/* Internal task record with only the fields needed for this test. */\ntypedef struct\n{\n    osal_task_entry delete_hook_pointer;\n    /* Other fields omitted for brevity */\n} OS_task_internal_record_t;\n\n/* Simple global task table for OS_OBJECT_TABLE_GET to index into. */\nstatic OS_task_internal_record_t OS_task_table[4];\n\n/* Constants (not macros) used by the target code. */\nenum\n{\n    OS_LOCK_MODE_EXCLUSIVE = 1,\n    LOCAL_OBJID_TYPE = 2\n};\n\n/* Success code constant. */\nstatic const int32 OS_SUCCESS = 0;\n\n/* Prototypes for the OS functions used by OS_TaskDelete. These are\n * minimal stub implementations to allow compilation and to produce\n * useful logs. */\nint32 OS_ObjectIdGetById(int lock_mode, int objtype, osal_id_t id, OS_object_token_t *token);\nOS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token);\nint32 OS_TaskDelete_Impl(OS_object_token_t *token);\nint32 OS_ObjectIdFinalizeDelete(int32 result, OS_object_token_t *token);\n\n/* Logging helper: append messages to /tmp/logs/2543.txt. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2543.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\n/* Stub implementations that mimic plausible behavior and emit logs. */\nint32 OS_ObjectIdGetById(int lock_mode, int objtype, osal_id_t id, OS_object_token_t *token)\n{\n    if (token == NULL)\n    {\n        probe_log(\"OS_ObjectIdGetById: token is NULL\");\n        return -1;\n    }\n\n    /* For the test scenario, accept any id in range and populate token. */\n    token->id = (uint32_t)(id % (sizeof(OS_task_table) / sizeof(OS_task_table[0])));\n    probe_log(\"OS_ObjectIdGetById: lock_mode=%d objtype=%d req_id=%u -> token.id=%u\", lock_mode, objtype, (unsigned)id, (unsigned)token->id);\n    return OS_SUCCESS;\n}\n\nOS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token)\n{\n    /* Return the address of the record referenced by the token. */\n    OS_task_internal_record_t *rec = &table[token.id];\n    probe_log(\"OS_OBJECT_TABLE_GET: token.id=%u -> record_addr=%p\", (unsigned)token.id, (void *)rec);\n    return rec;\n}\n\nint32 OS_TaskDelete_Impl(OS_object_token_t *token)\n{\n    probe_log(\"OS_TaskDelete_Impl: called with token.id=%u\", (unsigned)token->id);\n    /* Simulate successful deletion. */\n    return OS_SUCCESS;\n}\n\nint32 OS_ObjectIdFinalizeDelete(int32 result, OS_object_token_t *token)\n{\n    probe_log(\"OS_ObjectIdFinalizeDelete: input_result=%d token.id=%u\", result, (unsigned)token->id);\n    /* Return result unchanged for this test harness. */\n    return result;\n}\n\n/* The modified OS_TaskDelete with probes inserted to capture control flow and\n * state related to the reported MISRA Rule 8.13 violation scenario. Note:\n * The pointer 'task' remains a mutable pointer as in the original code so\n * that the test captures the original situation. */\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    /* Initialize delete_hook to NULL as in original code */\n    delete_hook = NULL;\n\n    probe_log(\"OS_TaskDelete: entry task_id=%u\", (unsigned)task_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    probe_log(\"OS_TaskDelete: OS_ObjectIdGetById returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n        probe_log(\"OS_TaskDelete: task pointer assigned -> %p\", (void *)task);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n        probe_log(\"OS_TaskDelete: saved delete_hook pointer -> %p\", (void *)delete_hook);\n\n        /* Note about const qualification: the pointer 'task' is non-const here.\n         * This probe records that the pointer is used only for read access in\n         * this function. */\n        probe_log(\"OS_TaskDelete: task is a mutable pointer in this scope (testing for MISRA 8.13). Read-only usage observed so far.\");\n\n        return_code = OS_TaskDelete_Impl(&token);\n        probe_log(\"OS_TaskDelete: OS_TaskDelete_Impl returned %d\", return_code);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        probe_log(\"OS_TaskDelete: OS_ObjectIdFinalizeDelete returned %d\", return_code);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        probe_log(\"OS_TaskDelete: calling delete_hook at %p\", (void *)delete_hook);\n        delete_hook();\n        probe_log(\"OS_TaskDelete: delete_hook returned\");\n    }\n    else\n    {\n        probe_log(\"OS_TaskDelete: no delete_hook to call or return_code=%d\", return_code);\n    }\n\n    probe_log(\"OS_TaskDelete: exit return_code=%d\", return_code);\n    return return_code;\n}\n"
}