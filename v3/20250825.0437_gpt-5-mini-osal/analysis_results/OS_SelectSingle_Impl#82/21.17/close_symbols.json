{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectSingle_Impl(const OS_object_token_t *token, uint32 *SelectFlags, int32 msecs)\n{\n    int32                           return_code;\n    fd_set                          wr_set;\n    fd_set                          rd_set;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n     * If called on a stream_id which does not support this\n     * operation, return immediately and do not invoke the system call\n     */\n    if (!impl->selectable)\n    {\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (impl->fd >= FD_SETSIZE)\n    {\n        /* out of range of select() implementation */\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (*SelectFlags != 0)\n    {\n        FD_ZERO(&wr_set);\n        FD_ZERO(&rd_set);\n        if (*SelectFlags & OS_STREAM_STATE_READABLE)\n        {\n            FD_SET(impl->fd, &rd_set);\n        }\n        if (*SelectFlags & OS_STREAM_STATE_WRITABLE)\n        {\n            FD_SET(impl->fd, &wr_set);\n        }\n\n        return_code = OS_DoSelect(impl->fd, &rd_set, &wr_set, msecs);\n\n        if (return_code == OS_SUCCESS)\n        {\n            if (!FD_ISSET(impl->fd, &rd_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_READABLE;\n            }\n            if (!FD_ISSET(impl->fd, &wr_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_WRITABLE;\n            }\n        }\n        else\n        {\n            *SelectFlags = 0;\n        }\n    }\n    else\n    {\n        /* Nothing to check for, return immediately. */\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_GenericRead_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedRead']}, 'OS_GenericWrite_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedWrite']}, 'OS_SocketConnect_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketConnect']}, 'OS_SocketAccept_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl', 'OS_SetSocketDefaultFlags_Impl'], 'callers': ['OS_SocketAccept']}, 'OS_SocketRecvFrom_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketRecvFrom']}, 'OS_SelectSingle': {'callees': ['OS_printf', 'OS_ObjectIdGetById', 'OS_SelectSingle_Impl', 'OS_ObjectIdRelease', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "fd_set (definition)",
    "FD_ZERO (macro/function implementation)",
    "FD_SET (macro/function implementation)",
    "FD_ISSET (macro/function implementation)",
    "FD_SETSIZE (macro/constant)",
    "Platform select header(s) that define the FD_* implementation (e.g. <sys/select.h> / <bits/select.h> or any __FD_* helper macros such as __NFDBITS, __FD_ELT, __FD_MASK used by FD_* macros)",
    "OS_impl_file_internal_record_t (type definition)",
    "OS_OBJECT_TABLE_GET (macro/function) and OS_impl_filehandle_table (the table symbol)",
    "OS_object_token_t (type)",
    "uint32 typedef",
    "OS_STREAM_STATE_READABLE and OS_STREAM_STATE_WRITABLE (constants)",
    "OS_DoSelect (prototype)"
  ],
  "explanation": "Why each symbol is required:\n\n- fd_set (definition): You must know the exact structure/layout and size of fd_set to determine whether any memset/bit operations performed by FD_ZERO/FD_SET/FD_ISSET will write/read within its bounds.\n\n- FD_ZERO (macro/function implementation): FD_ZERO commonly uses memset() to clear an fd_set. The MISRA rule concerns use of string.h functions such as memset, so the actual implementation must be inspected to ensure it does not write beyond the fd_set object.\n\n- FD_SET (macro/function implementation): FD_SET sets bits inside fd_set. Its implementation may perform index calculations and writes; you must verify it cannot write out of bounds for the fd value used by this function.\n\n- FD_ISSET (macro/function implementation): FD_ISSET reads bits from fd_set. Its implementation must be checked to ensure it does not read out of bounds (which could result from wrong index/mask calculations).\n\n- FD_SETSIZE (macro/constant): The code explicitly compares impl->fd against FD_SETSIZE. To validate the bound check and the capacity of fd_set you need the value of FD_SETSIZE and confirm it matches the capacity implied by fd_set and the FD_* implementations.\n\n- Platform select header(s) and internal helper macros (e.g. <sys/select.h>, <bits/select.h>, __NFDBITS, __FD_ELT, __FD_MASK): The FD_* macros often rely on helper macros/constants. These internal definitions determine how indices/masks are computed and whether FD_* operations use memset (string.h) or bit-array accesses that could go out of bounds. Inspecting these headers reveals the full behavior.\n\n- OS_impl_file_internal_record_t (type definition): The function dereferences impl->fd and impl->selectable. You need the type to confirm field types and ranges (signed/unsigned) and to ensure the fd value used in FD_* calls is the expected integer and not some other type that could lead to unexpected conversions/overflows.\n\n- OS_OBJECT_TABLE_GET and OS_impl_filehandle_table: The macro/function used to obtain impl must be known to ensure impl is a valid pointer/reference to an object of the expected type. If OS_OBJECT_TABLE_GET could return an unexpected object/layout, later FD_* usage could operate on an incorrectly-typed fd_set (affecting any memset/bit operations).\n\n- OS_object_token_t (type): Needed to understand how *token is used by OS_OBJECT_TABLE_GET and to confirm the index passed to the table lookup is in-range/typed correctly.\n\n- uint32 typedef: To verify the semantics of *SelectFlags operations (bitwise masks, clearing flags) and that no implicit conversions could affect memory accesses; not directly string.h but part of correctness.\n\n- OS_STREAM_STATE_READABLE and OS_STREAM_STATE_WRITABLE (constants): These masks determine which FD_SET calls are made. You need them to reason about whether FD_SET/FD_ZERO are invoked and whether any conditional logic could lead to unsafe string.h usage.\n\n- OS_DoSelect (prototype): OS_DoSelect takes pointers to rd_set and wr_set and may modify them. To ensure no string.h violations arise during or after the call you need its prototype/implementation (it may call select() or otherwise manipulate fd_set, possibly invoking string.h functions internally).\n\nIn short, the critical items are the fd_set/FD_* definitions and FD_SETSIZE (and any helper macros) so you can inspect whether FD_ZERO/FD_SET/FD_ISSET use memcpy/memset or perform index calculations that could access beyond the fd_set object. The OS-specific types/macros (impl record, table-get, token, stream state masks, uint32, and OS_DoSelect) are required to verify that the fd value and fd_set objects passed to these macros are correct and that the bound checks in the function are sufficient to prevent out-of-bounds accesses triggered by string.h calls."
}