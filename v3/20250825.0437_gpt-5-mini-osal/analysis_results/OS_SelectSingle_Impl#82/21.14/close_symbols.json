{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectSingle_Impl(const OS_object_token_t *token, uint32 *SelectFlags, int32 msecs)\n{\n    int32                           return_code;\n    fd_set                          wr_set;\n    fd_set                          rd_set;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n     * If called on a stream_id which does not support this\n     * operation, return immediately and do not invoke the system call\n     */\n    if (!impl->selectable)\n    {\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (impl->fd >= FD_SETSIZE)\n    {\n        /* out of range of select() implementation */\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (*SelectFlags != 0)\n    {\n        FD_ZERO(&wr_set);\n        FD_ZERO(&rd_set);\n        if (*SelectFlags & OS_STREAM_STATE_READABLE)\n        {\n            FD_SET(impl->fd, &rd_set);\n        }\n        if (*SelectFlags & OS_STREAM_STATE_WRITABLE)\n        {\n            FD_SET(impl->fd, &wr_set);\n        }\n\n        return_code = OS_DoSelect(impl->fd, &rd_set, &wr_set, msecs);\n\n        if (return_code == OS_SUCCESS)\n        {\n            if (!FD_ISSET(impl->fd, &rd_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_READABLE;\n            }\n            if (!FD_ISSET(impl->fd, &wr_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_WRITABLE;\n            }\n        }\n        else\n        {\n            *SelectFlags = 0;\n        }\n    }\n    else\n    {\n        /* Nothing to check for, return immediately. */\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_GenericRead_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedRead']}, 'OS_GenericWrite_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedWrite']}, 'OS_SocketConnect_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketConnect']}, 'OS_SocketAccept_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl', 'OS_SetSocketDefaultFlags_Impl'], 'callers': ['OS_SocketAccept']}, 'OS_SocketRecvFrom_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketRecvFrom']}, 'OS_SelectSingle': {'callees': ['OS_printf', 'OS_ObjectIdGetById', 'OS_SelectSingle_Impl', 'OS_ObjectIdRelease', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_OBJECT_TABLE_GET",
    "OS_impl_filehandle_table",
    "OS_ObjectIndexFromToken",
    "OS_object_token_t",
    "OS_impl_file_internal_record_t",
    "OS_DoSelect",
    "fd_set",
    "FD_ZERO",
    "FD_SET",
    "FD_ISSET",
    "FD_SETSIZE",
    "OS_STREAM_STATE_READABLE",
    "OS_STREAM_STATE_WRITABLE",
    "OS_ERR_OPERATION_NOT_SUPPORTED",
    "OS_SUCCESS",
    "uint32"
  ],
  "explanation": "For checking the MISRA rule (memcmp must not be used to compare null\u2011terminated strings) you must inspect not only the visible code but also any macros, data types, tables, and callees that could hide a memcmp on a string. Each listed symbol could contain or invoke such a comparison or affect whether a string comparison occurs:\n\n- OS_OBJECT_TABLE_GET: macro used to obtain 'impl' \u2014 its expansion may call helper routines or perform comparisons (possibly using memcmp) when indexing the object table.\n- OS_impl_filehandle_table: the table object passed to OS_OBJECT_TABLE_GET \u2014 its implementation code or lookup helpers may perform string comparisons internally.\n- OS_ObjectIndexFromToken: listed as a callee in the static graph and commonly used by object-table accessors; its implementation must be inspected for any use of memcmp on strings.\n- OS_object_token_t: the token type passed into the macro/function \u2014 if this contains or references char* or null\u2011terminated names, memcmp might be applied to them.\n- OS_impl_file_internal_record_t: the type of 'impl' \u2014 its definition shows which fields exist (e.g., selectable, fd, or string fields) and whether any string comparisons could be hidden via field accessors.\n- OS_DoSelect: a direct callee; although unlikely to use memcmp for strings, its implementation should be checked to be certain it does not.\n- fd_set: the type manipulated by FD_* macros \u2014 check its definition in case macros are implemented in C code that uses memory comparisons (rare but must be ruled out).\n- FD_ZERO, FD_SET, FD_ISSET: macros or functions that operate on fd_set \u2014 their definitions must be inspected to ensure they do not perform any memcmp-like operations on char buffers.\n- FD_SETSIZE: the constant used for the fd range check \u2014 include to verify the range logic and rule out macros that may include hidden string comparisons.\n- OS_STREAM_STATE_READABLE, OS_STREAM_STATE_WRITABLE: bitmask constants used for SelectFlags \u2014 include to ensure no helper macros/constants expand into string comparisons.\n- OS_ERR_OPERATION_NOT_SUPPORTED, OS_SUCCESS: return-code constants used by the function \u2014 included to locate their definitions if they are macros/functions that could hide extra behavior.\n- uint32: the integer type of SelectFlags \u2014 include to ensure SelectFlags is not actually a typedef to a struct or union that could contain strings.\n\nInspecting the implementations/definitions of these symbols lets the next analyst determine whether any memcmp calls (especially those comparing null\u2011terminated strings) are present either directly in OS_SelectSingle_Impl or indirectly through macros/callees, and thus whether the MISRA rule is violated."
}