{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_SocketOpen_Impl:\n```c\nint32 OS_SocketOpen_Impl(const OS_object_token_t *token)\n{\n    int                             os_domain;\n    int                             os_type;\n    int                             os_proto;\n    int                             os_flags;\n    OS_impl_file_internal_record_t *impl;\n    OS_stream_internal_record_t *   stream;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n    stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    os_proto = 0;\n\n    switch (stream->socket_type)\n    {\n        case OS_SocketType_DATAGRAM:\n            os_type  = SOCK_DGRAM;\n            os_proto = IPPROTO_UDP;\n            break;\n\n        case OS_SocketType_STREAM:\n            os_type  = SOCK_STREAM;\n            os_proto = IPPROTO_TCP;\n            break;\n\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    switch (stream->socket_domain)\n    {\n        case OS_SocketDomain_INET:\n            os_domain = AF_INET;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            os_domain = AF_INET6;\n            break;\n#endif\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    impl->fd = socket(os_domain, os_type, os_proto);\n    if (impl->fd < 0)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Setting the REUSEADDR flag helps during debugging when there might be frequent\n     * code restarts.  However if setting the option fails then it is not worth bailing out over.\n     */\n    os_flags = 1;\n    setsockopt(impl->fd, SOL_SOCKET, SO_REUSEADDR, &os_flags, sizeof(os_flags));\n\n    /*\n     * Set the standard options on the filehandle by default --\n     * this may set it to non-blocking mode if the implementation supports it.\n     * any blocking would be done explicitly via the select() wrappers\n     *\n     * NOTE: The implementation still generally works without this flag set, but\n     * nonblock mode does improve robustness in the event that multiple tasks\n     * attempt to accept new connections from the same server socket at the same time.\n     */\n    OS_IMPL_SET_SOCKET_FLAGS(token);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_SocketOpen_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_IMPL_SET_SOCKET_FLAGS(tok) OS_SetSocketDefaultFlags_Impl(tok)\n...\nextern OS_impl_file_internal_record_t OS_impl_filehandle_table[OS_MAX_NUM_OPEN_FILES]\n...\nextern OS_stream_internal_record_t OS_stream_table[OS_MAX_NUM_OPEN_FILES]\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    int  fd;\n    bool selectable;\n} OS_impl_file_internal_record_t\n...\ntypedef struct\n{\n    char   stream_name[OS_MAX_PATH_LEN];\n    uint8  socket_domain;\n    uint8  socket_type;\n    uint16 stream_state;\n} OS_stream_internal_record_t\n...\n#define OS_NETWORK_SUPPORTS_IPV6 \n...\n#define OS_ERR_NOT_IMPLEMENTED (-28)\n...\n#define OS_ERROR (-1)\n...\n#define OS_SUCCESS (0)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the function and related symbols for compiler/language extensions that are commonly documented as extensions (for example: GCC/Clang __attribute__ annotations, asm/inline assembly, typeof, statement-expressions ({ ... }), nested functions, __extension__, platform-specific builtin keywords, nonstandard storage-class specifiers, or other vendor-specific language constructs). None are present in the provided code. The things examined include:\n\n- Preprocessor usage: only standard #ifdef/#endif and a plain #define without a value (OS_NETWORK_SUPPORTS_IPV6). An empty #define is a standard preprocessor construct, not a compiler language extension.\n- Macros: OS_OBJECT_TABLE_GET and OS_IMPL_SET_SOCKET_FLAGS expand to standard C expressions or function calls; their usage (including taking an address of an expression) is standard C and, with the provided calling pattern, is valid.\n- Types and identifiers: use of identifiers like int32, bool, uint8, uint16 are typedefs/standard types (not compiler extensions). Typedefs are standard C.\n- No compiler-specific keywords or builtins (no __attribute__, no __asm__, no typeof, no statement-expressions, no nested functions, no GCC extended asm, no pragmas shown that are vendor-specific).\n- Standard library/system calls (socket, setsockopt, AF_INET/AF_INET6, SOCK_STREAM/DGRAM, IPPROTO_TCP/UDP) are platform APIs, not language extensions.\n\nTherefore there are no code fragments in the supplied snippet that should be reported for possible use of compiler language extensions under MISRA C 2023 Rule 1.2."
}