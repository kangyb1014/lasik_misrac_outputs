{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SelectMultiple:\n```c\nint32 OS_SelectMultiple(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    int32 return_code;\n\n    /*\n     * Check parameters\n     *\n     * Note \"ReadSet\" and \"WriteSet\" are not checked, because in certain configurations they can be validly null.\n     */\n\n    /*\n     * This does not currently increment any refcounts.\n     * That means a file/socket can be closed while actively inside a\n     * OS_SelectMultiple() call in another thread.\n     */\n    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SelectMultiple:\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n...\nstatic int32 OS_FdSet_ConvertIn_Impl(int *os_maxfd, fd_set *os_set, const OS_FdSet *OSAL_set)\n{\n    size_t       offset;\n    size_t       bit;\n    osal_index_t id;\n    uint8        objids;\n    int          osfd;\n    int32        status;\n\n    status = OS_SUCCESS;\n    for (offset = 0; offset < sizeof(OSAL_set->object_ids); ++offset)\n    {\n        objids = OSAL_set->object_ids[offset];\n        bit    = 0;\n        while (objids != 0)\n        {\n            id = OSAL_INDEX_C((offset * 8) + bit);\n            if ((objids & 0x01) != 0 && id < OS_MAX_NUM_OPEN_FILES)\n            {\n                osfd = OS_impl_filehandle_table[id].fd;\n                if (osfd >= 0)\n                {\n                    if (osfd >= FD_SETSIZE || !OS_impl_filehandle_table[id].selectable)\n                    {\n                        /* out of range of select() implementation */\n                        status = OS_ERR_OPERATION_NOT_SUPPORTED;\n                    }\n                    else\n                    {\n                        FD_SET(osfd, os_set);\n                        if (osfd > *os_maxfd)\n                        {\n                            *os_maxfd = osfd;\n                        }\n                    }\n                }\n            }\n            ++bit;\n            objids >>= 1;\n        }\n    }\n\n    return status;\n}\n...\nstatic void OS_FdSet_ConvertOut_Impl(fd_set *OS_set, OS_FdSet *OSAL_set)\n{\n    size_t       offset;\n    size_t       bit;\n    osal_index_t id;\n    uint8        objids;\n    int          osfd;\n\n    for (offset = 0; offset < sizeof(OSAL_set->object_ids); ++offset)\n    {\n        objids = OSAL_set->object_ids[offset];\n        bit    = 0;\n        while (objids != 0)\n        {\n            id = OSAL_INDEX_C((offset * 8) + bit);\n            if ((objids & 0x01) != 0 && id < OS_MAX_NUM_OPEN_FILES)\n            {\n                osfd = OS_impl_filehandle_table[id].fd;\n                if (osfd < 0 || !FD_ISSET(osfd, OS_set))\n                {\n                    OSAL_set->object_ids[offset] &= ~(1 << bit);\n                }\n            }\n            ++bit;\n            objids >>= 1;\n        }\n    }\n}\n...\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n...\nint32 OS_SelectFdZero(OS_FdSet *Set)\n{\n    /* check parameters */\n    OS_CHECK_POINTER(Set);\n\n    memset(Set, 0, sizeof(OS_FdSet));\n    return OS_SUCCESS;\n}\n...\nint32 OS_SelectFdAdd(OS_FdSet *Set, osal_id_t objid)\n{\n    int32        return_code;\n    osal_index_t local_id;\n\n    /* check parameters */\n    OS_CHECK_POINTER(Set);\n\n    return_code = OS_ObjectIdToArrayIndex(OS_OBJECT_TYPE_OS_STREAM, objid, &local_id);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * Sets the bit in the uint8 object_ids array that corresponds\n         * to the local_id where local_id >> 3 determines the array element,\n         * and the mask/shift sets the bit within that element.\n         */\n        Set->object_ids[local_id >> 3] |= 1 << (local_id & 0x7);\n    }\n\n    return return_code;\n}\n...\nint32 OS_SelectFdClear(OS_FdSet *Set, osal_id_t objid)\n{\n    int32        return_code;\n    osal_index_t local_id;\n\n    /* check parameters */\n    OS_CHECK_POINTER(Set);\n\n    return_code = OS_ObjectIdToArrayIndex(OS_OBJECT_TYPE_OS_STREAM, objid, &local_id);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * Clears the bit in the uint8 object_ids array that corresponds\n         * to the local_id where local_id >> 3 determines the array element,\n         * and the mask/shift clears the bit within that element.\n         */\n        Set->object_ids[local_id >> 3] &= ~(1 << (local_id & 0x7));\n    }\n\n    return return_code;\n}\n...\nbool OS_SelectFdIsSet(const OS_FdSet *Set, osal_id_t objid)\n{\n    int32        return_code;\n    osal_index_t local_id;\n\n    /* check parameters */\n    BUGCHECK(Set != NULL, false);\n\n    return_code = OS_ObjectIdToArrayIndex(OS_OBJECT_TYPE_OS_STREAM, objid, &local_id);\n    if (return_code != OS_SUCCESS)\n    {\n        return false;\n    }\n\n    /*\n     * Returns boolean for if the bit in the uint8 object_ids array that corresponds\n     * to the local_id is set where local_id >> 3 determines the array element,\n     * and the mask/shift checks the bit within that element.\n     */\n    return ((Set->object_ids[local_id >> 3] >> (local_id & 0x7)) & 0x1);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset(Set, 0, sizeof(OS_FdSet));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in this code as written: the memset length is sizeof(OS_FdSet) and the parameter type is OS_FdSet * (and the function checks the pointer), so the call writes exactly the size of the referenced object when the caller provides a bona fide OS_FdSet object. A potential violation scenario would be if a caller passed a pointer that does not reference a full OS_FdSet (for example a pointer to a sub-object or a smaller buffer, or a pointer obtained via an incorrect cast); in that case memset(Set, 0, sizeof(OS_FdSet)) could write beyond the actual object bounds and would violate Rule 21.17."
}