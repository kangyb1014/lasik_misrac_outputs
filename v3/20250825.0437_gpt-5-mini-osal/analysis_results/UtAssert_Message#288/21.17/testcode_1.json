{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to strcmp(string, \"%s\") (and similarly strcmp(string, \"%s\\n\")) can read past the bounds of the object referenced by 'string' if 'string' is NULL or not NUL-terminated. For example, if UT_Hook_GetArgValueByName returns NULL or a pointer to a non-terminated buffer (e.g. a 2-byte buffer containing {'%','s'} without a trailing '\\0'), strcmp will continue reading memory until it finds a NUL byte and thus access memory beyond the object \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_Message code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2889.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_Message as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_Message:\n```c\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n```\n</target_code>\nPlease provide the modified UtAssert_Message code.\n",
  "test_code": "void UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    /* Probe helpers: write concise diagnostic logs to /tmp/logs/2889.txt.\n     * These helpers intentionally avoid calling string functions that\n     * might read past object bounds. They examine Spec only up to a\n     * fixed limit to prevent over-reads. */\n    {\n        /* Static probe function definitions placed inside the function\n         * scope to avoid adding global symbols. */\n        void Probe_LogSpecContent(const char *s, FILE *log)\n        {\n            if (log == NULL)\n            {\n                return;\n            }\n\n            if (s == NULL)\n            {\n                fprintf(log, \"Spec pointer: NULL\\n\");\n                return;\n            }\n\n            /* Log the pointer value. */\n            fprintf(log, \"Spec pointer: %p\\n\", (const void *)s);\n\n            /* Safely sample up to 64 bytes from Spec without assuming NUL-termination. */\n            {\n                const size_t LIMIT = 64U;\n                size_t i;\n                unsigned char c;\n\n                fprintf(log, \"Spec sample (as chars, stops at NUL or %zu bytes): \\\"\", (size_t)LIMIT);\n                for (i = 0U; i < LIMIT; ++i)\n                {\n                    c = (unsigned char)s[i];\n                    if (c == '\\0')\n                    {\n                        /* Print the terminating NUL marker and stop. */\n                        fprintf(log, \"\\\\0\");\n                        break;\n                    }\n                    /* Print printable characters as-is, others as escape hex. */\n                    if (c >= 0x20U && c <= 0x7EU)\n                    {\n                        fputc((int)c, log);\n                    }\n                    else\n                    {\n                        fprintf(log, \"\\\\x%02X\", (unsigned int)c);\n                    }\n                }\n                if (i == LIMIT)\n                {\n                    /* Indicate that the sample was truncated. */\n                    fprintf(log, \"... (truncated)\");\n                }\n                fprintf(log, \"\\\"\\n\");\n\n                /* Also output the same bytes in hex for clarity. */\n                fprintf(log, \"Spec sample (hex):\");\n                for (i = 0U; i < LIMIT; ++i)\n                {\n                    c = (unsigned char)s[i];\n                    fprintf(log, \" %02X\", (unsigned int)c);\n                    if (c == '\\0')\n                    {\n                        break;\n                    }\n                }\n                if (i == LIMIT)\n                {\n                    fprintf(log, \" ...\");\n                }\n                fprintf(log, \"\\n\");\n            }\n        }\n\n        void Probe_Log(const char *stage, const char *FileArg, const char *BaseNameArg, uint32 LineArg, size_t MsgLenArg, const char *SpecArg)\n        {\n            FILE *log = fopen(\"/tmp/logs/2889.txt\", \"a\");\n            if (log == NULL)\n            {\n                return;\n            }\n\n            fprintf(log, \"--- UtAssert_Message probe: %s ---\\n\", stage);\n            fprintf(log, \"File pointer: %p\\n\", (const void *)FileArg);\n            if (FileArg != NULL)\n            {\n                fprintf(log, \"File content sample: %p\\n\", (const void *)FileArg);\n            }\n            fprintf(log, \"BaseName pointer: %p\\n\", (const void *)BaseNameArg);\n            if (BaseNameArg != NULL)\n            {\n                /* Print a short safe sample of BaseNameArg (up to 64 bytes). */\n                size_t j;\n                const size_t LIMIT2 = 64U;\n                fprintf(log, \"BaseName sample: \\\"\");\n                for (j = 0U; j < LIMIT2; ++j)\n                {\n                    unsigned char cc = (unsigned char)BaseNameArg[j];\n                    if (cc == '\\0')\n                    {\n                        fprintf(log, \"\\\\0\");\n                        break;\n                    }\n                    if (cc >= 0x20U && cc <= 0x7EU)\n                    {\n                        fputc((int)cc, log);\n                    }\n                    else\n                    {\n                        fprintf(log, \"\\\\x%02X\", (unsigned int)cc);\n                    }\n                }\n                if (j == LIMIT2)\n                {\n                    fprintf(log, \"... (truncated)\");\n                }\n                fprintf(log, \"\\\"\\n\");\n            }\n            fprintf(log, \"Line: %u\\n\", (unsigned int)LineArg);\n            fprintf(log, \"MsgLen before formatting: %zu\\n\", MsgLenArg);\n\n            /* Probe Spec content safely. */\n            Probe_LogSpecContent(SpecArg, log);\n\n            fprintf(log, \"--- end probe ---\\n\\n\");\n            fclose(log);\n        }\n\n        /* Expose the probe functions via local pointers to call later. */\n        (void)Probe_Log;\n        (void)Probe_LogSpecContent;\n\n        /* The probe functions will be invoked in the normal control flow below. */\n    }\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n    }\n\n    /* Log state BEFORE formatting. This captures File/BaseName/Line/Spec state. */\n    {\n        /* Call the inner Probe_Log via its symbol (defined above). */\n        /* Note: Because the helper is defined in an inner block, directly call it here by re-defining a small wrapper\n         * that matches the inner helper's behavior. This keeps logic local and avoids adding external symbols. */\n        void Probe_LogLocal(const char *stage, const char *FileArg, const char *BaseNameArg, uint32 LineArg, size_t MsgLenArg, const char *SpecArg)\n        {\n            FILE *log = fopen(\"/tmp/logs/2889.txt\", \"a\");\n            if (log == NULL)\n            {\n                return;\n            }\n            fprintf(log, \"--- UtAssert_Message probe: %s ---\\n\", stage);\n            fprintf(log, \"File pointer: %p\\n\", (const void *)FileArg);\n            fprintf(log, \"BaseName pointer: %p\\n\", (const void *)BaseNameArg);\n            if (BaseNameArg != NULL)\n            {\n                size_t j;\n                const size_t LIMIT2 = 64U;\n                fprintf(log, \"BaseName sample: \\\"\");\n                for (j = 0U; j < LIMIT2; ++j)\n                {\n                    unsigned char cc = (unsigned char)BaseNameArg[j];\n                    if (cc == '\\0')\n                    {\n                        fprintf(log, \"\\\\0\");\n                        break;\n                    }\n                    if (cc >= 0x20U && cc <= 0x7EU)\n                    {\n                        fputc((int)cc, log);\n                    }\n                    else\n                    {\n                        fprintf(log, \"\\\\x%02X\", (unsigned int)cc);\n                    }\n                }\n                if (j == LIMIT2)\n                {\n                    fprintf(log, \"... (truncated)\");\n                }\n                fprintf(log, \"\\\"\\n\");\n            }\n            fprintf(log, \"Line: %u\\n\", (unsigned int)LineArg);\n            fprintf(log, \"MsgLen before formatting: %zu\\n\", MsgLenArg);\n\n            /* Spec safe sample */\n            if (SpecArg == NULL)\n            {\n                fprintf(log, \"Spec pointer: NULL\\n\");\n            }\n            else\n            {\n                fprintf(log, \"Spec pointer: %p\\n\", (const void *)SpecArg);\n                {\n                    const size_t LIMIT = 64U;\n                    size_t i;\n                    fprintf(log, \"Spec sample (as chars, stops at NUL or %zu bytes): \\\"\", (size_t)LIMIT);\n                    for (i = 0U; i < LIMIT; ++i)\n                    {\n                        unsigned char c = (unsigned char)SpecArg[i];\n                        if (c == '\\0')\n                        {\n                            fprintf(log, \"\\\\0\");\n                            break;\n                        }\n                        if (c >= 0x20U && c <= 0x7EU)\n                        {\n                            fputc((int)c, log);\n                        }\n                        else\n                        {\n                            fprintf(log, \"\\\\x%02X\", (unsigned int)c);\n                        }\n                    }\n                    if (i == LIMIT)\n                    {\n                        fprintf(log, \"... (truncated)\");\n                    }\n                    fprintf(log, \"\\\"\\n\");\n\n                    fprintf(log, \"Spec sample (hex):\");\n                    for (i = 0U; i < LIMIT; ++i)\n                    {\n                        unsigned char c = (unsigned char)SpecArg[i];\n                        fprintf(log, \" %02X\", (unsigned int)c);\n                        if (c == '\\0')\n                        {\n                            break;\n                        }\n                    }\n                    if (i == LIMIT)\n                    {\n                        fprintf(log, \" ...\");\n                    }\n                    fprintf(log, \"\\n\");\n                }\n            }\n\n            fprintf(log, \"--- end probe ---\\n\\n\");\n            fclose(log);\n        }\n\n        Probe_LogLocal(\"before_format\", File, BaseName, Line, MsgLen, Spec);\n    }\n\n    va_start(va, Spec);\n    {\n        /* Call vsnprintf and capture its return value for logging. */\n        int rv = vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n        va_end(va);\n\n        /* Log AFTER formatting: resulting message length and a safe sample of FinalMessage. */\n        {\n            FILE *log = fopen(\"/tmp/logs/2889.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"--- UtAssert_Message probe: after_format ---\\n\");\n                fprintf(log, \"vsnprintf return value: %d\\n\", rv);\n                fprintf(log, \"FinalMessage pointer: %p\\n\", (void *)FinalMessage);\n\n                /* Print a safe sample of FinalMessage (up to 256 bytes buffer size). */\n                {\n                    size_t k;\n                    const size_t LIMIT3 = 256U;\n                    fprintf(log, \"FinalMessage sample: \\\"\");\n                    for (k = 0U; k < LIMIT3; ++k)\n                    {\n                        unsigned char cc = (unsigned char)FinalMessage[k];\n                        if (cc == '\\0')\n                        {\n                            fprintf(log, \"\\\\0\");\n                            break;\n                        }\n                        if (cc >= 0x20U && cc <= 0x7EU)\n                        {\n                            fputc((int)cc, log);\n                        }\n                        else\n                        {\n                            fprintf(log, \"\\\\x%02X\", (unsigned int)cc);\n                        }\n                    }\n                    if (k == LIMIT3)\n                    {\n                        fprintf(log, \"... (truncated)\");\n                    }\n                    fprintf(log, \"\\\"\\n\");\n                }\n\n                fprintf(log, \"--- end probe ---\\n\\n\");\n                fclose(log);\n            }\n        }\n    }\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n"
}