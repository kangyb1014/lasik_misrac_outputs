{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nLikely violated. The LENGTHCHECK(name, OS_MAX_API_NAME, ...) macro typically checks the string length; if it is implemented using an unbounded function such as strlen(name) then a caller that supplies a non-terminated or only partially-initialized buffer will cause strlen to scan past the bounds of the object. Example scenario: caller has char buf[5]; memcpy(buf, \"abcdE\", 5); // no terminating '\\0' then calls OS_SocketGetIdByName(&id, buf). ARGCHECK only checks for non-NULL, so LENGTHCHECK implemented as if (strlen(name) > OS_MAX_API_NAME) { ... } will invoke strlen and may read beyond buf, violating MISRA C 2023 Rule 21.17. (If LENGTHCHECK were implemented using a bounded operation such as strnlen(name, OS_MAX_API_NAME) or an explicit loop limited by OS_MAX_API_NAME then it would be compliant.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SocketGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2469.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SocketGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SocketGetIdByName:\n```c\nint32 OS_SocketGetIdByName(osal_id_t *sock_id, const char *sock_name)\n{\n    int32 return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(sock_id);\n    OS_CHECK_POINTER(sock_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sock_name, sock_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_SocketGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Helper: safe bounded strlen that does not read past `max` bytes. */\nstatic size_t safe_strnlen(const char *s, size_t max)\n{\n    size_t i;\n    if (s == NULL)\n    {\n        return 0u;\n    }\n    for (i = 0u; i < max; ++i)\n    {\n        if (s[i] == '\\0')\n            return i;\n    }\n    return max;\n}\n\n/* Helper: log a small, bounded representation of the name and pointers to a file. */\nstatic void log_socket_state(const char *stage, const void *sock_id_ptr, const char *sock_name, long rc, int have_rc)\n{\n    FILE *f = fopen(\"/tmp/logs/2469.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    fprintf(f, \"[OS_SocketGetIdByName] stage=%s sock_id=%p sock_name=%p\\n\",\n            (stage != NULL) ? stage : \"(null)\", sock_id_ptr, (const void *)sock_name);\n\n    /* Safely log the length up to a bounded maximum and a printable preview. */\n    {\n        const size_t MAX_PREVIEW = 256u;\n        size_t len = safe_strnlen(sock_name, MAX_PREVIEW);\n        fprintf(f, \"  safe_len=%zu (max=%zu)\\n\", len, (size_t)MAX_PREVIEW);\n\n        /* Print a short preview of the bytes (hex) up to a smaller preview limit. */\n        const size_t HEX_PREVIEW = (len < 64u) ? len : 64u;\n        if (HEX_PREVIEW > 0u && sock_name != NULL)\n        {\n            size_t i;\n            fprintf(f, \"  bytes_preview(hex) =\");\n            for (i = 0u; i < HEX_PREVIEW; ++i)\n            {\n                fprintf(f, \" %02x\", (unsigned char)sock_name[i]);\n            }\n            fprintf(f, \"\\n\");\n\n            /* Also print an ASCII-safe preview (non-printable -> '.') */\n            fprintf(f, \"  ascii_preview = \\\"\");\n            for (i = 0u; i < HEX_PREVIEW; ++i)\n            {\n                unsigned char c = (unsigned char)sock_name[i];\n                if (c >= 0x20u && c <= 0x7eu)\n                    fputc((int)c, f);\n                else\n                    fputc('.', f);\n            }\n            fprintf(f, \"\\\"\\n\");\n        }\n    }\n\n    if (have_rc)\n    {\n        fprintf(f, \"  return_code=%ld\\n\", rc);\n    }\n\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\n/*\n * Modified OS_SocketGetIdByName with inserted logging probes.\n * The original logic is preserved: the existing parameter checks and the\n * call to OS_ObjectIdFindByName remain unchanged. The probes log the\n * pointer values and a bounded, safe preview of the name string before\n * and after the lookup to help reproduce the violation scenario.\n */\nint32 OS_SocketGetIdByName(osal_id_t *sock_id, const char *sock_name)\n{\n    int32 return_code;\n\n    /* Check Parameters (kept as in original to preserve behavior) */\n    OS_CHECK_POINTER(sock_id);\n    OS_CHECK_POINTER(sock_name);\n\n    /* Log state before calling the finder. Use have_rc = 0 because we\n     * don't have a return code yet. Cast sock_id to void* for the helper. */\n    log_socket_state(\"before_find\", (const void *)sock_id, sock_name, 0L, 0);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sock_name, sock_id);\n\n    /* Log state after the finder. Include the return code to help diagnose\n     * the call outcome. */\n    log_socket_state(\"after_find\", (const void *)sock_id, sock_name, (long)return_code, 1);\n\n    return return_code;\n}\n"
}