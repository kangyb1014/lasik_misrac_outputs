{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: OS_CHECK_PATHNAME(devname) expands to OS_CHECK_STRING(str,OS_MAX_PATH_LEN,...) but the definition is not provided. If OS_CHECK_STRING uses unbounded <string.h> functions such as strlen/devname (or memcpy/strcpy) then a non\u2011null\u2011terminated devname or a buffer shorter than OS_MAX_PATH_LEN would cause those functions to read/operate beyond the object bounds. For example, if OS_CHECK_STRING calls strlen(devname) and the caller passes a char array that is not NUL-terminated (or whose allocated size is less than OS_MAX_PATH_LEN without a terminator), strlen will scan past the buffer, violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rmfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1839.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rmfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rmfs:\n```c\nint32 OS_rmfs(const char *devname)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(devname);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * NOTE: It is likely that if the file system is mounted,\n         * this call to stop the volume will fail.\n         *\n         * It would be prudent to first check the flags to ensure that\n         * the filesystem is unmounted first, but this would break\n         * compatibility with the existing unit tests.\n         */\n        return_code = OS_FileSysStopVolume_Impl(&token);\n\n        /* Free the entry in the master table  */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rmfs code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe logger for OS_rmfs. This file logs control flow and state to /tmp/logs/1839.txt\n * It intentionally avoids dereferencing the devname pointer to prevent any out-of-bounds\n * accesses (so as not to introduce new violations). It records pointer values and\n * return codes at key stages to help reproduce the violation scenario described.\n */\n\nstatic void OS_rmfs_log(const char *stage, const char *devname, long long return_code, const void *token_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/1839.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log stage, devname pointer value, whether the pointer is NULL, return code and token pointer */\n    fprintf(f, \"OS_rmfs: stage=%s\\n\", stage);\n    fprintf(f, \"  devname_ptr=%p\\n\", (const void *)devname);\n    fprintf(f, \"  devname_is_null=%s\\n\", (devname == NULL) ? \"true\" : \"false\");\n    fprintf(f, \"  return_code=%lld\\n\", return_code);\n    fprintf(f, \"  token_ptr=%p\\n\", token_ptr);\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\nint32 OS_rmfs(const char *devname)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log entry with devname pointer (do NOT dereference devname here) */\n    OS_rmfs_log(\"entry\", devname, 0, NULL);\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(devname);\n\n    /* Log after the pathname check (helps to see if the macro altered flow) */\n    OS_rmfs_log(\"after_check\", devname, 0, NULL);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, devname, &token);\n\n    /* Log outcome of name lookup and the token pointer */\n    OS_rmfs_log(\"after_ObjectIdGetByName\", devname, (long long)return_code, (const void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * NOTE: It is likely that if the file system is mounted,\n         * this call to stop the volume will fail.\n         *\n         * It would be prudent to first check the flags to ensure that\n         * the filesystem is unmounted first, but this would break\n         * compatibility with the existing unit tests.\n         */\n        return_code = OS_FileSysStopVolume_Impl(&token);\n\n        /* Log result of stopping the volume */\n        OS_rmfs_log(\"after_FileSysStopVolume_Impl\", devname, (long long)return_code, (const void *)&token);\n\n        /* Free the entry in the master table  */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Log finalization result */\n        OS_rmfs_log(\"after_ObjectIdFinalizeDelete\", devname, (long long)return_code, (const void *)&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n\n        /* Log error branch */\n        OS_rmfs_log(\"name_not_found_branch\", devname, (long long)return_code, NULL);\n    }\n\n    /* Log before returning */\n    OS_rmfs_log(\"exit\", devname, (long long)return_code, (const void *)&token);\n\n    return return_code;\n}\n"
}