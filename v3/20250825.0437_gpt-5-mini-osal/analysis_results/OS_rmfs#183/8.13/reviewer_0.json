{
  "user_message": "An agent A claimed that the following OS_rmfs code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_rmfs.\n```c\nint32 OS_rmfs(const char *devname)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(devname);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * NOTE: It is likely that if the file system is mounted,\n         * this call to stop the volume will fail.\n         *\n         * It would be prudent to first check the flags to ensure that\n         * the filesystem is unmounted first, but this would break\n         * compatibility with the existing unit tests.\n         */\n        return_code = OS_FileSysStopVolume_Impl(&token);\n\n        /* Free the entry in the master table  */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes a const char *name but calls OS_ObjectIdGetBySearch(..., (void *)name, ...), explicitly casting away the const qualifier. This discards const qualification of the pointer and allows the callee signature to accept a non-const void *, violating the requirement that pointers should point to const-qualified types when possible. A corrective action is to change OS_ObjectIdGetBySearch to accept a const void * (or otherwise avoid casting away const).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: OS_rmfs(devname=0x557ee4aff1e9, devname_str=\"/ramdev3\")\nCalling: OS_ObjectIdGetByName(mode=3, type=11, name=0x557ee4aff1e9, &token=0x7ffce4bbc940)\nReturned: OS_ObjectIdGetByName -> return_code=-17, token_addr=0x7ffce4bbc940\nPath: name not found (0x557ee4aff1e9). Mapping to OS_ERR_NAME_NOT_FOUND.\nEXIT: OS_rmfs -> return_code=-17\nENTER: OS_rmfs(devname=0x557ee4aff1e9, devname_str=\"/ramdev3\")\nCalling: OS_ObjectIdGetByName(mode=3, type=11, name=0x557ee4aff1e9, &token=0x7ffce4bbc940)\nReturned: OS_ObjectIdGetByName -> return_code=-17, token_addr=0x7ffce4bbc940\nPath: name not found (0x557ee4aff1e9). Mapping to OS_ERR_NAME_NOT_FOUND.\nEXIT: OS_rmfs -> return_code=-17\nENTER: OS_rmfs(devname=0x557ee4aff1e9, devname_str=\"/ramdev3\")\nCalling: OS_ObjectIdGetByName(mode=3, type=11, name=0x557ee4aff1e9, &token=0x7ffce4bbc940)\nReturned: OS_ObjectIdGetByName -> return_code=-17, token_addr=0x7ffce4bbc940\nPath: name not found (0x557ee4aff1e9). Mapping to OS_ERR_NAME_NOT_FOUND.\nEXIT: OS_rmfs -> return_code=-17\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_rmfs:\n#define OS_CHECK_PATHNAME(str) OS_CHECK_STRING(str,OS_MAX_PATH_LEN,OS_FS_ERR_PATH_TOO_LONG)\n...\nint32 OS_ObjectIdGetByName(OS_lock_mode_t lock_mode, osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    return OS_ObjectIdGetBySearch(lock_mode, idtype, OS_ObjectNameMatch, (void *)name, token);\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_FileSysStopVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * This is a no-op.\n     *\n     * Volatile volumes are just directories created in the temp dir,\n     * and this will not remove the directories just in case something\n     * went wrong.\n     *\n     * If the volume is started again, the directory will be re-used.\n     */\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    osal_id_t final_id;\n\n    /* Clear the OSAL ID if successful - this returns the record to the pool */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n    else\n    {\n        /* this restores the original ID */\n        final_id = token->obj_id;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n    }\n\n    return operation_status;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is essentially correct: a const-qualified pointer is being cast to a non-const pointer and passed down the call chain, which goes against the intent of MISRA C 2023 Rule 8.13. In the code shown OS_rmfs itself takes const char *devname and calls OS_ObjectIdGetByName (which also takes const char *). However the additional code shows that OS_ObjectIdGetByName does this: return OS_ObjectIdGetBySearch(..., OS_ObjectNameMatch, (void *)name, token); \u2014 i.e. it explicitly casts away the const and passes a void * to OS_ObjectIdGetBySearch. If OS_ObjectIdGetBySearch (and the match callback) do not need to modify the pointed data, their parameter should be declared const void * (and any callbacks adjusted accordingly) so the const qualifier is preserved and no cast is required. As written the cast away of const qualifies as a violation of the guidance in Rule 8.13.\n\nNote: the actual cast is in OS_ObjectIdGetByName/OS_ObjectIdGetBySearch, not directly in OS_rmfs; but because OS_rmfs's const pointer flows into that call and is cast away, the report that the call chain discards const is valid. Recommended corrective action: change OS_ObjectIdGetBySearch (and related callback signatures) to accept const void * (or otherwise avoid casting away const) unless modification of the data is genuinely required."
}