{
  "user_message": "Target function code is:\n```c\nint32 OS_QueuePut_Impl(const OS_object_token_t *token, const void *data, size_t size, uint32 flags)\n{\n    int32                            return_code;\n    int                              result;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     * NOTE - using a zero timeout here for the same reason that QueueGet does ---\n     * checking the attributes and doing the actual send is non-atomic, and if\n     * two threads call QueuePut() at the same time on a nearly-full queue,\n     * one could block.\n     */\n    memset(&ts, 0, sizeof(ts));\n\n    /* send message */\n    do\n    {\n        result = mq_timedsend(impl->id, data, size, 1, &ts);\n    } while (result == -1 && errno == EINTR);\n\n    if (result == 0)\n    {\n        return_code = OS_SUCCESS;\n    }\n    else if (errno == ETIMEDOUT)\n    {\n        return_code = OS_QUEUE_FULL;\n    }\n    else\n    {\n        /* Something else went wrong */\n        return_code = OS_ERROR;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_QueuePut_Impl': {'callees': ['OS_ObjectIndexFromToken'], 'callers': ['OS_QueuePut']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_QueuePut': {'callees': ['OS_printf', 'OS_ObjectIdGetById', 'OS_ObjectIndexFromToken', 'OS_QueuePut_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_OBJECT_TABLE_GET",
    "OS_impl_queue_table",
    "OS_object_token_t",
    "OS_impl_queue_internal_record_t",
    "impl->id",
    "mqd_t",
    "mq_timedsend",
    "errno",
    "EINTR",
    "ETIMEDOUT",
    "memset",
    "struct timespec",
    "size_t",
    "uint32",
    "int32",
    "OS_SUCCESS",
    "OS_QUEUE_FULL",
    "OS_ERROR"
  ],
  "explanation": "To determine whether the target function uses any compiler language extensions (per the MISRA rule), the analyzer must inspect any macro expansions, typedefs, and symbol definitions referenced by the function because extensions are often hidden there. Reasoning for each symbol:\n\n- OS_OBJECT_TABLE_GET: This macro is invoked in the function; macros commonly hide compiler extensions (e.g. GCC statement-expressions, typeof, inline asm, __attribute__, __extension__), so its definition must be examined.\n- OS_impl_queue_table: Often used as a macro argument; its declaration/definition could contain extension usage (e.g. special section attributes, compiler-specific storage-class qualifiers).\n- OS_object_token_t: The token type may be a typedef that uses compiler-specific attributes or non-standard extensions; must inspect its definition.\n- OS_impl_queue_internal_record_t: The structure type for impl may include extensions (packed, aligned, bitfields with non-standard widths, __attribute__ markers) and affects how impl->id is interpreted.\n- impl->id: The member passed to mq_timedsend must be checked for its exact type (and any attributes). Its definition may be a typedef or macro that hides extensions.\n- mqd_t: The POSIX message queue descriptor type; the exact typedef/definition ensures compatibility with mq_timedsend and may reveal platform-specific typedefs or extensions.\n- mq_timedsend: The prototype must be known to check whether the call matches standard signatures or relies on nonstandard overloads/variants (and to see whether an implicit conversion is required that might use an extension).\n- errno: errno is often a macro expanding to a function call or thread-local expression on some platforms; its expansion should be checked for nonstandard constructs.\n- EINTR: Platform macro; check it is a standard macro and not redefined via extensions.\n- ETIMEDOUT: Same as EINTR \u2014 ensure it is a standard macro and not an extension hiding nonstandard behavior.\n- memset: Standard library function prototype (inclusion of headers or a nonstandard replacement macro could hide extensions); check that the call uses a standard declaration.\n- struct timespec: The struct definition may be platform-specific and could include extensions; the code zeroes it and takes its address for mq_timedsend, so its layout must be standard.\n- size_t: Ensure this typedef is standard and not redefined with compiler extensions.\n- uint32: This typedef (likely a fixed-width integer) could be implemented with compiler attributes or nonstandard typedefs; verify its definition.\n- int32: As above for int32 \u2014 check the typedef for extensions.\n- OS_SUCCESS: These return-code macros/constants might be defined via expressions or macros that use extensions; need to inspect their definitions.\n- OS_QUEUE_FULL: Same reasoning as OS_SUCCESS \u2014 constants/macros may hide extensions.\n- OS_ERROR: Same as above.\n\nIn short: to reliably decide whether the function uses language extensions you must inspect the definitions/expansions of all macros, typedefs, struct members, and external function prototypes referenced by the function. The symbols above are the direct ones referenced in the function whose definitions could hide such extensions."
}