{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_GetFsInfo:\n```c\nint32 OS_GetFsInfo(os_fsinfo_t *filesys_info)\n{\n    OS_object_iter_t iter;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filesys_info);\n\n    memset(filesys_info, 0, sizeof(*filesys_info));\n\n    filesys_info->MaxFds     = OS_MAX_NUM_OPEN_FILES;\n    filesys_info->MaxVolumes = OS_MAX_FILE_SYSTEMS;\n\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_STREAM, &iter);\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeFds;\n    }\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_FILESYS, &iter);\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        ++filesys_info->FreeVolumes;\n    }\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_FILESYS, &iter);",
    "memset(filesys_info, 0, sizeof(*filesys_info));",
    "OS_ObjectIdIteratorInit(OS_FileSysFilterFree, NULL, OS_OBJECT_TYPE_OS_STREAM, &iter);",
    "int32 OS_GetFsInfo(os_fsinfo_t *filesys_info)",
    "while (OS_ObjectIdIteratorGetNext(&iter))",
    "OS_ObjectIdIteratorDestroy(&iter);",
    "OS_CHECK_POINTER(filesys_info);"
  ],
  "explanation": "Fragments not listed do not need investigation with respect to MISRA C 2023 Rule 8.13 because they either operate on objects that are intentionally modified (so the pointee cannot be const-qualified) or they are non-pointer/constant-value uses. Specifically: assignments to fields of filesys_info and increments of its members clearly modify the pointed-to object, so filesys_info cannot be const. The local iterator variable is passed to iterator APIs that must modify its state, so pointers to that iterator are expected to be non-const. Literal constants and enum/macro values (e.g. OS_MAX_NUM_OPEN_FILES, OS_MAX_FILE_SYSTEMS, OS_OBJECT_TYPE_...) are not pointer targets and are irrelevant to pointer const-qualification. The return statement and simple integer increments/assignments do not introduce additional pointer targets to consider. Therefore only the listed fragments (function parameter, pointer-check/memset usage, and the iterator initialisation/get/destroy and their NULL context pointer) warrant further inspection for possible const qualification opportunities."
}