{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call casts away the const qualifier: return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token); Here 'name' is declared as const char * but is cast to void *, discarding const. This violates MISRA C 2023 Rule 8.13 (pointers should point to const-qualified types whenever possible). The proper fix is to have OS_ObjectIdFindNextMatch (and the callback type it uses) accept a const void * (or otherwise preserve the const qualification) rather than casting it away.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_QueueCreate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2293.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_QueueCreate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_QueueCreate:\n```c\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        return_code = OS_QueueCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_QueueCreate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Minimal type definitions to allow compilation of this test harness. */\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef uint32_t osal_id_t;\ntypedef uint32_t osal_blockcount_t;\n\n/* Token and queue record types (simplified) */\ntypedef int OS_object_token_t;\n\ntypedef struct\n{\n    osal_blockcount_t max_depth;\n    size_t            max_size;\n    const char       *name;\n} OS_queue_internal_record_t;\n\n/* Basic status codes */\nenum { OS_SUCCESS = 0 };\n\n/* Local object type constant (stub) */\nstatic const int LOCAL_OBJID_TYPE = 0;\n\n/* Probe/logging helper that appends messages to the required logfile. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2293.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If log cannot be opened, silently ignore to avoid changing behavior. */\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Stubs for macros/functions used by OS_QueueCreate.  Implemented as functions to\n   keep the original OS_QueueCreate body intact while enabling logging. */\nstatic void OS_CHECK_POINTER(const void *ptr)\n{\n    /* In the real code this would check and possibly return an error. Here we just log. */\n    probe_log(\"OS_CHECK_POINTER: ptr=%p\", (const void *)ptr);\n}\n\nstatic void OS_CHECK_APINAME(const char *name)\n{\n    probe_log(\"OS_CHECK_APINAME: name=%p ('%s')\", (const void *)name, name ? name : \"(null)\");\n}\n\nstatic void OS_CHECK_SIZE(size_t s)\n{\n    probe_log(\"OS_CHECK_SIZE: size=%zu\", s);\n}\n\nstatic void ARGCHECK(int condition_result, int error_code)\n{\n    probe_log(\"ARGCHECK: condition=%d, err=%d\", condition_result, error_code);\n}\n\n/* Minimal in-memory object table for the purpose of this test harness. */\nstatic OS_queue_internal_record_t OS_queue_table_storage[16];\n\n/* Provide a function with the exact same name used in the target code so the call\n   remains unchanged. This returns a pointer to a table entry for the given token. */\nstatic OS_queue_internal_record_t *OS_OBJECT_TABLE_GET(void *table, OS_object_token_t token)\n{\n    /* Log which token/table was requested. */\n    (void)table; /* silence unused param */\n    probe_log(\"OS_OBJECT_TABLE_GET: token=%d -> table_entry=%p\", token, (void *)&OS_queue_table_storage[token]);\n    return &OS_queue_table_storage[token];\n}\n\n/* Initialize an object table entry (keeps same signature usage as original). */\nstatic void OS_OBJECT_INIT(OS_object_token_t token, OS_queue_internal_record_t *queue, const char *name1, const char *name2)\n{\n    (void)token;\n    queue->name = name1;\n    probe_log(\"OS_OBJECT_INIT: token=%d, queue=%p, name1=%p ('%s'), name2=%p ('%s')\",\n              token, (void *)queue, (const void *)name1, name1 ? name1 : \"(null)\", (const void *)name2, name2 ? name2 : \"(null)\");\n}\n\n/* Stub of OS_ObjectIdAllocateNew. This would normally search existing names and allocate\n   a new token. We log the input name (which is const char *) to provide evidence that a\n   const-qualified pointer is being passed into the allocation code. */\nstatic int32 OS_ObjectIdAllocateNew(int local_type, const char *name, OS_object_token_t *token)\n{\n    (void)local_type;\n    probe_log(\"OS_ObjectIdAllocateNew: called with name=%p ('%s')\", (const void *)name, name ? name : \"(null)\");\n\n    /* Simulate finding/allocating an object id/token. Use a small deterministic token. */\n    static OS_object_token_t next_token = 1;\n    *token = next_token++;\n\n    probe_log(\"OS_ObjectIdAllocateNew: returning token=%d\", *token);\n    return OS_SUCCESS;\n}\n\n/* OS_QueueCreate_Impl stub to simulate OS-specific queue creation. */\nstatic int32 OS_QueueCreate_Impl(OS_object_token_t *token, uint32 flags)\n{\n    probe_log(\"OS_QueueCreate_Impl: token=%p (value=%d), flags=0x%08x\", (void *)token, token ? *token : -1, flags);\n    return OS_SUCCESS;\n}\n\n/* OS_ObjectIdFinalizeNew stub to emulate finalization and set the output id. */\nstatic int32 OS_ObjectIdFinalizeNew(int32 result, OS_object_token_t *token, osal_id_t *id)\n{\n    probe_log(\"OS_ObjectIdFinalizeNew: result=%d, token=%p (value=%d)\", result, (void *)token, token ? *token : -1);\n    if (result == OS_SUCCESS && id != NULL && token != NULL)\n    {\n        *id = (osal_id_t)*token;\n        probe_log(\"OS_ObjectIdFinalizeNew: assigned id=%u\", *id);\n    }\n    return result;\n}\n\n/* Constants used in original function (provide reasonable stub values). */\nstatic const osal_blockcount_t OS_QUEUE_MAX_DEPTH = 1024;\nstatic const int OS_QUEUE_INVALID_SIZE = -2;\n\n/* The target function with logging probes inserted. The original logic is preserved as much\n   as possible; additional probe_log calls provide control flow and state information. */\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    probe_log(\"ENTER: OS_QueueCreate: queue_id=%p, queue_name=%p ('%s'), queue_depth=%u, data_size=%zu, flags=0x%08x\",\n              (void *)queue_id, (const void *)queue_name, queue_name ? queue_name : \"(null)\", (unsigned)queue_depth, data_size, flags);\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    probe_log(\"Calling OS_ObjectIdAllocateNew with queue_name=%p ('%s') -- NOTE: queue_name is const char *\", (const void *)queue_name, queue_name ? queue_name : \"(null)\");\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n    probe_log(\"OS_ObjectIdAllocateNew returned %d, token=%d\", return_code, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table_storage, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        probe_log(\"Queue record updated: token=%d, queue=%p, max_depth=%u, max_size=%zu, saved_name=%p ('%s')\",\n                  token, (void *)queue, (unsigned)queue->max_depth, queue->max_size, (const void *)queue->name, queue->name ? queue->name : \"(null)\");\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        probe_log(\"Calling OS_QueueCreate_Impl for token=%d\", token);\n        return_code = OS_QueueCreate_Impl(&token, flags);\n        probe_log(\"OS_QueueCreate_Impl returned %d\", return_code);\n\n        /* Check result, finalize record, and unlock global table. */\n        probe_log(\"Calling OS_ObjectIdFinalizeNew to finalize token=%d\", token);\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n        probe_log(\"OS_ObjectIdFinalizeNew returned %d, output queue_id=%p (value=%u)\", return_code, (void *)queue_id, queue_id ? *queue_id : 0);\n    }\n\n    probe_log(\"EXIT: OS_QueueCreate returning %d\", return_code);\n    return return_code;\n}\n"
}