{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nOS_NotifyEvent invokes a function-pointer OS_SharedGlobalVars.EventHandler. If this pointer is set to OS_NotifyEvent itself (or to any handler that calls back into OS_NotifyEvent), an indirect recursive call chain is formed (OS_NotifyEvent -> EventHandler -> OS_NotifyEvent), violating Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_QueueCreate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2296.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_QueueCreate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_QueueCreate:\n```c\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        return_code = OS_QueueCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_QueueCreate code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <dlfcn.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe logging helper - appends human-readable traces to /tmp/logs/2296.txt */\nstatic void OS_QueueCreate_ProbeLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2296.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] \", (long)t);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Helper to lookup symbol addresses in the running program (NULL-safe) */\nstatic void *OS_QueueCreate_LookupSymbol(const char *name)\n{\n    /* Use the main program handle (NULL) to find exported symbols. If not found, return NULL. */\n    void *handle = dlopen(NULL, RTLD_NOW);\n    if (!handle)\n    {\n        return NULL;\n    }\n\n    void *sym = dlsym(handle, name);\n    /* Keep handle open to avoid potential issues with some platforms; it's a lightweight leak for debugging probes. */\n    return sym;\n}\n\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    /* Log entry and input parameter state */\n    OS_QueueCreate_ProbeLog(\"ENTRY: OS_QueueCreate(queue_id=%p, queue_name='%s', queue_depth=%u, data_size=%zu, flags=0x%08x)\",\n                            (void *)queue_id, (queue_name ? queue_name : \"(null)\"), (unsigned)queue_depth, data_size, (unsigned)flags);\n\n    /* Probe for symbols related to the reported Rule 17.2 scenario. Do not call any function pointers; only record addresses. */\n    void *sym_notify = OS_QueueCreate_LookupSymbol(\"OS_NotifyEvent\");\n    void *sym_eventhandler = OS_QueueCreate_LookupSymbol(\"OS_SharedGlobalVars_EventHandler\");\n    void *sym_sharedglob = OS_QueueCreate_LookupSymbol(\"OS_SharedGlobalVars\");\n\n    OS_QueueCreate_ProbeLog(\"SYMBOLS: OS_NotifyEvent=%p, OS_SharedGlobalVars_EventHandler=%p, OS_SharedGlobalVars=%p\",\n                            sym_notify, sym_eventhandler, sym_sharedglob);\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    OS_QueueCreate_ProbeLog(\"Calling OS_ObjectIdAllocateNew(...)\");\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n    OS_QueueCreate_ProbeLog(\"OS_ObjectIdAllocateNew returned %ld\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token location/size to help trace mapping between token and table lookups */\n        OS_QueueCreate_ProbeLog(\"token located at %p (size=%zu)\", (void *)&token, sizeof(token));\n\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n        OS_QueueCreate_ProbeLog(\"OS_OBJECT_TABLE_GET -> queue=%p\", (void *)queue);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        /* Record configuration fields prior to OS-specific create implementation. */\n        OS_QueueCreate_ProbeLog(\"Queue config set: max_depth=%u, max_size=%zu\", (unsigned)queue_depth, data_size);\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        OS_QueueCreate_ProbeLog(\"Calling OS_QueueCreate_Impl(&token, flags=0x%08x)\", (unsigned)flags);\n        return_code = OS_QueueCreate_Impl(&token, flags);\n        OS_QueueCreate_ProbeLog(\"OS_QueueCreate_Impl returned %ld\", (long)return_code);\n\n        /* Check result, finalize record, and unlock global table. */\n        OS_QueueCreate_ProbeLog(\"Calling OS_ObjectIdFinalizeNew(return_code=%ld, &token, queue_id=%p)\", (long)return_code, (void *)queue_id);\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n        OS_QueueCreate_ProbeLog(\"OS_ObjectIdFinalizeNew returned %ld\", (long)return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* Log the assigned object id value for post-mortem correlation */\n            OS_QueueCreate_ProbeLog(\"SUCCESS: *queue_id=%p\", (void *)*queue_id);\n        }\n        else\n        {\n            OS_QueueCreate_ProbeLog(\"FAILED finalize: return_code=%ld\", (long)return_code);\n        }\n    }\n    else\n    {\n        OS_QueueCreate_ProbeLog(\"OS_ObjectIdAllocateNew failed; early exit with %ld\", (long)return_code);\n    }\n\n    OS_QueueCreate_ProbeLog(\"EXIT: OS_QueueCreate returning %ld\", (long)return_code);\n    return return_code;\n}\n"
}