{
  "user_message": "An agent A claimed that the following OS_GetResourceName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_GetResourceName.\n```c\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        if (record->name_entry != NULL)\n        {\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function OS_ObjectIdGlobalFromToken returns a non-const pointer to an element of the global OS_common_table (return &OS_common_table[base_idx + token->obj_idx];). In callers such as OS_GetResourceName the record is only read (record->name_entry) and never modified. Because the pointer could be const-qualified (const OS_common_record_t *) to express read-only access and prevent accidental modification, returning a non-const pointer here violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_GetResourceName:\ntypedef struct OS_common_record OS_common_record_t\n...\nOS_common_record_t *OS_ObjectIdGlobalFromToken(const OS_object_token_t *token)\n{\n    uint32 base_idx = OS_GetBaseForObjectType(token->obj_type);\n    return &OS_common_table[base_idx + token->obj_idx];\n}\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CHECK_SIZE(val) ARGCHECK((val)>0&&(val)<(UINT32_MAX/2),OS_ERR_INVALID_SIZE)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's general intuition \u2014 that pointers which are only used for reading should be const-qualified \u2014 is correct. In this function the local variable 'record' is only read and therefore could legitimately be declared as 'const OS_common_record_t *record;'. However the agent's stated cause is incorrect: they attribute the violation to OS_ObjectIdGlobalFromToken returning a non-const pointer. That return type may legitimately be non-const because other callers may need to modify the records; changing the global function's return type to const would be a global API change and may be inappropriate. MISRA Rule 8.13 applies to declarations where const qualification is possible. In this specific code the real, narrow issue (if you want to enforce the rule here) is the local declaration in OS_GetResourceName \u2014 it could be const \u2014 not necessarily the global function's prototype. Therefore the report as presented (blaming OS_ObjectIdGlobalFromToken) is not correct. A suitable fix without changing the API is to declare the local pointer as const OS_common_record_t *record."
}