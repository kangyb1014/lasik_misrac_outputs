{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_ProbeLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1899.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    /* Timestamp (UTC) */\n    time_t t = time(NULL);\n    struct tm tmv;\n    if (gmtime_r(&t, &tmv) != NULL)\n    {\n        char timestr[32];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%dT%H:%M:%SZ\", &tmv) > 0)\n        {\n            fprintf(f, \"%s \", timestr);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* Log entry and parameters */\n    OS_ProbeLog(\"OS_GetResourceName ENTER: object_id=%d, buffer=%p, buffer_size=%zu\",\n                (int)object_id, (void *)buffer, buffer_size);\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    OS_ProbeLog(\"OS_ObjectIdGetById -> return_code=%d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n        OS_ProbeLog(\"record=%p\", (void *)record);\n\n        if (record->name_entry != NULL)\n        {\n            /* Log intent to call OS_strnlen - this is the call that may read up to buffer_size bytes */\n            OS_ProbeLog(\"About to call OS_strnlen(name_entry=%p, maxlen=%zu)\", (void *)record->name_entry, buffer_size);\n\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n\n            /* Log the result of strnlen and the check that determines copying behaviour */\n            OS_ProbeLog(\"OS_strnlen returned name_len=%zu (buffer_size=%zu)\", name_len, buffer_size);\n\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n                OS_ProbeLog(\"Name too long: adjusted name_len=%zu, return_code=%d\", name_len, return_code);\n            }\n\n            /* Log memcpy parameters but do not dereference name_entry here to avoid extra reads */\n            OS_ProbeLog(\"About to memcpy(dest=%p, src=%p, n=%zu)\", (void *)buffer, (void *)record->name_entry, name_len);\n\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n\n            /* Log the resulting buffer content up to a small safe limit (min(name_len, 64)) */\n            {\n                size_t i;\n                size_t show = (name_len < 64u) ? name_len : 64u;\n                /* Print as hex to avoid non-printable issues */\n                OS_ProbeLog(\"Buffer after copy (first %zu bytes):\", show);\n                for (i = 0; i < show; ++i)\n                {\n                    OS_ProbeLog(\" buffer[%zu]=0x%02X\", i, (unsigned char)buffer[i]);\n                }\n\n                if (name_len > show)\n                {\n                    OS_ProbeLog(\"... (total name_len=%zu)\", name_len);\n                }\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    OS_ProbeLog(\"OS_GetResourceName EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpi5kt94zu/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ProbeLog':\n/tmp/tmpi5kt94zu/src/src/os/shared/src/osapi-idmap.c:1418:15: error: storage size of 'tmv' isn't known\n 1418 |     struct tm tmv;\n      |               ^~~\n/tmp/tmpi5kt94zu/src/src/os/shared/src/osapi-idmap.c:1430:22: note: expected '__va_list_tag *' but argument is of type 'OCS_va_list'\n 1430 |     vfprintf(f, fmt, ap);\n      |                      ^~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-idmap.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-idmap.dir/__/__/os/shared/src/osapi-idmap.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:3787: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-idmap.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_GetResourceName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <stdarg.h>\n\nstatic void OS_ProbeLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1899.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    /* Timestamp (UTC) */\n    time_t t = time(NULL);\n    struct tm tmv;\n    if (gmtime_r(&t, &tmv) != NULL)\n    {\n        char timestr[32];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%dT%H:%M:%SZ\", &tmv) > 0)\n        {\n            fprintf(f, \"%s \", timestr);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast ap to va_list to ensure correct type is passed to vfprintf in environments\n       where va_list may be typedef'd differently internally. */\n    vfprintf(f, fmt, (va_list)ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* Log entry and parameters */\n    OS_ProbeLog(\"OS_GetResourceName ENTER: object_id=%d, buffer=%p, buffer_size=%zu\",\n                (int)object_id, (void *)buffer, buffer_size);\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    OS_ProbeLog(\"OS_ObjectIdGetById -> return_code=%d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n        OS_ProbeLog(\"record=%p\", (void *)record);\n\n        if (record->name_entry != NULL)\n        {\n            /* Log intent to call OS_strnlen - this is the call that may read up to buffer_size bytes */\n            OS_ProbeLog(\"About to call OS_strnlen(name_entry=%p, maxlen=%zu)\", (void *)record->name_entry, buffer_size);\n\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n\n            /* Log the result of strnlen and the check that determines copying behaviour */\n            OS_ProbeLog(\"OS_strnlen returned name_len=%zu (buffer_size=%zu)\", name_len, buffer_size);\n\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n                OS_ProbeLog(\"Name too long: adjusted name_len=%zu, return_code=%d\", name_len, return_code);\n            }\n\n            /* Log memcpy parameters but do not dereference name_entry here to avoid extra reads */\n            OS_ProbeLog(\"About to memcpy(dest=%p, src=%p, n=%zu)\", (void *)buffer, (void *)record->name_entry, name_len);\n\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n\n            /* Log the resulting buffer content up to a small safe limit (min(name_len, 64)) */\n            {\n                size_t i;\n                size_t show = (name_len < 64u) ? name_len : 64u;\n                /* Print as hex to avoid non-printable issues */\n                OS_ProbeLog(\"Buffer after copy (first %zu bytes):\", show);\n                for (i = 0; i < show; ++i)\n                {\n                    OS_ProbeLog(\" buffer[%zu]=0x%02X\", i, (unsigned char)buffer[i]);\n                }\n\n                if (name_len > show)\n                {\n                    OS_ProbeLog(\"... (total name_len=%zu)\", name_len);\n                }\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    OS_ProbeLog(\"OS_GetResourceName EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n",
  "explanation": "I added the missing standard headers <time.h> and <stdarg.h> (and included <stdio.h> and <string.h> for completeness) so struct tm and va_list are defined. I also cast the variable argument list when calling vfprintf: vfprintf(f, fmt, (va_list)ap); \u2014 this ensures the correct va_list type is passed in environments where va_list may be typedef'd differently. No logic in OS_GetResourceName was changed."
}