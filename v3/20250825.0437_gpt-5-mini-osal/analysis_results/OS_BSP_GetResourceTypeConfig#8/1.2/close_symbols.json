{
  "user_message": "Target function code is:\n```c\nuint32 OS_BSP_GetResourceTypeConfig(uint32 ResourceType)\n{\n    uint32 ConfigOptionValue;\n\n    if (ResourceType < OS_OBJECT_TYPE_USER)\n    {\n        ConfigOptionValue = OS_BSP_Global.ResoureConfig[ResourceType];\n    }\n    else\n    {\n        ConfigOptionValue = 0;\n    }\n\n    return ConfigOptionValue;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "uint32 (typedef/definition)",
    "OS_BSP_Global (variable declaration)",
    "struct/union type of OS_BSP_Global (definition)",
    "OS_BSP_Global.ResoureConfig (member declaration/type and array dimensions/qualifiers/attributes)",
    "OS_OBJECT_TYPE_USER (macro or enum definition)",
    "Header(s) that contain the above definitions/declarations"
  ],
  "explanation": "To determine if this function uses any compiler language extensions you must inspect the definitions of the types, macros and globals it references, since extensions frequently appear there rather than in the function body. Specifically:\n\n- uint32 (typedef/definition): The underlying typedef may use a compiler-specific type or extension (e.g. an exotic builtin, __int128, __attribute__ on the type, or compiler-specific typedefs). Confirming the typedef is a standard C type alias is necessary.\n\n- OS_BSP_Global (variable declaration): The global variable might be declared with compiler extensions (e.g. __attribute__((section(...))), __attribute__((aligned(...))), __declspec, or other vendor attributes). You need the declaration to check for such annotations.\n\n- struct/union type of OS_BSP_Global (definition): The struct/union definition can contain extensions (packed, aligned, bit-field widths using implementation-specific behavior, flexible-array members used in non-standard ways, or attributes attached to the type or members). Inspecting the full definition is required to detect those.\n\n- OS_BSP_Global.ResoureConfig (member declaration/type and array dimensions/qualifiers/attributes): The member's type may itself use extensions (VLA, GCC typeof, attributes on the member, nonstandard array declarations, or nonstandard qualifiers). Also check for unusual qualifiers (register, far, huge) or compiler storage-class specifiers.\n\n- OS_OBJECT_TYPE_USER (macro or enum definition): This macro/enum could be implemented using nonstandard constructs (typeof, statement expressions, compound literals in macros, or other compiler extensions). Verify the exact definition to ensure no extensions are used.\n\n- Header(s) that contain the above definitions/declarations: The headers may include pragmas, compiler-specific macros, or conditional compilation that introduces extensions. Provide these headers so the analyzer can see any #pragma, __attribute__, __asm__, __declspec, or other compiler-specific constructs.\n\nCollecting these symbols/definitions allows a complete check for compiler-specific keywords and attributes that would constitute a violation of the MISRA rule against language extensions."
}