{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdToArrayIndex:\n```c\nint32 OS_ObjectIdToArrayIndex(osal_objtype_t idtype, osal_id_t object_id, osal_index_t *ArrayIndex)\n{\n    uint32         max_id;\n    uint32         obj_index;\n    osal_objtype_t actual_type;\n    int32          return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(ArrayIndex);\n\n    obj_index   = OS_ObjectIdToSerialNumber_Impl(object_id);\n    actual_type = OS_ObjectIdToType_Impl(object_id);\n\n    /*\n     * If requested by the caller, enforce that the ID is of the correct type.\n     * If the caller passed OS_OBJECT_TYPE_UNDEFINED, then anything is allowed.\n     */\n    if (idtype != OS_OBJECT_TYPE_UNDEFINED && actual_type != idtype)\n    {\n        return_code = OS_ERR_INVALID_ID;\n    }\n    else\n    {\n        max_id = OS_GetMaxForObjectType(actual_type);\n        if (max_id == 0)\n        {\n            return_code = OS_ERR_INVALID_ID;\n        }\n        else\n        {\n            return_code = OS_SUCCESS;\n            *ArrayIndex = OSAL_INDEX_C(obj_index % max_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_ObjectIdToArrayIndex:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nstatic inline uint32 OS_ObjectIdToSerialNumber_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) & OS_OBJECT_INDEX_MASK);\n}\n...\nstatic inline osal_objtype_t OS_ObjectIdToType_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) >> OS_OBJECT_TYPE_SHIFT);\n}\n...\nuint32 OS_GetMaxForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_MAX_TASKS;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_MAX_QUEUES;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_MAX_BIN_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_MAX_COUNT_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MAX_MUTEXES;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_MAX_NUM_OPEN_FILES;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_MAX_NUM_OPEN_DIRS;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_MAX_TIMEBASES;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_MAX_TIMERS;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MAX_MODULES;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_MAX_FILE_SYSTEMS;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_MAX_CONSOLES;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_MAX_CONDVARS;\n        default:\n            return 0;\n    }\n}\n...\n#define OSAL_INDEX_C(X) ((osal_index_t)(X))\n...\n#define OS_OBJECT_TYPE_UNDEFINED 0x00\n...\n#define OS_ERR_INVALID_ID (-16)\n...\n#define OS_SUCCESS (0)\n...\ntypedef uint32 osal_objtype_t\n...\ntypedef uint32 osal_id_t\n...\ntypedef uint32 osal_index_t\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "actual_type = OS_ObjectIdToType_Impl(object_id);",
    "obj_index   = OS_ObjectIdToSerialNumber_Impl(object_id);",
    "OS_CHECK_POINTER(ArrayIndex);",
    "static inline osal_objtype_t OS_ObjectIdToType_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) >> OS_OBJECT_TYPE_SHIFT);\n}",
    "uint32 OS_GetMaxForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_MAX_TASKS;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_MAX_QUEUES;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_MAX_BIN_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_MAX_COUNT_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MAX_MUTEXES;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_MAX_NUM_OPEN_FILES;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_MAX_NUM_OPEN_DIRS;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_MAX_TIMEBASES;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_MAX_TIMERS;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MAX_MODULES;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_MAX_FILE_SYSTEMS;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_MAX_CONSOLES;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_MAX_CONDVARS;\n        default:\n            return 0;\n    }\n}",
    "#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)",
    "max_id = OS_GetMaxForObjectType(actual_type);\nif (max_id == 0)\n{\n    return_code = OS_ERR_INVALID_ID;\n}\nelse\n{\n    return_code = OS_SUCCESS;\n    *ArrayIndex = OSAL_INDEX_C(obj_index % max_id);\n}",
    "if (idtype != OS_OBJECT_TYPE_UNDEFINED && actual_type != idtype)\n{\n    return_code = OS_ERR_INVALID_ID;\n}",
    "static inline uint32 OS_ObjectIdToSerialNumber_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) & OS_OBJECT_INDEX_MASK);\n}"
  ],
  "explanation": "I have reported fragments that can affect reachability and therefore should be investigated: the pointer-check macro (could be a non-returning assertion/termination), the ID-to-serial/type extraction inlines (they determine actual_type and therefore which switch branch is taken), the conditional that enforces a caller-requested type mismatch, and the max_id check plus the success branch that performs the modulo and writes *ArrayIndex. Also included is the full OS_GetMaxForObjectType switch (notably its default case returning 0) because whether that default can occur at runtime directly impacts reachability of the success branch.\n\nWhy other fragments need not be investigated here:\n- The final return of return_code is reachable whenever any of the branches set return_code; all branches in the function assign return_code before the return, so the return statement itself is not suspect for unreachable-code violations.\n- The modulo operation is already guarded by the max_id == 0 test; there is no direct divide-by-zero path in the shown code (the branch that would cause a modulo by zero is avoided), so the modulo line itself is not independently unreachable in the normal logic\u2014its reachability depends on max_id which is why the max_id-related fragments were included instead.\n- The macro OSAL_INDEX_C and the integer typedefs are simple casts/aliases and do not introduce unreachable code by themselves.\n- Simple assignments and variable declarations (e.g. uint32 max_id; declarations) are standard and reachable as part of function execution; they do not constitute unreachable code.\n\nInvestigate the reported fragments to determine whether any of the branches or cases are provably never taken (e.g. BUGCHECK being non-returning, OS_GetMaxForObjectType default being unreachable given how object IDs are formed, or callers always passing OS_OBJECT_TYPE_UNDEFINED) which would create unreachable code per MISRA Rule 2.1."
}