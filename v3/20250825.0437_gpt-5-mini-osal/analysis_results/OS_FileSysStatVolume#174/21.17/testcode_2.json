{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nOS_CHECK_PATHNAME expands to a string-length check (OS_CHECK_STRING) that uses a bounded string operation such as strnlen/strncmp with OS_MAX_PATH_LEN as the bound. If the caller passes a pointer to a character array smaller than OS_MAX_PATH_LEN that does not contain a terminating '\\0' within that allocated size (for example a char buf[8] filled with 8 non-terminator bytes while OS_MAX_PATH_LEN == 64), the strnlen/strncmp would attempt to read up to OS_MAX_PATH_LEN bytes and thus access memory beyond the bounds of the referenced object. This would violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileSysStatVolume code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1749.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileSysStatVolume as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileSysStatVolume:\n```c\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileSysStatVolume code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Probe logging utilities. These are lightweight helpers that append\n * diagnostic information to /tmp/logs/1749.txt so other agents can\n * reproduce/control the scenario. They do not change program logic. */\nstatic void osfs_log_append(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1749.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Log entry/parameter state before checks. Use only pointer values\n * (no dereference) to avoid introducing new out-of-bounds accesses. */\nstatic void osfs_probe_before_checks(const char *name, const void *statbuf)\n{\n    osfs_log_append(\"[OS_FileSysStatVolume] ENTER\");\n    osfs_log_append(\"[OS_FileSysStatVolume] name ptr = %p\", (const void *)name);\n    osfs_log_append(\"[OS_FileSysStatVolume] statbuf ptr = %p\", statbuf);\n\n#ifdef OS_MAX_PATH_LEN\n    osfs_log_append(\"[OS_FileSysStatVolume] OS_MAX_PATH_LEN = %d\", (int)OS_MAX_PATH_LEN);\n#else\n    osfs_log_append(\"[OS_FileSysStatVolume] OS_MAX_PATH_LEN not defined at compile time\");\n#endif\n\n    if (name == NULL)\n    {\n        osfs_log_append(\"[OS_FileSysStatVolume] name is NULL\");\n    }\n    else\n    {\n        osfs_log_append(\"[OS_FileSysStatVolume] name is non-NULL (not dereferenced here to avoid UB)\");\n    }\n\n    if (statbuf == NULL)\n    {\n        osfs_log_append(\"[OS_FileSysStatVolume] statbuf is NULL\");\n    }\n}\n\n/* Log results from the object search call and token storage address. */\nstatic void osfs_probe_after_search(int32_t return_code, const void *token_addr)\n{\n    osfs_log_append(\"[OS_FileSysStatVolume] after OS_ObjectIdGetBySearch: return_code = %d\", (int)return_code);\n    osfs_log_append(\"[OS_FileSysStatVolume] token local variable addr = %p\", token_addr);\n}\n\n/* Log just before calling the implementation and after release. */\nstatic void osfs_probe_before_impl(const void *token_addr, const void *statbuf)\n{\n    osfs_log_append(\"[OS_FileSysStatVolume] calling OS_FileSysStatVolume_Impl; token addr = %p, statbuf = %p\",\n                     token_addr, statbuf);\n}\n\nstatic void osfs_probe_after_impl(int32_t return_code)\n{\n    osfs_log_append(\"[OS_FileSysStatVolume] returning with return_code = %d\", (int)return_code);\n    osfs_log_append(\"[OS_FileSysStatVolume] EXIT\");\n}\n\n/* Modified function with inserted probes. The original logic is preserved;\n * probes are non-intrusive and do not dereference caller buffers. */\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Probe state before performing the original checks. */\n    osfs_probe_before_checks(name, (const void *)statbuf);\n\n    /* Check parameters (original checks preserved) */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    /* Perform lookup and log the result for reproduction of the scenario. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    osfs_probe_after_search(return_code, (const void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        osfs_probe_before_impl((const void *)&token, (const void *)statbuf);\n\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    osfs_probe_after_impl(return_code);\n\n    return return_code;\n}\n"
}