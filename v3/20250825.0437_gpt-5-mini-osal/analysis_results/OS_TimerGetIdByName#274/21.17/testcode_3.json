{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf LENGTHCHECK is implemented using an unbounded <string.h> function such as strlen(name), then a non-terminated or overly long name buffer can cause reads past the object bounds. For example, a caller passes a char name[OS_MAX_API_NAME] filled with non-zero bytes with no terminating '\\0' (or passes a pointer to a buffer whose terminator lies beyond OS_MAX_API_NAME). strlen(name) would scan past the buffer boundary and thus violate MISRA C 2023 Rule 21.17. (If LENGTHCHECK instead uses a bounded operation such as strnlen(name, OS_MAX_API_NAME) or otherwise guarantees no read past the limit, then no violation occurs.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TimerGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2749.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TimerGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TimerGetIdByName:\n```c\nint32 OS_TimerGetIdByName(osal_id_t *timer_id, const char *timer_name)\n{\n    int32          return_code;\n    osal_objtype_t objtype;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_POINTER(timer_name);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_TIMECB, timer_name, timer_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TimerGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/*\n * Probe helper for logging control flow and state information to a file.\n * Writes to /tmp/logs/2749.txt so external agents can inspect the sequence\n * of events that occurred when OS_TimerGetIdByName was called.\n *\n * Note: This helper preserves the original control flow and does not modify\n * the behavior of OS_TimerGetIdByName other than producing log output.\n */\nstatic void os_timer_log_probe(const char *stage, const void *timer_id, const void *timer_name, int objtype, int return_code)\n{\n    FILE *fp = fopen(\"/tmp/logs/2749.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* Logging failure should not alter program behavior */\n    }\n\n    /* Stage and pointer addresses are the most reliable information to log\n     * without risking additional undefined behavior by dereferencing user\n     * pointers. We cast numeric values to int to avoid requiring additional\n     * format macros/types. */\n    fprintf(fp, \"OS_TimerGetIdByName: stage=%s, timer_id=%p, timer_name=%p, objtype=%d, return_code=%d\\n\",\n            (stage != NULL) ? stage : \"(null)\", timer_id, timer_name, objtype, return_code);\n\n    fclose(fp);\n}\n\nint32 OS_TimerGetIdByName(osal_id_t *timer_id, const char *timer_name)\n{\n    int32          return_code;\n    osal_objtype_t objtype;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_POINTER(timer_name);\n\n    /* Log after parameter checks so NULL pointers that cause early exits are\n     * not logged as valid. This captures that the caller passed non-NULL\n     * pointers and gives agents the pointer values to help reproduce issues. */\n    os_timer_log_probe(\"after_checks\", (const void *)timer_id, (const void *)timer_name, -1, -1);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n\n    /* Log the resolved object type so callers can see if the function\n     * returned early due to being invoked from an incorrect context. */\n    os_timer_log_probe(\"after_objtype\", (const void *)timer_id, (const void *)timer_name, (int)objtype, -1);\n\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        /* Log the early return reason */\n        os_timer_log_probe(\"return_incorrect_obj_state\", (const void *)timer_id, (const void *)timer_name, (int)objtype, (int)OS_ERR_INCORRECT_OBJ_STATE);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /* Log just before calling the underlying name lookup so the trace shows\n     * the exact moment the potentially unsafe name handling (in other\n     * implementation layers) will be invoked. */\n    os_timer_log_probe(\"before_findbyname\", (const void *)timer_id, (const void *)timer_name, (int)objtype, -1);\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_TIMECB, timer_name, timer_id);\n\n    /* Log the result of the find operation. If an out-of-bounds read occurs in\n     * the implementation of the lookup (for example via an unbounded strlen),\n     * logs up to the point of the crash will be available in the file so\n     * external agents can correlate the failure with the input pointers. */\n    os_timer_log_probe(\"after_findbyname\", (const void *)timer_id, (const void *)timer_name, (int)objtype, (int)return_code);\n\n    return return_code;\n}\n"
}