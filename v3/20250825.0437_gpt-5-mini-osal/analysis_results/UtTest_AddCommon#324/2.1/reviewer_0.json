{
  "user_message": "An agent A claimed that the following UtTest_AddCommon code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_AddCommon.\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe if (status < 0) branch is unreachable. pthread_mutex_lock() returns 0 on success or a positive errno value on failure (POSIX returns non\u2011negative values), so status < 0 can never be true. The BSP_DEBUG() path will never execute, violating MISRA C 2023 Rule 2.1. (The correct check should be status != 0 to detect errors; as written the else branch will also run on failure.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nStage=entry TestName=OS_VxWorks_BinSemAPI_Impl_Init Test=0x55c6fd794859 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_VxWorks_BinSemAPI_Impl_Init Test=0x55c6fd794859 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_VxWorks_BinSemAPI_Impl_Init Test=0x55c6fd794859 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_VxWorks_BinSemAPI_Impl_Init Test=0x55c6fd794859 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_VxWorks_BinSemAPI_Impl_Init Test=0x55c6fd794859 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemCreate_Impl Test=0x55c6fd794921 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemCreate_Impl Test=0x55c6fd794921 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemCreate_Impl Test=0x55c6fd794921 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_BinSemCreate_Impl Test=0x55c6fd794921 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_BinSemCreate_Impl Test=0x55c6fd794921 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemDelete_Impl Test=0x55c6fd794b11 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemDelete_Impl Test=0x55c6fd794b11 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemDelete_Impl Test=0x55c6fd794b11 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_BinSemDelete_Impl Test=0x55c6fd794b11 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_BinSemDelete_Impl Test=0x55c6fd794b11 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemGive_Impl Test=0x55c6fd794c21 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemGive_Impl Test=0x55c6fd794c21 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemGive_Impl Test=0x55c6fd794c21 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_BinSemGive_Impl Test=0x55c6fd794c21 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_BinSemGive_Impl Test=0x55c6fd794c21 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemFlush_Impl Test=0x55c6fd794dfd Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemFlush_Impl Test=0x55c6fd794dfd Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemFlush_Impl Test=0x55c6fd794dfd Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_BinSemFlush_Impl Test=0x55c6fd794dfd Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_BinSemFlush_Impl Test=0x55c6fd794dfd Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemTake_Impl Test=0x55c6fd794fd9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemTake_Impl Test=0x55c6fd794fd9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemTake_Impl Test=0x55c6fd794fd9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_add TestName=OS_BinSemTake_Impl Test=0x55c6fd794fd9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_unlock TestName=OS_BinSemTake_Impl Test=0x55c6fd794fd9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=entry TestName=OS_BinSemTimedWait_Impl Test=0x55c6fd7950e9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=before_lock TestName=OS_BinSemTimedWait_Impl Test=0x55c6fd7950e9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 EntryType=2\nStage=after_lock TestName=OS_BinSemTimedWait_Impl Test=0x55c6fd7950e9 Setup=0x55c6fd7954cd Teardown=0x55c6fd795553 Entr\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtTest_AddCommon:\nvoid UT_BSP_Lock(void)\n{\n    OS_BSP_Lock_Impl();\n}\n...\nvoid OS_BSP_Lock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_lock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_lock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /*\n         * Temporarily Disable/Defer thread cancellation.\n         * Note that OS_BSP_ConsoleOutput_Impl() calls write() which is a cancellation point.\n         * So if this calling task is canceled, it risks leaving the BSP locked.\n         */\n        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &OS_BSP_GenericLinuxGlobal.AccessCancelState);\n    }\n}\n...\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n...\nvoid UT_BSP_Unlock(void)\n{\n    OS_BSP_Unlock_Impl();\n}\n...\nvoid OS_BSP_Unlock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_unlock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /* Restore previous cancellability state */\n        pthread_setcancelstate(OS_BSP_GenericLinuxGlobal.AccessCancelState, NULL);\n    }\n}\n...\ntypedef struct\n{\n    void (*Test)(void);\n    void (*Setup)(void);\n    void (*Teardown)(void);\n\n    /* Note - the name entry should be long enough to support a GroupName.TestName pattern,\n     * hence why it uses double the OS_MAX_API_NAME length */\n    char TestName[OS_MAX_API_NAME * 2];\n} UtTestDataBaseEntry_t\n...\nUtAssert_Global_t UtAssert_Global\n...\nvoid UtTest_Add(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(Test, Setup, Teardown, SequenceName, UTASSERT_GROUP_TEST);\n}\n...\nvoid UtTest_AddSetup(void (*Setup)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(NULL, Setup, NULL, SequenceName, UTASSERT_GROUP_SETUP);\n}\n...\nvoid UtTest_AddTeardown(void (*Teardown)(void), const char *SequenceName)\n{\n    UtTest_AddCommon(NULL, NULL, Teardown, SequenceName, UTASSERT_GROUP_TEARDOWN);\n}\n...\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct. The UtTest_AddCommon function shown contains no unreachable code itself \u2014 the conditional in question appears in OS_BSP_Lock_Impl, not in UtTest_AddCommon. Even for OS_BSP_Lock_Impl, the if (status < 0) test is not provably unreachable in standard C because pthread_mutex_lock is an external library call whose return semantics are not intrinsic to the C language; a static MISRA checker that does not assume POSIX semantics cannot conclude the branch is unreachable. Under POSIX the pthread functions return 0 on success and a nonzero error number on failure (positive), so status < 0 will normally never be true; however this is a platform/ABI assumption rather than a C-language proof of unreachable code. If you want to both correctly detect errors and avoid the appearance of unreachable code, change the test to if (status != 0) which handles all non\u2011success returns. In summary, the report misattributes the location and overstates provable unreachable code \u2014 therefore it is not a correct MISRA 2.1 violation report."
}