{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FdSet_ConvertIn_Impl:\n```c\nstatic int32 OS_FdSet_ConvertIn_Impl(int *os_maxfd, fd_set *os_set, const OS_FdSet *OSAL_set)\n{\n    size_t       offset;\n    size_t       bit;\n    osal_index_t id;\n    uint8        objids;\n    int          osfd;\n    int32        status;\n\n    status = OS_SUCCESS;\n    for (offset = 0; offset < sizeof(OSAL_set->object_ids); ++offset)\n    {\n        objids = OSAL_set->object_ids[offset];\n        bit    = 0;\n        while (objids != 0)\n        {\n            id = OSAL_INDEX_C((offset * 8) + bit);\n            if ((objids & 0x01) != 0 && id < OS_MAX_NUM_OPEN_FILES)\n            {\n                osfd = OS_impl_filehandle_table[id].fd;\n                if (osfd >= 0)\n                {\n                    if (osfd >= FD_SETSIZE || !OS_impl_filehandle_table[id].selectable)\n                    {\n                        /* out of range of select() implementation */\n                        status = OS_ERR_OPERATION_NOT_SUPPORTED;\n                    }\n                    else\n                    {\n                        FD_SET(osfd, os_set);\n                        if (osfd > *os_maxfd)\n                        {\n                            *os_maxfd = osfd;\n                        }\n                    }\n                }\n            }\n            ++bit;\n            objids >>= 1;\n        }\n    }\n\n    return status;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FdSet_ConvertIn_Impl:\nsize_t      length = strlen(string)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif ((objids & 0x01) != 0 && id < OS_MAX_NUM_OPEN_FILES)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No \u2014 the fragment is not inherently dead code. The LHS ((objids & 0x01) != 0) controls whether the bit is set and therefore whether the body should act on that object; the RHS (id < OS_MAX_NUM_OPEN_FILES) enforces a bounds check to avoid out-of-range access. In general removing either operand would change program behaviour, so Rule 2.2 is not violated. \n\nA concrete violation scenario would be if, by construction, id is provably always < OS_MAX_NUM_OPEN_FILES for every possible (offset, bit) (for example if sizeof(OSAL_set->object_ids)*8 <= OS_MAX_NUM_OPEN_FILES and OSAL_INDEX_C maps only into that range). In that build/configuration the bound check would never affect control flow (it would always be true) and thus the id < OS_MAX_NUM_OPEN_FILES test would be dead code (its removal would not change behaviour), which would violate Rule 2.2."
}