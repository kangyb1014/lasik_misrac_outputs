{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SocketAddrInit_Impl:\n```c\nint32 OS_SocketAddrInit_Impl(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    sa_family_t             sa_family;\n    socklen_t               addrlen;\n    OS_SockAddr_Accessor_t *Accessor;\n\n    memset(Addr, 0, sizeof(OS_SockAddr_t));\n    Accessor = (OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Domain)\n    {\n        case OS_SocketDomain_INET:\n            sa_family = AF_INET;\n            addrlen   = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            sa_family = AF_INET6;\n            addrlen   = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            sa_family = 0;\n            addrlen   = 0;\n            break;\n    }\n\n    if (addrlen == 0)\n    {\n        return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    Addr->ActualLength     = OSAL_SIZE_C(addrlen);\n    Accessor->sa.sa_family = sa_family;\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SocketAddrInit_Impl:\ntypedef enum\n{\n    OS_SocketDomain_INVALID, /**< @brief Invalid */\n    OS_SocketDomain_INET,    /**< @brief IPv4 address family, most commonly used) */\n    OS_SocketDomain_INET6,   /**< @brief IPv6 address family, depends on OS/network stack support */\n    OS_SocketDomain_MAX      /**< @brief Maximum */\n} OS_SocketDomain_t\n...\n#define OS_NETWORK_SUPPORTS_IPV6 \n...\ntypedef struct\n{\n    size_t            ActualLength; /**< @brief Length of the actual address data */\n    OS_SockAddrData_t AddrData;     /**< @brief Abstract Address data */\n} OS_SockAddr_t\n...\ntypedef union\n{\n    char               data[OS_SOCKADDR_MAX_LEN];\n    struct sockaddr    sa;\n    struct sockaddr_in sa_in;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n    struct sockaddr_in6 sa_in6;\n#endif\n} OS_SockAddr_Accessor_t\n...\n#define OSAL_SIZE_C(X) ((size_t)(X))\n...\n#define OS_ERR_NOT_IMPLEMENTED (-28)\n...\n#define OS_SUCCESS (0)\n...\nint32 OS_SocketAddrInit(OS_SockAddr_t *Addr, OS_SocketDomain_t Domain)\n{\n    /* Check parameters */\n    OS_CHECK_POINTER(Addr);\n\n    return OS_SocketAddrInit_Impl(Addr, Domain);\n}\n...\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n    Addr->ActualLength     = OSAL_SIZE_C(addrlen);\n    Accessor->sa.sa_family = sa_family;\n\n    return OS_SUCCESS;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment is executed when addrlen != 0, i.e. when Domain == OS_SocketDomain_INET (and when OS_NETWORK_SUPPORTS_IPV6 is defined, also for OS_SocketDomain_INET6). The switch sets addrlen for these supported domains; for unsupported domains the default sets addrlen = 0 and the function returns early (OS_ERR_NOT_IMPLEMENTED). Therefore the lines setting Addr->ActualLength and Accessor->sa.sa_family are reachable in normal supported-domain cases and are not dead/unreachable code."
}