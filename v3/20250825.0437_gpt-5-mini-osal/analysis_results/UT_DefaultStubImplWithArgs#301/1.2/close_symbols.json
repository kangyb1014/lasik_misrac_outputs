{
  "user_message": "Target function code is:\n```c\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_DefaultStubImplWithArgs': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry', 'UT_Stub_FindRetvalConfig', 'UtAssert_Message', 'UtAssert_Abort', 'UtAssert_GetContext'], 'callers': ['UT_DefaultStubImpl', 'UT_ExecuteVaHandler']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_Stub_FindRetvalConfig': {'callees': ['UT_GetStubEntry'], 'callers': ['UT_DefaultStubImplWithArgs']}, 'UtAssert_Message': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_DefaultStubImplWithArgs', 'UT_DefaultHandler_OS_printf']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UtAssert_GetContext': {'callees': [], 'callers': ['UtAssert', 'UT_StoreRetval', 'UT_LoadRetval', 'UT_SetDeferredRetcode', 'UT_Stub_GetReturnValuePtr', 'UT_Hook_GetArgPtr', 'UT_DefaultStubImplWithArgs', 'UtMem2BinFile', 'UtBinFile2Mem', 'UtMem2HexFile', 'UtMem2BinFileCmp', 'UT_AllocStubObjId', 'UT_DeleteStubObjId']}, 'UT_DefaultStubImpl': {'callees': ['UT_DefaultStubImplWithArgs'], 'callers': ['UT_ExecuteBasicHandler', 'dummy_function']}, 'UT_ExecuteVaHandler': {'callees': ['UT_GetStubEntry', 'UT_SetVaHandlerFunction', 'UT_DefaultStubImplWithArgs'], 'callers': ['OS_printf']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "UT_Stub_FindRetvalConfig",
    "UT_Stub_IsValueCompatible",
    "UT_LoadRetval",
    "UtDebug",
    "UtAssert_Abort",
    "UtAssert_Failed",
    "UT_EntryKey_t",
    "UT_StubTableEntry_t",
    "UT_StubContext_t",
    "UT_ValueGenre_INTEGER",
    "UT_ValueGenre_OPAQUE",
    "UT_ENTRYTYPE_CALLBACK_CONTEXT",
    "UT_ENTRYTYPE_COUNTER",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_CALLBACK_HOOK",
    "UT_ENTRYTYPE_FINAL_HANDLER",
    "UT_ENTRYTYPE_RETURN_BUFFER",
    "UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED",
    "memcpy",
    "memset",
    "va_copy",
    "va_end",
    "va_list",
    "UT_ReturnValueConfig_t (Rvc)",
    "UT_CallbackData_t (Cb)",
    "UT_BufferData_t (Buff)",
    "UT_RcData_t (Rc)"
  ],
  "explanation": "For a determination of whether this function uses any compiler language extensions, the next analyzer must be able to inspect the types, macros and functions that the function depends on. The listed symbols are those referenced (directly or via struct fields) in the target function; their definitions may themselves contain compiler-specific extensions (e.g. GNU attributes, statement-expressions, typeof, inline asm, compiler-specific macros) or map to macros that expand to extensions. Brief justification for each symbol:\n\n- UT_GetStubEntry, UT_ClearStubEntry, UT_Stub_FindRetvalConfig: These functions are used repeatedly; their declarations/definitions must be checked for extension usage in prototypes, attributes, inline definitions or macro wrappers.\n- UT_Stub_IsValueCompatible, UT_LoadRetval: Called to interpret/convert return-value buffers; their implementations or macros could use compiler extensions (e.g. type-generic macros, typeof, nonstandard casts).\n- UtDebug, UtAssert_Abort, UtAssert_Failed: Logging/assert helpers are commonly macros that expand to platform-specific code (variadic macros, attributes, statement expressions). Need their definitions to ensure they do not use extensions.\n- UT_EntryKey_t: The key type used as an argument; its typedef/definition could be a compiler-specific extension (e.g. unusual underlying type, bit-field packing pragmas, attributes).\n- UT_StubTableEntry_t: Central structure accessed extensively (Data union/fields). Its definition must be inspected for any non-standard constructs (anonymous unions/structs, compiler attributes, packed/aligned pragmas, bit-field ordering extensions).\n- UT_StubContext_t: LocalContext type \u2014 must check for unusual members (e.g. flexible array members, bit-fields, anonymous structs) or attributes.\n- UT_ValueGenre_INTEGER, UT_ValueGenre_OPAQUE: Enum or macro values used in compatibility checks \u2014 need their declarations to ensure no extension use in enum/macros.\n- UT_ENTRYTYPE_* constants (CALLBACK_CONTEXT, COUNTER, UNUSED, CALLBACK_HOOK, FINAL_HANDLER, RETURN_BUFFER, RETVAL_CONFIG_DEFERRED): These may be enums or macros; macros can hide extensions, so their definitions must be checked.\n- memcpy, memset: Standard library functions are usually fine, but they may be macros or mapped to compiler intrinsics on some platforms. The analyzer should confirm their headers do not inject extensions in this build environment.\n- va_copy, va_end, va_list: Varargs macros/types may be implemented as macros or map to compiler built-ins (e.g. __builtin_va_list); va_copy in particular can be a macro alias to a compiler-specific name. Their definitions must be inspected to ensure no compiler-specific extension is relied upon.\n- UT_ReturnValueConfig_t (Rvc), UT_CallbackData_t (Cb), UT_BufferData_t (Buff), UT_RcData_t (Rc): These names stand for the nested/inner types accessed through UT_StubTableEntry_t->Data.* (Rvc, Cb, Buff, Rc). Their field types and member access patterns (indirect pointers, ActualSz, Genre, IsVarg, function-pointer types like VaHook/SimpleHook/VaHandler/SimpleHandler, CallbackArg, BasePtr, Position, TotalSize, ContentTypeStr, etc.) must be examined. In particular check:\n  - function-pointer typedefs: signatures may use nonstandard calling conventions or attributes;\n  - use of anonymous structs/unions or unnamed fields inside the union (which can be a C11/GNU extension depending on style);\n  - any use of compiler attributes, packed/aligned pragmas or nonstandard integer types.\n\nIn short: to determine whether UT_DefaultStubImplWithArgs itself uses language extensions you must also inspect every externally-defined type, macro and function it uses (the ones above). Any compiler-specific attribute, macro expansion, builtin, anonymous/extension construct or nonstandard calling convention present in those definitions would mean the function relies on language extensions even if its local code appears standard."
}