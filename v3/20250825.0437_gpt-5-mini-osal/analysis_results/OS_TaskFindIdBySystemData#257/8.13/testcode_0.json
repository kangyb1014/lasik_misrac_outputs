{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nViolation: a const-qualified pointer (sysdata of type const void *) is cast to a non-const void * in the call to OS_ObjectIdGetBySearch: (void *)sysdata. This discards the const qualifier (and the OS_ObjectMatchFunc_t prototype uses a non-const arg), which violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskFindIdBySystemData code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2573.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskFindIdBySystemData as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskFindIdBySystemData:\n```c\nint32 OS_TaskFindIdBySystemData(osal_id_t *task_id, const void *sysdata, size_t sysdata_size)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_id);\n\n    /* The \"sysdata\" and \"sysdata_size\" must be passed to the underlying impl for validation */\n    return_code = OS_TaskValidateSystemData_Impl(sysdata, sysdata_size);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_TaskIdMatchSystemData_Impl,\n                                         (void *)sysdata, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *task_id = OS_ObjectIdFromToken(&token);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskFindIdBySystemData code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n\n/* Probe/log helper - appends formatted messages to the evidence log file */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2573.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Dump up to 'max_len' bytes from 'ptr' (as hex) to the log to help reproduce state */\nstatic void probe_dump_bytes(const void *ptr, size_t len, size_t max_len)\n{\n    const unsigned char *b = (const unsigned char *)ptr;\n    size_t i, n = (len < max_len) ? len : max_len;\n    FILE *f = fopen(\"/tmp/logs/2573.txt\", \"a\");\n    if (f == NULL) return;\n\n    fprintf(f, \"Dump %zu bytes from %p:\\n\", (size_t)n, ptr);\n    for (i = 0; i < n; ++i)\n    {\n        fprintf(f, \"%02X\", b[i]);\n        if ((i + 1) % 16 == 0 || i + 1 == n)\n        {\n            fprintf(f, \"\\n\");\n        }\n        else\n        {\n            fprintf(f, \" \");\n        }\n    }\n    fclose(f);\n}\n\n/* Forward references to external symbols used by the real implementation. These are not defined\n * here because they belong to the system under test. Their prototypes are declared so the\n * modified function compiles in the same translation unit as the original code. */\n\n/* Types used by the original function */\ntypedef int32_t int32;\ntypedef void *OS_object_token_t; /* opaque in this context; used only as a token variable */\ntypedef uint32_t osal_id_t;     /* assume some integral type for printing */\n\n/* External/system functions (implemented elsewhere) */\nextern void OS_CHECK_POINTER(void *ptr);\nextern int32 OS_TaskValidateSystemData_Impl(const void *sysdata, size_t sysdata_size);\nextern int32 OS_ObjectIdGetBySearch(int lock_mode, int obj_type, void *match_func, void *sysdata, OS_object_token_t *token);\nextern osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token);\nextern void OS_ObjectIdRelease(OS_object_token_t *token);\n\n/* Keep constants opaque - these are provided by the system. */\nextern const int OS_SUCCESS;\nextern const int OS_LOCK_MODE_GLOBAL;\nextern const int LOCAL_OBJID_TYPE;\nextern const void *OS_TaskIdMatchSystemData_Impl; /* function pointer; declared const to avoid warnings */\n\n/*\n * Modified function: inserts logging probes while preserving original logic.\n * The original cast (void *)sysdata that discards const is intentionally left in place\n * so the logs can capture and demonstrate the violation scenario.\n */\nint32 OS_TaskFindIdBySystemData(osal_id_t *task_id, const void *sysdata, size_t sysdata_size)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    probe_log(\"ENTER OS_TaskFindIdBySystemData: task_id=%p sysdata=%p sysdata_size=%zu\", (void *)task_id, sysdata, sysdata_size);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_id);\n    probe_log(\"After OS_CHECK_POINTER: task_id=%p\", (void *)task_id);\n\n    /* The \"sysdata\" and \"sysdata_size\" must be passed to the underlying impl for validation */\n    probe_log(\"Calling OS_TaskValidateSystemData_Impl with sysdata=%p sysdata_size=%zu\", sysdata, sysdata_size);\n    probe_dump_bytes(sysdata, sysdata_size, 64); /* dump up to first 64 bytes to help reproduce */\n\n    return_code = OS_TaskValidateSystemData_Impl(sysdata, sysdata_size);\n    probe_log(\"OS_TaskValidateSystemData_Impl returned %d\", (int)return_code);\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Validation failed, returning %d\", (int)return_code);\n        return return_code;\n    }\n\n    /*\n     * The original code performs a cast that discards const: (void *)sysdata.\n     * Keep the cast so the original control flow and violation can be reproduced.\n     */\n    probe_log(\"About to call OS_ObjectIdGetBySearch. Note: casting away const: (void *)sysdata=%p\", (void *)sysdata);\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, (void *)OS_TaskIdMatchSystemData_Impl,\n                                         (void *)sysdata, &token);\n    probe_log(\"OS_ObjectIdGetBySearch returned %d token_addr=%p\", (int)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        *task_id = OS_ObjectIdFromToken(&token);\n        probe_log(\"Object found: task_id=%llu (0x%llX)\", (unsigned long long)(uintptr_t)(*task_id), (unsigned long long)(uintptr_t)(*task_id));\n\n        /* Dump token raw bytes to the log to capture state at the time of success */\n        probe_dump_bytes(&token, sizeof(token), sizeof(token));\n\n        OS_ObjectIdRelease(&token);\n        probe_log(\"Token released\");\n    }\n\n    probe_log(\"EXIT OS_TaskFindIdBySystemData: returning %d\", (int)return_code);\n    return return_code;\n}\n"
}