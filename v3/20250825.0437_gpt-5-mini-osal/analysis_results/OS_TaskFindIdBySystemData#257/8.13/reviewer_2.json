{
  "user_message": "An agent A claimed that the following OS_TaskFindIdBySystemData code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskFindIdBySystemData.\n```c\nint32 OS_TaskFindIdBySystemData(osal_id_t *task_id, const void *sysdata, size_t sysdata_size)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_id);\n\n    /* The \"sysdata\" and \"sysdata_size\" must be passed to the underlying impl for validation */\n    return_code = OS_TaskValidateSystemData_Impl(sysdata, sysdata_size);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_TaskIdMatchSystemData_Impl,\n                                         (void *)sysdata, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *task_id = OS_ObjectIdFromToken(&token);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nOS_ObjectIdGetBySearch takes a parameter 'void *arg' but is used with a const pointer: OS_TaskFindIdBySystemData passes (void *)sysdata where sysdata is 'const void *'. The match function OS_TaskIdMatchSystemData_Impl treats the argument as const (casts to 'const pthread_t *' and does not modify it). Casting away const in the caller and declaring the parameter non-const means the pointer does not point to a const-qualified type when it could, violating MISRA C 2023 Rule 8.13. The signature should be changed to accept 'const void *arg' (and the OS_ObjectMatchFunc_t prototype adjusted accordingly) to avoid discarding the const qualifier.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskFindIdBySystemData:\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nbool OS_TaskIdMatchSystemData_Impl(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    const pthread_t *               target = (const pthread_t *)ref;\n    OS_impl_task_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    return (pthread_equal(*target, impl->id) != 0);\n}\n...\nint32 OS_TaskValidateSystemData_Impl(const void *sysdata, size_t sysdata_size)\n{\n    if (sysdata == NULL || sysdata_size != sizeof(pthread_t))\n    {\n        return OS_INVALID_POINTER;\n    }\n    return OS_SUCCESS;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The caller OS_TaskFindIdBySystemData casts away the const qualifier by passing (void *)sysdata into OS_ObjectIdGetBySearch, even though the callee chain treats the data as read-only. The match function OS_TaskIdMatchSystemData_Impl interprets the argument as a const pthread_t * and does not modify it, and the validation helper already takes a const void *. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the API should preserve the const qualification (e.g. change OS_ObjectIdGetBySearch/OS_ObjectMatchFunc_t and OS_TaskIdMatchSystemData_Impl to take const void */const ref). Casting away const to fit the current non-const prototype therefore violates the intent of Rule 8.13."
}