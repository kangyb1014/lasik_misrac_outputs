{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}, 'OS_FdSet_ConvertIn_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_FdSet_ConvertOut_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_SelectMultiple': {'callees': ['OS_SelectMultiple_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_FdSet_ConvertIn_Impl (prototype and body)",
    "OS_FdSet_ConvertOut_Impl (prototype and body)",
    "OS_DoSelect (prototype and body)",
    "OS_FdSet (typedef/struct definition)",
    "fd_set (typedef/struct definition)",
    "FD_ZERO (macro or function definition)",
    "OS_SUCCESS (macro/constant definition)",
    "OS_ERR_INVALID_ID (macro/constant definition)",
    "int32 (typedef definition)"
  ],
  "explanation": "To determine whether OS_SelectMultiple_Impl violates the MISRA rule \"A function parameter should not be modified\" you must be able to prove that none of the formal parameter variables (ReadSet, WriteSet, msecs) are assigned to inside the function or indirectly altered as variables of this function. The following symbols are required and why:\n\n- OS_FdSet_ConvertIn_Impl (prototype and body): This callee is invoked with ReadSet and WriteSet as arguments. You need its prototype to confirm its parameter types (e.g., whether it takes OS_FdSet * or OS_FdSet **). If it accepted a pointer-to-pointer and the call passed the address of a caller variable, that could indicate modification of the caller's pointer; the body is needed to check for any side-effects that could alter the value of the actual parameter variables (though in C, passing a pointer by value normally cannot change the caller's pointer itself).\n\n- OS_FdSet_ConvertOut_Impl (prototype and body): Same reasoning as ConvertIn_Impl \u2014 it is called with the ReadSet/WriteSet parameters. The prototype/body show whether the callee could modify the pointer variable in the caller (e.g., via pointer-to-pointer parameters) or perform macro-like operations that might affect the caller's formal parameters.\n\n- OS_DoSelect (prototype and body): Although msecs is passed by value, confirm the function's signature to ensure msecs is not passed by address or via a macro expansion that could affect the caller's formal variable. The body is needed to see if any global or macro trickery could indirectly modify formal parameter variables (rare but possible in embedded code bases).\n\n- OS_FdSet (typedef/struct definition): Knowing the concrete type of OS_FdSet clarifies whether any operations or macros elsewhere could alias or reinterpret the ReadSet/WriteSet variables (e.g., if OS_FdSet is a macro that expands to something unexpected). Also needed to interpret callee prototypes precisely.\n\n- fd_set (typedef/struct definition): FD_ZERO and FD-related operations act on fd_set; confirm these operate only on local rd_set/wr_set, not on the formal pointer parameters, and that there is no macro name collision or unexpected expansion involving ReadSet/WriteSet.\n\n- FD_ZERO (macro or function definition): FD_ZERO is a macro in many platforms and could conceivably expand in an unexpected way in some headers. Verify it only operates on its fd_set operand and does not reference or modify any function parameters.\n\n- OS_SUCCESS (macro/constant definition) and OS_ERR_INVALID_ID (macro/constant definition): Verify these are simple constant macros (no side effects). If they were macros with expressions that could modify variables (unlikely but possible), that could affect analysis of return_code and control flow relevant to parameter modification.\n\n- int32 (typedef definition): To ensure msecs is indeed an integer-by-value type (and not a macro/type alias that could be a pointer) so that passing msecs cannot result in the callee modifying the caller's msecs.\n\nIn short, the three callees' prototypes/bodies and the relevant type/macro definitions are necessary to prove whether any code (directly or indirectly) assigns to the formal parameter variables ReadSet, WriteSet or msecs. These symbols let you confirm that only the objects pointed to by ReadSet/WriteSet are modified (which is permitted), and that the pointer variables themselves are never reassigned or otherwise modified inside or via callees (which would violate the MISRA rule)."
}