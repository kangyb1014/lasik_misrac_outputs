{
  "user_message": "An agent A claimed that the following OS_SelectMultiple_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_SelectMultiple_Impl.\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes &wr_set as an input-only argument to OS_FdSet_ConvertOut_Impl. If OS_FdSet_ConvertOut_Impl's corresponding parameter is not const-qualified (e.g. prototype uses fd_set * rather than const fd_set *), this is a violation because the function only needs to read the fd_set to populate the OS_FdSet. The fd_set pointer should be const-qualified to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEnter OS_SelectMultiple_Impl: p1=(nil) p2=0x7ffc81b04dd1 v1=1 v2=0\nAfter FD_ZERO and init: p1=0x7ffc81b04ce0 p2=0x7ffc81b04c60 v1=-1 v2=0\nAfter OS_FdSet_ConvertIn_Impl (Write): p1=0x7ffc81b04c60 p2=0x7ffc81b04dd1 v1=-1 v2=0\nNo fds to select on, invalid id: p1=(nil) p2=(nil) v1=-16 v2=0\nExit OS_SelectMultiple_Impl: p1=(nil) p2=(nil) v1=-16 v2=-1\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim is not supported by the provided code. MISRA C 2023 Rule 8.13 concerns declarations: a pointer parameter should point to a const-qualified type when the pointed-to object is not modified. The code shown only contains calls (e.g. OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet)) and local declarations; it does not show the prototype/signature of OS_FdSet_ConvertOut_Impl. Whether there is a violation depends on that function's declaration: only if the prototype uses a non-const fd_set * even though the function does not modify the fd_set would Rule 8.13 be violated. The evidence presented (the call sites and the runtime log) does not prove the prototype lacks const qualification, nor prove the function does not modify the fd_set. Therefore the report as stated is not correct based on the information given. To confirm a violation, inspect the declaration of OS_FdSet_ConvertOut_Impl and verify whether its fd_set pointer parameter could and should be declared as const."
}