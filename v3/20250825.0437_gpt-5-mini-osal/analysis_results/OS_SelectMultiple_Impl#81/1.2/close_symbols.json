{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}, 'OS_FdSet_ConvertIn_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_FdSet_ConvertOut_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_SelectMultiple': {'callees': ['OS_SelectMultiple_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "int32",
    "OS_FdSet",
    "OS_SUCCESS",
    "OS_ERR_INVALID_ID",
    "OS_FdSet_ConvertIn_Impl",
    "OS_FdSet_ConvertOut_Impl",
    "OS_DoSelect",
    "fd_set",
    "FD_ZERO",
    "NULL"
  ],
  "explanation": "For checking MISRA C rule 'Language extensions should not be used' we must inspect any types, macros, constants, or called routines that could hide compiler-specific extensions. Each listed symbol is required for the analysis for the reasons below:\n\n- int32: This is a typedef (non-standard identifier). Its underlying definition must be checked to ensure it does not use compiler-specific types/keywords or attributes (e.g., __int64, __attribute__, __extension__, or other compiler extensions).\n\n- OS_FdSet: The OS_FdSet type may be a typedef or struct that could use language extensions (anonymous structs/unions, bit-field extensions, __attribute__ packing/alignment, flexible array members implemented non-portably). The full definition is needed.\n\n- OS_SUCCESS: A macro/constant used for flow control. Its definition should be checked for extension-like constructs (macros using compiler builtins or attributes).\n\n- OS_ERR_INVALID_ID: Same as OS_SUCCESS \u2014 verify it is a plain integer constant and not defined via compiler-specific constructs.\n\n- OS_FdSet_ConvertIn_Impl: The prototype/definition of this function must be inspected to see if it uses nonstandard parameter/return attributes or language extensions in its implementation that affect usage in the target function (calling conventions, inline asm, attributes, nonstandard qualifiers).\n\n- OS_FdSet_ConvertOut_Impl: Same rationale as ConvertIn \u2014 check the signature/definition for any language extensions.\n\n- OS_DoSelect: The implementation/prototype may use compiler-specific extensions (e.g., variable argument macros, nonstandard attributes, inline assembler, or nonportable headers). Also its parameters/return type could be typedefs using extensions.\n\n- fd_set: This is the system select() fd set type (from <sys/select.h> or equivalent). Its definition or macros that implement it must be checked in case the platform header uses compiler-specific constructs.\n\n- FD_ZERO: A macro (usually from system headers) that expands to code manipulating fd_set. The macro expansion must be inspected to ensure it does not use compiler-specific extensions (statement expressions, GCC extensions, builtins, or other nonstandard constructs).\n\n- NULL: The null macro definition should be checked to ensure it is a standard definition and not a compiler-specific extension.\n\nIncluding these symbols (their typedefs/macros/prototypes/definitions and relevant headers) in the next-agent prompt allows inspection of any hidden compiler-specific keywords, attributes, macros, or constructs that would violate the MISRA rule."
}