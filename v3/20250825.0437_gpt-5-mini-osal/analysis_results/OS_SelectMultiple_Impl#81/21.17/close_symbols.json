{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}, 'OS_FdSet_ConvertIn_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_FdSet_ConvertOut_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_SelectMultiple': {'callees': ['OS_SelectMultiple_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_FdSet_ConvertIn_Impl",
    "OS_FdSet_ConvertOut_Impl",
    "OS_DoSelect",
    "OS_FdSet (type/definition)",
    "fd_set (type/definition)",
    "FD_ZERO (macro/definition)",
    "FD_SET / FD_CLR / FD_ISSET (macros/definitions)",
    "<sys/select.h> or header that defines fd_set/FD_* macros"
  ],
  "explanation": "- OS_FdSet_ConvertIn_Impl: This function is called to populate the local fd_set (rd_set/wr_set). To check for any misuse of string.h routines (memcpy/memset/etc.) you must inspect its implementation for calls to those functions and for the pointer/length arguments it uses.\n- OS_FdSet_ConvertOut_Impl: This converts the kernel fd_set back into the OS_FdSet representation. It may use memcpy/memset or similar and must be checked for out-of-bounds accesses and correct length calculations.\n- OS_DoSelect: Although it likely calls the system select(), its implementation may also manipulate fd_set objects or call memcpy/memset. Inspecting it ensures no string.h functions are used incorrectly on rd_set/wr_set.\n- OS_FdSet (type/definition): The layout, size and field types of the OS-specific FD set object are required to determine the valid bounds when ConvertIn/ConvertOut copy data to/from fd_set and to verify that any memcpy/memset lengths are correct.\n- fd_set (type/definition): The exact size and representation of the fd_set used by FD_ZERO and the system select call are required to ensure any memset/memcpy use targets the correct number of bytes and does not write beyond the object.\n- FD_ZERO (macro/definition): FD_ZERO is invoked directly in this function and is commonly implemented using memset. You must see its definition to confirm the size/length passed to memset (or if another routine is used) to ensure it does not produce out-of-bounds writes.\n- FD_SET / FD_CLR / FD_ISSET (macros/definitions): These macros are commonly used inside the conversion functions. Their implementations determine how bits/indices map into fd_set memory and whether any helper routines use string.h functions incorrectly.\n- <sys/select.h> or header that defines fd_set/FD_* macros: The header will contain the canonical definitions/implementations (or inline macros) referenced above; the exact code is needed to reason about any string.h usage and byte counts.\n\nProviding these symbols/definitions allows static analysis of all places where standard string.h functions could be invoked on the fd_set/OS_FdSet objects and lets you verify that the length/size arguments are correct to avoid out-of-bounds accesses per the MISRA rule."
}