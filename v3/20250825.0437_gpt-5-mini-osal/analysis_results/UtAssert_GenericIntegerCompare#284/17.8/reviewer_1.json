{
  "user_message": "An agent A claimed that the following UtAssert_GenericIntegerCompare code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_GenericIntegerCompare.\n```c\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    if (strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        ActualText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n    if (strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        RefText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'RadixType' (an enum passed by value) is assigned to: RadixType = UtAssert_Radix_HEX; (when RadixType == UtAssert_Radix_DEFAULT and strchr(Typename,'*') != NULL). This modifies a function parameter and thus violates MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-console.c\n  Line: 63\n  IsUnsigned: 0\n  ActualValue: 0\n  RefValue   : 0\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_taskSpawn()\n  RefText    : 0\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_taskSpawn()\n  RefText (post-strip)   : 0\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-console.c\n  Line: 68\n  IsUnsigned: 0\n  ActualValue: 1\n  RefValue   : 1\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_taskSpawn()\n  RefText    : 1\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_taskSpawn()\n  RefText (post-strip)   : 1\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-idmap.c\n  Line: 45\n  IsUnsigned: 0\n  ActualValue: 1\n  RefValue   : 1\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_semTake()\n  RefText    : 1\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_semTake()\n  RefText (post-strip)   : 1\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-idmap.c\n  Line: 49\n  IsUnsigned: 0\n  ActualValue: 1\n  RefValue   : 1\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_semTake()\n  RefText    : 1\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_semTake()\n  RefText (post-strip)   : 1\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-idmap.c\n  Line: 64\n  IsUnsigned: 0\n  ActualValue: 1\n  RefValue   : 1\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_semGive()\n  RefText    : 1\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_semGive()\n  RefText (post-strip)   : 1\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/vxworks/src/coveragetest-idmap.c\n  Line: 68\n  IsUnsigned: 0\n  ActualValue: 1\n  RefValue   : 1\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_semGive()\n  RefText    : 1\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_semGive()\n  RefText (post-strip)   : 1\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/portable/src/coveragetest-bsd-select.c\n  Line: 80\n  IsUnsigned: 0\n  ActualValue: 3\n  RefValue   : 3\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename   : CallCount\n  ActualText : OCS_clock_gettime()\n  RefText    : 3\n  TagStr after processing: 'CallCount: '\n  TagLen: 11\nEXIT UtAssert_GenericIntegerCompare\n  Final RadixType: 10\n  TagStr: 'CallCount: '\n  ActualText (post-strip): OCS_clock_gettime()\n  RefText (post-strip)   : 3\n----------------------------------------\nENTRY UtAssert_GenericIntegerCompare\n  File: /tmp/tmpi6dx565j/src/src/unit-test-coverage/portable/src/coveragetest-bsd-select.c\n  Line: 81\n  IsUnsigned: 0\n  ActualValue: 2\n  RefValue   : 2\n  CompareType: 1\n  RadixType  : 10 (initial)\n  Typename\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_GenericIntegerCompare:\ntypedef ptrdiff_t UT_IntCheck_t\n...\ntypedef enum\n{\n    UtAssert_Compare_NONE,          /**< invalid/not used, always false */\n    UtAssert_Compare_EQ,            /**< actual equals reference value */\n    UtAssert_Compare_NEQ,           /**< actual does not non equal reference value */\n    UtAssert_Compare_LT,            /**< actual less than reference (exclusive) */\n    UtAssert_Compare_GT,            /**< actual greater than reference (exclusive)  */\n    UtAssert_Compare_LTEQ,          /**< actual less than or equal to reference (inclusive) */\n    UtAssert_Compare_GTEQ,          /**< actual greater than reference (inclusive) */\n    UtAssert_Compare_BITMASK_SET,   /**< actual equals reference value */\n    UtAssert_Compare_BITMASK_UNSET, /**< actual equals reference value */\n    UtAssert_Compare_MAX            /**< placeholder, not used */\n} UtAssert_Compare_t\n...\ntypedef enum\n{\n    UtAssert_Radix_DEFAULT = 0,  /**< no preference, use default */\n    UtAssert_Radix_BOOLEAN = 1,  /**< log integers as logical true (1) / false (0) */\n    UtAssert_Radix_OCTAL   = 8,  /**< log integers as octal, base 8 */\n    UtAssert_Radix_DECIMAL = 10, /**< log integers as decimal, base 10 */\n    UtAssert_Radix_HEX     = 16  /**< log integers as hexadecimal, base 16 */\n} UtAssert_Radix_t\n...\ntypedef uint32_t  uint32\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. RadixType is a scalar (enum) function parameter passed by value. The code assigns to it (RadixType = UtAssert_Radix_HEX;), which is a direct modification of a function parameter. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (the only allowed modification is to the object referred to by a pointer parameter, not to the pointer itself). The pointer exception does not apply here. Even if the assignment may not be taken at runtime in the observed traces, the assignment in the source is a rule violation. A compliant fix is to copy the parameter to a local variable and modify the local variable instead."
}