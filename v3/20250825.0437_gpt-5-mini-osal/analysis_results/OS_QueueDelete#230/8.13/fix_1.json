{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n#include <stdio.h>\\n#include <stdint.h>\\n#include <string.h>\\n#include <stdarg.h>\\n\\n/* Minimal type stubs to allow standalone compilation for testing. */\\ntypedef int32_t int32;\\ntypedef uint32_t osal_id_t;\\n\\ntypedef struct\\n{\\n    uint32_t value1;\\n    uint32_t value2;\\n} OS_object_token_t;\\n\\n/* Common constants used in the original code */\\n#define OS_SUCCESS                 0\\n#define OS_LOCK_MODE_EXCLUSIVE     1\\n#define LOCAL_OBJID_TYPE           2\\n\\n/* Prototypes for the (project) functions used by OS_QueueDelete.  */\\nint32 OS_ObjectIdGetById(int lock_mode, int local_type, osal_id_t id, OS_object_token_t *token);\\nint32 OS_QueueDelete_Impl(OS_object_token_t *token);\\nint32 OS_ObjectIdFinalizeDelete(int32 return_code, OS_object_token_t *token);\\n\\n/* ------------------------------------------------------------------\\n   Logging helpers: write useful probe information to \\\"/tmp/logs/2303.txt\\\".\\n   These helpers are intentionally simple: they append human-readable\\n   control-flow and token-state information so other agents can reproduce\\n   and gather evidence for the violation scenario.\\n   ------------------------------------------------------------------ */\\nstatic void log_printf(const char *fmt, ...)\\n{\\n    FILE *f = fopen(\\\"/tmp/logs/2303.txt\\\", \\\"a\\\");\\n    if (f == NULL)\\n    {\\n        /* Best-effort: if logging fails, do nothing. */\\n        return;\\n    }\\n\\n    va_list ap;\\n    va_start(ap, fmt);\\n    vfprintf(f, fmt, ap);\\n    va_end(ap);\\n    fprintf(f, \\\"\\\\n\\\");\\n    fclose(f);\\n}\\n\\nstatic void log_token_state(const char *label, const OS_object_token_t *token)\\n{\\n    if (token == NULL)\\n    {\\n        log_printf(\\\"%s: token = NULL\\\", label);\\n        return;\\n    }\\n\\n    /* Print basic info and raw byte contents so that a later comparison\\n       can show whether OS_QueueDelete_Impl modified the token. */\\n    log_printf(\\\"%s: token_addr=%p size=%zu value1=0x%08x value2=0x%08x\\\",\\n               label,\\n               (const void *)token,\\n               sizeof(*token),\\n               (unsigned)token->value1,\\n               (unsigned)token->value2);\\n\\n    /* Dump raw bytes in hex to detect any subtle changes. */\\n    {\\n        const unsigned char *p = (const unsigned char *)token;\\n        size_t i;\\n        char buf[3 * sizeof(*token) + 1]; /* \\\"AA \\\" per byte plus NUL */\\n        size_t pos = 0;\\n        for (i = 0; i < sizeof(*token) && (pos + 3) < sizeof(buf); ++i)\\n        {\\n            int written = snprintf(&buf[pos], sizeof(buf) - pos, \\\"%02X \\\", p[i]);\\n            if (written < 0)\\n                break;\\n            pos += (size_t)written;\\n        }\\n        buf[pos] = '\\\\0';\\n        log_printf(\\\"%s: bytes=%s\\\", label, buf);\\n    }\\n}\\n\\n/* ------------------------------------------------------------------\\n   Modified OS_QueueDelete with probes inserted. The logic is kept\\n   identical to the original routine, with logging before/after key calls\\n   so agents can observe whether OS_QueueDelete_Impl mutates the token.\\n   ------------------------------------------------------------------ */\\nint32 OS_QueueDelete(osal_id_t queue_id)\\n{\\n    OS_object_token_t token;\\n    int32             return_code;\\n\\n    log_printf(\\\"OS_QueueDelete: called with queue_id=%u\\\", (unsigned)queue_id);\\n\\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, queue_id, &token);\\n    log_printf(\\\"OS_ObjectIdGetById returned %d\\\", (int)return_code);\\n\\n    if (return_code == OS_SUCCESS)\\n    {\\n        /* Log token state before calling the implementation. */\\n        log_token_state(\\\"token_before_Impl\\\", &token);\\n\\n        /* Call the implementation (note: many real-world implementations\\n           declare this parameter as non-const; the MISRA issue arises if\\n           the implementation does not actually modify the token). */\\n        return_code = OS_QueueDelete_Impl(&token);\\n        log_printf(\\\"OS_QueueDelete_Impl returned %d\\\", (int)return_code);\\n\\n        /* Log token state after calling the implementation so we can detect\\n           whether the implementation modified the token (evidence for or\\n           against the need for a const-qualified parameter). */\\n        log_token_state(\\\"token_after\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_QueueDelete as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdarg.h>\n\n/* Minimal type stubs to allow standalone compilation for testing. */\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\n\ntypedef struct\n{\n    uint32_t value1;\n    uint32_t value2;\n} OS_object_token_t;\n\n/* Common constants used in the original code (use consts instead of macros). */\nstatic const int OS_SUCCESS = 0;\nstatic const int OS_LOCK_MODE_EXCLUSIVE = 1;\nstatic const int LOCAL_OBJID_TYPE = 2;\n\n/* Prototypes for the (project) functions used by OS_QueueDelete. */\nint32 OS_ObjectIdGetById(int lock_mode, int local_type, osal_id_t id, OS_object_token_t *token);\nint32 OS_QueueDelete_Impl(OS_object_token_t *token);\nint32 OS_ObjectIdFinalizeDelete(int32 return_code, OS_object_token_t *token);\n\n/* ------------------------------------------------------------------\n   Logging helpers: write useful probe information to \"/tmp/logs/2303.txt\".\n   These helpers are intentionally simple: they append human-readable\n   control-flow and token-state information so other agents can reproduce\n   and gather evidence for the violation scenario.\n   ------------------------------------------------------------------ */\nstatic void log_printf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2303.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Best-effort: if logging fails, do nothing. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void log_token_state(const char *label, const OS_object_token_t *token)\n{\n    if (token == NULL)\n    {\n        log_printf(\"%s: token = NULL\", label);\n        return;\n    }\n\n    /* Print basic info and raw byte contents so that a later comparison\n       can show whether OS_QueueDelete_Impl modified the token. */\n    log_printf(\"%s: token_addr=%p size=%zu value1=0x%08x value2=0x%08x\",\n               label,\n               (const void *)token,\n               sizeof(*token),\n               (unsigned)token->value1,\n               (unsigned)token->value2);\n\n    /* Dump raw bytes in hex to detect any subtle changes. */\n    {\n        const unsigned char *p = (const unsigned char *)token;\n        size_t i;\n        char buf[3 * sizeof(*token) + 1]; /* \"AA \" per byte plus NUL */\n        size_t pos = 0;\n        for (i = 0; i < sizeof(*token) && (pos + 3) < sizeof(buf); ++i)\n        {\n            int written = snprintf(&buf[pos], sizeof(buf) - pos, \"%02X \", p[i]);\n            if (written < 0)\n                break;\n            pos += (size_t)written;\n        }\n        buf[pos] = '\\0';\n        log_printf(\"%s: bytes=%s\", label, buf);\n    }\n}\n\n/* ------------------------------------------------------------------\n   Modified OS_QueueDelete with probes inserted. The logic is kept\n   identical to the original routine, with logging before/after key calls\n   so agents can observe whether OS_QueueDelete_Impl mutates the token.\n   ------------------------------------------------------------------ */\nint32 OS_QueueDelete(osal_id_t queue_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    log_printf(\"OS_QueueDelete: called with queue_id=%u\", (unsigned)queue_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, queue_id, &token);\n    log_printf(\"OS_ObjectIdGetById returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token state before calling the implementation. */\n        log_token_state(\"token_before_Impl\", &token);\n\n        /* Call the implementation (note: many real-world implementations\n           declare this parameter as non-const; the MISRA issue arises if\n           the implementation does not actually modify the token). */\n        return_code = OS_QueueDelete_Impl(&token);\n        log_printf(\"OS_QueueDelete_Impl returned %d\", (int)return_code);\n\n        /* Log token state after calling the implementation so we can detect\n           whether the implementation modified the token (evidence for or\n           against the need for a const-qualified parameter). */\n        log_token_state(\"token_after_Impl\", &token);\n\n        /* Finalize the delete operation (may adjust return_code). */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    log_printf(\"OS_QueueDelete: returning %d\", (int)return_code);\n    return return_code;\n}\n",
  "explanation": "The original input was truncated and used macros; I completed the missing portion of OS_QueueDelete (logging after the Impl call and calling OS_ObjectIdFinalizeDelete) and closed all open constructs. To satisfy the constraint forbidding macros, I replaced the #define constants with static const int variables. No mock functions or main() were added; only the original prototypes are kept. The code now compiles successfully."
}