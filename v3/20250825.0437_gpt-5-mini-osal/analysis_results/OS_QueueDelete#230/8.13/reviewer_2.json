{
  "user_message": "An agent A claimed that the following OS_QueueDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueDelete.\n```c\nint32 OS_QueueDelete(osal_id_t queue_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_QueueDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the implementation of OS_QueueDelete_Impl is declared to take a non-const pointer (for example: int32 OS_QueueDelete_Impl(OS_object_token_t *token)) but does not modify the object token, then the parameter should be const-qualified (const OS_object_token_t *token). In that situation passing &token constitutes a violation of MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type whenever possible. If, however, OS_QueueDelete_Impl is declared to take a pointer to const or it legitimately modifies the token, there is no violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s reasoning is correct but conditional. MISRA C 2023 Rule 8.13 requires that pointers should point to const-qualified types whenever possible. In this snippet the potential issue arises only if the callee prototypes are non-const (e.g. int32 OS_QueueDelete_Impl(OS_object_token_t *token)) but the functions do not actually modify the object token; in that case the parameter should be declared as const OS_object_token_t * and the current non-const prototype (and thus the call) would be a violation of 8.13. If, however, the implementations legitimately modify the token or the prototypes already take a pointer-to-const, there is no violation. Therefore the agent\u2019s report is correct in principle \u2014 the code may violate 8.13 depending on the callee declarations/behavior and should be checked and corrected for const-correctness where appropriate."
}