{
  "user_message": "An agent A claimed that the following OS_DeleteAllObjects code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of OS_DeleteAllObjects.\n```c\nvoid OS_DeleteAllObjects(void)\n{\n    uint32 ObjectCount;\n    uint32 TryCount;\n\n    /*\n     * Note - this is done in a loop because some objects depend on other objects\n     * and you will not be able to delete the object until the ref count becomes zero.\n     */\n    TryCount = 0;\n    while (true)\n    {\n        ObjectCount = 0;\n        ++TryCount;\n\n        /* Delete timers and tasks first, as they could be actively using other object types  */\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMECB, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMEBASE, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TASK, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        /* Then try to delete all other remaining objects of any type */\n        OS_ForEachObject(OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        if (ObjectCount == 0 || TryCount > 4)\n        {\n            break;\n        }\n        OS_TaskDelay(5);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe default: break; clause in OS_CleanUpObject is a no-op that will be executed when OS_IdentifyObject returns a value not matched by any case label. Removing that default would not change program behaviour, so it is an executed no\u2011op (dead code) and therefore violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe866bd600\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe866bd660\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe866bd6c0\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe866bd6c0\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe866bd6c0\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe866bd6c0\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\nENTER TryCount=1\nBEFORE OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount_ptr=0x7ffe167d4d20\nAFTER  OS_ForEachObjectOfType_TIMECB: obj_type=9, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount_ptr=0x7ffe167d4d20\nAFTER  OS_ForEachObjectOfType_TIMEBASE: obj_type=8, ObjectCount=0\nBEFORE OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount_ptr=0x7ffe167d4d20\nAFTER  OS_ForEachObjectOfType_TASK: obj_type=1, ObjectCount=0\nBEFORE OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount_ptr=0x7ffe167d4d20\nAFTER  OS_ForEachObject_ALL: obj_type=4294967295, ObjectCount=0\nEXIT_CONDITION: ObjectCount=0, TryCount=1\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_DeleteAllObjects:\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n...\nvoid OS_ForEachObject(osal_id_t creator_id, OS_ArgCallback_t callback_ptr, void *callback_arg)\n{\n    osal_objtype_t idtype;\n\n    for (idtype = 0; idtype < OS_OBJECT_TYPE_USER; ++idtype)\n    {\n        OS_ForEachObjectOfType(idtype, creator_id, callback_ptr, callback_arg);\n    }\n}\n...\nvoid OS_CleanUpObject(osal_id_t object_id, void *arg)\n{\n    uint32 *ObjectCount;\n\n    ObjectCount = (uint32 *)arg;\n    ++(*ObjectCount);\n    switch (OS_IdentifyObject(object_id))\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            OS_TaskDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            OS_QueueDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            OS_BinSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            OS_CountSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            OS_MutSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            OS_ModuleUnload(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            OS_TimeBaseDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            OS_TimerDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            OS_close(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_DIR:\n            OS_DirectoryClose(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            OS_CondVarDelete(object_id);\n            break;\n        default:\n            break;\n    }\n}\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nint32 OS_TaskDelay(uint32 millisecond)\n{\n    /* just call the implementation */\n    return OS_TaskDelay_Impl(millisecond);\n}\n...\nint32 OS_TaskDelay_Impl(uint32 millisecond)\n{\n    struct timespec sleep_end;\n    int             status;\n\n    clock_gettime(CLOCK_MONOTONIC, &sleep_end);\n    sleep_end.tv_sec += millisecond / 1000;\n    sleep_end.tv_nsec += 1000000 * (millisecond % 1000);\n\n    if (sleep_end.tv_nsec >= 1000000000)\n    {\n        sleep_end.tv_nsec -= 1000000000;\n        ++sleep_end.tv_sec;\n    }\n\n    do\n    {\n        status = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &sleep_end, NULL);\n    } while (status == EINTR);\n\n    if (status != 0)\n    {\n        return OS_ERROR;\n    }\n    else\n    {\n        return OS_SUCCESS;\n    }\n}\n...\n#define OS_OBJECT_TYPE_OS_TIMECB 0x09\n...\n#define OS_OBJECT_TYPE_OS_TIMEBASE 0x08\n...\n#define OS_OBJECT_TYPE_OS_TASK 0x01\n...\n#define OS_OBJECT_CREATOR_ANY OS_OBJECT_ID_UNDEFINED\n...\ntypedef uint32_t  uint32\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 2.2 forbids executed no\u2011ops that could be removed without changing program behaviour (dead code), but it explicitly distinguishes unreachable code (note 2). In this call chain the iterator APIs enumerate objects by a concrete object type and pass only object IDs of that type to OS_CleanUpObject. OS_IdentifyObject(object_id) therefore should always return one of the valid, enumerated object types handled by the case labels. That makes the default: break; effectively unreachable in normal operation, and unreachable code is not considered dead code per MISRA 2.2 notes. \n\nEven if the default were ever taken (which would imply an unexpected/invalid object id), the default simply prevents fall\u2011through and is a defensive coding measure; the evidence provided (the execution log) does not show the default being executed. On the available evidence, there is no executed no\u2011op that can be removed without changing behaviour, so the claim of a 2.2 violation is not supported."
}