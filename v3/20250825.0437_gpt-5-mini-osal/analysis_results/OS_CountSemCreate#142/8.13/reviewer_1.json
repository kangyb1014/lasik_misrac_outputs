{
  "user_message": "An agent A claimed that the following OS_CountSemCreate code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_CountSemCreate.\n```c\nint32 OS_CountSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options)\n{\n    int32                           return_code;\n    OS_object_token_t               token;\n    OS_count_sem_internal_record_t *countsem;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        countsem = OS_OBJECT_TABLE_GET(OS_count_sem_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, countsem, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_CountSemCreate_Impl(&token, sem_initial_value, options);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes &token to OS_CountSemCreate_Impl which, according to the comment, only reads information from the token. If OS_CountSemCreate_Impl is declared to take OS_object_token_t * (non-const) but does not modify the pointee, this violates MISRA C 2023 Rule 8.13 because the pointer parameter should be to a const-qualified type (const OS_object_token_t *). If, however, the implementation actually modifies the token, then const is not appropriate and there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_CountSemCreate ENTER: sem_name=CountSem 1, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a580\nOS_ObjectIdAllocateNew returned -1\nOS_CountSemCreate EXIT: return_code=-1\nOS_CountSemCreate ENTER: sem_name=CountSem 1, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a580\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=CountSem1, sem_initial_value=1, options=0, sem_id_ptr=(nil)\nOS_CountSemCreate ENTER: sem_name=(null), sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a4e0\nOS_CountSemCreate ENTER: sem_name=XXXXXXXXXXXXXXXXXXXXXXXXXXXXX, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a4e0\nOS_CountSemCreate ENTER: sem_name=COUNTSEM0, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a4e0\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=DUPLICATE, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a4e0\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=Good, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a4e0\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=DeleteTest, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a584\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=GiveTest, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a584\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=TakeTest, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a584\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=TimedWait, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a584\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=TimedWait, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a584\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=GetIDByName, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a55c\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=GetInfo, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a55c\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\nOS_CountSemCreate ENTER: sem_name=GetInfo, sem_initial_value=1, options=0, sem_id_ptr=0x7ffe50b6a55c\nOS_ObjectIdAllocateNew returned -35\nOS_CountSemCreate EXIT: return_code=-35\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CountSemCreate:\ntypedef uint32 osal_id_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    char obj_name[OS_MAX_API_NAME];\n} OS_count_sem_internal_record_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the evidence shown. MISRA C 2023 Rule 8.13 concerns how pointer types are declared (a pointer should point to a const-qualified type whenever possible). The mere call OS_CountSemCreate_Impl(&token, ...) in the shown code does not by itself prove a violation. Whether there is a Rule 8.13 violation depends on the declaration and implementation of OS_CountSemCreate_Impl:\n\n- If OS_CountSemCreate_Impl is declared to take a non-const pointer (OS_object_token_t *) but its implementation does not modify the pointee, then the function declaration should indeed use const OS_object_token_t * and the project would be violating 8.13. \n- If OS_CountSemCreate_Impl actually modifies the token, then a non-const parameter is appropriate and there is no violation.\n\nBecause the prototype/implementation of OS_CountSemCreate_Impl was not provided, you cannot conclude a violation from the call site or the comment alone. Recommendation: inspect the prototype and the implementation of OS_CountSemCreate_Impl. If it does not modify the token, change the parameter to const OS_object_token_t * to comply with Rule 8.13; if it does modify it, keep it non-const."
}