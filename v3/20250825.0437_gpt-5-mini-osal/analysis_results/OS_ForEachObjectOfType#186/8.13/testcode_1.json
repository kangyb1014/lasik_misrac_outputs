{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function parameter 'void *ref' and the local pointer 'OS_creator_filter_t *filter = ref;' are used only for read access. The pointer should therefore be to a const-qualified type (e.g. change the function prototype to 'bool OS_ForEachFilterCreator(const void *ref, ...)' and the local pointer to 'const OS_creator_filter_t *filter = (const OS_creator_filter_t *)ref;'). As written, a non-const void* is used for a read-only argument, violating MISRA C 2023 Rule 8.13. Note: the OS_ObjectMatchFunc_t typedef and any callers/assignments (e.g. OS_ObjectIdIteratorInit) must also be updated to accept a 'const void *' to keep types compatible.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ForEachObjectOfType code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1863.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ForEachObjectOfType as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ForEachObjectOfType:\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\nPlease provide the modified OS_ForEachObjectOfType code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n/* Minimal stand-ins for OS types so this test code is self-contained and compilable. */\ntypedef int32_t osal_objtype_t;\ntypedef int32_t osal_id_t;\ntypedef void (*OS_ArgCallback_t)(void *arg);\n\ntypedef struct\n{\n    int cursor;\n    int total;\n    void *user_ref;\n} OS_object_iter_t;\n\ntypedef struct\n{\n    osal_id_t creator_id;\n    OS_ArgCallback_t user_callback;\n    void *user_arg;\n} OS_creator_filter_t;\n\n/* Return value constant (kept as a const object rather than a macro). */\nconst int OS_SUCCESS = 0;\n\n/* Stubs for iterator functions to make this testable. */\nint OS_ObjectIdIteratorInit(int (*match_func)(const void *, osal_id_t), void *ref, osal_objtype_t idtype, OS_object_iter_t *iter)\n{\n    /* Very small deterministic iterator for testing: 3 entries */\n    if (iter == NULL) return -1;\n    iter->cursor = 0;\n    iter->total = 3;\n    iter->user_ref = ref;\n    (void)match_func; /* unused in stub */\n    (void)idtype;\n    return OS_SUCCESS;\n}\n\nint OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    if (iter == NULL) return 0;\n    if (iter->cursor < iter->total)\n    {\n        iter->cursor++;\n        return 1;\n    }\n    return 0;\n}\n\nvoid OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, void (*process)(OS_object_iter_t *))\n{\n    if (process != NULL)\n    {\n        process(iter);\n    }\n}\n\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    /* Nothing to free in the stub. */\n    (void)iter;\n}\n\n/* Stubs for callbacks used by the iterator. */\nint OS_ForEachFilterCreator(const void *ref, osal_id_t id)\n{\n    (void)ref;\n    (void)id;\n    return 1;\n}\n\nvoid OS_ForEachDoCallback(OS_object_iter_t *iter)\n{\n    /* Example processing stub: do nothing. */\n    (void)iter;\n}\n\n/* Logging helper that appends messages to /tmp/logs/1863.txt */\nstatic void os_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1863.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_POSIX_VERSION)\n    localtime_r(&t, &tm_buf);\n#else\n    /* Fallback if localtime_r isn't available */\n    {\n        struct tm *tmp = localtime(&t);\n        if (tmp != NULL)\n        {\n            tm_buf = *tmp;\n        }\n        else\n        {\n            tm_buf.tm_year = tm_buf.tm_mon = tm_buf.tm_mday = 0;\n            tm_buf.tm_hour = tm_buf.tm_min = tm_buf.tm_sec = 0;\n        }\n    }\n#endif\n    fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d - \", tm_buf.tm_year + 1900, tm_buf.tm_mon + 1,\n            tm_buf.tm_mday, tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * Modified OS_ForEachObjectOfType with probe logging added. The original logic\n * is preserved; the changes only add diagnostics written to /tmp/logs/1863.txt\n * so that the control flow and state relevant to the violation scenario can\n * be captured and inspected.\n */\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    os_log(\"ENTER OS_ForEachObjectOfType: idtype=%d, creator_id=%d, callback_ptr=%p, callback_arg=%p\",\n           (int)idtype, (int)creator_id, (void *)callback_ptr, callback_arg);\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    /* Log the populated filter contents and its address to make it possible to\n       observe that this object is passed by non-const pointer into the iterator. */\n    os_log(\"Filter populated at %p: creator_id=%d, user_callback=%p, user_arg=%p\",\n           (void *)&filter, (int)filter.creator_id, (void *)filter.user_callback, filter.user_arg);\n\n    /* Capture the return value so it can be logged. */\n    int init_status = OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter);\n    os_log(\"OS_ObjectIdIteratorInit called with match_func=%p, ref=%p, idtype=%d -> status=%d\",\n           (void *)OS_ForEachFilterCreator, (void *)&filter, (int)idtype, init_status);\n\n    if (init_status == OS_SUCCESS)\n    {\n        int loop_count = 0;\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            loop_count++;\n            os_log(\"Iterator GET NEXT #%d: iter=%p, cursor=%d, total=%d, iter->user_ref=%p\",\n                   loop_count, (void *)&iter, iter.cursor, iter.total, iter.user_ref);\n\n            /* Log that we are about to process the current entry. */\n            os_log(\"Processing entry #%d using OS_ForEachDoCallback at %p\", loop_count, (void *)OS_ForEachDoCallback);\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n            os_log(\"Finished processing entry #%d\", loop_count);\n        }\n\n        os_log(\"Iterator exhausted after %d entries, destroying iterator at %p\", loop_count, (void *)&iter);\n        OS_ObjectIdIteratorDestroy(&iter);\n        os_log(\"Iterator destroyed\");\n    }\n    else\n    {\n        os_log(\"OS_ObjectIdIteratorInit failed with status %d; skipping iteration\", init_status);\n    }\n\n    os_log(\"EXIT OS_ForEachObjectOfType\");\n}\n"
}