{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe iterator holds a void *arg and the match function type (OS_ObjectMatchFunc_t) takes a non-const void *ref. In the shown path the filter object is only read (OS_ForEachFilterCreator reads fields but does not modify them) yet the pointer types are not const-qualified. Specifically: iter->arg is declared as void * and OS_ForEachFilterCreator(void *ref, ...) takes a void * instead of const void *, so the pointer could and should be const-qualified. This fails the \u201cpointer should point to a const-qualified type whenever possible\u201d intent of MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER OS_ForEachObjectOfType: idtype=9, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133050: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=9, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=9, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=8, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133050: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=8, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=8, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=1, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133050: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=1, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=1, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=0, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=0, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=0, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=1, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=1, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=1, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=2, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=2, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=2, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=3, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=3, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=3, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=4, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=4, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=4, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=5, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=5, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=5, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=6, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=6, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=6, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=7, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=7, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=7, creator_id=0x00000000\nENTER OS_ForEachObjectOfType: idtype=8, creator_id=0x00000000, callback_ptr=0x55c4406e79a8, callback_arg=0x7ffe421330c0\nFilter at 0x7ffe42133010: creator_id=0x00000000, user_callback=0x55c4406e79a8, user_arg=0x7ffe421330c0\nIterator init failed for idtype=8, creator_id=0x00000000\nEXIT OS_ForEachObjectOfType: idtype=8, creator_id=0x00000000\nENTE\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachObjectOfType:\ntypedef void (*OS_ArgCallback_t)(osal_id_t object_id, void *arg)\n...\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n...\nint32 OS_ForEachDoCallback(osal_id_t obj_id, void *ref)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Just invoke the user callback */\n    filter->user_callback(obj_id, filter->user_arg);\n    return OS_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Summary: The agent A report is correct in substance. In the shown call-path the pointer parameter is only read and could be const-qualified, so the current use of non-const void * violates the intent of MISRA C 2023 Rule 8.13.\n\nDetails:\n- OS_ForEachObjectOfType creates a local OS_creator_filter_t filter and passes &filter (a pointer to data that is not modified) into OS_ObjectIdIteratorInit, which stores it in iter->arg (type void *).\n- The match function OS_ForEachFilterCreator is declared as bool OS_ForEachFilterCreator(void *ref, ...) and only reads fields of *ref. Likewise, the iterator processing function OS_ForEachDoCallback receives the same ref and only reads from it to call the user callback.\n- Because the data referenced by these pointers is not modified, they could and should be declared as pointers to const (for example: const OS_creator_filter_t *filter; iter->arg of type const void *; OS_ObjectMatchFunc_t taking const void *ref; the process-entry callback taking const void *). This would satisfy MISRA R8.13 (\u201cA pointer should point to a const-qualified type whenever possible\u201d).\n\nCaveat: If the iterator API (OS_ObjectMatchFunc_t, OS_ObjectIdIteratorInit, OS_object_iter_t.arg, or the process-entry callback type) is intentionally non-const because some other callers require a modifiable pointer, then the non-const declarations are necessary and the local usage is not an isolated defect (i.e., the API prevents applying const). In that case a deviation justification or targeted API change would be needed. But looking only at the shown path, the report correctly identifies a violation of Rule 8.13.\n"
}