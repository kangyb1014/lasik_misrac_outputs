{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe iterator stores a read-only context pointer in OS_object_iter_t::arg (declared as void *), and OS_ObjectIdIteratorInit assigns the incoming matcharg (void *) to it. The iterator only passes this pointer to match and callback functions (e.g. iter->match(iter->arg, ...) and OS_ObjectIdIteratorProcessEntry(..., iter->arg)) and those functions (OS_ForEachFilterCreator and OS_ForEachDoCallback) treat the referenced data as read-only. Therefore the pointer should be const-qualified (e.g. const void *matcharg and const void *arg, and corresponding function prototypes updated to accept const void *) to conform to MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=9 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=9 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=8 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=8 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=1 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=1 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=0 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=0 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=1 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=1 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=2 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=2 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=3 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=3 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=4 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=4 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=5 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=5 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=6 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=6 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=7 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=7 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=8 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=8 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=9 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=9 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=10 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=10 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=11 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=11 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=12 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=12 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=13 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=13 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=14 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=14 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=15 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=15 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=9 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=9 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=8 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=8 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=1 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=1 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=0 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=0 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=1 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=1 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=2 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=2 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=3 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=3 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=4 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=4 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=5 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=5 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0x7ffd59753df0 v1=6 v2=0\nOS_ObjectIdIteratorInit - failure p1=(nil) p2=(nil) v1=6 v2=0\nOS_ForEachObjectOfType - entry p1=0x5634d8bf79a8 p2=0\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ForEachObjectOfType:\ntypedef void (*OS_ArgCallback_t)(osal_id_t object_id, void *arg)\n...\ntypedef struct\n{\n    osal_id_t        creator_id;\n    OS_ArgCallback_t user_callback;\n    void *           user_arg;\n} OS_creator_filter_t\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n...\nint32 OS_ForEachDoCallback(osal_id_t obj_id, void *ref)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /* Just invoke the user callback */\n    filter->user_callback(obj_id, filter->user_arg);\n    return OS_SUCCESS;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA R8.13 says a pointer should be const-qualified where possible, but \u201cwhere possible\u201d is judged against the actual API and uses of that pointer. In this code the iterator's arg field and the function-pointer types it interworks with (OS_ArgCallback_t, the match/callback prototypes used by OS_ObjectIdIteratorGetNext/ProcessEntry) are declared as void * / (void *), i.e. they permit mutation via that pointer. Even though the particular functions passed in from OS_ForEachObjectOfType (OS_ForEachFilterCreator and OS_ForEachDoCallback) only read the referenced data, the iterator and the general iterator APIs must keep the non-const type for compatibility with other potential callbacks that could modify the pointed-to object. Changing just OS_object_iter_t::arg or the iterator init parameter to const void * would be an API-level change requiring corresponding changes to the function-pointer typedefs (and all users). Therefore, as presented, there is no standalone MISRA violation in this spot \u2014 the pointer cannot be const without a broader API change. If the intent of the whole API is that these context pointers are never modified, then the proper fix is to change the related typedefs and iterator function signatures to use const void * consistently across the API; only then would the code conform to R8.13."
}