{
  "user_message": "An agent A claimed that the following UT_DefaultStubImpl code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DefaultStubImpl.\n```c\nint32 UT_DefaultStubImpl(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, ...)\n{\n    int32   Retcode;\n    va_list va;\n\n    va_start(va, DefaultRc);\n    Retcode = UT_DefaultStubImplWithArgs(FunctionName, FuncKey, DefaultRc, va);\n    va_end(va);\n\n    return Retcode;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe initialization at declaration of StubPtr (\"UT_StubTableEntry_t *StubPtr = NULL;\") is dead code. In every control path of the function StubPtr is assigned before it is read: the while loop either sets StubPtr = NULL when SearchLen >= SearchLimit or sets StubPtr = &UT_StubTable[Idx] on each iteration. Thus the initial assignment to NULL at declaration is executed but could be removed without changing program behaviour.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UT_DefaultStubImpl(FunctionName=OCS_memset, FuncKey=94619377008637, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OCS_semBInitialize, FuncKey=94619377010714, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OCS_semBInitialize, FuncKey=94619377010714, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-1\nEXIT: UT_DefaultStubImpl -> Retcode=-1\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_GenericSemGive, FuncKey=94619377008026, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_GenericSemGive, FuncKey=94619377008026, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-6\nEXIT: UT_DefaultStubImpl -> Retcode=-6\nENTER: UT_DefaultStubImpl(FunctionName=OCS_semFlush, FuncKey=94619377011681, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OCS_semFlush, FuncKey=94619377011681, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-1\nEXIT: UT_DefaultStubImpl -> Retcode=-1\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_GenericSemTake, FuncKey=94619377007929, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_Milli2Ticks, FuncKey=94619377008160, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_GenericSemTake, FuncKey=94619377007929, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_Milli2Ticks, FuncKey=94619377008160, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_GenericSemTake, FuncKey=94619377007929, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-6\nEXIT: UT_DefaultStubImpl -> Retcode=-6\nENTER: UT_DefaultStubImpl(FunctionName=OS_Milli2Ticks, FuncKey=94619377008160, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-1\nEXIT: UT_DefaultStubImpl -> Retcode=-1\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_TableMutex_Init, FuncKey=93904579583461, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_TableMutex_Init, FuncKey=93904579583461, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=-1\nEXIT: UT_DefaultStubImpl -> Retcode=-1\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_TableMutex_Init, FuncKey=93904579583461, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultStubImpl(FunctionName=OS_VxWorks_TaskAPI_Impl_Init, FuncKey=93904579583972, DefaultRc=0)\nCALL: UT_DefaultStubImplWithArgs about to be invoked\nRETURNED: UT_DefaultStubImplWithArgs -> Retcode=0\nEXIT: UT_DefaultStubImpl -> Retcode=0\nENTER: UT_DefaultS\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DefaultStubImpl:\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n...\nvoid UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}\n...\nint32 dummy_function(void)\n{\n    int32 status;\n\n    status = UT_DEFAULT_IMPL(dummy_function);\n\n    return status;\n}\n...\nvoid UT_SetHandlerFunction(UT_EntryKey_t FuncKey, UT_HandlerFunc_t HandlerFunc, void *UserObj)\n{\n    UT_HookFuncPtr_t Value;\n\n    Value.SimpleHandler = HandlerFunc;\n\n    UT_DoSetHookFunction(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER, Value, UserObj, false);\n}\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\nUT_StubTableEntry_t *UT_Stub_FindRetvalConfig(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubEntryPtr;\n\n    StubEntryPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED);\n    if (StubEntryPtr != NULL)\n    {\n        /*\n         * The counter on a deferred retval config indicates the number of times it should\n         * be skipped/not used.   Decrement the counter now, and if it is not yet 0, do not\n         * return this yet, and go to a fallback - which could either be a constant value\n         * configuration, or the default fallback of 0.\n         *\n         * By definition, deferred retvals are only used once and then deleted.\n         */\n        --StubEntryPtr->Data.Rvc.Counter;\n\n        if (StubEntryPtr->Data.Rvc.Counter > 0)\n        {\n            StubEntryPtr = NULL;\n        }\n    }\n\n    if (StubEntryPtr == NULL)\n    {\n        StubEntryPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT);\n        if (StubEntryPtr != NULL)\n        {\n            /*\n             * the counter on a constant retval config will track the number of\n             * times the value was actually used, so it is incremented here.  Unlike\n             * deferred retval configs, these values may be used multiple times during\n             * a test.\n             */\n            ++StubEntryPtr->Data.Rvc.Counter;\n        }\n    }\n\n    return StubEntryPtr;\n}\n...\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nUtAssert_CaseType_t UtAssert_GetContext(void)\n{\n    return DefaultContext;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's observation about the code is correct in the sense that the initializer \"= NULL\" on the local variable StubPtr in UT_GetStubEntry is redundant: every path through the subsequent infinite loop assigns StubPtr (either to NULL in the SearchLen >= SearchLimit branch or to &UT_StubTable[Idx] when a match is found) before it is used or returned, so removing the initializer would not change program behaviour. However, MISRA C:2023 Rule 2.2 explicitly states (note 3) that initialization is not the same as an assignment operation and is therefore not a candidate for dead code. Therefore flagging this initializer as a Rule 2.2 violation is incorrect. The code may be slightly redundant, but it does not violate MISRA C:2023 Rule 2.2."
}