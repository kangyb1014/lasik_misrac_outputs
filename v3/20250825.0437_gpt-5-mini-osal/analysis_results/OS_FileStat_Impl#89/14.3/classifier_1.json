{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileStat_Impl:\n```c\nint32 OS_FileStat_Impl(const char *local_path, os_fstat_t *FileStats)\n{\n    struct stat     st;\n    mode_t          readbits;\n    mode_t          writebits;\n    mode_t          execbits;\n    struct timespec filetime;\n\n    if (stat(local_path, &st) < 0)\n    {\n        return OS_ERROR;\n    }\n\n    FileStats->FileSize = st.st_size;\n\n    /*\n     * NOTE: Traditional timestamps are only a whole number of seconds (time_t)\n     * POSIX.1-2008 expands this to have a full \"struct timespec\" with nanosecond\n     * resolution.\n     *\n     * GLIBC (and likely other C libraries that use similar feature selection)\n     * will expose this value based on _POSIX_C_SOURCE or _XOPEN_SOURCE minimum\n     * values.  Otherwise this just falls back to standard 1-second resolution\n     * available via the \"st_mtime\" member.\n     */\n#if (_POSIX_C_SOURCE >= 200809L) || (_XOPEN_SOURCE >= 700)\n    /*\n     * Better - use the full resolution (seconds + nanoseconds) as specified in POSIX.1-2008\n     */\n    filetime = st.st_mtim;\n#else\n    /*\n     * Fallback - every POSIX-compliant implementation must expose \"st_mtime\" field.\n     */\n    filetime.tv_sec  = st.st_mtime;\n    filetime.tv_nsec = 0;\n#endif\n\n    FileStats->FileTime = OS_TimeAssembleFromNanoseconds(filetime.tv_sec, filetime.tv_nsec);\n\n    /* note that the \"fst_mode\" member is already zeroed by the caller */\n    if (S_ISDIR(st.st_mode))\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_DIR;\n    }\n\n    /* always check world bits */\n    readbits  = S_IROTH;\n    writebits = S_IWOTH;\n    execbits  = S_IXOTH;\n\n    if (OS_IMPL_SELF_EUID == st.st_uid)\n    {\n        /* we own the file so use user bits for simplified perms */\n        readbits |= S_IRUSR;\n        writebits |= S_IWUSR;\n        execbits |= S_IXUSR;\n    }\n\n    if (OS_IMPL_SELF_EGID == st.st_gid)\n    {\n        /* our group owns the file so use group bits for simplified perms */\n        readbits |= S_IRGRP;\n        writebits |= S_IWGRP;\n        execbits |= S_IXGRP;\n    }\n\n    if (st.st_mode & readbits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_READ;\n    }\n    if (st.st_mode & writebits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_WRITE;\n    }\n    if (st.st_mode & execbits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_EXEC;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileStat_Impl:\nextern uid_t OS_IMPL_SELF_EUID\n...\nextern gid_t OS_IMPL_SELF_EGID\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (OS_IMPL_SELF_EUID == st.st_uid)\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the controlling expression depends on the runtime values OS_IMPL_SELF_EUID and st.st_uid. Given OS_IMPL_SELF_EUID is declared extern (uid_t) and st.st_uid comes from stat(), the expression is not invariant. (If instead OS_IMPL_SELF_EUID were a compile-time constant macro or an integer constant expression, then an invariant controlling expression could occur and would violate Rule 14.3.)"
}