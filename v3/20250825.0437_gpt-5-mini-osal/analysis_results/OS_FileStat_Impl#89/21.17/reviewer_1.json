{
  "user_message": "An agent A claimed that the following OS_FileStat_Impl code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileStat_Impl.\n```c\nint32 OS_FileStat_Impl(const char *local_path, os_fstat_t *FileStats)\n{\n    struct stat     st;\n    mode_t          readbits;\n    mode_t          writebits;\n    mode_t          execbits;\n    struct timespec filetime;\n\n    if (stat(local_path, &st) < 0)\n    {\n        return OS_ERROR;\n    }\n\n    FileStats->FileSize = st.st_size;\n\n    /*\n     * NOTE: Traditional timestamps are only a whole number of seconds (time_t)\n     * POSIX.1-2008 expands this to have a full \"struct timespec\" with nanosecond\n     * resolution.\n     *\n     * GLIBC (and likely other C libraries that use similar feature selection)\n     * will expose this value based on _POSIX_C_SOURCE or _XOPEN_SOURCE minimum\n     * values.  Otherwise this just falls back to standard 1-second resolution\n     * available via the \"st_mtime\" member.\n     */\n#if (_POSIX_C_SOURCE >= 200809L) || (_XOPEN_SOURCE >= 700)\n    /*\n     * Better - use the full resolution (seconds + nanoseconds) as specified in POSIX.1-2008\n     */\n    filetime = st.st_mtim;\n#else\n    /*\n     * Fallback - every POSIX-compliant implementation must expose \"st_mtime\" field.\n     */\n    filetime.tv_sec  = st.st_mtime;\n    filetime.tv_nsec = 0;\n#endif\n\n    FileStats->FileTime = OS_TimeAssembleFromNanoseconds(filetime.tv_sec, filetime.tv_nsec);\n\n    /* note that the \"fst_mode\" member is already zeroed by the caller */\n    if (S_ISDIR(st.st_mode))\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_DIR;\n    }\n\n    /* always check world bits */\n    readbits  = S_IROTH;\n    writebits = S_IWOTH;\n    execbits  = S_IXOTH;\n\n    if (OS_IMPL_SELF_EUID == st.st_uid)\n    {\n        /* we own the file so use user bits for simplified perms */\n        readbits |= S_IRUSR;\n        writebits |= S_IWUSR;\n        execbits |= S_IXUSR;\n    }\n\n    if (OS_IMPL_SELF_EGID == st.st_gid)\n    {\n        /* our group owns the file so use group bits for simplified perms */\n        readbits |= S_IRGRP;\n        writebits |= S_IWGRP;\n        execbits |= S_IXGRP;\n    }\n\n    if (st.st_mode & readbits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_READ;\n    }\n    if (st.st_mode & writebits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_WRITE;\n    }\n    if (st.st_mode & execbits)\n    {\n        FileStats->FileModeBits |= OS_FILESTAT_MODE_EXEC;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to OS_TranslatePath(path, local_path) can lead to out-of-bounds accesses if OS_TranslatePath copies or moves the input string into local_path without bounds checking. For example, if OS_TranslatePath internally does strcpy(local_path, path) or memcpy(local_path, path, strlen(path)+1) and strlen(path)+1 > OS_MAX_LOCAL_PATH_LEN, this will write past the local_path buffer and violate MISRA C 2023 Rule 21.17. There is no shown pre-check of path length before the call, so a too-long path is a realistic violation scenario.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileStat_Impl:\nstatic inline OS_time_t OS_TimeAssembleFromNanoseconds(int64 seconds, uint32 nanoseconds)\n{\n    OS_time_t result;\n    result.ticks = seconds * OS_TIME_TICKS_PER_SECOND;\n    result.ticks += nanoseconds / OS_TIME_TICK_RESOLUTION_NS;\n    return result;\n}\n...\nint32 OS_stat(const char *path, os_fstat_t *filestats)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(filestats);\n\n    memset(filestats, 0, sizeof(*filestats));\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileStat_Impl(local_path, filestats);\n    }\n\n    return return_code;\n}\n...\ntypedef struct\n{\n    uint32    FileModeBits;\n    OS_time_t FileTime;\n    size_t    FileSize;\n} os_fstat_t\n...\nextern uid_t OS_IMPL_SELF_EUID\n...\nextern gid_t OS_IMPL_SELF_EGID\n...\n#define OS_SUCCESS (0)\n...\n#define OS_ERROR (-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct for the shown OS_FileStat_Impl function. Rule 21.17 concerns use of string.h functions (memcpy/strcpy/strlen/etc.) that can access beyond the bounds of the objects referenced by their pointer parameters. The body of OS_FileStat_Impl does not call any string.h routines \u2014 it only calls stat(local_path, &st) and then inspects the returned struct stat. The only place a potential copy into local_path occurs is in OS_stat via OS_TranslatePath, which is not shown. If OS_TranslatePath used unsafe string.h functions without bounds checking (e.g. strcpy or memcpy with strlen+1 > OS_MAX_LOCAL_PATH_LEN) then that implementation would be the locus of a Rule 21.17 violation, not OS_FileStat_Impl. Also note that an unterminated or overrun local_path could cause stat() to read past the buffer (undefined behavior), but that is a different problem and the use in OS_FileStat_Impl itself is not a direct string.h misuse covered by MISRA C 2023 Rule 21.17. Therefore the report that OS_FileStat_Impl violates 21.17 is not correct."
}