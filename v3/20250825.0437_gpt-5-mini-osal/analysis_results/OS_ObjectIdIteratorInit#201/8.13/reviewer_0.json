{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorInit code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorInit.\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe member OS_object_iter_t::base is declared as a non-const pointer (OS_common_record_t *base) but it is initialized from &OS_common_table[...] and only used for read-only operations (e.g. match callbacks take a const OS_common_record_t *obj). Therefore the pointer can and should be const-qualified (const OS_common_record_t *base) to prevent accidental modification through the iterator.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b310, objtype=9\n[OS_ObjectIdIteratorInit] after init: iter->limit=10, base_index=247, iter->base=0x559f1cb389c8\n[OS_ObjectIdIteratorInit] address of &OS_common_table[247] = 0x559f1cb389c8\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b310, objtype=8\n[OS_ObjectIdIteratorInit] after init: iter->limit=5, base_index=242, iter->base=0x559f1cb38950\n[OS_ObjectIdIteratorInit] address of &OS_common_table[242] = 0x559f1cb38950\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b310, objtype=1\n[OS_ObjectIdIteratorInit] after init: iter->limit=64, base_index=0, iter->base=0x559f1cb372a0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[0] = 0x559f1cb372a0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=0\n[OS_ObjectIdIteratorInit] after init: iter->limit=0, base_index=0, iter->base=0x559f1cb372a0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[0] = 0x559f1cb372a0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=1\n[OS_ObjectIdIteratorInit] after init: iter->limit=64, base_index=0, iter->base=0x559f1cb372a0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[0] = 0x559f1cb372a0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=2\n[OS_ObjectIdIteratorInit] after init: iter->limit=64, base_index=64, iter->base=0x559f1cb378a0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[64] = 0x559f1cb378a0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=3\n[OS_ObjectIdIteratorInit] after init: iter->limit=20, base_index=148, iter->base=0x559f1cb38080\n[OS_ObjectIdIteratorInit] address of &OS_common_table[148] = 0x559f1cb38080\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=4\n[OS_ObjectIdIteratorInit] after init: iter->limit=20, base_index=128, iter->base=0x559f1cb37ea0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[128] = 0x559f1cb37ea0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=5\n[OS_ObjectIdIteratorInit] after init: iter->limit=20, base_index=168, iter->base=0x559f1cb38260\n[OS_ObjectIdIteratorInit] address of &OS_common_table[168] = 0x559f1cb38260\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=6\n[OS_ObjectIdIteratorInit] after init: iter->limit=50, base_index=188, iter->base=0x559f1cb38440\n[OS_ObjectIdIteratorInit] address of &OS_common_table[188] = 0x559f1cb38440\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransactionInit returned -35\n[OS_ObjectIdIteratorInit] ENTRY: matchfunc=0x559f1c8a8f91, matcharg=0x7ffd6927b2d0, objtype=7\n[OS_ObjectIdIteratorInit] after init: iter->limit=4, base_index=238, iter->base=0x559f1cb388f0\n[OS_ObjectIdIteratorInit] address of &OS_common_table[238] = 0x559f1cb388f0\n[OS_ObjectIdIteratorInit] matchfunc present\n[OS_ObjectIdIteratorInit] OS_ObjectIdTransa\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdIteratorInit:\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n...\nstatic OS_common_record_t OS_common_table[OS_MAX_TOTAL_RECORDS]\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nuint32 OS_GetBaseForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_TASK_BASE;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_QUEUE_BASE;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_BINSEM_BASE;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_COUNTSEM_BASE;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MUTEX_BASE;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_STREAM_BASE;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_DIR_BASE;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_TIMEBASE_BASE;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_TIMECB_BASE;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MODULE_BASE;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_FILESYS_BASE;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_CONSOLE_BASE;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_CONDVAR_BASE;\n        default:\n            return 0;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The iterator struct declares base as OS_common_record_t * (a non-const pointer) but it is initialized from &OS_common_table[...] and, in the provided code, is only ever used for read-only purposes (the match callback prototype takes a const OS_common_record_t * and the shown iterator processing functions do not write through iter->base). Assigning the address of a non-const object to a pointer-to-const is allowed, so the member can and should be declared const OS_common_record_t *base. Therefore the current declaration violates MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible). Note: if there are other, undisclosed call sites that write through iter->base, then making it const would be impossible; based on the supplied code and usage, however, the rule is violated."
}