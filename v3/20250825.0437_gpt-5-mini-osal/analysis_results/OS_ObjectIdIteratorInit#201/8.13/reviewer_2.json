{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorInit code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorInit.\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe member iter->base is declared as OS_common_record_t * (non-const) but is initialized from &OS_common_table[...] and is only used for read-only operations (e.g. match functions take const OS_common_record_t *). Since the pointed-to objects are not modified via this iterator, the pointer could and should be const-qualified (const OS_common_record_t *). Therefore this assignment violates MISRA C 2023 Rule 8.13. Recommendation: change OS_object_iter_t.base to const OS_common_record_t * and update any uses accordingly.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=9\n  limit=10\n  base_index=247\n  base_ptr=0x5615242069c8\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bf0\n  iter_token_addr=0x7ffe487b3c2c\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=8\n  limit=5\n  base_index=242\n  base_ptr=0x561524206950\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bf0\n  iter_token_addr=0x7ffe487b3c2c\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=1\n  limit=64\n  base_index=0\n  base_ptr=0x5615242052a0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bf0\n  iter_token_addr=0x7ffe487b3c2c\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=0\n  limit=0\n  base_index=0\n  base_ptr=0x5615242052a0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=1\n  limit=64\n  base_index=0\n  base_ptr=0x5615242052a0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=2\n  limit=64\n  base_index=64\n  base_ptr=0x5615242058a0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=3\n  limit=20\n  base_index=148\n  base_ptr=0x561524206080\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=4\n  limit=20\n  base_index=128\n  base_ptr=0x561524205ea0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=5\n  limit=20\n  base_index=168\n  base_ptr=0x561524206260\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=6\n  limit=50\n  base_index=188\n  base_ptr=0x561524206440\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=7\n  limit=4\n  base_index=238\n  base_ptr=0x5615242068f0\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=8\n  limit=5\n  base_index=242\n  base_ptr=0x561524206950\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=9\n  limit=10\n  base_index=247\n  base_ptr=0x5615242069c8\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=10\n  limit=20\n  base_index=257\n  base_ptr=0x561524206ab8\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=11\n  limit=14\n  base_index=277\n  base_ptr=0x561524206c98\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[1756098967] OS_ObjectIdIteratorInit called\n  objtype=12\n  limit=1\n  base_index=291\n  base_ptr=0x561524206de8\n  matchfunc_provided=yes\n  matcharg_ptr=0x7ffe487b3bb0\n  iter_token_addr=0x7ffe487b3bec\n[1756098967] OS_ObjectIdTransactionInit returned -35\n----\n[17560989\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdIteratorInit:\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n...\nstatic OS_common_record_t OS_common_table[OS_MAX_TOTAL_RECORDS]\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nuint32 OS_GetBaseForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_TASK_BASE;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_QUEUE_BASE;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_BINSEM_BASE;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_COUNTSEM_BASE;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MUTEX_BASE;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_STREAM_BASE;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_DIR_BASE;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_TIMEBASE_BASE;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_TIMECB_BASE;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MODULE_BASE;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_FILESYS_BASE;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_CONSOLE_BASE;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_CONDVAR_BASE;\n        default:\n            return 0;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in the assessment, subject to the usual caveat about other uses of the field. Rule 8.13 requires that pointers should point to a const-qualified type whenever that is feasible. In the snippets provided: the iterator stores a pointer to the common-record table (iter->base = &OS_common_table[...]) and the match callback is declared to take a const OS_common_record_t * (OS_ObjectMatchFunc_t). The shown iterator-processing code does not modify the pointed-to records. That indicates iter->base is only used for read-only access via the iterator API and therefore could and should be declared as const OS_common_record_t * to satisfy MISRA 8.13. Changing OS_object_iter_t.base to const OS_common_record_t * (and updating any call sites that currently modify records through that pointer) is the appropriate remedy. Note: if elsewhere in the code the iterator deliberately uses iter->base to perform writes, then making it const would not be possible without further design changes; in that case a documented deviation would be required. Given the provided code and signatures, the report is correct."
}