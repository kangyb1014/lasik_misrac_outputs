{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nOS_OBJECT_INIT(token, stream, stream_name, path) likely copies the caller-supplied 'path' into a fixed-size stream->stream_name buffer. If the macro expands to a string copy (e.g. strcpy/memcpy/strncpy) without guaranteeing the destination size or performing bounds checking, a long path provided by the caller can overflow stream_name and produce an out-of-bounds access. Note that the code uses the translated local_path for the actual open but passes the original path into the macro, so there is no guaranteed truncation/length check here. Therefore Rule 21.17 is violated unless OS_OBJECT_INIT internally enforces a safe, bounded copy (which is not shown).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_OpenCreate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1619.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_OpenCreate as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_OpenCreate:\n```c\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_OpenCreate code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Probe logging helper for OS_OpenCreate */\nstatic void OS_OpenCreate_Log(const char *stage,\n                              const char *path,\n                              const char *local_path,\n                              const void *token_addr,\n                              const void *stream_addr,\n                              int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1619.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"OS_OpenCreate: %s\\n\", stage);\n    fprintf(f, \"  return_code=%d\\n\", (int)return_code);\n    fprintf(f, \"  token_addr=%p\\n\", token_addr);\n    fprintf(f, \"  stream_addr=%p\\n\", stream_addr);\n\n    if (path != NULL)\n    {\n        fprintf(f, \"  path='%s'\\n\", path);\n        fprintf(f, \"  path_len=%zu\\n\", strlen(path));\n    }\n    else\n    {\n        fprintf(f, \"  path=(null)\\n\");\n    }\n\n    if (local_path != NULL)\n    {\n        /* local_path is a local buffer in the caller; log it safely */\n        fprintf(f, \"  local_path='%s'\\n\", local_path);\n        fprintf(f, \"  local_path_len=%zu\\n\", strlen(local_path));\n    }\n    else\n    {\n        fprintf(f, \"  local_path=(null)\\n\");\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Modified OS_OpenCreate with probes inserted. Original logic preserved. */\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    /* Log state after translation attempt */\n    OS_OpenCreate_Log(\"after_translate\", path, local_path, (const void *)&token, NULL, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Log state just before initializing the object name */\n            OS_OpenCreate_Log(\"before_OS_OBJECT_INIT\", path, local_path, (const void *)&token, (const void *)stream, return_code);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Log state immediately after OS_OBJECT_INIT to capture the copied name */\n            /* Attempt to log stream->stream_name safely if available. */\n            {\n                FILE *f = fopen(\"/tmp/logs/1619.txt\", \"a\");\n                if (f != NULL)\n                {\n                    fprintf(f, \"OS_OpenCreate: after_OS_OBJECT_INIT\\n\");\n                    fprintf(f, \"  token_addr=%p\\n\", (const void *)&token);\n                    fprintf(f, \"  stream_addr=%p\\n\", (const void *)stream);\n\n                    if (stream != NULL)\n                    {\n                        /* If the stream structure defines a stream_name member as an array, sizeof will yield its size.\n                         * This keeps the logging read to within the declared bounds of the member and avoids an out-of-bounds read.\n                         * If the type is incomplete here, sizeof(...) would have failed at compile time in the original build\n                         * environment; in that case the environment already provides the complete type and this will work.\n                         */\n                        size_t name_size = 0;\n                        /* Use a safe default in case the member isn't visible; this branch will be optimized out when compiled\n                         * in the real build where the type is complete. The explicit cast below relies on the member existing.\n                         */\n                        /* The following block is intentionally minimal and uses sizeof(stream->stream_name) to bound the copy. */\n                        {\n                            /* Attempt to compute size of the stream_name member */\n                            /* Note: If stream->stream_name does not exist in the real type, this will not compile in that environment.\n                             * In the intended OS build environment, the member exists and this is a safe bounded read.\n                             */\n                            name_size = sizeof(stream->stream_name);\n                        }\n\n                        if (name_size > 0)\n                        {\n                            /* Limit how many bytes we print to a reasonable amount for the log */\n                            size_t print_len = name_size;\n                            if (print_len > 256) print_len = 256;\n\n                            char namebuf[257];\n                            /* Copy at most print_len bytes and NUL-terminate for fprintf(\"%s\") */\n                            memcpy(namebuf, stream->stream_name, print_len);\n                            namebuf[print_len] = '\\0';\n\n                            fprintf(f, \"  stream->stream_name (first %zu bytes)='%s'\\n\", print_len, namebuf);\n                            fprintf(f, \"  stream->stream_name_declared_size=%zu\\n\", name_size);\n                        }\n                        else\n                        {\n                            fprintf(f, \"  stream->stream_name not available (name_size=0)\\n\");\n                        }\n                    }\n                    else\n                    {\n                        fprintf(f, \"  stream=(null)\\n\");\n                    }\n\n                    fprintf(f, \"\\n\");\n                    fclose(f);\n                }\n            }\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n\n            /* Log before finalizing the object id */\n            OS_OpenCreate_Log(\"before_finalize\", path, local_path, (const void *)&token, (const void *)stream, return_code);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n\n            /* Log after finalize so external agents can see final status. */\n            OS_OpenCreate_Log(\"after_finalize\", path, local_path, (const void *)&token, (const void *)stream, return_code);\n        }\n    }\n\n    return return_code;\n}\n"
}