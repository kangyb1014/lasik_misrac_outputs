{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleAPI_Init:\n```c\nint32 OS_ConsoleAPI_Init(void)\n{\n    OS_console_internal_record_t *console;\n    int32                         return_code;\n    OS_object_token_t             token;\n\n    memset(&OS_console_table, 0, sizeof(OS_console_table));\n\n    /*\n     * Configure a console device to be used for OS_printf() calls.\n     */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_CONSOLE, OS_PRINTF_CONSOLE_NAME, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, console, device_name, OS_PRINTF_CONSOLE_NAME);\n\n        /*\n         * Initialize the ring buffer pointers\n         */\n        console->BufBase = OS_printf_buffer_mem;\n        console->BufSize = sizeof(OS_printf_buffer_mem);\n        console->IsAsync = OS_CONSOLE_IS_ASYNC;\n\n        return_code = OS_ConsoleCreate_Impl(&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, &OS_SharedGlobalVars.PrintfConsoleId);\n\n        /*\n         * Printf can be enabled by default now that the buffer is configured.\n         */\n        OS_SharedGlobalVars.PrintfEnabled = true;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ConsoleAPI_Init:\nOS_console_internal_record_t OS_console_table[OS_MAX_CONSOLES]\n...\ntypedef struct\n{\n    char device_name[OS_MAX_API_NAME];\n\n    char *          BufBase;        /**< Start of the buffer memory */\n    size_t          BufSize;        /**< Total size of the buffer */\n    volatile size_t ReadPos;        /**< Offset of next byte to read */\n    volatile size_t WritePos;       /**< Offset of next byte to write */\n    uint32          OverflowEvents; /**< Number of lines dropped due to overflow */\n    bool            IsAsync;        /**< Whether to write data via deferred utility task */\n} OS_console_internal_record_t\n...\nstatic char OS_printf_buffer_mem[(sizeof(OS_PRINTF_CONSOLE_NAME) + OS_BUFFER_SIZE) * OS_BUFFER_MSG_DEPTH]\n...\n#define OS_PRINTF_CONSOLE_NAME \"\"\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_OBJECT_INIT(tok, ref, namefield, nameval) {memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nextern OS_SharedGlobalVars_t OS_SharedGlobalVars\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n{memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "In the shown use (OS_PRINTF_CONSOLE_NAME is \"\" and the destination is zeroed with memset, then strncpy(ref->device_name, nameval, sizeof(ref->device_name)-1) copies at most size-1 bytes and leaves the trailing byte as zero) there is no out-of-bounds access \u2014 the destination buffer is not overflowed and a terminator is guaranteed by the prior memset, so Rule 21.17 is not violated here.  A potential violation scenario would be if nameval pointed to a non\u2011null\u2011terminated source whose accessible storage is smaller than sizeof(ref->device_name)-1: in that case strncpy could read beyond the bounds of the source object, which would violate Rule 21.17."
}