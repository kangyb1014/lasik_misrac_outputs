{
  "user_message": "An agent A claimed that the following OS_ConsoleAPI_Init code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ConsoleAPI_Init.\n```c\nint32 OS_ConsoleAPI_Init(void)\n{\n    OS_console_internal_record_t *console;\n    int32                         return_code;\n    OS_object_token_t             token;\n\n    memset(&OS_console_table, 0, sizeof(OS_console_table));\n\n    /*\n     * Configure a console device to be used for OS_printf() calls.\n     */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_CONSOLE, OS_PRINTF_CONSOLE_NAME, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, console, device_name, OS_PRINTF_CONSOLE_NAME);\n\n        /*\n         * Initialize the ring buffer pointers\n         */\n        console->BufBase = OS_printf_buffer_mem;\n        console->BufSize = sizeof(OS_printf_buffer_mem);\n        console->IsAsync = OS_CONSOLE_IS_ASYNC;\n\n        return_code = OS_ConsoleCreate_Impl(&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, &OS_SharedGlobalVars.PrintfConsoleId);\n\n        /*\n         * Printf can be enabled by default now that the buffer is configured.\n         */\n        OS_SharedGlobalVars.PrintfEnabled = true;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the prototype of OS_ObjectIdAllocateNew declares the name parameter as a non-const pointer (e.g. char *name) while OS_PRINTF_CONSOLE_NAME is a string literal or otherwise not intended to be modified, then passing OS_PRINTF_CONSOLE_NAME to that non-const parameter violates MISRA C 2023 Rule 8.13. Example violating prototype: int32 OS_ObjectIdAllocateNew(uint32 type, char *name, OS_object_token_t *token); \u2014 the parameter should be const char *name (or OS_PRINTF_CONSOLE_NAME should be a writable buffer) to satisfy the rule.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 8.13 requires that pointers should point to const-qualified types whenever possible. In the scenario described, the potential problem is not in the call site per se but in the prototype of OS_ObjectIdAllocateNew: if it is declared as int32 OS_ObjectIdAllocateNew(uint32 type, char *name, OS_object_token_t *token); and the function does not need to modify the name, then that parameter should be const char *name. Passing OS_PRINTF_CONSOLE_NAME (a string literal or other non-modifiable text) to a non-const char * parameter is exactly the sort of situation Rule 8.13 is intended to prevent. (Note: in C a string literal has array-of-char type historically, but MISRA still requires APIs to use const where modification is not intended.) Therefore, given the reported prototype, the claim is correct: the code (or rather the API declaration) violates MISRA C 2023 Rule 8.13. The appropriate fix is to change the prototype to accept a const char * (or otherwise ensure the argument is a mutable buffer if modification is required)."
}