{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleOutput_Impl:\n```c\nvoid OS_ConsoleOutput_Impl(const OS_object_token_t *token)\n{\n    size_t                        StartPos;\n    size_t                        EndPos;\n    size_t                        WriteSize;\n    OS_console_internal_record_t *console;\n\n    console  = OS_OBJECT_TABLE_GET(OS_console_table, *token);\n    StartPos = console->ReadPos;\n    EndPos   = console->WritePos;\n\n    OS_BSP_Lock_Impl();\n\n    while (StartPos != EndPos)\n    {\n        if (StartPos > EndPos)\n        {\n            /* handle wrap */\n            WriteSize = console->BufSize - StartPos;\n        }\n        else\n        {\n            WriteSize = EndPos - StartPos;\n        }\n\n        OS_BSP_ConsoleOutput_Impl(&console->BufBase[StartPos], WriteSize);\n\n        StartPos += WriteSize;\n        if (StartPos >= console->BufSize)\n        {\n            /* handle wrap */\n            StartPos = 0;\n        }\n    }\n\n    OS_BSP_Unlock_Impl();\n\n    /* Update the global with the new read location */\n    console->ReadPos = StartPos;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ConsoleOutput_Impl:\ntypedef struct\n{\n    char device_name[OS_MAX_API_NAME];\n\n    char *          BufBase;        /**< Start of the buffer memory */\n    size_t          BufSize;        /**< Total size of the buffer */\n    volatile size_t ReadPos;        /**< Offset of next byte to read */\n    volatile size_t WritePos;       /**< Offset of next byte to write */\n    uint32          OverflowEvents; /**< Number of lines dropped due to overflow */\n    bool            IsAsync;        /**< Whether to write data via deferred utility task */\n} OS_console_internal_record_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_console_internal_record_t OS_console_table[OS_MAX_CONSOLES]\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nvoid OS_BSP_Lock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_lock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_lock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /*\n         * Temporarily Disable/Defer thread cancellation.\n         * Note that OS_BSP_ConsoleOutput_Impl() calls write() which is a cancellation point.\n         * So if this calling task is canceled, it risks leaving the BSP locked.\n         */\n        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &OS_BSP_GenericLinuxGlobal.AccessCancelState);\n    }\n}\n...\nvoid OS_BSP_Unlock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_unlock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /* Restore previous cancellability state */\n        pthread_setcancelstate(OS_BSP_GenericLinuxGlobal.AccessCancelState, NULL);\n    }\n}\n...\nvoid OS_BSP_ConsoleOutput_Impl(const char *Str, size_t DataLen)\n{\n    ssize_t WriteLen;\n\n    while (DataLen > 0)\n    {\n        /* writes the raw data directly to STDOUT_FILENO (unbuffered) */\n        WriteLen = write(STDOUT_FILENO, Str, DataLen);\n        if (WriteLen <= 0)\n        {\n            /* no recourse if this fails, just stop. */\n            break;\n        }\n        Str += WriteLen;\n        DataLen -= WriteLen;\n    }\n}\n...\nint32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /*\n         * The entire string should be put to the ring buffer,\n         * or none of it.  Therefore the WritePos in the table\n         * is not updated until complete success.\n         */\n        PendingWritePos = console->WritePos;\n\n        if (console->device_name[0] != 0)\n        {\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            console->WritePos = PendingWritePos;\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n        }\n\n        /*\n         * Notify the underlying console implementation of new data.\n         * This will forward the data to the actual console device.\n         *\n         * This is done while still locked, so it can support\n         * either a synchronous or asynchronous implementation.\n         */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWakeup_Impl(&token);\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleOutput_Impl(&token);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nstatic void *OS_ConsoleTask_Entry(void *arg)\n{\n    OS_VoidPtrValueWrapper_t           local_arg;\n    OS_impl_console_internal_record_t *local;\n    OS_object_token_t                  token;\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    local_arg.opaque_arg = arg;\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_CONSOLE, local_arg.id, &token) == OS_SUCCESS)\n    {\n        local = OS_OBJECT_TABLE_GET(OS_impl_console_table, token);\n\n        /* Loop forever (unless shutdown is set) */\n        while (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n        {\n            OS_ConsoleOutput_Impl(&token);\n            sem_wait(&local->data_sem);\n        }\n        OS_ObjectIdRelease(&token);\n    }\n    return NULL;\n}\n...\nstatic int32 OS_Console_CopyOut(OS_console_internal_record_t *console, const char *Str, size_t *NextWritePos)\n{\n    const char *pmsg;\n    size_t      WriteOffset;\n    int32       return_code;\n\n    return_code = OS_ERROR;\n    pmsg        = Str;\n    WriteOffset = *NextWritePos;\n    while (true)\n    {\n        if (*pmsg == 0)\n        {\n            /* String is complete */\n            *NextWritePos = WriteOffset;\n            return_code   = OS_SUCCESS;\n            break;\n        }\n        console->BufBase[WriteOffset] = *pmsg;\n        WriteOffset                   = WriteOffset + 1;\n        if (WriteOffset >= console->BufSize)\n        {\n            WriteOffset = 0;\n        }\n\n        if (WriteOffset == console->ReadPos)\n        {\n            /* out of space */\n            return_code = OS_QUEUE_FULL;\n            break;\n        }\n\n        ++pmsg;\n    }\n\n    return return_code;\n}\n...\nvoid OS_ConsoleWakeup_Impl(const OS_object_token_t *token)\n{\n    OS_impl_console_internal_record_t *local;\n\n    local = OS_OBJECT_TABLE_GET(OS_impl_console_table, *token);\n\n    /* post the sem for the utility task to run */\n    sem_post(&local->data_sem);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nwhile (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The while loop tests OS_SharedGlobalVars.GlobalState against OS_SHUTDOWN_MAGIC_NUMBER, but GlobalState is not shown as volatile/atomic and is not modified within the loop body. Because the expression can be treated as invariant by the compiler (leading to an unintended infinite loop), this violates MISRA C 2023 Rule 14.3. The construct is not one of the permitted exceptions (it is not an intentionally infinite loop and not the allowed do-while case)."
}