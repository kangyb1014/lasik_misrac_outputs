{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleOutput_Impl:\n```c\nvoid OS_ConsoleOutput_Impl(const OS_object_token_t *token)\n{\n    size_t                        StartPos;\n    size_t                        EndPos;\n    size_t                        WriteSize;\n    OS_console_internal_record_t *console;\n\n    console  = OS_OBJECT_TABLE_GET(OS_console_table, *token);\n    StartPos = console->ReadPos;\n    EndPos   = console->WritePos;\n\n    OS_BSP_Lock_Impl();\n\n    while (StartPos != EndPos)\n    {\n        if (StartPos > EndPos)\n        {\n            /* handle wrap */\n            WriteSize = console->BufSize - StartPos;\n        }\n        else\n        {\n            WriteSize = EndPos - StartPos;\n        }\n\n        OS_BSP_ConsoleOutput_Impl(&console->BufBase[StartPos], WriteSize);\n\n        StartPos += WriteSize;\n        if (StartPos >= console->BufSize)\n        {\n            /* handle wrap */\n            StartPos = 0;\n        }\n    }\n\n    OS_BSP_Unlock_Impl();\n\n    /* Update the global with the new read location */\n    console->ReadPos = StartPos;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nwhile (StartPos != EndPos)\n{\n    if (StartPos > EndPos)\n    {\n        /* handle wrap */\n        WriteSize = console->BufSize - StartPos;\n    }\n    else\n    {\n        WriteSize = EndPos - StartPos;\n    }\n\n    OS_BSP_ConsoleOutput_Impl(&console->BufBase[StartPos], WriteSize);\n\n    StartPos += WriteSize;\n    if (StartPos >= console->BufSize)\n    {\n        /* handle wrap */\n        StartPos = 0;\n    }\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in this fragment: WriteSize is computed so that the call OS_BSP_ConsoleOutput_Impl(&console->BufBase[StartPos], WriteSize) only references bytes StartPos .. StartPos+WriteSize-1 within the circular buffer. When StartPos > EndPos the fragment uses WriteSize = BufSize - StartPos (producing access up to BufBase[BufSize-1]); when StartPos < EndPos it uses WriteSize = EndPos - StartPos (access up to EndPos-1). Thus the code as shown does not cause accesses beyond the buffer bounds and does not itself call any <string.h> routines. A violation would occur if the buffer invariants were broken (e.g. BufSize == 0 or StartPos/EndPos could be >= BufSize) or if OS_BSP_ConsoleOutput_Impl internally called a string.h function (like strlen/memcpy) with mismatched length/termination assumptions that caused out-of-bounds access."
}