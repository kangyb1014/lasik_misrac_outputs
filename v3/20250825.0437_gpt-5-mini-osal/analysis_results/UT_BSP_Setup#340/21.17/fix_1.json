{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nvoid UT_BSP_Setup(void)\n{\n    /* Probe helper: append concise state information to /tmp/logs/3409.txt\n       This helper intentionally logs only pointer values and counters (no\n       dereference of pointed string contents) so it does not introduce\n       extra out-of-bounds reads beyond the original behavior. */\n    static void UT_BSP_LogProbe(const char *stage, uint32 ArgC, char *const *ArgV, int cmp_result)\n    {\n        FILE *f = fopen(\"/tmp/logs/3409.txt\", \"a\");\n        if (f != NULL)\n        {\n            /* Log stage, ArgC and ArgV pointer value. */\n            fprintf(f, \"%s: ArgC=%lu, ArgV=%p, strcmp_result=%d\\n\",\n                    stage, (unsigned long)ArgC, (void *)ArgV, cmp_result);\n\n            /* If ArgV exists, log the pointer values stored in the first two slots.\n               Do not dereference ArgV[0] to read string bytes (that could cause\n               additional out-of-bounds reads); only capture the pointer values. */\n            if (ArgV != NULL)\n            {\n                /* Safe to read ArgV[0] as a pointer value if ArgV is non-NULL. */\n                fprintf(f, \"%s: ArgV[0]=%p, ArgV[1]=%p\\n\",\n                        stage, (void *)ArgV[0], (void *)(ArgV[1]));\n            }\n\n            fclose(f);\n        }\n    }\n\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV;\n\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    UserShift = UTASSERT_CASETYPE_NONE;\n    ArgC      = OS_BSP_GetArgC();\n    UT_BSP_LogProbe(\"entry_after_GetArgC\", ArgC, NULL, 0);\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        UT_BSP_LogProbe(\"after_GetArgV\", ArgC, ArgV, 0);\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            /* Log state immediately before each strcmp call so evidence is\n               recorded in case the subsequent strcmp triggers an out-of-bounds\n               read or crash. The cmp_result parameter is 0 here to indicate\n               this is a pre-call probe. */\n            UT_BSP_LogProbe(\"before_strcmp_-d\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UT_BSP_LogProbe(\"after_strcmp_-d\", ArgC, ArgV, 0);\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n\n            UT_BSP_LogProbe(\"before_strcmp_-q\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UT_BSP_LogProbe(\"after_strcmp_-q\", ArgC, ArgV, 0);\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n\n            UT_BSP_LogProbe(\"before_strcmp_-v\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UT_BSP_LogProbe(\"before_strtoul_arg\", ArgC, ArgV, 0);\n                UserShift = strtoul(ArgV[1], NULL, 0);\n                UT_BSP_LogProbe(\"after_strtoul_arg\", ArgC, ArgV, (int)UserShift);\n                ++ArgV;\n            }\n\n            ++ArgV;\n        }\n    }\n\n    UT_BSP_LogProbe(\"after_loop\", ArgC, NULL, (int)UserShift);\n\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2 << UserShift) - 1;\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp650vulyj/src/ut_assert/src/utbsp.c: In function 'UT_BSP_Setup':\n/tmp/tmp650vulyj/src/ut_assert/src/utbsp.c:73:17: error: invalid storage class for function 'UT_BSP_LogProbe'\n   73 |     static void UT_BSP_LogProbe(const char *stage, uint32 ArgC, char *const *ArgV, int cmp_result)\n      |                 ^~~~~~~~~~~~~~~\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:146: ut_assert/CMakeFiles/ut_assert.dir/src/utbsp.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UT_BSP_Setup as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Minimal type aliases to match the original code's usage */\ntypedef uint8_t  uint8;\ntypedef uint32_t uint32;\n\n/* Minimal constants to match the original code's usage */\nenum\n{\n    UTASSERT_CASETYPE_NONE = 0,\n    UTASSERT_CASETYPE_DEBUG,\n    UTASSERT_CASETYPE_FAILURE,\n    UTASSERT_CASETYPE_PASS,\n    UTASSERT_CASETYPE_MAX,\n    UTASSERT_CASETYPE_BEGIN = 100 /* arbitrary distinct value for begin */\n};\n\n/* Minimal global structure used by the function */\nstruct\n{\n    unsigned int CurrVerbosity;\n} BSP_UT_Global;\n\n/* External functions provided elsewhere in the build (do not mock/define here) */\nextern uint32 OS_BSP_GetArgC(void);\nextern char *const *OS_BSP_GetArgV(void);\nextern void UT_BSP_DoText(int type, const char *text);\n\n/*\n * Probe helper moved to file scope (cannot define a function inside another\n * function in standard C). It intentionally only logs pointer values and\n * counters and does not dereference pointed string contents for safety.\n */\nstatic void UT_BSP_LogProbe(const char *stage, uint32 ArgC, char *const *ArgV, int cmp_result)\n{\n    FILE *f = fopen(\"/tmp/logs/3409.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Log stage, ArgC and ArgV pointer value. */\n        fprintf(f, \"%s: ArgC=%lu, ArgV=%p, strcmp_result=%d\\n\",\n                stage, (unsigned long)ArgC, (void *)ArgV, cmp_result);\n\n        /* If ArgV exists, log the pointer values stored in the first two slots.\n           Do not dereference ArgV[0] to read string bytes. */\n        if (ArgV != NULL)\n        {\n            fprintf(f, \"%s: ArgV[0]=%p, ArgV[1]=%p\\n\",\n                    stage, (void *)ArgV[0], (void *)(ArgV[1]));\n        }\n\n        fclose(f);\n    }\n}\n\nvoid UT_BSP_Setup(void)\n{\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV;\n\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    UserShift = UTASSERT_CASETYPE_NONE;\n    ArgC      = OS_BSP_GetArgC();\n    UT_BSP_LogProbe(\"entry_after_GetArgC\", ArgC, NULL, 0);\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        UT_BSP_LogProbe(\"after_GetArgV\", ArgC, ArgV, 0);\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            /* Log state immediately before each strcmp call so evidence is\n               recorded in case the subsequent strcmp triggers an out-of-bounds\n               read or crash. The cmp_result parameter is 0 here to indicate\n               this is a pre-call probe. */\n            UT_BSP_LogProbe(\"before_strcmp_-d\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UT_BSP_LogProbe(\"after_strcmp_-d\", ArgC, ArgV, 0);\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n\n            UT_BSP_LogProbe(\"before_strcmp_-q\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UT_BSP_LogProbe(\"after_strcmp_-q\", ArgC, ArgV, 0);\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n\n            UT_BSP_LogProbe(\"before_strcmp_-v\", ArgC, ArgV, 0);\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UT_BSP_LogProbe(\"before_strtoul_arg\", ArgC, ArgV, 0);\n                UserShift = strtoul(ArgV[1], NULL, 0);\n                UT_BSP_LogProbe(\"after_strtoul_arg\", ArgC, ArgV, (int)UserShift);\n                ++ArgV;\n            }\n\n            ++ArgV;\n        }\n    }\n\n    UT_BSP_LogProbe(\"after_loop\", ArgC, NULL, (int)UserShift);\n\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2 << UserShift) - 1;\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n",
  "explanation": "The original code defined the helper function UT_BSP_LogProbe inside UT_BSP_Setup, which is not allowed in standard C. I moved UT_BSP_LogProbe to file scope and marked it static. I also added minimal type aliases (uint8, uint32), enum constants for the UTASSERT_CASETYPE_* values, a minimal BSP_UT_Global structure, and extern declarations for the external functions used (OS_BSP_GetArgC, OS_BSP_GetArgV, UT_BSP_DoText). No functions were mocked/implemented; only declarations and necessary definitions were added so the unit compiles while preserving the original logic."
}