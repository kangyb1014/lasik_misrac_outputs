{
  "user_message": "An agent A claimed that the following UT_BSP_Setup code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_Setup.\n```c\nvoid UT_BSP_Setup(void)\n{\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV;\n\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    UserShift = UTASSERT_CASETYPE_NONE;\n    ArgC      = OS_BSP_GetArgC();\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UserShift = strtoul(ArgV[1], NULL, 0);\n                ++ArgV;\n            }\n\n            ++ArgV;\n        }\n    }\n\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2 << UserShift) - 1;\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nArgV is declared as char *const * which means the pointers to char are const but the characters pointed-to are not const. In the function ArgV is only used for read-only operations (strcmp, strtoul) and the code never modifies the pointed-to characters; therefore the pointee type should be const-qualified. e.g. declare as const char * const *ArgV (or char const * const *ArgV).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffe16aac1b8\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-binsem-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe16aac1b8\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe16aac1c0\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffe9a529238\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-common-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe9a529238\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe9a529240\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffc5641cef8\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-console-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffc5641cef8\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffc5641cf00\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffc0a7355e8\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-countsem-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffc0a7355e8\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffc0a7355f0\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffcdcaa0028\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-dirs-globals-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffcdcaa0028\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffcdcaa0030\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7fff430d1ef8\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-files-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7fff430d1ef8\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7fff430d1f00\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffce6549188\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-filesys-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffce6549188\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffce6549190\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffe355545e8\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-coverage/vxworks/coverage-vxworks-idmap-testrunner\n[ITER_START] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe355545e8\n[ITER_END] ArgC=0, UserShift=0, ArgV_ptr=0x7ffe355545f0\n[ADJUST_USERSHIFT_TO_PASS] ArgC=0, UserShift=0, ArgV_ptr=(nil)\n[USERSHIFT_IS_PASS] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[FINAL] ArgC=0, UserShift=11, ArgV_ptr=(nil)\n[INITIAL] ArgC=1, UserShift=0, ArgV_ptr=(nil)\n[BEFORE_LOOP] ArgC=1, UserShift=0, ArgV_ptr=0x7ffcfd45c928\n[BEFORE_LOOP] ArgV[0]=/tmp/tmp743lbghk/build/unit-test-\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the function ArgV is declared as char *const * which is a pointer to (char * const) \u2014 i.e. the pointer elements are const but the characters they point to are not const. All uses of ArgV in this function are read-only (strcmp, strtoul and reading ArgV[n]), so the pointed-to characters should be const-qualified to follow MISRA C 2023 Rule 8.13. The appropriate declaration would be const char * const *ArgV (or char const * const *ArgV). Note: changing the local declaration may require the OS_BSP_GetArgV API to return a matching const-qualified type (or an explicit, justified cast) \u2014 such an API mismatch is the only valid reason not to apply the const qualifier locally, and would need to be addressed (or formally deviated) to be fully MISRA-compliant."
}