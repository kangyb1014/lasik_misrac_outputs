{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nArgV is declared as 'char *const *ArgV' so the pointed-to strings are of type 'char *' (non-const), yet they are only read (passed to strcmp). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type when possible. The fragment 'strcmp(ArgV[0], \"-d\")' uses ArgV[0] in a read-only way, so ArgV should be declared as 'const char * const *ArgV' (or at least 'const char * const *' or 'const char * const *') to make the pointee const-qualified.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_BSP_Setup code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3403.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_BSP_Setup as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_BSP_Setup:\n```c\nvoid UT_BSP_Setup(void)\n{\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV;\n\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    UserShift = UTASSERT_CASETYPE_NONE;\n    ArgC      = OS_BSP_GetArgC();\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UserShift = strtoul(ArgV[1], NULL, 0);\n                ++ArgV;\n            }\n\n            ++ArgV;\n        }\n    }\n\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2 << UserShift) - 1;\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n```\n</target_code>\nPlease provide the modified UT_BSP_Setup code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n/* Minimal types to allow this unit to compile and run as a self-contained test.\n   These mirror the expected types used by the original UT_BSP_Setup() implementation. */\ntypedef uint8_t  uint8;\ntypedef uint32_t uint32;\n\n/* Minimal UT assert case type constants used in the original code. */\nenum\n{\n    UTASSERT_CASETYPE_NONE = 0,\n    UTASSERT_CASETYPE_DEBUG,\n    UTASSERT_CASETYPE_FAILURE,\n    UTASSERT_CASETYPE_PASS,\n    UTASSERT_CASETYPE_MAX = 8\n};\n\n/* Minimal BSP_UT_Global structure used by the original code. */\nstruct\n{\n    uint32 CurrVerbosity;\n} BSP_UT_Global;\n\n/* Stubs for external functions referenced by UT_BSP_Setup.  These provide a\n   deterministic set of arguments so the logging can demonstrate the control path. */\nstatic uint32 OS_BSP_GetArgC(void);\nstatic char **OS_BSP_GetArgV(void);\nstatic void UT_BSP_DoText(uint32 Type, const char *Text);\n\n/* Logging helper that appends entries to the required log file. */\nstatic void UT_BSP_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/3403.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging cannot be opened, there's nothing we can do here without\n           changing the program flow. Return silently to preserve original behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\n/* Provide a deterministic argument vector for testing.  These are mutable\n   arrays so they match the original code's 'char *const *' usage without\n   relying on string literals stored in read-only memory. */\nstatic uint32 OS_BSP_GetArgC(void)\n{\n    /* Example scenario: program invoked with: prog -d -v 3 -q\n       That should exercise the -d, -v <n>, and -q branches. */\n    return 4U; /* number of arg tokens after the program name in this mock */\n}\n\nstatic char **OS_BSP_GetArgV(void)\n{\n    /* Allocate a small static array of modifiable strings */\n    static char arg0[] = \"-d\";\n    static char arg1[] = \"-v\";\n    static char arg2[] = \"3\";\n    static char arg3[] = \"-q\";\n\n    /* Note: we intentionally provide a char * array to mirror the original\n       declaration 'char *const *ArgV' in the target code. */\n    static char *argv[] = { arg0, arg1, arg2, arg3 };\n\n    return argv;\n}\n\n/* Minimal implementation that logs when UT_BSP_DoText is invoked. */\nstatic void UT_BSP_DoText(uint32 Type, const char *Text)\n{\n    UT_BSP_Log(\"UT_BSP_DoText called: Type=%u, Text=\\\"%s\\\"\", (unsigned)Type, Text);\n}\n\n/* Modified UT_BSP_Setup with logging probes that capture the control flow and\n   state information relevant to the pointer qualifier/argument usage scenario.\n   The original logic is preserved; only logging statements have been added. */\nvoid UT_BSP_Setup(void)\n{\n    uint8        UserShift;\n    uint32       ArgC;\n    char *const *ArgV; /* Intentionally left as in the original code to reproduce the scenario */\n\n    /* Preserve original behavior: clear the global structure */\n    memset(&BSP_UT_Global, 0, sizeof(BSP_UT_Global));\n\n    /* Initial UserShift */\n    UserShift = UTASSERT_CASETYPE_NONE;\n\n    ArgC      = OS_BSP_GetArgC();\n    UT_BSP_Log(\"OS_BSP_GetArgC returned ArgC=%u\", (unsigned)ArgC);\n\n    if (ArgC > 0)\n    {\n        ArgV = OS_BSP_GetArgV();\n        UT_BSP_Log(\"OS_BSP_GetArgV returned ArgV=%p\", (void *)ArgV);\n\n        while (ArgC > 0)\n        {\n            --ArgC;\n\n            /* Log current token and pointer addresses to provide evidence about\n               how the pointer-to-pointer is being used (read-only in this code). */\n            UT_BSP_Log(\"Processing token: ArgC_remaining=%u, ArgV=%p, ArgV[0]=%p, ArgV[0] -> \\\"%s\\\"\",\n                       (unsigned)ArgC, (void *)ArgV, (void *)ArgV[0], ArgV[0] ? ArgV[0] : \"(null)\");\n\n            if (strcmp(ArgV[0], \"-d\") == 0)\n            {\n                UT_BSP_Log(\"Matched '-d' (strcmp returned 0). Setting UserShift=UTASSERT_CASETYPE_DEBUG\");\n                UserShift = UTASSERT_CASETYPE_DEBUG;\n            }\n            if (strcmp(ArgV[0], \"-q\") == 0)\n            {\n                UT_BSP_Log(\"Matched '-q' (strcmp returned 0). Setting UserShift=UTASSERT_CASETYPE_FAILURE\");\n                UserShift = UTASSERT_CASETYPE_FAILURE;\n            }\n            if (strcmp(ArgV[0], \"-v\") == 0 && ArgC > 0)\n            {\n                --ArgC;\n                UT_BSP_Log(\"Matched '-v' and ArgC>0. Consuming next token ArgV[1]=%p -> \\\"%s\\\"\",\n                           (void *)ArgV[1], ArgV[1] ? ArgV[1] : \"(null)\");\n\n                /* Preserve original behavior: parse numeric verbosity shift */\n                UserShift = (uint8)strtoul(ArgV[1], NULL, 0);\n                UT_BSP_Log(\"Parsed UserShift from ArgV[1]: %u\", (unsigned)UserShift);\n\n                ++ArgV; /* advance past the numeric parameter */\n            }\n\n            ++ArgV; /* advance to next token */\n            UT_BSP_Log(\"Advanced ArgV pointer to %p\", (void *)ArgV);\n        }\n    }\n    else\n    {\n        UT_BSP_Log(\"No arguments (ArgC==0). Skipping argument processing.\");\n    }\n\n    /* Ensure UserShift is valid as in original code */\n    if (UserShift == UTASSERT_CASETYPE_NONE || UserShift >= UTASSERT_CASETYPE_MAX)\n    {\n        UT_BSP_Log(\"UserShift=%u invalid or none. Forcing UserShift=UTASSERT_CASETYPE_PASS\", (unsigned)UserShift);\n        UserShift = UTASSERT_CASETYPE_PASS;\n    }\n\n    BSP_UT_Global.CurrVerbosity = (2U << UserShift) - 1U;\n    UT_BSP_Log(\"Final UserShift=%u, BSP_UT_Global.CurrVerbosity=%u\", (unsigned)UserShift, (unsigned)BSP_UT_Global.CurrVerbosity);\n\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, \"UNIT TEST\");\n}\n"
}