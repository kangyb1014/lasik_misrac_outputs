{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code reads fields from UtTestDataBaseEntry but does not modify the structure itself; the local pointer is declared as UtTestDataBaseEntry_t *UtTestDataBaseEntry (non-const). According to Rule 8.13 the pointer should point to a const-qualified type whenever possible, so it should be declared as const UtTestDataBaseEntry_t *UtTestDataBaseEntry (or equivalent) if the function does not modify the pointed-to object. Example fix: const UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtTest_Run code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3263.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtTest_Run as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtTest_Run:\n```c\nvoid UtTest_Run(void)\n{\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    UT_BSP_Lock();\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    UT_BSP_Unlock();\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                UtTestDataBaseEntry->Setup();\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                UtTestDataBaseEntry->Teardown();\n            }\n\n            UtAssert_EndTest();\n        }\n    }\n\n    UT_BSP_Lock();\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n    UT_BSP_Unlock();\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n}\n```\n</target_code>\nPlease provide the modified UtTest_Run code.\n",
  "test_code": "#include <stdio.h>\n\n/* Probe logging helpers to capture control flow and state for Rule 8.13 investigation */\nstatic FILE *UtTest_LogFile = NULL;\n\nstatic void UtTest_LogOpen(void)\n{\n    if (UtTest_LogFile == NULL)\n    {\n        /* Attempt to append to the required log file */\n        UtTest_LogFile = fopen(\"/tmp/logs/3263.txt\", \"a\");\n        if (UtTest_LogFile)\n        {\n            fprintf(UtTest_LogFile, \"--- UtTest_Run start ---\\n\");\n            fflush(UtTest_LogFile);\n        }\n    }\n}\n\nstatic void UtTest_LogClose(void)\n{\n    if (UtTest_LogFile)\n    {\n        fprintf(UtTest_LogFile, \"--- UtTest_Run end ---\\n\\n\");\n        fclose(UtTest_LogFile);\n        UtTest_LogFile = NULL;\n    }\n}\n\n/* Log the state of a database entry and its node. Use const-qualified parameter to emphasize read-only reporting. */\nstatic void UtTest_LogEntryState(const UtTestDataBaseEntry_t *Entry, const UtListNode_t *Node, const char *Stage)\n{\n    if (UtTest_LogFile == NULL)\n    {\n        return;\n    }\n\n    fprintf(UtTest_LogFile, \"Stage=%s, Node=%p, Entry=%p\\n\", Stage, (const void *)Node, (const void *)Entry);\n\n    if (Entry != NULL)\n    {\n        /* Log the commonly used fields (only read) to provide evidence that the code does not modify the structure */\n        fprintf(UtTest_LogFile, \"  TestName=%s\\n\",\n                (Entry->TestName != NULL) ? Entry->TestName : \"(null)\");\n        fprintf(UtTest_LogFile, \"  Setup=%p, Test=%p, Teardown=%p\\n\",\n                (const void *)Entry->Setup, (const void *)Entry->Test, (const void *)Entry->Teardown);\n    }\n    fflush(UtTest_LogFile);\n}\n\nvoid UtTest_Run(void)\n{\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry; /* Intentionally non-const to match original code under investigation */\n\n    UtTest_LogOpen(); /* open logging as early as practical */\n\n    UT_BSP_Lock();\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    /* Log the merged list head for traceability */\n    UtTest_LogEntryState(NULL, UtListMain, \"merged-list-head\");\n\n    UT_BSP_Unlock();\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        /* Log discovery of an entry and its read-only fields */\n        UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"entry-discovered\");\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"calling-setup\");\n                UtTestDataBaseEntry->Setup();\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"returned-setup\");\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                long oldCount = UtAssert_Global.ExecutedCount;\n\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"calling-test\");\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"returned-test\");\n\n                /* Log the increment for reproducible evidence */\n                if (UtTest_LogFile)\n                {\n                    fprintf(UtTest_LogFile, \"  ExecutedCount: %ld -> %ld\\n\", (long)oldCount, (long)UtAssert_Global.ExecutedCount);\n                    fflush(UtTest_LogFile);\n                }\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"calling-teardown\");\n                UtTestDataBaseEntry->Teardown();\n                UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"returned-teardown\");\n            }\n\n            UtAssert_EndTest();\n\n            /* Additional log to show that the entry was only read and not written to by this function */\n            UtTest_LogEntryState(UtTestDataBaseEntry, UtListNode, \"post-test-verification-read-only\");\n        }\n    }\n\n    UT_BSP_Lock();\n    UtTest_LogEntryState(NULL, UtListMain, \"before-destroy-database-head\");\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n    UT_BSP_Unlock();\n\n    /* Log counters at the end of the run */\n    if (UtTest_LogFile)\n    {\n        fprintf(UtTest_LogFile, \"Final ExecutedCount=%ld\\n\", (long)UtAssert_Global.ExecutedCount);\n        fflush(UtTest_LogFile);\n    }\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n\n    UtTest_LogClose();\n}\n"
}