{
  "user_message": "An agent A claimed that the following UtTest_Run code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_Run.\n```c\nvoid UtTest_Run(void)\n{\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    UT_BSP_Lock();\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    UT_BSP_Unlock();\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                UtTestDataBaseEntry->Setup();\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                UtTestDataBaseEntry->Teardown();\n            }\n\n            UtAssert_EndTest();\n        }\n    }\n\n    UT_BSP_Lock();\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n    UT_BSP_Unlock();\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nUtTestDataBaseEntry is used only for read access (checking and invoking the Setup function pointer) but is declared as a non-const pointer. The pointer could be const-qualified (e.g. const UtTestDataBaseEntry_t *UtTestDataBaseEntry) to reflect that the database entry is not modified here. Therefore this code violates Rule 8.13. (If the invoked Setup function or other code in scope is intended to modify the database entry itself, then const qualification would be inappropriate.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtTest_Run: Enter\nUtTest_Run: Initial merged head = 0x55b132cd58a0\nUtTest_Run: After merges, merged head = 0x55b132cd58a0\nUtTest_Run: Visiting node=0x55b132cd58c0, entry_ptr=(nil)\nUtTest_Run: Visiting node=0x55b132cd58e0, entry_ptr=(nil)\nUtTest_Run: Visiting node=0x55b132cd5930, entry_ptr=0x55b132cd5950\nUtTest_Run: TestName='OS_VxWorks_BinSemAPI_Impl_Init', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=0\nUtTest_Run: Calling Setup for 'OS_VxWorks_BinSemAPI_Impl_Init'\nUtTest_Run: Returned from Setup for 'OS_VxWorks_BinSemAPI_Impl_Init'\nUtTest_Run: Calling Test for 'OS_VxWorks_BinSemAPI_Impl_Init' (before) ExecutedCount=0\nUtTest_Run: Returned from Test for 'OS_VxWorks_BinSemAPI_Impl_Init' (after) ExecutedCount=1\nUtTest_Run: Calling Teardown for 'OS_VxWorks_BinSemAPI_Impl_Init'\nUtTest_Run: Returned from Teardown for 'OS_VxWorks_BinSemAPI_Impl_Init'\nUtTest_Run: Visiting node=0x55b132cd59a0, entry_ptr=0x55b132cd59c0\nUtTest_Run: TestName='OS_BinSemCreate_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=1\nUtTest_Run: Calling Setup for 'OS_BinSemCreate_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemCreate_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemCreate_Impl' (before) ExecutedCount=1\nUtTest_Run: Returned from Test for 'OS_BinSemCreate_Impl' (after) ExecutedCount=2\nUtTest_Run: Calling Teardown for 'OS_BinSemCreate_Impl'\nUtTest_Run: Returned from Teardown for 'OS_BinSemCreate_Impl'\nUtTest_Run: Visiting node=0x55b132cd5a10, entry_ptr=0x55b132cd5a30\nUtTest_Run: TestName='OS_BinSemDelete_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=2\nUtTest_Run: Calling Setup for 'OS_BinSemDelete_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemDelete_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemDelete_Impl' (before) ExecutedCount=2\nUtTest_Run: Returned from Test for 'OS_BinSemDelete_Impl' (after) ExecutedCount=3\nUtTest_Run: Calling Teardown for 'OS_BinSemDelete_Impl'\nUtTest_Run: Returned from Teardown for 'OS_BinSemDelete_Impl'\nUtTest_Run: Visiting node=0x55b132cd5a80, entry_ptr=0x55b132cd5aa0\nUtTest_Run: TestName='OS_BinSemGive_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=3\nUtTest_Run: Calling Setup for 'OS_BinSemGive_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemGive_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemGive_Impl' (before) ExecutedCount=3\nUtTest_Run: Returned from Test for 'OS_BinSemGive_Impl' (after) ExecutedCount=4\nUtTest_Run: Calling Teardown for 'OS_BinSemGive_Impl'\nUtTest_Run: Returned from Teardown for 'OS_BinSemGive_Impl'\nUtTest_Run: Visiting node=0x55b132cd5af0, entry_ptr=0x55b132cd5b10\nUtTest_Run: TestName='OS_BinSemFlush_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=4\nUtTest_Run: Calling Setup for 'OS_BinSemFlush_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemFlush_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemFlush_Impl' (before) ExecutedCount=4\nUtTest_Run: Returned from Test for 'OS_BinSemFlush_Impl' (after) ExecutedCount=5\nUtTest_Run: Calling Teardown for 'OS_BinSemFlush_Impl'\nUtTest_Run: Returned from Teardown for 'OS_BinSemFlush_Impl'\nUtTest_Run: Visiting node=0x55b132cd5b60, entry_ptr=0x55b132cd5b80\nUtTest_Run: TestName='OS_BinSemTake_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=5\nUtTest_Run: Calling Setup for 'OS_BinSemTake_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemTake_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemTake_Impl' (before) ExecutedCount=5\nUtTest_Run: Returned from Test for 'OS_BinSemTake_Impl' (after) ExecutedCount=6\nUtTest_Run: Calling Teardown for 'OS_BinSemTake_Impl'\nUtTest_Run: Returned from Teardown for 'OS_BinSemTake_Impl'\nUtTest_Run: Visiting node=0x55b132cd5bd0, entry_ptr=0x55b132cd5bf0\nUtTest_Run: TestName='OS_BinSemTimedWait_Impl', Setup_present=yes, Test_present=yes, Teardown_present=yes, ExecutedCount=6\nUtTest_Run: Calling Setup for 'OS_BinSemTimedWait_Impl'\nUtTest_Run: Returned from Setup for 'OS_BinSemTimedWait_Impl'\nUtTest_Run: Calling Test for 'OS_BinSemTimedWait_Impl' (bef\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown UtTest_Run implementation the local pointer UtTestDataBaseEntry is only used for read access: it is obtained from the list, tested for NULL, its TestName member is passed to UtAssert_BeginTest and the stored function pointers (Setup, Test, Teardown) are invoked. There are no writes to the pointee (no assignments to UtTestDataBaseEntry->... in this function), so the pointer can and therefore should be declared to point to a const-qualified type (e.g. const UtTestDataBaseEntry_t *UtTestDataBaseEntry) to satisfy MISRA C 2023 Rule 8.13. The only caveat is if other code (or the invoked callbacks) require a non-const pointer to the entry or modify the entry through some other means; if that were the case const qualification would be inappropriate. Based on the provided snippet and execution log, no such modifications are visible, so the report of a Rule 8.13 violation is correct."
}