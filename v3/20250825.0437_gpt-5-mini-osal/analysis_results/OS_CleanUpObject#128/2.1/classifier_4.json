{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CleanUpObject:\n```c\nvoid OS_CleanUpObject(osal_id_t object_id, void *arg)\n{\n    uint32 *ObjectCount;\n\n    ObjectCount = (uint32 *)arg;\n    ++(*ObjectCount);\n    switch (OS_IdentifyObject(object_id))\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            OS_TaskDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            OS_QueueDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            OS_BinSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            OS_CountSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            OS_MutSemDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            OS_ModuleUnload(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            OS_TimeBaseDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            OS_TimerDelete(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            OS_close(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_DIR:\n            OS_DirectoryClose(object_id);\n            break;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            OS_CondVarDelete(object_id);\n            break;\n        default:\n            break;\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CleanUpObject:\nosal_objtype_t OS_IdentifyObject(osal_id_t object_id)\n{\n    return OS_ObjectIdToType_Impl(object_id);\n}\n...\nstatic inline osal_objtype_t OS_ObjectIdToType_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) >> OS_OBJECT_TYPE_SHIFT);\n}\n...\ntypedef uint32 osal_id_t\n...\n#define OS_OBJECT_TYPE_OS_TASK 0x01\n...\n#define OS_OBJECT_TYPE_OS_QUEUE 0x02\n...\n#define OS_OBJECT_TYPE_OS_BINSEM 0x04\n...\n#define OS_OBJECT_TYPE_OS_COUNTSEM 0x03\n...\n#define OS_OBJECT_TYPE_OS_MUTEX 0x05\n...\n#define OS_OBJECT_TYPE_OS_MODULE 0x0A\n...\n#define OS_OBJECT_TYPE_OS_TIMEBASE 0x08\n...\n#define OS_OBJECT_TYPE_OS_TIMECB 0x09\n...\n#define OS_OBJECT_TYPE_OS_STREAM 0x06\n...\n#define OS_OBJECT_TYPE_OS_DIR 0x07\n...\n#define OS_OBJECT_TYPE_OS_CONDVAR 0x0D\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ncase OS_OBJECT_TYPE_OS_DIR:\n            OS_DirectoryClose(object_id);\n            break;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: OS_IdentifyObject() returns the object type extracted from the object_id (by shifting the integer form). The constant OS_OBJECT_TYPE_OS_DIR is defined as 0x07 and is one of the possible type values listed, so the case label can be reached when an object_id encodes that type. There is no evidence in the provided code that the value 0x07 is impossible, therefore the switch case is not unreachable."
}