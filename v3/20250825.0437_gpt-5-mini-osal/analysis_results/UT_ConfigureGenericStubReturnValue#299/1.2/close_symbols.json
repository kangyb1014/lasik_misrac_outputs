{
  "user_message": "Target function code is:\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_ConfigureGenericStubReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_SetDeferredRetcode', 'UT_SetDefaultReturnValue']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_SetDeferredRetcode': {'callees': ['UtAssert_GetContext', 'UT_ConfigureGenericStubReturnValue'], 'callers': []}, 'UT_SetDefaultReturnValue': {'callees': ['UT_ConfigureGenericStubReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry (function prototype/definition)",
    "UtAssert_Abort (function prototype/definition)",
    "UT_StoreRetval (function prototype/definition)",
    "UT_StubTableEntry_t (full type/struct/union definition)",
    "Data.Rvc.Buf type (the nested buffer type definition and its members)",
    "UT_EntryType_t and constants (UT_ENTRYTYPE_UNUSED, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT)",
    "UT_ValueGenre_t and constants (UT_ValueGenre_OPAQUE, etc.)",
    "UT_EntryKey_t (typedef/underlying type)",
    "int32 (typedef/definition)",
    "Relevant header(s) that define macros/attributes used by the above (any header that defines __attribute__, __declspec, anonymous-union or other compiler-specific macros)"
  ],
  "explanation": "To determine whether UT_ConfigureGenericStubReturnValue uses any compiler language extensions (MISRA rule check), the analyzer must inspect not only the body but the declarations and types it uses. For each listed symbol the reason is:\n\n- UT_GetStubEntry (function prototype/definition): The function is called twice; its declaration may carry compiler-specific attributes (e.g. calling-convention specifiers, __attribute__, __declspec) or nonstandard parameter types that would constitute language extensions.\n\n- UtAssert_Abort (function prototype/definition): This call is used for an abort path. Its declaration/definition commonly carries attributes such as noreturn or other vendor-specific annotations (noreturn attributes, format attributes, etc.). Those annotations are implementation extensions that must be checked.\n\n- UT_StoreRetval (function prototype/definition): Called to copy return-value data into the buffer. Its signature and implementation could use extensions (inline assembly, typeof, nonstandard pointer attributes) or accept/return compiler-specific types.\n\n- UT_StubTableEntry_t (full type/struct/union definition): The code writes multiple fields of this struct/union. The struct definition might use language extensions (anonymous structs/unions, nonstandard bit-field types, packed/aligned attributes, flexible-array members with extensions, or vendor pragmas). Inspecting the full definition is necessary to detect those.\n\n- Data.Rvc.Buf type (the nested buffer type definition and its members): The code accesses Buf.IndirectPtr and passes Buf to UT_StoreRetval. The buffer type could use compiler extensions (e.g. anonymous unions, GCC extension members, pointer-sized attributes). Its exact definition is required.\n\n- UT_EntryType_t and constants (UT_ENTRYTYPE_UNUSED, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT): These may be macros or enums; macros could expand to extension constructs, and enums might carry attributes. Need definitions to detect any nonstandard usage.\n\n- UT_ValueGenre_t and constants (UT_ValueGenre_OPAQUE, etc.): Same rationale as above \u2014 these may be declared via extension mechanisms or use nonstandard enum features.\n\n- UT_EntryKey_t (typedef/underlying type): The underlying type could be a compiler-specific typedef (e.g. using __int128 or other nonstandard integer types) or annotated with attributes \u2014 this must be checked.\n\n- int32 (typedef/definition): The code uses int32 (nonstandard name compared to int32_t); the typedef may map to a compiler-specific type or be defined using extensions \u2014 inspect its definition.\n\n- Relevant header(s) that define macros/attributes used by the above (any header that defines __attribute__, __declspec, anonymous-union or other compiler-specific macros): Many extensions are introduced or hidden behind macros. To reliably detect extensions you must inspect the headers that define those macros/annotations so the analyzer can see whether constructs used are standard C or compiler-specific extensions.\n\nCollecting these symbols (prototypes, typedefs, enum/macro definitions and the headers that define any macros/attributes) is sufficient to decide whether the target function or any of its direct dependencies use language extensions (e.g. __attribute__, __declspec, typeof, anonymous unions, inline asm, nonstandard base types, etc.)."
}