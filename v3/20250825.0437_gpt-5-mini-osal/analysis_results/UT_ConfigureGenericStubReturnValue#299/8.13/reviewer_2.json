{
  "user_message": "An agent A claimed that the following UT_ConfigureGenericStubReturnValue code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_ConfigureGenericStubReturnValue.\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member UT_StubTableEntry_t::Data.Rvc.TypeName is declared as a non-const char * (i.e. char *), then assigning the parameter const char *TypeName to it discards the const qualifier and thus violates MISRA C 2023 Rule 8.13. The correct approach is to declare the member as const char *TypeName so the pointer points to a const-qualified type. (If the struct member is already declared as const char *, then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: UT_ConfigureGenericStubReturnValue: FuncKey=94803861882906, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1, Counter=0, TypeName=(nil) ((null))\nControl: Counter<=0 -> ReqEntryType=RETVAL_CONFIG_CONSTANT, StubPtr from GetStubEntry=(nil)\nControl: StubPtr was NULL, re-obtained with UT_ENTRYTYPE_UNUSED -> StubPtr=0x56393e849e40\nBEFORE ASSIGN: StubPtr=0x56393e849e40, Prev FuncKey=0, Prev EntryType=0, Prev TypeNamePtr=(nil) ((null))\nASSIGNMENT: Assigning TypeName ptr (nil) ((null)) to StubPtr->Data.Rvc.TypeName\nAFTER ASSIGN: StubPtr->Data.Rvc.TypeName=(nil) ((null))\nVALUE GENRE: NON-OPAQUE -> Calling UT_StoreRetval with Buf=0x56393e849e58, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1\nUT_StoreRetval returned for FuncKey=94803861882906, Buf=0x56393e849e58\nEXIT: UT_ConfigureGenericStubReturnValue completed for FuncKey=94803861882906, StubPtr=0x56393e849e40\nENTER: UT_ConfigureGenericStubReturnValue: FuncKey=94803861880218, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1, Counter=0, TypeName=(nil) ((null))\nControl: Counter<=0 -> ReqEntryType=RETVAL_CONFIG_CONSTANT, StubPtr from GetStubEntry=(nil)\nControl: StubPtr was NULL, re-obtained with UT_ENTRYTYPE_UNUSED -> StubPtr=0x56393e850c80\nBEFORE ASSIGN: StubPtr=0x56393e850c80, Prev FuncKey=0, Prev EntryType=0, Prev TypeNamePtr=(nil) ((null))\nASSIGNMENT: Assigning TypeName ptr (nil) ((null)) to StubPtr->Data.Rvc.TypeName\nAFTER ASSIGN: StubPtr->Data.Rvc.TypeName=(nil) ((null))\nVALUE GENRE: NON-OPAQUE -> Calling UT_StoreRetval with Buf=0x56393e850c98, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1\nUT_StoreRetval returned for FuncKey=94803861880218, Buf=0x56393e850c98\nEXIT: UT_ConfigureGenericStubReturnValue completed for FuncKey=94803861880218, StubPtr=0x56393e850c80\nENTER: UT_ConfigureGenericStubReturnValue: FuncKey=94803861883873, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1, Counter=0, TypeName=(nil) ((null))\nControl: Counter<=0 -> ReqEntryType=RETVAL_CONFIG_CONSTANT, StubPtr from GetStubEntry=(nil)\nControl: StubPtr was NULL, re-obtained with UT_ENTRYTYPE_UNUSED -> StubPtr=0x56393e847ec0\nBEFORE ASSIGN: StubPtr=0x56393e847ec0, Prev FuncKey=0, Prev EntryType=0, Prev TypeNamePtr=(nil) ((null))\nASSIGNMENT: Assigning TypeName ptr (nil) ((null)) to StubPtr->Data.Rvc.TypeName\nAFTER ASSIGN: StubPtr->Data.Rvc.TypeName=(nil) ((null))\nVALUE GENRE: NON-OPAQUE -> Calling UT_StoreRetval with Buf=0x56393e847ed8, ValuePtr=0x7ffef5467620, ValueSize=8, ValueGenre=1\nUT_StoreRetval returned for FuncKey=94803861883873, Buf=0x56393e847ed8\nEXIT: UT_ConfigureGenericStubReturnValue completed for FuncKey=94803861883873, StubPtr=0x56393e847ec0\nENTER: UT_ConfigureGenericStubReturnValue: FuncKey=94803861880121, ValuePtr=0x7ffef5467610, ValueSize=8, ValueGenre=1, Counter=0, TypeName=(nil) ((null))\nControl: Counter<=0 -> ReqEntryType=RETVAL_CONFIG_CONSTANT, StubPtr from GetStubEntry=(nil)\nControl: StubPtr was NULL, re-obtained with UT_ENTRYTYPE_UNUSED -> StubPtr=0x56393e849f60\nBEFORE ASSIGN: StubPtr=0x56393e849f60, Prev FuncKey=0, Prev EntryType=0, Prev TypeNamePtr=(nil) ((null))\nASSIGNMENT: Assigning TypeName ptr (nil) ((null)) to StubPtr->Data.Rvc.TypeName\nAFTER ASSIGN: StubPtr->Data.Rvc.TypeName=(nil) ((null))\nVALUE GENRE: NON-OPAQUE -> Calling UT_StoreRetval with Buf=0x56393e849f78, ValuePtr=0x7ffef5467610, ValueSize=8, ValueGenre=1\nUT_StoreRetval returned for FuncKey=94803861880121, Buf=0x56393e849f78\nEXIT: UT_ConfigureGenericStubReturnValue completed for FuncKey=94803861880121, StubPtr=0x56393e849f60\nENTER: UT_ConfigureGenericStubReturnValue: FuncKey=94803861880352, ValuePtr=0x7ffef5467610, ValueSize=8, ValueGenre=1, Counter=0, TypeName=(nil) ((null))\nControl: Counter<=0 -> ReqEntryType=RETVAL_CONFIG_CONSTANT, StubPtr from GetStubEntry=(nil)\nControl: StubPtr was NULL, re-obtained with UT_ENTRYTYPE_UNUSED -> StubPtr=0x56393e84c480\nBEFORE ASSIGN: StubPtr=0x56393e84c480, Prev FuncKey=0, Prev EntryType=0, Prev TypeNamePtr=(nil) ((null))\nASSIGNMENT: Assigning TypeName ptr (nil) ((null)) to StubPtr->Data.Rvc.TypeName\nAFTER ASSIGN: StubPtr->Data.Rvc.TypeName=(nil) ((null))\nVALUE GENRE: NO\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown function the parameter is declared as const char *TypeName and is assigned directly to StubPtr->Data.Rvc.TypeName. If that struct member is declared as plain char * (non-const) this both discards the const qualifier (an unsafe qualifier drop) and means the pointer in the structure does not point to a const-qualified type. MISRA C 2023 Rule 8.13 requires that pointers should point to const-qualified types when possible, so the correct declaration for the struct member is const char *TypeName. If the member is already const char * there is no violation; if it is plain char * then the report of a violation is correct."
}