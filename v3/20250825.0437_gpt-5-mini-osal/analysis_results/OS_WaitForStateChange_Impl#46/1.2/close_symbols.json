{
  "user_message": "Target function code is:\n```c\nvoid OS_WaitForStateChange_Impl(osal_objtype_t idtype, uint32 attempts)\n{\n    OS_impl_objtype_lock_t *impl;\n    struct timespec         ts;\n\n    impl = OS_impl_objtype_lock_table[idtype];\n\n    /*\n     * because pthread_cond_timedwait() is also a cancellation point,\n     * this pushes a cleanup handler to ensure that if canceled during this call,\n     * the mutex will be released.\n     */\n    pthread_cleanup_push(OS_Posix_ReleaseTableMutex, &impl->mutex);\n\n    clock_gettime(CLOCK_REALTIME, &ts);\n\n    if (attempts <= 10)\n    {\n        /* Wait an increasing amount of time, starting at 10ms */\n        ts.tv_nsec += attempts * attempts * 10000000;\n        if (ts.tv_nsec >= 1000000000)\n        {\n            ts.tv_nsec -= 1000000000;\n            ++ts.tv_sec;\n        }\n    }\n    else\n    {\n        /* wait 1 second (max for polling) */\n        ++ts.tv_sec;\n    }\n\n    pthread_cond_timedwait(&impl->cond, &impl->mutex, &ts);\n\n    pthread_cleanup_pop(false);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_WaitForStateChange_Impl': {'callees': [], 'callers': ['OS_WaitForStateChange']}, 'OS_WaitForStateChange': {'callees': ['OS_WaitForStateChange_Impl'], 'callers': ['OS_ObjectIdConvertToken']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pthread_cleanup_push",
    "pthread_cleanup_pop",
    "OS_Posix_ReleaseTableMutex",
    "OS_impl_objtype_lock_table",
    "OS_impl_objtype_lock_t",
    "osal_objtype_t",
    "uint32",
    "struct timespec",
    "clock_gettime",
    "CLOCK_REALTIME",
    "pthread_cond_timedwait",
    "pthread_cond_t",
    "pthread_mutex_t",
    "false"
  ],
  "explanation": "To determine whether OS_WaitForStateChange_Impl uses any compiler language extensions you must inspect the actual definitions/expansions and declarations of the identifiers/macros/types used by the function. For each listed symbol: \n\n- pthread_cleanup_push: This is a macro in the pthread API whose expansion (in the system pthread headers) may use compiler-specific constructs (statement expressions, labels-as-values, GCC __attribute__ usage, or other extensions). You must check its macro expansion to see if any language extensions are used.\n\n- pthread_cleanup_pop: Same rationale as pthread_cleanup_push \u2014 its expansion must be inspected for compiler-specific extensions.\n\n- OS_Posix_ReleaseTableMutex: The cleanup handler passed to pthread_cleanup_push; its declaration/definition must be checked for use of compiler extensions (function attributes, nonstandard calling conventions, or other implementation-specific extensions).\n\n- OS_impl_objtype_lock_table: The global table referenced by index; its declaration (array type, extern linkage) must be checked to ensure no nonstandard storage-class or extension is used.\n\n- OS_impl_objtype_lock_t: The type of the table elements (structure) \u2014 inspect its definition for any language extensions inside (compiler attributes on the type/fields, bit-field extensions, flexible array members used in nonstandard ways, anonymous structs/unions if your MISRA policy treats them as extensions, etc.).\n\n- osal_objtype_t: The parameter type \u2014 inspect whether it is an enum/typedef that uses extensions (e.g., enum with explicit width using compiler-specific syntax) or other nonstandard constructs.\n\n- uint32: The integer typedef \u2014 verify its origin (stdint.h uint32_t vs. a compiler-provided nonstandard type) and whether its typedef uses extensions.\n\n- struct timespec: The timespec structure definition (from the system time headers) should be checked for any nonstandard fields or attributes used by the implementation.\n\n- clock_gettime: The declaration of this function may carry implementation-specific attributes or use nonstandard calling conventions; inspect its prototype/attributes.\n\n- CLOCK_REALTIME: The macro/constant \u2014 check how it is defined (some implementations may use nonstandard constructs to implement time IDs).\n\n- pthread_cond_timedwait: The pthread API call used \u2014 inspect its prototype and any macros/wrappers around it for compiler-specific attributes or extensions.\n\n- pthread_cond_t: The condition variable type used inside OS_impl_objtype_lock_t \u2014 inspect its definition in the pthread headers for any use of language extensions (implementation-specific internals or attributes).\n\n- pthread_mutex_t: The mutex type used inside OS_impl_objtype_lock_t \u2014 inspect its definition as above for extensions.\n\n- false: The boolean constant used in pthread_cleanup_pop(false) \u2014 verify its definition (from <stdbool.h> or other headers) to ensure it is standard (macro/keyword) and not a compiler-specific extension.\n\nIn short: examine the macro expansions and type/function declarations from the pthread and system headers and any OS-specific headers that define the OS_* symbols. The primary candidates for hidden language extensions are the pthread_cleanup_push/pop macros and any attributes or nonstandard syntax used in the OS_* type/function definitions; the other listed symbols are needed to reach and inspect those definitions."
}