{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nUT_BSP_DoText calls strlen(OutputMessage) with no check that OutputMessage is non-NULL or that it points to a NUL-terminated character array. If a caller passes a buffer that is not NUL-terminated (for example: char buf[10]; memcpy(buf, src, 10); UT_BSP_DoText(..., buf);) or passes a NULL pointer, strlen will read past the bounds of the object (or dereference NULL), thereby violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER UT_DoSetHookFunction: Value.Addr=0x5620d6b5d62c UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x5620d6b78e80\nSetting entry: StubPtr=0x5620d6b78e80 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x5620d6b5d62c IsVarg=0\nSet complete: StubPtr=0x5620d6b78e80 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x5620d6b78e80\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3e2af UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f5aa00\nSetting entry: StubPtr=0x55a610f5aa00 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3e2af IsVarg=0\nSet complete: StubPtr=0x55a610f5aa00 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f5aa00\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3cf13 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f5ae80\nSetting entry: StubPtr=0x55a610f5ae80 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3cf13 IsVarg=0\nSet complete: StubPtr=0x55a610f5ae80 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f5ae80\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3af41 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f58a80\nSetting entry: StubPtr=0x55a610f58a80 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3af41 IsVarg=0\nSet complete: StubPtr=0x55a610f58a80 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f58a80\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3d136 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f65080\nSetting entry: StubPtr=0x55a610f65080 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3d136 IsVarg=0\nSet complete: StubPtr=0x55a610f65080 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f65080\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3d351 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f61960\nSetting entry: StubPtr=0x55a610f61960 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3d351 IsVarg=0\nSet complete: StubPtr=0x55a610f61960 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f61960\nENTER UT_DoSetHookFunction: Value.Addr=0x55a610f3d003 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55a610f663a0\nSetting entry: StubPtr=0x55a610f663a0 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55a610f3d003 IsVarg=0\nSet complete: StubPtr=0x55a610f663a0 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55a610f663a0\nENTER UT_DoSetHookFunction: Value.Addr=0x55c61c0c9553 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55c61c0e5fe0\nSetting entry: StubPtr=0x55c61c0e5fe0 FuncKey=? EntryType=? UserObj=(nil) Value.Addr=0x55c61c0c9553 IsVarg=0\nSet complete: StubPtr=0x55c61c0e5fe0 (FuncKey/EntryType assigned)\nEXIT UT_DoSetHookFunction: StubPtr=0x55c61c0e5fe0\nENTER UT_DoSetHookFunction: Value.Addr=0x55d892216b6a UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and Value.Addr != NULL, searching for unused slot\nAfter second UT_GetStubEntry (UNUSED): StubPtr=0x55d89223c940\nS\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\n#define UT_MAX_FUNC_STUBS 200\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the cited function. UT_DoSetHookFunction does not call any <string.h> functions (no memcpy/strlen/strcpy/etc.) so it cannot directly violate MISRA C 2023 Rule 21.17.\n\nHowever, the scenario that agent A describes does point out a real potential 21.17 issue in UT_BSP_DoText: it calls strlen(OutputMessage) and later indexes OutputMessage[MsgLen - 1] without checking that OutputMessage is non-NULL or that it points to a NUL-terminated array. If a caller passes NULL or a non-NUL-terminated buffer (e.g. a raw 10-byte buffer filled with memcpy), strlen can read past the object bounds (or dereference NULL), which would violate Rule 21.17. Note: the use of strlen(Buffer) is safe because Buffer is produced with snprintf and is guaranteed NUL-terminated when sizeof(Buffer)>0.\n\nRecommendation: either ensure callers always pass valid NUL-terminated, non-NULL strings (and document the precondition), or make UT_BSP_DoText defensive: check OutputMessage != NULL and use a bounded-length scan (or strnlen-equivalent / explicit loop with a known maximum) to avoid reading beyond the buffer and to satisfy MISRA requirements."
}