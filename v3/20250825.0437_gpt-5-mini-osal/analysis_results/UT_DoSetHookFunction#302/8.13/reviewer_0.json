{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code tests Value.Addr (a union member declared as void * in UT_HookFuncPtr_t) against NULL and stores the union in the stub table without ever modifying the pointed-to object. Because the pointer is only observed/stored and not used to modify the pointee, the pointee type could and should be const-qualified (e.g. const void *Addr). Therefore the use of a non-const pointer (Value.Addr) violates MISRA C 2023 Rule 8.13. To fix, change the union member to point to a const-qualified type (for example: const void *Addr) or otherwise ensure the pointer actually needs to be non-const.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function UT_DoSetHookFunction:\ntypedef cpuaddr UT_EntryKey_t\n...\ntypedef enum\n{\n    UT_ENTRYTYPE_UNUSED,                 /**< Unused/available table entries */\n    UT_ENTRYTYPE_COUNTER,                /**< Records a usage count plus most recent return code */\n    UT_ENTRYTYPE_DATA_BUFFER,            /**< Storage for data buffers to simulate read/write or queue ops */\n    UT_ENTRYTYPE_CALLBACK_HOOK,          /**< A custom callback/hook function to be invoked prior to handler */\n    UT_ENTRYTYPE_CALLBACK_CONTEXT,       /**< Context data for callback/hook function */\n    UT_ENTRYTYPE_CALL_ONCE,              /**< Records a \"call once\" directive */\n    UT_ENTRYTYPE_FINAL_HANDLER,          /**< The final handler for the stub */\n    UT_ENTRYTYPE_RETURN_BUFFER,          /**< Storage for actual return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED, /**< Configuration for return value from stub */\n    UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT, /**< Configuration for return value from stub */\n} UT_EntryType_t\n...\ntypedef union\n{\n    void *             Addr;\n    UT_HookFunc_t      SimpleHook;\n    UT_VaHookFunc_t    VaHook;\n    UT_HandlerFunc_t   SimpleHandler;\n    UT_VaHandlerFunc_t VaHandler;\n} UT_HookFuncPtr_t\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the provided evidence. Rule 8.13 encourages declaring pointers to point to const-qualified types when possible, but you cannot conclude a violation from this single function alone. UT_HookFuncPtr_t is a union that contains multiple pointer types (including function-pointer types), and Value is used here as an opaque handle: the code only tests Value.Addr for NULL and stores the union into the stub table; it does not dereference or modify the pointee. Changing the union member to const void * may break other uses (assignments from non-const pointers or interaction with the function-pointer members), and function pointers are a different category where const qualification does not apply the same way. To determine a true MISRA 8.13 violation you must examine all uses of UT_HookFuncPtr_t/Addr across the codebase \u2014 if any code writes through Addr (dereferences to modify the pointee) or relies on a non-const type, then the current declaration is necessary; if no such uses exist, making it const could be an improvement but is a global design change, not an automatic violation in UT_DoSetHookFunction. Therefore the report (that this function violates MISRA C 2023 Rule 8.13) is not correct based on the shown code and types."
}