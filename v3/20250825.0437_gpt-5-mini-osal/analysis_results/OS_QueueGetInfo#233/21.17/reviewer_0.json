{
  "user_message": "An agent A claimed that the following OS_QueueGetInfo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGetInfo.\n```c\nint32 OS_QueueGetInfo(osal_id_t queue_id, OS_queue_prop_t *queue_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(queue_prop);\n\n    memset(queue_prop, 0, sizeof(OS_queue_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_queue_table, token);\n\n        strncpy(queue_prop->name, record->name_entry, sizeof(queue_prop->name) - 1);\n        queue_prop->creator = record->creator;\n\n        /*\n         * Currently there are no additional queue details provided by the impl layer -\n         * But this could be added in the future (i.e. current/max depth, msg size, etc)\n         */\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strncpy(queue_prop->name, record->name_entry, sizeof(queue_prop->name) - 1) may read up to sizeof(queue_prop->name)-1 bytes from record->name_entry. If record->name_entry is not guaranteed to be at least that long or to contain a NUL within its own bounds (for example, record->name_entry is a smaller buffer or not NUL-terminated), strncpy can read beyond the source buffer and thus access out-of-bounds memory. Although the destination is pre-zeroed and the chosen length prevents writing past the destination, the source-read case is not guaranteed safe from the shown code, so the rule is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_QueueGetInfo ENTER: queue_id=0xdeadbeef, queue_prop=0x7ffeb9b5ed70\nmemset done: queue_prop=0x7ffeb9b5ed70, sizeof(OS_queue_prop_t)=24, name_size=20\nOS_ObjectIdGetById returned -35\nOS_QueueGetInfo EXIT: return_code=-35\nOS_QueueGetInfo ENTER: queue_id=0x0, queue_prop=0x7ffeb9b5ed70\nmemset done: queue_prop=0x7ffeb9b5ed70, sizeof(OS_queue_prop_t)=24, name_size=20\nOS_ObjectIdGetById returned -35\nOS_QueueGetInfo EXIT: return_code=-35\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's concern describes a real potential hazard: strncpy(dest, src, n) may read up to n bytes from src and therefore can access beyond src's object if src is smaller than n and not NUL-terminated. MISRA C:2023 Rule 21.17 forbids such out-of-bounds reads by the <string.h> functions. However, whether a rule violation actually occurs depends on the definition/guarantees of record->name_entry, which is not shown in the snippet. If record->name_entry is an array at least sizeof(queue_prop->name)-1 bytes long (or otherwise guaranteed to contain a NUL within that range), then the strncpy call is safe and there is no Rule 21.17 violation. If no such size/termination guarantee exists, then the call can indeed read out of bounds and would violate the rule.\n\nGiven only the provided code and execution log (which shows destination size but does not show the type/size/termination guarantee of record->name_entry), the report cannot be confirmed. The agent's scenario is a valid potential violation, but the evidence is incomplete: you need to inspect the definition and invariants of OS_common_record_t/name_entry to decide definitively. Recommended fixes if you want to be defensive: (a) ensure record->name_entry is a fixed-size NUL-terminated array at least as large as the destination, or (b) copy using a size computed from strnlen(src, sizeof(dest)-1) and memcpy, or (c) document and assert the size/termination invariant."
}