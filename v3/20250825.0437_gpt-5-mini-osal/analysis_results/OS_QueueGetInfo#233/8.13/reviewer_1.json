{
  "user_message": "An agent A claimed that the following OS_QueueGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGetInfo.\n```c\nint32 OS_QueueGetInfo(osal_id_t queue_id, OS_queue_prop_t *queue_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(queue_prop);\n\n    memset(queue_prop, 0, sizeof(OS_queue_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_queue_table, token);\n\n        strncpy(queue_prop->name, record->name_entry, sizeof(queue_prop->name) - 1);\n        queue_prop->creator = record->creator;\n\n        /*\n         * Currently there are no additional queue details provided by the impl layer -\n         * But this could be added in the future (i.e. current/max depth, msg size, etc)\n         */\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes record->name_entry as the source to strncpy. If record->name_entry is declared without const (for example: char name_entry[...] or char *name_entry), then the pointer is not const-qualified even though it is not modified and should be. That situation violates MISRA C 2023 Rule 8.13. Fix: declare the source as const (e.g. const char name_entry[] or const char *name_entry) so the pointer points to a const-qualified type.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nStage: ENTER | queue_id: 3735928559 | note: entry into OS_QueueGetInfo\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): 'YYYYYYYYh\u0007\u000b]U'\n\nStage: AFTER_MEMSET | queue_id: 3735928559 | note: after memset of queue_prop\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: OBJECT_NOT_FOUND | queue_id: 3735928559 | note: ObjectIdGetById failed\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: EXIT | queue_id: 3735928559 | note: exiting failure\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: ENTER | queue_id: 0 | note: entry into OS_QueueGetInfo\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: AFTER_MEMSET | queue_id: 0 | note: after memset of queue_prop\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: OBJECT_NOT_FOUND | queue_id: 0 | note: ObjectIdGetById failed\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\nStage: EXIT | queue_id: 0 | note: exiting failure\n  queue_prop ptr: 0x7ffc6fe09490\n  queue_prop->name (sample): ''\n\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The snippet shown does not by itself demonstrate a MISRA C:2023 Rule 8.13 violation. Rule 8.13 concerns how pointer types are declared (they should point to const-qualified types when possible). Agent A\u2019s scenario assumes that record->name_entry is declared without const and never modified elsewhere, in which case the declaration (not this call site) would be the thing that could violate the rule. However: 1) strncpy\u2019s prototype takes a const char * for the source, so passing a non-const char[]/char * expression is permitted (it converts to const char *). That conversion does not by itself constitute the MISRA violation. 2) The code shown does not include the declaration of OS_common_record_t::name_entry, nor evidence that it is in fact immutable and therefore \u201cshould\u201d be const. Without inspecting the declaration and all uses of name_entry, you cannot conclude there is a definite Rule 8.13 breach. Recommendation: inspect the definition of OS_common_record_t and all writes to name_entry. If name_entry is not modified anywhere, change its declaration to point to/contain const-qualified characters (e.g. const char name_entry[] or const char *). If it is modified, the non-const declaration is justified and there is no violation at this call site."
}