{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE *log = fopen(\"/tmp/logs/1609.txt\", \"a\");\n\n    /* Minimal entry log with pointer value only (do not dereference here) */\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck ENTER: Filename=%p\\n\", (void *)Filename);\n        fflush(log);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log iterator and stream-level metadata without dereferencing string buffers */\n        if (log)\n        {\n            fprintf(log,\n                    \"iter.token=%u stream_ptr=%p socket_domain=%d stream_name_ptr=%p\\n\",\n                    (unsigned)iter.token,\n                    (void *)stream,\n                    (int)stream->socket_domain,\n                    (void *)stream->stream_name);\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log that strcmp was invoked and that it returned a match */\n            if (log)\n            {\n                fprintf(log,\n                        \"strcmp INVOKED: stream->stream_name=%p Filename=%p -> MATCH (token=%u)\\n\",\n                        (void *)stream->stream_name,\n                        (void *)Filename,\n                        (unsigned)iter.token);\n                fflush(log);\n            }\n\n            return_code = OS_SUCCESS;\n            break;\n        }\n        else\n        {\n            /* If the socket_domain was invalid we already attempted (or would attempt) strcmp above.\n             * Log the non-match case when socket_domain was invalid, or that the socket_domain was valid.\n             */\n            if (log)\n            {\n                if (stream->socket_domain == OS_SocketDomain_INVALID)\n                {\n                    fprintf(log,\n                            \"strcmp INVOKED: stream->stream_name=%p Filename=%p -> NO MATCH (token=%u)\\n\",\n                            (void *)stream->stream_name,\n                            (void *)Filename,\n                            (unsigned)iter.token);\n                }\n                else\n                {\n                    fprintf(log, \"socket_domain != INVALID for token=%u; strcmp NOT invoked\\n\", (unsigned)iter.token);\n                }\n                fflush(log);\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck EXIT: return_code=%d\\n\", return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp30tl4nr0/src/src/os/shared/src/osapi-file.c: In function 'OS_FileOpenCheck':\n/tmp/tmp30tl4nr0/src/src/os/shared/src/osapi-file.c:554:21: error: aggregate value used where an integer was expected\n  554 |                     (unsigned)iter.token,\n      |                     ^\n/tmp/tmp30tl4nr0/src/src/os/shared/src/osapi-file.c:570:25: error: aggregate value used where an integer was expected\n  570 |                         (unsigned)iter.token);\n      |                         ^\n/tmp/tmp30tl4nr0/src/src/os/shared/src/osapi-file.c:590:29: error: aggregate value used where an integer was expected\n  590 |                             (unsigned)iter.token);\n      |                             ^\n/tmp/tmp30tl4nr0/src/src/os/shared/src/osapi-file.c:594:21: error: aggregate value used where an integer was expected\n  594 |                     fprintf(log, \"socket_domain != INVALID for token=%u; strcmp NOT invoked\\n\", (unsigned)iter.token);\n      |                     ^~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_FileOpenCheck as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "int32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE *log = fopen(\"/tmp/logs/1609.txt\", \"a\");\n\n    /* Minimal entry log with pointer value only (do not dereference here) */\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck ENTER: Filename=%p\\n\", (void *)Filename);\n        fflush(log);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log iterator and stream-level metadata without dereferencing string buffers */\n        if (log)\n        {\n            fprintf(log,\n                    \"iter.token=%p stream_ptr=%p socket_domain=%d stream_name_ptr=%p\\n\",\n                    (void *)&iter.token,\n                    (void *)stream,\n                    (int)stream->socket_domain,\n                    (void *)stream->stream_name);\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log that strcmp was invoked and that it returned a match */\n            if (log)\n            {\n                fprintf(log,\n                        \"strcmp INVOKED: stream->stream_name=%p Filename=%p -> MATCH (token=%p)\\n\",\n                        (void *)stream->stream_name,\n                        (void *)Filename,\n                        (void *)&iter.token);\n                fflush(log);\n            }\n\n            return_code = OS_SUCCESS;\n            break;\n        }\n        else\n        {\n            /* If the socket_domain was invalid we already attempted (or would attempt) strcmp above.\n             * Log the non-match case when socket_domain was invalid, or that the socket_domain was valid.\n             */\n            if (log)\n            {\n                if (stream->socket_domain == OS_SocketDomain_INVALID)\n                {\n                    fprintf(log,\n                            \"strcmp INVOKED: stream->stream_name=%p Filename=%p -> NO MATCH (token=%p)\\n\",\n                            (void *)stream->stream_name,\n                            (void *)Filename,\n                            (void *)&iter.token);\n                }\n                else\n                {\n                    fprintf(log, \"socket_domain != INVALID for token=%p; strcmp NOT invoked\\n\", (void *)&iter.token);\n                }\n                fflush(log);\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck EXIT: return_code=%d\\n\", return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n",
  "explanation": "The compile errors occurred because iter.token is an aggregate type (not an integer), so casting it to (unsigned) and printing with %u was invalid. I changed the token logging to use the pointer format (%p) and passed the address of iter.token cast to (void *). This avoids treating an aggregate as an integer while preserving the original logging and function logic."
}