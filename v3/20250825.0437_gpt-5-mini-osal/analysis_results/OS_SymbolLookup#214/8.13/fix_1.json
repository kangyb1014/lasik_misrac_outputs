{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_Probe_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2143.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging can't be opened, silently fail to avoid changing program flow */\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\nstatic OS_static_symbol_record_t static_table[] =\n{\n    { \"Start\", \"boot\", 0x1000 },\n    { \"Init\",  \"init\", 0x2000 },\n    { \"Main\",  \"app\",  0x3000 },\n    { NULL,    NULL,    0 }\n};\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, void *unused)\n{\n    (void)unused;\n\n    if (SymbolAddress == NULL || SymbolName == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup_Static: invalid parameter (SymbolAddress=%p, SymbolName=%p)\", (void *)SymbolAddress, (void *)SymbolName);\n        return OS_INVALID_POINTER;\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup_Static: enter. Looking for '%s'\", SymbolName);\n\n    /* Violation scenario reproduction: local pointer declared non-const but only used for reads */\n    OS_static_symbol_record_t *StaticSym = static_table; /* non-const pointer to const-qualified members */\n\n    for (; StaticSym != NULL && StaticSym->Name != NULL; ++StaticSym)\n    {\n        /* Log the state: pointer value and the read-only members being accessed */\n        OS_Probe_Log(\"  Inspecting record at %p: Name='%s', Module='%s', Address=0x%zx\",\n                     (void *)StaticSym,\n                     StaticSym->Name ? StaticSym->Name : \"(null)\",\n                     StaticSym->Module ? StaticSym->Module : \"(null)\",\n                     (size_t)StaticSym->Address);\n\n        if (strcmp(StaticSym->Name, SymbolName) == 0)\n        {\n            *SymbolAddress = StaticSym->Address;\n            OS_Probe_Log(\"  Match found. Setting SymbolAddress=%p to 0x%zx\", (void *)SymbolAddress, (size_t)*SymbolAddress);\n            OS_Probe_Log(\"OS_SymbolLookup_Static: exit -> OS_SUCCESS\");\n            return OS_SUCCESS;\n        }\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup_Static: exit -> NOT FOUND\");\n    return OS_ERROR;\n}\nint32 OS_SymbolLookup(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32 return_code;\n    int32 staticsym_status;\n\n    /*\n    ** Check parameters (expanded inline instead of using OS_CHECK_POINTER macro)\n    */\n    if (SymbolAddress == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: NULL SymbolAddress parameter\");\n        return OS_INVALID_POINTER;\n    }\n    if (SymbolName == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: NULL SymbolName parameter\");\n        return OS_INVALID_POINTER;\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup: enter. SymbolName='%s', SymbolAddress=%p\", SymbolName, (void *)SymbolAddress);\n\n    /*\n     * attempt to find the symbol in the symbol table\n     */\n    return_code = OS_SymbolLookup_Impl(SymbolAddress, SymbolName);\n    OS_Probe_Log(\"OS_SymbolLookup: OS_SymbolLookup_Impl returned %d\", (int)return_code);\n\n    /*\n     * If the OS call did not find the symbol or the loader is\n     * disabled, then check if a static symbol table is present\n     */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: falling back to static lookup\");\n\n        staticsym_status = OS_SymbolLookup_Static(SymbolAddress, SymbolName, NULL);\n\n        OS_Probe_Log(\"OS_SymbolLookup: OS_SymbolLookup_Static returned %d\", (int)staticsym_status);\n\n        /*\n         * Only overwrite the return code if static lookup was successful.\n         * Otherwise keep the error code from the low level implementation.\n         */\n        if (staticsym_status == OS_SUCCESS)\n        {\n            OS_Probe_Log(\"OS_SymbolLookup: static lookup succeeded. Overwriting return_code=%d -> %d\", (int)return_code, (int)staticsym_status);\n            return_code = staticsym_status;\n        }\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup: exit with return_code=%d, SymbolAddress points to 0x%zx\", (int)return_code, (size_t)*SymbolAddress);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmphfyn_als/src/src/os/shared/src/osapi-module.c:124:7: error: conflicting types for 'OS_SymbolLookup_Static'; have 'int32(cpuaddr *, const char *, void *)' {aka 'int(long unsigned int *, const char *, void *)'}\n  124 | int32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, void *unused)\n      |       ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmphfyn_als/src/src/os/shared/src/osapi-module.c:47:\n/tmp/tmphfyn_als/src/src/os/shared/inc/os-shared-module.h:123:7: note: previous declaration of 'OS_SymbolLookup_Static' with type 'int32(cpuaddr *, const char *, const char *)' {aka 'int(long unsigned int *, const char *, const char *)'}\n  123 | int32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName);\n      |       ^~~~~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:230: CMakeFiles/osal.dir/src/os/shared/src/osapi-module.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_SymbolLookup as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void OS_Probe_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2143.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging can't be opened, silently fail to avoid changing program flow */\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\nstatic OS_static_symbol_record_t static_table[] =\n{\n    { \"Start\", \"boot\", 0x1000 },\n    { \"Init\",  \"init\", 0x2000 },\n    { \"Main\",  \"app\",  0x3000 },\n    { NULL,    NULL,    0 }\n};\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    (void)ModuleName;\n\n    if (SymbolAddress == NULL || SymbolName == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup_Static: invalid parameter (SymbolAddress=%p, SymbolName=%p)\", (void *)SymbolAddress, (void *)SymbolName);\n        return OS_INVALID_POINTER;\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup_Static: enter. Looking for '%s'\", SymbolName);\n\n    /* Violation scenario reproduction: local pointer declared non-const but only used for reads */\n    OS_static_symbol_record_t *StaticSym = static_table; /* non-const pointer to const-qualified members */\n\n    for (; StaticSym != NULL && StaticSym->Name != NULL; ++StaticSym)\n    {\n        /* Log the state: pointer value and the read-only members being accessed */\n        OS_Probe_Log(\"  Inspecting record at %p: Name='%s', Module='%s', Address=0x%zx\",\n                     (void *)StaticSym,\n                     StaticSym->Name ? StaticSym->Name : \"(null)\",\n                     StaticSym->Module ? StaticSym->Module : \"(null)\",\n                     (size_t)StaticSym->Address);\n\n        if (strcmp(StaticSym->Name, SymbolName) == 0)\n        {\n            *SymbolAddress = StaticSym->Address;\n            OS_Probe_Log(\"  Match found. Setting SymbolAddress=%p to 0x%zx\", (void *)SymbolAddress, (size_t)*SymbolAddress);\n            OS_Probe_Log(\"OS_SymbolLookup_Static: exit -> OS_SUCCESS\");\n            return OS_SUCCESS;\n        }\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup_Static: exit -> NOT FOUND\");\n    return OS_ERROR;\n}\nint32 OS_SymbolLookup(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32 return_code;\n    int32 staticsym_status;\n\n    /*\n    ** Check parameters (expanded inline instead of using OS_CHECK_POINTER macro)\n    */\n    if (SymbolAddress == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: NULL SymbolAddress parameter\");\n        return OS_INVALID_POINTER;\n    }\n    if (SymbolName == NULL)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: NULL SymbolName parameter\");\n        return OS_INVALID_POINTER;\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup: enter. SymbolName='%s', SymbolAddress=%p\", SymbolName, (void *)SymbolAddress);\n\n    /*\n     * attempt to find the symbol in the symbol table\n     */\n    return_code = OS_SymbolLookup_Impl(SymbolAddress, SymbolName);\n    OS_Probe_Log(\"OS_SymbolLookup: OS_SymbolLookup_Impl returned %d\", (int)return_code);\n\n    /*\n     * If the OS call did not find the symbol or the loader is\n     * disabled, then check if a static symbol table is present\n     */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_Probe_Log(\"OS_SymbolLookup: falling back to static lookup\");\n\n        staticsym_status = OS_SymbolLookup_Static(SymbolAddress, SymbolName, NULL);\n\n        OS_Probe_Log(\"OS_SymbolLookup: OS_SymbolLookup_Static returned %d\", (int)staticsym_status);\n\n        /*\n         * Only overwrite the return code if static lookup was successful.\n         * Otherwise keep the error code from the low level implementation.\n         */\n        if (staticsym_status == OS_SUCCESS)\n        {\n            OS_Probe_Log(\"OS_SymbolLookup: static lookup succeeded. Overwriting return_code=%d -> %d\", (int)return_code, (int)staticsym_status);\n            return_code = staticsym_status;\n        }\n    }\n\n    OS_Probe_Log(\"OS_SymbolLookup: exit with return_code=%d, SymbolAddress points to 0x%zx\", (int)return_code, (size_t)*SymbolAddress);\n    return return_code;\n}\n",
  "explanation": "The header declared OS_SymbolLookup_Static with the third parameter as const char *ModuleName, but the implementation used void *unused, causing a conflicting declaration. I changed the function signature to match the header (const char *ModuleName) and used (void)ModuleName to avoid an unused-parameter warning. No other logic was modified."
}