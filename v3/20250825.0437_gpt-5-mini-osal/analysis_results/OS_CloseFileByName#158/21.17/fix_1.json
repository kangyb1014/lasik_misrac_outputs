{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE                       *log = NULL;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    /* Open log file for append; best-effort only (do not alter return semantics on failure) */\n    log = fopen(\"/tmp/logs/1589.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"\\n--- OS_CloseFileByName called ---\\n\");\n        fprintf(log, \"Filename ptr=%p\\n\", (const void *)Filename);\n        fflush(log);\n    }\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Probe: gather safe information about stream->stream_name without reading past its object bounds */\n        if (log)\n        {\n            /* Determine the size of the stream_name member (this relies on the visible definition of the struct)\n               and use memchr with that size to detect if a NUL exists within the buffer. This avoids scanning\n               beyond the array bounds. We DO NOT attempt to inspect the memory pointed to by Filename here\n               because its bounds are not known. */\n            size_t name_buf_size = sizeof(stream->stream_name);\n            void *nulpos = memchr(stream->stream_name, '\\0', name_buf_size);\n            size_t name_len = (nulpos != NULL) ? ((const char *)nulpos - (const char *)stream->stream_name) : name_buf_size;\n\n            fprintf(log, \"iter.token=%u, stream_ptr=%p, socket_domain=%d\\n\", (unsigned)iter.token, (void *)stream, (int)stream->socket_domain);\n            fprintf(log, \"stream_name buffer addr=%p, buffer_size=%zu, has_nul_within_size=%s, visible_len=%zu\\n\",\n                    (void *)&stream->stream_name[0], name_buf_size, (nulpos ? \"YES\" : \"NO\"), name_len);\n\n            /* Print the stream_name up to the discovered safe length. This will not read beyond the object bounds. */\n            fprintf(log, \"stream_name (up to safe length): '%.*s'\\n\", (int)name_len, stream->stream_name);\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log the match decision. It is important to record that strcmp was invoked and its result led to\n               the close operation. This preserves the original control flow while providing evidence of when\n               and where strcmp returned equality. */\n            if (log)\n            {\n                fprintf(log, \"strcmp returned EQUAL for stream_ptr=%p and Filename ptr=%p --> invoking close on token %u\\n\",\n                        (void *)stream, (const void *)Filename, (unsigned)iter.token);\n                fflush(log);\n            }\n\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n        else\n        {\n            if (log)\n            {\n                /* If the condition didn't match, record that too. We don't call strcmp again; the above call\n                   is the only strcmp in the original logic. */\n                fprintf(log, \"No match for token %u (either socket_domain!=INVALID or strcmp!=0)\\n\", (unsigned)iter.token);\n                fflush(log);\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_CloseFileByName returning code=%d\\n\", (int)return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpbtwwtc3z/src/src/os/shared/src/osapi-file.c: In function 'OS_CloseFileByName':\n/tmp/tmpbtwwtc3z/src/src/os/shared/src/osapi-file.c:595:13: error: aggregate value used where an integer was expected\n  595 |             fprintf(log, \"iter.token=%u, stream_ptr=%p, socket_domain=%d\\n\", (unsigned)iter.token, (void *)stream, (int)stream->socket_domain);\n      |             ^~~~~~~\n/tmp/tmpbtwwtc3z/src/src/os/shared/src/osapi-file.c:612:25: error: aggregate value used where an integer was expected\n  612 |                         (void *)stream, (const void *)Filename, (unsigned)iter.token);\n      |                         ^\n/tmp/tmpbtwwtc3z/src/src/os/shared/src/osapi-file.c:630:17: error: aggregate value used where an integer was expected\n  630 |                 fprintf(log, \"No match for token %u (either socket_domain!=INVALID or strcmp!=0)\\n\", (unsigned)iter.token);\n      |                 ^~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "int32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE                       *log = NULL;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    /* Open log file for append; best-effort only (do not alter return semantics on failure) */\n    log = fopen(\"/tmp/logs/1589.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"\\n--- OS_CloseFileByName called ---\\n\");\n        fprintf(log, \"Filename ptr=%p\\n\", (const void *)Filename);\n        fflush(log);\n    }\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Probe: gather safe information about stream->stream_name without reading past its object bounds */\n        if (log)\n        {\n            /* Determine the size of the stream_name member (this relies on the visible definition of the struct)\n               and use memchr with that size to detect if a NUL exists within the buffer. This avoids scanning\n               beyond the array bounds. We DO NOT attempt to inspect the memory pointed to by Filename here\n               because its bounds are not known. */\n            size_t name_buf_size = sizeof(stream->stream_name);\n            void *nulpos = memchr(stream->stream_name, '\\0', name_buf_size);\n            size_t name_len = (nulpos != NULL) ? ((const char *)nulpos - (const char *)stream->stream_name) : name_buf_size;\n\n            /* iter.token is an aggregate type; printing it as an integer caused the compile error. It is only\n               used here for logging purposes, so print its address instead to avoid treating an aggregate as an int. */\n            fprintf(log, \"iter.token_ptr=%p, stream_ptr=%p, socket_domain=%d\\n\", (void *)&iter.token, (void *)stream, (int)stream->socket_domain);\n            fprintf(log, \"stream_name buffer addr=%p, buffer_size=%zu, has_nul_within_size=%s, visible_len=%zu\\n\",\n                    (void *)&stream->stream_name[0], name_buf_size, (nulpos ? \"YES\" : \"NO\"), name_len);\n\n            /* Print the stream_name up to the discovered safe length. This will not read beyond the object bounds. */\n            fprintf(log, \"stream_name (up to safe length): '%.*s'\\n\", (int)name_len, stream->stream_name);\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log the match decision. It is important to record that strcmp was invoked and its result led to\n               the close operation. This preserves the original control flow while providing evidence of when\n               and where strcmp returned equality. */\n            if (log)\n            {\n                fprintf(log, \"strcmp returned EQUAL for stream_ptr=%p and Filename ptr=%p --> invoking close on token %p\\n\",\n                        (void *)stream, (const void *)Filename, (void *)&iter.token);\n                fflush(log);\n            }\n\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n        else\n        {\n            if (log)\n            {\n                /* If the condition didn't match, record that too. We don't call strcmp again; the above call\n                   is the only strcmp in the original logic. */\n                fprintf(log, \"No match for token %p (either socket_domain!=INVALID or strcmp!=0)\\n\", (void *)&iter.token);\n                fflush(log);\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_CloseFileByName returning code=%d\\n\", (int)return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n",
  "explanation": "The compile errors were caused by treating iter.token (an aggregate type) as an integer when printing with \"%u\" and casting to (unsigned). To fix this without changing the function logic, I changed the debug prints to print the token's address (as a pointer) using \"%p\" and (void *)&iter.token. This avoids using an aggregate as an integer and keeps the original control flow and behavior unchanged (the token was only used for logging). No other logic was modified."
}