{
  "user_message": "An agent A claimed that the following OS_GenericWrite_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_GenericWrite_Impl.\n```c\nint32 OS_GenericWrite_Impl(const OS_object_token_t *token, const void *buffer, size_t nbytes, int32 timeout)\n{\n    int32                           return_code;\n    ssize_t                         os_result;\n    uint32                          operation;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    return_code = OS_SUCCESS;\n\n    if (nbytes > 0)\n    {\n        operation = OS_STREAM_STATE_WRITABLE;\n\n        /*\n         * If filehandle is set with O_NONBLOCK, then must call select() here.\n         *\n         * The \"selectable\" field should be set false for those file handles\n         * which the underlying OS does not support select() on.\n         *\n         * Note that a timeout will not work unless selectable is true.\n         */\n        if (impl->selectable)\n        {\n            return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n        }\n\n        if (return_code == OS_SUCCESS && (operation & OS_STREAM_STATE_WRITABLE) != 0)\n        {\n            /* on some system libraries for which the write() argument is not\n             * qualified correctly, it needs to be case to a void* here */\n            os_result = write(impl->fd, GENERIC_IO_CONST_DATA_CAST buffer, nbytes);\n            if (os_result < 0)\n            {\n                OS_DEBUG(\"write: %s\\n\", strerror(errno));\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                /* type conversion from ssize_t to int32 for return */\n                return_code = (int32)os_result;\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable impl is declared as a non-const pointer (OS_impl_file_internal_record_t *impl) but in this function it is only used for read-only accesses (impl->selectable, impl->fd). According to MISRA C 2023 Rule 8.13, the pointer should instead be declared to point to a const-qualified type (const OS_impl_file_internal_record_t *impl) whenever possible. Therefore the assignment impl = OS_OBJECT_TABLE_GET(...); and the non-const declaration constitute a violation unless the function later modifies the object through impl (which it does not in the shown code).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_GenericWrite_Impl:\n#define GENERIC_IO_CONST_DATA_CAST \n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In this function the local pointer impl is only used for read-only accesses (impl->selectable and impl->fd) and the pointer could therefore be declared to point to a const-qualified type (for example: const OS_impl_file_internal_record_t *impl). That is exactly what MISRA C 2023 Rule 8.13 intends: prefer pointers to const-qualified types when mutation is not required. Changing the declaration to a pointer-to-const is compatible with typical macro returns from OS_OBJECT_TABLE_GET (assigning a non-const pointer to a pointer-to-const is allowed). The only reason not to make the change would be if some later or hidden code (not shown) requires modifying the object through impl; no such modification appears in the shown function. Therefore the reported violation is correct."
}