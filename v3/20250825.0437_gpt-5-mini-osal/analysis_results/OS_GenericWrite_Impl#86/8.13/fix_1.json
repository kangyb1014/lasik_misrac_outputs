{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_GenericWrite_Impl_log(const char *stage, const OS_object_token_t *token, OS_impl_file_internal_record_t *impl, size_t nbytes, int32 timeout, uint32 operation, int32 return_code, ssize_t os_result)\n{\n    char buf[512];\n    int len = 0;\n\n    /* Compose a concise log message with relevant state. Protect accesses if impl is NULL. */\n    if (impl != NULL)\n    {\n        len = snprintf(buf, sizeof(buf),\n                       \"%s: token=%llu token_ptr=%p nbytes=%zu timeout=%d impl=%p selectable=%d fd=%d operation=0x%08x return_code=%d os_result=%zd errno=%d\\n\",\n                       stage,\n                       (unsigned long long)(*token), (const void *)token,\n                       nbytes, timeout,\n                       (const void *)impl,\n                       (int)impl->selectable, (int)impl->fd,\n                       (unsigned int)operation,\n                       return_code, os_result, errno);\n    }\n    else\n    {\n        len = snprintf(buf, sizeof(buf),\n                       \"%s: token=%llu token_ptr=%p nbytes=%zu timeout=%d impl=NULL operation=0x%08x return_code=%d os_result=%zd errno=%d\\n\",\n                       stage,\n                       (unsigned long long)(*token), (const void *)token,\n                       nbytes, timeout,\n                       (unsigned int)operation,\n                       return_code, os_result, errno);\n    }\n\n    if (len > 0)\n    {\n        int fd = open(\"/tmp/logs/863.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n        if (fd >= 0)\n        {\n            /* write may not write all bytes in one call, but this simple probe is sufficient for diagnostics */\n            (void)write(fd, buf, (size_t)len);\n            (void)close(fd);\n        }\n    }\n}\n\nint32 OS_GenericWrite_Impl(const OS_object_token_t *token, const void *buffer, size_t nbytes, int32 timeout)\n{\n    int32                           return_code;\n    ssize_t                         os_result;\n    uint32                          operation;\n    OS_impl_file_internal_record_t *impl;\n\n    OS_GenericWrite_Impl_log(\"entry\", token, NULL, nbytes, timeout, 0u, 0, 0);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    OS_GenericWrite_Impl_log(\"after_lookup\", token, impl, nbytes, timeout, 0u, 0, 0);\n\n    return_code = OS_SUCCESS;\n\n    if (nbytes > 0)\n    {\n        operation = OS_STREAM_STATE_WRITABLE;\n\n        /*\n         * If filehandle is set with O_NONBLOCK, then must call select() here.\n         *\n         * The \"selectable\" field should be set false for those file handles\n         * which the underlying OS does not support select() on.\n         *\n         * Note that a timeout will not work unless selectable is true.\n         */\n        if (impl != NULL && impl->selectable)\n        {\n            OS_GenericWrite_Impl_log(\"before_select\", token, impl, nbytes, timeout, operation, return_code, 0);\n            return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n            OS_GenericWrite_Impl_log(\"after_select\", token, impl, nbytes, timeout, operation, return_code, 0);\n        }\n\n        if (return_code == OS_SUCCESS && (operation & OS_STREAM_STATE_WRITABLE) != 0)\n        {\n            /* on some system libraries for which the write() argument is not\n             * qualified correctly, it needs to be case to a void* here */\n            OS_GenericWrite_Impl_log(\"before_write\", token, impl, nbytes, timeout, operation, return_code, 0);\n            os_result = write(impl->fd, GENERIC_IO_CONST_DATA_CAST buffer, nbytes);\n            if (os_result < 0)\n            {\n                OS_DEBUG(\"write: %s\\n\", strerror(errno));\n                OS_GenericWrite_Impl_log(\"write_error\", token, impl, nbytes, timeout, operation, OS_ERROR, os_result);\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                /* type conversion from ssize_t to int32 for return */\n                return_code = (int32)os_result;\n                OS_GenericWrite_Impl_log(\"write_success\", token, impl, nbytes, timeout, operation, return_code, os_result);\n            }\n        }\n    }\n\n    OS_GenericWrite_Impl_log(\"exit\", token, impl, nbytes, timeout, operation, return_code, 0);\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpf5fdy9i1/src/src/os/portable/os-impl-posix-io.c: In function 'OS_GenericWrite_Impl_log':\n/tmp/tmpf5fdy9i1/src/src/os/portable/os-impl-posix-io.c:234:24: error: aggregate value used where an integer was expected\n  234 |                        (unsigned long long)(*token), (const void *)token,\n      |                        ^\n/tmp/tmpf5fdy9i1/src/src/os/portable/os-impl-posix-io.c:246:24: error: aggregate value used where an integer was expected\n  246 |                        (unsigned long long)(*token), (const void *)token,\n      |                        ^\ngmake[2]: *** [posix_impl/CMakeFiles/osal_posix_impl.dir/build.make:328: posix_impl/CMakeFiles/osal_posix_impl.dir/__/portable/os-impl-posix-io.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:919: posix_impl/CMakeFiles/osal_posix_impl.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_GenericWrite_Impl as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void OS_GenericWrite_Impl_log(const char *stage, const OS_object_token_t *token, OS_impl_file_internal_record_t *impl, size_t nbytes, int32 timeout, uint32 operation, int32 return_code, ssize_t os_result)\n{\n    char buf[512];\n    int len = 0;\n\n    /* Compose a concise log message with relevant state. Protect accesses if impl is NULL. */\n    if (impl != NULL)\n    {\n        len = snprintf(buf, sizeof(buf),\n                       \"%s: token_ptr=%p nbytes=%zu timeout=%d impl=%p selectable=%d fd=%d operation=0x%08x return_code=%d os_result=%zd errno=%d\\n\",\n                       stage,\n                       (const void *)token,\n                       nbytes, timeout,\n                       (const void *)impl,\n                       (int)impl->selectable, (int)impl->fd,\n                       (unsigned int)operation,\n                       return_code, os_result, errno);\n    }\n    else\n    {\n        len = snprintf(buf, sizeof(buf),\n                       \"%s: token_ptr=%p nbytes=%zu timeout=%d impl=NULL operation=0x%08x return_code=%d os_result=%zd errno=%d\\n\",\n                       stage,\n                       (const void *)token,\n                       nbytes, timeout,\n                       (unsigned int)operation,\n                       return_code, os_result, errno);\n    }\n\n    if (len > 0)\n    {\n        int fd = open(\"/tmp/logs/863.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n        if (fd >= 0)\n        {\n            /* write may not write all bytes in one call, but this simple probe is sufficient for diagnostics */\n            (void)write(fd, buf, (size_t)len);\n            (void)close(fd);\n        }\n    }\n}\n\nint32 OS_GenericWrite_Impl(const OS_object_token_t *token, const void *buffer, size_t nbytes, int32 timeout)\n{\n    int32                           return_code;\n    ssize_t                         os_result;\n    uint32                          operation = 0u; /* initialized to avoid use-before-set */\n    OS_impl_file_internal_record_t *impl;\n\n    OS_GenericWrite_Impl_log(\"entry\", token, NULL, nbytes, timeout, 0u, 0, 0);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    OS_GenericWrite_Impl_log(\"after_lookup\", token, impl, nbytes, timeout, 0u, 0, 0);\n\n    return_code = OS_SUCCESS;\n\n    if (nbytes > 0)\n    {\n        operation = OS_STREAM_STATE_WRITABLE;\n\n        /*\n         * If filehandle is set with O_NONBLOCK, then must call select() here.\n         *\n         * The \"selectable\" field should be set false for those file handles\n         * which the underlying OS does not support select() on.\n         *\n         * Note that a timeout will not work unless selectable is true.\n         */\n        if (impl != NULL && impl->selectable)\n        {\n            OS_GenericWrite_Impl_log(\"before_select\", token, impl, nbytes, timeout, operation, return_code, 0);\n            return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n            OS_GenericWrite_Impl_log(\"after_select\", token, impl, nbytes, timeout, operation, return_code, 0);\n        }\n\n        if (return_code == OS_SUCCESS && (operation & OS_STREAM_STATE_WRITABLE) != 0)\n        {\n            /* on some system libraries for which the write() argument is not\n             * qualified correctly, it needs to be case to a void* here */\n            OS_GenericWrite_Impl_log(\"before_write\", token, impl, nbytes, timeout, operation, return_code, 0);\n            os_result = write(impl->fd, GENERIC_IO_CONST_DATA_CAST buffer, nbytes);\n            if (os_result < 0)\n            {\n                OS_DEBUG(\"write: %s\\n\", strerror(errno));\n                OS_GenericWrite_Impl_log(\"write_error\", token, impl, nbytes, timeout, operation, OS_ERROR, os_result);\n                return_code = OS_ERROR;\n            }\n            else\n            {\n                /* type conversion from ssize_t to int32 for return */\n                return_code = (int32)os_result;\n                OS_GenericWrite_Impl_log(\"write_success\", token, impl, nbytes, timeout, operation, return_code, os_result);\n            }\n        }\n    }\n\n    OS_GenericWrite_Impl_log(\"exit\", token, impl, nbytes, timeout, operation, return_code, 0);\n\n    return return_code;\n}\n",
  "explanation": "The build error was caused by attempting to use (*token) in a printf-style conversion while OS_object_token_t is an aggregate (not an integer). I removed the invalid dereference and instead print the token pointer value (token_ptr=%p). I updated both snprintf calls accordingly and adjusted the argument lists. Additionally I initialized the local variable 'operation' to 0u to avoid a possible use-before-set when nbytes == 0. These changes preserve the original logic while eliminating the invalid aggregate-to-integer usage that caused the compilation failure."
}