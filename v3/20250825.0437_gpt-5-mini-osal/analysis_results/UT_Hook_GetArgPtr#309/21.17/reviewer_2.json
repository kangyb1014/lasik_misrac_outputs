{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls strcmp(MetaPtr->Name, Name) without checking that the input parameter Name is non-NULL and points to a valid NUL-terminated string. Although MetaPtr->Name is guarded by MetaPtr->Name != NULL, Name is not validated; if UT_Hook_GetArgPtr is called with Name == NULL (or with a non-NUL-terminated buffer), strcmp will dereference beyond the object bounds (NULL or past the buffer), violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER UT_Hook_GetArgPtr: ContextPtr=0x7fffeac2b140 Name=0x55718e1677cc ExpectedTypeSize=4\nLOOP i=0 MetaPtr=0x7fffeac2b190 MetaPtr->Name=0x55718e167506 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167506 Name=0x55718e1677cc (strcmp will be invoked)\nSTRCMP_MATCH at i=0 (MetaPtr->Name=0x55718e167506 Name=0x55718e1677cc). Size check: Meta=4 Expected=4\nASSIGN Result (INDIRECT)=0x7fffeac2b3ec from ArgPtr[0]\nPOST_LOOP Result=0x7fffeac2b3ec\nEXIT UT_Hook_GetArgPtr: returning Result=0x7fffeac2b3ec\nENTER UT_Hook_GetArgPtr: ContextPtr=0x7fffeac2b140 Name=0x55718e1677a8 ExpectedTypeSize=4\nLOOP i=0 MetaPtr=0x7fffeac2b190 MetaPtr->Name=0x55718e167506 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167506 Name=0x55718e1677a8 (strcmp will be invoked)\nNO_MATCH at i=0 after strcmp or size check (MetaPtr->Name=0x55718e167506 Name=0x55718e1677a8)\nLOOP i=1 MetaPtr=0x7fffeac2b1a8 MetaPtr->Name=0x55718e1673b7 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677a8 (strcmp will be invoked)\nSTRCMP_MATCH at i=1 (MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677a8). Size check: Meta=4 Expected=4\nASSIGN Result (INDIRECT)=0x7fffeac2b3e8 from ArgPtr[1]\nPOST_LOOP Result=0x7fffeac2b3e8\nEXIT UT_Hook_GetArgPtr: returning Result=0x7fffeac2b3e8\nENTER UT_Hook_GetArgPtr: ContextPtr=0x7fffeac2b140 Name=0x55718e1677e0 ExpectedTypeSize=4\nLOOP i=0 MetaPtr=0x7fffeac2b190 MetaPtr->Name=0x55718e167506 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167506 Name=0x55718e1677e0 (strcmp will be invoked)\nNO_MATCH at i=0 after strcmp or size check (MetaPtr->Name=0x55718e167506 Name=0x55718e1677e0)\nLOOP i=1 MetaPtr=0x7fffeac2b1a8 MetaPtr->Name=0x55718e1673b7 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677e0 (strcmp will be invoked)\nNO_MATCH at i=1 after strcmp or size check (MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677e0)\nLOOP i=2 MetaPtr=0x7fffeac2b1c0 MetaPtr->Name=0x55718e167510 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167510 Name=0x55718e1677e0 (strcmp will be invoked)\nSTRCMP_MATCH at i=2 (MetaPtr->Name=0x55718e167510 Name=0x55718e1677e0). Size check: Meta=4 Expected=4\nASSIGN Result (INDIRECT)=0x7fffeac2b3e4 from ArgPtr[2]\nPOST_LOOP Result=0x7fffeac2b3e4\nEXIT UT_Hook_GetArgPtr: returning Result=0x7fffeac2b3e4\nENTER UT_Hook_GetArgPtr: ContextPtr=0x7fffeac2b140 Name=0x55718e1677c0 ExpectedTypeSize=8\nLOOP i=0 MetaPtr=0x7fffeac2b190 MetaPtr->Name=0x55718e167506 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167506 Name=0x55718e1677c0 (strcmp will be invoked)\nNO_MATCH at i=0 after strcmp or size check (MetaPtr->Name=0x55718e167506 Name=0x55718e1677c0)\nLOOP i=1 MetaPtr=0x7fffeac2b1a8 MetaPtr->Name=0x55718e1673b7 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677c0 (strcmp will be invoked)\nNO_MATCH at i=1 after strcmp or size check (MetaPtr->Name=0x55718e1673b7 Name=0x55718e1677c0)\nLOOP i=2 MetaPtr=0x7fffeac2b1c0 MetaPtr->Name=0x55718e167510 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167510 Name=0x55718e1677c0 (strcmp will be invoked)\nNO_MATCH at i=2 after strcmp or size check (MetaPtr->Name=0x55718e167510 Name=0x55718e1677c0)\nLOOP i=3 MetaPtr=0x7fffeac2b1d8 MetaPtr->Name=0x55718e1673ed MetaPtr->Size=8 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e1673ed Name=0x55718e1677c0 (strcmp will be invoked)\nSTRCMP_MATCH at i=3 (MetaPtr->Name=0x55718e1673ed Name=0x55718e1677c0). Size check: Meta=8 Expected=8\nASSIGN Result (INDIRECT)=0x7fffeac2b3d8 from ArgPtr[3]\nPOST_LOOP Result=0x7fffeac2b3d8\nEXIT UT_Hook_GetArgPtr: returning Result=0x7fffeac2b3d8\nENTER UT_Hook_GetArgPtr: ContextPtr=0x7fffeac2b140 Name=0x55718e1677cc ExpectedTypeSize=4\nLOOP i=0 MetaPtr=0x7fffeac2b190 MetaPtr->Name=0x55718e167506 MetaPtr->Size=4 MetaPtr->Type=2\nABOUT_TO_STRCMP MetaPtr->Name=0x55718e167506 Name=0x55718e1677cc (strcmp will be invoked)\nSTRCMP_MATCH at i=0 (MetaPtr->Name=0x55718e167506 Name=0x55718e1677cc). Size check: Meta=\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Hook_GetArgPtr:\ntypedef struct\n{\n    int32                Int32StatusCode;\n    bool                 Int32StatusIsSet;\n    uint32               ArgCount;\n    const void *         ArgPtr[UT_STUBCONTEXT_MAXSIZE];\n    UT_StubArgMetaData_t Meta[UT_STUBCONTEXT_MAXSIZE];\n} UT_StubContext_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n...\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The code calls strcmp(MetaPtr->Name, Name) without validating the incoming parameter Name. While MetaPtr->Name is guarded for NULL, Name is not checked; if UT_Hook_GetArgPtr is invoked with Name == NULL (or with a pointer to a non-NUL-terminated buffer), strcmp will dereference Name and can read beyond the bounds of the object (or dereference NULL). That behavior falls squarely within the concern of MISRA C 2023 Rule 21.17, which requires that uses of <string.h> functions must not result in accesses beyond object bounds. Unless there is a documented and enforced external precondition that Name is non-NULL and a valid NUL-terminated string (which is not evident in the provided code), the use of strcmp here violates Rule 21.17. Recommended remedies are to validate Name (e.g., check Name != NULL) before calling strcmp or otherwise enforce/annotate the non-NULL NUL-terminated-string precondition for the function."
}