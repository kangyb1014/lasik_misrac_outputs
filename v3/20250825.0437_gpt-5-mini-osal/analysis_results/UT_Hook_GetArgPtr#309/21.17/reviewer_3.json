{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nMetaPtr->Name = Name stores the pointer to the input string rather than copying its contents. If the supplied Name does not refer to a valid null-terminated object that remains alive for the lifetime of the stub metadata, later calls to string.h functions (e.g. strcmp(MetaPtr->Name, Name) or the while(*MetaPtr->Name) loop) can read past the bounds of the object. Example violating scenario: the caller passes a pointer to a stack buffer (char buf[] = \"x\";) or a non-null-terminated substring; UT_Stub_RegisterContextWithMetaData returns, the stack buffer goes out of scope, and later UT_Hook_GetArgPtr calls strcmp on MetaPtr->Name \u2014 strcmp will dereference an invalid pointer and may access beyond object bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[2025-08-25 05:38:55] ENTER UT_Hook_GetArgPtr: ContextPtr=0x7ffe2a0700c0, Name=0x55cabb60c7cc, ExpectedTypeSize=4, ArgCount=4\n[2025-08-25 05:38:55] iter=0: MetaPtr=0x7ffe2a070110, MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7cc, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7cc) -> 0\n[2025-08-25 05:38:55] Matched INDIRECT: returning ContextPtr->ArgPtr[0] = 0x7ffe2a07036c\n[2025-08-25 05:38:55] Search complete: Result=0x7ffe2a07036c\n[2025-08-25 05:38:55] EXIT UT_Hook_GetArgPtr: returning 0x7ffe2a07036c\n[2025-08-25 05:38:55] ENTER UT_Hook_GetArgPtr: ContextPtr=0x7ffe2a0700c0, Name=0x55cabb60c7a8, ExpectedTypeSize=4, ArgCount=4\n[2025-08-25 05:38:55] iter=0: MetaPtr=0x7ffe2a070110, MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7a8, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7a8) -> 3\n[2025-08-25 05:38:55] Name matched? no; size match? yes\n[2025-08-25 05:38:55] iter=1: MetaPtr=0x7ffe2a070128, MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7a8, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7a8) -> 0\n[2025-08-25 05:38:55] Matched INDIRECT: returning ContextPtr->ArgPtr[1] = 0x7ffe2a070368\n[2025-08-25 05:38:55] Search complete: Result=0x7ffe2a070368\n[2025-08-25 05:38:55] EXIT UT_Hook_GetArgPtr: returning 0x7ffe2a070368\n[2025-08-25 05:38:55] ENTER UT_Hook_GetArgPtr: ContextPtr=0x7ffe2a0700c0, Name=0x55cabb60c7e0, ExpectedTypeSize=4, ArgCount=4\n[2025-08-25 05:38:55] iter=0: MetaPtr=0x7ffe2a070110, MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7e0, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7e0) -> 3\n[2025-08-25 05:38:55] Name matched? no; size match? yes\n[2025-08-25 05:38:55] iter=1: MetaPtr=0x7ffe2a070128, MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7e0, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7e0) -> 116\n[2025-08-25 05:38:55] Name matched? no; size match? yes\n[2025-08-25 05:38:55] iter=2: MetaPtr=0x7ffe2a070140, MetaPtr->Name=0x55cabb60c510, Name=0x55cabb60c7e0, MetaPtr->Size=4, ExpectedTypeSize=4, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c510, Name=0x55cabb60c7e0) -> 0\n[2025-08-25 05:38:55] Matched INDIRECT: returning ContextPtr->ArgPtr[2] = 0x7ffe2a070364\n[2025-08-25 05:38:55] Search complete: Result=0x7ffe2a070364\n[2025-08-25 05:38:55] EXIT UT_Hook_GetArgPtr: returning 0x7ffe2a070364\n[2025-08-25 05:38:55] ENTER UT_Hook_GetArgPtr: ContextPtr=0x7ffe2a0700c0, Name=0x55cabb60c7c0, ExpectedTypeSize=8, ArgCount=4\n[2025-08-25 05:38:55] iter=0: MetaPtr=0x7ffe2a070110, MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7c0, MetaPtr->Size=4, ExpectedTypeSize=8, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c506, Name=0x55cabb60c7c0) -> -8\n[2025-08-25 05:38:55] Name matched? no; size match? no\n[2025-08-25 05:38:55] iter=1: MetaPtr=0x7ffe2a070128, MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7c0, MetaPtr->Size=4, ExpectedTypeSize=8, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c3b7, Name=0x55cabb60c7c0) -> -11\n[2025-08-25 05:38:55] Name matched? no; size match? no\n[2025-08-25 05:38:55] iter=2: MetaPtr=0x7ffe2a070140, MetaPtr->Name=0x55cabb60c510, Name=0x55cabb60c7c0, MetaPtr->Size=4, ExpectedTypeSize=8, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c510, Name=0x55cabb60c7c0) -> -11\n[2025-08-25 05:38:55] Name matched? no; size match? no\n[2025-08-25 05:38:55] iter=3: MetaPtr=0x7ffe2a070158, MetaPtr->Name=0x55cabb60c3ed, Name=0x55cabb60c7c0, MetaPtr->Size=8, ExpectedTypeSize=8, MetaPtr->Type=2\n[2025-08-25 05:38:55] strcmp(MetaPtr->Name=0x55cabb60c3ed, Name=0x55cabb60c7c0) -> 0\n[2025-08-25 05:38:55] Matched INDIRECT: returning ContextPtr->ArgPtr[3] = 0x7ffe2a070358\n[2025-08-25 05:38:55] Search complete: Result=0x7ffe2a070358\n[2025-08-\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Hook_GetArgPtr:\ntypedef struct\n{\n    int32                Int32StatusCode;\n    bool                 Int32StatusIsSet;\n    uint32               ArgCount;\n    const void *         ArgPtr[UT_STUBCONTEXT_MAXSIZE];\n    UT_StubArgMetaData_t Meta[UT_STUBCONTEXT_MAXSIZE];\n} UT_StubContext_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n...\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UT_Hook_GetArgPtr calls strcmp(MetaPtr->Name, Name) with MetaPtr->Name previously set by UT_Stub_RegisterContextWithMetaData as MetaPtr->Name = Name (and then advanced via ++MetaPtr->Name). Neither function establishes or enforces that the pointer(s) refer to a valid, null-terminated object with a lifetime that extends to the later strcmp call. If the caller passed a pointer to a short\u2011lived stack buffer or a non\u2011null\u2011terminated substring, later calls to strcmp (or the while (*MetaPtr->Name) loop in the registrar) can dereference a dangling pointer or read past the object bound, which is exactly the situation MISRA C 2023 Rule 21.17 forbids. Therefore the code can violate Rule 21.17 unless additional external guarantees (e.g. API contract that Name points to long\u2011lived, NUL-terminated storage) are imposed; as written, the report is correct."
}