{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe union member 'void * AsPtr' is declared as a pointer to non-const. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types when possible \u2014 here AsPtr should be declared as 'const void * AsPtr' (or an equivalent const-qualified pointer) to match its intended use as a read-only default pointer value.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='lock_mode' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nMatch found at index 0: Name='lock_mode' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[0] => 0x7ffc65e1ff6c\nBreaking loop after match at index 0\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff6c\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='idtype' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nMatch found at index 1: Name='idtype' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[1] => 0x7ffc65e1ff68\nBreaking loop after match at index 1\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff68\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='id' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nLoop i=2 MetaPtr=0x7ffc65e1fd40 Name='id' Size=4 Type=2\nMatch found at index 2: Name='id' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[2] => 0x7ffc65e1ff64\nBreaking loop after match at index 2\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff64\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='token' ExpectedTypeSize=8 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nLoop i=2 MetaPtr=0x7ffc65e1fd40 Name='id' Size=4 Type=2\nLoop i=3 MetaPtr=0x7ffc65e1fd58 Name='token' Size=8 Type=2\nMatch found at index 3: Name='token' Size=8 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[3] => 0x7ffc65e1ff58\nBreaking loop after match at index 3\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff58\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='lock_mode' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nMatch found at index 0: Name='lock_mode' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[0] => 0x7ffc65e1ff6c\nBreaking loop after match at index 0\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff6c\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='idtype' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nMatch found at index 1: Name='idtype' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[1] => 0x7ffc65e1ff68\nBreaking loop after match at index 1\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff68\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='id' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nLoop i=2 MetaPtr=0x7ffc65e1fd40 Name='id' Size=4 Type=2\nMatch found at index 2: Name='id' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[2] => 0x7ffc65e1ff64\nBreaking loop after match at index 2\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff64\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='token' ExpectedTypeSize=8 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nLoop i=1 MetaPtr=0x7ffc65e1fd28 Name='idtype' Size=4 Type=2\nLoop i=2 MetaPtr=0x7ffc65e1fd40 Name='id' Size=4 Type=2\nLoop i=3 MetaPtr=0x7ffc65e1fd58 Name='token' Size=8 Type=2\nMatch found at index 3: Name='token' Size=8 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[3] => 0x7ffc65e1ff58\nBreaking loop after match at index 3\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff58\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='lock_mode' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65e1fd10 Name='lock_mode' Size=4 Type=2\nMatch found at index 0: Name='lock_mode' Size=4 Type=2\nAssigned Result (indirect) = ContextPtr->ArgPtr[0] => 0x7ffc65e1ff6c\nBreaking loop after match at index 0\nExit UT_Hook_GetArgPtr returning 0x7ffc65e1ff6c\nEnter UT_Hook_GetArgPtr: ContextPtr=0x7ffc65e1fcc0 Name='idtype' ExpectedTypeSize=4 ArgCount=4\nLoop i=0 MetaPtr=0x7ffc65\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Hook_GetArgPtr:\ntypedef struct\n{\n    int32                Int32StatusCode;\n    bool                 Int32StatusIsSet;\n    uint32               ArgCount;\n    const void *         ArgPtr[UT_STUBCONTEXT_MAXSIZE];\n    UT_StubArgMetaData_t Meta[UT_STUBCONTEXT_MAXSIZE];\n} UT_StubContext_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 8.13 requires that pointer types point to const-qualified targets where possible. In the shown code the union contains a member declared as \"void * AsPtr\" (a pointer-to-non-const), but the intent/usage is read-only (the union is declared static const and used to provide a read-only default pointer). Declaring the member as \"const void * AsPtr\" (or equivalent) would better reflect the immutability of the pointed-to object and avoid discarding const-qualification. Although the union object itself is const, that does not make the pointer type within the union a pointer-to-const; therefore the current declaration does not satisfy the guidance of Rule 8.13. The report of a violation is justified."
}