{
  "user_message": "An agent A claimed that the following OS_ObjectIdGetBySearch code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdGetBySearch.\n```c\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function pointer typedef uses a non-const void *ref parameter: typedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj). The other pointer parameters are const-qualified, indicating the match callback is intended to examine but not modify the token or object. If the callback does not need to modify the data referenced by ref, that parameter should be const-qualified (const void *ref). As written, callers holding const data must cast away const to pass it, undermining const-correctness and violating MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=4 arg=0x559819b776b1 token=0x7ffe0311cec0\narg dump (first 16 bytes): 4E 61 6D 65 4E 6F 74 46 6F 75 6E 64 00 4F 53 5F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b776b1\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=3 arg=0x559819b79f7d token=0x7ffe0311cec0\narg dump (first 16 bytes): 4E 6F 74 46 6F 75 6E 64 00 4F 53 5F 45 52 52 5F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b79f7d\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=5 arg=0x559819b7a6d9 token=0x7ffe0311cec0\narg dump (first 16 bytes): 4E 6F 74 46 6F 75 6E 64 00 4F 53 5F 45 52 52 5F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b7a6d9\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=2 arg=0x559819b78f50 token=0x7ffe0311cec0\narg dump (first 16 bytes): 4E 61 6D 65 4E 6F 74 46 6F 75 6E 64 00 4F 53 5F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b78f50\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b791e9 token=0x7ffe0311cf30\narg dump (first 16 bytes): 2F 72 61 6D 64 65 76 33 00 00 00 00 00 00 00 4F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b791e9\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b792b8 token=0x7ffe0311ce40\narg dump (first 16 bytes): 2F 64 72 69 76 65 33 2F 73 65 6C 65 63 74 5F 74\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b792b8\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b792b8 token=0x7ffe0311ce70\narg dump (first 16 bytes): 2F 64 72 69 76 65 33 2F 73 65 6C 65 63 74 5F 74\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b792b8\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b79290 token=0x7ffe0311cf30\narg dump (first 16 bytes): 2F 64 72 69 76 65 33 00 4F 53 5F 6D 6F 75 6E 74\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b79290\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=3 idtype=11 arg=0x559819b791e9 token=0x7ffe0311cf30\narg dump (first 16 bytes): 2F 72 61 6D 64 65 76 33 00 00 00 00 00 00 00 4F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b791e9\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b791e9 token=0x7ffe0311cf30\narg dump (first 16 bytes): 2F 72 61 6D 64 65 76 33 00 00 00 00 00 00 00 4F\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdFindNextMatch with arg=0x559819b791e9\nOS_ObjectIdFindNextMatch returned -17\nNo match: calling OS_ObjectIdTransactionCancel\nEXIT: OS_ObjectIdGetBySearch return_code=-17\n\nENTER: OS_ObjectIdGetBySearch lock_mode=1 idtype=11 arg=0x559819b792b8 token=0x7ffe0311ce40\narg dump (first 16 bytes): 2F 64 72 69 76 65 33 2F 73 65 6C 65 63 74 5F 74\nAfter OS_ObjectIdTransactionInit\nCalling OS_ObjectIdF\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdGetBySearch:\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n...\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Unlock_Global(token);\n        token->lock_mode = OS_LOCK_MODE_NONE;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function-pointer typedef OS_ObjectMatchFunc_t and the related API use a void * parameter for the user-supplied reference/argument (void *ref / void *arg) while the other pointer parameters to the match callback are const-qualified. In the code shown, the library itself does not modify the arg (it merely passes it to the MatchFunc), and the other match callback parameters are declared const which strongly indicates the intent is for the callback to observe but not modify data. Under MISRA C:2023 Rule 8.13 (\u201cA pointer should point to a const-qualified type whenever possible\u201d), the parameter should be declared as const void *ref (and the functions taking/forwarding it should use const void *arg) unless there is a concrete need for the callback to modify the pointed-to object. As no such need is evident in the provided code, the non-const void * constitutes a violation (or at minimum a likely deviation) of Rule 8.13. If there are match callbacks elsewhere that legitimately modify the referenced data, then the non-const form would be justified; otherwise the typedef and API should be changed to use const void * to be MISRA-conformant."
}