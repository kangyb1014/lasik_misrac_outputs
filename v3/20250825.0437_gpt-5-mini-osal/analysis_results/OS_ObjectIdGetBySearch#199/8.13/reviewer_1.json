{
  "user_message": "An agent A claimed that the following OS_ObjectIdGetBySearch code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdGetBySearch.\n```c\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code assigns a non-const pointer to a table entry: `record = OS_OBJECT_TABLE_GET(base, *token);`. In OS_ObjectIdFindNextMatch the pointer is only used for read-only access (e.g. `record->active_id`) and then passed to MatchFunc whose prototype takes `const OS_common_record_t *obj`. Therefore `record` (and arguably `base`) could and should be declared as `const OS_common_record_t *` to reflect immutability. Leaving it as a non-const pointer allows accidental modification and violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nStage: enter\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_init\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_find\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: before_cancel\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: after_cancel\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: exit\n  lock_mode: 1\n  idtype: 4\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941a6b1\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: enter\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_init\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_find\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: before_cancel\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: after_cancel\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: exit\n  lock_mode: 1\n  idtype: 3\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941cf7d\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: enter\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_init\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_find\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: before_cancel\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: after_cancel\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: exit\n  lock_mode: 1\n  idtype: 5\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941d6d9\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: enter\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_init\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -1\n\nStage: after_find\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: before_cancel\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: after_cancel\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: exit\n  lock_mode: 1\n  idtype: 2\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941bf50\n  token ptr: 0x7fffc03d9a70\n  return_code (probe): -17\n\nStage: enter\n  lock_mode: 1\n  idtype: 11\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941c1e9\n  token ptr: 0x7fffc03d9ae0\n  return_code (probe): -1\n\nStage: after_init\n  lock_mode: 1\n  idtype: 11\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941c1e9\n  token ptr: 0x7fffc03d9ae0\n  return_code (probe): -1\n\nStage: after_find\n  lock_mode: 1\n  idtype: 11\n  MatchFunc: 0x556dd9401170\n  arg: 0x556dd941c1e9\n  token ptr: 0x7fffc03d9ae0\n  return_code (probe): -17\n\nStage: before_cancel\n  lock_mode: 1\n  idtype: 11\n  Matc\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdGetBySearch:\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n...\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Unlock_Global(token);\n        token->lock_mode = OS_LOCK_MODE_NONE;\n    }\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In OS_ObjectIdFindNextMatch both \"base\" and \"record\" are only used for read-only access: the function only reads record->active_id and then passes record to MatchFunc which accepts a const OS_common_record_t *. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so these local pointers should be declared const OS_common_record_t * to express immutability and prevent accidental modification. The change is straightforward (declare base and record as const pointers) provided the OS_OBJECT_TABLE_GET macro and any subsequent uses accept assignment to a const-qualified pointer. Therefore the agent A report is correct \u2014 the code as written violates Rule 8.13."
}