{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe inline OS_strnlen uses memchr(s, 0, maxlen). memchr will scan up to maxlen bytes starting from s, which can read beyond the actual allocated object if the object that s points to is smaller than maxlen. In OS_TranslatePath this is called as OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) where VirtualPath is an arbitrary const char * supplied by the caller. If the caller passes a pointer to a smaller buffer or a short string whose allocated storage is less than OS_MAX_PATH_LEN, memchr may access bytes beyond the object's bounds (undefined behavior). For example, passing a pointer to a 16-byte buffer containing \"abc\\0\" while OS_MAX_PATH_LEN is 256 causes memchr to probe up to 256 bytes and potentially read out-of-bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryOpen code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1509.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryOpen as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryOpen:\n```c\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryOpen code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <stdint.h>\n\n/* Probe / logging helpers (do not change program logic) */\nstatic void probe_append_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1509.txt\", \"a\");\n    if (!f) return;\n\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] %s\\n\", (long)t, msg);\n    fclose(f);\n}\n\nstatic void probe_log_ptr_info(const char *label, const void *p)\n{\n    FILE *f = fopen(\"/tmp/logs/1509.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"PTR %s: %p\\n\", label, p);\n\n    /* Attempt to locate the memory mapping that contains the pointer (best-effort, no dereference) */\n    FILE *m = fopen(\"/proc/self/maps\", \"r\");\n    if (m)\n    {\n        char line[256];\n        unsigned long start = 0, end = 0;\n        while (fgets(line, sizeof(line), m))\n        {\n            if (sscanf(line, \"%lx-%lx\", &start, &end) == 2)\n            {\n                unsigned long addr = (unsigned long)p;\n                if (addr >= start && addr < end)\n                {\n                    fprintf(f, \"  mapping: %s\", line);\n                    break;\n                }\n            }\n        }\n        fclose(m);\n    }\n\n    fclose(f);\n}\n\nstatic void probe_dump_buffer_hex(const char *label, const void *buf, size_t buf_size, size_t max_dump)\n{\n    FILE *f = fopen(\"/tmp/logs/1509.txt\", \"a\");\n    if (!f) return;\n\n    const unsigned char *b = (const unsigned char *)buf;\n    size_t dump = buf_size < max_dump ? buf_size : max_dump;\n\n    fprintf(f, \"BUF %s @%p size=%zu dump_len=%zu: \", label, buf, buf_size, dump);\n    for (size_t i = 0; i < dump; ++i)\n    {\n        fprintf(f, \"%02x\", b[i]);\n        if ((i + 1) % 16 == 0 && i + 1 < dump) fprintf(f, \" \");\n    }\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Modified OS_DirectoryOpen with probes inserted. The original logic is preserved. */\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    /* Probe: entering, log pointer and environment constants that are relevant to the violation scenario */\n    {\n        char msg[256];\n        snprintf(msg, sizeof(msg), \"ENTER OS_DirectoryOpen: path=%p\", (void *)path);\n        probe_append_log(msg);\n        probe_log_ptr_info(\"path\", path);\n\n        /* Log constants relevant to the string handling functions used by OS_TranslatePath */\n        snprintf(msg, sizeof(msg), \"CONSTANTS: OS_MAX_PATH_LEN=%d OS_MAX_LOCAL_PATH_LEN=%d\", (int)OS_MAX_PATH_LEN, (int)OS_MAX_LOCAL_PATH_LEN);\n        probe_append_log(msg);\n\n        /* Log the local_path buffer address and size (safe to inspect) */\n        probe_log_ptr_info(\"local_path\", local_path);\n        probe_dump_buffer_hex(\"local_path_before\", local_path, sizeof(local_path), 32);\n    }\n\n    /* Call the translator (this is the call implicated in the memchr scenario) */\n    return_code = OS_TranslatePath(path, local_path);\n\n    /* Probe: result of translation and snapshot of local_path after translation */\n    {\n        char msg[256];\n        snprintf(msg, sizeof(msg), \"AFTER OS_TranslatePath: return_code=%ld\", (long)return_code);\n        probe_append_log(msg);\n\n        /* Dump up to a safe amount of local_path contents (bounded by local_path size) */\n        probe_dump_buffer_hex(\"local_path_after\", local_path, sizeof(local_path), 64);\n\n        /* Note the incoming path pointer again for correlation */\n        probe_log_ptr_info(\"path_post_translate\", path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        probe_append_log(\"CALL OS_ObjectIdAllocateNew\");\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        probe_append_log(\"RETURN OS_ObjectIdAllocateNew\");\n\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            probe_append_log(\"CALL OS_DirOpen_Impl\");\n            return_code = OS_DirOpen_Impl(&token, local_path);\n            probe_append_log(\"RETURN OS_DirOpen_Impl\");\n\n            /* Check result, finalize record, and unlock global table. */\n            probe_append_log(\"CALL OS_ObjectIdFinalizeNew\");\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n            probe_append_log(\"RETURN OS_ObjectIdFinalizeNew\");\n        }\n    }\n\n    {\n        char msg[256];\n        snprintf(msg, sizeof(msg), \"EXIT OS_DirectoryOpen: return_code=%ld\", (long)return_code);\n        probe_append_log(msg);\n    }\n\n    return return_code;\n}\n"
}