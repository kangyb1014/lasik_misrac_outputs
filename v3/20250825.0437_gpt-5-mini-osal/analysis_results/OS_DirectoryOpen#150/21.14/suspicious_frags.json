{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryOpen:\n```c\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_DirectoryOpen:\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    uint32              max_id;\n    uint32              base_id;\n    uint32              local_id = 0;\n    uint32              serial;\n    uint32              i;\n    int32               return_code;\n    OS_common_record_t *obj = NULL;\n    OS_objtype_state_t *objtype_state;\n\n    base_id       = OS_GetBaseForObjectType(token->obj_type);\n    max_id        = OS_GetMaxForObjectType(token->obj_type);\n    objtype_state = &OS_objtype_state[token->obj_type];\n\n    if (max_id == 0)\n    {\n        /* if the max id is zero, then this build of OSAL\n         * does not include any support for that object type.\n         * Return the \"not implemented\" to differentiate between\n         * this case vs. running out of valid slots  */\n        return_code = OS_ERR_NOT_IMPLEMENTED;\n        serial      = 0;\n    }\n    else\n    {\n        return_code = OS_ERR_NO_FREE_IDS;\n        serial      = OS_ObjectIdToSerialNumber_Impl(objtype_state->last_id_issued);\n    }\n\n    for (i = 0; i < max_id; ++i)\n    {\n        local_id = (++serial) % max_id;\n        if (serial >= OS_OBJECT_INDEX_MASK)\n        {\n            /* reset to beginning of ID space */\n            serial = local_id;\n        }\n        obj = &OS_common_table[local_id + base_id];\n        if (!OS_ObjectIdDefined(obj->active_id))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(local_id);\n        OS_ObjectIdCompose_Impl(token->obj_type, serial, &token->obj_id);\n\n        /* Ensure any data in the record has been cleared */\n        obj->active_id  = token->obj_id;\n        obj->name_entry = NULL;\n        obj->creator    = OS_TaskGetId();\n        obj->refcount   = 0;\n\n        /* preemptively update the last id issued */\n        objtype_state->last_id_issued = token->obj_id;\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(-1);\n        token->obj_id  = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nvoid OS_ObjectIdTransactionFinish(OS_object_token_t *token, const osal_id_t *final_id)\n{\n    OS_common_record_t *record;\n\n    if (token->lock_mode == OS_LOCK_MODE_NONE)\n    {\n        /* nothing to do */\n        return;\n    }\n\n    record = OS_ObjectIdGlobalFromToken(token);\n\n    /* re-acquire global table lock to adjust refcount */\n    if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE || token->lock_mode == OS_LOCK_MODE_REFCOUNT)\n    {\n        OS_Lock_Global(token);\n    }\n\n    if (record->refcount > 0)\n    {\n        --record->refcount;\n    }\n\n    /*\n     * at this point the global mutex is always held, either\n     * from re-acquiring it above or it is still held from\n     * the original lock when using OS_LOCK_MODE_GLOBAL.\n     *\n     * If an ID update was pending (i.e. for a create/delete op)\n     * then do the ID update now while holding the mutex.\n     */\n    if (final_id != NULL)\n    {\n        record->active_id = *final_id;\n    }\n    else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n    {\n        /*\n         * If the lock type was EXCLUSIVE, it means that the ID in the record\n         * was reset to OS_OBJECT_ID_RESERVED.  This must restore the original\n         * object ID from the token.\n         */\n        record->active_id = token->obj_id;\n    }\n\n    /* always unlock (this also covers OS_LOCK_MODE_GLOBAL case) */\n    OS_Unlock_Global(token);\n\n    /*\n     * Setting to \"NONE\" indicates that this token has been\n     * released, and should not be released again.\n     */\n    token->lock_mode = OS_LOCK_MODE_NONE;\n}\n...\n#define OS_OBJECT_INIT(tok, ref, namefield, nameval) {memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nint32 OS_DirOpen_Impl(const OS_object_token_t *token, const char *local_path)\n{\n    DIR *                          dp = opendir(local_path);\n    OS_impl_dir_internal_record_t *impl;\n\n    if (dp == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    impl     = OS_OBJECT_TABLE_GET(OS_impl_dir_table, *token);\n    impl->dp = dp;\n\n    return OS_SUCCESS;\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "MISRA C:2023 Rule 21.14 forbids using memcmp to compare null-terminated strings. The provided target and additional code were scanned for memcmp usage. No calls to memcmp are present. The memory/string functions that do appear are memchr, memcpy, memset, strncpy, strrchr and the custom OS_strnlen; these are used for searching for the NUL byte, copying data, clearing memory, and bounded copying \u2014 none of which violate Rule 21.14. OS_OBJECT_INIT uses strncpy with a size-1 limit, not memcmp. Therefore there are no code fragments in the supplied code that need investigation for Rule 21.14. (If memcmp is used elsewhere in the codebase not provided here, those locations should be inspected.)"
}