{
  "user_message": "An agent A claimed that the following UtAssert_GetOpText code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_GetOpText.\n```c\nconst char *UtAssert_GetOpText(UtAssert_Compare_t CompareType)\n{\n    const char *OpText;\n\n    switch (CompareType)\n    {\n        case UtAssert_Compare_EQ: /* actual equals reference value */\n            OpText = \"==\";\n            break;\n        case UtAssert_Compare_NEQ: /* actual does not non equal reference value */\n            OpText = \"!=\";\n            break;\n        case UtAssert_Compare_LT: /* actual less than reference (exclusive) */\n            OpText = \"<\";\n            break;\n        case UtAssert_Compare_GT: /* actual greater than reference (exclusive)  */\n            OpText = \">\";\n            break;\n        case UtAssert_Compare_LTEQ: /* actual less than or equal to reference (inclusive) */\n            OpText = \"<=\";\n            break;\n        case UtAssert_Compare_GTEQ: /* actual greater than reference (inclusive) */\n            OpText = \">=\";\n            break;\n        case UtAssert_Compare_BITMASK_SET: /* bit(s) in reference are set in actual */\n            OpText = \"&\";\n            break;\n        case UtAssert_Compare_BITMASK_UNSET: /* bit(s) in reference are not set in actual */\n            OpText = \"&~\";\n            break;\n        default: /* should never happen */\n            OpText = \"??\";\n            break;\n    }\n\n    return OpText;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code increments the pointer parameter RefText (RefText += sizeof(UTASSERT_PREFIX) - 1;), i.e. reassigns the parameter variable to point past the prefix. This modifies the pointer parameter itself rather than the object it points to, which violates MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x562c70b94ca9\nUtAssert_GetOpText: exit returning OpText_ptr=0x562c70b94ca9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x562c70b94ca9\nUtAssert_GetOpText: exit returning OpText_ptr=0x562c70b94ca9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: exit returning OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: exit returning OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: exit returning OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: exit returning OpText_ptr=0x563e769b6721\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: exit returning OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: exit returning OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: exit returning OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: exit returning OpText_ptr=0x5609452c0889\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d42877beb1\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType=1, OpText=\"==\", OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: exit returning OpText_ptr=0x55d60dea0cb9\nUtAssert_GetOpText: entry CompareType=1\nUtAssert_GetOpText: CompareType\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtAssert_GetOpText:\ntypedef enum\n{\n    UtAssert_Compare_NONE,          /**< invalid/not used, always false */\n    UtAssert_Compare_EQ,            /**< actual equals reference value */\n    UtAssert_Compare_NEQ,           /**< actual does not non equal reference value */\n    UtAssert_Compare_LT,            /**< actual less than reference (exclusive) */\n    UtAssert_Compare_GT,            /**< actual greater than reference (exclusive)  */\n    UtAssert_Compare_LTEQ,          /**< actual less than or equal to reference (inclusive) */\n    UtAssert_Compare_GTEQ,          /**< actual greater than reference (inclusive) */\n    UtAssert_Compare_BITMASK_SET,   /**< actual equals reference value */\n    UtAssert_Compare_BITMASK_UNSET, /**< actual equals reference value */\n    UtAssert_Compare_MAX            /**< placeholder, not used */\n} UtAssert_Compare_t\n...\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    if (strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        ActualText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n    if (strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        RefText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 17.8 forbids modifying a function parameter (the pointer itself may not be reassigned; modifying the object pointed to is allowed). The function shown, UtAssert_GetOpText(UtAssert_Compare_t CompareType), does not modify its parameter: CompareType is only read in the switch and never reassigned. All pointer assignments in that function are to the local variable OpText (a locally declared const char *), not to the parameter. Therefore UtAssert_GetOpText does not violate Rule 17.8.\n\nThe scenario described by agent A (RefText += sizeof(UTASSERT_PREFIX) - 1;) occurs in UtAssert_GenericIntegerCompare, not in UtAssert_GetOpText. Reassigning the pointer parameters ActualText and RefText in UtAssert_GenericIntegerCompare would be a breach of Rule 17.8 (because the pointer parameters themselves are being modified), but that is a different function than the one claimed. In short: the report is incorrect for UtAssert_GetOpText; the pointer-modifying code cited belongs to another function and would be the relevant violation if reported against that function."
}