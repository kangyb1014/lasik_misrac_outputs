{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileSysStartVolume_Impl:\n```c\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    break;\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileSysStartVolume_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nextern OS_filesys_internal_record_t OS_filesys_table[OS_MAX_FILE_SYSTEMS]\n...\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\nconst char OS_POSIX_DEVICEFILE_PREFIX[] = \"/dev/\"\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n...\n#define OS_DEBUG(__VA_ARGS__) \n...\n#define OS_FS_ERR_DRIVE_NOT_CREATED (-106)\n...\n#define OS_SUCCESS (0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The code fragment contains no dead code: the branch if (mplen < sizeof(local->system_mountpt)) can be taken or not depending on the length of tmpdir (or TMPDIR) and the buffer size, and the subsequent vollen calculation, memcpy and explicit null-termination are required to safely append the volume_name. Removing any of these executed operations would change program behaviour."
}