{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t",
    "UT_StubTableEntry_t",
    "UT_GetStubEntry",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF",
    "UtAssert_Abort",
    "malloc",
    "memcpy",
    "size_t",
    "bool"
  ],
  "explanation": "For MISRA rule checking that function parameters are not modified, the next analyst needs the exact types/prototypes and structure member types used by UT_SetDataBuffer so they can determine whether any statements actually write into the parameter objects (or reassign the parameter variables). Brief reasons:\n\n- UT_EntryKey_t: Must know whether this typedef is a scalar, an integer, or a pointer type. If it is a pointer type then passing/copying it could have different implications; also to confirm that assigning StubPtr->FuncKey = FuncKey is reading FuncKey, not modifying the parameter.\n\n- UT_StubTableEntry_t: The full struct definition (including members FuncKey, EntryType, ModeFlags and the nested Data.Buff struct with BasePtr, TotalSize, Position) is needed to confirm that assignments (e.g., StubPtr->Data.Buff.BasePtr = DataBuffer, .TotalSize = BufferSize, .Position = 0, ModeFlags |= ...) modify the stub object, not the incoming parameter variables.\n\n- UT_GetStubEntry: Prototype/signature (parameter types and whether parameters are by-value or by-pointer) is required to verify the call UT_GetStubEntry(FuncKey, ...) cannot modify the FuncKey parameter (e.g., by taking a pointer to it) or otherwise alias it.\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER: Macro/constant definitions are needed to ensure they do not expand to expressions that could modify parameters (in case of weird macro definitions) and to interpret the meaning of the EntryType assignment.\n\n- UT_MODEFLAG_ALLOC_BUF: Definition is required to ensure the |= operation only touches the ModeFlags member and does not have side effects on function parameters via macro expansion.\n\n- UtAssert_Abort: Prototype is needed to confirm that calling UtAssert_Abort(...) cannot modify any of UT_SetDataBuffer's parameters (in case of unconventional API that takes pointers to them).\n\n- malloc: Prototype/behavior (standard) to confirm malloc does not modify any of UT_SetDataBuffer's parameters; also to confirm the returned pointer is assigned to the stub, not to a parameter.\n\n- memcpy: Prototype/behavior to verify that memcpy(BasePtr, DataBuffer, BufferSize) reads from the memory pointed to by DataBuffer but does not modify the DataBuffer pointer parameter itself (nor BufferSize parameter variable).\n\n- size_t: Definition/type required to confirm BufferSize's type and that BufferSize is passed/used by value and not modified by any called routine.\n\n- bool: Definition required to confirm AllocateCopy's type (passed by value) and that the code does not modify the parameter variable itself.\n\nIncluding these symbols (types, prototypes and macros) allows an analyzer to determine precisely that all writes in UT_SetDataBuffer target the stub object (StubPtr->...) or memory pointed to by DataBuffer, and that none of the formal parameters (FuncKey, DataBuffer, BufferSize, AllocateCopy) are reassigned within the function (or via called functions/macros)."
}