{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UtAssert_Abort",
    "malloc",
    "memcpy",
    "UT_StubTableEntry_t (type/struct)",
    "UT_EntryKey_t (type)",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF"
  ],
  "explanation": "To determine whether UT_SetDataBuffer violates the MISRA C rule for well-formed for-loops you must verify that there are no for-statements in the function itself and that no called routines introduce loop-behaviour that should be considered part of a for-loop body. The following symbols are therefore required and why:\n\n- UT_GetStubEntry\n  - UT_SetDataBuffer calls this function. Its implementation must be inspected to see if it contains any for-statements (or modifies objects that could act as loop counters/control flags) whose behaviour could be observed as part of UT_SetDataBuffer (the MISRA rule counts called-function behaviour as part of a loop body).\n\n- UtAssert_Abort\n  - Called when UT_GetStubEntry returns NULL or malloc fails. If UtAssert_Abort contains for-statements or side-effecting loops, those must be known because they could be considered part of any for-loop body that included the call site.\n\n- malloc\n  - Standard allocator is called when AllocateCopy is true. Although normally an external library function, its implementation (or any wrapper used in this codebase) must be checked if you need to reason about loops inside called functions for MISRA analysis.\n\n- memcpy\n  - Used to copy the buffer when AllocateCopy is true. Its implementation may contain loops; if UT_SetDataBuffer were placed inside a for-statement, the behaviour of memcpy would be part of the loop body and must be known (and also to ensure no objects used as loop counters are modified inside memcpy unexpectedly).\n\n- UT_StubTableEntry_t (type/struct)\n  - Inspecting the structure is necessary to confirm that assignments to its members (FuncKey, EntryType, Data.Buff.BasePtr, Data.Buff.TotalSize, Data.Buff.Position, ModeFlags) do not hide macros or inline functions that contain for-statements or modify external objects that could act as loop counters/control flags.\n\n- UT_EntryKey_t (type)\n  - The key type used as loop-control-like data in the function. Its definition is required to ensure no unusual semantics (e.g., if it is a macro, typedef to a complex type, or if assignments invoke hidden side-effects) that could affect loop well-formedness reasoning.\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER (macros/constants)\n  - Their definitions must be checked to ensure they are plain constants (no macro expansion that contains for-statements or side-effects).\n\n- UT_MODEFLAG_ALLOC_BUF (macro/constant)\n  - Needed to ensure the bitwise OR assignment to ModeFlags is a simple constant and not a macro with hidden side-effects or loops.\n\nNotes:\n- UT_SetDataBuffer itself contains no for-statements; the primary reason to gather the above symbols is to inspect all called functions and any macros/structs for concealed for-loops or side-effects that would be relevant if UT_SetDataBuffer were placed inside a for-loop or if any called routine implicitly uses/changes objects that a surrounding for-loop might rely upon.\n- If you confirm that none of the listed callees, macros or structure member accesses introduce for-statements or modify loop counters/flags, then UT_SetDataBuffer cannot violate the MISRA for-loop rule (because it contains no for statements itself)."
}