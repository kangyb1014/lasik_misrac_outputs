{
  "user_message": "An agent A claimed that the following UT_SetDataBuffer code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_SetDataBuffer.\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. If AllocateCopy is true the code does memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize) and then stores StubPtr->Data.Buff.TotalSize = BufferSize. There is no verification that the object referenced by DataBuffer is at least BufferSize bytes long. If the caller passes a DataBuffer that is smaller than BufferSize (or an incorrect BufferSize), the memcpy will read beyond the bounds of the source object; additionally, when AllocateCopy is false the code records TotalSize = BufferSize for the externally provided buffer and later uses of the buffer (memcpy/memmove/str* calls) could access beyond the actual object size. Both cases can result in out\u2011of\u2011bounds accesses of objects referenced by pointer parameters to <string.h> functions, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_SetDataBuffer ENTRY: FuncKey=94162468128387, DataBuffer=0x7fff9ecc0b40, BufferSize=48, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7fff9ecc0b40 for FuncKey=94162468128387\nUT_SetDataBuffer EXIT: FuncKey=94162468128387 BasePtr=0x7fff9ecc0b40 TotalSize=48 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94481696558389, DataBuffer=0x55ee3bf75aa0, BufferSize=32768, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x55ee3bf75aa0 for FuncKey=94481696558389\nUT_SetDataBuffer EXIT: FuncKey=94481696558389 BasePtr=0x55ee3bf75aa0 TotalSize=32768 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94481696559249, DataBuffer=0x55ee3bf75aa0, BufferSize=32768, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x55ee3bf75aa0 for FuncKey=94481696559249\nUT_SetDataBuffer EXIT: FuncKey=94481696559249 BasePtr=0x55ee3bf75aa0 TotalSize=32768 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94481696563313, DataBuffer=0x7fff95033230, BufferSize=8, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7fff95033230 for FuncKey=94481696563313\nUT_SetDataBuffer EXIT: FuncKey=94481696563313 BasePtr=0x7fff95033230 TotalSize=8 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94481696563313, DataBuffer=0x7fff95033230, BufferSize=8, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7fff95033230 for FuncKey=94481696563313\nUT_SetDataBuffer EXIT: FuncKey=94481696563313 BasePtr=0x7fff95033230 TotalSize=8 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085052259, DataBuffer=0x7ffc0af92780, BufferSize=32, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92780 for FuncKey=93848085052259\nUT_SetDataBuffer EXIT: FuncKey=93848085052259 BasePtr=0x7ffc0af92780 TotalSize=32 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085052438, DataBuffer=0x7ffc0af92780, BufferSize=32, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92780 for FuncKey=93848085052438\nUT_SetDataBuffer EXIT: FuncKey=93848085052438 BasePtr=0x7ffc0af92780 TotalSize=32 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085052259, DataBuffer=0x7ffc0af92780, BufferSize=32, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92780 for FuncKey=93848085052259\nUT_SetDataBuffer EXIT: FuncKey=93848085052259 BasePtr=0x7ffc0af92780 TotalSize=32 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085051320, DataBuffer=0x7ffc0af92718, BufferSize=4, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92718 for FuncKey=93848085051320\nUT_SetDataBuffer EXIT: FuncKey=93848085051320 BasePtr=0x7ffc0af92718 TotalSize=4 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085051320, DataBuffer=0x7ffc0af92718, BufferSize=4, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92718 for FuncKey=93848085051320\nUT_SetDataBuffer EXIT: FuncKey=93848085051320 BasePtr=0x7ffc0af92718 TotalSize=4 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085051320, DataBuffer=0x7ffc0af92718, BufferSize=4, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92718 for FuncKey=93848085051320\nUT_SetDataBuffer EXIT: FuncKey=93848085051320 BasePtr=0x7ffc0af92718 TotalSize=4 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=93848085051320, DataBuffer=0x7ffc0af92718, BufferSize=4, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc0af92718 for FuncKey=93848085051320\nUT_SetDataBuffer EXIT: FuncKey=93848085051320 BasePtr=0x7ffc0af92718 TotalSize=4 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94165444713627, DataBuffer=0x7ffc706bfea0, BufferSize=12, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc706bfea0 for FuncKey=94165444713627\nUT_SetDataBuffer EXIT: FuncKey=94165444713627 BasePtr=0x7ffc706bfea0 TotalSize=12 Position=0\nUT_SetDataBuffer ENTRY: FuncKey=94165444713627, DataBuffer=0x7ffc706bfea0, BufferSize=12, AllocateCopy=0\nUT_SetDataBuffer INFO: Using external buffer BasePtr=0x7ffc706bfea0 for FuncKey=94165444713627\nUT_SetDataBuffer EXIT: FuncKey=94165444713627 BasePtr=0x7ffc706bfea0 TotalSize=12 Posit\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_SetDataBuffer:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\n#define UT_MODEFLAG_ALLOC_BUF 0x1U\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize) without any verification that the object referenced by DataBuffer is at least BufferSize bytes long. Although the destination is allocated to BufferSize, nothing in UT_SetDataBuffer ensures the source buffer actually contains BufferSize bytes, so a malformed caller-supplied DataBuffer/BufferSize pair can cause memcpy to read beyond the source object bounds (a direct contravention of MISRA C 2023 Rule 21.17). Likewise, when AllocateCopy is false the function records TotalSize = BufferSize for an externally provided buffer; later uses that rely on TotalSize could perform string.h operations that exceed the actual source object size and thus also violate the rule. This would only be acceptable if there is a formally established and verifiable precondition (and proof) that the caller always supplies a valid pointer/size pair; absent that, the usage is non\u2011compliant."
}