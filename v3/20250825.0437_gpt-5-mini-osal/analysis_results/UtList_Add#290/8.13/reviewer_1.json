{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter Data is declared as void * in UtList_Add and is passed to UtList_NewNode(Data, DataSize). If UtList_NewNode only reads from the memory pointed to by Data (i.e. it treats it as input-only), Data should be declared const void * and passed as such. Having Data as a non-const pointer therefore violates MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): 79 58 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): 79 58 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_NewNode: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237930\nAFTER_NewNode: Data[0..16): 79 58 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_Insert: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237930\nAFTER_Insert: Data[0..16): 79 58 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): 41 59 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): 41 59 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_NewNode: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da2379a0\nAFTER_NewNode: Data[0..16): 41 59 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_Insert: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da2379a0\nAFTER_Insert: Data[0..16): 41 59 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): 31 5B 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): 31 5B 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_NewNode: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237a10\nAFTER_NewNode: Data[0..16): 31 5B 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_Insert: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237a10\nAFTER_Insert: Data[0..16): 31 5B 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): 41 5C 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): 41 5C 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_NewNode: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237a80\nAFTER_NewNode: Data[0..16): 41 5C 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_Insert: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237a80\nAFTER_Insert: Data[0..16): 41 5C 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): 1D 5E 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): 1D 5E 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_NewNode: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237af0\nAFTER_NewNode: Data[0..16): 1D 5E 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_Insert: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=0x5568da237af0\nAFTER_Insert: Data[0..16): 1D 5E 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nENTRY: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=(nil) NewNode=(nil)\nENTRY: Data[0..16): F9 5F 5E C1 68 55 00 00 ED 64 5E C1 68 55 00 00\nAFTER_GetHead: ListHead=0x5568da237890 Data=0x7fff34a323a0 DataSize=64 Tag=2 TagHead=0x5568da2378e0 NewNode=(nil)\nAFTER_GetHead: Data[0..16): F9 5F 5E C1 68 55 00 00 ED 64 5E C\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13: a pointer should point to a const-qualified type whenever possible. In the provided UtList_Add implementation the parameter Data is declared as void * but is not modified in this function: it is only forwarded to UtList_NewNode(Data, DataSize). The execution log shows the bytes at Data remain unchanged before and after calls, which supports the view that Data is used as input-only. Therefore, unless UtList_NewNode (or any other callee) legitimately requires a mutable pointer and actually modifies the object, Data should be declared const void * to satisfy Rule 8.13. If UtList_NewNode\u2019s prototype currently takes a non-const void * then the correct remediation is to change the prototype (and all callers) to accept const void * (or, if that is impossible for a justified reason, to document and suppress the deviation). Given the information and evidence provided, Agent A\u2019s report is correct: this is a violation of MISRA C 2023 Rule 8.13 unless there is a justified reason why Data must be non-const."
}