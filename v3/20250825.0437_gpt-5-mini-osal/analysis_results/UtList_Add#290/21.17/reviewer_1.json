{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. memcpy(AllocNode->Node.Data, Data, DataSize) can access beyond object bounds if malloc fails (AllocNode == NULL) or if the caller passes a Data pointer that does not point to at least DataSize bytes. The function does not check the return value of malloc nor validate the source buffer length/NULL, so memcpy may read/write out of bounds (NULL dereference or buffer overrun).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769c930\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769c9a0\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769ca10\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769ca80\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769caf0\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769cb60\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769cbd0\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assigned NewNode->Tag (continuing to insert)\nUtList_Add: UtList_Insert_Before returned (operation complete)\nUtList_Add EXIT: ListHead=0x564a7769c890 Tag=2\n\nUtList_Add ENTRY: ListHead=0x564a7769c890 Data=0x7fffe0711c00 DataSize=64 Tag=2\nUtList_Add: UtList_GetHead returned TagHead=0x564a7769c8e0\nUtList_Add: TagHead != NULL, creating new node with Data=0x7fffe0711c00 DataSize=64\nUtList_Add: UtList_NewNode returned NewNode=0x564a7769cc40\nUtList_Add: about to assign NewNode->Tag = 2 (this may crash if NewNode is NULL)\nUtList_Add: assi\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Add:\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UtList_NewNode calls malloc(...) and then immediately uses memset(AllocNode, 0, sizeof(union NodeAllocator)) and memcpy(AllocNode->Node.Data, Data, DataSize) without checking that AllocNode is non-NULL. If malloc fails, these calls will dereference a NULL pointer and thus perform out-of-bounds accesses via the standard string.h functions, which is exactly what MISRA C 2023 Rule 21.17 prohibits. In addition, memcpy is used with the caller-supplied Data pointer and DataSize without any validation of the source pointer or size; if Data does not point to at least DataSize bytes (or is NULL) this also results in out-of-bounds access. To comply with Rule 21.17, the code must check the result of malloc (and validate the source buffer as appropriate) before calling memset/memcpy (or otherwise ensure the pointer parameters always reference objects of sufficient size)."
}