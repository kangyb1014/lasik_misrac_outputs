{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. UtList_NewNode calls memcpy(AllocNode->Node.Data, Data, DataSize) (and earlier memset(AllocNode,0, sizeof(union))) without validating the pointer/size inputs. This can read/write out of bounds. Example violations: (1) Caller does UtList_Add(&head, &some_uint32, sizeof(uint64_t), tag) \u2014 Data points to a 4\u2011byte object but DataSize==8, so memcpy reads 8 bytes past the source object. (2) Caller passes Data == NULL with DataSize > 0, or malloc returns NULL so AllocNode is NULL \u2014 then memset/memcpy are invoked on an invalid pointer. In these cases the use of memcpy/memset can access beyond the bounds of the objects referenced by their pointer parameters, violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfe930\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfe930\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfe9a0\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfe9a0\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfea10\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfea10\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfea80\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfea80\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfeaf0\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfeaf0\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nAFTER_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfeb60\nINSERT_BEFORE_DONE: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=0x557070bfeb60\nTAGHEAD_EVALUATED: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 Tag=2 TagHead=0x557070bfe8e0 NewNode=(nil)\nINFO: UtList_NewNode returned NULL (allocation failure or other error)\nABOUT_TO_CALL_NewNode: ListHead=0x557070bfe890 Data=0x7ffcd99782c0 DataSize=64 \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_Add:\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n...\nUtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    if (Tag >= ListHead->NumberOfTags)\n    {\n        return NULL;\n    }\n    return &ListHead->Tags[Tag];\n}\n...\nvoid UtList_Insert_Before(UtListNode_t *ExistingNode, UtListNode_t *NewNode)\n{\n    NewNode->Next       = ExistingNode;\n    NewNode->Prev       = ExistingNode->Prev;\n    NewNode->Prev->Next = NewNode;\n    NewNode->Next->Prev = NewNode;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UtList_NewNode uses memset and memcpy without validating pointers or sizes: it does not check the return value of malloc (AllocNode can be NULL, causing memset(NULL,...) and later accesses via AllocNode to be undefined), and it blindly copies DataSize bytes from the caller-supplied Data pointer into the newly allocated buffer. If Data == NULL with DataSize > 0, or if the caller passes a Data pointer to an object smaller than DataSize (e.g. passing &some_uint32 with DataSize == sizeof(uint64_t)), memcpy will read out of bounds of the source object. Both situations are exactly the kind of out-of-bounds access of the objects referenced by pointer parameters that MISRA C 2023 Rule 21.17 forbids. Therefore the agent A's claim of a Rule 21.17 violation is correct."
}