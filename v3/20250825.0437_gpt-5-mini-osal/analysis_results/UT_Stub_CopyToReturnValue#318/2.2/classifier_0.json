{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CopyToReturnValue:\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyToReturnValue:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n...\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n...\nstatic void UT_GenericReadStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    void * buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", void *);\n    size_t nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t CopySize;\n    int32  status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyToLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyToLocal returns zero, this probably means no buffer was supplied,\n         * in which case just generate fill data and pretend it was read.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            memset(buffer, 0, nbytes);\n            status = nbytes;\n        }\n    }\n    else if (status > 0)\n    {\n        /* generate fill data for requested size */\n        memset(buffer, 0, status);\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nstatic void UT_GenericWriteStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t      CopySize;\n    int32       status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = nbytes;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionString(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionString), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionCodeName(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionCodeName), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n...\ntypedef cpuaddr UT_EntryKey_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic void UT_GenericWriteStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t      CopySize;\n    int32       status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = nbytes;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: every operation in UT_GenericWriteStub contributes to observable behavior. The status value passed to UT_Stub_SetReturnValue is either provided by UT_Stub_GetInt32StatusCode or computed from CopySize (which itself is computed from buffer/nbytes). The calls to UT_Hook_GetArgValueByName, UT_Stub_GetInt32StatusCode, UT_Stub_CopyFromLocal and the assignments to status/Copysize all influence the return value, so removing them would change program behaviour. Therefore Rule 2.2 is not violated."
}