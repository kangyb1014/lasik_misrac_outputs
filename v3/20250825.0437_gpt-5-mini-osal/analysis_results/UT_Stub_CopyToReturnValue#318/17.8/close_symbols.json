{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyToReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_GenericReadStub', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_lseek', 'UT_DefaultHandler_OS_IdentifyObject', 'UT_DefaultHandler_OS_QueueGet', 'UT_DefaultHandler_OS_SocketRecvFrom', 'UT_DefaultHandler_OS_SocketSendTo', 'UT_DefaultHandler_OS_TaskGetId', 'UT_DefaultHandler_OS_GetVersionString', 'UT_DefaultHandler_OS_GetVersionCodeName']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_GenericReadStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_read', 'UT_DefaultHandler_OS_TimedRead']}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_lseek': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_IdentifyObject': {'callees': ['UT_Hook_GetArgPtr', 'UT_ObjIdDecompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGet': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'OS_ObjectIdToInteger', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketRecvFrom': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_TaskGetId': {'callees': ['UT_ObjIdCompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionString': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionCodeName': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry (prototype)",
    "UT_StubTableEntry_t (full struct/type definition, including Data.Buff fields: TotalSize, BasePtr, Position)",
    "UT_ENTRYTYPE_RETURN_BUFFER (macro/enum)",
    "UtAssert_Abort (prototype/macro/definition)",
    "memcpy (declaration/macro/definition)",
    "UT_EntryKey_t (typedef)",
    "size_t (typedef/header)"
  ],
  "explanation": "Why each symbol is needed to check the MISRA rule (a function parameter shall not be modified):\n\n- UT_GetStubEntry (prototype): needed to confirm its signature/expansion and to ensure the call cannot modify any of this function's parameters by reference or via macro side-effects. Also to confirm the returned pointer type (UT_StubTableEntry_t *).\n\n- UT_StubTableEntry_t (full struct/type definition, including Data.Buff fields: TotalSize, BasePtr, Position): required to verify that writes performed in this function (memcpy to BasePtr, assignment to Position) do not alias any parameter object (e.g., BufferPtr or FuncKey) and to check types (so we can determine whether any member access could in fact modify a parameter).\n\n- UT_ENTRYTYPE_RETURN_BUFFER (macro/enum): include the definition to ensure the token passed to UT_GetStubEntry does not expand to code with side-effects that could modify parameters.\n\n- UtAssert_Abort (prototype/macro/definition): to check whether this call (or its macro expansion) could alter any of the function parameters (for example via unusual macro expansion or by taking pointers to them). The call site uses a string literal, but the callee/macro must be inspected to be sure.\n\n- memcpy (declaration/macro/definition): needed to confirm the semantics/prototype (source is const void *) so passing BufferPtr does not cause modification of the pointer parameter itself and to detect any nonstandard macro that might reassign BufferPtr.\n\n- UT_EntryKey_t (typedef): to determine the underlying type of FuncKey (scalar vs pointer) so we can reason whether any operations in this function could be modifying a pointer parameter or the object it points to.\n\n- size_t (typedef/header): to confirm BufferSize type and rule applicability (ensure no hidden typedef/macro that would make BufferSize a modifiable object in an unexpected way).\n\nTogether these symbols let the analyzer determine whether any parameter (FuncKey, BufferPtr, BufferSize) is being assigned/modified in this function or indirectly modified via macro expansions or aliasing."
}