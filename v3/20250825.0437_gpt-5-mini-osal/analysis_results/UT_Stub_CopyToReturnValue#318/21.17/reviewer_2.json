{
  "user_message": "An agent A claimed that the following UT_Stub_CopyToReturnValue code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyToReturnValue.\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code does not validate the source pointer or its accessible size before calling memcpy. If BufferPtr is NULL (with BufferSize>0) or BufferPtr actually points to a buffer smaller than BufferSize, the call memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize) will read beyond the bounds of the source object. For example, passing a 4-byte source buffer with BufferSize==8 will cause an out-of-bounds read.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7dc0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c826e20\nStubBuf: BasePtr=0x55de829d69a0, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d69a0, src=0x7ffc799c7dc0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7d5c, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c8233a0\nStubBuf: BasePtr=0x55de829d6a00, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d6a00, src=0x7ffc799c7d5c, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7db0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c82dc60\nStubBuf: BasePtr=0x55de829d6a20, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d6a20, src=0x7ffc799c7db0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7dc0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c826e20\nStubBuf: BasePtr=0x55de829d69a0, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d69a0, src=0x7ffc799c7dc0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7dc0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c826e20\nStubBuf: BasePtr=0x55de829d69a0, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d69a0, src=0x7ffc799c7dc0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7d5c, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c8233a0\nStubBuf: BasePtr=0x55de829d6a00, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d6a00, src=0x7ffc799c7d5c, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7db0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c82dc60\nStubBuf: BasePtr=0x55de829d6a20, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d6a20, src=0x7ffc799c7db0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffc799c7dc0, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55de7c826e20\nStubBuf: BasePtr=0x55de829d69a0, TotalSize=4, Position=0\nAbout to memcpy dest=0x55de829d69a0, src=0x7ffc799c7dc0, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffdd319fc30, BufferSize=8\nUT_GetStubEntry returned StubPtr=0x55b453490600\nStubBuf: BasePtr=0x55b47450cd40, TotalSize=8, Position=0\nAbout to memcpy dest=0x55b47450cd40, src=0x7ffdd319fc30, n=8\nmemcpy completed. New Position=8\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffdd319fc10, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55b45348d480\nStubBuf: BasePtr=0x55b47450cd80, TotalSize=4, Position=0\nAbout to memcpy dest=0x55b47450cd80, src=0x7ffdd319fc10, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffdd319fc80, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55b453486640\nStubBuf: BasePtr=0x55b47450cd60, TotalSize=4, Position=0\nAbout to memcpy dest=0x55b47450cd60, src=0x7ffdd319fc80, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffdd319fc58, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55b45348a9c0\nStubBuf: BasePtr=0x55b47450cd80, TotalSize=4, Position=0\nAbout to memcpy dest=0x55b47450cd80, src=0x7ffdd319fc58, n=4\nmemcpy completed. New Position=4\n--- UT_Stub_CopyToReturnValue EXIT ---\n\n--- UT_Stub_CopyToReturnValue ENTRY ---\nBufferPtr=0x7ffdd319fc58, BufferSize=4\nUT_GetStubEntry returned StubPtr=0x55b45348a9c0\nStubBuf: BasePtr=0x55b47450cd80, TotalSize=4, Position=0\nAbout to memcpy dest=0x55b47450cd80, src=0x7ffdd319fc58, n=4\nmemcpy completed. New Position=4\n--\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyToReturnValue:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n...\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 requires that uses of memcpy (and other string.h functions) must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In UT_Stub_CopyToReturnValue the call memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize) only checks that the destination buffer (StubPtr->Data.Buff.TotalSize) equals BufferSize; there is no validation that BufferPtr is non-NULL when BufferSize>0 or that the source object accessible at BufferPtr is at least BufferSize bytes long. Therefore the memcpy could read beyond the bounds of the source object (or dereference a NULL source) if a caller passes an undersized or NULL source with a non-zero BufferSize. The execution log shows only safe invocations, but that does not eliminate the potential out-of-bounds read in general. Consequently the agent A report is correct: this use of memcpy can violate MISRA C 2023 Rule 21.17. A fix would be to require/verify BufferPtr != NULL when BufferSize>0 and otherwise ensure the source buffer length is sufficient (or document and enforce the precondition)."
}