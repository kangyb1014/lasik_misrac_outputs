{
  "user_message": "Target function code is:\n```c\nint32 OS_TimeBaseCreate_Impl(const OS_object_token_t *token)\n{\n    int32                               return_code;\n    int                                 status;\n    int                                 i;\n    osal_index_t                        idx;\n    struct sigevent                     evp;\n    struct timespec                     ts;\n    OS_impl_timebase_internal_record_t *local;\n    OS_timebase_internal_record_t *     timebase;\n    OS_VoidPtrValueWrapper_t            arg;\n\n    local    = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, *token);\n    timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, *token);\n\n    /*\n     * Spawn a dedicated time base handler thread\n     *\n     * This alleviates the need to handle expiration in the context of a signal handler -\n     * The handler thread can call a BSP synchronized delay implementation as well as the\n     * application callback function.  It should run with elevated priority to reduce latency.\n     *\n     * Note the thread will not actually start running until this function exits and releases\n     * the global table lock.\n     */\n    memset(&arg, 0, sizeof(arg));\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    arg.id      = OS_ObjectIdFromToken(token);\n    return_code = OS_Posix_InternalTaskCreate_Impl(&local->handler_thread, OSAL_PRIORITY_C(0), 0,\n                                                   OS_TimeBasePthreadEntry, arg.opaque_arg);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    local->assigned_signal = 0;\n    clock_gettime(OS_PREFERRED_CLOCK, &local->softsleep);\n\n    /*\n     * Set up the necessary OS constructs\n     *\n     * If an external sync function is used then there is nothing to do here -\n     * we simply call that function and it should synchronize to the time source.\n     *\n     * If no external sync function is provided then this will set up a POSIX\n     * timer to locally simulate the timer tick using the CPU clock.\n     */\n    if (timebase->external_sync == NULL)\n    {\n        sigemptyset(&local->sigset);\n\n        /*\n         * find an RT signal that is not used by another time base object.\n         * This is all done while the global lock is held so no chance of the\n         * underlying tables changing\n         */\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            if (OS_ObjectIdIsValid(OS_global_timebase_table[idx].active_id) &&\n                OS_impl_timebase_table[idx].assigned_signal != 0)\n            {\n                sigaddset(&local->sigset, OS_impl_timebase_table[idx].assigned_signal);\n            }\n        }\n\n        for (i = SIGRTMIN; i <= SIGRTMAX; ++i)\n        {\n            if (!sigismember(&local->sigset, i))\n            {\n                local->assigned_signal = i;\n                break;\n            }\n        }\n\n        do\n        {\n            if (local->assigned_signal == 0)\n            {\n                OS_DEBUG(\"No free RT signals to use for simulated time base\\n\");\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            sigemptyset(&local->sigset);\n            sigaddset(&local->sigset, local->assigned_signal);\n\n            /*\n             * Ensure that the chosen signal is NOT already pending.\n             *\n             * Perform a \"sigtimedwait\" with a zero timeout to poll the\n             * status of the selected signal.  RT signals are also queued,\n             * so this needs to be called in a loop to until sigtimedwait()\n             * returns an error.\n             *\n             * The max number of signals that can be queued is available\n             * via sysconf() as the _SC_SIGQUEUE_MAX value.\n             *\n             * The output is irrelevant here; the objective is to just ensure\n             * that the signal is not already pending.\n             */\n            i = sysconf(_SC_SIGQUEUE_MAX);\n            do\n            {\n                ts.tv_sec  = 0;\n                ts.tv_nsec = 0;\n                if (sigtimedwait(&local->sigset, NULL, &ts) < 0)\n                {\n                    /* signal is NOT pending */\n                    break;\n                }\n                --i;\n            } while (i > 0);\n\n            /*\n            **  Initialize the sigevent structures for the handler.\n            */\n            memset((void *)&evp, 0, sizeof(evp));\n            evp.sigev_notify = SIGEV_SIGNAL;\n            evp.sigev_signo  = local->assigned_signal;\n\n            /*\n             * Pass the Timer Index value of the object ID to the signal handler --\n             *  Note that the upper bits can be safely assumed as a timer ID to recreate the original,\n             *  and doing it this way should still work on a system where sizeof(sival_int) < sizeof(uint32)\n             *  (as long as sizeof(sival_int) >= number of bits in OS_OBJECT_INDEX_MASK)\n             */\n            evp.sigev_value.sival_int = (int)OS_ObjectIdToSerialNumber_Impl(OS_ObjectIdFromToken(token));\n\n            /*\n            ** Create the timer\n            ** Note using the \"MONOTONIC\" clock here as this will still produce consistent intervals\n            ** even if the system clock is stepped (e.g. clock_settime).\n            */\n            status = timer_create(OS_PREFERRED_CLOCK, &evp, &local->host_timerid);\n            if (status < 0)\n            {\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            timebase->external_sync = OS_TimeBase_SigWaitImpl;\n        } while (0);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /*\n         * NOTE about the thread cancellation -- this technically is just a backup,\n         * we should not need to cancel it because the handler thread will exit automatically\n         * if the active ID does not match the expected value.  This check would fail\n         * if this function returns non-success (the ID in the global will be set zero)\n         */\n        pthread_cancel(local->handler_thread);\n        local->assigned_signal = 0;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_TimeBaseCreate_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_ObjectIdFromToken', 'OS_Posix_InternalTaskCreate_Impl', 'OS_ObjectIdIsValid', 'OS_ObjectIdToSerialNumber_Impl'], 'callers': ['OS_TimeBaseCreate']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_ObjectIdFromToken': {'callees': [], 'callers': ['OS_ConsoleCreate_Impl', 'OS_TaskCreate_Impl', 'OS_TimeBaseCreate_Impl', 'OS_ObjectIdConvertToken', 'OS_ObjectIdIteratorProcessEntry', 'OS_TaskFindIdBySystemData', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete']}, 'OS_Posix_InternalTaskCreate_Impl': {'callees': ['OS_PriorityRemap'], 'callers': ['OS_ConsoleCreate_Impl', 'OS_TaskCreate_Impl', 'OS_TimeBaseCreate_Impl']}, 'OS_ObjectIdIsValid': {'callees': [], 'callers': ['OS_TimeBaseCreate_Impl', 'OS_ForEachFilterCreator', 'OS_ObjectIdConvertToken', 'OS_Lock_Global']}, 'OS_ObjectIdToSerialNumber_Impl': {'callees': [], 'callers': ['OS_TimeBaseCreate_Impl', 'OS_ObjectIdFindNextFree', 'OS_ObjectIdToArrayIndex']}, 'OS_TimeBaseCreate': {'callees': ['OS_printf', 'OS_ObjectIdToType_Impl', 'OS_TaskGetId_Impl', 'OS_ObjectIdAllocateNew', 'OS_ObjectIndexFromToken', 'OS_ObjectIdGlobalFromToken', 'OS_TimeBaseCreate_Impl', 'OS_ObjectIdFinalizeNew', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': ['OS_TimerCreate']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_object_token_t",
    "OS_OBJECT_TABLE_GET",
    "OS_ObjectIndexFromToken",
    "OS_ObjectIdFromToken",
    "OS_ObjectIdToSerialNumber_Impl"
  ],
  "explanation": "OS_object_token_t: the typedef/struct layout and const qualification are needed to confirm how the parameter is represented and whether any operations (e.g. dereference *token) could legally modify the object or the pointer itself.\n\nOS_OBJECT_TABLE_GET: this macro is used directly with *token. Macros can expand to assignments or other side-effects that might modify the parameter variable (token) \u2014 the macro definition is required to check whether it writes to or rebinds the token parameter.\n\nOS_ObjectIndexFromToken: the static call graph shows this symbol may be invoked (commonly inside OS_OBJECT_TABLE_GET). If that function/macro accepts the token or *token, its implementation/prototype is needed to ensure it does not perform any assignment to the token parameter or otherwise modify the caller's parameter variable.\n\nOS_ObjectIdFromToken: called directly with token. If this is a macro or an inline function it might modify the parameter name via expansion; its prototype/definition is required to verify it does not assign to the token parameter variable (or call another routine that does so through a pointer-to-pointer).\n\nOS_ObjectIdToSerialNumber_Impl: although it receives the result of OS_ObjectIdFromToken rather than token directly, its presence is listed in the call graph and could be implemented as a macro or inline that references token via nested macros. Including its definition ensures no indirect macro expansion or nested call chain ends up assigning to the token parameter.\n\n(These symbols together allow inspection of macro expansions and callee signatures/definitions to determine if any of them perform assignments to the function parameter variable 'token' \u2014 the crux of the MISRA rule check.)"
}