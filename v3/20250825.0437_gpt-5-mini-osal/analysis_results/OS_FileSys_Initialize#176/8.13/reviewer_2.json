{
  "user_message": "An agent A claimed that the following OS_FileSys_Initialize code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSys_Initialize.\n```c\nint32 OS_FileSys_Initialize(char *address, const char *fsdevname, const char *fsvolname, size_t blocksize,\n                            osal_blockcount_t numblocks, bool should_format)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n\n    /*\n     * Check parameters\n     *\n     * Note \"address\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_STRING(fsdevname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(fsvolname, sizeof(filesys->volume_name), OS_FS_ERR_PATH_TOO_LONG);\n\n    /* check names are not empty strings */\n    if (fsdevname[0] == 0 || fsvolname[0] == 0)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, fsdevname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, fsdevname);\n\n        /* populate the VolumeName and BlockSize ahead of the Impl call,\n         * so the implementation can reference this info if necessary */\n        filesys->blocksize = blocksize;\n        filesys->numblocks = numblocks;\n        filesys->address   = address;\n        strncpy(filesys->volume_name, fsvolname, sizeof(filesys->volume_name) - 1);\n\n        /*\n         * Determine basic type of filesystem, if not already known\n         *\n         * if either an address was supplied, or if the volume name\n         * contains the string \"RAM\" then it is a RAM disk. Otherwise\n         * leave the type as UNKNOWN and let the implementation decide.\n         */\n        if (filesys->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n            (filesys->address != NULL || strncmp(filesys->volume_name, OS_FILESYS_RAMDISK_VOLNAME_PREFIX,\n                                                 sizeof(OS_FILESYS_RAMDISK_VOLNAME_PREFIX) - 1) == 0))\n        {\n            filesys->fstype = OS_FILESYS_TYPE_VOLATILE_DISK;\n        }\n\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * The \"mkfs\" call also formats the device.\n             * this is the primary difference between mkfs and initfs.\n             */\n            if (should_format)\n            {\n                return_code = OS_FileSysFormatVolume_Impl(&token);\n            }\n\n            if (return_code == OS_SUCCESS)\n            {\n                filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            }\n            else\n            {\n                /*\n                 * To avoid leaving in an intermediate state,\n                 * this also stops the volume if formatting failed.\n                 * Cast to void to repress analysis warnings for\n                 * ignored return value.\n                 */\n                (void)OS_FileSysStopVolume_Impl(&token);\n            }\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter and record field 'address' are declared as char * even though in the shown code they are only stored and compared (not modified). This allows callers to pass const data only by casting away const, and permits accidental modification later. Example violation: a caller has const char *rom_address (e.g. a pointer into read-only memory or a string literal) and must cast to char * to call OS_FileSys_Initialize; if the implementation ever writes through filesys->address this would be undefined behavior. The pointer should be declared const char * (and filesys->address made const) if the pointed-to data is not intended to be modified.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nOS_FileSys_Initialize ENTRY: address=(nil), fsdevname='/ramdev3', fsvolname='RAM3', blocksize=512, numblocks=20, should_format=1\nOS_ObjectIdAllocateNew returned -35\nOS_FileSys_Initialize EXIT: return_code=-35\nOS_FileSys_Initialize ENTRY: address=(nil), fsdevname='/ramdev3', fsvolname='RAM3', blocksize=512, numblocks=20, should_format=1\nOS_ObjectIdAllocateNew returned -35\nOS_FileSys_Initialize EXIT: return_code=-35\nOS_FileSys_Initialize ENTRY: address=(nil), fsdevname='/ramdev3', fsvolname='RAM3', blocksize=512, numblocks=20, should_format=1\nOS_ObjectIdAllocateNew returned -35\nOS_FileSys_Initialize EXIT: return_code=-35\nOS_FileSys_Initialize ENTRY: address=(nil), fsdevname='/ramdev3', fsvolname='RAM3', blocksize=512, numblocks=64, should_format=1\nOS_ObjectIdAllocateNew returned -35\nOS_FileSys_Initialize EXIT: return_code=-35\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileSys_Initialize:\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n...\nint32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n{\n    osal_id_t final_id;\n\n    /* if operation was unsuccessful, then clear\n     * the active_id field within the record, so\n     * the record can be re-used later.\n     *\n     * Otherwise, ensure that the record_id to be\n     * exported is sane (it always should be)\n     */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = token->obj_id;\n    }\n    else\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n    }\n\n    if (outid != NULL)\n    {\n        /* always write the final value to the output buffer */\n        *outid = final_id;\n    }\n\n    return operation_status;\n}\n...\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    break;\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n...\nint32 OS_FileSysFormatVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * In theory, this should wipe any existing files in the ramdisk,\n     * but since ramdisks here are implemented using a directory within a tmpfs,\n     * removal of such files could be risky if something goes wrong,\n     * because it might remove files that were important.\n     *\n     * So the safest option is just a no-op.\n     * (this is also backward compatible since POSIX mkfs was always a no-op)\n     */\n    return OS_SUCCESS;\n}\n...\nint32 OS_FileSysStopVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * This is a no-op.\n     *\n     * Volatile volumes are just directories created in the temp dir,\n     * and this will not remove the directories just in case something\n     * went wrong.\n     *\n     * If the volume is started again, the directory will be re-used.\n     */\n    return OS_SUCCESS;\n}\n...\n#define OS_CHECK_STRING(str, maxlen, errcode) do{OS_CHECK_POINTER(str);LENGTHCHECK(str,maxlen,errcode);}while(0)\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_OBJECT_INIT(tok, ref, namefield, nameval) {memset(ref,0,sizeof(*ref));strncpy(ref->namefield,nameval,sizeof(ref->namefield)-1);OS_ObjectIdGlobalFromToken(&tok)->name_entry=ref->namefield;}\n...\nOS_filesys_internal_record_t OS_filesys_table[LOCAL_NUM_OBJECTS]\n...\nconst char OS_FILESYS_RAMDISK_VOLNAME_PREFIX[] = \"RAM\"\n...\n#define OS_FILESYS_FLAG_IS_READY 0x02\n...\n#define OS_FS_ERR_PATH_TOO_LONG (-103)\n...\n#define OS_FS_ERR_PATH_INVALID (-108)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 R8.13 encourages using pointers-to-const when the pointed-to object is never modified, but it is a guideline that must be judged in context. In this code the parameter 'address' is immediately stored in the filesys record field filesys->address, and that field is declared as char * (non-const). That indicates the design intentionally permits future writes through that pointer (e.g. an implementation or driver that treats it as the base of a RAM disk and writes into it). Because the pointer is propagated into a non-const storage location and may be used elsewhere for mutable access, declaring the parameter as const char * would be incorrect for the intended API. If, conversely, the entire system truly never writes through that pointer, then making it const would be appropriate \u2014 but that cannot be established from the excerpt alone. Given the visible declarations and intended semantics, the agent A report is not correct: this is not necessarily a violation of R8.13 in context."
}