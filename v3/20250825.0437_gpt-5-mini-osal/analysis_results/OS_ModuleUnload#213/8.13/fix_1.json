{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    /* Helper probe: append trace lines to /tmp/logs/2133.txt.  This routine\n     * is intentionally lightweight and does not change program logic. */\n    static void OS_ModuleUnload_Log(const char *stage,\n                                     OS_module_internal_record_t *mod_ptr,\n                                     const OS_object_token_t *tok_ptr,\n                                     int32 rc)\n    {\n        FILE *fp = fopen(\"/tmp/logs/2133.txt\", \"a\");\n        if (fp != NULL)\n        {\n            /* Print stage, return code, token address (token value may be\n             * an integer or struct; printing its address provides a stable\n             * trace without assuming its concrete type), module pointer and\n             * module->module_type when available. */\n            fprintf(fp, \"[OS_ModuleUnload] stage=%s rc=%d token_addr=%p module_ptr=%p\",\n                    stage, (int)rc, (const void *)tok_ptr, (const void *)mod_ptr);\n\n            if (mod_ptr != NULL)\n            {\n                /* module_type is read-only here; log its value. Cast to int\n                 * for safe printing regardless of underlying enum type. */\n                fprintf(fp, \" module_type=%d\", (int)mod_ptr->module_type);\n            }\n\n            fprintf(fp, \"\\n\");\n            fclose(fp);\n        }\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of id lookup */\n    OS_ModuleUnload_Log(\"after_ObjectIdGetById\", NULL, &token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /* Log after obtaining module pointer from object table */\n        OS_ModuleUnload_Log(\"after_OBJECT_TABLE_GET\", module, &token, return_code);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            OS_ModuleUnload_Log(\"before_ModuleUnload_Impl_dynamic\", module, &token, return_code);\n            return_code = OS_ModuleUnload_Impl(&token);\n            OS_ModuleUnload_Log(\"after_ModuleUnload_Impl\", module, &token, return_code);\n        }\n        else\n        {\n            OS_ModuleUnload_Log(\"skip_unload_not_dynamic\", module, &token, return_code);\n        }\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Log finalization result */\n        OS_ModuleUnload_Log(\"after_ObjectIdFinalizeDelete\", module, &token, return_code);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp3q_lvu6x/src/src/os/shared/src/osapi-module.c: In function 'OS_ModuleUnload':\n/tmp/tmp3q_lvu6x/src/src/os/shared/src/osapi-module.c:279:17: error: invalid storage class for function 'OS_ModuleUnload_Log'\n  279 |     static void OS_ModuleUnload_Log(const char *stage,\n      |                 ^~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:230: CMakeFiles/osal.dir/src/os/shared/src/osapi-module.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_ModuleUnload as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of id lookup */\n    OS_ModuleUnload_Log(\"after_ObjectIdGetById\", NULL, &token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /* Log after obtaining module pointer from object table */\n        OS_ModuleUnload_Log(\"after_OBJECT_TABLE_GET\", module, &token, return_code);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            OS_ModuleUnload_Log(\"before_ModuleUnload_Impl_dynamic\", module, &token, return_code);\n            return_code = OS_ModuleUnload_Impl(&token);\n            OS_ModuleUnload_Log(\"after_ModuleUnload_Impl\", module, &token, return_code);\n        }\n        else\n        {\n            OS_ModuleUnload_Log(\"skip_unload_not_dynamic\", module, &token, return_code);\n        }\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Log finalization result */\n        OS_ModuleUnload_Log(\"after_ObjectIdFinalizeDelete\", module, &token, return_code);\n    }\n\n    return return_code;\n}\n\n/* Helper probe: append trace lines to /tmp/logs/2133.txt.  This routine\n * is intentionally lightweight and does not change program logic. Placed at\n * file scope because nested functions are not valid in standard C. */\nstatic void OS_ModuleUnload_Log(const char *stage,\n                                 OS_module_internal_record_t *mod_ptr,\n                                 const OS_object_token_t *tok_ptr,\n                                 int32 rc)\n{\n    FILE *fp = fopen(\"/tmp/logs/2133.txt\", \"a\");\n    if (fp != NULL)\n    {\n        /* Print stage, return code, token address (token value may be\n         * an integer or struct; printing its address provides a stable\n         * trace without assuming its concrete type), module pointer and\n         * module->module_type when available. */\n        fprintf(fp, \"[OS_ModuleUnload] stage=%s rc=%d token_addr=%p module_ptr=%p\",\n                stage, (int)rc, (const void *)tok_ptr, (const void *)mod_ptr);\n\n        if (mod_ptr != NULL)\n        {\n            /* module_type is read-only here; log its value. Cast to int\n             * for safe printing regardless of underlying enum type. */\n            fprintf(fp, \" module_type=%d\", (int)mod_ptr->module_type);\n        }\n\n        fprintf(fp, \"\\n\");\n        fclose(fp);\n    }\n}\n",
  "explanation": "The compile error was caused by defining a function (OS_ModuleUnload_Log) inside another function (OS_ModuleUnload), which is not allowed in standard C. I moved the helper function to file scope (below OS_ModuleUnload) and made it static to preserve internal linkage. I also added #include <stdio.h> so FILE and I/O functions are available. The original logic and call sites are unchanged."
}