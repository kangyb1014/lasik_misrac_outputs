{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call memset(token, 0, sizeof(*token)) writes sizeof(OS_object_token_t) bytes starting at the address in token. If token is NULL or points to an object smaller than OS_object_token_t (or otherwise invalid), this will write beyond the bounds of the referenced object. For example, if OS_ObjectIdTransactionInit is invoked with token == NULL (or with a pointer to a smaller/incorrectly typed buffer), the memset will perform an out-of-bounds write (NULL dereference), violating Rule 21.17. Note: the specific call path shown (OS_ModuleUnload -> OS_ObjectIdGetById -> OS_ObjectIdTransactionInit) passes a local OS_object_token_t variable address and is safe, but the function itself lacks a pointer validity check and is therefore vulnerable in other call scenarios.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ModuleUnload code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2139.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ModuleUnload as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ModuleUnload:\n```c\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            return_code = OS_ModuleUnload_Impl(&token);\n        }\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ModuleUnload code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <unistd.h>\n\n/* Probe logging helper: append human-readable logs to /tmp/logs/2139.txt */\nstatic void OS_ModuleUnload_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2139.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    time_t t = time(NULL);\n    pid_t pid = getpid();\n\n    fprintf(f, \"[%ld] pid=%d: \", (long)t, (int)pid);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    /* Log entry and input */\n    OS_ModuleUnload_Log(\"Enter OS_ModuleUnload: module_id=%lld\", (long long)module_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of lookup and token address/size (do not dereference token) */\n    OS_ModuleUnload_Log(\"OS_ObjectIdGetById returned %d, token_addr=%p, token_size=%zu\",\n                        (int)return_code, (void *)&token, sizeof(token));\n\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /* Log the module pointer we obtained (do not read fields here to avoid changing behavior) */\n        OS_ModuleUnload_Log(\"OS_OBJECT_TABLE_GET returned module_ptr=%p\", (void *)module);\n\n        /* Only call the implementation if the file was actually loaded.\n         * Preserve the original dereference behaviour: the condition below\n         * reads module->module_type exactly as in the original code. */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            OS_ModuleUnload_Log(\"module->module_type == OS_MODULE_TYPE_DYNAMIC; calling OS_ModuleUnload_Impl with token_addr=%p\",\n                                (void *)&token);\n\n            return_code = OS_ModuleUnload_Impl(&token);\n\n            OS_ModuleUnload_Log(\"OS_ModuleUnload_Impl returned %d\", (int)return_code);\n        }\n        else\n        {\n            OS_ModuleUnload_Log(\"module->module_type != OS_MODULE_TYPE_DYNAMIC; skipping OS_ModuleUnload_Impl\");\n        }\n\n        /* Complete the operation via the common routine */\n        OS_ModuleUnload_Log(\"Calling OS_ObjectIdFinalizeDelete with return_code=%d, token_addr=%p\",\n                            (int)return_code, (void *)&token);\n\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        OS_ModuleUnload_Log(\"OS_ObjectIdFinalizeDelete returned %d\", (int)return_code);\n    }\n    else\n    {\n        OS_ModuleUnload_Log(\"OS_ObjectIdGetById failed with code %d; nothing to finalize\", (int)return_code);\n    }\n\n    OS_ModuleUnload_Log(\"Exit OS_ModuleUnload with return_code=%d\", (int)return_code);\n    return return_code;\n}\n"
}