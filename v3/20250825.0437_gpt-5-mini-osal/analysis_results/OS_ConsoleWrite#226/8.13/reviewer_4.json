{
  "user_message": "An agent A claimed that the following OS_ConsoleWrite code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ConsoleWrite.\n```c\nint32 OS_ConsoleWrite(osal_id_t console_id, const char *Str)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_console_internal_record_t *console;\n    size_t                        PendingWritePos;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONSOLE, console_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        console = OS_OBJECT_TABLE_GET(OS_console_table, token);\n\n        /*\n         * The entire string should be put to the ring buffer,\n         * or none of it.  Therefore the WritePos in the table\n         * is not updated until complete success.\n         */\n        PendingWritePos = console->WritePos;\n\n        if (console->device_name[0] != 0)\n        {\n            return_code = OS_Console_CopyOut(console, console->device_name, &PendingWritePos);\n        }\n        if (return_code == OS_SUCCESS)\n        {\n            return_code = OS_Console_CopyOut(console, Str, &PendingWritePos);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* the entire message was successfully written */\n            console->WritePos = PendingWritePos;\n        }\n        else\n        {\n            /* the message did not fit */\n            ++console->OverflowEvents;\n        }\n\n        /*\n         * Notify the underlying console implementation of new data.\n         * This will forward the data to the actual console device.\n         *\n         * This is done while still locked, so it can support\n         * either a synchronous or asynchronous implementation.\n         */\n        if (console->IsAsync)\n        {\n            /* post the sem for the utility task to run */\n            OS_ConsoleWakeup_Impl(&token);\n        }\n        else\n        {\n            /* output directly */\n            OS_ConsoleOutput_Impl(&token);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the implementation OS_ConsoleOutput_Impl has the prototype OS_ConsoleOutput_Impl(OS_object_token_t *token) but does not modify the token, then the call OS_ConsoleOutput_Impl(&token) violates MISRA C 2023 Rule 8.13. In that case the parameter should be declared as const OS_object_token_t * to indicate it is not modified. Without the function prototype/implementation it cannot be proven safe; if the function legitimately modifies the token then no violation occurs.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not verifiable from the snippet and so is not correct as presented. MISRA 8.13 requires pointers to be declared to point to const if the pointee is not modified. That requirement applies to the function declaration/definition (the callee), not to the act of passing &token at the call site. From the code shown we cannot tell the prototype or implementation of OS_ConsoleOutput_Impl (or OS_ConsoleWakeup_Impl). If those functions are declared/defined as taking OS_object_token_t * but in fact do not modify the token, then the function declaration/definition would be non-compliant with 8.13 and should be changed to take const OS_object_token_t *. Conversely, if the functions legitimately modify the token (or the API is designed to allow modification), then the non-const parameter is appropriate and there is no violation. Therefore the report claiming a violation based only on the call is not correct \u2014 you must inspect the callee prototypes/definitions to determine a real 8.13 violation."
}