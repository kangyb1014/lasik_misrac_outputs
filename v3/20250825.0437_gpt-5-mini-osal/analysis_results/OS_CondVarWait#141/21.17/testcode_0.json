{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to memset(token, 0, sizeof(*token)) can write bytes beyond the bounds of the object referenced by token if token is invalid. For example, if OS_ObjectIdTransactionInit is ever called with token == NULL (or with a pointer to a smaller/incorrectly sized object), the memset will attempt to write sizeof(OS_object_token_t) bytes at an invalid location (NULL or outside the actual object), causing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CondVarWait code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1419.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CondVarWait as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CondVarWait:\n```c\nint32 OS_CondVarWait(osal_id_t var_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_CondVarWait_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CondVarWait code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Probe logging helpers for reproducing potential out-of-bounds scenario. */\nstatic void OS_1419_log_entry(unsigned long long var_id)\n{\n    FILE *f = fopen(\"/tmp/logs/1419.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"OS_CondVarWait ENTRY: var_id=%llu\\n\", var_id);\n        fclose(f);\n    }\n}\n\n/* Log the result of OS_ObjectIdGetById and a hex dump of the token when available. */\nstatic void OS_1419_log_after_get(long long return_code, void *token_ptr, size_t token_size)\n{\n    FILE *f = fopen(\"/tmp/logs/1419.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"OS_CondVarWait after OS_ObjectIdGetById: return_code=%lld, token_addr=%p, token_size=%zu\\n\",\n                return_code, token_ptr, token_size);\n\n        if ((return_code == 0) && (token_ptr != NULL)) /* assume OS_SUCCESS == 0 in typical OSAL */\n        {\n            unsigned char *p = (unsigned char *)token_ptr;\n            size_t i;\n            fprintf(f, \" token_bytes:\");\n            for (i = 0; i < token_size; ++i)\n            {\n                /* print each byte of the token as hex */\n                fprintf(f, \" %02x\", (unsigned int)p[i]);\n            }\n            fprintf(f, \"\\n\");\n        }\n\n        fclose(f);\n    }\n}\n\nstatic void OS_1419_log_before_impl(void *token_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/1419.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"OS_CondVarWait: about to call OS_CondVarWait_Impl with token=%p\\n\", token_ptr);\n        fclose(f);\n    }\n}\n\nstatic void OS_1419_log_after_impl(long long return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1419.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"OS_CondVarWait: returned from OS_CondVarWait_Impl return_code=%lld\\n\", return_code);\n        fclose(f);\n    }\n}\n\n/*\n * The original function with inserted probes. The original logic is preserved.\n * Note: types like OS_object_token_t, osal_id_t, and int32 are assumed to be\n * defined elsewhere in the build environment. The probes use generic casts so\n * they don't require redefinition of those types here.\n */\nint32 OS_CondVarWait(osal_id_t var_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Entry probe */\n    OS_1419_log_entry((unsigned long long)var_id);\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n\n    /* Log result of the get-by-id and a safe hex-dump only if the call succeeded. */\n    OS_1419_log_after_get((long long)return_code, (void *)&token, sizeof(token));\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log just before calling the implementation */\n        OS_1419_log_before_impl((void *)&token);\n\n        return_code = OS_CondVarWait_Impl(&token);\n\n        /* Log after impl returns */\n        OS_1419_log_after_impl((long long)return_code);\n    }\n\n    return return_code;\n}\n"
}