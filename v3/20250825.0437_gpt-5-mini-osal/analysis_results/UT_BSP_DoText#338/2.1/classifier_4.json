{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_BSP_DoText:\n```c\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_BSP_DoText:\n#define OS_BSP_CONSOLEMODE_NORMAL 0x0\n...\n#define OS_BSP_CONSOLEMODE_HIGHLIGHT 0x8\n...\n#define OS_BSP_CONSOLEMODE_RED 0x1\n...\n#define OS_BSP_CONSOLEMODE_GREEN 0x2\n...\n#define OS_BSP_CONSOLEMODE_BLUE 0x4\n...\nvoid UT_BSP_StartTestSegment(uint32 SegmentNumber, const char *SegmentName)\n{\n    char ReportBuffer[128];\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u %s\", (unsigned int)SegmentNumber, SegmentName);\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, ReportBuffer);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MsgEnabled & 1)\n{\n    UT_BSP_Lock();\n\n    /* Determine if the message type warrants special treatment (color/highlight/etc). */\n    switch (MessageType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n        case UTASSERT_CASETYPE_FAILURE:\n            TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n            break;\n        case UTASSERT_CASETYPE_MIR:\n        case UTASSERT_CASETYPE_WARN:\n            TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n            break;\n        case UTASSERT_CASETYPE_TSF:\n        case UTASSERT_CASETYPE_TTF:\n            TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n            break;\n        default:\n            break;\n    }\n\n    if (MsgEnabled <= 1)\n    {\n        TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    }\n\n    snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n    if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n    {\n        OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n    }\n\n    OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n    if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n    {\n        OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n    }\n\n    OS_BSP_ConsoleOutput_Impl(\" \", 1);\n    MsgLen = strlen(OutputMessage);\n    OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n    if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n    {\n        OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n    }\n\n    UT_BSP_Unlock();\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. Every statement in the fragment can be reached at run time depending on MessageType and BSP_UT_Global.CurrVerbosity. For example, if BSP_UT_Global.CurrVerbosity has bit MessageType set (e.g. BSP_UT_Global.CurrVerbosity == (1u << UTASSERT_CASETYPE_ABORT)) then MsgEnabled = 1 and the outer if (MsgEnabled & 1) is true. With MessageType == UTASSERT_CASETYPE_ABORT the switch arm will be taken, snprintf and the subsequent console output calls and UT_BSP_Unlock() will execute. The final if (MessageType == UTASSERT_CASETYPE_ABORT) outside the shown fragment will also execute, calling OS_BSP_Shutdown_Impl(). Other MessageType values (BEGIN, PASS, WARN, etc.) will exercise the other switch arms and the conditional TermModeBits branches. No compile-time or logically unreachable statements are present in the fragment."
}