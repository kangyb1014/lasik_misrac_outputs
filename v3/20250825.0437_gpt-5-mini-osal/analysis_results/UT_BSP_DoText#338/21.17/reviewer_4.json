{
  "user_message": "An agent A claimed that the following UT_BSP_DoText code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_DoText.\n```c\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strlen(OutputMessage) can read past the bounds of the object referenced by OutputMessage if that pointer is NULL or does not point to a null-terminated character array. UT_BSP_DoText does not validate that OutputMessage is non-NULL or NUL-terminated before calling strlen. Example violating scenario: a caller passes a pointer to a non-terminated buffer (e.g. char buf[4] = {'a','b','c','d'}; UT_BSP_DoText(..., buf);) or passes NULL \u2014 strlen(OutputMessage) will access memory beyond the object bounds (or dereference NULL), violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_BSP_DoText ENTER: MessageType=8, OutputMessage=0x55d3e2b61ee9, CurrVerbosity=4095, MsgEnabled(before mask)=15\nPrepared Buffer=[BEGIN] (addr=0x7ffc3876e110)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x55d3e2b61ee9\nComputed MsgLen=9 for OutputMessage=0x55d3e2b61ee9\nUT_BSP_DoText: finished output for MessageType=8\nUT_BSP_DoText EXIT: MessageType=8\nUT_BSP_DoText ENTER: MessageType=8, OutputMessage=0x7ffc3876e090, CurrVerbosity=4095, MsgEnabled(before mask)=15\nPrepared Buffer=[BEGIN] (addr=0x7ffc3876e050)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876e090\nComputed MsgLen=8 for OutputMessage=0x7ffc3876e090\nUT_BSP_DoText: finished output for MessageType=8\nUT_BSP_DoText EXIT: MessageType=8\nUT_BSP_DoText ENTER: MessageType=9, OutputMessage=0x55d3e2b61878, CurrVerbosity=4095, MsgEnabled(before mask)=7\nPrepared Buffer=[  END] (addr=0x7ffc3876e080)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x55d3e2b61878\nComputed MsgLen=14 for OutputMessage=0x55d3e2b61878\nUT_BSP_DoText: finished output for MessageType=9\nUT_BSP_DoText EXIT: MessageType=9\nUT_BSP_DoText ENTER: MessageType=8, OutputMessage=0x7ffc3876e060, CurrVerbosity=4095, MsgEnabled(before mask)=15\nPrepared Buffer=[BEGIN] (addr=0x7ffc3876e020)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876e060\nComputed MsgLen=33 for OutputMessage=0x7ffc3876e060\nUT_BSP_DoText: finished output for MessageType=8\nUT_BSP_DoText EXIT: MessageType=8\nUT_BSP_DoText ENTER: MessageType=13, OutputMessage=0x7ffc3876dc00, CurrVerbosity=4095, MsgEnabled(before mask)=0\nUT_BSP_DoText EXIT: MessageType=13\nUT_BSP_DoText ENTER: MessageType=11, OutputMessage=0x7ffc3876dd60, CurrVerbosity=4095, MsgEnabled(before mask)=1\nPrepared Buffer=[ PASS] (addr=0x7ffc3876dcf0)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876dd60\nComputed MsgLen=96 for OutputMessage=0x7ffc3876dd60\nUT_BSP_DoText: finished output for MessageType=11\nUT_BSP_DoText EXIT: MessageType=11\nUT_BSP_DoText ENTER: MessageType=10, OutputMessage=0x7ffc3876dfd0, CurrVerbosity=4095, MsgEnabled(before mask)=3\nPrepared Buffer=[ INFO] (addr=0x7ffc3876df90)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876dfd0\nComputed MsgLen=82 for OutputMessage=0x7ffc3876dfd0\nUT_BSP_DoText: finished output for MessageType=10\nUT_BSP_DoText EXIT: MessageType=10\nUT_BSP_DoText ENTER: MessageType=9, OutputMessage=0x7ffc3876dfd0, CurrVerbosity=4095, MsgEnabled(before mask)=7\nPrepared Buffer=[  END] (addr=0x7ffc3876df90)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876dfd0\nComputed MsgLen=102 for OutputMessage=0x7ffc3876dfd0\nUT_BSP_DoText: finished output for MessageType=9\nUT_BSP_DoText EXIT: MessageType=9\nUT_BSP_DoText ENTER: MessageType=8, OutputMessage=0x7ffc3876e060, CurrVerbosity=4095, MsgEnabled(before mask)=15\nPrepared Buffer=[BEGIN] (addr=0x7ffc3876e020)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen = strlen(OutputMessage); OutputMessage=0x7ffc3876e060\nComputed MsgLen=23 for OutputMessage=0x7ffc3876e060\nUT_BSP_DoText: finished output for MessageType=8\nUT_BSP_DoText EXIT: MessageType=8\nUT_BSP_DoText ENTER: MessageType=13, OutputMessage=0x7ffc3876dbe0, CurrVerbosity=4095, MsgEnabled(before mask)=0\nUT_BSP_DoText EXIT: MessageType=13\nUT_BSP_DoText ENTER: MessageType=11, OutputMessage=0x7ffc3876dd40, CurrVerbosity=4095, MsgEnabled(before mask)=1\nPrepared Buffer=[ PASS] (addr=0x7ffc3876dcd0)\nAbout to output Buffer via OS_BSP_ConsoleOutput_Impl; strlen(Buffer)=7\nAbout to compute MsgLen =\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_BSP_DoText:\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    const char *AbbrevStr;\n\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_ABORT:\n            AbbrevStr = \"ABORT\";\n            break;\n        case UTASSERT_CASETYPE_FAILURE:\n            AbbrevStr = \"FAIL\";\n            break;\n        case UTASSERT_CASETYPE_MIR:\n            AbbrevStr = \"MIR\";\n            break;\n        case UTASSERT_CASETYPE_TSF:\n            AbbrevStr = \"TSF\";\n            break;\n        case UTASSERT_CASETYPE_TTF:\n            AbbrevStr = \"TTF\";\n            break;\n        case UTASSERT_CASETYPE_WARN:\n            AbbrevStr = \"WARN\";\n            break;\n        case UTASSERT_CASETYPE_NA:\n            AbbrevStr = \"N/A\";\n            break;\n        case UTASSERT_CASETYPE_BEGIN:\n            AbbrevStr = \"BEGIN\";\n            break;\n        case UTASSERT_CASETYPE_END:\n            AbbrevStr = \"END\";\n            break;\n        case UTASSERT_CASETYPE_PASS:\n            AbbrevStr = \"PASS\";\n            break;\n        case UTASSERT_CASETYPE_INFO:\n            AbbrevStr = \"INFO\";\n            break;\n        case UTASSERT_CASETYPE_FLOW:\n            AbbrevStr = \"FLOW\";\n            break;\n        case UTASSERT_CASETYPE_DEBUG:\n            AbbrevStr = \"DEBUG\";\n            break;\n        default:\n            /* do not return NULL, as the result may be directly passed to C library functions */\n            AbbrevStr = \"OTHER\";\n            break;\n    }\n\n    return AbbrevStr;\n}\n...\nvoid UT_BSP_StartTestSegment(uint32 SegmentNumber, const char *SegmentName)\n{\n    char ReportBuffer[128];\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u %s\", (unsigned int)SegmentNumber, SegmentName);\n    UT_BSP_DoText(UTASSERT_CASETYPE_BEGIN, ReportBuffer);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UT_BSP_DoText calls strlen(OutputMessage) without validating that OutputMessage is non-NULL and points to a null-terminated character array. If a caller passes NULL or a buffer that is not NUL-terminated (e.g. char buf[4] = {'a','b','c','d'}), strlen will read beyond the bounds of the object (or dereference NULL), which is exactly what MISRA C 2023 Rule 21.17 forbids. Although some call sites shown (e.g. UT_BSP_StartTestSegment using a snprintf-produced ReportBuffer) produce NUL-terminated strings, the function itself makes no guarantees or checks and therefore can be invoked with unsafe pointers. To comply with Rule 21.17 the function must ensure the operand to strlen cannot cause an out-of-bounds access (for example, check for NULL and use a bounded length/version such as strnlen with a documented maximum, or otherwise enforce/document and statically guarantee that callers always pass valid NUL-terminated strings)."
}