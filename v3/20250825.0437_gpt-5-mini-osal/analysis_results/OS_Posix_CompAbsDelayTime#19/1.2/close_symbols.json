{
  "user_message": "Target function code is:\n```c\nvoid OS_Posix_CompAbsDelayTime(uint32 msecs, struct timespec *tm)\n{\n    clock_gettime(CLOCK_REALTIME, tm);\n\n    /* add the delay to the current time */\n    tm->tv_sec += (time_t)(msecs / 1000);\n    /* convert residue ( msecs )  to nanoseconds */\n    tm->tv_nsec += (msecs % 1000) * 1000000L;\n\n    if (tm->tv_nsec >= 1000000000L)\n    {\n        tm->tv_nsec -= 1000000000L;\n        tm->tv_sec++;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_Posix_CompAbsDelayTime': {'callees': [], 'callers': ['OS_BinSemTimedWait_Impl', 'OS_CountSemTimedWait_Impl', 'OS_QueueGet_Impl']}, 'OS_BinSemTimedWait_Impl': {'callees': ['OS_Posix_CompAbsDelayTime', 'OS_GenericBinSemTake_Impl'], 'callers': ['OS_BinSemTimedWait']}, 'OS_CountSemTimedWait_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_Posix_CompAbsDelayTime'], 'callers': ['OS_CountSemTimedWait']}, 'OS_QueueGet_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_Posix_CompAbsDelayTime'], 'callers': ['OS_QueueGet']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "uint32",
    "struct timespec",
    "time_t",
    "clock_gettime",
    "CLOCK_REALTIME",
    "tv_sec",
    "tv_nsec"
  ],
  "explanation": "To determine whether the function uses any compiler language extensions you must know the precise definitions/declarations of the types/macros/functions used in the code:\n\n- uint32: the typedef for the msecs parameter. Needed to check whether this is a standard typedef (e.g. from stdint.h) or a compiler-specific/extension type (e.g. a compiler builtin typedef). If it is a nonstandard compiler extension, that would be relevant to the MISRA rule.\n\n- struct timespec: the complete struct definition is required to confirm that its fields are standard, not compiler extensions, and to see the member types (tv_sec/tv_nsec) and their types/widths.\n\n- time_t: the underlying type of time_t must be known to verify that the cast (time_t)(...) is to a standard type and not to a compiler-specific extended type.\n\n- clock_gettime: the function prototype/declaration is needed to see whether this is a standard library/POSIX function or a compiler-specific extension (some platforms expose additional variants or require feature-test macros). This helps determine if use of the symbol implies a language/compiler extension.\n\n- CLOCK_REALTIME: the macro/constant definition should be checked to see if it is a standard POSIX constant or a platform/compiler extension.\n\n- tv_sec and tv_nsec: the exact member types for these fields (e.g. time_t, long, long long, etc.) are required to verify that arithmetic and the integer literal suffixes (1000000000L) do not rely on implementation/compiler extensions (for example, if tv_nsec were an unusual compiler-introduced type).\n\nCollecting these symbol definitions (typically from the headers <time.h>/<sys/time.h> and the project typedefs) is sufficient to determine whether any compiler language extensions are being used by this function. Note: callers in the static call graph are not required to assess language-extension usage for this function, so they are not included."
}