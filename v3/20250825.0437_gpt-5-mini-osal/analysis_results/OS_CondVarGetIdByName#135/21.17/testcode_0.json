{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the LENGTHCHECK macro uses a <string.h> function that scans for a NUL terminator (for example strlen(name) or similar) then it can read past the supplied object if the string is not NUL\u2011terminated within the object's bounds or the object is smaller than OS_MAX_API_NAME. Concretely, if LENGTHCHECK expands to something like: if (strlen(name) >= OS_MAX_API_NAME) return OS_ERR_NAME_TOO_LONG; and name points to a buffer without a terminating '\\0' within its allocated size (or a buffer smaller than OS_MAX_API_NAME), strlen will access memory beyond the object bounds \u2014 violating MISRA C 2023 Rule 21.17. (If, instead, LENGTHCHECK is implemented using a bounded operation such as strnlen(name, OS_MAX_API_NAME) or an explicit limit-aware loop, then the rule would not be violated.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CondVarGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1359.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CondVarGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CondVarGetIdByName:\n```c\nint32 OS_CondVarGetIdByName(osal_id_t *var_id, const char *var_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(var_id);\n    OS_CHECK_POINTER(var_name);\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_CONDVAR, var_name, var_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CondVarGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Probe logger: appends entries to /tmp/logs/1359.txt to record control flow and state.\n * It intentionally avoids dereferencing the var_name pointer to prevent any out-of-bounds reads.\n */\nstatic void __log_probe(const char *event, const void *var_id, const void *var_name, long rc)\n{\n    FILE *fp = fopen(\"/tmp/logs/1359.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* Try to create the directory and reopen. Ignore errors if directory already exists. */\n        (void)mkdir(\"/tmp/logs\", 0777);\n        fp = fopen(\"/tmp/logs/1359.txt\", \"a\");\n    }\n\n    if (fp != NULL)\n    {\n        time_t t = time(NULL);\n        /* Log timestamp, event tag, pointer values and return code (if available). Do not dereference var_name. */\n        (void)fprintf(fp, \"%ld: %s: var_id=%p var_name=%p rc=%ld\\n\", (long)t, event, var_id, var_name, rc);\n        (void)fflush(fp);\n        (void)fclose(fp);\n    }\n}\n\nint32 OS_CondVarGetIdByName(osal_id_t *var_id, const char *var_name)\n{\n    int32 return_code;\n\n    /* Entry probe */\n    __log_probe(\"ENTRY\", (const void *)var_id, (const void *)var_name, -1);\n\n    /* Check parameters (log before/after to capture control flow if a macro returns early) */\n    __log_probe(\"CHECK_POINTER_var_id_before\", (const void *)var_id, (const void *)var_name, -1);\n    OS_CHECK_POINTER(var_id);\n    __log_probe(\"CHECK_POINTER_var_id_after\", (const void *)var_id, (const void *)var_name, -1);\n\n    __log_probe(\"CHECK_POINTER_var_name_before\", (const void *)var_id, (const void *)var_name, -1);\n    OS_CHECK_POINTER(var_name);\n    __log_probe(\"CHECK_POINTER_var_name_after\", (const void *)var_id, (const void *)var_name, -1);\n\n    __log_probe(\"BEFORE_OS_ObjectIdFindByName\", (const void *)var_id, (const void *)var_name, -1);\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_CONDVAR, var_name, var_id);\n    __log_probe(\"AFTER_OS_ObjectIdFindByName\", (const void *)var_id, (const void *)var_name, (long)return_code);\n\n    __log_probe(\"EXIT\", (const void *)var_id, (const void *)var_name, (long)return_code);\n\n    return return_code;\n}\n"
}