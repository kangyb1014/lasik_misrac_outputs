{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_BinSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_bin_sem_internal_record_t *binsem;\n\n    /* Helper: append a log entry recording the current state. */\n    static void os_binsem_log(const char *stage, const osal_id_t *id, const char *name, uint32 init_val, uint32 opts, int32 rc, const void *token_ptr)\n    {\n        FILE *f = fopen(\"/tmp/logs/1163.txt\", \"a\");\n        if (f != NULL)\n        {\n            /* Write a compact single-line record for easy parsing by other agents. */\n            fprintf(f, \"stage=%s sem_id_ptr=%p sem_name=%s sem_initial_value=%u options=%u return_code=%d token_ptr=%p\\n\",\n                    stage,\n                    (const void *)id,\n                    (name != NULL) ? name : \"(null)\",\n                    (unsigned)init_val,\n                    (unsigned)opts,\n                    (int)rc,\n                    token_ptr);\n            fclose(f);\n        }\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Log: parameters validated */\n    os_binsem_log(\"params_validated\", sem_id, sem_name, sem_initial_value, options, -1, NULL);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    os_binsem_log(\"before_allocate\", sem_id, sem_name, sem_initial_value, options, -1, NULL);\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    os_binsem_log(\"after_allocate\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        binsem = OS_OBJECT_TABLE_GET(OS_bin_sem_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, binsem, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        os_binsem_log(\"before_impl\", sem_id, sem_name, sem_initial_value, options, -1, &token);\n        return_code = OS_BinSemCreate_Impl(&token, sem_initial_value, options);\n        os_binsem_log(\"after_impl\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n        os_binsem_log(\"after_finalize\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n    }\n    else\n    {\n        /* Log allocation failure path */\n        os_binsem_log(\"allocate_failed\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n    }\n\n    /* Final log before return */\n    os_binsem_log(\"return\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpinhuq8un/src/src/os/shared/src/osapi-binsem.c: In function 'OS_BinSemCreate':\n/tmp/tmpinhuq8un/src/src/os/shared/src/osapi-binsem.c:106:17: error: invalid storage class for function 'os_binsem_log'\n  106 |     static void os_binsem_log(const char *stage, const osal_id_t *id, const char *name, uint32 init_val, uint32 opts, int32 rc, const void *token_ptr)\n      |                 ^~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:76: CMakeFiles/osal.dir/src/os/shared/src/osapi-binsem.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_BinSemCreate as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "\nint32 OS_BinSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options);\n\n/* Helper: append a log entry recording the current state. */\nstatic void os_binsem_log(const char *stage, const osal_id_t *id, const char *name, uint32 init_val, uint32 opts, int32 rc, const void *token_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/1163.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Write a compact single-line record for easy parsing by other agents. */\n        fprintf(f, \"stage=%s sem_id_ptr=%p sem_name=%s sem_initial_value=%u options=%u return_code=%d token_ptr=%p\\n\",\n                stage,\n                (const void *)id,\n                (name != NULL) ? name : \"(null)\",\n                (unsigned)init_val,\n                (unsigned)opts,\n                (int)rc,\n                token_ptr);\n        fclose(f);\n    }\n}\n\nint32 OS_BinSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 sem_initial_value, uint32 options)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_bin_sem_internal_record_t *binsem;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Log: parameters validated */\n    os_binsem_log(\"params_validated\", sem_id, sem_name, sem_initial_value, options, -1, NULL);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    os_binsem_log(\"before_allocate\", sem_id, sem_name, sem_initial_value, options, -1, NULL);\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    os_binsem_log(\"after_allocate\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        binsem = OS_OBJECT_TABLE_GET(OS_bin_sem_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, binsem, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        os_binsem_log(\"before_impl\", sem_id, sem_name, sem_initial_value, options, -1, &token);\n        return_code = OS_BinSemCreate_Impl(&token, sem_initial_value, options);\n        os_binsem_log(\"after_impl\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n        os_binsem_log(\"after_finalize\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n    }\n    else\n    {\n        /* Log allocation failure path */\n        os_binsem_log(\"allocate_failed\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n    }\n\n    /* Final log before return */\n    os_binsem_log(\"return\", sem_id, sem_name, sem_initial_value, options, return_code, &token);\n\n    return return_code;\n}\n",
  "explanation": "C does not allow defining a function inside another function. The original helper os_binsem_log was declared inside OS_BinSemCreate which caused the \"invalid storage class for function\" error. I moved the os_binsem_log definition to file scope (above OS_BinSemCreate) as a static function, and left the rest of OS_BinSemCreate unchanged so the original logic is preserved."
}