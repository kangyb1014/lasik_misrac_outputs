{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential buffer over-read of stream->stream_name: strcmp(stream->stream_name, old) reads byte-by-byte until a '\\0' is found. If stream->stream_name is not guaranteed to contain a terminating NUL within its OS_MAX_PATH_LEN bytes (for example, if the record was initialized/updated elsewhere using memcpy or an unterminated strncpy, or the entry is uninitialized/corrupted), strcmp can read past the bounds of stream->stream_name and thus violate Rule 21.17. (Note: the 'old' argument is validated earlier by OS_TranslatePath when OS_rename proceeds, so the risk is the stream->stream_name side.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rename code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1709.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rename as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rename:\n```c\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rename code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Probe helpers for logging control flow and state to /tmp/logs/1709.txt.\n * These helpers are added to capture evidence for a potential buffer over-read\n * of stream->stream_name when strcmp is used. The helpers only access\n * stream->stream_name with explicit bounded operations (no %s prints), so they\n * do not introduce additional out-of-bounds reads.\n */\nstatic void os_1709_dump_hex(FILE *f, const unsigned char *buf, size_t len)\n{\n    size_t i;\n    for (i = 0; i < len; ++i)\n    {\n        /* print as two hex digits; group for readability */\n        fprintf(f, \"%02X\", buf[i]);\n        if (((i + 1) % 2) == 0 && (i + 1) != len)\n        {\n            fprintf(f, \" \");\n        }\n    }\n}\n\nstatic void os_1709_log_stream_pre(const char *context, int iter_token, const void *stream_ptr,\n                                   const void *socket_domain_ptr, const char *old, const char *new,\n                                   const char *stream_name_buf, size_t stream_name_len, int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1709.txt\", \"a\");\n    if (!f) return;\n\n    /* Header with context and parameters known to be NUL-terminated */\n    fprintf(f, \"[OS_rename] %s: iter_token=%d, stream_ptr=%p, socket_domain_ptr=%p, return_code=%d\\n\",\n            context, iter_token, stream_ptr, socket_domain_ptr, return_code);\n    fprintf(f, \"  old (arg) = '%s'\\n\", old ? old : \"(null)\");\n    fprintf(f, \"  new (arg) = '%s'\\n\", new ? new : \"(null)\");\n\n    /* Inspect stream_name buffer safely: look for terminating NUL within bounds */\n    const void *nul_pos = memchr(stream_name_buf, '\\0', stream_name_len);\n    if (nul_pos != NULL)\n    {\n        size_t idx = (const unsigned char *)nul_pos - (const unsigned char *)stream_name_buf;\n        fprintf(f, \"  stream_name: NUL found at index %zu (within %zu bytes)\\n\", idx, stream_name_len);\n        fprintf(f, \"  stream_name (bytes up to NUL) = \");\n        os_1709_dump_hex(f, (const unsigned char *)stream_name_buf, idx + 1); /* include terminator */\n        fprintf(f, \"\\n\");\n    }\n    else\n    {\n        fprintf(f, \"  stream_name: NO NUL within %zu bytes -> potential unterminated buffer\\n\", stream_name_len);\n        fprintf(f, \"  stream_name (full %zu bytes) = \", stream_name_len);\n        os_1709_dump_hex(f, (const unsigned char *)stream_name_buf, stream_name_len);\n        fprintf(f, \"\\n\");\n    }\n\n    fclose(f);\n}\n\nstatic void os_1709_log_match_and_update(const char *message, int iter_token, const void *stream_ptr,\n                                         const char *old, const char *new, const char *stream_name_buf,\n                                         size_t stream_name_len)\n{\n    FILE *f = fopen(\"/tmp/logs/1709.txt\", \"a\");\n    if (!f) return;\n\n    fprintf(f, \"[OS_rename] %s: iter_token=%d, stream_ptr=%p\\n\", message, iter_token, stream_ptr);\n    fprintf(f, \"  old (arg) = '%s'\\n\", old ? old : \"(null)\");\n    fprintf(f, \"  new (arg) = '%s'\\n\", new ? new : \"(null)\");\n\n    /* After potential update, dump resulting stream_name safely */\n    const void *nul_pos = memchr(stream_name_buf, '\\0', stream_name_len);\n    if (nul_pos != NULL)\n    {\n        size_t idx = (const unsigned char *)nul_pos - (const unsigned char *)stream_name_buf;\n        fprintf(f, \"  post-update stream_name: NUL at index %zu\\n\", idx);\n        fprintf(f, \"  post-update stream_name (bytes up to NUL) = \");\n        os_1709_dump_hex(f, (const unsigned char *)stream_name_buf, idx + 1);\n        fprintf(f, \"\\n\");\n    }\n    else\n    {\n        fprintf(f, \"  post-update stream_name: NO NUL within %zu bytes\\n\", stream_name_len);\n        fprintf(f, \"  post-update stream_name (full bytes) = \");\n        os_1709_dump_hex(f, (const unsigned char *)stream_name_buf, stream_name_len);\n        fprintf(f, \"\\n\");\n    }\n\n    fclose(f);\n}\n\n/* Modified OS_rename with inserted probes. Original logic is preserved; probes are\n * inserted to log state before the strcmp that may over-read, and after any\n * update to stream->stream_name. The probes avoid using %s on stream->stream_name\n * and operate only within its known size to prevent introducing further issues.\n */\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            /* Probe: log the state of the stream record and stream_name buffer before strcmp.\n             * This uses only bounded memory accesses (memchr and byte dumps) so it does not\n             * itself cause out-of-bounds reads even if the buffer is unterminated.\n             */\n            os_1709_log_stream_pre(\"pre-strcmp\", iter.token, (const void *)stream,\n                                   (const void *)&stream->socket_domain,\n                                   old, new,\n                                   stream->stream_name, sizeof(stream->stream_name), return_code);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                /* Log that a match was detected and that an update will be performed. */\n                os_1709_log_match_and_update(\"match-detected-before-update\", iter.token, (const void *)stream,\n                                            old, new, stream->stream_name, sizeof(stream->stream_name));\n\n                /* Preserve original behavior: copy new into stream_name with truncation and explicit NUL. */\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                /* Log the post-update state */\n                os_1709_log_match_and_update(\"post-update\", iter.token, (const void *)stream,\n                                            old, new, stream->stream_name, sizeof(stream->stream_name));\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n"
}