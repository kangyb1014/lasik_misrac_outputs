{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorProcessEntry code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorProcessEntry.\n```c\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe struct OS_object_iter_t contains pointer members that are not const-qualified even though they are used only for read access. For example, iter->base is set to &OS_common_table[...] in OS_ObjectIdIteratorInit and is used by the iterator to read table entries; it should be declared as const OS_common_record_t *base to prevent accidental modification. Similarly, iter->arg is a context pointer passed to handlers that are expected to only read it; if the argument is not modified by the handlers it should be declared const void *arg. Declaring these pointers const whenever they are only used for reading would satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_ObjectIdIteratorProcessEntry:\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nvoid OS_Unlock_Global(OS_object_token_t *token)\n{\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype = &OS_objtype_state[token->obj_type];\n\n        /*\n         * Un-track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done before unlocking, while this has exclusive access\n         * to the state object.\n         */\n        if ((objtype->owner_key.key_value & 0xFF000000) != OS_LOCK_KEY_FIXED_VALUE ||\n            objtype->owner_key.key_value != token->lock_key.key_value)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\\n\",\n                     (unsigned int)token->obj_type, (unsigned long)token->lock_key.key_value,\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n\n        objtype->owner_key = OS_LOCK_KEY_INVALID;\n        token->lock_key    = OS_LOCK_KEY_INVALID;\n\n        OS_Unlock_Global_Impl(token->obj_type);\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot unlock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n...\nvoid OS_Lock_Global(OS_object_token_t *token)\n{\n    osal_id_t           self_task_id;\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype      = &OS_objtype_state[token->obj_type];\n        self_task_id = OS_TaskGetId_Impl();\n\n        OS_Lock_Global_Impl(token->obj_type);\n\n        /*\n         * Track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done after successfully locking, so this has exclusive access\n         * to the state object.\n         */\n        if (!OS_ObjectIdIsValid(self_task_id))\n        {\n            /*\n             * This just means the calling context is not an OSAL-created task.\n             * This is not necessarily an error, but it should be tracked.\n             * Also note that the root/initial task also does not have an ID.\n             */\n            self_task_id = OS_OBJECT_ID_RESERVED; /* nonzero, but also won't alias a known task */\n        }\n\n        /*\n         * The key value is computed with fixed/nonzero flag bits combined\n         * with the lower 24 bits of the task ID xor'ed with transaction id.\n         * This makes it different for every operation, and different depending\n         * on what task is calling the function.\n         */\n        token->lock_key.key_value =\n            OS_LOCK_KEY_FIXED_VALUE | ((OS_ObjectIdToInteger(self_task_id) ^ objtype->transaction_count) & 0xFFFFFF);\n\n        ++objtype->transaction_count;\n\n        if (objtype->owner_key.key_value != 0)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u acquired by task 0x%lx when already assigned key 0x%lx\\n\",\n                     (unsigned int)token->obj_type, OS_ObjectIdToInteger(self_task_id),\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n        else\n        {\n            objtype->owner_key = token->lock_key;\n        }\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot lock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n...\ntypedef uint32 osal_id_t\n...\ntypedef int32_t   int32\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA R8.13 is about declarations: pointers should be to const-qualified types when it is feasible across all uses. The code shown in OS_ObjectIdIteratorProcessEntry merely reads iter->arg and passes it to a callback of type int32 (*)(osal_id_t, void *). That callback type explicitly allows modification of the object pointed to by the void *; therefore changing iter->arg to a const void * would be an API/ABI change and is not obviously safe without a whole-program check of every callback implementation. Likewise, although iter->base is assigned from &OS_common_table[...] and many iterator users may only read entries, there is no evidence here that the table and its records are never modified elsewhere (and the base pointer might be used by other code that writes). Determining whether either pointer can be const-qualified requires analysis of all uses of OS_object_iter_t and all callbacks. Given the provided snippets, there is not enough evidence to conclude a definite MISRA 8.13 violation in OS_ObjectIdIteratorProcessEntry; the reported violation is therefore not proven/correct."
}