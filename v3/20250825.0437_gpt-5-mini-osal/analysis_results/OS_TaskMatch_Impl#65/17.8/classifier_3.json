{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_TaskMatch_Impl:\n```c\nint32 OS_TaskMatch_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    if (pthread_equal(pthread_self(), impl->id) == 0)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TaskMatch_Impl:\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_task_internal_record_t OS_impl_task_table[OS_MAX_TASKS]\n...\ntypedef struct\n{\n    pthread_t id;\n} OS_impl_task_internal_record_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_ObjectIndexFromToken(&(tok))\n```\nFocus on the above code fragment and judge whether it violates the rule 17.8 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. In the call OS_OBJECT_TABLE_GET(..., *token) the macro expands to OS_ObjectIndexFromToken(&(tok)) with tok substituted by *token, so this becomes OS_ObjectIndexFromToken(&(*token)). Taking the address of the dereferenced parameter yields the original pointer value but does not assign to or modify the function parameter 'token'. There is no modification of the parameter itself (only access to the pointed-to object), so MISRA C 2023 Rule 17.8 is not violated."
}