{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to memset(token, 0, sizeof(*token)) can write sizeof(OS_object_token_t) bytes starting at the address in token. If OS_ObjectIdTransactionInit is ever called with token == NULL or with token pointing to an object smaller than OS_object_token_t (for example a caller mistake or an incorrectly cast pointer), this will result in writes beyond the bounds of the referenced object (e.g. a NULL pointer dereference or buffer overflow). Although the shown call chain (OS_TaskPrepare -> OS_ObjectIdGetById -> OS_ObjectIdTransactionInit) passes &token (a local OS_object_token_t) and is safe, the function itself lacks a runtime pointer check and therefore can be invoked in a way that violates Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskPrepare code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2619.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskPrepare as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskPrepare:\n```c\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        return_code = OS_TaskMatch_Impl(&token);\n        *entrypt    = task->entry_function_pointer;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TaskRegister_Impl(task_id);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Give event callback to the application */\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        *entrypt = NULL;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskPrepare code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Probe helper: append a formatted message to the log file. */\nstatic void probe_log_append(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2619.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If the log file or directory can't be opened, silently skip logging to avoid\n           interfering with the original program logic. */\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Lightweight probe that records key pointer and state information for OS_TaskPrepare. */\nstatic void probe_task_prepare_enter(void *task_id_ptr, void *entrypt_ptr, size_t token_size)\n{\n    probe_log_append(\"ENTER OS_TaskPrepare: task_id_ptr=%p, entrypt_ptr=%p, token_size=%zu\",\n                     task_id_ptr, entrypt_ptr, token_size);\n}\n\nstatic void probe_after_getbyid(int return_code, void *token_addr)\n{\n    probe_log_append(\"After OS_ObjectIdGetById: return_code=%d, token_addr=%p\",\n                     (int)return_code, token_addr);\n}\n\nstatic void probe_after_table_get(void *task_ptr)\n{\n    probe_log_append(\"OS_OBJECT_TABLE_GET returned task_ptr=%p\", task_ptr);\n}\n\nstatic void probe_before_release(void *token_addr)\n{\n    probe_log_append(\"About to call OS_ObjectIdRelease with token_addr=%p\", token_addr);\n}\n\nstatic void probe_before_register(void *task_id_ptr)\n{\n    probe_log_append(\"About to call OS_TaskRegister_Impl with task_id=%p\", task_id_ptr);\n}\n\nstatic void probe_before_notify(void *task_id_ptr)\n{\n    probe_log_append(\"About to call OS_NotifyEvent(OS_EVENT_TASK_STARTUP) for task_id=%p\", task_id_ptr);\n}\n\nstatic void probe_on_error(int return_code, void *entrypt_ptr)\n{\n    probe_log_append(\"OS_TaskPrepare error: return_code=%d, setting *entrypt (at %p) = NULL\",\n                     (int)return_code, entrypt_ptr);\n}\n\n/* Modified OS_TaskPrepare with inserted probes. The original logic is preserved. */\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Log entry and basic token size/address info. Do not dereference token. */\n    probe_task_prepare_enter((void *)(uintptr_t)task_id, (void *)entrypt, sizeof(token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    probe_after_getbyid(return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n        probe_after_table_get((void *)task);\n\n        return_code = OS_TaskMatch_Impl(&token);\n\n        /* Only touch task->entry_function_pointer after task is retrieved. */\n        *entrypt    = task->entry_function_pointer;\n\n        probe_before_release((void *)&token);\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_before_register((void *)(uintptr_t)task_id);\n        return_code = OS_TaskRegister_Impl(task_id);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_before_notify((void *)(uintptr_t)task_id);\n        /* Give event callback to the application */\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_on_error(return_code, (void *)entrypt);\n        *entrypt = NULL;\n    }\n\n    probe_log_append(\"EXIT OS_TaskPrepare: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n"
}