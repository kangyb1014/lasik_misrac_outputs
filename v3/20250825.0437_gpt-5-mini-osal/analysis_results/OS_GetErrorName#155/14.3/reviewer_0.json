{
  "user_message": "An agent A claimed that the following OS_GetErrorName code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of OS_GetErrorName.\n```c\nint32 OS_GetErrorName(int32 error_num, os_err_name_t *err_name)\n{\n    int32                        return_code;\n    const OS_ErrorTable_Entry_t *Error;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(err_name);\n\n    Error = OS_GLOBAL_ERROR_NAME_TABLE;\n    while (Error->Name != NULL && Error->Number != error_num)\n    {\n        ++Error;\n    }\n\n    if (Error->Number != error_num)\n    {\n        Error = OS_IMPL_ERROR_NAME_TABLE;\n        while (Error->Name != NULL && Error->Number != error_num)\n        {\n            ++Error;\n        }\n    }\n\n    if (Error->Number == error_num && Error->Name != NULL)\n    {\n        strncpy(*err_name, Error->Name, sizeof(*err_name) - 1);\n        *err_name[sizeof(*err_name) - 1] = 0;\n        return_code                      = OS_SUCCESS;\n    }\n    else\n    {\n        snprintf(*err_name, OS_ERROR_NAME_LENGTH, \"OS_UNKNOWN(%d)\", (int)error_num);\n        return_code = OS_ERROR;\n    }\n\n    (*err_name)[OS_ERROR_NAME_LENGTH - 1] = '\\0';\n\n    return return_code;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: the while loop controlling expression is invariant (always false). Error is set to OS_IMPL_ERROR_NAME_TABLE which is defined as {{0, NULL}}, so Error->Name is NULL and the condition (Error->Name != NULL && Error->Number != error_num) is always false; this is an invariant controlling expression and not one of the permitted exceptions to MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER OS_GetErrorName: error_num=-1, err_name_ptr=(nil)\nSearching GLOBAL table at 0x55a1c21f74c0, first entry: Number=0, Name=0x55a1c21eaed8\nEvaluate GLOBAL while condition: (Error->Name != NULL)=true, (Error->Number != error_num)=true\nGLOBAL loop iterate: current entry addr=0x55a1c21f74c0, Number=0, Name=OS_SUCCESS\nGLOBAL loop advanced to addr=0x55a1c21f74d0, Number=-1, Name=0x55a1c21eaee3\nAfter GLOBAL search: entry addr=0x55a1c21f74d0, Number=-1, Name=0x55a1c21eaee3\nFound in GLOBAL table: Number=-1, Name=OS_ERROR\nMatch found: copying name 'OS_ERROR' into provided buffer\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function OS_GetErrorName:\ntypedef struct\n{\n    int32       Number;\n    const char *Name;\n} OS_ErrorTable_Entry_t\n...\nstatic const OS_ErrorTable_Entry_t OS_GLOBAL_ERROR_NAME_TABLE[] = {\n    {OS_SUCCESS, \"OS_SUCCESS\"},\n    {OS_ERROR, \"OS_ERROR\"},\n    {OS_INVALID_POINTER, \"OS_INVALID_POINTER\"},\n    {OS_ERROR_ADDRESS_MISALIGNED, \"OS_ERROR_ADDRESS_MISALIGNED\"},\n    {OS_ERROR_TIMEOUT, \"OS_ERROR_TIMEOUT\"},\n    {OS_INVALID_INT_NUM, \"OS_INVALID_INT_NUM\"},\n    {OS_SEM_FAILURE, \"OS_SEM_FAILURE\"},\n    {OS_SEM_TIMEOUT, \"OS_SEM_TIMEOUT\"},\n    {OS_QUEUE_EMPTY, \"OS_QUEUE_EMPTY\"},\n    {OS_QUEUE_FULL, \"OS_QUEUE_FULL\"},\n    {OS_QUEUE_TIMEOUT, \"OS_QUEUE_TIMEOUT\"},\n    {OS_QUEUE_INVALID_SIZE, \"OS_QUEUE_INVALID_SIZE\"},\n    {OS_QUEUE_ID_ERROR, \"OS_QUEUE_ID_ERROR\"},\n    {OS_ERR_NAME_TOO_LONG, \"OS_ERR_NAME_TOO_LONG\"},\n    {OS_ERR_NO_FREE_IDS, \"OS_ERR_NO_FREE_IDS\"},\n    {OS_ERR_NAME_TAKEN, \"OS_ERR_NAME_TAKEN\"},\n    {OS_ERR_INVALID_ID, \"OS_ERR_INVALID_ID\"},\n    {OS_ERR_NAME_NOT_FOUND, \"OS_ERR_NAME_NOT_FOUND\"},\n    {OS_ERR_SEM_NOT_FULL, \"OS_ERR_SEM_NOT_FULL\"},\n    {OS_ERR_INVALID_PRIORITY, \"OS_ERR_INVALID_PRIORITY\"},\n    {OS_INVALID_SEM_VALUE, \"OS_INVALID_SEM_VALUE\"},\n    {OS_ERR_FILE, \"OS_ERR_FILE\"},\n    {OS_ERR_NOT_IMPLEMENTED, \"OS_ERR_NOT_IMPLEMENTED\"},\n    {OS_TIMER_ERR_INVALID_ARGS, \"OS_TIMER_ERR_INVALID_ARGS\"},\n    {OS_TIMER_ERR_TIMER_ID, \"OS_TIMER_ERR_TIMER_ID\"},\n    {OS_TIMER_ERR_UNAVAILABLE, \"OS_TIMER_ERR_UNAVAILABLE\"},\n    {OS_TIMER_ERR_INTERNAL, \"OS_TIMER_ERR_INTERNAL\"},\n    {OS_ERR_OBJECT_IN_USE, \"OS_ERR_OBJECT_IN_USE\"},\n    {OS_ERR_BAD_ADDRESS, \"OS_ERR_BAD_ADDRESS\"},\n    {OS_ERR_INCORRECT_OBJ_STATE, \"OS_ERR_INCORRECT_OBJ_STATE\"},\n    {OS_ERR_INCORRECT_OBJ_TYPE, \"OS_ERR_INCORRECT_OBJ_TYPE\"},\n    {OS_ERR_STREAM_DISCONNECTED, \"OS_ERR_STREAM_DISCONNECTED\"},\n    {OS_ERR_OPERATION_NOT_SUPPORTED, \"OS_ERR_OPERATION_NOT_SUPPORTED\"},\n    {OS_ERR_INVALID_SIZE, \"OS_ERR_INVALID_SIZE\"},\n    {OS_ERR_OUTPUT_TOO_LARGE, \"OS_ERR_OUTPUT_TOO_LARGE\"},\n    {OS_ERR_INVALID_ARGUMENT, \"OS_ERR_INVALID_ARGUMENT\"},\n    {OS_FS_ERR_PATH_TOO_LONG, \"OS_FS_ERR_PATH_TOO_LONG\"},\n    {OS_FS_ERR_NAME_TOO_LONG, \"OS_FS_ERR_NAME_TOO_LONG\"},\n    {OS_FS_ERR_DRIVE_NOT_CREATED, \"OS_FS_ERR_DRIVE_NOT_CREATED\"},\n    {OS_FS_ERR_DEVICE_NOT_FREE, \"OS_FS_ERR_DEVICE_NOT_FREE\"},\n    {OS_FS_ERR_PATH_INVALID, \"OS_FS_ERR_PATH_INVALID\"},\n\n    {0, NULL} /* End of table marker */\n}\n...\nconst OS_ErrorTable_Entry_t OS_IMPL_ERROR_NAME_TABLE[] = {{0, NULL}}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\ntypedef int32_t   int32\n...\ntypedef char os_err_name_t[OS_ERROR_NAME_LENGTH]\n...\n#define OS_ERROR_NAME_LENGTH 35\n...\n#define OS_SUCCESS (0)\n...\n#define OS_ERROR (-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The second while loop\u2019s controlling expression (Error->Name != NULL && Error->Number != error_num) is effectively invariantly false given the provided definition const OS_ErrorTable_Entry_t OS_IMPL_ERROR_NAME_TABLE[] = {{0, NULL}}. When Error is set to OS_IMPL_ERROR_NAME_TABLE, Error->Name is NULL and so Error->Name != NULL is always false, making the whole controlling expression always false. This is not one of the permitted exceptions to MISRA C:2023 Rule 14.3 (it is not an intentionally infinite loop nor the allowed do-while constant-false case). Note: if OS_IMPL_ERROR_NAME_TABLE were intended to be populated in other builds/links such that it could contain entries, the expression might not be invariant; however, given the definition shown, the report of a Rule 14.3 violation is correct."
}