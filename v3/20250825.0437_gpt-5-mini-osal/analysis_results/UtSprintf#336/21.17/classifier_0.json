{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UtSprintf:\n```c\nchar *UtSprintf(const char *Spec, ...)\n{\n    va_list                     Args;\n    static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n    static uint32               TextIndex = 0;\n\n    ++TextIndex;\n    if (TextIndex >= UT_SNPRINTF_MAX_BUFS)\n        TextIndex = 0;\n\n    va_start(Args, Spec);\n    vsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n    va_end(Args);\n\n    return Buf[TextIndex].Text;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The declaration itself does not call any <string.h> functions and therefore does not by itself violate Rule 21.17. However, a realistic violation scenario is: if UT_SNPRINTF_MAX_BUFS is defined as 0 (resulting in an array with no elements) or otherwise incorrect so that Buf[TextIndex] is out-of-bounds at runtime, then the subsequent vsnprintf(Buf[TextIndex].Text, ...) call would pass a pointer that does not reference a valid object and could result in accesses beyond the bounds of the object referenced by that pointer (violating Rule 21.17)."
}