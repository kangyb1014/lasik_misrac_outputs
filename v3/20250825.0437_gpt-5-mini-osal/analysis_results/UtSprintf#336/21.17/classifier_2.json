{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UtSprintf:\n```c\nchar *UtSprintf(const char *Spec, ...)\n{\n    va_list                     Args;\n    static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n    static uint32               TextIndex = 0;\n\n    ++TextIndex;\n    if (TextIndex >= UT_SNPRINTF_MAX_BUFS)\n        TextIndex = 0;\n\n    va_start(Args, Spec);\n    vsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n    va_end(Args);\n\n    return Buf[TextIndex].Text;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nvsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call does not inherently violate Rule 21.17 when Buf[TextIndex].Text is an actual character array and sizeof(Buf[TextIndex].Text) yields the true byte size of that array (e.g. char Text[N]); vsnprintf will then be given the correct buffer length and will not write beyond the bounds (it truncates output to n-1 characters and NUL-terminates when n>0). However, a violation can occur if Text is not an array but a pointer (e.g. declared as char *Text) or otherwise the sizeof expression does not reflect the actual allocated buffer size (for example if Text points to a dynamically allocated buffer of different size). In that scenario sizeof yields the size of the pointer (or an incorrect size) and vsnprintf may write past the actual buffer, violating Rule 21.17."
}