{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t (full struct definition)",
    "UT_StubTableEntry_t.Data.Buff (nested member layout and types)",
    "UT_EntryKey_t (typedef)",
    "UT_ENTRYTYPE_DATA_BUFFER (macro/enum value and definition)",
    "UT_GetStubEntry (prototype and any function attributes/macros)",
    "UT_ClearStubEntry (prototype and any function attributes/macros)",
    "memcpy (declaration / included header and any compiler builtin/attribute mappings)",
    "size_t (typedef / header where defined)"
  ],
  "explanation": "Explain why each is required for checking MISRA rule about language extensions:\n\n- UT_StubTableEntry_t (full struct definition): The function indexes BasePtr and accesses nested members (TotalSize, Position, BasePtr). The struct definition may use language extensions (e.g. zero-length arrays, compiler-specific attributes, anonymous/unusual bit-fields, packed/aligned pragmas or GCC attributes). The full definition is needed to detect any such non\u2011standard constructs.\n\n- UT_StubTableEntry_t.Data.Buff (nested member layout and types): The Buffer sub-structure member types (e.g. whether BasePtr is declared as a pointer, flexible array, or zero-length array) determine whether an extension is used (zero-length array is a common compiler extension). Also need to see type widths (signed/unsigned) and any attributes on these members.\n\n- UT_EntryKey_t (typedef): The key type might be a compiler-specific typedef (e.g. an extended integer type, bitfield typedef, or typedef to a function pointer with attributes). Its declaration is required to ensure no extensions are used in the type definition.\n\n- UT_ENTRYTYPE_DATA_BUFFER (macro/enum value and definition): This token passed to UT_GetStubEntry could be defined using non\u2011standard constructs or macros that expand to compiler extensions; the definition must be inspected for extensions (e.g. complex macro tricks, compiler-specific annotations).\n\n- UT_GetStubEntry (prototype and any function attributes/macros): The call site uses UT_GetStubEntry; the function declaration/definition may carry compiler extensions (GCC attributes, asm labels, non-standard calling conventions, inline assembly, or non\u2011portable linkage). Inspecting its prototype/attributes ensures no extension usage affects the target.\n\n- UT_ClearStubEntry (prototype and any function attributes/macros): Same rationale as UT_GetStubEntry \u2014 its declaration/definition could include language extensions that the target relies on or propagates.\n\n- memcpy (declaration / included header and any compiler builtin/attribute mappings): memcpy is standard, but some implementations map it to a compiler builtin or use attribute annotations. The declaration in the used headers (and any compiler-specific builtin mapping) should be checked to ensure no extension is relied upon.\n\n- size_t (typedef / header where defined): size_t is standard, but its typedef origin should be confirmed (header macros or implementation-specific typedefs). Confirming the standard typedef avoids missing subtle non\u2011standard definitions.\n\nCollecting these symbols (their declarations/definitions and any attached attributes or macros) lets the next analyzer determine whether the target function uses any language/compiler extensions (e.g. zero-length arrays, GCC attributes, asm, non-standard pragmas) that would violate the stated MISRA prohibition."
}