{
  "user_message": "An agent A claimed that the following UT_Stub_CopyFromLocal code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyFromLocal.\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn UT_DefaultHandler_OS_printf the initial assignment 'size_t length = strlen(string);' is redundant: the variable 'length' is recomputed (length = strlen(string);) inside the subsequent 'if (status >= 0)' block before any use, and if status < 0 the initial value is never used. Thus the call to strlen and the assignment constitute dead code \u2014 removing that line would not affect program behaviour (aside from minor timing differences).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CopyFromLocal called: FuncKey=94849808579097, LocalBuffer=0x5643f1269008, MaxSize=7\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=94849808579097\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=94849808579097, LocalBuffer=0x5643f1269008, MaxSize=7\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=94849808579097\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=93961202937586, LocalBuffer=0x7ffdabd272c0, MaxSize=72\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=93961202937586\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=93961202937586, LocalBuffer=0x7ffdabd272c0, MaxSize=72\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=93961202937586\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=93961202937586, LocalBuffer=0x7ffdabd26f80, MaxSize=72\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=93961202937586\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=94293508078435, LocalBuffer=0x7ffed31d7b50, MaxSize=32\nUT_GetStubEntry returned StubPtr=0x55c26b0fb260\nBefore copy: TotalSize=32, Position=0\nInitial computed ActualCopy=32\nActualCopy to perform=32\nmemcpy performed: src=0x7ffed31d7b50, dest=BasePtr+0, bytes=32\nUpdated Position=32\nBuffer complete (Position=32 >= TotalSize=32). Clearing entry.\nReturn ActualCopy=32\n\nUT_Stub_CopyFromLocal called: FuncKey=94293508078435, LocalBuffer=0x7ffed31d7b50, MaxSize=32\nUT_GetStubEntry returned StubPtr=0x55c26b0fb260\nBefore copy: TotalSize=32, Position=0\nInitial computed ActualCopy=32\nActualCopy to perform=32\nmemcpy performed: src=0x7ffed31d7b50, dest=BasePtr+0, bytes=32\nUpdated Position=32\nBuffer complete (Position=32 >= TotalSize=32). Clearing entry.\nReturn ActualCopy=32\n\nUT_Stub_CopyFromLocal called: FuncKey=94293508078435, LocalBuffer=0x7ffed31d7bb0, MaxSize=32\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey=94293508078435\nReturn ActualCopy=0\n\nUT_Stub_CopyFromLocal called: FuncKey=93913075547918, LocalBuffer=0x7ffcba7a46be, MaxSize=13\nUT_GetStubEntry returned StubPtr=0x5569d783a220\nBefore copy: TotalSize=13, Position=0\nInitial computed ActualCopy=13\nActualCopy to perform=13\nmemcpy performed: src=0x7ffcba7a46be, dest=BasePtr+0, bytes=13\nUpdated Position=13\nBuffer complete (Position=13 >= TotalSize=13). Clearing entry.\nReturn ActualCopy=13\n\nUT_Stub_CopyFromLocal called: FuncKey=93913075547918, LocalBuffer=0x7ffcba7a46be, MaxSize=13\nUT_GetStubEntry returned StubPtr=0x5569d783a220\nBefore copy: TotalSize=13, Position=0\nInitial computed ActualCopy=13\nActualCopy to perform=13\nmemcpy performed: src=0x7ffcba7a46be, dest=BasePtr+0, bytes=13\nUpdated Position=13\nBuffer complete (Position=13 >= TotalSize=13). Clearing entry.\nReturn ActualCopy=13\n\nUT_Stub_CopyFromLocal called: FuncKey=94256175070633, LocalBuffer=0x7ffef1e41630, MaxSize=4\nUT_GetStubEntry returned StubPtr=0x55b9b9d73120\nBefore copy: TotalSize=32, Position=0\nInitial computed ActualCopy=32\nMaxSize (4) < ActualCopy (32) \u2014 limiting ActualCopy to MaxSize\nActualCopy to perform=4\nmemcpy performed: src=0x7ffef1e41630, dest=BasePtr+0, bytes=4\nUpdated Position=4\nBuffer not complete (Position=4 < TotalSize=32). Entry retained.\nReturn ActualCopy=4\n\nUT_Stub_CopyFromLocal called: FuncKey=94256175070633, LocalBuffer=0x7ffef1e41634, MaxSize=12\nUT_GetStubEntry returned StubPtr=0x55b9b9d73120\nBefore copy: TotalSize=32, Position=4\nInitial computed ActualCopy=28\nMaxSize (12) < ActualCopy (28) \u2014 limiting ActualCopy to MaxSize\nActualCopy to perform=12\nmemcpy performed: src=0x7ffef1e41634, dest=BasePtr+4, bytes=12\nUpdated Position=16\nBuffer not complete (Position=16 < TotalSize=32). Entry retained.\nReturn ActualCopy=12\n\nUT_Stub_CopyFromLocal called: FuncKey=94256175070633, LocalBuffer=0x7ffef1e41630, MaxSize=2\nUT_GetStubEntry returned StubPtr=0x55b9b9d73120\nBefore copy: TotalSize=32, Position=16\nInitial computed ActualCopy=16\nMaxSize (2) < ActualCopy (16) \u2014 limiting ActualCopy to MaxSize\nActualCopy to perform=2\nmemcpy performed: src=0x7ffef1e41630, dest=BasePtr+16, b\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyFromLocal:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n...\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n...\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n...\nstatic void UT_GenericWriteStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t      CopySize;\n    int32       status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = nbytes;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nvoid UT_DefaultHandler_OS_printf(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context, va_list va)\n{\n    const char *string = UT_Hook_GetArgValueByName(Context, \"string\", const char *);\n    size_t      length = strlen(string);\n    char        str[128];\n    va_list     va_debugcopy;\n    int32       status;\n\n    UT_Stub_GetInt32StatusCode(Context, &status);\n\n    va_copy(va_debugcopy, va);\n    /* Output the message when in debug mode (uses a copy of the va list) */\n    vsnprintf(str, sizeof(str), string, va_debugcopy);\n    UtDebug(\"OS_printf: %s\", str);\n    va_end(va_debugcopy);\n\n    if (status >= 0)\n    {\n        /*\n         * Special treatment of a format string which is only \"%s\" ...\n         * This is merely a way to avoid having to do full-blown printf processing\n         * inside the UT stub (which would make it the full version, not a stub)\n         */\n        if (strcmp(string, \"%s\") == 0 || strcmp(string, \"%s\\n\") == 0)\n        {\n            string = va_arg(va, const char *);\n        }\n        length = strlen(string);\n        if (length > 0)\n        {\n            /*\n             * prune any supplied newlines -\n             * one will be explicitly added\n             *\n             * (this is to ensure a consistent separator in the output buffer)\n             */\n            while (length > 0 && string[length - 1] == '\\n')\n            {\n                --length;\n            }\n            UT_Stub_CopyFromLocal(UT_KEY(OS_printf), string, length);\n            UT_Stub_CopyFromLocal(UT_KEY(OS_printf), \"\\n\", 1);\n        }\n    }\n}\n...\nvoid UT_DefaultHandler_OS_SetLocalTime(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const OS_time_t *time_struct = UT_Hook_GetArgValueByName(Context, \"time_struct\", const OS_time_t *);\n    int32            status;\n\n    UT_Stub_GetInt32StatusCode(Context, &status);\n\n    if (status == OS_SUCCESS)\n    {\n        UT_Stub_CopyFromLocal(UT_KEY(OS_SetLocalTime), time_struct, sizeof(*time_struct));\n    }\n}\n...\nvoid UT_DefaultHandler_OS_SocketSendTo(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      buflen = UT_Hook_GetArgValueByName(Context, \"buflen\", size_t);\n    int32       status;\n    size_t      CopySize;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(UT_KEY(OS_SocketSendTo), buffer, buflen);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = buflen;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is essentially correct: the initial initialization \"size_t length = strlen(string);\" in UT_DefaultHandler_OS_printf is never used before being overwritten later (length is recomputed inside the if (status >= 0) block), so the call to strlen and that assignment are an executed operation whose removal would not change the program state (other than timing). That fits the definition of dead code in MISRA C:2023 Rule 2.2 and should be removed or the initialization deferred until the value is actually required.\n\n(Notes: the report text mistakenly referenced UT_Stub_CopyFromLocal in its header but the redundant initialization appears in UT_DefaultHandler_OS_printf; this does not change the validity of the finding. One caveat: if strlen(string) has externally observable side-effects in your environment (for example triggering a crash when string is NULL), removing the call could change timing/manifestation of that undefined behaviour \u2014 however strlen is normally side-effect free, so in typical circumstances the initialization is redundant and constitutes dead code.)"
}