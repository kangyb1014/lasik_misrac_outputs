{
  "user_message": "An agent A claimed that the following UT_Stub_CopyFromLocal code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyFromLocal.\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation can occur when the computed destination start or the source pointer do not reference at least ActualCopy bytes. Example: if StubPtr->Data.Buff.Position > StubPtr->Data.Buff.TotalSize (e.g. TotalSize = 10, Position = 15) then the subtraction underflows producing a very large ActualCopy; even if ActualCopy is subsequently clamped by MaxSize (e.g. MaxSize = 2) the code still writes starting at BasePtr + 15 which is beyond the allocated buffer (TotalSize == 10). Another scenario is BasePtr == NULL (or LocalBuffer == NULL) \u2014 there is no null check before the memcpy, so the call can dereference/access invalid memory. In these cases the memcpy call can access beyond the bounds of the objects referenced by its pointer parameters, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nUT_Stub_CopyFromLocal invoked: FuncKey=0x56014af84b63, StubPtr=0x56014afa1fc0, LocalBuffer=0x7ffd6bb71ba0, MaxSize=32, ActualCopy=32\n  BasePtr=0x7ffd6bb71c50, Position=0, TotalSize=32, Remaining(before clamp)=32\n  Computed destination address (as integer) = 0x7ffd6bb71c50\n  MaxSize=32, ActualCopy(after clamp)=32\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x56014af84b63, StubPtr=0x56014afa1fc0, LocalBuffer=0x7ffd6bb71ba0, MaxSize=32, ActualCopy=32\n  BasePtr=0x7ffd6bb71c50, Position=0, TotalSize=32, Remaining(before clamp)=32\n  Computed destination address (as integer) = 0x7ffd6bb71c50\n  MaxSize=32, ActualCopy(after clamp)=32\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x5620a0a3ff0e, StubPtr=0x5620a0a5fea0, LocalBuffer=0x7ffef7dd4bbe, MaxSize=13, ActualCopy=13\n  BasePtr=0x7ffef7dd4bcb, Position=0, TotalSize=13, Remaining(before clamp)=13\n  Computed destination address (as integer) = 0x7ffef7dd4bcb\n  MaxSize=13, ActualCopy(after clamp)=13\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x5620a0a3ff0e, StubPtr=0x5620a0a5fea0, LocalBuffer=0x7ffef7dd4bbe, MaxSize=13, ActualCopy=13\n  BasePtr=0x7ffef7dd4bcb, Position=0, TotalSize=13, Remaining(before clamp)=13\n  Computed destination address (as integer) = 0x7ffef7dd4bcb\n  MaxSize=13, ActualCopy(after clamp)=13\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x55ad18047da9, StubPtr=0x55ad18063fe0, LocalBuffer=0x7fff1dbcaa40, MaxSize=4, ActualCopy=4\n  BasePtr=0x7fff1dbcaa50, Position=0, TotalSize=32, Remaining(before clamp)=32\n  Computed destination address (as integer) = 0x7fff1dbcaa50\n  MaxSize=4, ActualCopy(after clamp)=4\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x55ad18047da9, StubPtr=0x55ad18063fe0, LocalBuffer=0x7fff1dbcaa44, MaxSize=12, ActualCopy=12\n  BasePtr=0x7fff1dbcaa50, Position=4, TotalSize=32, Remaining(before clamp)=28\n  Computed destination address (as integer) = 0x7fff1dbcaa54\n  MaxSize=12, ActualCopy(after clamp)=12\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x55ad18047da9, StubPtr=0x55ad18063fe0, LocalBuffer=0x7fff1dbcaa40, MaxSize=2, ActualCopy=2\n  BasePtr=0x7fff1dbcaa50, Position=16, TotalSize=32, Remaining(before clamp)=16\n  Computed destination address (as integer) = 0x7fff1dbcaa60\n  MaxSize=2, ActualCopy(after clamp)=2\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x558a49d06ab9, StubPtr=0x558a49d2b340, LocalBuffer=0x7ffd74e60eec, MaxSize=4, ActualCopy=4\n  BasePtr=0x7ffd74e60ef0, Position=0, TotalSize=8, Remaining(before clamp)=8\n  Computed destination address (as integer) = 0x7ffd74e60ef0\n  MaxSize=4, ActualCopy(after clamp)=4\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x558a49d06ab9, StubPtr=0x558a49d2b340, LocalBuffer=0x7ffd74e60eec, MaxSize=4, ActualCopy=4\n  BasePtr=0x7ffd74e60ef0, Position=0, TotalSize=8, Remaining(before clamp)=8\n  Computed destination address (as integer) = 0x7ffd74e60ef0\n  MaxSize=4, ActualCopy(after clamp)=4\n--- end log entry ---\n\nUT_Stub_CopyFromLocal invoked: FuncKey=0x558a49d06ab9, StubPtr=0x558a49d2b340, LocalBuffer=0x7ffd74e60c90, MaxSize=9, ActualCopy=9\n  BasePtr=0x7ffd74e60eef, Position=0, TotalSize=9, Remaining(before clamp)=9\n  Computed destination address (as integer) = 0x7ffd74e60eef\n  MaxSize=9, ActualCopy(after clamp)=9\n--- end log entry ---\n\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CopyFromLocal:\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's report is correct. The memcpy call can result in out-of-bounds accesses of either the destination or the source, violating MISRA C 2023 Rule 21.17.\n\nConcrete problematic scenarios present in the code:\n- Position > TotalSize (unsigned underflow): ActualCopy is computed as TotalSize - Position. If Position > TotalSize this wraps to a very large value. Even though ActualCopy is subsequently clamped by MaxSize, the destination start address used in memcpy is &BasePtr[Position], which may already point beyond the allocated buffer (i.e. BasePtr + Position out-of-range). A small ActualCopy does not fix that \u2014 memcpy will still start writing at an out-of-bounds address.\n- Null pointers: There is no check that StubPtr->Data.Buff.BasePtr is non-NULL before using it as the destination, nor that LocalBuffer is non-NULL before using it as the source. If either is NULL, memcpy() will dereference an invalid pointer.\n- Source length not validated: The function assumes LocalBuffer points to at least ActualCopy bytes; there is no verification of the source object size, so memcpy could read beyond the source buffer as well.\n\nNothing in the shown UT_GetStubEntry or surrounding code guarantees the invariants (Position <= TotalSize and non-NULL BasePtr/LocalBuffer), so the call to memcpy can indeed lead to out-of-bounds accesses and therefore violates Rule 21.17.\n\nRecommended mitigation: validate Position <= TotalSize before computing Remaining, check BasePtr and LocalBuffer for non-NULL, and ensure the source buffer length is known/validated (or document/codify the caller contract)."
}