{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nOS_chmod allocates local_path as char local_path[OS_MAX_LOCAL_PATH_LEN] and calls OS_TranslatePath(path, local_path). If OS_TranslatePath uses a string.h function unsafely (for example strcpy(local_path, path) or strcat without length checks), and an input path has length >= OS_MAX_LOCAL_PATH_LEN, the string copy will write beyond local_path bounds (no room for terminating '\\0'), causing an out-of-bounds access. This violates MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileChmod_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/879.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileChmod_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileChmod_Impl:\n```c\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n        }\n    }\n\n    close(fd);\n\n    return status;\n}\n```\n</target_code>\nPlease provide the modified OS_FileChmod_Impl code.\n",
  "test_code": "static size_t safe_strnlen(const char *s, size_t max)\n{\n    size_t i = 0;\n    if (s == NULL)\n    {\n        return 0;\n    }\n    while (i < max && s[i] != '\\0')\n    {\n        ++i;\n    }\n    return i;\n}\n\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* LOG: entry and input state */\n    {\n        FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n        if (logf)\n        {\n            fprintf(logf, \"ENTRY: OS_FileChmod_Impl local_path=%p access_mode=%u\\n\", (const void *)local_path, (unsigned)access_mode);\n            if (local_path != NULL)\n            {\n                size_t len = safe_strnlen(local_path, 4096);\n                fprintf(logf, \"  local_path_len=%zu sample=\\\"%.*s\\\"\\n\", len, (int)(len > 256 ? 256 : len), local_path);\n            }\n            else\n            {\n                fprintf(logf, \"  local_path is NULL\\n\");\n            }\n            fclose(logf);\n        }\n    }\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n\n    /* LOG: result of first open attempt */\n    {\n        FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n        if (logf)\n        {\n            fprintf(logf, \"open(O_RDONLY) -> fd=%d errno=%d\\n\", fd, errno);\n            fclose(logf);\n        }\n    }\n\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n\n        /* LOG: result of second open attempt */\n        {\n            FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"open(O_WRONLY) -> fd=%d errno=%d\\n\", fd, errno);\n                fclose(logf);\n            }\n        }\n\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n\n            /* LOG: failing open final */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"FAILED: both open attempts failed for path=%p errno=%d\\n\", (const void *)local_path, errno);\n                    if (local_path)\n                    {\n                        size_t len = safe_strnlen(local_path, 4096);\n                        fprintf(logf, \"  local_path_len=%zu sample=\\\"%.*s\\\"\\n\", len, (int)(len > 256 ? 256 : len), local_path);\n                    }\n                    fclose(logf);\n                }\n            }\n\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n\n        /* LOG: fstat failed */\n        {\n            FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"fstat FAILED for fd=%d path=%p errno=%d\\n\", fd, (const void *)local_path, errno);\n                fclose(logf);\n            }\n        }\n\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* LOG: fstat success and initial stat values */\n        {\n            FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"fstat OK fd=%d st_mode=0%o st_uid=%lu st_gid=%lu\\n\", fd, (unsigned)st.st_mode, (unsigned long)st.st_uid, (unsigned long)st.st_gid);\n                fclose(logf);\n            }\n        }\n\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n\n            /* LOG: user owns file */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"owner match: using user bits readbits=0%o writebits=0%o\\n\", (unsigned)readbits, (unsigned)writebits);\n                    fclose(logf);\n                }\n            }\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n\n            /* LOG: group owns file */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"group match: using group bits readbits=0%o writebits=0%o\\n\", (unsigned)readbits, (unsigned)writebits);\n                    fclose(logf);\n                }\n            }\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n\n            /* LOG: setting write bits */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"access_mode requests write bits: applied writebits=0%o new_st_mode=0%o\\n\", (unsigned)writebits, (unsigned)st.st_mode);\n                    fclose(logf);\n                }\n            }\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n\n            /* LOG: clearing write bits */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"access_mode clears write bits: cleared writebits=0%o new_st_mode=0%o\\n\", (unsigned)writebits, (unsigned)st.st_mode);\n                    fclose(logf);\n                }\n            }\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n\n            /* LOG: setting read bits */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"access_mode requests read bits: applied readbits=0%o new_st_mode=0%o\\n\", (unsigned)readbits, (unsigned)st.st_mode);\n                    fclose(logf);\n                }\n            }\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n\n            /* LOG: clearing read bits */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"access_mode clears read bits: cleared readbits=0%o new_st_mode=0%o\\n\", (unsigned)readbits, (unsigned)st.st_mode);\n                    fclose(logf);\n                }\n            }\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /* LOG: fchmod failed, record errno and prepared mode */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"fchmod FAILED fd=%d attempted_mode=0%o errno=%d\\n\", fd, (unsigned)st.st_mode, errno);\n                    fclose(logf);\n                }\n            }\n\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            /* LOG: fchmod success */\n            {\n                FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"fchmod OK fd=%d final_mode=0%o\\n\", fd, (unsigned)st.st_mode);\n                    fclose(logf);\n                }\n            }\n\n            status = OS_SUCCESS;\n        }\n    }\n\n    /* Ensure fd is closed and log the close result */\n    {\n        int cerr = close(fd);\n        FILE *logf = fopen(\"/tmp/logs/879.txt\", \"a\");\n        if (logf)\n        {\n            fprintf(logf, \"close(fd=%d) -> %d\\n\", fd, cerr);\n            fprintf(logf, \"EXIT: status=%d\\n\", status);\n            fclose(logf);\n        }\n    }\n\n    return status;\n}\n"
}