{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void UtAssert_LogAppend(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2897.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* best effort logging only */\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\nstatic bool UtAssertEx_LogAndCall(bool Result, int CaseType, const char *File, uint32_t Line,\n                                  const char *FormattedMessage)\n{\n    /* Log pre-call state */\n    UtAssert_LogAppend(\"[PRE] UtAssertEx call: Result=%d, CaseType=%d, File=%s, Line=%u, Message=\\\"%s\\\"\",\n                       Result, CaseType, File ? File : \"(null)\", Line, FormattedMessage ? FormattedMessage : \"(null)\");\n\n    /* Call the real UtAssertEx. We pass the pre-formatted message as a single string. */\n    bool ret = UtAssertEx(Result, CaseType, File, Line, \"%s\", FormattedMessage);\n\n    /* Log post-call state */\n    UtAssert_LogAppend(\"[POST] UtAssertEx returned: %d\", ret);\n\n    return ret;\n}\n\nbool UtAssert_StringBufCompare(const char *String1, size_t String1Max, const char *String2, size_t String2Max,\n                               /* UtAssert_Compare_t */ int CompareType, const char *File, uint32 Line)\n{\n    char        ScrubbedString1[256];\n    char        ScrubbedString2[256];\n    const char *EndPtr1;\n    const char *EndPtr2;\n    size_t      FormatLen1;\n    size_t      FormatLen2;\n    bool        Result;\n    int         Compare;\n\n    /* Locate the actual end of both strings */\n    if (String1 == NULL)\n    {\n        EndPtr1 = NULL;\n    }\n    else if (String1Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        /*\n         * NOTE: it is technically undefined behavior to pass a size to memchr()\n         * that is larger than the actual buffer, even if it is known/guaranteed\n         * to find a match within the actual buffer.  Therefore the regular strlen()\n         * is used instead.\n         */\n        EndPtr1 = String1 + strlen(String1);\n    }\n    else\n    {\n        EndPtr1 = memchr(String1, 0, String1Max);\n    }\n\n    if (EndPtr1 != NULL)\n    {\n        FormatLen1 = EndPtr1 - String1;\n    }\n    else\n    {\n        FormatLen1 = String1Max;\n    }\n\n    if (String2 == NULL)\n    {\n        EndPtr2 = NULL;\n    }\n    else if (String2Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        EndPtr2 = String2 + strlen(String2);\n    }\n    else\n    {\n        EndPtr2 = memchr(String2, 0, String2Max);\n    }\n\n    if (EndPtr2 != NULL)\n    {\n        FormatLen2 = EndPtr2 - String2;\n    }\n    else\n    {\n        FormatLen2 = String2Max;\n    }\n\n    if (FormatLen1 == 0 && FormatLen2 == 0)\n    {\n        /* Two empty strings are considered equal */\n        Compare = 0;\n    }\n    else\n    {\n        /* Compare actual content based on the shorter of the two strings */\n        if (FormatLen1 < FormatLen2)\n        {\n            Compare = memcmp(String1, String2, FormatLen1);\n        }\n        else\n        {\n            Compare = memcmp(String1, String2, FormatLen2);\n        }\n\n        /* If initial content was the same, go by whichever is longer */\n        if (Compare == 0)\n        {\n            /*\n             * If String1 is longer, compare should be positive (String1 > String2)\n             * If String2 is longer, compare should be negative (String1 < String2)\n             * If strings are the same length, compare should be 0.\n             */\n            Compare = FormatLen1 - FormatLen2;\n        }\n    }\n\n    switch (CompareType)\n    {\n        case UtAssert_Compare_EQ: /* actual equals reference value */\n            Result = (Compare == 0);\n            break;\n        case UtAssert_Compare_NEQ: /* actual does not non equal reference value */\n            Result = (Compare != 0);\n            break;\n        case UtAssert_Compare_LT: /* actual less than reference (exclusive) */\n            Result = (Compare < 0);\n            break;\n        case UtAssert_Compare_GT: /* actual greater than reference (exclusive)  */\n            Result = (Compare > 0);\n            break;\n        case UtAssert_Compare_LTEQ: /* actual less than or equal to reference (inclusive) */\n            Result = (Compare <= 0);\n            break;\n        case UtAssert_Compare_GTEQ: /* actual greater than reference (inclusive) */\n            Result = (Compare >= 0);\n            break;\n        default: /* should never happen */\n            Result = false;\n            break;\n    }\n\n    /* Now make \"safe\" copies of the strings */\n    /* Check for a newline within the string, and if present, end the string there instead */\n    if (FormatLen1 > 0)\n    {\n        EndPtr1 = memchr(String1, '\\n', FormatLen1);\n        if (EndPtr1 != NULL)\n        {\n            FormatLen1 = EndPtr1 - String1;\n        }\n        memcpy(ScrubbedString1, String1, FormatLen1);\n    }\n    ScrubbedString1[FormatLen1] = 0;\n\n    if (FormatLen2 > 0)\n    {\n        EndPtr2 = memchr(String2, '\\n', FormatLen2);\n        if (EndPtr2 != NULL)\n        {\n            FormatLen2 = EndPtr2 - String2;\n        }\n        memcpy(ScrubbedString2, String2, FormatLen2);\n    }\n    ScrubbedString2[FormatLen2] = 0;\n\n    /*\n     * Prepare the final message and log internal state so other agents can\n     * reproduce the conditions leading up to the UtAssertEx call. This logs\n     * the control path and values such as Compare, Result, FormatLen1/2 and\n     * the CompareType selector.\n     */\n    char FinalMsg[512];\n    (void)snprintf(FinalMsg, sizeof(FinalMsg), \"String: '%s' == '%s'\", ScrubbedString1, ScrubbedString2);\n\n    UtAssert_LogAppend(\"[STATE] Compare=%d, Result=%d, FormatLen1=%zu, FormatLen2=%zu, CompareType=%d\",\n                       Compare, Result ? 1 : 0, FormatLen1, FormatLen2, CompareType);\n\n    /* Log that we will call UtAssertEx with a failure case type. This shows the\n     * value passed into UtAssertEx; agents can then inspect UtAssertEx behavior\n     * (e.g. by also logging inside UtAssertEx) to determine if the parameter\n     * was modified inside that function. */\n    UtAssert_LogAppend(\"[CALL] Invoking UtAssertEx with CaseType=%d (UTASSERT_CASETYPE_FAILURE expected), File=%s, Line=%u\",\n                       (int)UTASSERT_CASETYPE_FAILURE, File ? File : \"(null)\", Line);\n\n    /* Call UtAssertEx via logging wrapper to capture the call and return. */\n    return UtAssertEx_LogAndCall(Result, (int)UTASSERT_CASETYPE_FAILURE, File, Line, FinalMsg);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpo5kyh1m0/src/ut_assert/src/utassert.c:615:6: error: conflicting types for 'UtAssert_StringBufCompare'; have '_Bool(const char *, size_t,  const char *, size_t,  int,  const char *, uint32)' {aka '_Bool(const char *, long unsigned int,  const char *, long unsigned int,  int,  const char *, unsigned int)'}\n  615 | bool UtAssert_StringBufCompare(const char *String1, size_t String1Max, const char *String2, size_t String2Max,\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo5kyh1m0/src/ut_assert/src/utassert.c:44:\n/tmp/tmpo5kyh1m0/src/ut_assert/inc/utassert.h:1004:6: note: previous declaration of 'UtAssert_StringBufCompare' with type '_Bool(const char *, size_t,  const char *, size_t,  UtAssert_Compare_t,  const char *, uint32)' {aka '_Bool(const char *, long unsigned int,  const char *, long unsigned int,  UtAssert_Compare_t,  const char *, unsigned int)'}\n 1004 | bool UtAssert_StringBufCompare(const char *String1, size_t String1Max, const char *String2, size_t String2Max,\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:76: ut_assert/CMakeFiles/ut_assert.dir/src/utassert.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UtAssert_StringBufCompare as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void UtAssert_LogAppend(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2897.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* best effort logging only */\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\nstatic bool UtAssertEx_LogAndCall(bool Result, int CaseType, const char *File, uint32_t Line,\n                                  const char *FormattedMessage)\n{\n    /* Log pre-call state */\n    UtAssert_LogAppend(\"[PRE] UtAssertEx call: Result=%d, CaseType=%d, File=%s, Line=%u, Message=\\\"%s\\\"\",\n                       Result, CaseType, File ? File : \"(null)\", Line, FormattedMessage ? FormattedMessage : \"(null)\");\n\n    /* Call the real UtAssertEx. We pass the pre-formatted message as a single string. */\n    bool ret = UtAssertEx(Result, CaseType, File, Line, \"%s\", FormattedMessage);\n\n    /* Log post-call state */\n    UtAssert_LogAppend(\"[POST] UtAssertEx returned: %d\", ret);\n\n    return ret;\n}\n\nbool UtAssert_StringBufCompare(const char *String1, size_t String1Max, const char *String2, size_t String2Max,\n                               UtAssert_Compare_t CompareType, const char *File, uint32 Line)\n{\n    char        ScrubbedString1[256];\n    char        ScrubbedString2[256];\n    const char *EndPtr1;\n    const char *EndPtr2;\n    size_t      FormatLen1;\n    size_t      FormatLen2;\n    bool        Result;\n    int         Compare;\n\n    /* Locate the actual end of both strings */\n    if (String1 == NULL)\n    {\n        EndPtr1 = NULL;\n    }\n    else if (String1Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        /*\n         * NOTE: it is technically undefined behavior to pass a size to memchr()\n         * that is larger than the actual buffer, even if it is known/guaranteed\n         * to find a match within the actual buffer.  Therefore the regular strlen()\n         * is used instead.\n         */\n        EndPtr1 = String1 + strlen(String1);\n    }\n    else\n    {\n        EndPtr1 = memchr(String1, 0, String1Max);\n    }\n\n    if (EndPtr1 != NULL)\n    {\n        FormatLen1 = EndPtr1 - String1;\n    }\n    else\n    {\n        FormatLen1 = String1Max;\n    }\n\n    if (String2 == NULL)\n    {\n        EndPtr2 = NULL;\n    }\n    else if (String2Max == UTASSERT_STRINGBUF_NULL_TERM)\n    {\n        EndPtr2 = String2 + strlen(String2);\n    }\n    else\n    {\n        EndPtr2 = memchr(String2, 0, String2Max);\n    }\n\n    if (EndPtr2 != NULL)\n    {\n        FormatLen2 = EndPtr2 - String2;\n    }\n    else\n    {\n        FormatLen2 = String2Max;\n    }\n\n    if (FormatLen1 == 0 && FormatLen2 == 0)\n    {\n        /* Two empty strings are considered equal */\n        Compare = 0;\n    }\n    else\n    {\n        /* Compare actual content based on the shorter of the two strings */\n        if (FormatLen1 < FormatLen2)\n        {\n            Compare = memcmp(String1, String2, FormatLen1);\n        }\n        else\n        {\n            Compare = memcmp(String1, String2, FormatLen2);\n        }\n\n        /* If initial content was the same, go by whichever is longer */\n        if (Compare == 0)\n        {\n            /*\n             * If String1 is longer, compare should be positive (String1 > String2)\n             * If String2 is longer, compare should be negative (String1 < String2)\n             * If strings are the same length, compare should be 0.\n             */\n            Compare = FormatLen1 - FormatLen2;\n        }\n    }\n\n    switch (CompareType)\n    {\n        case UtAssert_Compare_EQ: /* actual equals reference value */\n            Result = (Compare == 0);\n            break;\n        case UtAssert_Compare_NEQ: /* actual does not non equal reference value */\n            Result = (Compare != 0);\n            break;\n        case UtAssert_Compare_LT: /* actual less than reference (exclusive) */\n            Result = (Compare < 0);\n            break;\n        case UtAssert_Compare_GT: /* actual greater than reference (exclusive)  */\n            Result = (Compare > 0);\n            break;\n        case UtAssert_Compare_LTEQ: /* actual less than or equal to reference (inclusive) */\n            Result = (Compare <= 0);\n            break;\n        case UtAssert_Compare_GTEQ: /* actual greater than reference (inclusive) */\n            Result = (Compare >= 0);\n            break;\n        default: /* should never happen */\n            Result = false;\n            break;\n    }\n\n    /* Now make \"safe\" copies of the strings */\n    /* Check for a newline within the string, and if present, end the string there instead */\n    if (FormatLen1 > 0)\n    {\n        EndPtr1 = memchr(String1, '\\n', FormatLen1);\n        if (EndPtr1 != NULL)\n        {\n            FormatLen1 = EndPtr1 - String1;\n        }\n        memcpy(ScrubbedString1, String1, FormatLen1);\n    }\n    ScrubbedString1[FormatLen1] = 0;\n\n    if (FormatLen2 > 0)\n    {\n        EndPtr2 = memchr(String2, '\\n', FormatLen2);\n        if (EndPtr2 != NULL)\n        {\n            FormatLen2 = EndPtr2 - String2;\n        }\n        memcpy(ScrubbedString2, String2, FormatLen2);\n    }\n    ScrubbedString2[FormatLen2] = 0;\n\n    /*\n     * Prepare the final message and log internal state so other agents can\n     * reproduce the conditions leading up to the UtAssertEx call. This logs\n     * the control path and values such as Compare, Result, FormatLen1/2 and\n     * the CompareType selector.\n     */\n    char FinalMsg[512];\n    (void)snprintf(FinalMsg, sizeof(FinalMsg), \"String: '%s' == '%s'\", ScrubbedString1, ScrubbedString2);\n\n    UtAssert_LogAppend(\"[STATE] Compare=%d, Result=%d, FormatLen1=%zu, FormatLen2=%zu, CompareType=%d\",\n                       Compare, Result ? 1 : 0, FormatLen1, FormatLen2, CompareType);\n\n    /* Log that we will call UtAssertEx with a failure case type. This shows the\n     * value passed into UtAssertEx; agents can then inspect UtAssertEx behavior\n     * (e.g. by also logging inside UtAssertEx) to determine if the parameter\n     * was modified inside that function. */\n    UtAssert_LogAppend(\"[CALL] Invoking UtAssertEx with CaseType=%d (UTASSERT_CASETYPE_FAILURE expected), File=%s, Line=%u\",\n                       (int)UTASSERT_CASETYPE_FAILURE, File ? File : \"(null)\", Line);\n\n    /* Call UtAssertEx via logging wrapper to capture the call and return. */\n    return UtAssertEx_LogAndCall(Result, (int)UTASSERT_CASETYPE_FAILURE, File, Line, FinalMsg);\n}\n",
  "explanation": "The header declared UtAssert_StringBufCompare to take UtAssert_Compare_t for the CompareType parameter (and uint32 for Line). The implementation used an int for CompareType, causing a conflicting type error. I changed the function signature to match the header: replaced the int CompareType parameter with UtAssert_Compare_t CompareType (keeping uint32 Line). No other logic was changed."
}