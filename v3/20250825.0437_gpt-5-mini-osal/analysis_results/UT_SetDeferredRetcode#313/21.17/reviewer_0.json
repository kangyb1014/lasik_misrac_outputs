{
  "user_message": "An agent A claimed that the following UT_SetDeferredRetcode code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_SetDeferredRetcode.\n```c\nvoid UT_SetDeferredRetcode(UT_EntryKey_t FuncKey, int32 Count, UT_IntReturn_t Retcode)\n{\n    /* The count should always be a positive integer, if not there is a bug in the test */\n    if (Count <= 0)\n    {\n        UtAssert_Failed(\"BUG: Invalid Count (%ld) passed to UT_SetDeferredRetcode()\", (long)Count);\n    }\n    else\n    {\n        UT_ConfigureGenericStubReturnValue(FuncKey, &Retcode, sizeof(Retcode), UT_ValueGenre_INTEGER, Count, NULL);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code stores the TypeName pointer directly into the stub table (StubPtr->Data.Rvc.TypeName = TypeName) without copying it. If the caller passes a pointer to a temporary/stack buffer or to a non-null-terminated buffer, and later code uses a <string.h> routine (e.g. strlen, strcpy, strcat, strcmp) on StubPtr->Data.Rvc.TypeName, that string function can access beyond the lifetime or bounds of the original object and therefore violate MISRA C 2023 Rule 21.17. For example: a caller creates a local char name[16]; fills it; calls UT_SetDeferredRetcode(..., name); the local name goes out of scope; later code calls strlen(StubPtr->Data.Rvc.TypeName) \u2014 this may read out-of-bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=ENTRY FuncKey=0x56518b99726e Count=2 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=BEFORE_CONFIGURE FuncKey=0x56518b99726e Count=2 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=AFTER_CONFIGURE FuncKey=0x56518b99726e Count=2 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=EXIT FuncKey=0x56518b99726e Count=2 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=ENTRY FuncKey=0x56518b99457f Count=1 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=BEFORE_CONFIGURE FuncKey=0x56518b99457f Count=1 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=AFTER_CONFIGURE FuncKey=0x56518b99457f Count=1 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914474 TID=18446744072805709632 STAGE=EXIT FuncKey=0x56518b99457f Count=1 ValuePtr=0x7fffd689a668 ValueVal=-1\n[1756100354] PID=3914482 TID=1393952576 STAGE=ENTRY FuncKey=0x55f4a9b8160c Count=1 ValuePtr=0x7fffbbd4eba8 ValueVal=-1\n[1756100354] PID=3914482 TID=1393952576 STAGE=BEFORE_CONFIGURE FuncKey=0x55f4a9b8160c Count=1 ValuePtr=0x7fffbbd4eba8 ValueVal=-1\n[1756100354] PID=3914482 TID=1393952576 STAGE=AFTER_CONFIGURE FuncKey=0x55f4a9b8160c Count=1 ValuePtr=0x7fffbbd4eba8 ValueVal=-1\n[1756100354] PID=3914482 TID=1393952576 STAGE=EXIT FuncKey=0x55f4a9b8160c Count=1 ValuePtr=0x7fffbbd4eba8 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=ENTRY FuncKey=0x5600e00f9faf Count=2 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=BEFORE_CONFIGURE FuncKey=0x5600e00f9faf Count=2 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=AFTER_CONFIGURE FuncKey=0x5600e00f9faf Count=2 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=EXIT FuncKey=0x5600e00f9faf Count=2 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=ENTRY FuncKey=0x5600e00f5b03 Count=1 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=BEFORE_CONFIGURE FuncKey=0x5600e00f5b03 Count=1 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=AFTER_CONFIGURE FuncKey=0x5600e00f5b03 Count=1 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914496 TID=1644066624 STAGE=EXIT FuncKey=0x5600e00f5b03 Count=1 ValuePtr=0x7ffd1bab9128 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=ENTRY FuncKey=0x561d807429f6 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=BEFORE_CONFIGURE FuncKey=0x561d807429f6 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=AFTER_CONFIGURE FuncKey=0x561d807429f6 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=EXIT FuncKey=0x561d807429f6 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=ENTRY FuncKey=0x561d80747c56 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=BEFORE_CONFIGURE FuncKey=0x561d80747c56 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=AFTER_CONFIGURE FuncKey=0x561d80747c56 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=EXIT FuncKey=0x561d80747c56 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=ENTRY FuncKey=0x561d807477f8 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=BEFORE_CONFIGURE FuncKey=0x561d807477f8 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=AFTER_CONFIGURE FuncKey=0x561d807477f8 Count=1 ValuePtr=0x7fff42c387e8 ValueVal=-1\n[1756100354] PID=3914506 TID=18446744071683413824 STAGE=\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_SetDeferredRetcode:\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\n#define UtAssert_Failed(__VA_ARGS__) UtAssertEx(false,UtAssert_GetContext(),__FILE__,__LINE__,__VA_ARGS__)\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. UT_SetDeferredRetcode does not take or pass any string pointer \u2014 it calls UT_ConfigureGenericStubReturnValue with the final parameter TypeName set to NULL. Rule 21.17 concerns calls to <string.h> routines (strlen, strcpy, etc.) that may access beyond an object\u2019s bounds. Neither UT_SetDeferredRetcode nor UT_ConfigureGenericStubReturnValue invoke any <string.h> function here. While UT_ConfigureGenericStubReturnValue does store the TypeName pointer (StubPtr->Data.Rvc.TypeName = TypeName) and thereby could enable a later misuse (e.g. a caller passing a pointer to a stack buffer which is later used with strlen), that potential misuse would be a violation at the site where a string.h function is actually called or where a pointer to a transient buffer is accepted without documented lifetime requirements \u2014 not a direct violation by UT_SetDeferredRetcode itself. In short, the provided UT_SetDeferredRetcode code does not trigger MISRA C:2023 Rule 21.17, so the report is false."
}