{
  "user_message": "An agent A claimed that the following UT_SetDeferredRetcode code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of UT_SetDeferredRetcode.\n```c\nvoid UT_SetDeferredRetcode(UT_EntryKey_t FuncKey, int32 Count, UT_IntReturn_t Retcode)\n{\n    /* The count should always be a positive integer, if not there is a bug in the test */\n    if (Count <= 0)\n    {\n        UtAssert_Failed(\"BUG: Invalid Count (%ld) passed to UT_SetDeferredRetcode()\", (long)Count);\n    }\n    else\n    {\n        UT_ConfigureGenericStubReturnValue(FuncKey, &Retcode, sizeof(Retcode), UT_ValueGenre_INTEGER, Count, NULL);\n    }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The assignment StubPtr->Data.Rvc.ActualSz = ValueSize sets the stored size without any bounds checking. Later, for non-opaque genres the code calls UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre), which typically uses memcpy/memmove to copy ValueSize bytes into the internal buffer. If ValueSize is larger than the destination buffer in StubPtr->Data.Rvc.Buf (or larger than the actual object pointed to by ValuePtr), the subsequent string.h-based copy will access beyond object bounds. Example: ValueGenre != UT_ValueGenre_OPAQUE, ValuePtr points to a small buffer but ValueSize is larger than Buf capacity \u2014 memcpy(ValuePtr, Buf, ValueSize) would overflow and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756100445] PID:4036036 Entered UT_SetDeferredRetcode: FuncKey=94495254860430, Count=2, Retcode_size=8\n[1756100445] PID:4036036 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94495254860430, Retcode(@0x7ffdf07f3d58) size=8, Genre=INTEGER, Count=2\n[1756100445] PID:4036036 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94495254860430, Count=2\n[1756100445] PID:4036036 Entered UT_SetDeferredRetcode: FuncKey=94495254848927, Count=1, Retcode_size=8\n[1756100445] PID:4036036 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94495254848927, Retcode(@0x7ffdf07f3d58) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036036 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94495254848927, Count=1\n[1756100445] PID:4036048 Entered UT_SetDeferredRetcode: FuncKey=93966429001260, Count=1, Retcode_size=8\n[1756100445] PID:4036048 About to call UT_ConfigureGenericStubReturnValue: FuncKey=93966429001260, Retcode(@0x7ffe6b94ecd8) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036048 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=93966429001260, Count=1\n[1756100445] PID:4036074 Entered UT_SetDeferredRetcode: FuncKey=94222529781711, Count=2, Retcode_size=8\n[1756100445] PID:4036074 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94222529781711, Retcode(@0x7fff14a0b338) size=8, Genre=INTEGER, Count=2\n[1756100445] PID:4036074 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94222529781711, Count=2\n[1756100445] PID:4036074 Entered UT_SetDeferredRetcode: FuncKey=94222529764131, Count=1, Retcode_size=8\n[1756100445] PID:4036074 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94222529764131, Retcode(@0x7fff14a0b338) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036074 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94222529764131, Count=1\n[1756100445] PID:4036088 Entered UT_SetDeferredRetcode: FuncKey=94619266632214, Count=1, Retcode_size=8\n[1756100445] PID:4036088 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94619266632214, Retcode(@0x7ffc1d78f638) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036088 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94619266632214, Count=1\n[1756100445] PID:4036088 Entered UT_SetDeferredRetcode: FuncKey=94619266653302, Count=1, Retcode_size=8\n[1756100445] PID:4036088 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94619266653302, Retcode(@0x7ffc1d78f638) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036088 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94619266653302, Count=1\n[1756100445] PID:4036088 Entered UT_SetDeferredRetcode: FuncKey=94619266652184, Count=1, Retcode_size=8\n[1756100445] PID:4036088 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94619266652184, Retcode(@0x7ffc1d78f638) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036088 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94619266652184, Count=1\n[1756100445] PID:4036096 Entered UT_SetDeferredRetcode: FuncKey=94783904979028, Count=1, Retcode_size=8\n[1756100445] PID:4036096 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94783904979028, Retcode(@0x7ffcb0581638) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036096 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94783904979028, Count=1\n[1756100445] PID:4036096 Entered UT_SetDeferredRetcode: FuncKey=94783904979028, Count=1, Retcode_size=8\n[1756100445] PID:4036096 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94783904979028, Retcode(@0x7ffcb0581638) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036096 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94783904979028, Count=1\n[1756100445] PID:4036100 Entered UT_SetDeferredRetcode: FuncKey=94485259916505, Count=1, Retcode_size=8\n[1756100445] PID:4036100 About to call UT_ConfigureGenericStubReturnValue: FuncKey=94485259916505, Retcode(@0x7fff41f3bfb8) size=8, Genre=INTEGER, Count=1\n[1756100445] PID:4036100 Returned from UT_ConfigureGenericStubReturnValue: FuncKey=94485259916505, Count=1\n[1756100445] PID:4036100 Entered UT_SetDeferredRetcode: FuncKey=944852\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function UT_SetDeferredRetcode:\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n...\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\n#define UtAssert_Failed(__VA_ARGS__) UtAssertEx(false,UtAssert_GetContext(),__FILE__,__LINE__,__VA_ARGS__)\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in its assessment of a potential MISRA 21.17 violation. UT_SetDeferredRetcode passes a caller-supplied ValueSize (sizeof(Retcode)) into UT_ConfigureGenericStubReturnValue, which assigns Data.Rvc.ActualSz = ValueSize and then \u2014 for non-opaque genres \u2014 calls UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre) without any bounds checking shown in the provided code. If UT_StoreRetval uses memcpy/memmove (as the scenario states) and does not itself ensure the destination buffer is large enough (or clamp/validate ValueSize), that memcpy/memmove can read/write past the bounds of the source or destination object, which is exactly what MISRA C 2023 Rule 21.17 forbids. The only way this would not be a violation is if UT_StoreRetval internally enforces size checks or the buffer capacity is guaranteed elsewhere; no such guarantee or checks are visible in the supplied code, so the report of a potential Rule 21.17 violation is justified."
}