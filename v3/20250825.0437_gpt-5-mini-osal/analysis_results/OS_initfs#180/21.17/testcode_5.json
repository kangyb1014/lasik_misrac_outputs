{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential buffer over-read if OS_CHECK_STRING uses an unbounded string operation (e.g. strlen) on fsvolname. For example, if a caller passes fsvolname pointing to a 5-byte buffer without a terminating NUL (char name[5] = { 'A','B','C','D','E' };) then OS_CHECK_STRING(fsvolname, sizeof(filesys->volume_name), ...) that invokes strlen(fsvolname) would read beyond the bounds of the 5-byte object, violating Rule 21.17. If the macro instead uses a bounded routine (e.g. strnlen with the supplied size) then the violation would not occur.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_initfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1809.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_initfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_initfs:\n```c\nint32 OS_initfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, false);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_initfs code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <ctype.h>\n\n/*\n * Probe helpers for OS_initfs logging. These are kept local/static so they\n * do not change the external interface or program logic. They write logs to\n * /tmp/logs/1809.txt for later inspection by other agents.\n *\n * Note: we intentionally use a bounded scan (probe_strnlen) rather than\n * calling strlen() without bounds to avoid introducing the very unbounded\n * string operation that the violation scenario is concerned with.\n */\nstatic size_t probe_strnlen(const char *s, size_t maxlen)\n{\n    size_t i;\n    if (s == NULL)\n    {\n        return 0;\n    }\n    for (i = 0; i < maxlen; ++i)\n    {\n        if (s[i] == '\\0')\n        {\n            return i;\n        }\n    }\n    return maxlen;\n}\n\nstatic void probe_log_bytes(FILE *f, const char *label, const char *s, size_t maxlen)\n{\n    size_t len = probe_strnlen(s, maxlen);\n    size_t i;\n\n    fprintf(f, \"%s: ptr=%p len_reported=%zu contents(hex, up to 64 bytes):\", label, (const void *)s, len);\n\n    for (i = 0; i < len && i < 64; ++i)\n    {\n        fprintf(f, \" %02X\", (unsigned char)s[i]);\n    }\n    if (len > 64)\n    {\n        fprintf(f, \" ...\");\n    }\n    if (len == maxlen)\n    {\n        fprintf(f, \" (no NUL found within bound=%zu)\", maxlen);\n    }\n    fprintf(f, \"\\n\");\n}\n\nstatic void probe_log_entry(char *address, const char *devname, const char *volname, size_t blocksize, unsigned long long numblocks)\n{\n    FILE *f = fopen(\"/tmp/logs/1809.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"OS_initfs ENTRY:\\n\");\n    fprintf(f, \"  address ptr=%p\\n\", (void *)address);\n    fprintf(f, \"  devname ptr=%p\\n\", (const void *)devname);\n    fprintf(f, \"  volname ptr=%p\\n\", (const void *)volname);\n    fprintf(f, \"  blocksize=%zu numblocks=%llu\\n\", blocksize, numblocks);\n\n    /* Probe the devname and volname with a conservative bound to avoid\n     * unbounded reads. This captures whether the string appears NUL-terminated\n     * within the bound and prints a hex dump of the initial bytes. */\n    probe_log_bytes(f, \"  devname\", devname, 256);\n    probe_log_bytes(f, \"  volname\", volname, 256);\n\n    fclose(f);\n}\n\nstatic void probe_log_exit(int32_t rc_before_translation, int32_t rc_after_translation)\n{\n    FILE *f = fopen(\"/tmp/logs/1809.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"OS_initfs EXIT:\\n\");\n    fprintf(f, \"  return_code_before_translation=%d\\n\", (int)rc_before_translation);\n    fprintf(f, \"  return_code_after_translation=%d\\n\", (int)rc_after_translation);\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\n/*\n * Modified OS_initfs: retains original control flow and semantics while\n * inserting probes to capture inputs and the return-code translation path.\n */\nint32 OS_initfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    /* Log entry and input state. Cast numblocks to unsigned long long for logging. */\n    probe_log_entry(address, devname, volname, blocksize, (unsigned long long)numblocks);\n\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, false);\n\n    /* Preserve original translation behavior but log both before/after values. */\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        int32 prior = return_code;\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n        probe_log_exit(prior, return_code);\n\n        return return_code;\n    }\n\n    probe_log_exit(return_code, return_code);\n    return return_code;\n}\n"
}