{
  "user_message": "An agent A claimed that the following OS_SocketAddrToString_Impl code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAddrToString_Impl.\n```c\nint32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr)\n{\n    const void *                  addrbuffer;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            addrbuffer = &Accessor->sa_in.sin_addr;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrbuffer = &Accessor->sa_in6.sin6_addr;\n            break;\n#endif\n        default:\n            return OS_ERR_BAD_ADDRESS;\n            break;\n    }\n\n    if (inet_ntop(Accessor->sa.sa_family, addrbuffer, buffer, buflen) == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf sock->stream_name is not NUL-terminated such that OS_strnlen(sock->stream_name, sizeof(sock->stream_name)) returns sizeof(sock->stream_name), then len == sizeof(sock->stream_name). The expression &sock->stream_name[len] yields a pointer one-past-the-end of the array and is passed as the destination argument to snprintf. Even though the size argument becomes 0, passing a pointer that refers beyond the object bounds to a string handling function can lead to accesses beyond the object and thus violates MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SocketAddrToString_Impl:\ntypedef struct\n{\n    size_t            ActualLength; /**< @brief Length of the actual address data */\n    OS_SockAddrData_t AddrData;     /**< @brief Abstract Address data */\n} OS_SockAddr_t\n...\ntypedef union\n{\n    char               data[OS_SOCKADDR_MAX_LEN];\n    struct sockaddr    sa;\n    struct sockaddr_in sa_in;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n    struct sockaddr_in6 sa_in6;\n#endif\n} OS_SockAddr_Accessor_t\n...\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n...\nint32 OS_SocketAddrToString(char *buffer, size_t buflen, const OS_SockAddr_t *Addr)\n{\n    /* Check parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buflen);\n\n    return OS_SocketAddrToString_Impl(buffer, buflen, Addr);\n}\n...\n#define OS_NETWORK_SUPPORTS_IPV6 \n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for OS_SocketAddrToString_Impl. Rule 21.17 (as quoted) applies to the string functions from <string.h>; the target function calls inet_ntop (not a <string.h> routine). More importantly, the scenario described by agent A concerns passing &sock->stream_name[len] into snprintf in OS_CreateSocketName, not the internals of OS_SocketAddrToString_Impl itself. Even that scenario is guarded against by the behavior of OS_SocketAddrToString_Impl: on success inet_ntop always produces a NUL-terminated string in the provided buffer; on failure OS_SocketAddrToString_Impl returns an error and OS_CreateSocketName sets sock->stream_name[0] = 0. Therefore after the call the stream_name is NUL-terminated when the port/parent-name appends are attempted, so OS_strnlen cannot legally return sizeof(sock->stream_name) in the normal-success path. Thus there is no demonstrated pathway in the provided code where a one-past-the-end pointer is passed as the destination to a <string.h> function by OS_SocketAddrToString_Impl, nor does OS_SocketAddrToString_Impl itself call any of the <string.h> functions listed by the rule. For these reasons the agent A report is incorrect."
}