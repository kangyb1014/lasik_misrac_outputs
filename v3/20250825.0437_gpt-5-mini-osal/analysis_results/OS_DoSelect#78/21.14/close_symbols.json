{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "memset",
    "clock_gettime",
    "select",
    "errno",
    "EINTR",
    "EAGAIN",
    "NULL",
    "fd_set (type and macros)",
    "struct timeval (definition)",
    "struct timespec (definition)",
    "int32 (typedef)",
    "OS_ERROR",
    "OS_ERROR_TIMEOUT",
    "OS_SUCCESS"
  ],
  "explanation": "To determine whether OS_DoSelect violates the MISRA rule banning use of memcmp to compare null-terminated strings we must be sure that no memcmp use is hidden behind any symbol used by the function. The required symbols and why they are needed:\n\n- memset: Called directly in the function. Confirm it is the standard library memset and does not expand to or wrap a memcmp-like routine that could compare strings.\n\n- clock_gettime: Called directly. Verify that its implementation or any wrapper used here does not internally call memcmp on C-strings.\n\n- select: Called directly. Ensure the select implementation or any local wrapper does not call memcmp on null-terminated strings.\n\n- errno: The function checks errno after select. Include to ensure any errno macros/wrappers do not hide memcmp usage.\n\n- EINTR, EAGAIN: Error macros checked in the retry loop. Confirm they are simple integer macros (as expected) and not aliases to functions or macros that might involve memcmp.\n\n- NULL: Used to set tvptr. Include to ensure NULL is the expected null pointer macro and not a macro that could expand to something involving string comparison.\n\n- fd_set (type and macros): rd_set/wr_set are fd_set pointers passed to select. Include the fd_set definition and any associated macros to ensure none use memcmp to compare null-terminated strings.\n\n- struct timeval (definition): tv is a timeval; include its definition to rule out any hidden inline functions/macros associated with timeval that might call memcmp on strings.\n\n- struct timespec (definition): ts_now/ts_end are timespecs; include their definition for the same reason as timeval.\n\n- int32 (typedef): The function uses int32. Include to confirm it is a typedef and not a macro that could expand to something involving memcmp or string comparison.\n\n- OS_ERROR, OS_ERROR_TIMEOUT, OS_SUCCESS: Return-code macros/constants used by the function. Include them to ensure they are simple constants and not macros or inline functions that could internally use memcmp on null-terminated strings.\n\nRationale: The MISRA rule focuses on use of memcmp for null-terminated string comparison. OS_DoSelect itself contains no memcmp call, so the only way it could violate the rule is if any symbol it uses (direct calls, macros, wrappers, or types) expands to or calls memcmp on null-terminated strings. The symbols above cover every function call, macro, and type used in OS_DoSelect so the next-stage analysis can inspect their definitions/implementations for any memcmp usage."
}