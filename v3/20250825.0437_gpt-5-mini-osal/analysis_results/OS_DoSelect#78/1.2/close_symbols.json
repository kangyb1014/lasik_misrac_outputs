{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "int32",
    "fd_set",
    "struct timeval",
    "struct timespec",
    "time_t",
    "suseconds_t",
    "CLOCK_MONOTONIC",
    "clock_gettime",
    "select",
    "errno",
    "EINTR",
    "EAGAIN",
    "memset",
    "NULL",
    "OS_ERROR",
    "OS_ERROR_TIMEOUT",
    "OS_SUCCESS"
  ],
  "explanation": "For determining whether OS_DoSelect uses any compiler language extensions you must inspect the declarations/definitions of every type, macro and function used by the routine to ensure they do not themselves use non\u2011standard language features. The required symbols and why they are needed:\n\n- int32: typedef for the function return/parameter type; its definition must be checked for non\u2011standard attributes or extension keywords.\n- fd_set: type of the rd_set/wr_set parameters; fd_set implementation may use compiler extensions (anonymous structs, bit\u2011fields with implementation extensions, GCC builtins) so inspect its definition.\n- struct timeval: used for tv and tv.tv_sec/tv.tv_usec; ensure the struct and its member types are standard C and do not use compiler extensions.\n- struct timespec: used for ts_now/ts_end; inspect its definition for extensions (e.g., nonstandard attributes or anonymous members).\n- time_t and suseconds_t: underlying typedefs used in timeval/timespec members; their typedefs may use compiler\u2011specific integer aliases or attributes that would constitute extensions.\n- CLOCK_MONOTONIC: macro/enum used as clock id for clock_gettime; verify it is a standard constant and not a compiler extension macro.\n- clock_gettime: declaration (signature) of this function should be checked for nonstandard linkage, attributes, or use of compiler extensions in its prototype.\n- select: system call wrapper used here; ensure its prototype and related types (e.g., fd_set handling) do not rely on compiler extensions.\n- errno: macro/identifier used in the loop condition; errno implementations can be macros that expand to extension constructs (thread\u2011local accessors, __builtin functions) so inspect its definition.\n- EINTR and EAGAIN: macros used to compare errno; verify they are standard integer macros and not defined using compiler\u2011specific constructs.\n- memset: standard library function used here; check its prototype/implementation for nonstandard attributes if present in project headers.\n- NULL: macro used in code (tvptr = NULL); inspect its definition in the environment to ensure it is a standard integer/void* macro and not an extension.\n- OS_ERROR, OS_ERROR_TIMEOUT, OS_SUCCESS: platform/OS return macros used by this module; their definitions must be checked to ensure they are plain macros/constants (no compiler extensions, attributes, or inline asm).\n\nCollecting these symbols lets the next analyst open the precise typedefs/macros/function prototypes used by OS_DoSelect and verify they do not employ compiler vendor extensions (GNU/Clang attributes, builtins, statement expressions, nested functions, nonstandard keywords, etc.)."
}