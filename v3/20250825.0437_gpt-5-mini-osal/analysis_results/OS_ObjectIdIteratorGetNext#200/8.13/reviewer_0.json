{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable 'record' is declared as a mutable pointer (OS_common_record_t *record) but in this function it is only dereferenced for reading (record->active_id) and passed to iter->match for inspection. If neither OS_OBJECT_TABLE_GET nor iter->match need to modify the pointed-to record, the pointer should be declared to point to a const-qualified type (const OS_common_record_t *record). Therefore, unless OS_OBJECT_TABLE_GET or iter->match require a mutable pointer, this use violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation is plausible but not provable from the snippet alone. Rule 8.13 recommends declaring pointers to point to const when the pointed-to object is not modified. In this function, the local variable record is only read (record->active_id) and passed to iter->match, so it could be const if (and only if) both of these are compatible with a const-qualified pointer:\n\n- OS_OBJECT_TABLE_GET must allow assignment to a pointer-to-const (assigning an OS_common_record_t * to a const OS_common_record_t * is permitted).\n- iter->match must accept a pointer-to-const for its third parameter; if it expects a non-const OS_common_record_t * then declaring record const would be incompatible.\n\nBecause the code excerpt does not show the prototype of iter->match or the type/return of OS_OBJECT_TABLE_GET, you cannot definitively conclude a MISRA 8.13 violation. If those APIs already require/allow non-const, then record cannot be const and there is no violation; if they allow const, then the local variable should indeed be declared const and the report would be correct.\n\nRecommendation: inspect the declarations of OS_OBJECT_TABLE_GET and iter->match. If both permit const, change the local declaration to \u201cconst OS_common_record_t *record\u201d; otherwise the current code is acceptable."
}