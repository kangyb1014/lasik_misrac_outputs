{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable 'record' is declared as OS_common_record_t * but is only used for read-only access (accessing record->active_id and passing it to iter->match). It could be declared as 'const OS_common_record_t *record', so using a non-const pointer here violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not conclusively correct given only the snippet. Rule 8.13 says a pointer should point to a const-qualified type whenever possible, but whether that is possible here depends on the callee and the source of the pointer:\n\n- In this function the local 'record' is only used for read access (record->active_id) and passed to iter->match. If iter->match has a prototype taking a pointer-to-const (e.g. const OS_common_record_t *), then 'record' could and should be declared const and the report would be correct.\n- However, if iter->match is typed to accept a non-const OS_common_record_t * (or if the OS_OBJECT_TABLE_GET macro yields a non-const pointer that the API requires to remain non-const), then declaring 'record' const would be incompatible with the match call (or would require a cast). In that case making it const is not possible and there is no violation of 8.13.\n\nBecause the snippet does not show the type/signature of iter->match nor the definition of OS_OBJECT_TABLE_GET, you cannot determine unambiguously that declaring 'record' as const is possible. Therefore the report as stated is not provably correct."
}