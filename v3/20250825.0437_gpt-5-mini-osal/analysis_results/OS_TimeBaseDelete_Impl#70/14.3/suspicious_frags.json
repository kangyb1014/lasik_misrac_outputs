{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_TimeBaseDelete_Impl:\n```c\nint32 OS_TimeBaseDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_timebase_internal_record_t *local;\n    int                                 status;\n\n    local = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, *token);\n\n    pthread_cancel(local->handler_thread);\n\n    /*\n    ** Delete the timer\n    */\n    if (local->assigned_signal != 0)\n    {\n        status = timer_delete(local->host_timerid);\n        if (status < 0)\n        {\n            OS_DEBUG(\"Error deleting timer: %s\\n\", strerror(errno));\n            return OS_TIMER_ERR_INTERNAL;\n        }\n\n        local->assigned_signal = 0;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_TimeBaseDelete_Impl:\nint32 OS_TimeBaseCreate_Impl(const OS_object_token_t *token)\n{\n    int32                               return_code;\n    int                                 status;\n    int                                 i;\n    osal_index_t                        idx;\n    struct sigevent                     evp;\n    struct timespec                     ts;\n    OS_impl_timebase_internal_record_t *local;\n    OS_timebase_internal_record_t *     timebase;\n    OS_VoidPtrValueWrapper_t            arg;\n\n    local    = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, *token);\n    timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, *token);\n\n    /*\n     * Spawn a dedicated time base handler thread\n     *\n     * This alleviates the need to handle expiration in the context of a signal handler -\n     * The handler thread can call a BSP synchronized delay implementation as well as the\n     * application callback function.  It should run with elevated priority to reduce latency.\n     *\n     * Note the thread will not actually start running until this function exits and releases\n     * the global table lock.\n     */\n    memset(&arg, 0, sizeof(arg));\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    arg.id      = OS_ObjectIdFromToken(token);\n    return_code = OS_Posix_InternalTaskCreate_Impl(&local->handler_thread, OSAL_PRIORITY_C(0), 0,\n                                                   OS_TimeBasePthreadEntry, arg.opaque_arg);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    local->assigned_signal = 0;\n    clock_gettime(OS_PREFERRED_CLOCK, &local->softsleep);\n\n    /*\n     * Set up the necessary OS constructs\n     *\n     * If an external sync function is used then there is nothing to do here -\n     * we simply call that function and it should synchronize to the time source.\n     *\n     * If no external sync function is provided then this will set up a POSIX\n     * timer to locally simulate the timer tick using the CPU clock.\n     */\n    if (timebase->external_sync == NULL)\n    {\n        sigemptyset(&local->sigset);\n\n        /*\n         * find an RT signal that is not used by another time base object.\n         * This is all done while the global lock is held so no chance of the\n         * underlying tables changing\n         */\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            if (OS_ObjectIdIsValid(OS_global_timebase_table[idx].active_id) &&\n                OS_impl_timebase_table[idx].assigned_signal != 0)\n            {\n                sigaddset(&local->sigset, OS_impl_timebase_table[idx].assigned_signal);\n            }\n        }\n\n        for (i = SIGRTMIN; i <= SIGRTMAX; ++i)\n        {\n            if (!sigismember(&local->sigset, i))\n            {\n                local->assigned_signal = i;\n                break;\n            }\n        }\n\n        do\n        {\n            if (local->assigned_signal == 0)\n            {\n                OS_DEBUG(\"No free RT signals to use for simulated time base\\n\");\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            sigemptyset(&local->sigset);\n            sigaddset(&local->sigset, local->assigned_signal);\n\n            /*\n             * Ensure that the chosen signal is NOT already pending.\n             *\n             * Perform a \"sigtimedwait\" with a zero timeout to poll the\n             * status of the selected signal.  RT signals are also queued,\n             * so this needs to be called in a loop to until sigtimedwait()\n             * returns an error.\n             *\n             * The max number of signals that can be queued is available\n             * via sysconf() as the _SC_SIGQUEUE_MAX value.\n             *\n             * The output is irrelevant here; the objective is to just ensure\n             * that the signal is not already pending.\n             */\n            i = sysconf(_SC_SIGQUEUE_MAX);\n            do\n            {\n                ts.tv_sec  = 0;\n                ts.tv_nsec = 0;\n                if (sigtimedwait(&local->sigset, NULL, &ts) < 0)\n                {\n                    /* signal is NOT pending */\n                    break;\n                }\n                --i;\n            } while (i > 0);\n\n            /*\n            **  Initialize the sigevent structures for the handler.\n            */\n            memset((void *)&evp, 0, sizeof(evp));\n            evp.sigev_notify = SIGEV_SIGNAL;\n            evp.sigev_signo  = local->assigned_signal;\n\n            /*\n             * Pass the Timer Index value of the object ID to the signal handler --\n             *  Note that the upper bits can be safely assumed as a timer ID to recreate the original,\n             *  and doing it this way should still work on a system where sizeof(sival_int) < sizeof(uint32)\n             *  (as long as sizeof(sival_int) >= number of bits in OS_OBJECT_INDEX_MASK)\n             */\n            evp.sigev_value.sival_int = (int)OS_ObjectIdToSerialNumber_Impl(OS_ObjectIdFromToken(token));\n\n            /*\n            ** Create the timer\n            ** Note using the \"MONOTONIC\" clock here as this will still produce consistent intervals\n            ** even if the system clock is stepped (e.g. clock_settime).\n            */\n            status = timer_create(OS_PREFERRED_CLOCK, &evp, &local->host_timerid);\n            if (status < 0)\n            {\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            timebase->external_sync = OS_TimeBase_SigWaitImpl;\n        } while (0);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /*\n         * NOTE about the thread cancellation -- this technically is just a backup,\n         * we should not need to cancel it because the handler thread will exit automatically\n         * if the active ID does not match the expected value.  This check would fail\n         * if this function returns non-success (the ID in the global will be set zero)\n         */\n        pthread_cancel(local->handler_thread);\n        local->assigned_signal = 0;\n    }\n\n    return return_code;\n}\n...\nint32 OS_TimeBaseSet_Impl(const OS_object_token_t *token, uint32 start_time, uint32 interval_time)\n{\n    OS_impl_timebase_internal_record_t *local;\n    struct itimerspec                   timeout;\n    int32                               return_code;\n    int                                 status;\n    OS_timebase_internal_record_t *     timebase;\n\n    local       = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, *token);\n    timebase    = OS_OBJECT_TABLE_GET(OS_timebase_table, *token);\n    return_code = OS_SUCCESS;\n\n    /* There is only something to do here if we are generating a simulated tick */\n    if (local->assigned_signal != 0)\n    {\n        /*\n        ** Convert from Microseconds to timespec structures\n        */\n        memset(&timeout, 0, sizeof(timeout));\n        OS_UsecToTimespec(start_time, &timeout.it_value);\n        OS_UsecToTimespec(interval_time, &timeout.it_interval);\n\n        /*\n        ** Program the real timer\n        */\n        status = timer_settime(local->host_timerid, 0, /* Flags field can be zero */\n                               &timeout,               /* struct itimerspec */\n                               NULL);                  /* Oldvalue */\n\n        if (status < 0)\n        {\n            OS_DEBUG(\"Error in timer_settime: %s\\n\", strerror(errno));\n            return_code = OS_TIMER_ERR_INTERNAL;\n        }\n        else if (interval_time > 0)\n        {\n            timebase->accuracy_usec = (uint32)((timeout.it_interval.tv_nsec + 999) / 1000);\n        }\n        else\n        {\n            timebase->accuracy_usec = (uint32)((timeout.it_value.tv_nsec + 999) / 1000);\n        }\n    }\n\n    local->reset_flag = (return_code == OS_SUCCESS);\n    return return_code;\n}\n...\nstatic int32 OS_DoTimerAdd(osal_id_t *timer_id, const char *timer_name, osal_id_t timebase_ref_id,\n                           OS_ArgCallback_t callback_ptr, void *callback_arg, uint32 flags)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              listcb_token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /*\n     * Check parameters\n     *\n     * Note \"callback_arg\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timer_name);\n    OS_CHECK_POINTER(callback_ptr);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Check that the timebase reference is valid\n     * If successful, then after this statement, we MUST decrement the refcount\n     * if we leave this routine with an error.\n     */\n    return_code =\n        OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_TIMEBASE, timebase_ref_id, &timebase_token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_TIMECB, timer_name, &timecb_token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timebase_token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(timecb_token, timecb, timer_name, timer_name);\n\n        /*\n         * transfer ownership so the refcount obtained earlier is now\n         * associated with the timecb object, and will be retained until\n         * the object is deleted.\n         */\n        OS_ObjectIdTransferToken(&timebase_token, &timecb->timebase_token);\n\n        timecb->callback_ptr = callback_ptr;\n        timecb->callback_arg = callback_arg;\n        timecb->flags        = flags;\n        timecb->prev_cb      = OS_ObjectIdFromToken(&timecb_token);\n        timecb->next_cb      = OS_ObjectIdFromToken(&timecb_token);\n\n        /*\n         * Now we need to add it to the time base callback ring, so take the\n         * timebase-specific lock to prevent a tick from being processed at this moment.\n         */\n        OS_TimeBaseLock_Impl(&timebase_token);\n\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timebase->first_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n\n            timecb->next_cb = OS_ObjectIdFromToken(&listcb_token);\n            timecb->prev_cb = list_timecb->prev_cb;\n\n            if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n                OS_SUCCESS)\n            {\n                list_timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n                list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n                list_timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n            }\n        }\n\n        timebase->first_cb = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_TimeBaseUnlock_Impl(&timebase_token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &timecb_token, timer_id);\n    }\n    else\n    {\n        OS_ObjectIdRelease(&timebase_token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_TimerSet(osal_id_t timer_id, uint32 start_time, uint32 interval_time)\n{\n    OS_timecb_internal_record_t *timecb;\n    int32                        return_code;\n    osal_objtype_t               objtype;\n    osal_id_t                    dedicated_timebase_id;\n    OS_object_token_t            token;\n\n    dedicated_timebase_id = OS_OBJECT_ID_UNDEFINED;\n\n    ARGCHECK(start_time < (UINT32_MAX / 2), OS_TIMER_ERR_INVALID_ARGS);\n    ARGCHECK(interval_time < (UINT32_MAX / 2), OS_TIMER_ERR_INVALID_ARGS);\n    ARGCHECK(start_time != 0 || interval_time != 0, OS_TIMER_ERR_INVALID_ARGS);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TIMECB, timer_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb = OS_OBJECT_TABLE_GET(OS_timecb_table, token);\n\n        OS_TimeBaseLock_Impl(&timecb->timebase_token);\n\n        if ((timecb->flags & TIMECB_FLAG_DEDICATED_TIMEBASE) != 0)\n        {\n            dedicated_timebase_id = OS_ObjectIdFromToken(&timecb->timebase_token);\n        }\n\n        timecb->wait_time     = (int32)start_time;\n        timecb->interval_time = (int32)interval_time;\n\n        OS_TimeBaseUnlock_Impl(&timecb->timebase_token);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    /*\n     * If the timer uses a dedicated time base, then also change that to the same interval.\n     *\n     * This is not perfect in the sense that the update is not all done atomically.  If this\n     * is not the first call to TimerSet, then weirdness can happen:\n     *  - a timer tick could occur between setting the callback times above and now\n     *  - the call to OS_TimeBaseSet() could fail leaving us in a mixed state\n     *\n     * However, the notion of multiple TimerSet() calls is a gray area to begin with, since\n     * timer ticks can occur at any moment - there is never a guarantee your new TimerSet values\n     * will get applied before the old timer expires.  Therefore by definition an application\n     * MUST be able to handle a possible \"spurious\" callback in these circumstances.\n     */\n    if (return_code == OS_SUCCESS && OS_ObjectIdDefined(dedicated_timebase_id))\n    {\n        return_code = OS_TimeBaseSet(dedicated_timebase_id, start_time, interval_time);\n    }\n    return return_code;\n}\n...\nint32 OS_TimerDelete(osal_id_t timer_id)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    osal_id_t                      dedicated_timebase_id;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              listcb_token;\n    OS_timebase_internal_record_t *timebase;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n\n    dedicated_timebase_id = OS_OBJECT_ID_UNDEFINED;\n    memset(&timebase_token, 0, sizeof(timebase_token));\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, OS_OBJECT_TYPE_OS_TIMECB, timer_id, &timecb_token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timecb->timebase_token);\n\n        OS_ObjectIdTransferToken(&timecb->timebase_token, &timebase_token);\n\n        OS_TimeBaseLock_Impl(&timecb->timebase_token);\n\n        /*\n         * If the timer uses a dedicated time base, then also delete that.\n         */\n        if ((timecb->flags & TIMECB_FLAG_DEDICATED_TIMEBASE) != 0)\n        {\n            dedicated_timebase_id = OS_ObjectIdFromToken(&timecb->timebase_token);\n        }\n\n        /*\n         * Now we need to remove it from the time base callback ring\n         */\n        if (OS_ObjectIdEqual(timebase->first_cb, OS_ObjectIdFromToken(&timecb_token)))\n        {\n            if (OS_ObjectIdEqual(OS_ObjectIdFromToken(&timecb_token), timecb->next_cb))\n            {\n                timebase->first_cb = OS_OBJECT_ID_UNDEFINED;\n            }\n            else\n            {\n                timebase->first_cb = timecb->next_cb;\n            }\n        }\n\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n            list_timecb->next_cb = timecb->next_cb;\n        }\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->next_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n            list_timecb->prev_cb = timecb->prev_cb;\n        }\n\n        timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n        timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_TimeBaseUnlock_Impl(&timecb->timebase_token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &timecb_token);\n    }\n\n    /*\n     * Remove the reference count against the timebase\n     */\n    OS_ObjectIdRelease(&timebase_token);\n\n    /*\n     * If the timer uses a dedicated time base, then also delete it.\n     */\n    if (return_code == OS_SUCCESS && OS_ObjectIdDefined(dedicated_timebase_id))\n    {\n        OS_TimeBaseDelete(dedicated_timebase_id);\n    }\n\n    return return_code;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No controlling expressions that are invariant were found in the provided code. I reviewed all loops and conditional constructs in OS_TimeBaseDelete_Impl and the additional routines: \n\n- The only literal-constant do-while pattern encountered is the do { ... } while (0) in OS_TimeBaseCreate_Impl; this is an allowed exception in MISRA C 2023 Rule 14.3 (a do-while with an essentially Boolean constant false controlling expression is permitted). \n\n- All for and while loops (e.g., for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx), for (i = SIGRTMIN; i <= SIGRTMAX; ++i), and the inner do { ... } while (i > 0)) have controlling expressions that depend on loop variables or runtime values (idx, i, return_code, etc.), so they are not invariant.\n\n- No occurrences of while(1), for(;;), if (1), or other invariant controlling expressions intended to be constant (other than the permitted do { ... } while (0)) were found.\n\n- Common macro idioms (ARGCHECK, OS_CHECK_POINTER, etc.) often expand to a do { ... } while (0) form; such instances are permissible under the exception noted above. If desired, expansion of those macros can be inspected, but based on usage here they do not present an invariant controlling expression issue.\n\nTherefore there are no fragments that need further investigation for violation of MISRA C 2023 Rule 14.3 in the supplied code."
}