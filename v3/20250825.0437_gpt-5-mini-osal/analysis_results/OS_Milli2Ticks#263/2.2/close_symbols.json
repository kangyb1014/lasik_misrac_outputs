{
  "user_message": "Target function code is:\n```c\nint32 OS_Milli2Ticks(uint32 milli_seconds, int *ticks)\n{\n    uint64 num_of_ticks;\n    int32  return_code = OS_SUCCESS;\n\n    num_of_ticks = (((uint64)milli_seconds * OS_SharedGlobalVars.TicksPerSecond) + 999) / 1000;\n\n    /* Check against maximum int32 (limit from some OS's) */\n    if (num_of_ticks <= INT_MAX)\n    {\n        *ticks = (int)num_of_ticks;\n    }\n    else\n    {\n        return_code = OS_ERROR;\n        *ticks      = 0;\n    }\n\n    return return_code;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SharedGlobalVars (type/definition and the global variable instance)",
    "OS_SharedGlobalVars.TicksPerSecond (type, declared range, and all initialization/assignment sites)",
    "Any configuration macro or build-time constant that sets TicksPerSecond (e.g. OS_TICKS_PER_SECOND)",
    "API/contract documentation for OS_Milli2Ticks (allowed/expected range of milli_seconds)",
    "All call sites of OS_Milli2Ticks in the project (to know actual argument values and use of the out-parameter 'ticks')",
    "Definition of INT_MAX (platform limits.h) and target platform 'int' width",
    "typedefs for uint32, uint64, int32 (stdint.h or project typedefs) and their ranges/semantics",
    "Definitions of OS_SUCCESS and OS_ERROR (enum/macros) and any code that relies on those return values",
    "Any static analysis/annotations or assertions that establish invariants on milli_seconds or TicksPerSecond (e.g. assert, MISR A annotations, formal contracts)",
    "Any code that reads the 'ticks' out-parameter after calling OS_Milli2Ticks (to determine whether writing *ticks is ever observed)"
  ],
  "explanation": "To determine whether any operation in OS_Milli2Ticks is dead (i.e. executed but removable without changing program behaviour) you must be able to prove whether each assignment/branch can ever affect behaviour. The listed symbols are required because:\n\n- OS_SharedGlobalVars (type and instance): the TicksPerSecond member is used in the arithmetic. You need the struct/variable definition to find the member type and where/how it can change at runtime.\n\n- OS_SharedGlobalVars.TicksPerSecond (type, declared range, initialization/assignments): whether the 'else' branch (num_of_ticks > INT_MAX) can ever be taken depends on the possible values of TicksPerSecond. You must inspect all places that set this value (initializers, config, runtime assignments) to know its bounds.\n\n- Configuration macros/build-time constants that set TicksPerSecond: often TicksPerSecond is derived from a macro. If that macro constrains the value such that num_of_ticks is always <= INT_MAX (or always > INT_MAX), a branch could be provably never executed (making it unreachable or rendering some assignments effectively dead).\n\n- API/contract documentation for OS_Milli2Ticks (allowed milli_seconds): the input domain of milli_seconds (either via documentation or validated by callers) is needed to determine the possible range of the product and therefore which branches are feasible.\n\n- All call sites of OS_Milli2Ticks: callers determine the actual milli_seconds values passed and how the out-parameter 'ticks' and return value are used. If every caller ignores the return value or never uses *ticks, those writes might be dead. Also callers may precondition milli_seconds such that branches are never hit.\n\n- INT_MAX and platform 'int' width: the comparison against INT_MAX decides the branch. You must know INT_MAX value on the target platform (and whether 'int' is 32-bit) to evaluate whether num_of_ticks can exceed it.\n\n- typedefs for uint32/uint64/int32 and their ranges: to reason about overflow, casting and value ranges you need the exact integer-width typedefs used in the expression and the cast to uint64.\n\n- OS_SUCCESS and OS_ERROR definitions: to reason whether assigning return_code in either branch affects observable behaviour you need to know the values and how callers or further code interpret them (e.g. if the return value is never used the assignments might be dead).\n\n- Static annotations/assertions/formal invariants: any existing guarantees (asserts, static-analysis annotations, MISRA annotations) can make branches impossible or show certain assignments never affect behaviour.\n\n- Code that reads the 'ticks' out-parameter after calls: to judge whether the writes to *ticks are meaningful (observable) you must examine the readers. If no code ever reads the out-parameter, those stores may be dead operations.\n\nTogether these symbols let an analyst determine whether either branch or particular assignments are never executed or executed but have no observable effect \u2014 the information required to decide if the code contains dead operations under the MISRA rule."
}