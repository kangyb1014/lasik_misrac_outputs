{
  "user_message": "An agent A claimed that the following UtList_NewNode code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UtList_NewNode.\n```c\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'Data' is declared as void * but is only read (used as the source argument to memcpy). It should be declared as 'const void *Data' so the pointer points to a const-qualified type. Change signature to: UtListNode_t *UtList_NewNode(const void *Data, uint32 DataSize).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6940\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6960, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 79 48 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 56 78 57 6F 72\nAfter memcpy, dest 0x556b914a6960 first 32 bytes (hex): 79 48 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 56 78 57 6F 72\nNode.Next=0x556b914a6940, Node.Prev=0x556b914a6940\nReturning node 0x556b914a6940\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a69b0\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a69d0, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 41 49 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nAfter memcpy, dest 0x556b914a69d0 first 32 bytes (hex): 41 49 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nNode.Next=0x556b914a69b0, Node.Prev=0x556b914a69b0\nReturning node 0x556b914a69b0\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6a20\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6a40, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 31 4B 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nAfter memcpy, dest 0x556b914a6a40 first 32 bytes (hex): 31 4B 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nNode.Next=0x556b914a6a20, Node.Prev=0x556b914a6a20\nReturning node 0x556b914a6a20\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6a90\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6ab0, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 41 4C 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nAfter memcpy, dest 0x556b914a6ab0 first 32 bytes (hex): 41 4C 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nNode.Next=0x556b914a6a90, Node.Prev=0x556b914a6a90\nReturning node 0x556b914a6a90\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6b00\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6b20, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 1D 4E 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nAfter memcpy, dest 0x556b914a6b20 first 32 bytes (hex): 1D 4E 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nNode.Next=0x556b914a6b00, Node.Prev=0x556b914a6b00\nReturning node 0x556b914a6b00\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6b70\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6b90, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): F9 4F 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nAfter memcpy, dest 0x556b914a6b90 first 32 bytes (hex): F9 4F 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5F 42 69 6E 53 65\nNode.Next=0x556b914a6b70, Node.Prev=0x556b914a6b70\nReturning node 0x556b914a6b70\n=== UtList_NewNode exit ===\n\n=== UtList_NewNode entry ===\nParameters: Data=0x7ffe5c4467a0, DataSize=64\nmalloc(96) -> 0x556b914a6be0\nmemset on union header (32 bytes) done\nNode.Data set to 0x556b914a6c00, Node.DataSize=64\nAbout to memcpy 64 bytes from source 0x7ffe5c4467a0. First 32 bytes (hex): 09 51 21 83 6B 55 00 00 ED 54 21 83 6B 55 00 00 73 55 21 83 6B 55 00 00 4F 53 5\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The parameter Data is only read (used as the source argument to memcpy) and is never modified in UtList_NewNode, so it should be declared as pointing to a const-qualified type (const void *Data) per MISRA C 2023 Rule 8.13. Changing the signature to UtListNode_t *UtList_NewNode(const void *Data, uint32 DataSize) is safe (implicit conversion from void * to const void * is allowed for callers) and expresses the intended non-modifiable intent. Other pointers in the function (AllocNode, Node.Data, etc.) are written to and therefore should remain non-const as shown."
}