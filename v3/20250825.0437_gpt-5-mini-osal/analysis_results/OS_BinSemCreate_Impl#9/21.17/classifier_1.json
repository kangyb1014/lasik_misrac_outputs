{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_BinSemCreate_Impl:\n```c\nint32 OS_BinSemCreate_Impl(const OS_object_token_t *token, uint32 initial_value, uint32 options)\n{\n    int                               ret;\n    int                               attr_created;\n    int                               mutex_created;\n    int                               cond_created;\n    int32                             return_code;\n    pthread_mutexattr_t               mutex_attr;\n    OS_impl_binsem_internal_record_t *sem;\n\n    /*\n     * This preserves a bit of pre-existing functionality that was particular to binary sems:\n     * if the initial value is greater than 1 it just silently used 1 without error.\n     * (by contrast the counting semaphore will return an error)\n     */\n    if (initial_value > 1)\n    {\n        initial_value = 1;\n    }\n\n    attr_created  = 0;\n    mutex_created = 0;\n    cond_created  = 0;\n    sem           = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n    memset(sem, 0, sizeof(*sem));\n\n    do\n    {\n        /*\n         ** Initialize the pthread mutex attribute structure with default values\n         */\n        ret = pthread_mutexattr_init(&mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /* After this point, the attr object should be destroyed before return */\n        attr_created = 1;\n\n        /*\n         ** Use priority inheritance\n         */\n        ret = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /*\n         ** Initialize the mutex that is used with the condition variable\n         */\n        ret = pthread_mutex_init(&(sem->id), &mutex_attr);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutex_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        mutex_created = 1;\n\n        /*\n         ** Initialize the condition variable\n         */\n        ret = pthread_cond_init(&(sem->cv), NULL);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: pthread_cond_init failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        cond_created = 1;\n\n        /*\n         * Check sem call, avoids unreachable destroy logic\n         */\n        ret = pthread_cond_signal(&(sem->cv));\n        if (ret != 0)\n        {\n            OS_DEBUG(\"Error: initial pthread_cond_signal failed: %s\\n\", strerror(ret));\n            return_code = OS_SEM_FAILURE;\n            break;\n        }\n\n        /*\n         ** fill out the proper OSAL table fields\n         */\n\n        sem->current_value = initial_value;\n\n        return_code = OS_SUCCESS;\n    } while (0);\n\n    /* Clean up resources if the operation failed */\n    if (return_code != OS_SUCCESS)\n    {\n        if (mutex_created)\n        {\n            pthread_mutex_destroy(&(sem->id));\n        }\n        if (cond_created)\n        {\n            pthread_cond_destroy(&(sem->cv));\n        }\n    }\n\n    if (attr_created)\n    {\n        /* Done with the attribute object -\n         * this call is a no-op in linux - but for other implementations if\n         * the create call allocated something this should free it\n         */\n        pthread_mutexattr_destroy(&mutex_attr);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BinSemCreate_Impl:\ntypedef struct\n{\n    pthread_mutex_t       id;\n    pthread_cond_t        cv;\n    volatile sig_atomic_t flush_request;\n    volatile sig_atomic_t current_value;\n} OS_impl_binsem_internal_record_t\n...\nOS_impl_binsem_internal_record_t OS_impl_bin_sem_table[OS_MAX_BIN_SEMAPHORES]\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset(sem, 0, sizeof(*sem));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The code calls memset(sem, 0, sizeof(*sem)) where sem is obtained via OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token) without validating the token index. If token->obj_idx is out of range (>= OS_MAX_BIN_SEMAPHORES) or otherwise corrupted, OS_OBJECT_TABLE_GET yields an out-of-bounds pointer and the memset will write beyond the bounds of the array element (undefined behavior). Therefore the use of memset can result in accesses beyond the bounds of the object referenced by sem."
}