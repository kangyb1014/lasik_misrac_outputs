{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SymbolTableDump:\n```c\nint32 OS_SymbolTableDump(const char *filename, size_t SizeLimit)\n{\n    int32             return_code;\n    char              translated_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filename);\n\n    /*\n     ** Translate the filename to the Host System\n     */\n    return_code = OS_TranslatePath(filename, translated_path);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Locking the global ensures only one symbol table dump\n     * can be executing.  It also prevents module loading/unloading\n     * while the dump is occurring.\n     *\n     * Because calls to this function are serialized, the\n     * underlying implementation may safely use globals for\n     * state storage.\n     */\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, &token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_SymbolTableDump_Impl(translated_path, SizeLimit);\n\n    OS_ObjectIdTransactionCancel(&token);\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SymbolTableDump:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\n#define OS_SUCCESS (0)\n...\n#define OS_MAX_LOCAL_PATH_LEN (OS_MAX_PATH_LEN+OS_FS_PHYS_NAME_LEN)\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n...\nuint32 OS_GetMaxForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_MAX_TASKS;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_MAX_QUEUES;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_MAX_BIN_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_MAX_COUNT_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MAX_MUTEXES;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_MAX_NUM_OPEN_FILES;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_MAX_NUM_OPEN_DIRS;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_MAX_TIMEBASES;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_MAX_TIMERS;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MAX_MODULES;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_MAX_FILE_SYSTEMS;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_MAX_CONSOLES;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_MAX_CONDVARS;\n        default:\n            return 0;\n    }\n}\n...\nvoid OS_Lock_Global(OS_object_token_t *token)\n{\n    osal_id_t           self_task_id;\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype      = &OS_objtype_state[token->obj_type];\n        self_task_id = OS_TaskGetId_Impl();\n\n        OS_Lock_Global_Impl(token->obj_type);\n\n        /*\n         * Track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done after successfully locking, so this has exclusive access\n         * to the state object.\n         */\n        if (!OS_ObjectIdIsValid(self_task_id))\n        {\n            /*\n             * This just means the calling context is not an OSAL-created task.\n             * This is not necessarily an error, but it should be tracked.\n             * Also note that the root/initial task also does not have an ID.\n             */\n            self_task_id = OS_OBJECT_ID_RESERVED; /* nonzero, but also won't alias a known task */\n        }\n\n        /*\n         * The key value is computed with fixed/nonzero flag bits combined\n         * with the lower 24 bits of the task ID xor'ed with transaction id.\n         * This makes it different for every operation, and different depending\n         * on what task is calling the function.\n         */\n        token->lock_key.key_value =\n            OS_LOCK_KEY_FIXED_VALUE | ((OS_ObjectIdToInteger(self_task_id) ^ objtype->transaction_count) & 0xFFFFFF);\n\n        ++objtype->transaction_count;\n\n        if (objtype->owner_key.key_value != 0)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u acquired by task 0x%lx when already assigned key 0x%lx\\n\",\n                     (unsigned int)token->obj_type, OS_ObjectIdToInteger(self_task_id),\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n        else\n        {\n            objtype->owner_key = token->lock_key;\n        }\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot lock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\nint32 OS_SymbolTableDump_Impl(const char *filename, size_t SizeLimit)\n{\n    /*\n     * Limiting strictly to POSIX-defined API means there is no defined\n     * method to get iterate over the symbol table.\n     *\n     * Some C libraries do offer an extension to provide this function, so\n     * if this becomes a requirement on those platforms, this function\n     * might need to move.\n     *\n     * Currently this is not a widely used/needed feature so it will report\n     * unimplemented here.\n     */\n\n    return OS_ERR_NOT_IMPLEMENTED;\n}\n...\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Unlock_Global(token);\n        token->lock_mode = OS_LOCK_MODE_NONE;\n    }\n}\n...\nvoid OS_Unlock_Global(OS_object_token_t *token)\n{\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype = &OS_objtype_state[token->obj_type];\n\n        /*\n         * Un-track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done before unlocking, while this has exclusive access\n         * to the state object.\n         */\n        if ((objtype->owner_key.key_value & 0xFF000000) != OS_LOCK_KEY_FIXED_VALUE ||\n            objtype->owner_key.key_value != token->lock_key.key_value)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\\n\",\n                     (unsigned int)token->obj_type, (unsigned long)token->lock_key.key_value,\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n\n        objtype->owner_key = OS_LOCK_KEY_INVALID;\n        token->lock_key    = OS_LOCK_KEY_INVALID;\n\n        OS_Unlock_Global_Impl(token->obj_type);\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot unlock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nreturn_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, &token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation \u2014 the call to OS_ObjectIdTransactionInit and the subsequent check are live code. The function initializes the token (memset and other state) and may acquire a global lock; the return value is used to decide whether to return early. Removing the call or the check would change program behavior (token state and locking), so this is not dead code."
}