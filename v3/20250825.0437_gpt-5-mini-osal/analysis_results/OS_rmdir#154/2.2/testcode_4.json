{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe assignments 'SysMountPointLen = 0;' and 'VirtPathBegin = VirtPathLen;' are executed but never affect program behaviour. In all execution paths where these variables are later used (the 'if (return_code == OS_SUCCESS)' block) they are overwritten by values computed from the mounted filesystem record. In other paths the values are never used because return_code != OS_SUCCESS prevents their use. Therefore these two assignments are dead code: removing them would not change program behaviour.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rmdir code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1542.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rmdir as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rmdir:\n```c\nint32 OS_rmdir(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirRemove_Impl(local_path);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rmdir code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Minimal typedefs and constants so this test file is self-contained and\n   compilable. These are not macros (per constraints). */\ntypedef int32_t int32;\nenum {\n    OS_SUCCESS = 0,\n    OS_ERROR   = -1,\n    OS_MAX_LOCAL_PATH_LEN = 256\n};\n\n/* Probe/logging helper - appends records to /tmp/logs/1542.txt. */\nstatic void OS_rmdir_log(const char *event, const char *path, const char *local_path, int32 rc)\n{\n    FILE *f = fopen(\"/tmp/logs/1542.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be performed we do not change behavior of OS_rmdir. */\n        return;\n    }\n\n    fprintf(f, \"EVENT: %s\\n\", event);\n    if (path != NULL) fprintf(f, \"  path: '%s'\\n\", path);\n    if (local_path != NULL) fprintf(f, \"  local_path: '%s'\\n\", local_path);\n    fprintf(f, \"  return_code: %d\\n\", (int)rc);\n    fprintf(f, \"----\\n\");\n    fclose(f);\n}\n\n/*\n * NOTE: The real OS_TranslatePath and OS_DirRemove_Impl are expected to be\n * provided elsewhere in the system. For this test file to be compilable and\n * to allow reproduction of control flow, lightweight stubs are provided.\n * These stubs are intentionally simple and do not change the OS_rmdir\n * logic; they emulate success/failure so the logging captures the decision\n * points inside OS_rmdir.\n */\nstatic int32 OS_TranslatePath(const char *path, char *local_path)\n{\n    /* Emulate typical behavior: if path is non-empty copy it and return success. */\n    if (path == NULL || path[0] == '\\0')\n    {\n        return OS_ERROR;\n    }\n\n    /* Emulate that OS_TranslatePath fills local_path from the mount/virt logic. */\n    strncpy(local_path, path, OS_MAX_LOCAL_PATH_LEN - 1);\n    local_path[OS_MAX_LOCAL_PATH_LEN - 1] = '\\0';\n\n    /* For additional diagnosability, write an entry about what Translate did. */\n    OS_rmdir_log(\"OS_TranslatePath completed\", path, local_path, OS_SUCCESS);\n\n    return OS_SUCCESS;\n}\n\nstatic int32 OS_DirRemove_Impl(const char *local_path)\n{\n    /* Emulate a successful directory removal for logging purposes. */\n    OS_rmdir_log(\"OS_DirRemove_Impl called\", NULL, local_path, OS_SUCCESS);\n    return OS_SUCCESS;\n}\n\n/* The original function with logging probes inserted. Logic is preserved. */\nint32 OS_rmdir(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log entry and input state */\n    OS_rmdir_log(\"entry\", path, \"\", 0);\n\n    return_code = OS_TranslatePath(path, local_path);\n\n    /* Log after translation attempt so callers can see whether local_path\n       was produced and what the return code was. This helps demonstrate the\n       scenario where earlier-written intermediate values would be overwritten\n       by the mount-based translation or not used when translation fails. */\n    OS_rmdir_log(\"after OS_TranslatePath\", path, local_path, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log that we are about to attempt removal using the translated path. */\n        OS_rmdir_log(\"before OS_DirRemove_Impl (will attempt remove)\", path, local_path, return_code);\n\n        return_code = OS_DirRemove_Impl(local_path);\n\n        /* Log result of the removal implementation. */\n        OS_rmdir_log(\"after OS_DirRemove_Impl\", path, local_path, return_code);\n    }\n    else\n    {\n        /* Log that OS_DirRemove_Impl was not invoked due to translation failure. */\n        OS_rmdir_log(\"skipped OS_DirRemove_Impl (translate failed)\", path, NULL, return_code);\n    }\n\n    /* Final return value is logged as well. */\n    OS_rmdir_log(\"exit\", path, local_path, return_code);\n\n    return return_code;\n}\n"
}