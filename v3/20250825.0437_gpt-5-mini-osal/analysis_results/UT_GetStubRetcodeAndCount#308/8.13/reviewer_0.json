{
  "user_message": "An agent A claimed that the following UT_GetStubRetcodeAndCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubRetcodeAndCount.\n```c\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n        Result   = true;\n    }\n    else\n    {\n        Result = false;\n    }\n\n    return Result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer StubPtr is declared as UT_StubTableEntry_t * but in this function it is only used for read access (reading Data.Rc.Count and Data.Rc.Value). According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible (e.g. const UT_StubTableEntry_t *StubPtr). Therefore the assignment StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER); and the non-const declaration constitute a violation. (Fix: declare StubPtr as const UT_StubTableEntry_t * and/or have UT_GetStubEntry return a pointer to const if appropriate.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In UT_GetStubRetcodeAndCount the local pointer StubPtr is only used to read members (Data.Rc.Count and Data.Rc.Value) and there is no modification of the pointed object through StubPtr. MISRA C 2023 Rule 8.13 advises that a pointer should point to a const-qualified type whenever possible; therefore StubPtr should be declared as const UT_StubTableEntry_t *StubPtr. Assigning the non-const return of UT_GetStubEntry to a const pointer is allowed (conversion from T * to const T *), so making StubPtr const is feasible and appropriate. The only reasons not to make it const would be a specific need later in the function to modify the object (not present here) or an overriding design justification. Absent such justification, the code violates Rule 8.13. Recommended fix: declare StubPtr as const UT_StubTableEntry_t * (or otherwise provide a justified deviation)."
}