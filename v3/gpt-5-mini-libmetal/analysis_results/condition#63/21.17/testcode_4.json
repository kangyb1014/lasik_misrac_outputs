{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation: pthread_create() returns a positive errno (e.g. EAGAIN == 11). The code sets error = -pthread_create(...), so on failure error becomes negative (e.g. -11). The fragment then calls strerror(error) with a negative errnum. strerror(expectation is a valid non\u2011negative errno) may index into its internal message table or otherwise access memory based on errnum; passing a negative value can cause out\u2011of\u2011bounds access of the internal data and thus violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified condition code that contains useful probe functions that print useful logs to a file \"/tmp/logs/639.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of condition as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of condition:\n```c\nstatic int condition(void)\n{\n\tint ret;\n\tint ts_created;\n\tpthread_t tids[THREADS];\n\n\t/** TC1 consumer threads go first */\n\t/** create 10 consumer threads first */\n\tret = metal_run_noblock(THREADS, consumer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 producer threads next */\n\tret = metal_run(THREADS, producer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** wait for consumer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\n\t/** TC2 producer threads go first */\n\t/** create 10 producer threads first */\n\tret = metal_run_noblock(THREADS, producer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 consumer threads next */\n\tret = metal_run(THREADS, consumer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/** wait for producer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\treturn ret;\n}\n```\n</target_code>\nPlease provide the modified condition code.\n",
  "test_code": "static int condition(void)\n{\n\tint ret;\n\tint ts_created;\n\tpthread_t tids[THREADS];\n\n\t/* Probe helper: append structured logs to /tmp/logs/639.txt */\n\tauto void probe_log(const char *stage, int ret_val, int ts_created_val, pthread_t *tids_val)\n\t{\n\t\tFILE *f = fopen(\"/tmp/logs/639.txt\", \"a\");\n\t\tif (!f)\n\t\t\treturn;\n\t\tint saved_errno = errno;\n\t\tfprintf(f, \"[condition] stage=%s ret=%d errno=%d ts_created=%d\\n\",\n\t\t\tstage, ret_val, saved_errno, ts_created_val);\n\t\t/* Log first few thread ids (as unsigned long) to capture control flow */\n\t\tfor (int i = 0; i < THREADS && i < 4; ++i) {\n\t\t\tfprintf(f, \"[condition] %s tids[%d]=%lu\\n\", stage, i,\n\t\t\t\t(unsigned long)tids_val[i]);\n\t\t}\n\t\t/* If ret indicates a negative error encoding (-errno), log both forms\n\t\t   but never call strerror() with a negative value. */\n\t\tif (ret_val < 0) {\n\t\t\tint simulated_errno = -ret_val; /* positive errno value expected */\n\t\t\tfprintf(f, \"[condition] %s detected negative ret: %d -> simulated errno: %d\\n\",\n\t\t\t\tstage, ret_val, simulated_errno);\n\t\t\t/* Safe: only call strerror with non-negative errnum */\n\t\t\tif (simulated_errno >= 0) {\n\t\t\t\tchar const *msg = strerror(simulated_errno);\n\t\t\t\tif (msg)\n\t\t\t\t\tfprintf(f, \"[condition] %s strerror(simulated_errno)=%s\\n\",\n\t\t\t\t\t\tstage, msg);\n\t\t\t}\n\t\t\t/* Warn about the unsafe call pattern that may lead to out-of-bounds\n\t\t\t   accesses if caller passes the negative value directly to strerror */\n\t\t\tfprintf(f, \"[condition] %s WARNING: calling strerror(ret) would pass a negative errnum (%d) and may be unsafe.\\n\",\n\t\t\t\tstage, ret_val);\n\t\t}\n\t\tfclose(f);\n\t}\n\n\t/** TC1 consumer threads go first */\n\t/** create 10 consumer threads first */\n\tret = metal_run_noblock(THREADS, consumer_thread, NULL, tids,\n\t\t\t\t\t&ts_created);\n\t/* Probe after attempting to create consumer threads */\n\tprobe_log(\"after_metal_run_noblock_consumers\", ret, ts_created, tids);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 producer threads next */\n\tret = metal_run(THREADS, producer_thread, NULL);\n\t/* Probe after attempting to create producer threads */\n\tprobe_log(\"after_metal_run_producers\", ret, ts_created, tids);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** wait for consumer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\n\t/** TC2 producer threads go first */\n\t/** create 10 producer threads first */\n\tret = metal_run_noblock(THREADS, producer_thread, NULL, tids,\n\t\t\t\t\t&ts_created);\n\t/* Probe after attempting to create producer threads (noblock) */\n\tprobe_log(\"after_metal_run_noblock_producers\", ret, ts_created, tids);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 consumer threads next */\n\tret = metal_run(THREADS, consumer_thread, NULL);\n\t/* Probe after attempting to create consumer threads (blocking) */\n\tprobe_log(\"after_metal_run_consumers\", ret, ts_created, tids);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/** wait for producer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\t/* Final probe before return */\n\tprobe_log(\"exit_condition\", ret, ts_created, tids);\n\treturn ret;\n}\n"
}