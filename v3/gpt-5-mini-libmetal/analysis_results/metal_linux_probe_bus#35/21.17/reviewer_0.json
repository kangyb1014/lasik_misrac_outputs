{
  "user_message": "An agent A claimed that the following metal_linux_probe_bus code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_bus.\n```c\nstatic int metal_linux_probe_bus(struct linux_bus *lbus)\n{\n\tstruct linux_driver *ldrv;\n\tint ret, error = -ENODEV;\n\n\tlbus->sbus = sysfs_open_bus(lbus->bus_name);\n\tif (!lbus->sbus)\n\t\treturn -ENODEV;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tret = metal_linux_probe_driver(lbus, ldrv);\n\t\t/* Clear the error if any driver is available */\n\t\tif (!ret)\n\t\t\terror = ret;\n\t}\n\n\tif (error) {\n\t\tmetal_linux_bus_close(&lbus->bus);\n\t\treturn error;\n\t}\n\n\terror = metal_linux_register_bus(lbus);\n\tif (error)\n\t\tmetal_linux_bus_close(&lbus->bus);\n\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nmetal_bus_register calls strlen(bus->name) after only checking bus and bus->name for NULL. There is no guarantee in this function that the object pointed to by bus->name is a null-terminated string of appropriate bounds. If bus->name points to a non-terminated char array (for example from a prior non-terminating strncpy or corrupted/uninitialized memory), strlen will read past the object bounds, causing an out-of-bounds access and violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: metal_linux_probe_bus: lbus=0x7fbc7ec1eb60, bus_name_ptr=0x7fbc7ec18730, bus_struct_ptr=0x7fbc7ec1eb60\nsysfs_open_bus succeeded: sbus=0x562d894b78c0\nprobing driver: ldrv=0x7fbc7ec1ebc0\nmetal_linux_probe_driver returned 0 for driver 0x7fbc7ec1ebc0\nprobing driver: ldrv=0x7fbc7ec1ec08\nmetal_linux_probe_driver returned 0 for driver 0x7fbc7ec1ec08\nabout to register bus: bus_struct=0x7fbc7ec1eb60, bus_name_ptr=(nil)\nmetal_linux_register_bus returned 0 for bus 0x7fbc7ec1eb60\nregistration succeeded for bus 0x7fbc7ec1eb60\nexit: metal_linux_probe_bus returning 0 for lbus=0x7fbc7ec1eb60\nenter: metal_linux_probe_bus: lbus=0x7fbc7ec1fdc8, bus_name_ptr=0x7fbc7ec1875d, bus_struct_ptr=0x7fbc7ec1fdc8\nsysfs_open_bus succeeded: sbus=0x562d894b7d60\nprobing driver: ldrv=0x7fbc7ec1fe28\nmetal_linux_probe_driver returned 0 for driver 0x7fbc7ec1fe28\nprobing driver: ldrv=0x7fbc7ec1fe70\nmetal_linux_probe_driver returned 0 for driver 0x7fbc7ec1fe70\nabout to register bus: bus_struct=0x7fbc7ec1fdc8, bus_name_ptr=(nil)\nmetal_linux_register_bus returned 0 for bus 0x7fbc7ec1fdc8\nregistration succeeded for bus 0x7fbc7ec1fdc8\nexit: metal_linux_probe_bus returning 0 for lbus=0x7fbc7ec1fdc8\nenter: metal_linux_probe_bus: lbus=0x55efcdb34260, bus_name_ptr=0x55efcdb2c220, bus_struct_ptr=0x55efcdb34260\nsysfs_open_bus succeeded: sbus=0x55efe062b8c0\nprobing driver: ldrv=0x55efcdb342c0\nmetal_linux_probe_driver returned 0 for driver 0x55efcdb342c0\nprobing driver: ldrv=0x55efcdb34308\nmetal_linux_probe_driver returned 0 for driver 0x55efcdb34308\nabout to register bus: bus_struct=0x55efcdb34260, bus_name_ptr=(nil)\nmetal_linux_register_bus returned 0 for bus 0x55efcdb34260\nregistration succeeded for bus 0x55efcdb34260\nexit: metal_linux_probe_bus returning 0 for lbus=0x55efcdb34260\nenter: metal_linux_probe_bus: lbus=0x55efcdb354c8, bus_name_ptr=0x55efcdb2c24d, bus_struct_ptr=0x55efcdb354c8\nsysfs_open_bus succeeded: sbus=0x55efe062bd60\nprobing driver: ldrv=0x55efcdb35528\nmetal_linux_probe_driver returned 0 for driver 0x55efcdb35528\nprobing driver: ldrv=0x55efcdb35570\nmetal_linux_probe_driver returned 0 for driver 0x55efcdb35570\nabout to register bus: bus_struct=0x55efcdb354c8, bus_name_ptr=(nil)\nmetal_linux_register_bus returned 0 for bus 0x55efcdb354c8\nregistration succeeded for bus 0x55efcdb354c8\nexit: metal_linux_probe_bus returning 0 for lbus=0x55efcdb354c8\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_probe_bus:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n...\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n...\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n...\nstatic struct linux_bus *to_linux_bus(struct metal_bus *bus)\n{\n\treturn metal_container_of(bus, struct linux_bus, bus);\n}\n...\nstatic int metal_linux_register_bus(struct linux_bus *lbus)\n{\n\tlbus->bus.name = lbus->bus_name;\n\tlbus->bus.ops  = metal_linux_bus_ops;\n\treturn metal_bus_register(&lbus->bus);\n}\n...\nint metal_bus_register(struct metal_bus *bus)\n{\n\tif (!bus || !bus->name || !strlen(bus->name))\n\t\treturn -EINVAL;\n\tif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n\tmetal_list_init(&bus->devices);\n\tmetal_list_add_tail(&_metal.common.bus_list, &bus->node);\n\tmetal_log(METAL_LOG_DEBUG, \"registered %s bus\\n\", bus->name);\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The claim is correct. The call chain is: metal_linux_probe_bus -> metal_linux_register_bus (which does lbus->bus.name = lbus->bus_name) -> metal_bus_register, which calls strlen(bus->name) after only checking bus and bus->name for NULL. There is no code shown that guarantees the object pointed to by lbus->bus_name is a NUL\u2011terminated character array of appropriate bounds. If bus_name were a non\u2011terminated buffer (e.g. result of a non\u2011terminating strncpy, corrupted or uninitialized memory), strlen could read past the object bounds and cause an out\u2011of\u2011bounds access. That behaviour is exactly what MISRA C 2023 Rule 21.17 forbids. Absent an explicit, provable contract elsewhere that bus_name is a valid NUL\u2011terminated string, this use of strlen constitutes a violation."
}