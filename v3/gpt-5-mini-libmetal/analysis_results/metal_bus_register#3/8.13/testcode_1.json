{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf the struct member bus->name is declared as 'char *' (non-const) then this usage violates MISRA C 2023 Rule 8.13 because the function only reads the string (calls strlen) and the pointer should be const-qualified (const char *).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_bus_register code that contains useful probe functions that print useful logs to a file \"/tmp/logs/33.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_bus_register as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_bus_register:\n```c\nint metal_bus_register(struct metal_bus *bus)\n{\n\tif (!bus || !bus->name || !strlen(bus->name))\n\t\treturn -EINVAL;\n\tif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n\tmetal_list_init(&bus->devices);\n\tmetal_list_add_tail(&_metal.common.bus_list, &bus->node);\n\tmetal_log(METAL_LOG_DEBUG, \"registered %s bus\\n\", bus->name);\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified metal_bus_register code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n\n/* Minimal types and stubs to make this translation self-contained for testing.\n   In the real project these are defined elsewhere; the stubs below are provided\n   so this file can be compiled/linked standalone for generating logs. */\n\nstruct metal_node {\n    void *prev;\n    void *next;\n};\n\nstruct metal_list {\n    struct metal_node *head;\n};\n\nstruct metal_bus {\n    /* NOTE: intentionally non-const to reflect the violation scenario reported */\n    char *name;\n    struct metal_list devices;\n    struct metal_node node;\n};\n\n/* Global bus list container used by metal_bus_register (minimal stub). */\nstatic struct {\n    struct {\n        struct metal_list bus_list;\n    } common;\n} _metal;\n\n/* Stubs for functions used by metal_bus_register.  These are minimal and\n   intended only to allow compilation and to keep the original control flow. */\nint metal_bus_find(const char *name, void *arg)\n{\n    /* For testing, pretend the bus is not present (return non-zero).\n       Real implementation will search and return 0 if found. */\n    (void)name;\n    (void)arg;\n    return 1;\n}\n\nvoid metal_list_init(struct metal_list *list)\n{\n    if (list != NULL) {\n        list->head = NULL;\n    }\n}\n\nvoid metal_list_add_tail(struct metal_list *list, struct metal_node *node)\n{\n    (void)list;\n    (void)node;\n    /* No-op stub for testing logging; real implementation links nodes. */\n}\n\nvoid metal_log(int level, const char *fmt, ...)\n{\n    (void)level;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n}\n\n/* Probe helper: append structured information to /tmp/logs/33.txt.  These\n   helpers are careful not to dereference NULL pointers and will record the\n   control path and relevant state so other agents can reproduce the reported\n   violation (non-const char * used only for reading). */\nstatic void probe_log(const char *event, const struct metal_bus *bus)\n{\n    FILE *f = fopen(\"/tmp/logs/33.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    fprintf(f, \"EVENT: %s\\n\", event);\n    fprintf(f, \"  bus_ptr=%p\\n\", (const void *)bus);\n    if (bus == NULL) {\n        fprintf(f, \"  bus is NULL\\n\\n\");\n        fclose(f);\n        return;\n    }\n    fprintf(f, \"  name_ptr=%p\\n\", (const void *)bus->name);\n    if (bus->name != NULL) {\n        /* Log the actual string content and its length to show it is only read. */\n        fprintf(f, \"  name_str=\\\"\");\n        /* write the string safely: replace newlines to keep single-line record */\n        const char *p = bus->name;\n        while (*p != '\\0') {\n            if (*p == '\\n') {\n                fputs(\"\\\\n\", f);\n            } else {\n                fputc((int)*p, f);\n            }\n            p++;\n        }\n        fprintf(f, \"\\\"\\n\");\n        fprintf(f, \"  name_len=%zu\\n\", strlen(bus->name));\n    } else {\n        fprintf(f, \"  name is NULL\\n\");\n    }\n    fprintf(f, \"  devices_addr=%p node_addr=%p\\n\\n\",\n            (const void *)&bus->devices, (const void *)&bus->node);\n    fclose(f);\n}\n\nstatic void probe_log_find(const char *event, const struct metal_bus *bus, int find_res)\n{\n    FILE *f = fopen(\"/tmp/logs/33.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    fprintf(f, \"EVENT: %s\\n\", event);\n    fprintf(f, \"  bus_ptr=%p find_result=%d\\n\\n\", (const void *)bus, find_res);\n    fclose(f);\n}\n\n/* Modified metal_bus_register with inserted probes.  The original logic is\n   preserved; probes only record state and control-flow decisions to the log\n   file for reproducing the Rule 8.13 violation scenario. */\nint metal_bus_register(struct metal_bus *bus)\n{\n    probe_log(\"entry\", bus);\n\n    if (!bus || !bus->name || !strlen(bus->name)) {\n        probe_log(\"invalid_input_or_empty_name\", bus);\n        return -EINVAL;\n    }\n\n    probe_log(\"before_metal_bus_find\", bus);\n    int find_res = metal_bus_find(bus->name, NULL);\n    probe_log_find(\"after_metal_bus_find\", bus, find_res);\n\n    if (find_res == 0) {\n        probe_log(\"bus_already_exists\", bus);\n        return -EEXIST;\n    }\n\n    metal_list_init(&bus->devices);\n    probe_log(\"after_metal_list_init\", bus);\n\n    metal_list_add_tail(&_metal.common.bus_list, &bus->node);\n    probe_log(\"after_metal_list_add_tail\", bus);\n\n    metal_log(0 /* METAL_LOG_DEBUG stubbed as 0 */, \"registered %s bus\\n\", bus->name);\n    probe_log(\"return_success\", bus);\n    return 0;\n}\n"
}