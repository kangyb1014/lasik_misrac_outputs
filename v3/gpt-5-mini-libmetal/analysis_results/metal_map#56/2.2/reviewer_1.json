{
  "user_message": "An agent A claimed that the following metal_map code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of metal_map.\n```c\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment fd = -1 inside the fd < 0 branch is dead code: immediately afterwards flags is set to MAP_PRIVATE | MAP_ANONYMOUS, and mmap ignores the fd argument when MAP_ANONYMOUS is used. Removing the fd = -1 assignment would not change program behaviour, so this operation constitutes dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_map entry: fd=8, offset=0, size=1048576, expand=1, flags=0x0\nmetal_map entry: fd=9, offset=0, size=1048576, expand=1, flags=0x0\nmetal_map entry: fd=6, offset=0, size=1048576, expand=1, flags=0x0\nmetal_map entry: fd=7, offset=0, size=1048576, expand=1, flags=0x0\nafter flags |= MAP_SHARED: flags=0x1\nafter flags |= MAP_SHARED: flags=0x1\nafter flags |= MAP_SHARED: flags=0x1\nafter flags |= MAP_SHARED: flags=0x1\nbranch: expand path (fd=8), reqsize=1048576\nbranch: expand path (fd=9), reqsize=1048576\nbranch: expand path (fd=6), reqsize=1048576\nbranch: expand path (fd=7), reqsize=1048576\nafter flock(LOCK_EX): error=0, errno=0\nmetal_map entry: fd=14, offset=0, size=1048576, expand=1, flags=0x0\nafter fstat: error=0, st_size=1048576\nmetal_map entry: fd=13, offset=0, size=1048576, expand=1, flags=0x0\nafter flags |= MAP_SHARED: flags=0x1\nmetal_map entry: fd=17, offset=0, size=1048576, expand=1, flags=0x0\nafter potential ftruncate: error=0\nafter flags |= MAP_SHARED: flags=0x1\nbranch: expand path (fd=14), reqsize=1048576\nmetal_map entry: fd=10, offset=0, size=1048576, expand=1, flags=0x0\nmetal_map entry: fd=18, offset=0, size=1048576, expand=1, flags=0x0\nmetal_map entry: fd=21, offset=0, size=1048576, expand=1, flags=0x0\nafter flags |= MAP_SHARED: flags=0x1\nafter flock(LOCK_UN)\nbranch: expand path (fd=13), reqsize=1048576\nafter flock(LOCK_EX): error=0, errno=0\nafter flags |= MAP_SHARED: flags=0x1\nafter flags |= MAP_SHARED: flags=0x1\nafter flags |= MAP_SHARED: flags=0x1\nbranch: expand path (fd=17), reqsize=1048576\nbefore mmap: fd=8, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nbranch: expand path (fd=10), reqsize=1048576\nbranch: expand path (fd=18), reqsize=1048576\nbranch: expand path (fd=21), reqsize=1048576\nafter potential ftruncate: error=0\nmmap succeeded: result=0x7fbd280dc000\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=9, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=6, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=7, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=14, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=13, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=17, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nmmap succeeded: result=0x7fbd21efc000\nbefore mmap: fd=10, offset=0, size=1048576, prot=0x3, flags=0x1\nmmap succeeded: result=0x7fbd21dfc000\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nafter flock(LOCK_EX): error=0, errno=0\nbefore mmap: fd=18, offset=0, size=1048576, prot=0x3, flags=0x1\nafter fstat: error=0, st_size=1048576\nafter potential ftruncate: error=0\nafter flock(LOCK_UN)\nbefore mmap: fd=21, offset=0, size=1048576, prot=0x3, flags=0x1\nmmap succeeded: result=0x7fbd21bfc000\nmmap succeeded: result=0x7fbd21cfc000\nmmap succeeded: result=0x7fbd21afc000\nmmap succeeded: result=0x7fbd219fc000\nmmap succeeded: result=0x7fbd218fc000\nmmap succeeded: result=0x7fbd217fc000\nmmap succeeded: result=0x7fbd216fc000\nmetal_map entry: fd=7, offset=0, size=1048576, expand=1, flags=0x0\nafter flags |= MAP_SHARED: flags=0x1\nmetal_map entry: fd=6, offset=0, size=1048576, expand=1, flags=0x0\nbranch: expand path (fd=7), reqsize=1048576\nafter flags |= MAP_SHARED: flags=0x1\nafter \n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_map:\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the fd < 0 branch the code assigns fd = -1 and then unconditionally sets flags = MAP_PRIVATE | MAP_ANONYMOUS. No other operations in that branch use fd, and mmap later is called with MAP_ANONYMOUS set (on Linux/POSIX the fd argument is ignored when MAP_ANONYMOUS is used). Removing the assignment fd = -1 would not change program behaviour, so that assignment is an executed operation whose removal would not affect behaviour \u2014 i.e. dead code under MISRA C 2023 Rule 2.2. (If portability to a platform where MAP_ANONYMOUS does not cause fd to be ignored were a concern, the conclusion could differ; for the shown project/target the claim stands.)"
}