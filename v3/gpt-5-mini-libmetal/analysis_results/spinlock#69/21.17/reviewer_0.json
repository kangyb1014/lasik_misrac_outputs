{
  "user_message": "An agent A claimed that the following spinlock code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of spinlock.\n```c\nstatic int spinlock(void)\n{\n\tstruct metal_spinlock lock = METAL_SPINLOCK_INIT;\n\tconst int threads = 10;\n\tint value, error;\n\n\terror = metal_run(threads, spinlock_thread, &lock);\n\tif (!error) {\n\t\tvalue = total;\n\t\tvalue -= spinlock_test_count * threads;\n\t\tif (value) {\n\t\t\tmetal_log(METAL_LOG_DEBUG, \"counter mismatch, delta = %d\\n\",\n\t\t\t\t  value);\n\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen pthread_create fails it returns a positive errno (e.g. 11). The code stores error = -pthread_create(...), producing a negative value (e.g. -11), then calls strerror(error). strerror expects a non\u2011negative error number; passing a negative value can cause the implementation to index out of bounds of its internal message table or otherwise access memory beyond the bounds of the object returned by strerror, violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-22T06:33:17 PID=2405667: enter spinlock(): threads=10\n2025-08-22T06:33:17 PID=2405667: calling metal_run(threads=10, spinlock_thread, &lock)\n2025-08-22T06:33:17 PID=2405667: metal_run returned error=0, errno=17\n2025-08-22T06:33:17 PID=2405667: exit spinlock(): returning error=0\n2025-08-22T06:33:18 PID=2405843: enter spinlock(): threads=10\n2025-08-22T06:33:18 PID=2405843: calling metal_run(threads=10, spinlock_thread, &lock)\n2025-08-22T06:33:18 PID=2405843: metal_run returned error=0, errno=17\n2025-08-22T06:33:18 PID=2405843: exit spinlock(): returning error=0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function spinlock:\nint metal_run(int threads, metal_thread_t child, void *arg)\n{\n\tpthread_t tids[threads];\n\tint error, ts_created;\n\n\terror = metal_run_noblock(threads, child, arg, tids, &ts_created);\n\n\tmetal_finish_threads(ts_created, (void *)tids);\n\n\treturn error;\n}\n...\nint metal_run_noblock(int threads, metal_thread_t child,\n\t\t     void *arg, void *tids, int *threads_out)\n{\n\tint error, i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\terror = -pthread_create(&tid_p[i], NULL, child, arg);\n\t\tif (error) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"failed to create thread - %s\\n\",\n\t\t\t\t  strerror(error));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*threads_out = i;\n\treturn error;\n}\n...\nvoid metal_finish_threads(int threads, void *tids)\n{\n\tint i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < threads; i++)\n\t\t(void)pthread_join(tid_p[i], NULL);\n}\n...\nstatic void *spinlock_thread(void *arg)\n{\n\tstruct metal_spinlock *l = arg;\n\tint i;\n\n\tfor (i = 0; i < spinlock_test_count; i++) {\n\t\tmetal_spinlock_acquire(l);\n\t\ttotal++;\n\t\tmetal_spinlock_release(l);\n\t}\n\n\treturn NULL;\n}\n...\nstatic unsigned int total = 0\n...\nstatic const int spinlock_test_count = 1000\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstruct metal_spinlock {\n\tatomic_flag v;\n}\n...\n#define METAL_SPINLOCK_INIT {ATOMIC_FLAG_INIT}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. pthread_create returns 0 on success or a positive POSIX errnum on failure; metal_run_noblock negates that return value (error = -pthread_create(...)), so on failure error is negative. The code then calls strerror(error). strerror is declared in <string.h> and expects a non\u2011negative error number; passing a negative value can lead the implementation to index its internal message table out of bounds (or otherwise access memory incorrectly). That is exactly the sort of out\u2011of\u2011bounds access of string.h facilities that MISRA C 2023 Rule 21.17 forbids. The execution log only shows successful runs and does not refute the potential fault. Recommended fixes: do not negate the pthread_create return when passing to strerror (e.g. call strerror(-error) if error holds -errnum), or better save the positive errnum and use strerror_r or otherwise ensure a valid non\u2011negative error number is passed to strerror."
}