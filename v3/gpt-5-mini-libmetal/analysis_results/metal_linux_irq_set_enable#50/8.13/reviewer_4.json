{
  "user_message": "An agent A claimed that the following metal_linux_irq_set_enable code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_irq_set_enable.\n```c\nstatic void metal_linux_irq_set_enable(struct metal_irq_controller *irq_cntr,\n\t\t\t\t       int irq, unsigned int state)\n{\n\tint offset, ret;\n\n\tif (irq < irq_cntr->irq_base ||\n\t    irq >= irq_cntr->irq_base + irq_cntr->irq_num) {\n\t\tmetal_log(METAL_LOG_ERROR, \"%s: invalid irq %d\\n\",\n\t\t\t  __func__, irq);\n\t\treturn;\n\t}\n\toffset = irq - linux_irq_cntr.irq_base;\n\tmetal_mutex_acquire(&irq_lock);\n\tif (state == METAL_IRQ_ENABLE)\n\t\tmetal_bitmap_set_bit(irqs_enabled, offset);\n\telse\n\t\tmetal_bitmap_clear_bit(irqs_enabled, offset);\n\tmetal_mutex_release(&irq_lock);\n\t/* Notify IRQ thread that IRQ state has changed */\n\tret = metal_linux_irq_notify();\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to notify set %d enable\\n\",\n\t\t\t  __func__, irq);\n\t}\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'irq_cntr' is declared as 'struct metal_irq_controller *irq_cntr' but in the function body only its members are read (irq_base, irq_num); the function does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13 this should be declared 'const struct metal_irq_controller *irq_cntr'. As written it violates Rule 8.13. (If the function must match an existing function-pointer type 'metal_irq_set_enable' that lacks the const qualifier, the typedef should be updated instead of leaving this parameter non-const.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_irq_set_enable:\nstruct metal_irq_controller {\n\tint irq_base; /**< Start of IRQ number of the range managed by\n\t\t \t* the IRQ controller\n\t\t \t*/\n\tint irq_num; /**< Number of IRQs managed by the IRQ controller */\n\tvoid *arg; /**< Argument to pass to interrupt controller function */\n\tmetal_irq_set_enable irq_set_enable; /**< function to set IRQ enable */\n\tmetal_cntr_irq_register irq_register; /**< function to register IRQ\n\t\t\t\t\t\t* handler\n\t\t\t\t\t\t*/\n\tstruct metal_list node; /**< list node */\n\tstruct metal_irq *irqs; /**< Array of IRQs managed by the controller */\n}\n...\nstatic METAL_IRQ_CONTROLLER_DECLARE(linux_irq_cntr,\n\t\t\t\t    0, MAX_IRQS,\n\t\t\t\t    NULL,\n\t\t\t\t    metal_linux_irq_set_enable, NULL,\n\t\t\t\t    irqs)\n...\nstatic unsigned long\nirqs_enabled[metal_div_round_up(MAX_IRQS, METAL_BITS_PER_ULONG)]\n...\nstatic metal_mutex_t irq_lock\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 says a pointer should point to a const-qualified type whenever possible \u2014 i.e. when the function does not modify the pointed-to object. While metal_linux_irq_set_enable only reads members of *irq_cntr and could conceptually take a const pointer, in this code the function is assigned to the irq_set_enable field of struct metal_irq_controller, which is declared as a function-pointer type (metal_irq_set_enable) that does not include a const qualifier. The function\u2019s prototype must match that typedef to be assignable; adding const would make it incompatible with the existing function-pointer type. Thus the non-const parameter is dictated by the API/typedef, and this use is not a violation of MISRA 8.13 in context. (If the API/typedef were changed project\u2011wide to accept a pointer-to-const, then the function signature should be updated \u2014 but that is a design change, not a local MISRA violation.)"
}