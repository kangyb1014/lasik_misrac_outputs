{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses the GCC token-pasting extension '##__VA_ARGS__' (seen in the metal_log macro) to swallow the preceding comma when no variadic arguments are provided. This '##__VA_ARGS__' usage is a compiler-specific (GNU) extension and thus violates MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: ps=0x5598d45f0800, page_size=4096, fd=7, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=8, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=6, requested_size=1048576, mmap_flags=0x0\naligned size=1048576, pages=256\naligned size=1048576, pages=256\nenter: ps=0x5598d45f0800, page_size=4096, fd=11, requested_size=1048576, mmap_flags=0x0\naligned size=1048576, pages=256\nenter: ps=0x5598d45f0800, page_size=4096, fd=14, requested_size=1048576, mmap_flags=0x0\nmetal_map returned 0, mem=0x7f83d8b3d000\naligned size=1048576, pages=256\nmetal_map returned 0, mem=0x7f83d8a3d000\nenter: ps=0x5598d45f0800, page_size=4096, fd=12, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=18, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=20, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=21, requested_size=1048576, mmap_flags=0x0\nenter: ps=0x5598d45f0800, page_size=4096, fd=24, requested_size=1048576, mmap_flags=0x0\naligned size=1048576, pages=256\nmetal_map returned 0, mem=0x7f83d813c000\naligned size=1048576, pages=256\naligned size=1048576, pages=256\naligned size=1048576, pages=256\naligned size=1048576, pages=256\naligned size=1048576, pages=256\nmlock returned 0 (errno=0 -> Success)\nallocating phys array of size=2048\nmlock returned 0 (errno=0 -> Success)\nallocating phys array of size=2048\nmetal_map returned 0, mem=0x7f83d803c000\nmlock returned 0 (errno=0 -> Success)\nmetal_map returned 0, mem=0x7f83d2efe000\nallocating phys array of size=2048\nmetal_map returned 0, mem=0x7f83d2dfe000\nmlock returned 0 (errno=0 -> Success)\nmetal_map returned 0, mem=0x7f83d2cfe000\nallocating phys array of size=2048\nmetal_map returned 0, mem=0x7f83d2bfe000\nmlock returned 0 (errno=0 -> Success)\nmetal_map returned 0, mem=0x7f83d2afe000\nallocating phys array of size=2048\nphys allocated at 0x7f83c4000d50\nphys allocated at 0x7f83c8000d50\nmetal_map returned 0, mem=0x7f83d29fe000\nphys allocated at 0x7f83c0000d50\nphys allocated at 0x7f83cc000d50\nio allocated at 0x7f83c4001560\nio allocated at 0x7f83c8001560\nio allocated at 0x7f83c0001560\nio allocated at 0x7f83cc001560\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\nmlock returned 0 (errno=0 -> Success)\nallocating phys array of size=2048\nmlock returned 0 (errno=0 -> Success)\nallocating phys array of size=2048\nmlock returned 0 (errno=0 -> Success)\nphys allocated at 0x7f83b8000d50\nallocating phys array of size=2048\nphys allocated at 0x7f83a4000d50\nphys allocated at 0x7f83bc000d50\nio allocated at 0x7f83b8001560\npage=0, virt=0x7f83d813c000, offset=0, virt_addr=0x7f83d813c000, virt2phys_error=0, phys[0]=0x0\nio allocated at 0x7f83a4001560\nio allocated at 0x7f83bc001560\npage=0, virt=0x7f83d2efe000, offset=0, virt_addr=0x7f83d2efe000, virt2phys_error=0, phys[0]=0x0\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\npage=0, virt=0x7f83d8b3d000, offset=0, virt_addr=0x7f83d8b3d000, virt2phys_error=0, phys[0]=0x0\npage=0, virt=0x7f83d8a3d000, offset=0, virt_addr=0x7f83d8a3d000, virt2phys_error=0, phys[0]=0x0\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\npage=1, virt=0x7f83d813c000, offset=4096, virt_addr=0x7f83d813d000, virt2phys_error=0, phys[1]=0x0\npagemap_fd >= 0 (value=4). resolving virtual->physical for each page\nphys allocated at 0x7f83b4000d50\npage=1, virt=0x7f83d2efe000, offset=4096, virt_addr=0x7f83d2eff000, virt2phys_error=0, phys[1]=0x0\npage=1, virt=0x7f83d8b3d000, offset=4096, virt_addr=0x7f83d8b3e000, virt2phys_error=0, phys[1]=0x0\npage=0, virt=0x7f83d2cfe000, offset=0, virt_addr=0x7f83d2cfe000, virt2phys_error=0, phys[0]=0x0\npage=2, virt=0x7f83d813c000, offset=8192, virt_addr=0x7f83d813e000, virt2phys_error=0, phys[2]=0x0\nio allocated at 0x7f83b4001560\npage=1, virt=0x7f83d8a3d000, offse\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\n#define metal_align_up(size, align) metal_align_down((size)+(align)-1,align)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\ntypedef unsigned long metal_phys_addr_t\n...\n#define METAL_BAD_OFFSET ((unsignedlong)-1)\n...\nstatic const struct metal_io_ops metal_shmem_io_ops = {\n\tNULL, NULL, NULL, NULL, NULL, metal_shmem_io_close, NULL, NULL\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The metal_log macro in the additional code uses the GNU extension '##__VA_ARGS__' (the comma-swallowing idiom) which is a compiler-specific extension and therefore contravenes MISRA C 2023 Rule 1.2. In addition, the macro uses the GCC statement-expression form '({ ... })', which is another compiler extension. While __VA_ARGS__ itself is a standard C feature (C99), the specific use of '##__VA_ARGS__' to remove a preceding comma is a GNU extension (and __VA_OPT__ in C2x is the standardized replacement). Both identified constructs are language extensions and thus justify the Rule 1.2 violation."
}