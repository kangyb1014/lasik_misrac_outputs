{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses GCC language extensions: it employs the GCC 'statement expression' extension \"({ ... })\" and the GNU token-pasting trick '##__VA_ARGS__' to swallow a comma for empty variadic args. Both are compiler-specific extensions (not standard C) and thus violate MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=7 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=8 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=9 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=6 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\nmetal_map returned error=0 mem=0x7fba241bd000\nmetal_map returned error=0 mem=0x7fba240bd000\nmetal_map returned error=0 mem=0x7fba1eefe000\nmetal_map returned error=0 mem=0x7fba1edfe000\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=13 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\naligned size=1048576 pages=256\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=10 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\naligned size=1048576 pages=256\nmlock returned error=0 errno=0 (Success)\nmlock returned error=0 errno=0 (Success)\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nmlock returned error=0 errno=0 (Success)\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nmlock returned error=0 errno=0 (Success)\nmetal_map returned error=0 mem=0x7fba1e4fd000\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nmlock returned error=0 errno=0 (Success)\nallocated io=0x7fba14001560\nallocated io=0x7fba10001560\nallocated io=0x7fba0c001560\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\n_metal.pagemap_fd=4\n_metal.pagemap_fd=4\n_metal.pagemap_fd=4\nallocated io=0x7fba18001560\nvirt2phys: page=0 offset=0 virt_addr=0x7fba1eefe000\nvirt2phys: page=0 offset=0 virt_addr=0x7fba240bd000\nvirt2phys: page=0 offset=0 virt_addr=0x7fba241bd000\nmetal_map returned error=0 mem=0x7fba1dbfc000\nallocated io=0x7fba04001560\n_metal.pagemap_fd=4\nmetal_virt2phys returned error=0 phys[0]=0\nmetal_virt2phys returned error=0 phys[0]=0\nmetal_virt2phys returned error=0 phys[0]=0\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=11 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=14 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=18 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\nENTER: metal_shmem_try_map ps=0x55acf141e800 fd=24 requested_size=1048576 ps->page_size=4096 ps->mmap_flags=0x0 ps->page_shift=12\n_metal.pagemap_fd=4\nvirt2phys: page=0 offset=0 virt_addr=0x7fba1edfe000\nvirt2phys: page=1 offset=4096 virt_addr=0x7fba1eeff000\nvirt2phys: page=1 offset=4096 virt_addr=0x7fba241be000\nvirt2phys: page=1 offset=4096 virt_addr=0x7fba240be000\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\naligned size=1048576 pages=256\nvirt2phys: page=0 offset=0 virt_addr=0x7fba1e4fd000\nmetal_virt2phys returned error=0 phys[0]=0\nmetal_virt2phys returned error=0 phys[1]=0\nmetal_virt2phys returned error=0 phys[1]=0\nmetal_virt2phys returned error=0 phys[1]=0\nvirt2phys: page=1 offset=4096 virt_addr=0x7fba1edff000\nvirt2phys: page=2 offset=8192 virt_addr=0x7fba241bf000\nvirt2phys: page=2 offset=8192 virt_addr=0x7fba1ef00000\nvirt2phys: page=2 offset=8192 virt_addr=0x7fba240bf000\nmetal_virt2phys returned error=0 phys[0]=0\nvirt2phys: page=1 offset=4096 virt_addr=0x7fba1e4fe000\nmlock returned error=0 errno=0 (Success)\nmetal_map returned error=0 mem=0x7fba1d2fb000\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nmetal_map returned error=0 mem=0x7fba1d1fb000\nmlock returned error=0 errno=0 (Success)\nmetal_map returned error=0 mem=0x7fba1d0fb000\nallocating phys array size=2048 (pages=256 sizeof=*phys=8)\nmetal_map returned error=0 mem=0x7fba1cffb000\nallocated io=0x7fba08001560\nmetal_virt2phys re\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\n#define metal_align_up(size, align) metal_align_down((size)+(align)-1,align)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\ntypedef unsigned long metal_phys_addr_t\n...\n#define METAL_BAD_OFFSET ((unsignedlong)-1)\n...\nstatic const struct metal_io_ops metal_shmem_io_ops = {\n\tNULL, NULL, NULL, NULL, NULL, metal_shmem_io_close, NULL, NULL\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The provided additional code shows the macro\n\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\n})\n\nwhich uses two GNU extensions: the GCC/Clang statement-expression construct ({ ... }) and the token-pasting trick '##__VA_ARGS__' to swallow a comma for empty variadic arguments. Both are compiler-specific language extensions and therefore violate MISRA C 2023 Rule 1.2. Because metal_shmem_try_map calls metal_log, the function (as presented with its supporting macros) depends on these extensions."
}