{
  "user_message": "An agent A claimed that the following metal_shmem_try_map code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_try_map.\n```c\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'virt' is declared as uint8_t * but is only used to compute addresses (virt + offset) and passed to metal_virt2phys for address translation; it is never used to modify the pointed memory. Therefore it could and should be declared as a pointer to a const-qualified type (e.g. const uint8_t *virt). As written it violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=6, size=1048576)\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=9, size=1048576)\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=10, size=1048576)\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=7, size=1048576)\naligned size=1048576, page_size=4096, pages=256\naligned size=1048576, page_size=4096, pages=256\nmetal_map(fd=10, size=1048576, flags=0x0) -> error=0, mem=0x7f83e83c7000\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=15, size=1048576)\naligned size=1048576, page_size=4096, pages=256\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=17, size=1048576)\naligned size=1048576, page_size=4096, pages=256\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=18, size=1048576)\naligned size=1048576, page_size=4096, pages=256\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=19, size=1048576)\naligned size=1048576, page_size=4096, pages=256\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=13, size=1048576)\naligned size=1048576, page_size=4096, pages=256\naligned size=1048576, page_size=4096, pages=256\nENTER: metal_shmem_try_map(ps=0x55b613a68800, fd=16, size=1048576)\naligned size=1048576, page_size=4096, pages=256\naligned size=1048576, page_size=4096, pages=256\nmetal_map(fd=6, size=1048576, flags=0x0) -> error=0, mem=0x7f83e82c7000\nmlock(mem=0x7f83e83c7000, size=1048576) -> 0\nmetal_map(fd=15, size=1048576, flags=0x0) -> error=0, mem=0x7f83e81c7000\nmetal_map(fd=17, size=1048576, flags=0x0) -> error=0, mem=0x7f83e80c7000\nmlock(mem=0x7f83e81c7000, size=1048576) -> 0\nmetal_map(fd=18, size=1048576, flags=0x0) -> error=0, mem=0x7f83da6fd000\nmetal_map(fd=13, size=1048576, flags=0x0) -> error=0, mem=0x7f83da5fd000\nmlock(mem=0x7f83da6fd000, size=1048576) -> 0\nmetal_map(fd=9, size=1048576, flags=0x0) -> error=0, mem=0x7f83da4fd000\nmlock(mem=0x7f83da4fd000, size=1048576) -> 0\nmetal_map(fd=16, size=1048576, flags=0x0) -> error=0, mem=0x7f83da3fd000\nmetal_map(fd=19, size=1048576, flags=0x0) -> error=0, mem=0x7f83da2fd000\nmlock(mem=0x7f83da3fd000, size=1048576) -> 0\nmetal_map(fd=7, size=1048576, flags=0x0) -> error=0, mem=0x7f83da1fd000\nmlock(mem=0x7f83da1fd000, size=1048576) -> 0\nmalloc phys (2048 bytes) -> 0x7f83e0000d50\nmalloc io (112 bytes) -> 0x7f83e0001560\npage 0: virt=0x7f83da1fd000 offset=0 computed_addr=0x7f83da1fd000\nmalloc phys (2048 bytes) -> 0x7f83d4001d60\nmalloc phys (2048 bytes) -> 0x7f83c8000b70\nmalloc phys (2048 bytes) -> 0x7f83cc001d60\nmalloc io (112 bytes) -> 0x7f83cc002570\npage 0: virt=0x7f83e83c7000 offset=0 computed_addr=0x7f83e83c7000\nmalloc io (112 bytes) -> 0x7f83c8001380\npage 0: virt=0x7f83da3fd000 offset=0 computed_addr=0x7f83da3fd000\nmalloc phys (2048 bytes) -> 0x7f83d0000b70\nmalloc io (112 bytes) -> 0x7f83d0001380\npage 0: virt=0x7f83e81c7000 offset=0 computed_addr=0x7f83e81c7000\nmalloc io (112 bytes) -> 0x7f83d4002570\npage 0: virt=0x7f83da4fd000 offset=0 computed_addr=0x7f83da4fd000\nmlock(mem=0x7f83e80c7000, size=1048576) -> 0\nmlock(mem=0x7f83da5fd000, size=1048576) -> 0\nmetal_virt2phys(addr=0x7f83da1fd000) -> error=0, phys[0]=0\npage 1: virt=0x7f83da1fd000 offset=4096 computed_addr=0x7f83da1fe000\nmetal_virt2phys(addr=0x7f83da3fd000) -> error=0, phys[0]=0\nmetal_virt2phys(addr=0x7f83e81c7000) -> error=0, phys[0]=0\nmetal_virt2phys(addr=0x7f83e83c7000) -> error=0, phys[0]=0\nmalloc phys (2048 bytes) -> 0x7f83c4000b70\nmalloc io (112 bytes) -> 0x7f83c4001380\npage 0: virt=0x7f83da6fd000 offset=0 computed_addr=0x7f83da6fd000\npage 1: virt=0x7f83e83c7000 offset=4096 computed_addr=0x7f83e83c8000\npage 1: virt=0x7f83da3fd000 offset=4096 computed_addr=0x7f83da3fe000\nmetal_virt2phys(addr=0x7f83da4fd000) -> error=0, phys[0]=0\npage 1: virt=0x7f83da4fd000 offset=4096 computed_addr=0x7f83da4fe000\npage 1: virt=0x7f83e81c7000 offset=4096 computed_addr=0x7f83e81c8000\nmlock(mem=0x7f83da2fd000, size=1048576) -> 0\nmlock(mem=0x7f83e82c7000, size=1048576) -> 0\nmalloc phys (2048 bytes) -> 0x7f83bc000b70\nmalloc io (112 bytes) -> 0x7f83bc001380\npage 0: virt=0x7f83da2fd000 offset=0 computed_addr=0x7f83da2fd000\nmetal_virt2phys(addr=0x7f83da3fe000) -> error=0, phys[1]=0\nmetal_virt2phys(addr=0x7f83da1\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_try_map:\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\ntypedef unsigned long metal_phys_addr_t\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In the function virt is only used to compute addresses (virt + offset) and to pass those addresses to metal_virt2phys; the pointed-to memory is never modified through virt. Therefore the local pointer can and should be declared to point to a const-qualified type (for example const uint8_t *virt or const void *virt) to satisfy MISRA C 2023 Rule 8.13. The only caveat is if the prototype of metal_virt2phys (or some other API used here) requires a non-const pointer; in that case the API constraint prevents making virt const (or a cast would be needed at the call site). Given the code shown, however, the report that this location violates Rule 8.13 is valid."
}