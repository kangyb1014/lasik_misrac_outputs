{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_linux_get_device_property:\n```c\nint metal_linux_get_device_property(struct metal_device *device,\n\t\t\t\t    const char *property_name,\n\t\t\t\t    void *output, int len)\n{\n\tint fd = 0;\n\tint status = 0;\n\tconst int flags = O_RDONLY;\n\tconst int mode = S_IRUSR | S_IRGRP | S_IROTH;\n\tstruct linux_device *ldev = to_linux_device(device);\n\tchar path[PATH_MAX];\n\n\tsnprintf(path, sizeof(path), \"%s/of_node/%s\",\n\t\t\t ldev->sdev->path, property_name);\n\tfd = open(path, flags, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\tif (read(fd, output, len) < 0) {\n\t\tstatus = -errno;\n\t\tclose(fd);\n\t\treturn status;\n\t}\n\n\tstatus = close(fd);\n\treturn status < 0 ? -errno : 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_get_device_property:\nstatic struct linux_device *to_linux_device(struct metal_device *device)\n{\n\treturn metal_container_of(device, struct linux_device, device);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (read(fd, output, len) < 0) {\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the call uses read(), which is not one of the <string.h> string\u2011handling functions covered by MISRA C 2023 Rule 21.17. Rule 21.17 specifically targets functions such as memcpy/memmove/memset/strcmp/strcpy/strlen/etc. However, there is a separate safety concern: if the caller provides an output buffer smaller than len (e.g. a buffer of 16 bytes while len is 32), read(fd, output, len) can write beyond the buffer and cause a buffer overflow (this would violate other memory\u2011safety rules, but not 21.17)."
}