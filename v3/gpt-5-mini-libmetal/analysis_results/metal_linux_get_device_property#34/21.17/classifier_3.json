{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_linux_get_device_property:\n```c\nint metal_linux_get_device_property(struct metal_device *device,\n\t\t\t\t    const char *property_name,\n\t\t\t\t    void *output, int len)\n{\n\tint fd = 0;\n\tint status = 0;\n\tconst int flags = O_RDONLY;\n\tconst int mode = S_IRUSR | S_IRGRP | S_IROTH;\n\tstruct linux_device *ldev = to_linux_device(device);\n\tchar path[PATH_MAX];\n\n\tsnprintf(path, sizeof(path), \"%s/of_node/%s\",\n\t\t\t ldev->sdev->path, property_name);\n\tfd = open(path, flags, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\tif (read(fd, output, len) < 0) {\n\t\tstatus = -errno;\n\t\tclose(fd);\n\t\treturn status;\n\t}\n\n\tstatus = close(fd);\n\treturn status < 0 ? -errno : 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_get_device_property:\nstatic struct linux_device *to_linux_device(struct metal_device *device)\n{\n\treturn metal_container_of(device, struct linux_device, device);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nchar path[PATH_MAX];\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the declaration char path[PATH_MAX] itself does not invoke any <string.h> functions. In the function the buffer is populated via snprintf(path, sizeof(path), \"%s/of_node/%s\", ...), which is size-bounded and will not write beyond path (it truncates). A concrete violation scenario would be if unbounded string.h functions were used, e.g. strcpy(path, ldev->sdev->path); strcat(path, \"/of_node/\"); strcat(path, property_name); \u2014 this could overflow path when the combined source lengths >= PATH_MAX."
}