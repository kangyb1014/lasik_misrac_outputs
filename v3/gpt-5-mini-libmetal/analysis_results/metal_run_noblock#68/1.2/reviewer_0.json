{
  "user_message": "An agent A claimed that the following metal_run_noblock code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_run_noblock.\n```c\nint metal_run_noblock(int threads, metal_thread_t child,\n\t\t     void *arg, void *tids, int *threads_out)\n{\n\tint error, i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\terror = -pthread_create(&tid_p[i], NULL, child, arg);\n\t\tif (error) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"failed to create thread - %s\\n\",\n\t\t\t\t  strerror(error));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*threads_out = i;\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses compiler-specific language extensions: the GNU statement-expression extension '({ ... })' and the GCC/Clang variadic-macro comma swallowing '##__VA_ARGS__'. Both are non\u2011standard extensions and therefore violate MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_run_noblock ENTRY: threads=10, child=0x5609f7357863, arg=0x7fff908a8f2c, tids=0x7fff908a8e70, threads_out=0x7fff908a8ee0\nmetal_run_noblock: creating thread index=0 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=1 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=2 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=3 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=4 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=5 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=6 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=7 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=8 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=9 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock EXIT: created_count=10, return_error=0\nmetal_run_noblock ENTRY: threads=10, child=0x5609f7357e1c, arg=0x7fff908a8f3c, tids=0x7fff908a8e80, threads_out=0x7fff908a8ef0\nmetal_run_noblock: creating thread index=0 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=1 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=2 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=3 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=4 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=5 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=6 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=7 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=8 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=9 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock EXIT: created_count=10, return_error=0\nmetal_run_noblock ENTRY: threads=10, child=0x5609f735846e, arg=0x5609f735d198, tids=0x7fff908a8e80, threads_out=0x7fff908a8ef0\nmetal_run_noblock: creating thread index=0 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=1 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=2 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=3 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=4 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=5 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=6 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=7 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=8 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=9 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock EXIT: created_count=10, return_error=0\nmetal_run_noblock ENTRY: threads=10, child=0x5609f7358c4e, arg=(nil), tids=0x7fff908a8ef0, threads_out=0x7fff908a8ee8\nmetal_run_noblock: creating thread index=0 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=1 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=2 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=3 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=4 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=5 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=6 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=7 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=8 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock: creating thread index=9 -> pthread_create_ret=0, error_var=0\nmetal_run_noblock EXIT: created_count=10, return_error=0\nmetal_run_noblock ENTRY: threads=10, child=0x5609f7358d36, arg=(nil), tids=0x7fff908a8e30, threads_out=0x7fff908a8ea0\nmetal_run_noblock: creating thread index=0 -> pthre\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_run_noblock:\ntypedef void *(*metal_thread_t)(void *)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function metal_run_noblock itself does not contain non\u2011standard syntax, but it calls the macro metal_log which (per the additional code) is defined using GNU extensions: a statement-expression ({ ... }) and the GCC/Clang variadic\u2011macro comma\u2011swallowing '##__VA_ARGS__'. Both of those are explicitly documented compiler extensions (GCC/Clang) and therefore constitute use of language extensions, violating MISRA C 2023 Rule 1.2. Recommendation: replace the statement\u2011expression with a standard inline function or a do { ... } while (0) macro, and avoid the GCC '##__VA_ARGS__' comma\u2011swallowing technique (use a portable variadic function or a standards\u2011compliant variadic macro approach)."
}