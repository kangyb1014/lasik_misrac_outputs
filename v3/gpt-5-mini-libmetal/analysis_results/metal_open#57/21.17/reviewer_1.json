{
  "user_message": "An agent A claimed that the following metal_open code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_open.\n```c\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf path is non-NULL but points to a character array that is not guaranteed to be null-terminated (or whose terminator may lie beyond the allocated object), calling strlen(path) can read past the object bounds. Although the NULL check (short-circuited left operand) prevents dereferencing a NULL pointer, there is no protection against running off the end of a non-terminated buffer \u2014 strlen can therefore access beyond the bounds and violate Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: call succeeded; fd=11\nmetal_open: call succeeded; fd=9\nmetal_open: call succeeded; fd=10\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: call succeeded; fd=6\nmetal_open: call succeeded; fd=8\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: call succeeded; fd=7\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: call succeeded; fd=12\nmetal_open: call succeeded; fd=13\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: call succeeded; fd=14\nmetal_open: entry; path=0x56112934d198, shm=1\nmetal_open: about to call strlen(path); path=0x56112934d198\nmetal_open: strlen returned 4 for path=0x56112934d198\nmetal_open: calling shm_open for path=0x56112934d198\nmetal_open: call succeeded; fd=15\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: call succeeded; fd=7\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: call succeeded; fd=11\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: call succeeded; fd=6\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: call succeeded; fd=8\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: call succeeded; fd=9\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: entry; path=0x564f116ae198, shm=1\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: about to call strlen(path); path=0x564f116ae198\nmetal_open: calling shm_open for path=0x564f116ae198\nmetal_open: strlen returned 4 for path=0x564f116ae198\nmetal_open: call succeeded\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_open:\nstatic int metal_uio_dev_open(struct linux_bus *lbus, struct linux_device *ldev)\n{\n\tchar *instance, path[SYSFS_PATH_MAX];\n\tstruct linux_driver *ldrv = ldev->ldrv;\n\tunsigned long *phys, offset = 0, size = 0;\n\tstruct metal_io_region *io;\n\tstruct dlist *dlist;\n\tint result, i;\n\tvoid *virt;\n\tint irq_info;\n\n\n\tldev->fd = -1;\n\tldev->device.irq_info = (void *)-1;\n\n\tldev->sdev = sysfs_open_device(lbus->bus_name, ldev->dev_name);\n\tif (!ldev->sdev) {\n\t\tmetal_log(METAL_LOG_ERROR, \"device %s:%s not found\\n\",\n\t\t\t  lbus->bus_name, ldev->dev_name);\n\t\treturn -ENODEV;\n\t}\n\tmetal_log(METAL_LOG_DEBUG, \"opened sysfs device %s:%s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name);\n\n\tresult = metal_uio_dev_bind(ldev, ldrv);\n\tif (result)\n\t\treturn result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/uio\", ldev->sdev->path);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tdlist = sysfs_open_directory_list(path);\n\tif (!dlist) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to scan class path %s\\n\",\n\t\t\t  path);\n\t\treturn -errno;\n\t}\n\n\tdlist_for_each_data(dlist, instance, char) {\n\t\tresult = snprintf(ldev->cls_path, sizeof(ldev->cls_path),\n\t\t\t\t  \"%s/%s\", path, instance);\n\t\tif (result >= (int)sizeof(ldev->cls_path))\n\t\t\treturn -EOVERFLOW;\n\t\tresult = snprintf(ldev->dev_path, sizeof(ldev->dev_path),\n\t\t\t\t  \"/dev/%s\", instance);\n\t\tif (result >= (int)sizeof(ldev->dev_path))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t}\n\tsysfs_close_list(dlist);\n\n\tif (sysfs_path_is_dir(ldev->cls_path) != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid device class path %s\\n\",\n\t\t\t  ldev->cls_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif (!access(ldev->dev_path, F_OK))\n\t\t\tbreak;\n\t\tusleep(10);\n\t\ti++;\n\t} while (i < 1000);\n\tif (i >= 1000) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open file %s, timeout.\\n\",\n\t\t\t  ldev->dev_path);\n\t\treturn -ENODEV;\n\t}\n\tresult = metal_open(ldev->dev_path, 0);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open device %s\\n\",\n\t\t\t  ldev->dev_path, strerror(-result));\n\t\treturn result;\n\t}\n\tldev->fd = result;\n\n\tmetal_log(METAL_LOG_DEBUG, \"opened %s:%s as %s\\n\",\n\t\t  lbus->bus_name, ldev->dev_name, ldev->dev_path);\n\n\tfor (i = 0, result = 0; !result && i < METAL_MAX_DEVICE_REGIONS; i++) {\n\t\tphys = &ldev->region_phys[ldev->device.num_regions];\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"offset\", &offset));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"addr\", phys));\n\t\tresult = (result ? result :\n\t\t\t metal_uio_read_map_attr(ldev, i, \"size\", &size));\n\t\tresult = (result ? result :\n\t\t\t metal_map(ldev->fd, i * getpagesize(), size, 0, 0, &virt));\n\t\tif (!result) {\n\t\t\tio = &ldev->device.regions[ldev->device.num_regions];\n\t\t\tmetal_io_init(io, virt, phys, size, -1, 0, NULL);\n\t\t\tldev->device.num_regions++;\n\t\t}\n\t}\n\n\tirq_info = 1;\n\tif (write(ldev->fd, &irq_info, sizeof(irq_info)) <= 0) {\n\t\tmetal_log(METAL_LOG_INFO,\n\t\t\t  \"%s: No IRQ for device %s.\\n\",\n\t\t\t  __func__, ldev->dev_name);\n\t\tldev->device.irq_num =  0;\n\t\tldev->device.irq_info = (void *)-1;\n\t} else {\n\t\tldev->device.irq_num =  1;\n\t\tldev->device.irq_info = (void *)(intptr_t)ldev->fd;\n\t\tmetal_linux_irq_register_dev(&ldev->device, ldev->fd);\n\t}\n\n\treturn 0;\n}\n...\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n...\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n...\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nstatic int metal_uio_read_map_attr(struct linux_device *ldev,\n\t\t\t\t   unsigned int index,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned long *value)\n{\n\tconst char *cls = ldev->cls_path;\n\tstruct sysfs_attribute *attr;\n\tchar path[SYSFS_PATH_MAX];\n\tint result;\n\n\tresult = snprintf(path, sizeof(path), \"%s/maps/map%u/%s\", cls, index, name);\n\tif (result >= (int)sizeof(path))\n\t\treturn -EOVERFLOW;\n\tattr = sysfs_open_attribute(path);\n\tif (!attr || sysfs_read_attribute(attr) != 0) {\n\t\tsysfs_close_attribute(attr);\n\t\treturn -errno;\n\t}\n\n\t*value = strtoul(attr->value, NULL, 0);\n\n\tsysfs_close_attribute(attr);\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strlen() scans until a terminating NUL and therefore can read past the bounds of the object referenced by path if that object is not guaranteed to be NUL\u2011terminated. The code only checks for a NULL pointer and then calls strlen(path) (the left operand short\u2011circuits the NULL test but does not protect against a non\u2011terminated buffer), so there is a possible out\u2011of\u2011bounds access and a violation of MISRA C 2023 Rule 21.17 unless every caller can be proved to always pass a NUL\u2011terminated string. The provided execution log only shows runs where the strings happened to be NUL\u2011terminated and does not remove the potential violation. Recommended fixes include using a bounded length check (e.g. strnlen with a known maximum) or otherwise enforcing/documenting and verifying the precondition that path is NUL\u2011terminated before calling strlen."
}