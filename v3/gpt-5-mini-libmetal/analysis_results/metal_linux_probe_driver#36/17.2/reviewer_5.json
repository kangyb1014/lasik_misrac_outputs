{
  "user_message": "An agent A claimed that the following metal_linux_probe_driver code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_driver.\n```c\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_log expands to a call through the function pointer _metal.common.log_handler. If the installed log handler function (e.g. void my_log_handler(...)) calls metal_log, the call sequence becomes: my_log_handler(...) -> metal_log(...) (macro expansion) -> _metal.common.log_handler(...) -> my_log_handler(...). That is an indirect self-call of my_log_handler, violating MISRA C 2023 Rule 17.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[pid=2269786] ENTER metal_linux_probe_driver: lbus=0x7feb9f486b80, ldrv=0x7feb9f486be0, drv_name=uio_pdrv_genirq, mod_name=uio_pdrv_genirq\n[pid=2269786] after initial sysfs_open_driver: sdrv=0x55a916a63a20\n[pid=2269786] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x55a916a63a20)\n[pid=2269786] ENTER metal_linux_probe_driver: lbus=0x7feb9f486b80, ldrv=0x7feb9f486c28, drv_name=uio_dmem_genirq, mod_name=uio_dmem_genirq\n[pid=2269786] after initial sysfs_open_driver: sdrv=0x55a916a63bc0\n[pid=2269786] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x55a916a63bc0)\n[pid=2269786] ENTER metal_linux_probe_driver: lbus=0x7feb9f487de8, ldrv=0x7feb9f487e48, drv_name=vfio-pci, mod_name=vfio-pci\n[pid=2269786] after initial sysfs_open_driver: sdrv=0x55a916a63ec0\n[pid=2269786] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x55a916a63ec0)\n[pid=2269786] ENTER metal_linux_probe_driver: lbus=0x7feb9f487de8, ldrv=0x7feb9f487e90, drv_name=uio_pci_generic, mod_name=uio_pci_generic\n[pid=2269786] after initial sysfs_open_driver: sdrv=0x55a916a64060\n[pid=2269786] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x55a916a64060)\n[pid=2270513] ENTER metal_linux_probe_driver: lbus=0x5610691a9260, ldrv=0x5610691a92c0, drv_name=uio_pdrv_genirq, mod_name=uio_pdrv_genirq\n[pid=2270513] after initial sysfs_open_driver: sdrv=0x56109cdc9a20\n[pid=2270513] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x56109cdc9a20)\n[pid=2270513] ENTER metal_linux_probe_driver: lbus=0x5610691a9260, ldrv=0x5610691a9308, drv_name=uio_dmem_genirq, mod_name=uio_dmem_genirq\n[pid=2270513] after initial sysfs_open_driver: sdrv=0x56109cdc9bc0\n[pid=2270513] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x56109cdc9bc0)\n[pid=2270513] ENTER metal_linux_probe_driver: lbus=0x5610691aa4c8, ldrv=0x5610691aa528, drv_name=vfio-pci, mod_name=vfio-pci\n[pid=2270513] after initial sysfs_open_driver: sdrv=0x56109cdc9ec0\n[pid=2270513] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x56109cdc9ec0)\n[pid=2270513] ENTER metal_linux_probe_driver: lbus=0x5610691aa4c8, ldrv=0x5610691aa570, drv_name=uio_pci_generic, mod_name=uio_pci_generic\n[pid=2270513] after initial sysfs_open_driver: sdrv=0x56109cdca060\n[pid=2270513] EXIT metal_linux_probe_driver: returning 0 (sdrv=0x56109cdca060)\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_probe_driver:\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic int metal_linux_probe_bus(struct linux_bus *lbus)\n{\n\tstruct linux_driver *ldrv;\n\tint ret, error = -ENODEV;\n\n\tlbus->sbus = sysfs_open_bus(lbus->bus_name);\n\tif (!lbus->sbus)\n\t\treturn -ENODEV;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tret = metal_linux_probe_driver(lbus, ldrv);\n\t\t/* Clear the error if any driver is available */\n\t\tif (!ret)\n\t\t\terror = ret;\n\t}\n\n\tif (error) {\n\t\tmetal_linux_bus_close(&lbus->bus);\n\t\treturn error;\n\t}\n\n\terror = metal_linux_register_bus(lbus);\n\tif (error)\n\t\tmetal_linux_bus_close(&lbus->bus);\n\n\treturn error;\n}\n...\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n...\nstatic int metal_linux_register_bus(struct linux_bus *lbus)\n{\n\tlbus->bus.name = lbus->bus_name;\n\tlbus->bus.ops  = metal_linux_bus_ops;\n\treturn metal_bus_register(&lbus->bus);\n}\n...\nint metal_linux_bus_init(void)\n{\n\tstruct linux_bus *lbus;\n\tint valid = 0;\n\n\tfor_each_linux_bus(lbus)\n\t\tvalid += metal_linux_probe_bus(lbus) ? 0 : 1;\n\n\treturn valid ? 0 : -ENODEV;\n}\n...\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. metal_linux_probe_driver does not call itself (directly or indirectly) in the supplied source: it calls sysfs_open_driver and uses the metal_log macro. metal_log is a macro that expands to a call via the function pointer _metal.common.log_handler. An indirect recursive call sequence my_log_handler -> metal_log -> _metal.common.log_handler -> my_log_handler would indeed be an indirect self-call of the user-supplied handler (my_log_handler) and would violate MISRA Rule 17.2 if both functions are part of the same program and the call graph contains that cycle. However, that recursion arises only because a user-installed log handler calls metal_log (i.e. it is a problem in the handler implementation/installation), not because metal_linux_probe_driver itself violates Rule 17.2. Also, metal_log is a macro invoking a function pointer; the library code does not inherently create a recursive call cycle. Therefore the claim that metal_linux_probe_driver violates MISRA C 2023 Rule 17.2 is false."
}