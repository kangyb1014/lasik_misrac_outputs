{
  "user_message": "Target function code is:\n```c\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'shmem_child': {'callees': ['metal_shmem_open', 'metal_io_virt', 'metal_io_phys', 'metal_io_phys_to_virt', 'metal_io_virt_to_phys', 'metal_io_finish'], 'callers': []}, 'metal_shmem_open': {'callees': ['metal_shmem_open_generic', 'metal_open', 'metal_shmem_try_map'], 'callers': ['shmem_child']}, 'metal_io_virt': {'callees': [], 'callers': ['metal_io_block_read', 'metal_io_block_write', 'metal_io_block_set', 'shmem_child']}, 'metal_io_phys': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_phys_to_virt': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_virt_to_phys': {'callees': [], 'callers': ['shmem_child']}, 'metal_io_finish': {'callees': [], 'callers': ['shmem_child']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_mutex_t",
    "struct metal_io_region",
    "METAL_BAD_OFFSET",
    "metal_shmem_open",
    "metal_io_virt",
    "metal_io_phys",
    "metal_io_phys_to_virt",
    "metal_io_virt_to_phys",
    "metal_io_finish",
    "metal_log",
    "METAL_LOG_ERROR",
    "atomic_fetch_add",
    "nb_err"
  ],
  "explanation": "For each symbol below we need its declaration/definition to determine whether the target function relies on any compiler/language extensions (GCC/Clang __attribute__, __builtin_*, typeof, statement-expressions, inline asm, compiler-specific keywords or macros, non-standard anonymous/unnamed constructs, etc.). Inspecting the symbol lets the analyzer decide if the symbol itself or its use in this function introduces a language extension.\n\n- metal_mutex_t: typedef/definition may use compiler-specific attributes, bitfields, or nonstandard typedefs; check to ensure no extension is introduced via the type.\n- struct metal_io_region: the struct/type behind io may be defined with compiler extensions (packed/section attributes, inline assembly members, nonstandard anonymous members); need its definition.\n- METAL_BAD_OFFSET: macro/constant may use casts or compiler builtins; inspect for use of extension constructs.\n- metal_shmem_open: function or macro wrapper; its prototype/definition may be a macro using extensions or inline function with attributes or builtins\u2014must check.\n- metal_io_virt: function/macro that converts IO to virtual address; definition could be a macro using typeof/statement-expression or builtins\u2014inspect.\n- metal_io_phys: same rationale as metal_io_virt (may be macro or use builtins/attributes).\n- metal_io_phys_to_virt: conversion helper may be macro/inline with extensions; need its body/signature.\n- metal_io_virt_to_phys: same as above.\n- metal_io_finish: cleanup function/macro; its implementation may hide extensions (attributes, asm, macros).\n- metal_log: logging may be a macro wrapping variadic macros, GCC extensions, or use attributes\u2014need its definition to ensure standard language only.\n- METAL_LOG_ERROR: likely a macro or enum; verify it is not defined using compiler-specific constructs.\n- atomic_fetch_add: could be the C11 stdatomic function or a compiler builtin/macro mapping to __sync/__atomic builtins; must check its declaration/implementation to determine if it relies on compiler extensions.\n- nb_err: the object being updated; its type (e.g., atomic type, macro) may itself be defined using extensions\u2014inspect its declaration.\n\nOnly these symbols are required because they are the external types/macros/functions referenced directly in the target function whose declarations/definitions could introduce language extensions that would violate the MISRA rule."
}