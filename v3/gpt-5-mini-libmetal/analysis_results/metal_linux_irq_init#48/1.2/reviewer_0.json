{
  "user_message": "An agent A claimed that the following metal_linux_irq_init code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_irq_init.\n```c\nint metal_linux_irq_init(void)\n{\n\tint ret;\n\n\tmemset(&irqs, 0, sizeof(irqs));\n\n\tirq_notify_fd = eventfd(0, EFD_CLOEXEC);\n\tif (irq_notify_fd < 0) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"Failed to create eventfd for IRQ handling.\\n\");\n\t\treturn  -EAGAIN;\n\t}\n\n\tmetal_mutex_init(&irq_lock);\n\tirq_handling_stop = false;\n\tret = metal_irq_register_controller(&linux_irq_cntr);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"Linux IRQ controller failed to register.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = pthread_create(&irq_pthread, NULL,\n\t\t\t     metal_linux_irq_handling, NULL);\n\tif (ret != 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create IRQ thread: %d.\\n\",\n\t\t\t  ret);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_log uses GCC/Clang-specific extensions: the statement-expression construct '({ ... })' and the GNU comma-swallowing token paste '##__VA_ARGS__'. Both are compiler extensions (statement expressions and the '##__VA_ARGS__' GCC extension) and therefore violate MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n1755844181 entry: metal_linux_irq_init entered ret=0 fd=-1 stop=0\n1755844181 state: irqs zeroed ret=0 fd=-1 stop=0\n1755844181 after_eventfd: eventfd() returned ret=0 fd=5 stop=0\n1755844181 state: mutex initialized ret=0 fd=5 stop=0\n1755844181 state: irq_handling_stop set to false ret=0 fd=5 stop=0\n1755844181 after_register: metal_irq_register_controller returned ret=0 fd=5 stop=0\n1755844181 after_pthread_create: pthread_create returned ret=0 fd=5 stop=0\n1755844181 exit: metal_linux_irq_init succeeded ret=0 fd=5 stop=0\n1755844182 entry: metal_linux_irq_init entered ret=0 fd=-1 stop=0\n1755844182 state: irqs zeroed ret=0 fd=-1 stop=0\n1755844182 after_eventfd: eventfd() returned ret=0 fd=5 stop=0\n1755844182 state: mutex initialized ret=0 fd=5 stop=0\n1755844182 state: irq_handling_stop set to false ret=0 fd=5 stop=0\n1755844182 after_register: metal_irq_register_controller returned ret=0 fd=5 stop=0\n1755844182 after_pthread_create: pthread_create returned ret=0 fd=5 stop=0\n1755844182 exit: metal_linux_irq_init succeeded ret=0 fd=5 stop=0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_irq_init:\nstatic pthread_t irq_pthread\n...\nstatic void *metal_linux_irq_handling(void *args)\n{\n\tstruct sched_param param;\n\tuint64_t val;\n\tint ret;\n\tint i, j, pfds_total;\n\tstruct pollfd *pfds;\n\n\t(void)args;\n\n\tpfds = (struct pollfd *)malloc(FD_SETSIZE * sizeof(struct pollfd));\n\tif (!pfds) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to allocate irq fds mem.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tparam.sched_priority = sched_get_priority_max(SCHED_FIFO);\n\t/* Ignore the set scheduler error */\n\tret = sched_setscheduler(0, SCHED_FIFO, &param);\n\tif (ret) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s: Failed to set scheduler: %s.\\n\", __func__,\n\t\t\t  strerror(ret));\n\t}\n\n\twhile (1) {\n\t\tmetal_mutex_acquire(&irq_lock);\n\t\tif (irq_handling_stop) {\n\t\t\t/* Killing this IRQ handling thread */\n\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get the fdset */\n\t\tmemset(pfds, 0, MAX_IRQS * sizeof(struct pollfd));\n\t\tpfds[0].fd = irq_notify_fd;\n\t\tpfds[0].events = POLLIN;\n\t\tj = 1;\n\t\tmetal_bitmap_for_each_set_bit(irqs_enabled, i,\n\t\t\t\t\t      linux_irq_cntr.irq_num) {\n\t\t\tpfds[j].fd = i;\n\t\t\tpfds[j].events = POLLIN;\n\t\t\tj++;\n\t\t}\n\t\tmetal_mutex_release(&irq_lock);\n\t\t/* Wait for interrupt */\n\t\tret = poll(pfds, j, -1);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"%s: poll() failed: %s.\\n\",\n\t\t\t\t  __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\t/* Waken up from interrupt */\n\t\tpfds_total = j;\n\t\tfor (i = 0; i < pfds_total; i++) {\n\t\t\tif ((pfds[i].fd == irq_notify_fd) &&\n\t\t\t    (pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\t/* IRQ registration change notification */\n\t\t\t\tif (read(pfds[i].fd,\n\t\t\t\t\t (void *)&val, sizeof(uint64_t)) < 0)\n\t\t\t\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t\t\t\t  \"%s, read irq fd %d failed\\n\",\n\t\t\t\t\t\t  __func__, pfds[i].fd);\n\t\t\t} else if ((pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\tstruct metal_device *dev = NULL;\n\t\t\t\tint irq_handled = 0;\n\t\t\t\tint fd;\n\n\t\t\t\tfd = pfds[i].fd;\n\t\t\t\tdev = irqs_devs[fd];\n\t\t\t\tmetal_mutex_acquire(&irq_lock);\n\t\t\t\tif (metal_irq_handle(&irqs[fd], fd)\n\t\t\t\t    == METAL_IRQ_HANDLED)\n\t\t\t\t\tirq_handled = 1;\n\t\t\t\tif (irq_handled) {\n\t\t\t\t\tif (dev && dev->bus->ops.dev_irq_ack)\n\t\t\t\t\t\tdev->bus->ops.dev_irq_ack(\n\t\t\t\t\t\t\tdev->bus, dev, fd);\n\t\t\t\t}\n\t\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\t} else if (pfds[i].revents) {\n\t\t\t\tmetal_log(METAL_LOG_DEBUG,\n\t\t\t\t\t  \"%s: poll unexpected. fd %d: %d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  pfds[i].fd, pfds[i].revents);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfds);\n\treturn NULL;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nint metal_irq_register_controller(struct metal_irq_controller *cntr)\n{\n\tint irq_base;\n\tstruct metal_list *node;\n\n\tif (cntr == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tif (node == &cntr->node) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Allocate IRQ numbers which are not yet used by any IRQ\n\t * controllers.\n\t */\n\tirq_base = metal_irq_allocate(cntr->irq_base, cntr->irq_num);\n\tif (irq_base == METAL_IRQ_ANY) {\n\t\treturn -EINVAL;\n\t}\n\tcntr->irq_base = irq_base;\n\n\tmetal_list_add_tail(&irq_cntrs, &cntr->node);\n\treturn 0;\n}\n...\nstatic struct metal_irq irqs[MAX_IRQS]\n...\nstatic int irq_notify_fd\n...\nstatic bool irq_handling_stop\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The metal_log macro as defined uses two GCC/Clang language extensions: the statement-expression construct ({ ... }) and the GNU \u2018##__VA_ARGS__\u2019 comma-swallowing token paste. Both are documented compiler extensions and therefore fall under MISRA C 2023 Rule 1.2 (language extensions should not be used). metal_linux_irq_init calls metal_log, so the function indirectly uses those extensions and must be reported as violating Rule 1.2."
}