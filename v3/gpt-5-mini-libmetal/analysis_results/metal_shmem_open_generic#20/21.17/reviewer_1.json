{
  "user_message": "An agent A claimed that the following metal_shmem_open_generic code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open_generic.\n```c\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strcmp(shmem->name, name) can read until a NUL byte from both pointers. Nothing in the shown code guarantees that shmem->name or the caller-supplied name point to NUL-terminated character arrays or that their buffers are large enough. For example, if the caller passes a pointer to a non-terminated buffer (e.g. a 4\u2011byte buffer filled with characters but no '\\0'), or if shmem->name points to a fixed-length char array that was not NUL-terminated, strcmp will read past the object bounds and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc523a2e20)\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc51ba1e20)\nEXIT: not found, returning -ENOENT\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc52ba3e20)\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc533a4e20)\nEXIT: not found, returning -ENOENT\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc543a6e20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc53ba5e20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc33ffee20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc511a0e20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc2bffee20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x55e8daf90198, size=1048576, result=0x7fcc337fde20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecfdffae20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecfeffce20)\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecfe7fbe20)\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecff7fde20)\nEXIT: not found, returning -ENOENT\nEXIT: not found, returning -ENOENT\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fed04fe0e20)\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecfd7f9e20)\nEXIT: not found, returning -ENOENT\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecffffee20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecfcff8e20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecdfffee20)\nEXIT: not found, returning -ENOENT\nENTER: metal_shmem_open_generic(name=0x563ab34d9198, size=1048576, result=0x7fecdf7fde20)\nEXIT: not found, returning -ENOENT\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open_generic:\nstruct metal_generic_shmem {\n\tconst char\t\t*name;\n\tstruct metal_io_region\tio;\n\tstruct metal_list\tnode;\n}\n...\nstruct metal_list {\n\tstruct metal_list *next, *prev;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 21.17 requires that uses of the <string.h> functions must not be able to read beyond the bounds of the referenced objects. In the posted code strcmp(shmem->name, name) is called but neither shmem->name nor the caller-supplied name parameter are validated or constrained in this function: they are plain const char * pointers and there is no guarantee shown that the objects they point to are NUL-terminated or large enough to contain a terminating '\\0'. Therefore strcmp could read past the end of one or both objects and so the use can result in out-of-bounds accesses. That is a violation of Rule 21.17 unless there is an external, provable API contract (or other code invariants) that guarantee both pointers always reference NUL-terminated arrays; no such guarantee is present in the provided code. Recommendation: either document/ensure the API contract that names are NUL-terminated, or change the implementation to use bounded comparisons (e.g. compare lengths or use strncmp with a known maximum length or store lengths and use memcmp) to avoid unbounded reads."
}