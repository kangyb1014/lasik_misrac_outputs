{
  "user_message": "An agent A claimed that the following metal_generic_dev_dma_map code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_generic_dev_dma_map.\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) without verifying that sg_in and sg_out actually reference at least nents_in elements (and without checking nents_in for non\u2011negativity). If the caller provides sg_out with capacity < nents_in elements (or sg_in contains fewer than nents_in elements), memcpy will write/read past the object bounds. Also a negative nents_in would convert to a very large size_t and likewise cause out\u2011of\u2011bounds access. Therefore the code can violate Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call memcpy(sg_out, sg_in, nents_in * sizeof(struct metal_sg)) (and the subsequent indexed accesses sg_out[i]) can read/write beyond the bounds of the objects if the caller supplies sg_in or sg_out that contain fewer than nents_in elements, or if nents_in is negative (it is promoted to size_t when multiplied by sizeof, producing a very large size). The function performs no validation of nents_in (non\u2011negativity) nor any capacity checks on the buffers, so there is a real potential for out\u2011of\u2011bounds accesses, which violates MISRA C 2023 Rule 21.17. To be compliant the code must ensure/validate that both pointers reference at least nents_in elements (and handle negative nents_in) or otherwise enforce/document and statically guarantee the preconditions."
}