{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg (definition)",
    "memcpy (declaration from <string.h>)",
    "callers / allocators that create or pass sg_in and sg_out (their code/prototypes and any size-related macros/constants)",
    "contract/validation for nents_in (allowed range, and any runtime checks or annotations)",
    "size/type limits: SIZE_MAX and INT_MAX (or platform integer/size_t widths)",
    "caller documentation/annotations about overlap allowance between sg_in and sg_out (aliasing policy)"
  ],
  "explanation": "1) struct metal_sg (definition)\n   - Required to know the actual size (sizeof(struct metal_sg)) used in the memcpy length computation and to understand fields (e.g. virt, len). The exact size and layout determine the byte count copied and whether the multiplication by nents_in is correct.\n\n2) memcpy (declaration from <string.h>)\n   - To confirm parameter types and the standard semantics (no handling of overlapping regions). This is needed to check whether memcpy is used safely (vs memmove) when sg_in and sg_out might overlap.\n\n3) callers / allocators that create or pass sg_in and sg_out (their code/prototypes and any size-related macros/constants)\n   - To determine the actual allocated sizes (in elements or bytes) of the objects pointed to by sg_in and sg_out. The MISRA rule requires proving the memcpy length does not access beyond the destination (sg_out); only the allocation sites or calling contexts can show that sg_out has at least nents_in elements.\n\n4) contract/validation for nents_in (allowed range, and any runtime checks or annotations)\n   - Needed to ensure nents_in is non-negative and within bounds so that the multiplication nents_in * sizeof(struct metal_sg) does not request more bytes than the destination. If the API guarantees a maximum or validates nents_in, that influences safety.\n\n5) size/type limits: SIZE_MAX and INT_MAX (or platform integer/size_t widths)\n   - To analyze potential integer overflow in nents_in * sizeof(struct metal_sg). Widths/limits are required to reason if the multiplication can wrap and cause a smaller memcpy length than intended, leading to out-of-bounds access.\n\n6) caller documentation/annotations about overlap allowance between sg_in and sg_out (aliasing policy)\n   - memcpy has undefined behaviour for overlapping source/destination. To determine rule conformance we must know whether callers may provide overlapping buffers; if overlap is permitted, memcpy would be inappropriate and could violate safety requirements.\n\nNote: metal_cache_flush/metal_cache_invalidate and METAL_DMA_DEV_W are irrelevant to the <string.h> bounds rule for memcpy, except insofar as any caller behavior that affects buffer sizes/aliasing could be discovered in caller code. For a complete MISRA analysis you must review the caller/allocation sites and any API contracts that bound nents_in and buffer sizes."
}