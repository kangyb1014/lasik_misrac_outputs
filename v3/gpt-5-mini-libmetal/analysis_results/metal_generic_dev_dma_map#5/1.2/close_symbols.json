{
  "user_message": "Target function code is:\n```c\nint metal_generic_dev_dma_map(struct metal_bus *bus,\n\t\t\t     struct metal_device *device,\n\t\t\t     uint32_t dir,\n\t\t\t     struct metal_sg *sg_in,\n\t\t\t     int nents_in,\n\t\t\t     struct metal_sg *sg_out)\n{\n\tint i;\n\t(void)bus;\n\t(void)device;\n\n\tif (sg_out != sg_in)\n\t\tmemcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));\n\tfor (i = 0; i < nents_in; i++) {\n\t\tif (dir == METAL_DMA_DEV_W) {\n\t\t\tmetal_cache_flush(sg_out[i].virt, sg_out[i].len);\n\t\t}\n\t\tmetal_cache_invalidate(sg_out[i].virt, sg_out[i].len);\n\t}\n\n\treturn nents_in;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_generic_dev_dma_map': {'callees': ['metal_cache_flush', 'metal_cache_invalidate'], 'callers': []}, 'metal_cache_flush': {'callees': [], 'callers': ['metal_generic_dev_dma_map']}, 'metal_cache_invalidate': {'callees': [], 'callers': ['metal_generic_dev_dma_map', 'metal_generic_dev_dma_unmap']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_sg (definition)",
    "struct metal_bus (definition)",
    "struct metal_device (definition)",
    "METAL_DMA_DEV_W (macro or enum definition)",
    "metal_cache_flush (prototype/implementation)",
    "metal_cache_invalidate (prototype/implementation)",
    "memcpy (declaration / macro in <string.h> or project header)",
    "uint32_t typedef (from <stdint.h> or project typedef)"
  ],
  "explanation": "To determine whether this function or its use of other identifiers relies on compiler language extensions, the next analyst must inspect the definitions/declarations that could hide extensions or non\u2011standard constructs. Specifically:\n\n- struct metal_sg (definition): the struct layout could include flexible/zero\u2011length arrays, unnamed bitfields, or GCC/Clang attributes (e.g. __attribute__((packed)), __attribute__((aligned)), or extensions) that would violate the MISRA rule if used. Also the fields (virt, len) must be standard types.\n\n- struct metal_bus (definition) and struct metal_device (definition): even though they are not referenced beyond being cast to void here, their definitions could contain non\u2011standard attributes, compiler keywords or extensions that affect whether including or referencing them violates the rule.\n\n- METAL_DMA_DEV_W (macro or enum definition): the macro/constant could be defined using compiler extensions (e.g. statement expressions, builtin intrinsics, or non\u2011standard tokens). Inspecting its definition ensures it is a plain constant/enum as required.\n\n- metal_cache_flush and metal_cache_invalidate (prototypes/implementations): these functions are called from the target; their declarations or implementations might use compiler extensions (inline asm, __attribute__ markers, builtin functions, non\u2011standard calling conventions, or GCC/Clang keywords). The function bodies may also contain extensions that affect correctness of the call site analysis.\n\n- memcpy (declaration / macro in <string.h> or project header): memcpy may be a macro alias to a compiler builtin or wrapper that uses extensions (intrinsics, asm, builtins). Verify the visible declaration to detect any non\u2011standard extension usage.\n\n- uint32_t typedef (from <stdint.h> or project typedef): ensure this integer type is a standard typedef and not a compiler\u2011specific extension type or defined via compiler extension.\n\nInspecting these symbols (their headers/definitions) is sufficient to detect any language/compiler extensions used directly by the target function or hidden in the types/macros/ callees it relies on."
}