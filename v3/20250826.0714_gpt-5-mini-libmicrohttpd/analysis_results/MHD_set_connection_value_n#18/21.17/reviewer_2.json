{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. If key is non-NULL but not NUL-terminated within the accessible object bounds, calling strlen(key) may scan past the end of the object. Example: key points to a buffer of length key_size==3 containing {'a','b','c'} (no '\\0'); strlen(key) will read beyond those 3 bytes and thus access out-of-bounds. This violates MISRA C 2023 Rule 21.17. (Use strnlen(key, key_size) or memchr to ensure termination within key_size.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls strlen(key) (and strlen(value)) when key (or value) is non-NULL without any guarantee that the pointed-to object is NUL-terminated within its accessible bounds. If the buffer contains no NUL within its accessible extent (for example a buffer of length key_size == 3 containing {'a','b','c'}), strlen will scan past the end of the object and may access memory out-of-bounds. That is exactly the situation MISRA C 2023 Rule 21.17 forbids (use of <string.h> functions that can access beyond object bounds).\n\nTo fix this you must either a) establish and document an API precondition that when non-NULL the pointers are valid NUL-terminated C strings (so strlen is safe), or b) replace the unbounded strlen calls with bounded checks (for example use strnlen or memchr to search for '\\0' within the known maximum length or otherwise use explicit length-based logic) so no scan can read beyond the accessible object. Without such a guarantee the reported violation is valid."
}