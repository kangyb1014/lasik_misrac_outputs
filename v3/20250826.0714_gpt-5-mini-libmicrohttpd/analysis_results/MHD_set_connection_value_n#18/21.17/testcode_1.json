{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf value is non-NULL but not NUL-terminated within its allocated/object bounds (e.g. a binary buffer of length value_size with no terminating '\\0'), the call to strlen(value) will read past the end of that object searching for a NUL, potentially accessing memory beyond the object. For example: char buf[3] = {'a','b','c'}; value = buf; value_size = 3; strlen(value) will read out of bounds. This violates the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_set_connection_value_n code that contains useful probe functions that print useful logs to a file \"/tmp/logs/189.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_set_connection_value_n as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_set_connection_value_n:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\nPlease provide the modified MHD_set_connection_value_n code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n\n/* Probe/log helper: writes details to /tmp/logs/189.txt. */\nstatic void mhd_probe_log(const char *stage,\n                          const void *connection,\n                          int kind,\n                          const char *key,\n                          size_t key_size,\n                          const char *value,\n                          size_t value_size)\n{\n    FILE *f = fopen(\"/tmp/logs/189.txt\", \"a\");\n    if (!f) {\n        /* try to create parent directory and reopen */\n        (void)mkdir(\"/tmp/logs\", 0700);\n        f = fopen(\"/tmp/logs/189.txt\", \"a\");\n    }\n    if (!f) {\n        return; /* best-effort logging only */\n    }\n\n    /* Safe checks: do not call strlen on possibly unterminated buffers. Use memchr\n       to check for a NUL within the given size. This avoids reading beyond the\n       provided object bounds when probing. */\n    int key_has_nul = 0;\n    int value_has_nul = 0;\n    if (key && key_size > 0) {\n        key_has_nul = (memchr(key, '\\0', key_size) != NULL) ? 1 : 0;\n    } else if (key && key_size == 0) {\n        /* empty size: treat as no NUL within size */\n        key_has_nul = 0;\n    }\n    if (value && value_size > 0) {\n        value_has_nul = (memchr(value, '\\0', value_size) != NULL) ? 1 : 0;\n    } else if (value && value_size == 0) {\n        value_has_nul = 0;\n    }\n\n    fprintf(f, \"[%s] MHD_set_connection_value_n enter/step:\\n\", stage);\n    fprintf(f, \"  connection=%p kind=%d key=%p key_size=%zu value=%p value_size=%zu\\n\",\n            connection, kind, (const void*)key, key_size, (const void*)value, value_size);\n    fprintf(f, \"  probe: key_has_nul_within_key_size=%d value_has_nul_within_value_size=%d\\n\",\n            key_has_nul, value_has_nul);\n\n    if (key) {\n        /* Log a short prefix of key safely (up to key_size or 64 bytes) without\n           assuming NUL termination. */\n        size_t tolog = key_size;\n        if (tolog > 64) tolog = 64;\n        fprintf(f, \"  key_bytes(%zu): \", tolog);\n        for (size_t i = 0; i < tolog; ++i) {\n            unsigned char c = (unsigned char)key[i];\n            fprintf(f, \"%02x\", c);\n            if (i + 1 < tolog) fprintf(f, \" \");\n        }\n        fprintf(f, \"\\n\");\n    }\n    if (value) {\n        size_t tolog = value_size;\n        if (tolog > 64) tolog = 64;\n        fprintf(f, \"  value_bytes(%zu): \", tolog);\n        for (size_t i = 0; i < tolog; ++i) {\n            unsigned char c = (unsigned char)value[i];\n            fprintf(f, \"%02x\", c);\n            if (i + 1 < tolog) fprintf(f, \" \");\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fprintf(f, \"  NOTE: The original code will call strlen(key) and strlen(value) as part of its checks.\\n\");\n    fprintf(f, \"  If value is non-NULL and not NUL-terminated within value_size, calling strlen(value) will read past the object bounds.\\n\");\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  /* Log initial state before performing the original checks. This probe uses\n     memchr to determine whether a terminating NUL exists within the provided\n     sizes, so it does not itself read beyond the bounds of the provided\n     objects. */\n  mhd_probe_log(\"pre-check\", connection, (int)kind, key, key_size, value, value_size);\n\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n  {\n    /* Log that we are about to return MHD_NO due to the check failing. Do not\n       attempt to re-evaluate strlen here; that would duplicate the unsafe\n       access the original code performs. */\n    mhd_probe_log(\"pre-return-MHD_NO\", connection, (int)kind, key, key_size, value, value_size);\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  /* Log continuation when the checks pass. */\n  mhd_probe_log(\"post-check-pass\", connection, (int)kind, key, key_size, value, value_size);\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n"
}