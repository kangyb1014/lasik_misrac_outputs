{
  "user_message": "An agent A claimed that the following is_param_equal code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal.\n```c\n_MHD_static_inline bool\nis_param_equal (const struct MHD_RqDAuthParam *param,\n                const char *const str,\n                const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression param->value.str is passed as a read-only string to an equality routine. If the struct member value.str is declared as a plain char * (not const char *), then the code is violating MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type when it is only used for read access. Note: having the parameter declared as const struct MHD_RqDAuthParam * does not make the pointee type of the member const; the correct fix is to declare the member as const char * (or otherwise const-qualify the pointed-to type). If value.str is already declared const char *, there is no violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's assessment is correct. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever they are only used for read access. In the snippet param is a pointer to const struct, but that does not change the declared type of the member value.str. If value.str is declared as plain char * (not const char *), then the code is using that pointer only for reading (passed to memcmp and an equality routine) and therefore violates the intent of Rule 8.13. If, however, value.str is already declared as const char * (or another const-qualified pointer type), there is no violation. Note also that although passing a char * to a function expecting const char * is allowed by the language, it does not satisfy the MISRA preference for the pointer\u2019s own type to be const-qualified when appropriate. The appropriate fix is to const-qualify the member (e.g., const char *value.str) where feasible."
}