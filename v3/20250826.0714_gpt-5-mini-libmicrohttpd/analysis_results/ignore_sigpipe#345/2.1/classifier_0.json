{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of ignore_sigpipe:\n```c\nstatic void\nignore_sigpipe (void)\n{\n  struct sigaction oldsig;\n  struct sigaction sig;\n\n  sig.sa_handler = &catcher;\n  sigemptyset (&sig.sa_mask);\n#ifdef SA_INTERRUPT\n  sig.sa_flags = SA_INTERRUPT;  /* SunOS */\n#else\n  sig.sa_flags = SA_RESTART;\n#endif\n  if (0 != sigaction (SIGPIPE, &sig, &oldsig))\n    fprintf (stderr,\n             \"Failed to install SIGPIPE handler: %s\\n\", strerror (errno));\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#ifdef SA_INTERRUPT\n  sig.sa_flags = SA_INTERRUPT;  /* SunOS */\n#else\n  sig.sa_flags = SA_RESTART;\n#endif\n\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The #ifdef/#else is a preprocessing choice: only one assignment to sig.sa_flags appears in the compiled translation unit, so there is no unreachable runtime code introduced by this fragment. (If instead both branches were present in the compiled code but one could never be executed \u2014 e.g. a constant false if (0) branch \u2014 that would be a violation.)"
}