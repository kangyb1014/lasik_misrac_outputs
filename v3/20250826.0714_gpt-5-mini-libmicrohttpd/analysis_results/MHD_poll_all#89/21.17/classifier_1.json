{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_poll_all:\n```c\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nurh_to_pollfd (urh, &(p[poll_server + i]));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No \u2014 this call does not itself violate MISRA C 2023 Rule 21.17. p is allocated with (2 + num_connections) entries and num_connections was computed to include two entries per urh (num_connections += 2 in the counting phase). The code fills the array so that i (the index offset) ranges within 0..num_connections-1 and the extra 2 accounts for possible listen/ITC slots (poll_server \u2264 2). Therefore passing &p[poll_server + i] to urh_to_pollfd() is within the allocated bounds. A violation would only occur if num_connections were miscomputed or the connection/urh lists changed between the counting and filling phases (i.e. a concurrency/modification bug), but under the intended single-threaded/controlled access assumptions in this code path no out-of-bounds access should occur."
}