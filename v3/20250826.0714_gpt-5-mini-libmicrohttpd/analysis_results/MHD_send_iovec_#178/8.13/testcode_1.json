{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: r_iov is declared as 'struct MHD_iovec_track_ *const r_iov' (pointer to mutable object). The call send_iov_nontls(connection, r_iov, push_data) will violate MISRA C 2023 Rule 8.13 if send_iov_nontls's parameter is a non-const pointer but the function does not need to modify the pointed-to MHD_iovec_track_ object. In that case the parameter and the argument should be of type 'const struct MHD_iovec_track_ *' (or the function prototype should accept a pointer-to-const) and the present call/definition would violate the rule. The code as given cannot be determined to definitely violate the rule without the prototype/implementation of send_iov_nontls; the above describes the specific violation scenario.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_send_iovec_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1783.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_send_iovec_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_send_iovec_:\n```c\nssize_t\nMHD_send_iovec_ (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  bool use_iov_send = true;\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert (NULL != connection->rp.resp_iov.iov);\n  mhd_assert (NULL != connection->rp.response->data_iov);\n  mhd_assert (connection->rp.resp_iov.cnt > connection->rp.resp_iov.sent);\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n#ifdef HTTPS_SUPPORT\n  use_iov_send = use_iov_send &&\n                 (0 == (connection->daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT */\n#ifdef _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED\n  use_iov_send = use_iov_send && (connection->daemon->sigpipe_blocked ||\n                                  connection->sk_spipe_suppress);\n#endif /* _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  if (use_iov_send)\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  return send_iov_nontls (connection, r_iov, push_data);\n#endif /* MHD_VECT_SEND */\n\n#if ! defined(MHD_VECT_SEND) || defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  return send_iov_emu (connection, r_iov, push_data);\n#endif /* !MHD_VECT_SEND || HTTPS_SUPPORT\n          || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n}\n```\n</target_code>\nPlease provide the modified MHD_send_iovec_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n/* Probe function: append logs to /tmp/logs/1783.txt. Keep signature generic to avoid\n   needing internal struct definitions; log pointer values and key flags. */\nstatic void mhd_log_probe(const char *msg,\n                          const void *connection,\n                          const void *r_iov,\n                          int push_data,\n                          int use_iov_send)\n{\n    FILE *f = fopen(\"/tmp/logs/1783.txt\", \"a\");\n    if (NULL == f)\n        return;\n    if (use_iov_send >= 0)\n    {\n        fprintf(f, \"%s: connection=%p, r_iov=%p, push_data=%d, use_iov_send=%d\\n\",\n                msg, connection, r_iov, push_data, use_iov_send);\n    }\n    else\n    {\n        fprintf(f, \"%s: connection=%p, r_iov=%p, push_data=%d\\n\",\n                msg, connection, r_iov, push_data);\n    }\n    fclose(f);\n}\n\nssize_t\nMHD_send_iovec_ (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  bool use_iov_send = true;\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n#endif /* MHD_VECT_SEND */\n\n  /* Log entry with basic state: pointers and push flag. use_iov_send is unknown at this\n     point, so pass -1. */\n  mhd_log_probe(\"MHD_send_iovec_ entry\", (const void *)connection,\n                (const void *)r_iov, (int)push_data, -1);\n\n  mhd_assert (NULL != connection->rp.resp_iov.iov);\n  mhd_assert (NULL != connection->rp.response->data_iov);\n  mhd_assert (connection->rp.resp_iov.cnt > connection->rp.resp_iov.sent);\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n#ifdef HTTPS_SUPPORT\n  use_iov_send = use_iov_send &&\n                 (0 == (connection->daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT */\n#ifdef _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED\n  use_iov_send = use_iov_send && (connection->daemon->sigpipe_blocked ||\n                                  connection->sk_spipe_suppress);\n#endif /* _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  /* Log the computed decision for use_iov_send along with pointers */\n  mhd_log_probe(\"MHD_send_iovec_ computed use_iov_send\",\n                (const void *)connection, (const void *)r_iov,\n                (int)push_data, (use_iov_send ? 1 : 0));\n  if (use_iov_send)\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  {\n      /* Log the actual call about to be made so callers can trace whether the\n         non-TLS vector send path (potential violation scenario) is taken. */\n      mhd_log_probe(\"MHD_send_iovec_ calling send_iov_nontls\",\n                    (const void *)connection, (const void *)r_iov,\n                    (int)push_data, (use_iov_send ? 1 : 0));\n      return send_iov_nontls (connection, r_iov, push_data);\n  }\n#endif /* MHD_VECT_SEND */\n\n#if ! defined(MHD_VECT_SEND) || defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  /* Log that the emulated path will be taken. */\n  mhd_log_probe(\"MHD_send_iovec_ calling send_iov_emu\",\n                (const void *)connection, (const void *)r_iov,\n                (int)push_data, -1);\n  return send_iov_emu (connection, r_iov, push_data);\n#endif /* !MHD_VECT_SEND || HTTPS_SUPPORT\n          || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n}\n"
}