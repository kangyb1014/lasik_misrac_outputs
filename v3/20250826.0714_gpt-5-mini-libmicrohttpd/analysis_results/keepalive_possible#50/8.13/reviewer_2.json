{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe string literal \"Keep-Alive\" is passed to MHD_lookup_header_s_token_ci. If that function's prototype declares the corresponding parameter as a non-const pointer (e.g. char *token), this is a MISRA C 2023 Rule 8.13 violation because a pointer should point to a const-qualified type whenever possible. The correct form would be to declare the parameter as const char * (or otherwise ensure the pointer-to-const is used) so that string literals, which must not be modified, are passed to a const-qualified pointer.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[keepalive] ENTER: connection=0x55875f880df0\n[keepalive] initial: conn=0x55875f880df0, resp=0x55875f8890c0, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x55875f880df0, resp=0x55875f8890c0, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x55875f889a80\n[keepalive] initial: conn=0x55875f889a80, resp=0x55875f889cd0, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x55875f889a80, resp=0x55875f889cd0, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x55875f881090\n[keepalive] initial: conn=0x55875f881090, resp=0x55875f88a290, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x55875f881090, resp=0x55875f88a290, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x7f7160000b90\n[keepalive] initial: conn=0x7f7160000b90, resp=0x7f7158000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x7f7160000b90, resp=0x7f7158000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x7f7160000b90\n[keepalive] initial: conn=0x7f7160000b90, resp=0x7f7158000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x7f7160000b90, resp=0x7f7158000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x7f7160000b90\n[keepalive] initial: conn=0x7f7160000b90, resp=0x7f715c000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x7f7160000b90, resp=0x7f715c000b90, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x7f7160000b90\n[keepalive] initial: conn=0x7f7160000b90, resp=0x7f7160008f40, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade: conn=0x7f7160000b90, resp=0x7f7160008f40, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] ENTER: connection=0x7f7160000b90\n[keepalive] initial: conn=0x7f7160000b90, resp=0x7f7160008f40, keepalive=0, read_closed=0, discard_request=1, stop_with_error=0, rq.http_ver=3, r->flags=0x0, r->flags_auto=0x1, r->upgrade_handler=0x55872f788af0\n[keepalive] upgrade handler present: returning MHD_CONN_MUST_UPGRADE\n[keepalive] upgrade\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is about pointer declarations: a pointer should point to a const-qualified type whenever possible. The snippet you provided only shows calls that pass the string literal \"Keep-Alive\" to MHD_lookup_header_s_token_ci; it does not show the declaration/prototype of MHD_lookup_header_s_token_ci. Whether there is a Rule 8.13 violation depends on that prototype, not on the call site. If the prototype declares the parameter as a non-const pointer (e.g. char *token) while the function does not (and need not) modify the pointed string, then that declaration would violate 8.13 and should be changed to const char *token. However, the code shown here does not itself prove a violation, because in C the string literal decays to a char *-typed pointer (array-to-pointer) and the issue is the callee's parameter declaration. In short: the agent's claim can be correct if and only if the function's parameter is declared as a non-const pointer; but no such prototype is provided, so you cannot conclude there is a definitive MISRA 8.13 violation from the snippet alone. Recommended action: inspect the declaration of MHD_lookup_header_s_token_ci and, if it is char * (and the function does not modify the data), change it to const char * to satisfy Rule 8.13."
}