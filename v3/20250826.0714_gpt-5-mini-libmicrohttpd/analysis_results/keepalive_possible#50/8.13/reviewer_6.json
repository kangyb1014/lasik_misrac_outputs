{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the function MHD_lookup_header_s_token_ci has a non-const parameter for the token (e.g. prototype uses 'char *token'), then this call is a violation: a string literal \"close\" is being passed to a non-const pointer. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible, so the function parameter should be declared as 'const char *' (and likewise the connection parameter should be 'const struct MHD_Connection *' if the function only reads it).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nkeepalive_possible: entry connection=0x556ee8b0bdf0 c=0x556ee8b0bdf0 r=0x556ee8b140c0\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x556ee8b14a80 c=0x556ee8b14a80 r=0x556ee8b14cd0\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x556ee8b0c090 c=0x556ee8b0c090 r=0x556ee8b15290\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb94000b90\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb98000b90\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb98000b90\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f60\nstate: c->keepalive=0 c->rq.http_ver=3 c->read_closed=0 c->discard_request=1 c->stop_with_error=0\nresponse: r->flags=0x00000000 r->flags_auto=0x00000001 r->upgrade_handler=0x556ec0435af0\ndecision: MUST_UPGRADE because r->upgrade_handler != NULL\nkeepalive_possible: entry connection=0x7fbb9c000b90 c=0x7fbb9c000b90 r=0x7fbb9c008f40\nstate: c->keepalive=0 c->rq.http_ver=3\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 concerns pointer declarations: pointers should point to const-qualified types whenever possible. Agent A's scenario is correct in spirit. If MHD_lookup_header_s_token_ci is declared with a non-const parameter such as 'char *token', that declaration violates Rule 8.13 because the function only reads the token and therefore the parameter should be declared 'const char *token'. Passing a string literal like \"close\" or \"Keep-Alive\" to a non-const parameter is symptomatic of that violation (the real violation is the non-const parameter declaration).\n\nAlso in the shown function keepalive_possible the incoming parameter is declared as 'struct MHD_Connection *connection' but the function only reads from the pointed-to object; therefore the parameter and the local aliases (c and r) could/should be declared to point to const-qualified types (e.g. 'const struct MHD_Connection *connection' and 'const struct MHD_Connection *const c', and similarly for r). Those non-const pointer declarations are also non-compliant with Rule 8.13 if indeed the pointed-to objects are not modified.\n\nOne caveat: the rule applies to the declarations themselves. Without seeing the prototype of MHD_lookup_header_s_token_ci and usages of keepalive_possible elsewhere, I cannot prove an actual violation in the codebase from the single translation unit excerpt alone; however, given the scenario (the lookup function has a non-const token parameter) the agent's report that Rule 8.13 is violated is correct."
}