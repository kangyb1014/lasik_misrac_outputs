{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'connection' (and the local alias 'c') is declared as a pointer to a mutable struct: 'struct MHD_Connection *connection' and 'struct MHD_Connection *const c = connection;'. In the shown fragment the code only reads fields (e.g. c->rq.http_ver via MHD_IS_HTTP_VER_SUPPORTED) and does not modify the pointed-to object, so the pointer could and should be const-qualified \u2014 e.g. 'const struct MHD_Connection *connection' or at least 'const struct MHD_Connection *const c'. Therefore this use violates MISRA C 2023 Rule 8.13. (If other calls in the function or API require a non-const pointer, that may justify the current signature, but based solely on the fragment the pointer should be const.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=upgrade_must_upgrade decision=2 keepalive=0 read_closed=0 discard_request=1 stop_with_error=0 rq_http_ver=3 r_flags=0x0 r_flags_auto=0x1 r_upgrade_handler=0x55bcec722af0\nKEEPALIVE_LOG point=entry decision=-1 keepalive=0 read_closed=0 discar\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a MISRA 8.13 violation. Rule 8.13 requires that a pointer should point to a const-qualified type wherever that is possible (i.e. the pointed-to object is not modified and the pointer is not passed to callees that require a non\u2011const target). In the shown fragment the function does only read fields from *connection, and the local alias c is declared as a const pointer (pointer value cannot change) but the pointee is not const-qualified. However, the function calls other routines (e.g. MHD_lookup_header_s_token_ci and any macros used) and those prototypes may require a non-const struct MHD_Connection * (or may modify the object). Declaring the parameter as const struct MHD_Connection *connection would be incorrect if any called function expects a mutable pointer (because you cannot pass const T * to a function taking T * without a cast). Therefore you cannot decide a violation from this fragment alone \u2014 you must inspect all callees and the whole translation unit to determine whether the pointee could be const. Given only the excerpt, the agent A\u2019s claim is not demonstrably correct."
}