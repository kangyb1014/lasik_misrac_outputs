{
  "user_message": "An agent A claimed that the following MHD_create_response_from_buffer code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_response_from_buffer.\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer (size_t size,\n                                 void *buffer,\n                                 enum MHD_ResponseMemoryMode mode)\n{\n  if (MHD_RESPMEM_MUST_FREE == mode)\n    return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                   buffer,\n                                                                   &free,\n                                                                   buffer);\n  if (MHD_RESPMEM_MUST_COPY == mode)\n    return MHD_create_response_from_buffer_copy (size,\n                                                 buffer);\n\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function MHD_create_response_from_buffer has its parameter declared as void *buffer but the code path for MHD_RESPMEM_MUST_COPY simply passes that pointer to MHD_create_response_from_buffer_copy which only needs to read (copy) the data. The pointer should therefore be const-qualified (const void *buffer) in the API and the variable here should be const-qualified. As written, a non-const pointer is used where a const-qualified pointer would suffice, violating MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s report is not correct. MISRA C 2023 Rule 8.13 recommends qualifying pointer targets as const when the pointed-to object is not modified. In this API the buffer parameter is used in multiple modes: for MHD_RESPMEM_MUST_FREE the library takes ownership and will pass the pointer to free (which has signature void free(void *)), so the buffer must be a non-const pointer to allow deallocation without casting away const. Because at least one supported code path requires a non-const pointer (ownership transfer / free), it is not possible to make the parameter const-qualified for the whole function without breaking that mode or inserting casts. Thus the function\u2019s non-const void *buffer is justified and does not violate Rule 8.13. If a const-taking variant is desired for read-only copy-only usage, the library already provides separate copy APIs (or could provide a const-taking wrapper), but that does not make the current API non-conforming."
}