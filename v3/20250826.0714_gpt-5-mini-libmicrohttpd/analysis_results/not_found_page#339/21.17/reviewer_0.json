{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strlen(NOT_FOUND_ERROR) can read bytes until a NUL is found. If NOT_FOUND_ERROR is not guaranteed to be a null\u2011terminated C string (for example if it is a pointer to a buffer that may lack a terminating '\\0' or a fixed char array initialized without a terminator), strlen may access memory beyond the object bounds, violating Rule 21.17. (To avoid this, ensure NOT_FOUND_ERROR is a null\u2011terminated string literal/array or use an explicit known length such as sizeof NOT_FOUND_ERROR - 1 when applicable.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not conclusively correct for the code as shown. strlen() does indeed scan until a '\\0' and therefore will access bytes beyond the object if and only if NOT_FOUND_ERROR is not a properly null\u2011terminated C string. MISRA C 2023 Rule 21.17 requires that uses of <string.h> functions must not permit accesses beyond object bounds \u2014 so the pattern strlen(NOT_FOUND_ERROR) would violate the rule only if NOT_FOUND_ERROR might lack a terminating NUL or otherwise be an object whose bounds do not include a terminating NUL.\n\nBecause the snippet does not show the definition of NOT_FOUND_ERROR, you cannot determine from this fragment alone that a violation occurs. If NOT_FOUND_ERROR is a string literal or a char array guaranteed to be NUL\u2011terminated (e.g. \"...\" or const char s[] = \"...\"), the call is safe and does not violate Rule 21.17. If NOT_FOUND_ERROR can be a non\u2011terminated buffer or a pointer to memory without a terminating NUL, then Agent A\u2019s concern is valid and the code would violate the rule.\n\nRecommendation: ensure NOT_FOUND_ERROR is a null\u2011terminated string (prefer a string literal or const char[] initialized with a literal), or use an explicit known length (e.g. sizeof NOT_FOUND_ERROR - 1 for an array initialized from a literal or maintain and pass an explicit length) so that strlen is not required to scan past the object bounds."
}