{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code only checks that (value_end - last_escape) is smaller than sizeof(pp->xbuf) before copying, but it does not ensure that the source range [last_escape, value_end) lies within an object large enough to read that many bytes. If last_escape points into a small buffer (e.g. a 2-byte buffer containing \"%\") but value_end points 10 bytes after it (difference 10 < sizeof(pp->xbuf)), memcpy(pp->xbuf, last_escape, 10) will read beyond the bounds of the source object. Additionally, the safety assertions (mhd_assert) may be disabled in production builds, so the runtime check present is insufficient to guarantee absence of out\u2011of\u2011bounds reads. Therefore Rule 21.17 can be violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2359.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_value as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_value:\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\nPlease provide the modified process_value code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Probe logging helper: append human-readable logs to /tmp/logs/2359.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2359.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Helper to dump a small portion of a buffer as hex (safe to call only with\n   a pointer to a valid buffer of at least 'len' bytes). */\nstatic void probe_hexdump(const char *label, const unsigned char *buf, size_t len)\n{\n    size_t i, m = (len > 32) ? 32 : len;\n    if (m == 0)\n    {\n        probe_log(\"%s: <empty>\", label);\n        return;\n    }\n    /* build a small hex string */\n    char out[3 * 32 + 1];\n    size_t pos = 0;\n    for (i = 0; i < m; ++i)\n    {\n        int written = snprintf(out + pos, sizeof(out) - pos, \"%02x\", buf[i]);\n        if (written < 0)\n            break;\n        pos += (size_t) written;\n        if (i + 1 < m && pos + 1 < sizeof(out))\n            out[pos++] = ' ';\n    }\n    out[pos] = '\\0';\n    probe_log(\"%s (first %zu bytes): %s\", label, m, out);\n}\n\n/* The original function with inserted logging probes. The logic is preserved. */\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n\n  /* Log entry and initial state */\n  probe_log(\"process_value ENTRY: pp=%p, value_start=%p, value_end=%p, last_escape=%p, pp->xbuf_pos=%zu, pp->value_offset=%zu\",\n            (void *)pp, (const void *)value_start, (const void *)value_end, (const void *)last_escape,\n            pp ? pp->xbuf_pos : (size_t)0, pp ? pp->value_offset : (size_t)0);\n\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n  {\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n    probe_hexdump(\"copied pp->xbuf into local xbuf\", (const unsigned char *)xbuf, pp->xbuf_pos);\n  }\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    /* Log decision about last_escape handling */\n    size_t len = (size_t) (value_end - last_escape);\n    probe_log(\"last_escape branch: last_escape=%p value_end=%p len=%zu sizeof(pp->xbuf)=%zu\",\n              (const void *)last_escape, (const void *)value_end, len, sizeof(pp->xbuf));\n\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    probe_log(\"pp->xbuf_pos set to %zu before memcpy from last_escape\", pp->xbuf_pos);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    probe_hexdump(\"copied last_escape -> pp->xbuf\", (const unsigned char *)pp->xbuf, pp->xbuf_pos < 32 ? pp->xbuf_pos : 32);\n    value_end = last_escape;\n    probe_log(\"value_end adjusted to last_escape=%p\", (const void *)value_end);\n  }\n\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    probe_log(\"loop start: value_start=%p value_end=%p delta=%zu xoff=%zu must_ikvi=%d\",\n              (const void *)value_start, (const void *)value_end, delta, xoff, (int)pp->must_ikvi);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      probe_log(\"memcpy -> &xbuf[%zu] from value_start=%p len=%zu\", xoff, (const void *)value_start, delta);\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n      probe_hexdump(\"xbuf after memcpy into processing buffer\", (const unsigned char *)xbuf, xoff < 32 ? xoff : 32);\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      probe_log(\"found trailing '%%' at xbuf[%zu], cut=%d new xoff=%zu\", xoff, (int)cut, xoff);\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n        probe_log(\"storing '%%' into pp->xbuf[0], pp->xbuf_pos=1\");\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n        probe_log(\"skipping '%%' for next iteration, delta=%zu clen=%zu\", delta, clen);\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      probe_log(\"found trailing '%%' at xbuf[%zu] (two chars), cut=%d new xoff=%zu\", xoff, (int)cut, xoff);\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n        probe_hexdump(\"stored two-char escape into pp->xbuf\", (const unsigned char *)pp->xbuf, 2);\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n        probe_log(\"skipping two-char '%%' for next iteration, delta=%zu clen=%zu\", delta, clen);\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n      probe_log(\"after unescape: xoff=%zu\", xoff);\n      probe_hexdump(\"xbuf (post-unescape)\", (const unsigned char *)xbuf, xoff < 32 ? xoff : 32);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      probe_log(\"invoking ikvi: cls=%p key=%p value_offset=%zu xoff=%zu\",\n                (const void *)pp->cls, (const void *)&pp[1], pp->value_offset, xoff);\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        probe_log(\"ikvi returned MHD_NO, setting state to PP_Error and returning\");\n        pp->state = PP_Error;\n        return;\n      }\n      else\n      {\n        probe_log(\"ikvi returned success\");\n      }\n    }\n    pp->value_offset += xoff;\n    probe_log(\"updated pp->value_offset=%zu\", pp->value_offset);\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n      probe_log(\"moved remaining %%-sequence to front of xbuf, clen=%zu\", clen);\n      probe_hexdump(\"xbuf after memmove\", (const unsigned char *)xbuf, clen < 32 ? clen : 32);\n    }\n    xoff = clen;\n  }\n\n  probe_log(\"process_value EXIT: pp=%p pp->xbuf_pos=%zu pp->value_offset=%zu pp->state=%d\",\n            (void *)pp, pp ? pp->xbuf_pos : (size_t)0, pp ? pp->value_offset : (size_t)0,\n            pp ? (int)pp->state : -1);\n}\n"
}