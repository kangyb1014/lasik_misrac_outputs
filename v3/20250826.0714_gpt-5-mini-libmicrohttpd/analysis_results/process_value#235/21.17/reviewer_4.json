{
  "user_message": "An agent A claimed that the following process_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of process_value.\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the preconditions implied by the mhd_asserts are not enforced at run time (for example, when asserts are disabled) a violation can occur. In particular: if value_start and value_end are both NULL but the loop is entered (because pp->must_ikvi is true or xoff > 0), the subtraction value_end - value_start is undefined and may produce a non\u2011zero delta; memcpy(&xbuf[xoff], value_start, delta) would then read from a NULL/invalid source pointer or copy more bytes than the source actually contains. This can result in accesses beyond the bounds of the objects referenced by the pointer parameters to memcpy.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->must_ikvi=1, value_start=0x5583781c702b, value_end=0x5583781c702f, last_escape=(nil)\nafter_restore: xoff=0\nloop ITER: value_start=0x5583781c702b, value_end=0x5583781c702f, pp->must_ikvi=1, xoff=0\ncomputed delta=4\nabout to memcpy into xbuf: dest=&xbuf[0], src=0x5583781c702b, len=4\nxbuf_after_memcpy: len=4 bytes [xxxx]\nafter memcpy: xoff=4, value_start=0x5583781c702f\nbefore unescape: xoff=4\nafter unescape: xoff=4\nunescaped_xbuf: len=4 bytes [xxxx]\ncalling ikvi: pp->cls=(nil), key_buf=0x55838a348480, value_off=0, xoff=4\nikvi returned OK\nupdated pp->value_offset=4\nend of loop iteration: xoff=0, pp->xbuf_pos=0, must_ikvi=0, value_start=0x5583781c702f, value_end=0x5583781c702f\nprocess_value EXIT: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->state=5, value_start=0x5583781c702f, value_end=0x5583781c702f\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->must_ikvi=1, value_start=0x5583781c7036, value_end=0x5583781c703a, last_escape=(nil)\nafter_restore: xoff=0\nloop ITER: value_start=0x5583781c7036, value_end=0x5583781c703a, pp->must_ikvi=1, xoff=0\ncomputed delta=4\nabout to memcpy into xbuf: dest=&xbuf[0], src=0x5583781c7036, len=4\nxbuf_after_memcpy: len=4 bytes [yyyy]\nafter memcpy: xoff=4, value_start=0x5583781c703a\nbefore unescape: xoff=4\nafter unescape: xoff=4\nunescaped_xbuf: len=4 bytes [yyyy]\ncalling ikvi: pp->cls=(nil), key_buf=0x55838a348480, value_off=0, xoff=4\nikvi returned OK\nupdated pp->value_offset=4\nend of loop iteration: xoff=0, pp->xbuf_pos=0, must_ikvi=0, value_start=0x5583781c703a, value_end=0x5583781c703a\nprocess_value EXIT: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->state=6, value_start=0x5583781c703a, value_end=0x5583781c703a\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->must_ikvi=1, value_start=0x5583781c7040, value_end=0x5583781c7040, last_escape=(nil)\nafter_restore: xoff=0\nloop ITER: value_start=0x5583781c7040, value_end=0x5583781c7040, pp->must_ikvi=1, xoff=0\ncomputed delta=0\nbefore unescape: xoff=0\ncalling ikvi: pp->cls=(nil), key_buf=0x55838a348480, value_off=0, xoff=0\nikvi returned OK\nupdated pp->value_offset=0\nend of loop iteration: xoff=0, pp->xbuf_pos=0, must_ikvi=0, value_start=0x5583781c7040, value_end=0x5583781c7040\nprocess_value EXIT: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->state=6, value_start=0x5583781c7040, value_end=0x5583781c7040\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->must_ikvi=1, value_start=0x5583781cf15c, value_end=0x5583781cf15c, last_escape=(nil)\nafter_restore: xoff=0\nloop ITER: value_start=0x5583781cf15c, value_end=0x5583781cf15c, pp->must_ikvi=1, xoff=0\ncomputed delta=0\nbefore unescape: xoff=0\ncalling ikvi: pp->cls=(nil), key_buf=0x55838a348480, value_off=0, xoff=0\nikvi returned OK\nupdated pp->value_offset=0\nend of loop iteration: xoff=0, pp->xbuf_pos=0, must_ikvi=0, value_start=0x5583781cf15c, value_end=0x5583781cf15c\nprocess_value EXIT: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->state=6, value_start=0x5583781cf15c, value_end=0x5583781cf15c\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=0, pp->must_ikvi=1, value_start=0x5583781c704c, value_end=0x5583781c7052, last_escape=0x5583781c7050\nafter_restore: xoff=0\nloop ITER: value_start=0x5583781c704c, value_end=0x5583781c7052, pp->must_ikvi=1, xoff=0\ncomputed delta=6\nabout to memcpy into xbuf: dest=&xbuf[0], src=0x5583781c704c, len=6\nxbuf_after_memcpy: len=6 bytes [text%2]\nafter memcpy: xoff=6, value_start=0x5583781c7052\nfound '%' at -2: cut=1, new_xoff=4\nmoved two-byte escape to pp->xbuf, pp->xbuf_pos=2\nbefore unescape: xoff=4\nafter unescape: xoff=4\nunescaped_xbuf: len=4 bytes [text]\ncalling ikvi: pp->cls=(nil), key_buf=0x55838a348480, value_off=0, xoff=4\nikvi returned OK\nupdated pp->value_offset=4\nprocess_value EXIT: pp=0x55838a3483e0, pp->xbuf_pos=2, pp->state=5, value_start=0x5583781c7052, value_end=0x5583781c7052\nprocess_value ENTRY: pp=0x55838a3483e0, pp->xbuf_pos=2, pp->must_ikvi=0, value_start=0x5583781c7053, value_end=0x5583781c7059, last_escape=(nil)\ncopied_prior_xbuf: len=2 bytes [%2]\nafter_restore: xoff=2\nloop ITER: value_start=0x558378\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code relies on mhd_assert to document the precondition that value_start/value_end are non-NULL when used, but those asserts can be compiled out. If value_start==value_end==NULL and the loop is entered (e.g. pp->must_ikvi true or xoff>0), the expression (size_t)(value_end - value_start) performs pointer subtraction on potentially NULL pointers (undefined behaviour) and may yield a non-zero delta. The subsequent memcpy(&xbuf[xoff], value_start, delta) would then read from an invalid/NULL source or copy more bytes than the referenced object contains, causing accesses beyond the bounds of the object passed to memcpy. While there are checks that protect the destination size, there is no runtime guard that value_start is a valid non-NULL pointer before doing the subtraction/copy. That violates MISRA C 2023 Rule 21.17. To fix, enforce the precondition at runtime (explicitly check for NULL) or restructure the code so memcpy is only called with a valid source and with a length guaranteed within the source object."
}