{
  "user_message": "An agent A claimed that the following process_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of process_value.\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe memcpy call uses pp->xbuf_pos as the length but the function only asserts pp->xbuf_pos < sizeof(xbuf) (the local destination size). There is no check that pp->xbuf_pos <= sizeof(pp->xbuf) (the source buffer size). If pp->xbuf is smaller than xbuf or pp->xbuf_pos contains a value that is less than sizeof(xbuf) but greater than sizeof(pp->xbuf) (for example, pp->xbuf_pos has been set/corrupted to a value in the range sizeof(pp->xbuf)+1 .. sizeof(xbuf)-1), memcpy(xbuf, pp->xbuf, pp->xbuf_pos) will read beyond the bounds of pp->xbuf. Therefore Rule 21.17 can be violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=0, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b2602b, value_end=0x5579d9b2602f, last_escape=(nil)\nLOOP START: value_start=0x5579d9b2602b, value_end=0x5579d9b2602f, delta(before)=4, xoff=0, must_ikvi=1\nPRE memcpy input -> xbuf at offset 0: delta=4, src=0x5579d9b2602b\nPOST memcpy input -> xbuf: new xoff=4, new value_start=0x5579d9b2602f\nBEFORE unescape: xoff=4, xbuf(@)=0x7fffc3216600\nAFTER unescape: new xoff=4, xbuf(@)=0x7fffc3216600\nCALL ikvi: pp->cls=(nil), key=@0x557a1875e480, value_offset=0, xoff=4\nikvi returned success\nAFTER handler: pp->value_offset=4\nLOOP END: xoff=0, value_start=0x5579d9b2602f, value_end=0x5579d9b2602f\nEXIT: pp=0x557a1875e3e0, pp->xbuf_pos=0, pp->value_offset=4, state=5\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=0, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b26036, value_end=0x5579d9b2603a, last_escape=(nil)\nLOOP START: value_start=0x5579d9b26036, value_end=0x5579d9b2603a, delta(before)=4, xoff=0, must_ikvi=1\nPRE memcpy input -> xbuf at offset 0: delta=4, src=0x5579d9b26036\nPOST memcpy input -> xbuf: new xoff=4, new value_start=0x5579d9b2603a\nBEFORE unescape: xoff=4, xbuf(@)=0x7fffc3216600\nAFTER unescape: new xoff=4, xbuf(@)=0x7fffc3216600\nCALL ikvi: pp->cls=(nil), key=@0x557a1875e480, value_offset=0, xoff=4\nikvi returned success\nAFTER handler: pp->value_offset=4\nLOOP END: xoff=0, value_start=0x5579d9b2603a, value_end=0x5579d9b2603a\nEXIT: pp=0x557a1875e3e0, pp->xbuf_pos=0, pp->value_offset=4, state=6\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=0, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b26040, value_end=0x5579d9b26040, last_escape=(nil)\nLOOP START: value_start=0x5579d9b26040, value_end=0x5579d9b26040, delta(before)=0, xoff=0, must_ikvi=1\nBEFORE unescape: xoff=0, xbuf(@)=0x7fffc3216600\nCALL ikvi: pp->cls=(nil), key=@0x557a1875e480, value_offset=0, xoff=0\nikvi returned success\nAFTER handler: pp->value_offset=0\nLOOP END: xoff=0, value_start=0x5579d9b26040, value_end=0x5579d9b26040\nEXIT: pp=0x557a1875e3e0, pp->xbuf_pos=0, pp->value_offset=0, state=6\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=0, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b2e1ec, value_end=0x5579d9b2e1ec, last_escape=(nil)\nLOOP START: value_start=0x5579d9b2e1ec, value_end=0x5579d9b2e1ec, delta(before)=0, xoff=0, must_ikvi=1\nBEFORE unescape: xoff=0, xbuf(@)=0x7fffc3216600\nCALL ikvi: pp->cls=(nil), key=@0x557a1875e480, value_offset=0, xoff=0\nikvi returned success\nAFTER handler: pp->value_offset=0\nLOOP END: xoff=0, value_start=0x5579d9b2e1ec, value_end=0x5579d9b2e1ec\nEXIT: pp=0x557a1875e3e0, pp->xbuf_pos=0, pp->value_offset=0, state=6\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=0, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b2604c, value_end=0x5579d9b26052, last_escape=0x5579d9b26050\nLOOP START: value_start=0x5579d9b2604c, value_end=0x5579d9b26052, delta(before)=6, xoff=0, must_ikvi=1\nPRE memcpy input -> xbuf at offset 0: delta=6, src=0x5579d9b2604c\nPOST memcpy input -> xbuf: new xoff=6, new value_start=0x5579d9b26052\nESCAPE2 detected at end: cut=1, xoff(after-=2)=4\nPRE memcpy escape(2) -> pp->xbuf: src=&xbuf[4], len=2\nPOST memcpy escape(2) -> pp->xbuf: pp->xbuf_pos=2\nBEFORE unescape: xoff=4, xbuf(@)=0x7fffc3216600\nAFTER unescape: new xoff=4, xbuf(@)=0x7fffc3216600\nCALL ikvi: pp->cls=(nil), key=@0x557a1875e480, value_offset=0, xoff=4\nikvi returned success\nAFTER handler: pp->value_offset=4\nEXIT: pp=0x557a1875e3e0, pp->xbuf_pos=2, pp->value_offset=4, state=5\nENTRY: pp=0x557a1875e3e0, pp->xbuf_pos=2, sizeof(xbuf)=513, sizeof(pp->xbuf)=2, value_start=0x5579d9b26053, value_end=0x5579d9b26059, last_escape=(nil)\nPRE memcpy: copy from pp->xbuf -> xbuf len=2 (pp->xbuf_pos), src_size=2, dst_size=513\nPOST memcpy: copied 2 bytes from pp->xbuf to xbuf\nLOOP START: value_start=0x5579d9b26053, value_end=0x5579d9b26059, delta(before)=6, xoff=2, must_ikvi=0\nPRE memcpy input -> xbuf at offset 2: delta=6, src=0x5579d9b26053\nPOST memcpy input -> xbuf: new xoff=8, new value_start=0x5579d9b26059\nBEFORE unescape: xoff=8, xbuf(@)=0x7fffc3216600\nAFTER unescape: new xoff\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The memcpy at the start of the function\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf, pp->xbuf, pp->xbuf_pos);\nuses pp->xbuf_pos as the length but the code only asserts pp->xbuf_pos < sizeof(xbuf). There is no runtime check that pp->xbuf_pos is <= sizeof(pp->xbuf) (the size of the source buffer). An assertion does not prevent a real out\u2011of\u2011bounds read at runtime and MISRA Rule 21.17 requires that uses of string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. If pp->xbuf_pos were larger than the actual size of pp->xbuf (for example due to logic error or corruption), this memcpy would read beyond the bounds of pp->xbuf, violating R21.17.\n\n(Other memcpy/memmove uses in the function are guarded: the copy into pp->xbuf from last_escape is protected by a check against sizeof(pp->xbuf), and the two\u2011byte copy uses a fixed length. The unguarded initial memcpy is the problematic one.)\n\nRecommendation: add an explicit runtime check ensuring pp->xbuf_pos <= sizeof(pp->xbuf) (and also <= sizeof(xbuf)) before performing the memcpy, or otherwise ensure by design that pp->xbuf_pos cannot exceed the source buffer size."
}