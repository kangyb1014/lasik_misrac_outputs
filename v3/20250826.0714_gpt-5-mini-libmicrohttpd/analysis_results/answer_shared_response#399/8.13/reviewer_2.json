{
  "user_message": "An agent A claimed that the following answer_shared_response code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of answer_shared_response.\n```c\nstatic enum MHD_Result\nanswer_shared_response (void *cls,\n                        struct MHD_Connection *connection,\n                        const char *url,\n                        const char *method,\n                        const char *version,\n                        const char *upload_data,\n                        size_t *upload_data_size,\n                        void **req_cls)\n{\n  static int marker = 0;\n  unsigned int resp_index;\n  static volatile unsigned int last_index = 0;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n  /* This kind of operation does not guarantee that numbers are not reused\n     in parallel threads, when processed simultaneously, but this should not\n     be a big problem, as it just slow down replies a bit due to\n     responses locking. */\n  resp_index = (last_index++) % num_resps;\n  return MHD_queue_response (connection, MHD_HTTP_OK, resps[resp_index]);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code stores the address of 'marker' (a non-const int) into a void* via '*req_cls = (void *)&marker;'. The pointer stored is not const-qualified even though the code does not modify 'marker' through that pointer \u2014 Rule 8.13 expects a pointer to point to a const-qualified type when possible. The use of the API parameter type (void **) forces a non-const pointer here, so absent that external-API constraint this is a violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct: the code is non-compliant with MISRA C 2023 Rule 8.13. The rule asks that pointers point to const-qualified types whenever possible. In this function the address of 'marker' (a non-const int) is stored into a void* via '*req_cls = (void *)&marker;', producing a pointer to a non-const object even though the code does not modify 'marker' via that pointer and 'marker' could be made const. That situation violates the spirit of 8.13. \n\nThat said, the non-compliance stems from the external API: the callback signature uses a void **req_cls, so the function cannot express a pointer-to-const through that parameter without conflicting with the API. In practice this means the violation is tolerable only if justified as an unavoidable interaction with an external library and documented as a deviation. A proper remediation would be to document the deviation or, if possible, change the API to accept a const-qualified pointer so that the pointed-to object can be const-qualified."
}