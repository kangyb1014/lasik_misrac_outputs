{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe assertion mhd_assert(buf_size >= used) is performed after get_rq_uname has already written into the username buffer. If get_rq_uname internally uses a string.h function (e.g. memcpy/memmove/strncpy) and copies 'used' bytes into the buffer but used > buf_size (for example get_rq_uname copies buf_size+10 bytes), an out-of-bounds write will occur before the assertion runs. Because the assert may be compiled out in non-debug builds, this does not prevent the overrun and therefore the code can result in accesses beyond the bounds of the username object.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_digest_auth_get_username code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2569.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_digest_auth_get_username as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_get_username:\n```c\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n```\n</target_code>\nPlease provide the modified MHD_digest_auth_get_username code.\n",
  "test_code": "_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /* Logging probe variables */\n  FILE *logf = NULL;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  /* Open log as early as possible so we can capture control flow */\n  logf = fopen(\"/tmp/logs/2569.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTRY: MHD_digest_auth_get_username connection=%p params=%p\\n\",\n            (void *) connection, (void *) params);\n    fflush(logf);\n  }\n\n  if (NULL == params)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"EXIT: params is NULL -> returning NULL\\n\");\n      fclose(logf);\n    }\n    return NULL;\n  }\n\n  uname_type = get_rq_uname_type (params);\n  if (logf)\n  {\n    fprintf(logf, \"INFO: uname_type=%d\\n\", (int) uname_type);\n    fflush(logf);\n  }\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n  {\n    if (logf)\n    {\n      fprintf(logf, \"EXIT: unsupported uname_type=%d -> returning NULL\\n\", (int) uname_type);\n      fclose(logf);\n    }\n    return NULL;\n  }\n\n  buf_size = get_rq_unames_size (params, uname_type);\n  if (logf)\n  {\n    fprintf(logf, \"INFO: buf_size=%zu\\n\", buf_size);\n    fflush(logf);\n  }\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (logf)\n  {\n    fprintf(logf, \"INFO: allocated username=%p\\n\", (void *) username);\n    fflush(logf);\n  }\n  if (NULL == username)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"EXIT: calloc failed -> returning NULL\\n\");\n      fclose(logf);\n    }\n    return NULL;\n  }\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n    size_t i, dump_len;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    if (logf)\n    {\n      fprintf(logf, \"INFO: Calling get_rq_uname(params=%p, uname_type=%d, uname_strct=%p, username=%p, buf_size=%zu)\\n\",\n              (void *) params, (int) uname_type, (void *) &uname_strct, (void *) username, buf_size);\n      fflush(logf);\n    }\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n\n    if (logf)\n    {\n      fprintf(logf, \"INFO: get_rq_uname returned used=%zu uname_strct.uname_type=%d\\n\",\n              used, (int) uname_strct.uname_type);\n      /* Detect potential overrun: the writer may have written more than allocated */\n      if (used > buf_size)\n      {\n        fprintf(logf, \"WARNING: used (%zu) > buf_size (%zu) -> potential out-of-bounds write occurred BEFORE assertion\\n\",\n                used, buf_size);\n      }\n      /* Safely dump up to the allocated buffer size, but cap the dump to avoid huge logs */\n      dump_len = buf_size;\n      if (dump_len > 64)\n        dump_len = 64;\n      fprintf(logf, \"DUMP: username (first %zu bytes) =\", dump_len);\n      for (i = 0; i < dump_len; ++i)\n      {\n        /* Read only within allocated region [0, buf_size) */\n        unsigned char c = (unsigned char) username[i];\n        fprintf(logf, \" %02x\", c);\n      }\n      fprintf(logf, \"\\n\");\n      fflush(logf);\n    }\n\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      if (logf)\n      {\n        fprintf(logf, \"EXIT: uname_type mismatch (expected=%d got=%d) -> freeing username and returning NULL\\n\",\n                (int) uname_type, (int) uname_strct.uname_type);\n        fclose(logf);\n      }\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n\n    if (logf)\n    {\n      fprintf(logf, \"INFO: assertion checked buf_size (%zu) >= used (%zu)\\n\", buf_size, used);\n      fprintf(logf, \"EXIT: returning username=%p\\n\", (void *) username);\n      fclose(logf);\n    }\n  }\n\n  return username;\n}\n"
}