{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_username code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_username.\n```c\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion mhd_assert(buf_size >= used) is performed after get_rq_uname has already written into the username buffer. If get_rq_uname internally uses a string.h function (e.g. memcpy/memmove/strncpy) and copies 'used' bytes into the buffer but used > buf_size (for example get_rq_uname copies buf_size+10 bytes), an out-of-bounds write will occur before the assertion runs. Because the assert may be compiled out in non-debug builds, this does not prevent the overrun and therefore the code can result in accesses beyond the bounds of the username object.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.17 forbids use of the string.h functions in a way that results in accesses beyond the bounds of the objects passed to them. The code shown does not itself call any <string.h> routine; it allocates a buffer of size buf_size and passes that buffer and buf_size to get_rq_uname. If get_rq_uname internally misuses a string.h function (or otherwise copies more than buf_size bytes) then that implementation \u2014 not this caller \u2014 would be the locus of a Rule 21.17 violation. The agent's scenario correctly observes that the mhd_assert(buf_size >= used) occurs after the copy and cannot prevent an overrun, but that only shows that a buggy get_rq_uname could cause an out\u2011of\u2011bounds access; it does not show that the code in MHD_digest_auth_get_username itself violates Rule 21.17. Therefore the report that this function violates MISRA C 2023 Rule 21.17 is not correct. To be robust, get_rq_uname must be implemented to respect the provided size or return an error before any copy that would exceed buf_size."
}