{
  "user_message": "An agent A claimed that the following MHD_get_connection_values_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values_n.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values_n (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             MHD_KeyValueIteratorN iterator,\n                             void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n\n  if (NULL == iterator)\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if (0 != (kind & pos->kind))\n        ret++;\n    }\n  else\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n      if (0 != (kind & pos->kind))\n      {\n        ret++;\n        if (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->header_size,\n                                pos->value,\n                                pos->value_size))\n          return ret;\n      }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes pos->header and pos->value to the iterator function. If the iterator type is declared to take non-const pointers (e.g. char *header, char *value) or the struct fields are declared as char * (not const char *), then pointer types are not const-qualified even though the data is only read here. That violates MISRA C 2023 Rule 8.13. Example violating scenario: MHD_KeyValueIteratorN is typedef int (*)(void *, enum MHD_ValueKind, char *header, size_t, char *value, size_t) or struct MHD_HTTP_Req_Header has char *header; char *value; \u2014 both should use const char * when the data is not modified.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_connection_values_n called: connection=0x55f483663270 kind=1 iterator=0x55f45ae5a550 iterator_cls=0x7ffee9365310\niterator provided: calling iterator for each matching header\ninvocation #1: pos=0x55f48366b480 kind=1 header=0x55f4836634d1 header_size=4 value=0x55f4836634d7 value_size=9\n  header bytes (size=4): 48 6f 73 74\n  value bytes (size=9): 6c 6f 63 61 6c 68 6f 73 74\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #2: pos=0x55f48366b440 kind=1 header=0x55f4836634e2 header_size=10 value=0x55f4836634ee value_size=15\n  header bytes (size=10): 55 73 65 72 2d 41 67 65 6e 74\n  value bytes (size=15): 64 75 6d 6d 79 63 6c 69 65 6e 74 2f 30 2e 39\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #3: pos=0x55f48366b400 kind=1 header=0x55f4836634ff header_size=14 value=0x55f48366350f value_size=2\n  header bytes (size=14): 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68\n  value bytes (size=2): 31 38\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #4: pos=0x55f48366b3c0 kind=1 header=0x55f483663513 header_size=12 value=0x55f483663521 value_size=10\n  header bytes (size=12): 43 6f 6e 74 65 6e 74 2d 54 79 70 65\n  value bytes (size=10): 74 65 78 74 2f 70 6c 61 69 6e\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ncompleted: returning 4\nMHD_get_connection_values_n called: connection=0x55f483663270 kind=1 iterator=0x55f45ae5a550 iterator_cls=0x7ffee9365310\niterator provided: calling iterator for each matching header\ninvocation #1: pos=0x55f48366b480 kind=1 header=0x55f4836634d1 header_size=4 value=0x55f4836634d7 value_size=9\n  header bytes (size=4): 48 6f 73 74\n  value bytes (size=9): 6c 6f 63 61 6c 68 6f 73 74\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #2: pos=0x55f48366b440 kind=1 header=0x55f4836634e2 header_size=10 value=0x55f4836634ee value_size=15\n  header bytes (size=10): 55 73 65 72 2d 41 67 65 6e 74\n  value bytes (size=15): 64 75 6d 6d 79 63 6c 69 65 6e 74 2f 30 2e 39\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #3: pos=0x55f48366b400 kind=1 header=0x55f4836634ff header_size=14 value=0x55f48366350f value_size=2\n  header bytes (size=14): 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68\n  value bytes (size=2): 31 38\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #4: pos=0x55f48366b3c0 kind=1 header=0x55f483663513 header_size=12 value=0x55f483663521 value_size=10\n  header bytes (size=12): 43 6f 6e 74 65 6e 74 2d 54 79 70 65\n  value bytes (size=10): 74 65 78 74 2f 70 6c 61 69 6e\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ncompleted: returning 4\nMHD_get_connection_values_n called: connection=0x55f483663270 kind=1 iterator=0x55f45ae5a550 iterator_cls=0x7ffee9365310\niterator provided: calling iterator for each matching header\ninvocation #1: pos=0x55f48366b480 kind=1 header=0x55f4836634d1 header_size=4 value=0x55f4836634d7 value_size=9\n  header bytes (size=4): 48 6f 73 74\n  value bytes (size=9): 6c 6f 63 61 6c 68 6f 73 74\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #2: pos=0x55f48366b440 kind=1 header=0x55f4836634e2 header_size=10 value=0x55f4836634ee value_size=15\n  header bytes (size=10): 55 73 65 72 2d 41 67 65 6e 74\n  value bytes (size=15): 64 75 6d 6d 79 63 6c 69 65 6e 74 2f 30 2e 39\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #3: pos=0x55f48366b400 kind=1 header=0x55f4836634ff header_size=14 value=0x55f48366350f value_size=2\n  header bytes (size=14): 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68\n  value bytes (size=2): 31 38\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ninvocation #4: pos=0x55f48366b3c0 kind=1 header=0x55f483663513 header_size=12 value=0x55f483663521 value_size=10\n  header bytes (size=12): 43 6f 6e 74 65 6e 74 2d 54 79 70 65\n  value bytes (size=10): 74 65 78 74 2f 70 6c 61 69 6e\nabout to call iterator at 0x55f45ae5a550\niterator returned 1\ncompleted: returning 4\nMHD_get_connection_values_n called: connection=0x55f483663270 kind=1 iterator=0x55f45ae5a550 iterator_cls=0x7ffee93\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not provably correct from the code shown. MISRA C:2023 Rule 8.13 concerns pointer declarations (they should be to const-qualified types when the pointee is not modified). The snippet of MHD_get_connection_values_n itself does not show the declarations of (a) struct MHD_HTTP_Req_Header (pos->header, pos->value) nor (b) the MHD_KeyValueIteratorN function-pointer type. Whether a violation exists depends entirely on those declarations:\n\n- If the struct fields are declared as const char * (and the iterator typedef takes const char * arguments), there is no violation. Passing const-qualified pointers through is compliant.\n- If the struct fields are declared as char * but they actually point to immutable data, MISRA 8.13 would recommend changing those fields to const char *. That would be a violation of the guideline in the library design, but this is not visible in the provided code.\n- If the iterator type is declared to accept non-const pointers (char *), and the data are actually read-only, then that typedef would violate Rule 8.13. However, that is a deficiency in the iterator/type declarations, not in the shown function body itself.\n\nTherefore the agent\u2019s scenario describes a possible violation in other declarations (the iterator typedef or the struct field types), but the provided function alone does not prove a MISRA 8.13 violation. To confirm a real violation you must inspect the actual declarations of MHD_HTTP_Req_Header and MHD_KeyValueIteratorN. Recommended remediation (if the data are read-only): declare header/value as const char * and declare the iterator parameters as const char * so no const is discarded and Rule 8.13 is satisfied."
}