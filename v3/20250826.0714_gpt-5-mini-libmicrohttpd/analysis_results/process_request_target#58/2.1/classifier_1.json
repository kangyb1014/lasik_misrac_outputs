{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of process_request_target:\n```c\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  return true;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated in the shown code. The mhd_assert line is inside the error branch executed when MHD_parse_arguments_ returns MHD_NO, so it is reachable when that call fails. It would only become unreachable (and thus violate Rule 2.1) if MHD_parse_arguments_ is provably incapable of returning MHD_NO (for example, it is guaranteed by specification or previous code to always return success), in which case the entire if-body (including this assertion and the return) could never be executed."
}