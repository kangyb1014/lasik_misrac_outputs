{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the request-target contains a lone '?' as its final character (i.e. the query string is empty), then rq.hdrs.rq_line.rq_tgt_qmark points to that '?' which is replaced with '\\0'. The code nevertheless passes rq.hdrs.rq_line.rq_tgt_qmark + 1 to MHD_parse_arguments_. In that case +1 points to the byte immediately after the string terminator (one-past the request-target region) and is not guaranteed to be a valid NUL-terminated buffer. If MHD_parse_arguments_ (or the string.h functions it uses) reads from that pointer, it can access memory beyond the bounds of the object, violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_request_target code that contains useful probe functions that print useful logs to a file \"/tmp/logs/589.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_request_target as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_request_target:\n```c\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  return true;\n}\n```\n</target_code>\nPlease provide the modified process_request_target code.\n",
  "test_code": "static bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  /* Probe helper: write diagnostic logs to /tmp/logs/589.txt.  Keep as\n     small and self-contained as possible to avoid changing program logic. */\n  static void probe_log_state (struct MHD_Connection *pc, const char *stage, size_t params_len_probe)\n  {\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (NULL == f)\n      return; /* best-effort logging only */\n\n    /* Basic context info */\n    fprintf (f, \"[process_request_target] stage=%s\\n\", stage);\n    fprintf (f, \"  connection ptr=%p\\n\", (void *) pc);\n\n    if (NULL == pc)\n    {\n      fprintf (f, \"  NOTE: connection pointer is NULL\\n\\n\");\n      fclose (f);\n      return;\n    }\n\n    /* Request-target pointers and lengths */\n    fprintf (f, \"  rq.url=%p url_len=%zu\\n\",\n             (void *) pc->rq.url, (size_t) pc->rq.url_len);\n    fprintf (f, \"  rq_tgt=%p rq_tgt_qmark=%p rq_req_target_len=%zu\\n\",\n             (void *) pc->rq.hdrs.rq_line.rq_tgt,\n             (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark,\n             (size_t) pc->rq.req_target_len);\n\n    /* If qmark exists, report the character at qmark and the pointer passed to parser */\n    if (NULL != pc->rq.hdrs.rq_line.rq_tgt_qmark)\n    {\n      /* Safe to read the qmark character itself since it points inside the request buffer */\n      unsigned char qch = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[0];\n      void *parser_ptr = (void *) (pc->rq.hdrs.rq_line.rq_tgt_qmark + 1);\n      void *one_past_end = (void *) (pc->rq.hdrs.rq_line.rq_tgt + pc->rq.req_target_len);\n\n      fprintf (f, \"  qmark_char='%c'(0x%02x) at %p\\n\",\n               (qch >= 32 && qch < 127) ? (char) qch : '?', (unsigned) qch,\n               (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark);\n      fprintf (f, \"  parser pointer (qmark+1)=%p\\n\", parser_ptr);\n      fprintf (f, \"  computed one-past-end (tgt + req_target_len)=%p\\n\", one_past_end);\n\n      if (parser_ptr == one_past_end)\n      {\n        fprintf (f, \"  WARNING: parser pointer equals one-past-end of request-target buffer.\\n\");\n        fprintf (f, \"           This is the reported violation scenario: the buffer passed to parser\\n\");\n        fprintf (f, \"           may not be a valid NUL-terminated string and subsequent string.h\\n\");\n        fprintf (f, \"           operations could read out-of-bounds.\\n\");\n      }\n      else if (parser_ptr > one_past_end)\n      {\n        fprintf (f, \"  ERROR: parser pointer is beyond one-past-end (unexpected).\\n\");\n      }\n      else\n      {\n        /* parser_ptr < one_past_end: there is at least one byte after '?' within req_target_len */\n        fprintf (f, \"  Info: parser pointer is within request-target region.\\n\");\n\n        /* Log up to the next few bytes after the qmark (without reading beyond known length) */\n        size_t bytes_after_qmark = (size_t) (one_past_end - parser_ptr);\n        size_t to_print = (bytes_after_qmark > 16U) ? 16U : bytes_after_qmark;\n\n        fprintf (f, \"  bytes_after_qmark=%zu (will print up to %zu bytes)\\n\",\n                 bytes_after_qmark, to_print);\n        if (to_print > 0U)\n        {\n          size_t i;\n          fprintf (f, \"  bytes: \");\n          for (i = 0U; i < to_print; ++i)\n          {\n            unsigned char b = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[1 + i];\n            fprintf (f, \"%02x\", b);\n            if (i + 1U < to_print)\n              fprintf (f, \" \");\n          }\n          fprintf (f, \"\\n\");\n        }\n      }\n    }\n    else\n    {\n      fprintf (f, \"  Info: no query mark present (rq_tgt_qmark == NULL).\\n\");\n    }\n\n    /* Debug-level params_len if provided */\n    fprintf (f, \"  params_len (probe)=%zu\\n\", params_len_probe);\n\n    fprintf (f, \"\\n\");\n    fclose (f);\n  }\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n\n    /* Probe before modification: record state and whether parser pointer is one-past-end */\n#ifdef _DEBUG\n    probe_log_state (c, \"before_replace_question\", params_len);\n#else\n    probe_log_state (c, \"before_replace_question\", 0U);\n#endif /* _DEBUG */\n\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n\n    /* Probe immediately after replacement, prior to invoking MHD_parse_arguments_ */\n#ifdef _DEBUG\n    probe_log_state (c, \"after_replace_before_parse\", params_len);\n#else\n    probe_log_state (c, \"after_replace_before_parse\", 0U);\n#endif /* _DEBUG */\n\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      /* Log parse failure */\n      probe_log_state (c, \"parse_failed\", 0U);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n\n    /* Log successful parse return */\n    probe_log_state (c, \"parse_succeeded\", 0U);\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  probe_log_state (c, \"done\", 0U);\n\n  return true;\n}\n"
}