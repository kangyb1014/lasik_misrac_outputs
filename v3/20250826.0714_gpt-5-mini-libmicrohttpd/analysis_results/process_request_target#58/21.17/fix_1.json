{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  /* Probe helper: write diagnostic logs to /tmp/logs/589.txt.  Keep as\n     small and self-contained as possible to avoid changing program logic. */\n  static void probe_log_state (struct MHD_Connection *pc, const char *stage, size_t params_len_probe)\n  {\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (NULL == f)\n      return; /* best-effort logging only */\n\n    /* Basic context info */\n    fprintf (f, \"[process_request_target] stage=%s\\n\", stage);\n    fprintf (f, \"  connection ptr=%p\\n\", (void *) pc);\n\n    if (NULL == pc)\n    {\n      fprintf (f, \"  NOTE: connection pointer is NULL\\n\\n\");\n      fclose (f);\n      return;\n    }\n\n    /* Request-target pointers and lengths */\n    fprintf (f, \"  rq.url=%p url_len=%zu\\n\",\n             (void *) pc->rq.url, (size_t) pc->rq.url_len);\n    fprintf (f, \"  rq_tgt=%p rq_tgt_qmark=%p rq_req_target_len=%zu\\n\",\n             (void *) pc->rq.hdrs.rq_line.rq_tgt,\n             (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark,\n             (size_t) pc->rq.req_target_len);\n\n    /* If qmark exists, report the character at qmark and the pointer passed to parser */\n    if (NULL != pc->rq.hdrs.rq_line.rq_tgt_qmark)\n    {\n      /* Safe to read the qmark character itself since it points inside the request buffer */\n      unsigned char qch = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[0];\n      void *parser_ptr = (void *) (pc->rq.hdrs.rq_line.rq_tgt_qmark + 1);\n      void *one_past_end = (void *) (pc->rq.hdrs.rq_line.rq_tgt + pc->rq.req_target_len);\n\n      fprintf (f, \"  qmark_char='%c'(0x%02x) at %p\\n\",\n               (qch >= 32 && qch < 127) ? (char) qch : '?', (unsigned) qch,\n               (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark);\n      fprintf (f, \"  parser pointer (qmark+1)=%p\\n\", parser_ptr);\n      fprintf (f, \"  computed one-past-end (tgt + req_target_len)=%p\\n\", one_past_end);\n\n      if (parser_ptr == one_past_end)\n      {\n        fprintf (f, \"  WARNING: parser pointer equals one-past-end of request-target buffer.\\n\");\n        fprintf (f, \"           This is the reported violation scenario: the buffer passed to parser\\n\");\n        fprintf (f, \"           may not be a valid NUL-terminated string and subsequent string.h\\n\");\n        fprintf (f, \"           operations could read out-of-bounds.\\n\");\n      }\n      else if (parser_ptr > one_past_end)\n      {\n        fprintf (f, \"  ERROR: parser pointer is beyond one-past-end (unexpected).\\n\");\n      }\n      else\n      {\n        /* parser_ptr < one_past_end: there is at least one byte after '?' within req_target_len */\n        fprintf (f, \"  Info: parser pointer is within request-target region.\\n\");\n\n        /* Log up to the next few bytes after the qmark (without reading beyond known length) */\n        size_t bytes_after_qmark = (size_t) (one_past_end - parser_ptr);\n        size_t to_print = (bytes_after_qmark > 16U) ? 16U : bytes_after_qmark;\n\n        fprintf (f, \"  bytes_after_qmark=%zu (will print up to %zu bytes)\\n\",\n                 bytes_after_qmark, to_print);\n        if (to_print > 0U)\n        {\n          size_t i;\n          fprintf (f, \"  bytes: \");\n          for (i = 0U; i < to_print; ++i)\n          {\n            unsigned char b = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[1 + i];\n            fprintf (f, \"%02x\", b);\n            if (i + 1U < to_print)\n              fprintf (f, \" \");\n          }\n          fprintf (f, \"\\n\");\n        }\n      }\n    }\n    else\n    {\n      fprintf (f, \"  Info: no query mark present (rq_tgt_qmark == NULL).\\n\");\n    }\n\n    /* Debug-level params_len if provided */\n    fprintf (f, \"  params_len (probe)=%zu\\n\", params_len_probe);\n\n    fprintf (f, \"\\n\");\n    fclose (f);\n  }\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n\n    /* Probe before modification: record state and whether parser pointer is one-past-end */\n#ifdef _DEBUG\n    probe_log_state (c, \"before_replace_question\", params_len);\n#else\n    probe_log_state (c, \"before_replace_question\", 0U);\n#endif /* _DEBUG */\n\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n\n    /* Probe immediately after replacement, prior to invoking MHD_parse_arguments_ */\n#ifdef _DEBUG\n    probe_log_state (c, \"after_replace_before_parse\", params_len);\n#else\n    probe_log_state (c, \"after_replace_before_parse\", 0U);\n#endif /* _DEBUG */\n\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      /* Log parse failure */\n      probe_log_state (c, \"parse_failed\", 0U);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n\n    /* Log successful parse return */\n    probe_log_state (c, \"parse_succeeded\", 0U);\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  probe_log_state (c, \"done\", 0U);\n\n  return true;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nconnection.c:5568:3: error: function definition is not allowed here\n 5568 |   {\n      |   ^\nconnection.c:5688:5: error: call to undeclared function 'probe_log_state'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]\n 5688 |     probe_log_state (c, \"before_replace_question\", 0U);\n      |     ^\nconnection.c:5730:3: error: call to undeclared function 'probe_log_state'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]\n 5730 |   probe_log_state (c, \"done\", 0U);\n      |   ^\n3 errors generated.\nmake[3]: *** [Makefile:2098: libmicrohttpd_la-connection.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_request_target as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void probe_log_state (struct MHD_Connection *pc, const char *stage, size_t params_len_probe)\n{\n  FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n  if (NULL == f)\n    return; /* best-effort logging only */\n\n  /* Basic context info */\n  fprintf (f, \"[process_request_target] stage=%s\\n\", stage);\n  fprintf (f, \"  connection ptr=%p\\n\", (void *) pc);\n\n  if (NULL == pc)\n  {\n    fprintf (f, \"  NOTE: connection pointer is NULL\\n\\n\");\n    fclose (f);\n    return;\n  }\n\n  /* Request-target pointers and lengths */\n  fprintf (f, \"  rq.url=%p url_len=%zu\\n\",\n           (void *) pc->rq.url, (size_t) pc->rq.url_len);\n  fprintf (f, \"  rq_tgt=%p rq_tgt_qmark=%p rq_req_target_len=%zu\\n\",\n           (void *) pc->rq.hdrs.rq_line.rq_tgt,\n           (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark,\n           (size_t) pc->rq.req_target_len);\n\n  /* If qmark exists, report the character at qmark and the pointer passed to parser */\n  if (NULL != pc->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n    /* Safe to read the qmark character itself since it points inside the request buffer */\n    unsigned char qch = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[0];\n    void *parser_ptr = (void *) (pc->rq.hdrs.rq_line.rq_tgt_qmark + 1);\n    void *one_past_end = (void *) (pc->rq.hdrs.rq_line.rq_tgt + pc->rq.req_target_len);\n\n    fprintf (f, \"  qmark_char='%c'(0x%02x) at %p\\n\",\n             (qch >= 32 && qch < 127) ? (char) qch : '?', (unsigned) qch,\n             (void *) pc->rq.hdrs.rq_line.rq_tgt_qmark);\n    fprintf (f, \"  parser pointer (qmark+1)=%p\\n\", parser_ptr);\n    fprintf (f, \"  computed one-past-end (tgt + req_target_len)=%p\\n\", one_past_end);\n\n    if (parser_ptr == one_past_end)\n    {\n      fprintf (f, \"  WARNING: parser pointer equals one-past-end of request-target buffer.\\n\");\n      fprintf (f, \"           This is the reported violation scenario: the buffer passed to parser\\n\");\n      fprintf (f, \"           may not be a valid NUL-terminated string and subsequent string.h\\n\");\n      fprintf (f, \"           operations could read out-of-bounds.\\n\");\n    }\n    else if (parser_ptr > one_past_end)\n    {\n      fprintf (f, \"  ERROR: parser pointer is beyond one-past-end (unexpected).\\n\");\n    }\n    else\n    {\n      /* parser_ptr < one_past_end: there is at least one byte after '?' within req_target_len */\n      fprintf (f, \"  Info: parser pointer is within request-target region.\\n\");\n\n      /* Log up to the next few bytes after the qmark (without reading beyond known length) */\n      size_t bytes_after_qmark = (size_t) (one_past_end - parser_ptr);\n      size_t to_print = (bytes_after_qmark > 16U) ? 16U : bytes_after_qmark;\n\n      fprintf (f, \"  bytes_after_qmark=%zu (will print up to %zu bytes)\\n\",\n               bytes_after_qmark, to_print);\n      if (to_print > 0U)\n      {\n        size_t i;\n        fprintf (f, \"  bytes: \");\n        for (i = 0U; i < to_print; ++i)\n        {\n          unsigned char b = (unsigned char) pc->rq.hdrs.rq_line.rq_tgt_qmark[1 + i];\n          fprintf (f, \"%02x\", b);\n          if (i + 1U < to_print)\n            fprintf (f, \" \");\n        }\n        fprintf (f, \"\\n\");\n      }\n    }\n  }\n  else\n  {\n    fprintf (f, \"  Info: no query mark present (rq_tgt_qmark == NULL).\\n\");\n  }\n\n  /* Debug-level params_len if provided */\n  fprintf (f, \"  params_len (probe)=%zu\\n\", params_len_probe);\n\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\n\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n\n    /* Probe before modification: record state and whether parser pointer is one-past-end */\n#ifdef _DEBUG\n    probe_log_state (c, \"before_replace_question\", params_len);\n#else\n    probe_log_state (c, \"before_replace_question\", 0U);\n#endif /* _DEBUG */\n\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n\n    /* Probe immediately after replacement, prior to invoking MHD_parse_arguments_ */\n#ifdef _DEBUG\n    probe_log_state (c, \"after_replace_before_parse\", params_len);\n#else\n    probe_log_state (c, \"after_replace_before_parse\", 0U);\n#endif /* _DEBUG */\n\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      /* Log parse failure */\n      probe_log_state (c, \"parse_failed\", 0U);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n\n    /* Log successful parse return */\n    probe_log_state (c, \"parse_succeeded\", 0U);\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  probe_log_state (c, \"done\", 0U);\n\n  return true;\n}\n",
  "explanation": "The compilation errors were caused by a nested function definition: probe_log_state was defined inside process_request_target, which is not allowed in standard C. I moved probe_log_state out to file scope (above process_request_target) as a static function. No other logic was changed; all calls to probe_log_state and the conditional debug handling remain the same. This removes the nested-function syntax error and the subsequent 'undeclared function' errors."
}