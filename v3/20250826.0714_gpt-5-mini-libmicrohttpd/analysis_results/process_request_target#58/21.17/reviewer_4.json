{
  "user_message": "An agent A claimed that the following process_request_target code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of process_request_target.\n```c\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf c->rq.hdrs.rq_line.rq_tgt does not have a terminating '\\0' within the bounds of the object (for example when rq_tgt_qmark == NULL and the request-target buffer contains exactly req_target_len bytes but no NUL), strlen(c->rq.hdrs.rq_line.rq_tgt) will scan past the object\u2019s bounds and thus access out-of-range memory. In other words, unless there is a guaranteed NUL within the object (either the code earlier null-terminated the buffer or rq_tgt_qmark was replaced by '\\0'), this use of strlen can read beyond the bounds and violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- probe: entry ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: entry ---\n\n--- probe: before_qmark_handling ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_qmark_handling ---\n\n--- probe: before_strlen_assertion ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_strlen_assertion ---\n\n--- probe: exit_after_unescape ---\nconn=0x563a6be9c270 state=1\nrq.url=0x563a6be9c4c4 rq.url_len=2\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: exit_after_unescape ---\n\n--- probe: entry ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: entry ---\n\n--- probe: before_qmark_handling ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_qmark_handling ---\n\n--- probe: before_strlen_assertion ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_strlen_assertion ---\n\n--- probe: exit_after_unescape ---\nconn=0x563a6be9c270 state=1\nrq.url=0x563a6be9c4c4 rq.url_len=2\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: exit_after_unescape ---\n\n--- probe: entry ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: entry ---\n\n--- probe: before_qmark_handling ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_qmark_handling ---\n\n--- probe: before_strlen_assertion ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_strlen_assertion ---\n\n--- probe: exit_after_unescape ---\nconn=0x563a6be9c270 state=1\nrq.url=0x563a6be9c4c4 rq.url_len=2\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: exit_after_unescape ---\n\n--- probe: entry ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: entry ---\n\n--- probe: before_qmark_handling ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_qmark_handling ---\n\n--- probe: before_strlen_assertion ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: before_strlen_assertion ---\n\n--- probe: exit_after_unescape ---\nconn=0x563a6be9c270 state=1\nrq.url=0x563a6be9c4c4 rq.url_len=2\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmark=(nil) req_target_len=2\nrq_tgt (first 2 bytes): 2f 61\nnul_index_within_first_2_bytes=-1\n--- end probe: exit_after_unescape ---\n\n--- probe: entry ---\nconn=0x563a6be9c270 state=1\nrq.url=(nil) rq.url_len=0\nrq_tgt=0x563a6be9c4c4 rq_tgt_qmar\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. strlen(c->rq.hdrs.rq_line.rq_tgt) is used without a guaranteed NUL terminator being present inside the object bounds, so it may read past the end of the buffer and thus can access out-of-range memory, violating MISRA C 2023 Rule 21.17. The code only writes a NUL when rq_tgt_qmark != NULL (rq_tgt_qmark[0] = 0). When rq_tgt_qmark == NULL there is no null insertion shown in the snippet, and the execution log demonstrates a case where rq_tgt_qmark is NULL, req_target_len == 2 and the first two bytes contain no NUL \u2014 strlen in that case will scan beyond the object's bounds. To comply with Rule 21.17 the code must ensure a NUL exists within the object (e.g. explicitly terminate at req_target_len or use length-bounded checks such as memchr/memcpy/memmove with known lengths) before calling strlen or otherwise avoid unbounded string functions."
}