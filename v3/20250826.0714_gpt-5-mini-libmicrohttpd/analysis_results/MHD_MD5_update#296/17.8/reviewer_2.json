{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'length' (a by-value function parameter) is modified by the statement 'length -= bytes_left;'. MISRA C 2023 Rule 17.8 prohibits modifying function parameters; only the object referred to by a pointer parameter may be modified (and pointer itself must not be changed). This assignment therefore violates Rule 17.8. Use a local copy (e.g. 'size_t len = length;') and modify that instead.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b2301b, length=28\nBefore count update: ctx->count=0, adding length=28\nAfter count update: ctx->count=28\nFinal copy of incomplete block: data=0x564df8b2301b, length=28, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=28\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23038, length=14\nBefore count update: ctx->count=0, adding length=14\nAfter count update: ctx->count=14\nFinal copy of incomplete block: data=0x564df8b23038, length=14, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=14\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23047, length=26\nBefore count update: ctx->count=0, adding length=26\nAfter count update: ctx->count=26\nFinal copy of incomplete block: data=0x564df8b23047, length=26, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=26\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b230b0, length=26\nBefore count update: ctx->count=0, adding length=26\nAfter count update: ctx->count=26\nFinal copy of incomplete block: data=0x564df8b230b0, length=26, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=26\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23062, length=104\nBefore count update: ctx->count=0, adding length=104\nAfter count update: ctx->count=104\nWhile loop entry: processing full block: data=0x564df8b23062, length=104\nWhile loop after transform: data=0x564df8b230a2, length=40\nFinal copy of incomplete block: data=0x564df8b230a2, length=40, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=40\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b230cb, length=378\nBefore count update: ctx->count=0, adding length=378\nAfter count update: ctx->count=378\nWhile loop entry: processing full block: data=0x564df8b230cb, length=378\nWhile loop after transform: data=0x564df8b2310b, length=314\nWhile loop entry: processing full block: data=0x564df8b2310b, length=314\nWhile loop after transform: data=0x564df8b2314b, length=250\nWhile loop entry: processing full block: data=0x564df8b2314b, length=250\nWhile loop after transform: data=0x564df8b2318b, length=186\nWhile loop entry: processing full block: data=0x564df8b2318b, length=186\nWhile loop after transform: data=0x564df8b231cb, length=122\nWhile loop entry: processing full block: data=0x564df8b231cb, length=122\nWhile loop after transform: data=0x564df8b2320b, length=58\nFinal copy of incomplete block: data=0x564df8b2320b, length=58, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=58\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b24d6d, length=0\nShortcut return: length is 0\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b24c54, length=1\nBefore count update: ctx->count=0, adding length=1\nAfter count update: ctx->count=1\nFinal copy of incomplete block: data=0x564df8b24c54, length=1, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=1\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23246, length=3\nBefore count update: ctx->count=0, adding length=3\nAfter count update: ctx->count=3\nFinal copy of incomplete block: data=0x564df8b23246, length=3, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=3\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b2324a, length=14\nBefore count update: ctx->count=0, adding length=14\nAfter count update: ctx->count=14\nFinal copy of incomplete block: data=0x564df8b2324a, length=14, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=14\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23259, length=62\nBefore count update: ctx->count=0, adding length=62\nAfter count update: ctx->count=62\nFinal copy of incomplete block: data=0x564df8b23259, length=62, bytes_have=0\nEXIT MHD_MD5_update: ctx=0x7ffddc1d65a0, final length parameter=62\nENTER MHD_MD5_update: ctx=0x7ffddc1d65a0, data=0x564df8b23298, length=80\nBefore count update: ctx->count=0, adding length=80\nAfter count update: ctx->count=80\nWhile loop ent\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function modifies the by-value parameter 'length' (e.g. length -= bytes_left; length -= MD5_BLOCK_SIZE;) which violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified). Additionally, the code also modifies the pointer parameter 'data' (data += bytes_left; data += MD5_BLOCK_SIZE;), which likewise violates Rule 17.8 because the pointer itself must not be changed (only the object it points to may be modified). The recommended fix is to make local copies (for example: size_t len = length; const uint8_t *p = data;) and use/modify those locals instead of the parameter identifiers, preserving the same semantics (ensure ctx->count is updated using the original length or the copy as appropriate)."
}