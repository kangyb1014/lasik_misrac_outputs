{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression 'data += bytes_left;' modifies the pointer parameter 'data' (it increments the pointer). MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified \u2014 the object pointed to may be changed, but not the pointer parameter itself. Therefore this statement violates Rule 17.8. A compliant fix is to copy the parameter to a local pointer (e.g. 'const uint8_t *p = data;') and update 'p' instead, using 'p' for subsequent accesses.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nentry: data=0x55a0d96b501b length=28 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=0\n  data[0..15] = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nafter_count_update: data=0x55a0d96b501b length=28 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=28\n  data[0..15] = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nbefore_final_copy: data=0x55a0d96b501b length=28 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=28\n  data[0..15] = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nafter_final_copy: data=0x55a0d96b501b length=28 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=28\n  data[0..15] = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nexit: data=0x55a0d96b501b length=28 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=28\n  data[0..15] = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24\nentry: data=0x55a0d96b5038 length=14 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=0\n  data[0..13] = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nafter_count_update: data=0x55a0d96b5038 length=14 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=14\n  data[0..13] = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nbefore_final_copy: data=0x55a0d96b5038 length=14 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=14\n  data[0..13] = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nafter_final_copy: data=0x55a0d96b5038 length=14 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=14\n  data[0..13] = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nexit: data=0x55a0d96b5038 length=14 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=14\n  data[0..13] = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nentry: data=0x55a0d96b5047 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=0\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nafter_count_update: data=0x55a0d96b5047 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nbefore_final_copy: data=0x55a0d96b5047 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nafter_final_copy: data=0x55a0d96b5047 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nexit: data=0x55a0d96b5047 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nentry: data=0x55a0d96b50b0 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=0\n  data[0..15] = 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nafter_count_update: data=0x55a0d96b50b0 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nbefore_final_copy: data=0x55a0d96b50b0 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nafter_final_copy: data=0x55a0d96b50b0 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nexit: data=0x55a0d96b50b0 length=26 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=26\n  data[0..15] = 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 4d 4c 4b\nentry: data=0x55a0d96b5062 length=104 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=0\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nafter_count_update: data=0x55a0d96b5062 length=104 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nwhile_before_transform: data=0x55a0d96b5062 length=104 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nwhile_after_transform_before_advance: data=0x55a0d96b5062 length=104 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  data[0..15] = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70\nwhile_after_advance: data=0x55a0d96b50a2 length=40 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  data[0..15] = 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7a 79\nbefore_final_copy: data=0x55a0d96b50a2 length=40 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  data[0..15] = 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7a 79\nafter_final_copy: data=0x55a0d96b50a2 length=40 bytes_have=0 ctx=0x7ffc86fc5640 ctx_count=104\n  dat\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the pointer object itself must not be changed; the object pointed to may be changed). In MHD_MD5_update the code alters the formal parameters: \"data += bytes_left;\" and \"data += MD5_BLOCK_SIZE;\" change the pointer parameter 'data', and the code also modifies the scalar parameter 'length' (length -= bytes_left; length -= MD5_BLOCK_SIZE;). Both kinds of modifications violate Rule 17.8. A compliant fix is to copy parameters to local variables (for example: const uint8_t *p = data; size_t len = length;) and update p and len instead, using those locals throughout the function. Note: modifying the object pointed to by 'ctx' (e.g. ctx->count += length;) is permitted under the rule."
}