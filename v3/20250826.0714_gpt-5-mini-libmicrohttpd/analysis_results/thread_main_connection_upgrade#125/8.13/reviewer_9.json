{
  "user_message": "An agent A claimed that the following thread_main_connection_upgrade code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of thread_main_connection_upgrade.\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes 'urh' (type: struct MHD_UpgradeResponseHandle *) to urh_to_fdset. If urh_to_fdset does not modify the object pointed to by 'urh' (i.e. its parameter could be declared as const struct MHD_UpgradeResponseHandle *), then the code violates MISRA C 2023 Rule 8.13 because the pointer/parameter is not const-qualified. The other arguments (&rs, &ws, &es, &max_fd) are clearly intended to be modified by urh_to_fdset and therefore should not be const. Without the urh_to_fdset prototype/implementation we cannot be certain, but this call is a potential violation when urh is only read by the function.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7ff1d8000d30 con=0x7ff1d0000b90 daemon=0x563ea42612e0\n           urh->connection=0x7ff1d0000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7ff1cc000d30 con=0x7ff1d0000b90 daemon=0x563ea4261760\n           urh->connection=0x7ff1d0000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7ff1d8000cf0 con=0x7ff1d0000b90 daemon=0x563ea4261ba0\n           urh->connection=0x7ff1d0000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7f1898000d30 con=0x7f1890000b90 daemon=0x55747baf5b00\n           urh->connection=0x7f1890000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7f1898000cf0 con=0x7f1890000b90 daemon=0x55747baf5f80\n           urh->connection=0x7f1890000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7f1898000cb0 con=0x7f1890000b90 daemon=0x55747baf63c0\n           urh->connection=0x7f1890000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7fe35c000d30 con=0x7fe364000b90 daemon=0x55b1e8269710\n           urh->connection=0x7fe364000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7fe358000d30 con=0x7fe364000b90 daemon=0x55b1e8269b50\n           urh->connection=0x7fe364000b90 socket_fd=6\ncleanup: calling MHD_connection_finish_forward_\n[urh-state] exit: urh=0x7fe358000cf0 con=0x7fe364000b90 daemon=0x55b1e8269f90\n           urh->connection=0x7fe364000b90 socket_fd=6\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. MISRA C 2023 Rule 8.13 is about preferring pointers to const when the pointed-to object does not need modification. To demonstrate a violation you must show that the pointer type could be declared as pointing to const (i.e. that none of the uses or callees mutate the object). In the snippet, urh is used in multiple calls (urh_to_fdset, urh_from_fdset, process_urh, urh_update_pollfd, urh_from_pollfd) and is derived from con->urh; any of those functions may legitimately modify the structure. The agent's claim rests on a speculative possibility (that urh_to_fdset does not modify the object) without the function prototypes/implementations. If the called functions\u2019 prototypes require a non-const pointer, or if they modify urh, then declaring urh as pointer-to-const would be incorrect. Therefore, based on the provided code alone, you cannot conclude a definite MISRA 8.13 violation."
}