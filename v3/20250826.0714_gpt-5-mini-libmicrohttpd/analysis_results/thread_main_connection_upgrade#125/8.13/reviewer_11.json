{
  "user_message": "An agent A claimed that the following thread_main_connection_upgrade code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of thread_main_connection_upgrade.\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'daemon' is initialized from con->daemon but is only used for read-only access (e.g. checking options, shutdown flag, and passing to logging macros). It is declared as 'struct MHD_Daemon *daemon' (non-const) even though it could be 'const struct MHD_Daemon *daemon' to reflect read-only use. This violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756200765] EVENT: before_finish_forward\n  pointers: con=0x7f4c78000b90, daemon=0x5590988032e0, urh=0x7f4c70000d30\n  daemon->options=0xa40d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c70000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200765] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f4c78000b90, daemon=0x5590988032e0, urh=0x7f4c70000d30\n  daemon->options=0xa40d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c70000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200765] EVENT: before_finish_forward\n  pointers: con=0x7f4c78000b90, daemon=0x559098803760, urh=0x7f4c74000d30\n  daemon->options=0x1a44d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c74000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200765] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f4c78000b90, daemon=0x559098803760, urh=0x7f4c74000d30\n  daemon->options=0x1a44d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c74000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200765] EVENT: before_finish_forward\n  pointers: con=0x7f4c78000b90, daemon=0x559098803ba0, urh=0x7f4c74000cf0\n  daemon->options=0xa44d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c74000cf0\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200765] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f4c78000b90, daemon=0x559098803ba0, urh=0x7f4c74000cf0\n  daemon->options=0xa44d, daemon->shutdown=0\n  con (pointer)=0x7f4c78000b90\n  urh (pointer)=0x7f4c74000cf0\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: before_finish_forward\n  pointers: con=0x7f5dbc000b90, daemon=0x558d32228b00, urh=0x7f5dc4000d30\n  daemon->options=0xa40d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc4000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f5dbc000b90, daemon=0x558d32228b00, urh=0x7f5dc4000d30\n  daemon->options=0xa40d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc4000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: before_finish_forward\n  pointers: con=0x7f5dbc000b90, daemon=0x558d32228f80, urh=0x7f5dc4000cf0\n  daemon->options=0x1a44d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc4000cf0\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f5dbc000b90, daemon=0x558d32228f80, urh=0x7f5dc4000cf0\n  daemon->options=0x1a44d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc4000cf0\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: before_finish_forward\n  pointers: con=0x7f5dbc000b90, daemon=0x558d322293c0, urh=0x7f5dc0000d30\n  daemon->options=0xa44d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc0000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: exit_thread_main_connection_upgrade\n  pointers: con=0x7f5dbc000b90, daemon=0x558d322293c0, urh=0x7f5dc0000d30\n  daemon->options=0xa44d, daemon->shutdown=0\n  con (pointer)=0x7f5dbc000b90\n  urh (pointer)=0x7f5dc0000d30\n  max_fd=-1, num_ready=0, err=0\n  NOTE: daemon pointer used only for read-only checks in this path.\n\n[1756200766] EVENT: before_finish_forward\n  pointers: con=0x7f0860000b90, daemon=0x563a79b47710, urh=0x7f0868000d30\n  da\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The claim is correct. In thread_main_connection_upgrade the local variable daemon is only used for read-only access (tests of daemon->options, daemon->shutdown and passing it to logging/assert macros); there are no stores through that pointer. Therefore, per MISRA C 2023 Rule 8.13 the pointer should be declared to point to a const-qualified type (e.g. const struct MHD_Daemon *daemon) where possible. Assigning con->daemon (a non-const pointer) to a pointer-to-const is permitted by C, so this change is feasible. The only caveat is if any of the macros or functions called here (e.g. MHD_D_IS_USING_SELECT_ / MHD_D_IS_USING_THREADS_) are prototyped to take a non-const pointer and internally modify the object; in that case declaring daemon as pointer-to-const would either require changing those APIs or inserting casts (which have their own MISRA implications). Given the code shown, however, the local daemon pointer can and should be const-qualified, so Agent A\u2019s report is correct."
}