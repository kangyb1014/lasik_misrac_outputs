{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of thread_main_connection_upgrade:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )",
    "memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;",
    "urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);",
    "/* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;",
    "urh_update_pollfd (urh, p);",
    "FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }",
    "mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );",
    "if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }"
  ],
  "explanation": "Fragments not listed above were not selected because they perform observable side-effects, are essential control-flow, or are conditionally removed at compile time and therefore are not candidates for runtime dead code under MISRA Rule 2.2. Examples: calls such as urh_from_pollfd(...), process_urh(...), MHD_connection_finish_forward_(con) and the surrounding loop bodies perform socket I/O and state updates (side effects) so removing them would change program behaviour. Preprocessor guards (#ifdef HTTPS_SUPPORT, #ifdef HAVE_POLL, #ifdef HAVE_MESSAGES) exclude code at compile time rather than leaving executed-but-redundant operations in the final binary; those excluded blocks are not runtime dead code. Similarly, logging calls enclosed in HAVE_MESSAGES and error-handling branches (errno/EINTR handling) have observable effects when enabled and must be preserved. In short, only the fragments listed were flagged because they contain assertions, preparatory calls, conditional checks, or initialization/zeroing patterns that appear potentially redundant or no-op in common configurations and therefore merit investigation for dead-code violations; the remaining lines implement I/O, state changes or explicit control flow and so are not considered dead-code candidates."
}