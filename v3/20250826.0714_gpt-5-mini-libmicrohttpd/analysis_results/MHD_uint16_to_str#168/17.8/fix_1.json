{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nvoid mhd_assert (int cond)\n{\n  /* Keep same semantics: do nothing in release; a real project may abort on false. */\n  (void) cond;\n}\nstatic void\nmhd_log_uint16_state (const char *tag,\n                      const uint16_t *val_ptr,\n                      uint16_t divisor,\n                      int digit,\n                      const char *buf_ptr,\n                      size_t buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/1687.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* best-effort logging only */\n  }\n\n  /* Print a compact record with control location and key state. */\n  (void) fprintf (f, \"[%s] val_ptr=%p val=%\" PRIu16 \" divisor=%\" PRIu16 \" digit=%d buf=%p buf_size=%zu\\n\",\n                  tag,\n                  (void *) val_ptr,\n                  (uint16_t) *val_ptr,\n                  (uint16_t) divisor,\n                  digit,\n                  (const void *) buf_ptr,\n                  buf_size);\n  (void) fclose (f);\n}\n\nsize_t\nMHD_uint16_to_str (uint16_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 65535 */\n  uint16_t divisor = UINT16_C (10000);\n  int digit;\n\n  /* Log entry state */\n  mhd_log_uint16_state(\"entry\", &val, divisor, -1, buf, buf_size);\n\n  chr = buf;\n  digit = (int) (val / divisor);\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n    {\n      /* Log just before returning (completed) */\n      mhd_log_uint16_state(\"return_complete\", &val, divisor, digit, buf, buf_size);\n      return (size_t) (chr - buf);\n    }\n\n    /* Log before the operation that modifies the function parameter 'val' */\n    mhd_log_uint16_state(\"before_mod\", &val, divisor, digit, buf, buf_size);\n\n    /* Violation point: modifies function parameter 'val' */\n    val = (uint16_t) (val % divisor);\n\n    /* Log immediately after modification to provide evidence of the change */\n    mhd_log_uint16_state(\"after_mod\", &val, divisor, digit, buf, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  /* Log buffer-too-small case */\n  mhd_log_uint16_state(\"return_overflow\", &val, divisor, digit, buf, buf_size);\n  return 0; /* The buffer is too small */\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_str.c:1558:6: error: expected identifier or '('\n 1558 | void mhd_assert (int cond)\n      |      ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nmhd_str.c:1558:6: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nmhd_str.c:1558:6: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\nmhd_str.c:1558:6: error: expected ')'\n 1558 | void mhd_assert (int cond)\n      |      ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nmhd_str.c:1558:6: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2140: libmicrohttpd_la-mhd_str.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_uint16_to_str as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n\n/* If a release header has defined mhd_assert as a macro, remove that\n   macro so we can provide a real function implementation here. This is\n   an #undef (not a new macro definition). */\n#undef mhd_assert\n\nvoid mhd_assert (int cond)\n{\n  /* Keep same semantics: do nothing in release; a real project may abort on false. */\n  (void) cond;\n}\n\nstatic void\nmhd_log_uint16_state (const char *tag,\n                      const uint16_t *val_ptr,\n                      uint16_t divisor,\n                      int digit,\n                      const char *buf_ptr,\n                      size_t buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/1687.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* best-effort logging only */\n  }\n\n  /* Print a compact record with control location and key state. */\n  (void) fprintf (f, \"[%s] val_ptr=%p val=%\" PRIu16 \" divisor=%\" PRIu16 \" digit=%d buf=%p buf_size=%zu\\n\",\n                  tag,\n                  (void *) val_ptr,\n                  (uint16_t) *val_ptr,\n                  (uint16_t) divisor,\n                  digit,\n                  (const void *) buf_ptr,\n                  buf_size);\n  (void) fclose (f);\n}\n\nsize_t\nMHD_uint16_to_str (uint16_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 65535 */\n  uint16_t divisor = UINT16_C (10000);\n  int digit;\n\n  /* Log entry state */\n  mhd_log_uint16_state(\"entry\", &val, divisor, -1, buf, buf_size);\n\n  chr = buf;\n  digit = (int) (val / divisor);\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n    {\n      /* Log just before returning (completed) */\n      mhd_log_uint16_state(\"return_complete\", &val, divisor, digit, buf, buf_size);\n      return (size_t) (chr - buf);\n    }\n\n    /* Log before the operation that modifies the function parameter 'val' */\n    mhd_log_uint16_state(\"before_mod\", &val, divisor, digit, buf, buf_size);\n\n    /* Violation point: modifies function parameter 'val' */\n    val = (uint16_t) (val % divisor);\n\n    /* Log immediately after modification to provide evidence of the change */\n    mhd_log_uint16_state(\"after_mod\", &val, divisor, digit, buf, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n  }\n\n  /* Log buffer-too-small case */\n  mhd_log_uint16_state(\"return_overflow\", &val, divisor, digit, buf, buf_size);\n  return 0; /* The buffer is too small */\n}\n",
  "explanation": "The compilation error was caused by a macro named mhd_assert (from an included header) colliding with the function definition. To fix this I added standard includes (stdio.h, stdint.h, inttypes.h, stddef.h) and explicitly #undef'ed mhd_assert before providing the function implementation so the identifier is not replaced by a macro. No macros were newly defined. The original logic of MHD_uint16_to_str and the logging helper was preserved."
}