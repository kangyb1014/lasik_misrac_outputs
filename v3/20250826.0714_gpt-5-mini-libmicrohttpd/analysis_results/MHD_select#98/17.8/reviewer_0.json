{
  "user_message": "An agent A claimed that the following MHD_select code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_select.\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn MHD_select the value of the function parameter 'millisec' is assigned: if (MHD_NO != err_state) millisec = 0; \u2014 this modifies a function parameter (millisec), which violates MISRA C 2023 Rule 17.8.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_suspend_resume_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_err_state_check: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: before_timeout_calc: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: just_before_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: after_select: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: internal_run_from_select_nonzero_return: daemon=0x5652c18e3de0 millisec=0 err_state=0\nMHD_select: entry_after_shutdown_check: daemon=0x5652c18e3de0 millisec=0 err_state=-1\nMHD_select: before_suspend_resume_chec\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified. In MHD_select the by-value parameter 'millisec' is assigned to (e.g. \"millisec = 0;\" appears in at least two places), which modifies the formal parameter and therefore violates Rule 17.8. (The rule exception about pointer parameters and the objects they point to does not apply here because 'millisec' is a non-pointer parameter.) A compliant remedy is to copy the parameter into a local variable (for example, \"int32_t timeout_ms = millisec;\") and modify that local instead."
}