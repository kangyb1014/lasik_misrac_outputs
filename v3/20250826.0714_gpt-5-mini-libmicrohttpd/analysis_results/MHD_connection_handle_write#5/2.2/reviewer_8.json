{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 the mhd_assert(0) call in these reachable switch cases can be dead code. If mhd_assert is a debug-only macro that expands to a no-op in the project\u2019s release build (e.g. via NDEBUG), the mhd_assert(0) call is executed but has no effect and its removal would not affect program behaviour, which violates MISRA C 2023 Rule 2.2. (If, however, mhd_assert always has an observable effect in every project configuration, then there is no violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n1756194660: event=enter_write conn=0x55b11f15adf0 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x55b11f163a80 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x55b11f15b090 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4ce8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4ce8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4ce8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4ce8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4ce8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000f50 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000b70 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000b70 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194660: event=enter_write conn=0x7f4cdc000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x55faf78cd610 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x55faf78cf2a0 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x55faf78cd8b0 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f7684000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f767c000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f767c000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f767c000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f767c000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x559b352d6e10 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x559b352d7a90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x559b352d84c0 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f2ab8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f2ab8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194661: event=enter_write conn=0x7f2ab8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194662: event=enter_write conn=0x7f2ab8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194662: event=enter_write conn=0x7f2ab8000b90 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194662: event=enter_write conn=0x7f2ab8000b70 state=13 note=(null) url=/ write_send_off=0 rsp_write_pos=0\n1756194662: event=enter_wr\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct in principle. The mhd_assert(0) statements in several reachable switch cases can constitute dead code under MISRA C:2023 Rule 2.2 if, in the project configuration in use, the mhd_assert macro expands to a no\u2011op (for example ((void)0) or nothing) while remaining present in the compiled control flow. In that situation the assertion expression is executed but has no observable effect and its removal would not change program behaviour, therefore it meets the Rule 2.2 definition of dead code. Whether an actual violation exists depends on the project\u2019s definition of mhd_assert across all build configurations: if mhd_assert always produces an observable effect (logging/abort/handler call) then there is no dead code; if it is compiled globally to a no\u2011op, the occurrences reported are dead code and violate Rule 2.2. To resolve: inspect the mhd_assert macro and the project build configurations; either ensure assertions remain observable in all builds or remove/guard them so no executed no\u2011op statements remain in production code."
}