{
  "user_message": "An agent A claimed that the following find_boundary code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_boundary.\n```c\nstatic int\nfind_boundary (struct MHD_PostProcessor *pp,\n               const char *boundary,\n               size_t blen,\n               size_t *ioffptr,\n               enum PP_State next_state,\n               enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  const char *dash;\n\n  if (pp->buffer_pos < 2 + blen)\n  {\n    if (pp->buffer_pos == pp->buffer_size)\n      pp->state = PP_Error;     /* out of memory */\n    /* ++(*ioffptr); */\n    return MHD_NO;              /* not enough data */\n  }\n  if ( (0 != memcmp (\"--\",\n                     buf,\n                     2)) ||\n       (0 != memcmp (&buf[2],\n                     boundary,\n                     blen)))\n  {\n    if (pp->state != PP_Init)\n    {\n      /* garbage not allowed */\n      pp->state = PP_Error;\n    }\n    else\n    {\n      /* skip over garbage (RFC 2046, 5.1.1) */\n      dash = memchr (buf,\n                     '-',\n                     pp->buffer_pos);\n      if (NULL == dash)\n        (*ioffptr) += pp->buffer_pos;         /* skip entire buffer */\n      else if (dash == buf)\n        (*ioffptr)++;                         /* at least skip one byte */\n      else\n        (*ioffptr) += (size_t) (dash - buf);  /* skip to first possible boundary */\n    }\n    return MHD_NO;                            /* expected boundary */\n  }\n  /* remove boundary from buffer */\n  (*ioffptr) += 2 + blen;\n  /* next: start with headers */\n  pp->skip_rn = RN_Dash;\n  pp->state = next_state;\n  pp->dash_state = next_dash_state;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'buf' is used only for read-only operations (memcmp, memchr), but it's declared as char * and initialized with (char *)&pp[1] instead of a pointer to a const-qualified type. It should be declared as const char *buf = (const char *)&pp[1];\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=1, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d\nboundary (hex): 416142303378\n--- end probe ---\ninsufficient data: buffer_pos=1, required=8\n--- probe: return_not_enough_data ---\npp=0x55d802c7f820, state=2, buffer_pos=1, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=231, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\nmemcmp results: cmp1=0 (-- vs buf[0..1]), cmp2=0 (buf[2..] vs boundary)\nboundary matched: advancing ioff by 8 to 8\n--- probe: success_boundary_found ---\npp=0x55d802c7f820, state=7, buffer_pos=231, buffer_size=1028, blen=6, ioff=8\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=2, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d\nboundary (hex): 416142303378\n--- end probe ---\ninsufficient data: buffer_pos=2, required=8\n--- probe: return_not_enough_data ---\npp=0x55d802c7f820, state=2, buffer_pos=2, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=231, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\nmemcmp results: cmp1=0 (-- vs buf[0..1]), cmp2=0 (buf[2..] vs boundary)\nboundary matched: advancing ioff by 8 to 8\n--- probe: success_boundary_found ---\npp=0x55d802c7f820, state=7, buffer_pos=231, buffer_size=1028, blen=6, ioff=8\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=3, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d41\nboundary (hex): 416142303378\n--- end probe ---\ninsufficient data: buffer_pos=3, required=8\n--- probe: return_not_enough_data ---\npp=0x55d802c7f820, state=2, buffer_pos=3, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d41\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=231, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\nmemcmp results: cmp1=0 (-- vs buf[0..1]), cmp2=0 (buf[2..] vs boundary)\nboundary matched: advancing ioff by 8 to 8\n--- probe: success_boundary_found ---\npp=0x55d802c7f820, state=7, buffer_pos=231, buffer_size=1028, blen=6, ioff=8\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=4, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161\nboundary (hex): 416142303378\n--- end probe ---\ninsufficient data: buffer_pos=4, required=8\n--- probe: return_not_enough_data ---\npp=0x55d802c7f820, state=2, buffer_pos=4, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161\nboundary (hex): 416142303378\n--- end probe ---\n--- probe: entry ---\npp=0x55d802c7f820, state=2, buffer_pos=231, buffer_size=1028, blen=6, ioff=0\nbuf (hex): 2d2d4161423033780d0a636f6e74656e742d646973706f736974696f6e3a20666f726d2d646174613b206e616d653d226669656c6431220d0a0d0a4a6f652042...\nboundary (hex): 416142303378\n--- end probe ---\nmemcmp results: cmp1=0 (-- vs buf[0..1]), cmp2=0 (buf[2..] vs boundary)\nboundary matched: advancing ioff by 8 to 8\n--- probe: success_boundary_found ---\npp=0x55\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown function 'buf' is only used for read-only operations (passed to memcmp and memchr and used in pointer arithmetic/subtraction) and never used to modify the underlying bytes. MISRA C 2023 Rule 8.13 requires that pointers should point to const-qualified types whenever possible, so 'buf' should be declared const char * (and the initializer cast changed to (const char *)&pp[1]) to reflect that intent. If there were a later need to mutate through 'buf' then a non-const pointer would be justified, but no such use appears in the provided code or execution log."
}