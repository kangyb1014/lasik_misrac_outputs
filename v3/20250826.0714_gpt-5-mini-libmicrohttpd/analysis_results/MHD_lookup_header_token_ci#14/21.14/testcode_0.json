{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nThe call passes 'token' (checked earlier as a C string: token != NULL and token[0] != 0) and 'pos->value' (header value, also a C string) into MHD_str_has_token_caseless_. If that function internally uses the Standard Library function memcmp to compare the null\u2011terminated token (or null\u2011terminated substrings of pos->value) \u2014 e.g. memcmp(p, token, token_len) == 0 or memcmp(token, p, token_len) == 0 \u2014 then Rule 21.14 is violated because memcmp is being used to compare null\u2011terminated strings.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_lookup_header_token_ci code that contains useful probe functions that print useful logs to a file \"/tmp/logs/148.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_lookup_header_token_ci as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_lookup_header_token_ci:\n```c\nstatic bool\nMHD_lookup_header_token_ci (const struct MHD_Connection *connection,\n                            const char *header,\n                            size_t header_len,\n                            const char *token,\n                            size_t token_len)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if ((NULL == connection) || (NULL == header) || (0 == header[0]) ||\n      (NULL == token) || (0 == token[0]))\n    return false;\n\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if ((0 != (pos->kind & MHD_HEADER_KIND)) &&\n        (header_len == pos->header_size) &&\n        ( (header == pos->header) ||\n          (MHD_str_equal_caseless_bin_n_ (header,\n                                          pos->header,\n                                          header_len)) ) &&\n        (MHD_str_has_token_caseless_ (pos->value, token, token_len)))\n      return true;\n  }\n  return false;\n}\n```\n</target_code>\nPlease provide the modified MHD_lookup_header_token_ci code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe logging helper: appends log lines to /tmp/logs/148.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/148.txt\", \"a\");\n    if (NULL == f)\n        return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nstatic bool\nMHD_lookup_header_token_ci (const struct MHD_Connection *connection,\n                            const char *header,\n                            size_t header_len,\n                            const char *token,\n                            size_t token_len)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  probe_log(\"ENTER: MHD_lookup_header_token_ci connection=%p header=%p header_len=%zu token=%p token_len=%zu\",\n            (const void *)connection,\n            (const void *)header,\n            header_len,\n            (const void *)token,\n            token_len);\n\n  if ((NULL == connection) || (NULL == header) || (0 == header[0]) ||\n      (NULL == token) || (0 == token[0]))\n  {\n    probe_log(\"EARLY RETURN: invalid input: connection=%p header=%p token=%p\",\n              (const void *)connection, (const void *)header, (const void *)token);\n    return false;\n  }\n\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    /* Log basic state of current header node */\n    probe_log(\"ITER: pos=%p kind=0x%08x header_size=%zu header_ptr=%p value_ptr=%p\",\n              (const void *)pos,\n              (unsigned int) pos->kind,\n              pos->header_size,\n              (const void *) pos->header,\n              (const void *) pos->value);\n\n    /* Preserve original short-circuit logic by checking conditions step by step, logging each decision */\n    if (0 == (pos->kind & MHD_HEADER_KIND))\n    {\n      probe_log(\"SKIP: pos kind mask not set (pos=%p)\", (const void *)pos);\n      continue;\n    }\n\n    if (header_len != pos->header_size)\n    {\n      probe_log(\"SKIP: header_len mismatch: expected=%zu pos->header_size=%zu\",\n                header_len, pos->header_size);\n      continue;\n    }\n\n    /* Check header identity or caseless equality */\n    bool header_matches = false;\n    if (header == pos->header)\n    {\n      header_matches = true;\n      probe_log(\"HEADER MATCH: pointer equality (header=%p pos->header=%p)\", (const void *)header, (const void *)pos->header);\n    }\n    else\n    {\n      header_matches = MHD_str_equal_caseless_bin_n_ (header, pos->header, header_len);\n      probe_log(\"HEADER MATCH: string caseless equality result=%d header=\\\"%.*s\\\" pos->header=\\\"%.*s\\\"\",\n                header_matches ? 1 : 0,\n                (int) header_len, header ? header : \"(null)\",\n                (int) header_len, pos->header ? pos->header : \"(null)\");\n    }\n\n    if (!header_matches)\n    {\n      probe_log(\"SKIP: header content not matching (pos=%p)\", (const void *)pos);\n      continue;\n    }\n\n    /* Log token and value characteristics before calling token check */\n    if (token != NULL)\n    {\n      size_t token_str_len = strlen(token); /* scenario states token is a C string; log its strlen for evidence */\n      probe_log(\"TOKEN INFO: token_ptr=%p token_len=%zu token_str_len=%zu token=\\\"%s\\\"\",\n                (const void *)token, token_len, token_str_len, token);\n    }\n    else\n    {\n      probe_log(\"TOKEN INFO: token is NULL\");\n    }\n\n    probe_log(\"VALUE INFO: pos->value_ptr=%p value=\\\"%s\\\"\",\n              (const void *) pos->value, pos->value ? pos->value : \"(null)\");\n\n    /* Now perform the token check (only reached when previous conditions are true) */\n    bool has_token = MHD_str_has_token_caseless_ (pos->value, token, token_len);\n    probe_log(\"MHD_str_has_token_caseless_ returned %d for pos=%p (token_ptr=%p)\", has_token ? 1 : 0, (const void *)pos, (const void *)token);\n\n    if (has_token)\n    {\n      probe_log(\"MATCH FOUND: pos=%p header=\\\"%.*s\\\" value=\\\"%s\\\" token=\\\"%s\\\"\",\n                (const void *)pos,\n                (int) pos->header_size, pos->header ? pos->header : \"(null)\",\n                pos->value ? pos->value : \"(null)\",\n                token ? token : \"(null)\");\n      return true;\n    }\n  }\n\n  probe_log(\"EXIT: no matching header token found\");\n  return false;\n}\n"
}