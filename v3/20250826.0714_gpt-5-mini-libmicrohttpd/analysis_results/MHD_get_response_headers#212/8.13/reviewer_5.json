{
  "user_message": "An agent A claimed that the following MHD_get_response_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_headers.\n```c\n_MHD_EXTERN int\nMHD_get_response_headers (struct MHD_Response *response,\n                          MHD_KeyValueIterator iterator,\n                          void *iterator_cls)\n{\n  int numHeaders = 0;\n  struct MHD_HTTP_Res_Header *pos;\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    numHeaders++;\n    if ((NULL != iterator) &&\n        (MHD_NO == iterator (iterator_cls,\n                             pos->kind,\n                             pos->header,\n                             pos->value)))\n      break;\n  }\n  return numHeaders;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'void *iterator_cls' is not const-qualified. If the iterator callback treats the context pointer as read-only (i.e. it only inspects data via iterator_cls and does not modify it), then the pointer should be declared as 'const void *iterator_cls'. In that common case the current declaration violates MISRA C 2023 Rule 8.13 because it fails to qualify the pointed-to type as const when possible.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_response_headers: entry; response=0x7f896c008e20, iterator=(nil), iterator_cls=(nil)\nMHD_get_response_headers: visiting header #1; header=MyHeader; value=MyValueToo; kind=1; pos=0x7f896c008fa0\nMHD_get_response_headers: exit; total_headers=1\nMHD_get_response_headers: entry; response=0x7f8964000b70, iterator=(nil), iterator_cls=(nil)\nMHD_get_response_headers: visiting header #1; header=MyHeader; value=MyValueToo; kind=1; pos=0x7f8964000cf0\nMHD_get_response_headers: exit; total_headers=1\nMHD_get_response_headers: entry; response=0x7f8954008e20, iterator=(nil), iterator_cls=(nil)\nMHD_get_response_headers: visiting header #1; header=MyHeader; value=MyValueToo; kind=1; pos=0x7f8954008fa0\nMHD_get_response_headers: exit; total_headers=1\nMHD_get_response_headers: entry; response=0x5628dfbd2310, iterator=(nil), iterator_cls=(nil)\nMHD_get_response_headers: visiting header #1; header=MyHeader; value=MyValueToo; kind=1; pos=0x5628dfbd75d0\nMHD_get_response_headers: exit; total_headers=1\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA R8.13 recommends adding const qualification when the pointed-to object is never modified, but qualification must be compatible across the API. In MHD_get_response_headers the iterator_cls argument is forwarded unchanged to the iterator callback (type MHD_KeyValueIterator) which, in the public API, is declared to accept a void * context. Changing only this function parameter to const void * would be incompatible with the callback type and with callers that expect to pass a mutable context. The implementation shown does not itself modify the context, but that alone does not make the current declaration a violation: the pointer cannot be made const in isolation without changing the callback/API. The runtime log (iterator == NULL) does not establish that the context is always read\u2011only in general. If the entire API (callback typedef and all callers) were changed to use const void * then R8.13 would favour that, but as written the report is not correct."
}