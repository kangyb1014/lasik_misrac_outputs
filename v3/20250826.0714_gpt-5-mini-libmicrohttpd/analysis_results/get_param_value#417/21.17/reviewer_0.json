{
  "user_message": "An agent A claimed that the following get_param_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_param_value.\n```c\nstatic enum PerfRepl_param_result\nget_param_value (const char *param_name, const char *param_tail,\n                 const char *next_param, unsigned int *param_value)\n{\n  const char *value_str;\n  size_t digits;\n  if (0 != param_tail[0])\n  {\n    if ('=' != param_tail[0])\n      value_str = param_tail;\n    else\n      value_str = param_tail + 1;\n  }\n  else\n    value_str = next_param;\n\n  if (NULL != value_str)\n    digits = mhd_tool_str_to_uint (value_str, param_value);\n  else\n    digits = 0;\n\n  if ((0 == digits) || (0 != value_str[digits]))\n  {\n    fprintf (stderr, \"Parameter '%s' is not followed by valid number.\\n\",\n             param_name);\n    return PERF_RPL_PARAM_ERROR;\n  }\n\n  if (0 != param_tail[0])\n    return PERF_RPL_PARAM_FULL_STR;\n\n  return PERF_RPL_PARAM_STR_PLUS_NEXT;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf mhd_tool_str_to_uint returns a count greater than the length of the string in value_str (for example because of a bug or unexpected return value), the expression value_str[digits] will index past the terminating NUL and access out of bounds. Although the code short-circuits when digits == 0 (protecting the value_str == NULL case), there is no guarantee here that digits <= strlen(value_str), so an out-of-bounds access is possible.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 21.17 specifically concerns the use of the standard <string.h> functions (memcpy/memmove/memset/memcmp/strcpy/strncpy/strcat/strncat/strlen/strspn, etc.) and requires that their use must not cause out\u2011of\u2011bounds accesses. The shown code does not call any <string.h> routine; it performs an array access value_str[digits] and calls a custom function mhd_tool_str_to_uint. The scenario describes a possible defect in mhd_tool_str_to_uint (it returning a count larger than the actual string length), which could indeed cause an out\u2011of\u2011bounds access \u2014 but that would be a bug in the helper function or a missing validation in this function, not a violation of Rule 21.17 as written.\n\nAlso, the code avoids indexing a NULL pointer: when value_str is NULL digits is set to 0 and the first disjunct (0 == digits) makes the condition true so value_str[digits] is not required. If you want to be defensive against a misbehaving mhd_tool_str_to_uint, add an explicit check that digits <= strlen(value_str) (or have mhd_tool_str_to_uint guarantee a bounded return) before indexing.\n"
}