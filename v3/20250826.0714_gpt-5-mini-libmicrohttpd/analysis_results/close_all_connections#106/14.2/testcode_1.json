{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.2.\nHere is the comment from the agent.\n<violation scenario>\nThe for loop uses 'pos' as the single loop counter: for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev). The third clause uses pos->prev. Inside the loop body the code unlocks the cleanup mutex and calls a join function (MHD_mutex_unlock_chk_, MHD_thread_handle_ID_join_thread_, MHD_mutex_lock_chk_). While the mutex is released and a thread is joined, other threads may modify the linked-list nodes (including the prev pointer of the node pointed to by pos). Those modifications occur as part of the behavior of functions called in the loop body, so the third clause reads an object (pos->prev) that can be modified during the loop body. This violates MISRA C 2023 Rule 14.2 (clause 3: the third clause shall modify only the loop counter and shall not use objects that are modified in the loop body).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified close_all_connections code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1064.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of close_all_connections as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of close_all_connections:\n```c\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    while (NULL != susp)\n    {\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}\n```\n</target_code>\nPlease provide the modified close_all_connections code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n/* Probe logging helper. Appends human-readable logs to /tmp/logs/1064.txt. */\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/1064.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* timestamp */\n  time_t t = time (NULL);\n  struct tm tm_buf;\n  if (0 == localtime_r (&t, &tm_buf))\n  {\n    /* fallback: do nothing */\n  }\n  else\n  {\n    char timestr[64];\n    if (strftime (timestr, sizeof (timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf) > 0)\n      fprintf (f, \"[%s] \", timestr);\n  }\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void\nlog_connection_state (struct MHD_Connection *pos, const char *tag)\n{\n  if (NULL == pos)\n  {\n    mhd_probe_log (\"%s: pos=NULL\", tag);\n    return;\n  }\n  /* Print key fields to help detect concurrent modification. */\n  mhd_probe_log (\"%s: pos=%p, pos->prev=%p, pos->thread_joined=%d, pos->tid=%lu, pos->socket_fd=%d\",\n                 tag,\n                 (void *) pos,\n                 (void *) pos->prev,\n                 (int) pos->thread_joined,\n                 (unsigned long) pos->tid,\n                 pos->socket_fd);\n}\n\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    while (NULL != susp)\n    {\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    mhd_probe_log (\"Entering upgraded-suspended-connections join loop: daemon=%p, suspended_tail=%p\",\n                   (void *) daemon,\n                   (void *) daemon->suspended_connections_tail);\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n\n      /* Log state at loop start */\n      log_connection_state (pos, \"upg_loop: start\");\n\n      if (! pos->thread_joined)\n      {\n        /* Snapshot prev before unlocking/join to detect concurrent change */\n        struct MHD_Connection *prev_before = pos->prev;\n        mhd_probe_log (\"upg_loop: about to unlock cleanup mutex for pos=%p; prev_before=%p, tid=%lu\",\n                       (void *) pos, (void *) prev_before, (unsigned long) pos->tid);\n\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n        mhd_probe_log (\"upg_loop: unlocked cleanup mutex for pos=%p (joining tid=%lu)\",\n                       (void *) pos, (unsigned long) pos->tid);\n\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n        {\n          mhd_probe_log (\"upg_loop: join FAILED for pos=%p tid=%lu\", (void *) pos, (unsigned long) pos->tid);\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        }\n\n        mhd_probe_log (\"upg_loop: join succeeded for pos=%p tid=%lu\", (void *) pos, (unsigned long) pos->tid);\n        pos->thread_joined = true;\n\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n\n        /* After re-acquiring the mutex, check whether the prev pointer changed. */\n        struct MHD_Connection *prev_after = pos->prev;\n        mhd_probe_log (\"upg_loop: after re-lock for pos=%p; prev_before=%p prev_after=%p\",\n                       (void *) pos, (void *) prev_before, (void *) prev_after);\n\n        /* Re-log the updated connection state */\n        log_connection_state (pos, \"upg_loop: after join\");\n      }\n    }\n    mhd_probe_log (\"Exiting upgraded-suspended-connections join loop\");\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      /* log each iteration's start state */\n      log_connection_state (pos, \"collect_threads_loop: start\");\n\n      if (! pos->thread_joined)\n      {\n        /* Snapshot prev to detect concurrent modifications */\n        struct MHD_Connection *prev_before = pos->prev;\n        mhd_probe_log (\"collect_threads_loop: unlocking for pos=%p prev_before=%p tid=%lu\",\n                       (void *) pos, (void *) prev_before, (unsigned long) pos->tid);\n\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n        {\n          mhd_probe_log (\"collect_threads_loop: join FAILED for pos=%p tid=%lu\", (void *) pos, (unsigned long) pos->tid);\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        }\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        mhd_probe_log (\"collect_threads_loop: restarted scan from connections_tail=%p\", (void *) pos);\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    mhd_probe_log (\"moving to cleanup: pos=%p\", (void *) pos);\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}\n"
}