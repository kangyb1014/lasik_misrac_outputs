{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of close_all_connections:\n```c\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    while (NULL != susp)\n    {\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n/* loop over suspended connections (uses MHD_PANIC inside) */\nsusp = daemon->suspended_connections_tail;\nwhile (NULL != susp)\n{\n  if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n  else if (used_tls &&\n           used_thr_p_c &&\n           (! susp->urh->clean_ready) )\n    shutdown (susp->urh->app.socket,\n              SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n  else\n  {\n    /* ... remainder of else block ... */\n  }\n  susp = susp->prev;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The loop body contains an if that calls MHD_PANIC when susp->urh == NULL, and subsequent else/else-if branches handle the case susp->urh != NULL. All branches are reachable depending on runtime values (susp->urh, used_tls, used_thr_p_c, susp->urh->clean_ready). Although MHD_PANIC likely does not return when invoked, that only makes the remainder of that particular iteration unreachable in that execution path \u2014 it does not make the code unreachable in all cases. The conditionals and preprocessor guards depend on runtime state or compilation options, so there is no statically unreachable code in this fragment."
}