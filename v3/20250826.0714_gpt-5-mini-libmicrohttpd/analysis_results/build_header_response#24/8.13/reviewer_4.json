{
  "user_message": "An agent A claimed that the following build_header_response code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of build_header_response.\n```c\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  mhd_assert (c->rp.props.set);\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          ! c->rp.props.chunked,\n                          (! c->rp.props.use_reply_body_headers) &&\n                          (0 ==\n                           (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)),\n                          use_conn_close,\n                          use_conn_k_alive))\n    return MHD_NO;\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes r which is declared as 'struct MHD_Response *const r' (a const pointer to a mutable object). If add_user_headers only reads the response (its prototype is, e.g., add_user_headers(char *buf, size_t *pos, size_t buf_size, struct MHD_Response *r, ...)) then the pointed-to type should be const-qualified. In that situation the code violates MISRA C 2023 Rule 8.13 because a pointer that need not allow modification of the pointee is not declared to point to a const-qualified type. Remediation: change the parameter and local declaration to use 'const struct MHD_Response *' (for example 'const struct MHD_Response *const r' and a prototype taking const struct MHD_Response *r).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- enter build_header_response ---\nconnection ptr: 0x556d1d5dddf0\nresponse ptr:   0x556d1d5e60c0\nkeepalive: 0\nrq.http_ver: 3\ndaemon->options: 41985\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- before add_user_headers ---\nconnection ptr: 0x556d1d5dddf0\nresponse ptr:   0x556d1d5e60c0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 41985\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\nCalling add_user_headers\n  buf: 0x556d1d5de0d0\n  pos: 71\n  buf_size: 32576\n  r: 0x556d1d5e60c0\n  send_headers_for_body: 1\n  need_content_length_header: 1\n  use_conn_close: 0\n  use_conn_k_alive: 0\n\n--- after add_user_headers ---\nconnection ptr: 0x556d1d5dddf0\nresponse ptr:   0x556d1d5e60c0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 41985\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- exit build_header_response ---\nconnection ptr: 0x556d1d5dddf0\nresponse ptr:   0x556d1d5e60c0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 41985\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- enter build_header_response ---\nconnection ptr: 0x556d1d5e6a80\nresponse ptr:   0x556d1d5e6cd0\nkeepalive: 0\nrq.http_ver: 3\ndaemon->options: 108033\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- before add_user_headers ---\nconnection ptr: 0x556d1d5e6a80\nresponse ptr:   0x556d1d5e6cd0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 108033\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\nCalling add_user_headers\n  buf: 0x556d1d5de0d0\n  pos: 71\n  buf_size: 32576\n  r: 0x556d1d5e6cd0\n  send_headers_for_body: 1\n  need_content_length_header: 1\n  use_conn_close: 0\n  use_conn_k_alive: 0\n\n--- after add_user_headers ---\nconnection ptr: 0x556d1d5e6a80\nresponse ptr:   0x556d1d5e6cd0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 108033\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- exit build_header_response ---\nconnection ptr: 0x556d1d5e6a80\nresponse ptr:   0x556d1d5e6cd0\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 108033\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- enter build_header_response ---\nconnection ptr: 0x556d1d5de090\nresponse ptr:   0x556d1d5e7290\nkeepalive: 0\nrq.http_ver: 3\ndaemon->options: 42497\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- before add_user_headers ---\nconnection ptr: 0x556d1d5de090\nresponse ptr:   0x556d1d5e7290\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 42497\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\nCalling add_user_headers\n  buf: 0x556d1d5e74f0\n  pos: 71\n  buf_size: 32576\n  r: 0x556d1d5e7290\n  send_headers_for_body: 1\n  need_content_length_header: 1\n  use_conn_close: 0\n  use_conn_k_alive: 0\n\n--- after add_user_headers ---\nconnection ptr: 0x556d1d5de090\nresponse ptr:   0x556d1d5e7290\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 42497\nrp.props.chunked: 0\nrp.props.use_reply_body_headers: 0\nr->flags: 0x00000000\nr->flags_auto: 0x00000001\nr->total_size: 0\nr->upgrade_handler: 0x556d03254af0\n\n--- exit build_header_response ---\nconnection ptr: 0x556d1d5de090\nresponse ptr:   0x556d1d5e7290\nkeepalive: 2\nrq.http_ver: 3\ndaemon->options: 42497\nrp.props.chunked: 0\nrp.props.use_reply\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in the presented scenario. In build_header_response the local alias r is only used for reads (inspect flags, flags_auto, total_size, upgrade_handler, etc.) and is passed to add_user_headers. The provided execution log shows that add_user_headers does not modify the response (the response fields are unchanged before and after the call). Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so r should be declared to point at const (e.g. const struct MHD_Response *const r) and any callee that only inspects the response should accept a const-qualified parameter (e.g. add_user_headers(..., const struct MHD_Response *r, ...)). Note: if any of the called functions actually modify the response object via that pointer (or if other code in this function intends to modify *r through r), then making r point-to-const would be incorrect; based on the code and the provided runtime trace, no such modifications are visible, so the reported MISRA 8.13 violation stands and the recommended remediation (add const to the pointee type in the local declaration and in callee prototypes) is appropriate."
}