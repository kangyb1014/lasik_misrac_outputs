{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nprobe_log_state (const struct MHD_Connection *const c,\n                 const struct MHD_Response *const r,\n                 const char *stage,\n                 const char *filename)\n{\n  FILE *f = fopen (filename, \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"--- %s ---\\n\", stage);\n  fprintf (f, \"connection ptr: %p\\n\", (const void *) c);\n  fprintf (f, \"response ptr:   %p\\n\", (const void *) r);\n  fprintf (f, \"keepalive: %u\\n\", (unsigned) c->keepalive);\n  fprintf (f, \"rq.http_ver: %u\\n\", (unsigned) c->rq.http_ver);\n  fprintf (f, \"daemon->options: %u\\n\", (unsigned) c->daemon->options);\n  fprintf (f, \"rp.props.set: %u\\n\", (unsigned) c->rp.props.set);\n  fprintf (f, \"rp.props.chunked: %u\\n\", (unsigned) c->rp.props.chunked);\n  fprintf (f, \"rp.props.use_reply_body_headers: %u\\n\",\n           (unsigned) c->rp.props.use_reply_body_headers);\n\n  /* Response-specific fields used in the decision tree */\n  fprintf (f, \"r->flags: 0x%08x\\n\", (unsigned) r->flags);\n  fprintf (f, \"r->flags_auto: 0x%08x\\n\", (unsigned) r->flags_auto);\n  fprintf (f, \"r->total_size: %llu\\n\", (unsigned long long) r->total_size);\n#ifdef UPGRADE_SUPPORT\n  fprintf (f, \"r->upgrade_handler: %p\\n\", (const void *) r->upgrade_handler);\n#endif\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nprobe_log_add_user_headers_call (const char *filename,\n                                 char *buf,\n                                 size_t pos,\n                                 size_t buf_size,\n                                 const struct MHD_Response *const r,\n                                 bool send_headers_for_body,\n                                 bool need_content_length_header,\n                                 bool use_conn_close,\n                                 bool use_conn_k_alive)\n{\n  FILE *f = fopen (filename, \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"Calling add_user_headers\\n\");\n  fprintf (f, \"  buf: %p\\n\", (void *) buf);\n  fprintf (f, \"  pos: %zu\\n\", pos);\n  fprintf (f, \"  buf_size: %zu\\n\", buf_size);\n  fprintf (f, \"  r: %p\\n\", (const void *) r);\n  fprintf (f, \"  send_headers_for_body: %u\\n\", (unsigned) send_headers_for_body);\n  fprintf (f, \"  need_content_length_header: %u\\n\", (unsigned) need_content_length_header);\n  fprintf (f, \"  use_conn_close: %u\\n\", (unsigned) use_conn_close);\n  fprintf (f, \"  use_conn_k_alive: %u\\n\", (unsigned) use_conn_k_alive);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  /* Log entry into the function with initial state */\n  probe_log_state (c, r, \"enter build_header_response\", \"/tmp/logs/243.txt\");\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  mhd_assert (c->rp.props.set);\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  /* Compute the boolean arguments for add_user_headers explicitly so we can\n   * log them. Keeping the exact expressions preserves program logic. */\n  bool arg_send_headers_for_body = ! c->rp.props.chunked;\n  bool arg_need_content_length_header = (! c->rp.props.use_reply_body_headers) &&\n                                        (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n\n  /* Log state immediately before calling add_user_headers to capture the\n   * fact that 'r' (a struct MHD_Response *const) is being passed to the\n   * function. This provides runtime evidence of the call and the relevant\n   * state that supports the violation scenario analysis. */\n  probe_log_state (c, r, \"before add_user_headers\", \"/tmp/logs/243.txt\");\n  probe_log_add_user_headers_call (\"/tmp/logs/243.txt\",\n                                  buf,\n                                  pos,\n                                  buf_size,\n                                  r,\n                                  arg_send_headers_for_body,\n                                  arg_need_content_length_header,\n                                  use_conn_close,\n                                  use_conn_k_alive);\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          arg_send_headers_for_body,\n                          arg_need_content_length_header,\n                          use_conn_close,\n                          use_conn_k_alive))\n  {\n    /* Log failure of add_user_headers to aid reproduction */\n    FILE *f = fopen (\"/tmp/logs/243.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"add_user_headers returned failure. pos=%zu, buf_size=%zu\\n\\n\",\n               pos, buf_size);\n      fclose (f);\n    }\n    return MHD_NO;\n  }\n\n  /* Log after successful add_user_headers call */\n  probe_log_state (c, r, \"after add_user_headers\", \"/tmp/logs/243.txt\");\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n\n  /* Log exit state */\n  probe_log_state (c, r, \"exit build_header_response\", \"/tmp/logs/243.txt\");\n\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nconnection.c:2491:60: error: no member named 'set' in 'struct MHD_Reply_Properties'\n 2491 |   fprintf (f, \"rp.props.set: %u\\n\", (unsigned) c->rp.props.set);\n      |                                                ~~~~~~~~~~~ ^\n1 error generated.\nmake[3]: *** [Makefile:2098: libmicrohttpd_la-connection.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of build_header_response as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void\nprobe_log_state (const struct MHD_Connection *const c,\n                 const struct MHD_Response *const r,\n                 const char *stage,\n                 const char *filename)\n{\n  FILE *f = fopen (filename, \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"--- %s ---\\n\", stage);\n  fprintf (f, \"connection ptr: %p\\n\", (const void *) c);\n  fprintf (f, \"response ptr:   %p\\n\", (const void *) r);\n  fprintf (f, \"keepalive: %u\\n\", (unsigned) c->keepalive);\n  fprintf (f, \"rq.http_ver: %u\\n\", (unsigned) c->rq.http_ver);\n  fprintf (f, \"daemon->options: %u\\n\", (unsigned) c->daemon->options);\n  fprintf (f, \"rp.props.chunked: %u\\n\", (unsigned) c->rp.props.chunked);\n  fprintf (f, \"rp.props.use_reply_body_headers: %u\\n\",\n           (unsigned) c->rp.props.use_reply_body_headers);\n\n  /* Response-specific fields used in the decision tree */\n  fprintf (f, \"r->flags: 0x%08x\\n\", (unsigned) r->flags);\n  fprintf (f, \"r->flags_auto: 0x%08x\\n\", (unsigned) r->flags_auto);\n  fprintf (f, \"r->total_size: %llu\\n\", (unsigned long long) r->total_size);\n#ifdef UPGRADE_SUPPORT\n  fprintf (f, \"r->upgrade_handler: %p\\n\", (const void *) r->upgrade_handler);\n#endif\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nprobe_log_add_user_headers_call (const char *filename,\n                                 char *buf,\n                                 size_t pos,\n                                 size_t buf_size,\n                                 const struct MHD_Response *const r,\n                                 bool send_headers_for_body,\n                                 bool need_content_length_header,\n                                 bool use_conn_close,\n                                 bool use_conn_k_alive)\n{\n  FILE *f = fopen (filename, \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"Calling add_user_headers\\n\");\n  fprintf (f, \"  buf: %p\\n\", (void *) buf);\n  fprintf (f, \"  pos: %zu\\n\", pos);\n  fprintf (f, \"  buf_size: %zu\\n\", buf_size);\n  fprintf (f, \"  r: %p\\n\", (const void *) r);\n  fprintf (f, \"  send_headers_for_body: %u\\n\", (unsigned) send_headers_for_body);\n  fprintf (f, \"  need_content_length_header: %u\\n\", (unsigned) need_content_length_header);\n  fprintf (f, \"  use_conn_close: %u\\n\", (unsigned) use_conn_close);\n  fprintf (f, \"  use_conn_k_alive: %u\\n\", (unsigned) use_conn_k_alive);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  /* Log entry into the function with initial state */\n  probe_log_state (c, r, \"enter build_header_response\", \"/tmp/logs/243.txt\");\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  /* The original code asserted that props were initialized via a member called\n     'set'. Some versions of the struct do not contain that member. Remove the\n     direct reference and rely on subsequent asserts that validate specific\n     properties used later. */\n\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  /* Compute the boolean arguments for add_user_headers explicitly so we can\n   * log them. Keeping the exact expressions preserves program logic. */\n  bool arg_send_headers_for_body = ! c->rp.props.chunked;\n  bool arg_need_content_length_header = (! c->rp.props.use_reply_body_headers) &&\n                                        (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n\n  /* Log state immediately before calling add_user_headers to capture the\n   * fact that 'r' (a struct MHD_Response *const) is being passed to the\n   * function. This provides runtime evidence of the call and the relevant\n   * state that supports the violation scenario analysis. */\n  probe_log_state (c, r, \"before add_user_headers\", \"/tmp/logs/243.txt\");\n  probe_log_add_user_headers_call (\"/tmp/logs/243.txt\",\n                                  buf,\n                                  pos,\n                                  buf_size,\n                                  r,\n                                  arg_send_headers_for_body,\n                                  arg_need_content_length_header,\n                                  use_conn_close,\n                                  use_conn_k_alive);\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          arg_send_headers_for_body,\n                          arg_need_content_length_header,\n                          use_conn_close,\n                          use_conn_k_alive))\n  {\n    /* Log failure of add_user_headers to aid reproduction */\n    FILE *f = fopen (\"/tmp/logs/243.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"add_user_headers returned failure. pos=%zu, buf_size=%zu\\n\\n\",\n               pos, buf_size);\n      fclose (f);\n    }\n    return MHD_NO;\n  }\n\n  /* Log after successful add_user_headers call */\n  probe_log_state (c, r, \"after add_user_headers\", \"/tmp/logs/243.txt\");\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n\n  /* Log exit state */\n  probe_log_state (c, r, \"exit build_header_response\", \"/tmp/logs/243.txt\");\n\n  return MHD_YES;\n}\n",
  "explanation": "The failure was caused by referencing a non-existent member rp.props.set. I removed the fprintf that printed that member and removed the direct assertion of props.set after setup_reply_properties. Instead, I kept the subsequent assertions that validate the specific properties actually used later (chunked, use_reply_body_headers, send_reply_body, etc.). No other logic was changed; this preserves the behavior while avoiding access to a removed/renamed struct member so the code will compile."
}