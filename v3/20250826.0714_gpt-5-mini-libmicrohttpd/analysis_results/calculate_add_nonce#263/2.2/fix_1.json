{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nmhd_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] \", (long) t);\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nmhd_log_hex (const char *label, const unsigned char *buf, size_t len)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] %s: \", (long) t, label);\n  for (size_t i = 0; i < len; ++i)\n    fprintf (f, \"%02x\", buf[i]);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nmhd_log_str (const char *label, const char *s, size_t len)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] %s: \", (long) t, label);\n  /* Print as a string safely up to len, replacing non-printables */\n  for (size_t i = 0; i < len; ++i)\n    {\n      unsigned char c = (unsigned char) s[i];\n      if (c >= 32 && c < 127)\n        fputc (c, f);\n      else\n        fprintf (f, \"\\\\x%02x\", c);\n    }\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  /* Log entry and key computed values */\n  mhd_log (\"calculate_add_nonce: entry connection=%p daemon=%p timestamp=%\" PRIu64 \" realm_len=%zu\",\n           (void *) connection, (void *) daemon, (uint64_t) timestamp, realm_len);\n  mhd_log (\"Calculated nonce_size=%zu (digest_size=%zu)\", nonce_size, (size_t) digest_get_size (da));\n\n  /* Record asserted invariants (without changing behavior of asserts) */\n  mhd_log (\"Pre-assert: da=%p hashing=%d\", (void *) da, (int) da->hashing);\n  mhd_log (\"Pre-assert: MAX_DIGEST_NONCE_LENGTH=%d nonce_size=%zu\", MAX_DIGEST_NONCE_LENGTH, nonce_size);\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  mhd_log (\"Calling calculate_nonce with timestamp=%\" PRIu64 \"\", (uint64_t) timestamp);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n  /* Log the generated nonce bytes (hex) and a best-effort printable form */\n  mhd_log_hex (\"Generated nonce (hex)\", (unsigned char *) nonce, nonce_size);\n  mhd_log_str (\"Generated nonce (as bytes)\", nonce, nonce_size);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n  {\n    mhd_log (\"digest_ext_error returned true -> returning false\");\n    return false;\n  }\n  else\n  {\n    mhd_log (\"digest_ext_error returned false\");\n  }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  mhd_log (\"daemon->nonce_nc_size=%zu\", (size_t) daemon->nonce_nc_size);\n  if (0 == daemon->nonce_nc_size)\n  {\n    mhd_log (\"nonce_nc_size == 0 -> returning false\");\n    return false;\n  }\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  size_t idx = get_nonce_nc_idx (daemon->nonce_nc_size,\n                                 nonce,\n                                 nonce_size);\n  mhd_log (\"Computed nonce index: %zu\", idx);\n\n  nn = daemon->nnc + idx;\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    mhd_log (\"Slot available: copying nonce into slot %zu\", idx);\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n    mhd_log_hex (\"Stored nonce (hex)\", (unsigned char *) nn->nonce, nonce_size);\n    mhd_log_str (\"Stored nonce (as bytes)\", nn->nonce, nonce_size);\n  }\n  else\n  {\n    ret = false;\n    mhd_log (\"Slot not available for index %zu -> ret=false\", idx);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  mhd_log (\"calculate_add_nonce: exit returning %d\", (int) ret);\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:1777:67: error: no member named 'hashing' in 'struct DigestAlgorithm'\n 1777 |   mhd_log (\"Pre-assert: da=%p hashing=%d\", (void *) da, (int) da->hashing);\n      |                                                               ~~  ^\n1 error generated.\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of calculate_add_nonce as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void\nmhd_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] \", (long) t);\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nmhd_log_hex (const char *label, const unsigned char *buf, size_t len)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] %s: \", (long) t, label);\n  for (size_t i = 0; i < len; ++i)\n    fprintf (f, \"%02x\", buf[i]);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nmhd_log_str (const char *label, const char *s, size_t len)\n{\n  FILE *f = fopen (\"/tmp/logs/2632.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time (NULL);\n  fprintf (f, \"[%ld] %s: \", (long) t, label);\n  /* Print as a string safely up to len, replacing non-printables */\n  for (size_t i = 0; i < len; ++i)\n    {\n      unsigned char c = (unsigned char) s[i];\n      if (c >= 32 && c < 127)\n        fputc (c, f);\n      else\n        fprintf (f, \"\\\\x%02x\", c);\n    }\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  /* Log entry and key computed values */\n  mhd_log (\"calculate_add_nonce: entry connection=%p daemon=%p timestamp=%\" PRIu64 \" realm_len=%zu\",\n           (void *) connection, (void *) daemon, (uint64_t) timestamp, realm_len);\n  mhd_log (\"Calculated nonce_size=%zu (digest_size=%zu)\", nonce_size, (size_t) digest_get_size (da));\n\n  /* Record asserted invariants (without changing behavior of asserts) */\n  /* Removed reference to da->hashing because DigestAlgorithm may not have that member. */\n  mhd_log (\"Pre-assert: da=%p\", (void *) da);\n  mhd_log (\"Pre-assert: MAX_DIGEST_NONCE_LENGTH=%d nonce_size=%zu\", MAX_DIGEST_NONCE_LENGTH, nonce_size);\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  mhd_log (\"Calling calculate_nonce with timestamp=%\" PRIu64 \"\", (uint64_t) timestamp);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n  /* Log the generated nonce bytes (hex) and a best-effort printable form */\n  mhd_log_hex (\"Generated nonce (hex)\", (unsigned char *) nonce, nonce_size);\n  mhd_log_str (\"Generated nonce (as bytes)\", nonce, nonce_size);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n  {\n    mhd_log (\"digest_ext_error returned true -> returning false\");\n    return false;\n  }\n  else\n  {\n    mhd_log (\"digest_ext_error returned false\");\n  }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  mhd_log (\"daemon->nonce_nc_size=%zu\", (size_t) daemon->nonce_nc_size);\n  if (0 == daemon->nonce_nc_size)\n  {\n    mhd_log (\"nonce_nc_size == 0 -> returning false\");\n    return false;\n  }\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  size_t idx = get_nonce_nc_idx (daemon->nonce_nc_size,\n                                 nonce,\n                                 nonce_size);\n  mhd_log (\"Computed nonce index: %zu\", idx);\n\n  nn = daemon->nnc + idx;\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    mhd_log (\"Slot available: copying nonce into slot %zu\", idx);\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n    mhd_log_hex (\"Stored nonce (hex)\", (unsigned char *) nn->nonce, nonce_size);\n    mhd_log_str (\"Stored nonce (as bytes)\", nn->nonce, nonce_size);\n  }\n  else\n  {\n    ret = false;\n    mhd_log (\"Slot not available for index %zu -> ret=false\", idx);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  mhd_log (\"calculate_add_nonce: exit returning %d\", (int) ret);\n\n  return ret;\n}\n",
  "explanation": "The compile error was caused by referencing a non-existent member da->hashing in struct DigestAlgorithm. I replaced the logging call that referenced da->hashing with a safer log that only prints the pointer: mhd_log (\"Pre-assert: da=%p\", (void *) da); This preserves the original logic and assertions while removing the invalid member access that caused the build failure."
}