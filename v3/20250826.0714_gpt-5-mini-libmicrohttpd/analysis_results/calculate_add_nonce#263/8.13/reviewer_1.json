{
  "user_message": "An agent A claimed that the following calculate_add_nonce code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce.\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes several pointers where const qualification appears appropriate but the called function likely accepts non-const pointers. In particular, struct DigestAlgorithm *da is passed although calculate_nonce appears to only read algorithm data (earlier code used da only for digest_get_size and assertions). If calculate_nonce does not modify the DigestAlgorithm object, its parameter should be declared const (const struct DigestAlgorithm *da). Similarly, string/byte inputs such as connection->rq.http_mthd, connection->rq.method, daemon->digest_auth_random, connection->addr and connection->rq.url should be const-qualified in calculate_nonce's prototype if they are not modified by it. Realm is already const and nonce is an output buffer (must remain non-const). Without the calculate_nonce prototype we cannot be 100% certain, but the likely violation is that non-const pointer parameters (notably da) should be const-qualified \u2014 so Rule 8.13 is violated.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Summary: Agent A\u2019s report is speculative and cannot be confirmed from the snippet alone. The MISRA 2023 Rule 8.13 says pointers should point to const-qualified types whenever possible. Inside calculate_add_nonce the function does not itself modify the DigestAlgorithm object nor the input buffers it passes to calculate_nonce \u2014 so, from the local view, declaring da and some of the input pointers as pointer-to-const would be more const-correct and would satisfy Rule 8.13 for this function.\n\nWhy the report is not proven correct: whether Rule 8.13 is actually violated depends on the callee(s) and overall use. calculate_add_nonce forwards da and several buffer pointers to calculate_nonce. If calculate_nonce (or any other function called with those pointers) modifies the DigestAlgorithm object or any of those buffers, then the non-const parameter types are required and there is no MISRA violation here. The snippet shows uses of da only for reads (assert and digest_get_size) but also contains an assert on da->hashing and later checks digest_ext_error(da) \u2014 which could hint that calculate_nonce or other digest routines may update state in da. Without the prototype/definition of calculate_nonce and the definition/usage contract of struct DigestAlgorithm (and of the other called functions), you cannot conclude a definite violation.\n\nRecommendation: inspect the prototype/definition of calculate_nonce and any other functions that receive these pointers, and inspect whether they modify the pointed-to objects. If they do not modify them, change the parameter types to const (e.g. const struct DigestAlgorithm *da and const char * for input buffers) across all declarations and callers. If they do modify them, the current non-const types are appropriate and Rule 8.13 is not violated.\n"
}