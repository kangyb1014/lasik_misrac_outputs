{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 14.3.\nHere is the comment from the agent.\n<violation scenario>\nThe controlling expression 'if (! use_poll)' depends on the local variable 'use_poll' which is declared as 'const bool use_poll = ...' and is initialized once before the loop and never modified. Therefore the condition is invariant across loop iterations (in the case HAVE_POLL not defined it is even a compile-time constant). This is not one of the permitted exceptions (not an infinite-loop invariant nor the allowed do-while case), so it violates MISRA C 2023 Rule 14.3.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified thread_main_handle_connection code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1265.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of thread_main_handle_connection as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of thread_main_handle_connection:\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\nPlease provide the modified thread_main_handle_connection code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/* Probe logging helpers: write control-flow and state to /tmp/logs/1265.txt */\nstatic void probe_logf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/1265.txt\", \"a\");\n  if (NULL == f)\n    return;\n  {\n    va_list ap;\n    va_start (ap, fmt);\n    vfprintf (f, fmt, ap);\n    va_end (ap);\n  }\n  fflush (f);\n  fclose (f);\n}\n\nstatic void probe_log_state (const struct MHD_Connection *con,\n                             const struct MHD_Daemon *daemon,\n                             const bool use_poll,\n                             const bool was_suspended,\n                             const bool use_zero_timeout,\n                             const char *note)\n{\n  probe_logf (\n    \"%s: use_poll=%d was_suspended=%d use_zero_timeout=%d connection_timeout_ms=%lld event_loop_info=%d socket_fd=%lld daemon_itc_valid=%d\\n\",\n    (note != NULL) ? note : \"state\",\n    (int) use_poll,\n    (int) was_suspended,\n    (int) use_zero_timeout,\n    (long long) con->connection_timeout_ms,\n    (int) con->event_loop_info,\n    (long long) con->socket_fd,\n    (int) MHD_ITC_IS_VALID_ (daemon->itc));\n}\n\nstatic MHD_THRD_RTRN_TYPE_  MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n\n  /* Log initial state (captures the invariant use_poll initialization) */\n  probe_log_state (con, daemon, use_poll, was_suspended, false, \"INIT\");\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    /* Log each loop iteration arrival (note that use_poll is expected to be invariant) */\n    probe_logf (\"LOOP_ENTER: daemon->shutdown=%d con->state=%d use_poll=%d\\n\",\n                (int) daemon->shutdown,\n                (int) con->state,\n                (int) use_poll);\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      probe_logf (\"SUSPENDED_BRANCH_ENTER: use_poll=%d\\n\", (int) use_poll);\n      if (! use_poll)\n      {\n        probe_logf (\"SUSPENDED_SELECT_PATH (use_poll==false) before FD_ZERO / add / select\\n\");\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n          probe_logf (\"SUSPENDED_SELECT_PATH: MHD_add_to_fd_set_ failed - goto exit\\n\");\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          {\n            probe_logf (\"SUSPENDED_SELECT_PATH: select interrupted (EINTR), continue\\n\");\n            continue;\n          }\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          probe_logf (\"SUSPENDED_SELECT_PATH: select error %d, breaking\\n\", err);\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        probe_logf (\"SUSPENDED_POLL_PATH (use_poll==true) before poll\\n\");\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          {\n            probe_logf (\"SUSPENDED_POLL_PATH: poll interrupted (EINTR), continue\\n\");\n            continue;\n          }\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          probe_logf (\"SUSPENDED_POLL_PATH: poll error, breaking\\n\");\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      probe_logf (\"SUSPENDED_BRANCH_WAIT_COMPLETE: resume signaled, continue loop\\n\");\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      probe_logf (\"WAS_SUSPENDED_POST_PROCESS: updating last activity and handling idle\\n\");\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n\n    /* Log decision point that depends on invariant 'use_poll' */\n    probe_log_state (con, daemon, use_poll, was_suspended, use_zero_timeout, \"BEFORE_SELECT_OR_POLL\");\n\n    if (! use_poll)\n    {\n      /* use select */\n      probe_logf (\"TAKING_SELECT_BRANCH because use_poll==false\\n\");\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        probe_logf (\"EVENT_LOOP_INFO_CLEANUP reached - goto exit\\n\");\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        probe_logf (\"SELECT_BRANCH: err_state set while adding FDs - goto exit\\n\");\n        goto exit;\n      }\n\n      probe_logf (\"SELECT_BRANCH: calling select(maxsock+1=%lld) tvp=%p\\n\", (long long) (maxsock + 1), (void *) tvp);\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        {\n          probe_logf (\"SELECT_BRANCH: select EINTR, continue\\n\");\n          continue;\n        }\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        probe_logf (\"SELECT_BRANCH: select error %d, breaking\\n\", err);\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      probe_logf (\"SELECT_BRANCH: calling call_handlers fdset states: read=%d write=%d exc=%d\\n\",\n                  FD_ISSET (con->socket_fd, &rs),\n                  FD_ISSET (con->socket_fd, &ws),\n                  FD_ISSET (con->socket_fd, &es));\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n      {\n        probe_logf (\"SELECT_BRANCH: call_handlers returned MHD_NO - goto exit\\n\");\n        goto exit;\n      }\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      probe_logf (\"TAKING_POLL_BRANCH because use_poll==true\\n\");\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        probe_logf (\"POLL_BRANCH: EVENT_LOOP_INFO_CLEANUP reached - goto exit\\n\");\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      probe_logf (\"POLL_BRANCH: calling poll(timeout_val=%d)\\n\", timeout_val);\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n        {\n          probe_logf (\"POLL_BRANCH: poll EINTR, continue\\n\");\n          continue;\n        }\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        probe_logf (\"POLL_BRANCH: poll error, breaking\\n\");\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      probe_logf (\"POLL_BRANCH: calling call_handlers revents: read=%d write=%d err=%d\\n\",\n                  (int) (0 != (p[0].revents & POLLIN)),\n                  (int) (0 != (p[0].revents & POLLOUT)),\n                  (int) (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)));\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n      {\n        probe_logf (\"POLL_BRANCH: call_handlers returned MHD_NO - goto exit\\n\");\n        goto exit;\n      }\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      probe_logf (\"UPGRADE_PATH: connection upgraded, returning thread\\n\");\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n  {\n    probe_logf (\"CLOSING_CONNECTION: daemon->shutdown=%d con->state=%d\\n\", (int) daemon->shutdown, (int) con->state);\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  }\n  MHD_connection_handle_idle (con);\nexit:\n  probe_logf (\"EXIT_LABEL reached: cleaning up response/socket and signaling daemon\\n\");\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n    probe_logf (\"EXIT_LABEL: failed to signal thread termination via ITC\\n\");\n  }\n  probe_logf (\"THREAD_RETURN: returning from thread_main_handle_connection\\n\");\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n"
}