{
  "user_message": "An agent A claimed that the following MHD_socket_create_listen_ code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_socket_create_listen_.\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen the project is built with MHD_WINSOCK_SOCKETS and WSA_FLAG_NO_HANDLE_INHERIT defined (the Windows branch), cloexec_set is unconditionally set to true (!0). Therefore the test if (!cloexec_set) is always false and the call to MHD_socket_noninheritable_(fd) can never be executed (unreachable). A similar unreachable case can occur on POSIX builds if SOCK_CLOEXEC_OR_ZERO is a non\u2011zero constant, making cloexec_set always true.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nafter_posix_socket_init: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nbefore_noninheritable_check: fd=0x3, cloexec_set=1, nosigpipe_set=-1\nreturning_valid_socket: fd=0x3, cloexec_set=1, nosigpipe_set=-1\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA Rule 2.1 forbids code that is unreachable in all possible executions of the project. The reported if (!cloexec_set) / MHD_socket_noninheritable_(fd) call is not unreachable in all executions. Although in some build/run combinations the initial socket call may set cloexec_set to true (so that particular run will skip the call), there exists a reachable execution path that makes cloexec_set false: if the platform-specific socket creation (e.g. WSASocket or the SOCK_CLOEXEC variant) returns MHD_INVALID_SOCKET, the code falls back to the second socket() call and explicitly sets cloexec_set = 0. In that fallback case the if (!cloexec_set) branch can be taken, so the code is reachable. The provided execution log only shows runs where the initial socket succeeded (cloexec_set == 1) \u2014 that does not prove the branch is impossible. Therefore the claim of a Rule 2.1 violation is incorrect."
}