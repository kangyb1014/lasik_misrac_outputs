{
  "user_message": "An agent A claimed that the following MHD_socket_create_listen_ code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_socket_create_listen_.\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression (! cloexec_set) can be invariant depending on build-time configuration. For example, when MHD_WINSOCK_SOCKETS && WSA_FLAG_NO_HANDLE_INHERIT is defined, cloexec_set is set to !0 (i.e. 1) so (! cloexec_set) is always false; similarly, in the fallback branch cloexec_set = 0 so (! cloexec_set) is always true. In these configurations the if condition is invariant, which violates MISRA C 2023 Rule 14.3 (no applicable exceptions).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=10 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=10 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=3 cloexec_set=1 nosigpipe_set=-1 extra=0\nstage=after_init_flags pf=2 fd=4 cloexec_set=1 nosigpipe_set=-\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The controlling expression if (! cloexec_set) can be invariant for particular build configurations because cloexec_set is unconditionally assigned a compile-time constant in some #if branches and is not modified between that assignment and the if. Examples:\n- In the WINSOCK branch cloexec_set = !0 (i.e. 1) so (! cloexec_set) is always false for that build.\n- In the fallback branch cloexec_set = 0 so (! cloexec_set) is always true for that build (unless later overwritten by the conditional fallback socket creation, but in the common successful-socket path it remains constant).\n\nMISRA C:2023 Rule 14.3 forbids invariant controlling expressions (except the listed exceptions, which do not apply here). The condition here is not an allowed exception and can be a compile-time invariant depending on configuration, so the reported violation is correct. If the intent is to avoid a violation, the code should either make the test conditional on the same preprocessor symbols (so it is omitted when known-invariant), compute the value in a way that can vary at runtime, or document/audit and formally deviate from the rule."
}