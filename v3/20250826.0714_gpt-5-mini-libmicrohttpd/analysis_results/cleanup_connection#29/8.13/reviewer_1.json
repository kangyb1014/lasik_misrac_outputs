{
  "user_message": "An agent A claimed that the following cleanup_connection code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of cleanup_connection.\n```c\nstatic void\ncleanup_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (connection->in_cleanup)\n    return; /* Prevent double cleanup. */\n  connection->in_cleanup = true;\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if (connection->suspended)\n  {\n    DLL_remove (daemon->suspended_connections_head,\n                daemon->suspended_connections_tail,\n                connection);\n    connection->suspended = false;\n  }\n  else\n  {\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n      if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      else\n        XDLL_remove (daemon->manual_timeout_head,\n                     daemon->manual_timeout_tail,\n                     connection);\n    }\n    DLL_remove (daemon->connections_head,\n                daemon->connections_tail,\n                connection);\n  }\n  DLL_insert (daemon->cleanup_head,\n              daemon->cleanup_tail,\n              connection);\n  connection->resuming = false;\n  connection->in_idle = false;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* if we were at the connection limit before and are in\n       thread-per-connection mode, signal the main thread\n       to resume accepting connections */\n    if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n         (! MHD_itc_activate_ (daemon->itc, \"c\")) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal end of connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis call passes a string literal (via _()) to MHD_DLOG. If MHD_DLOG (or the _ macro/gettext) is declared to take a plain char * (non-const), then the pointer parameter is not const-qualified even though the argument is an immutable string literal \u2014 violating MISRA C 2023 Rule 8.13. Example violating declaration: void MHD_DLOG(struct MHD_Daemon *d, char *msg); or char *_(const char *s); (returning non-const).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e121e0 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e121e0 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: inserted_into_cleanup ---\nconnection=0x55f493e121e0 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=0\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e13670 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e13670 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: inserted_into_cleanup ---\nconnection=0x55f493e13670 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=0\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e138c0 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e138c0 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: inserted_into_cleanup ---\nconnection=0x55f493e138c0 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=0\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e13b10 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e13b10 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: inserted_into_cleanup ---\nconnection=0x55f493e13b10 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=0\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e13d60 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e13d60 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: inserted_into_cleanup ---\nconnection=0x55f493e13d60 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=0\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: entry ---\nconnection=0x55f493e13fb0 daemon=0x55f493e118d0\n  in_cleanup=0 suspended=0 resuming=0 in_idle=1\n  connection_timeout_ms=5000\n  daemon->connection_timeout_ms=5000\n-------------------------------\n\n--- cleanup_connection probe: removed_from_connections ---\nconnection=0x55f493e13fb0 daemon=0x55f493e118d0\n  in_cleanup=1 suspended=0 resuming=0 in_idle=1\n  conn\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim is not proven by the snippet alone. MISRA C:2023 Rule 8.13 concerns declarations (a pointer should point to a const-qualified type whenever possible). The call site in cleanup_connection simply passes the result of _(...) to MHD_DLOG. Whether that is a Rule 8.13 violation depends entirely on the declarations of _ (or gettext) and MHD_DLOG: a violation would exist only if those functions are (improperly, per MISRA) declared to take a non-const char * while the data is effectively immutable. The source shown does not include those declarations, so you cannot conclude there is a violation from this code alone. In practice, many gettext implementations historically return char * and many logging APIs take char *; if those prototypes are non-const, the declarations would be what violates 8.13 (not this call site). If you can change the API, the proper fix is to declare/define _ and MHD_DLOG to use const char * for immutable strings."
}