{
  "user_message": "An agent A claimed that the following MHD_ip_limit_del code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_ip_limit_del.\n```c\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable nodep is declared as void ** (pointer to a non-const pointer). The pointer returned by tfind is only used for read access (the code never modifies *nodep), so nodep should point to a const-qualified type (for example: void * const *nodep, or const void * const *nodep) to express that the pointed-to pointer/data are not modified. Declaring nodep as void ** therefore violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55e1e7b50430, addrlen=16\ndaemon->per_ip_connection_limit=0\nAfter MHD_get_master: master daemon=0x55e1e7b4f8d0\nNo per-ip limit (0) \u2014 returning early\nENTER MHD_ip_limit_del: daemon=0x55e1e7b4f8d0, addr=0x55\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The local variable nodep is declared as void ** but the code only reads *nodep (it never modifies the pointer stored at *nodep). MISRA C 2023 Rule 8.13 advises that a pointer should point to a const-qualified type whenever possible \u2014 i.e., the pointed-to object should be const if it is not modified. In this case nodep should therefore be declared so that the pointed-to pointer is const (for example: void * const *nodep, or another appropriate const-qualified form matching the tfind/tsearch API and intent). \n\nNote: changing the declaration will likely require a cast when assigning the result of tfind (depending on the platform/header prototypes), but that is an API/compatibility issue; it does not remove the correctness of the agent A\u2019s observation that the current declaration does not adhere to Rule 8.13."
}