{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe daemon object is passed as const, but the member custom_error_log_cls is (presumably) declared as a pointer to a non-const type (e.g. void *custom_error_log_cls). Accessing daemon->custom_error_log_cls therefore yields a pointer that is top-level const (void * const) but which points to a non-const type. Rule 8.13 requires pointers to point to const-qualified types when possible, so the member should be declared as const void *custom_error_log_cls (and the callback should accept a const void *), or the API adjusted otherwise.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_DLOG code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1283.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_DLOG as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_DLOG:\n```c\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n```\n</target_code>\nPlease provide the modified MHD_DLOG code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/* Probe helper: append diagnostic information to /tmp/logs/1283.txt.\n   This function intentionally reads the same members used by MHD_DLOG\n   to capture the control flow and the state that is relevant to the\n   reported Rule 8.13 scenario.\n\n   It preserves the original program logic and only observes members;\n   it does not modify daemon nor any of its members. */\nstatic void\nmhd_dlog_probe_write(const struct MHD_Daemon *daemon,\n                     const char *phase,\n                     const char *format,\n                     int callback_invoked)\n{\n  FILE *f = fopen(\"/tmp/logs/1283.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Print basic control flow marker and pointers/flags. */\n  fprintf(f, \"MHD_DLOG probe: phase=%s\\n\", phase);\n  fprintf(f, \"  daemon=%p\\n\", (const void *)daemon);\n  fprintf(f, \"  format_ptr=%p\\n\", (const void *)format);\n  fprintf(f, \"  format_text=\\\"%s\\\"\\n\", (format != NULL) ? format : \"(null)\");\n\n  /* options is an unsigned integer in the real struct; print as unsigned long\n     to get a portable numeric display. */\n  fprintf(f, \"  options=0x%08lx\\n\", (unsigned long)daemon->options);\n\n  /* Report whether the error-log option appears set (matches the runtime check). */\n  fprintf(f, \"  MHD_USE_ERROR_LOG bit set=%d\\n\", (int)((daemon->options & MHD_USE_ERROR_LOG) != 0));\n\n  /* Do not attempt to convert function pointers to void* (implementation-defined).\n     Instead report whether the callback pointer is NULL/non-NULL. */\n  fprintf(f, \"  custom_error_log_is_non_null=%d\\n\", (int)(daemon->custom_error_log != NULL));\n\n  /* The member custom_error_log_cls is the subject of the top-level const vs\n     pointee-const discussion. Print its pointer value (as a pointer-sized value).\n     Casting to const void * only observes the address and does not attempt to\n     change qualifications of the pointed-to type. */\n  fprintf(f, \"  custom_error_log_cls_ptr=%p\\n\", (const void *)daemon->custom_error_log_cls);\n\n  /* Indicate whether the callback was actually invoked in this call. */\n  fprintf(f, \"  callback_invoked=%d\\n\", callback_invoked);\n\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\n\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  /* Log entry and the state observed at function entry. */\n  mhd_dlog_probe_write(daemon, \"entry\", format, 0);\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n  {\n    /* Log early exit (error logging not enabled). */\n    mhd_dlog_probe_write(daemon, \"exit_no_error_log\", format, 0);\n    return;\n  }\n\n  va_start (va, format);\n\n  /* Log just before invoking the custom error log callback.  Do not\n     inspect va here (to avoid changing its state) \u2014 we only record that\n     we are about to invoke the callback and the observed pointers/flags. */\n  mhd_dlog_probe_write(daemon, \"before_callback\", format, 0);\n\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n\n  va_end (va);\n\n  /* Log after callback invocation. */\n  mhd_dlog_probe_write(daemon, \"after_callback\", format, 1);\n}\n"
}