{
  "user_message": "An agent A claimed that the following setup_epoll_to_listen code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of setup_epoll_to_listen.\n```c\nstatic enum MHD_Result\nsetup_epoll_to_listen (struct MHD_Daemon *daemon)\n{\n  struct epoll_event event;\n  MHD_socket ls;\n\n  mhd_assert (MHD_D_IS_USING_EPOLL_ (daemon));\n  mhd_assert (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) || \\\n               MHD_ITC_IS_VALID_ (daemon->itc) );\n  daemon->epoll_fd = setup_epoll_fd (daemon);\n  if (! MHD_D_IS_USING_THREADS_ (daemon)\n      && (0 != (daemon->options & MHD_USE_AUTO)))\n  {\n    /* Application requested \"MHD_USE_AUTO\", probably MHD_get_fdset() will be\n       used.\n       Make sure that epoll FD is suitable for fd_set.\n       Actually, MHD_get_fdset() is allowed for MHD_USE_EPOLL direct,\n       but most probably direct requirement for MHD_USE_EPOLL means that\n       epoll FD will be used directly. This logic is fuzzy, but better\n       than nothing with current MHD API. */\n    if (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->epoll_fd, daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"The epoll FD is too large to be used with fd_set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n  }\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (0 != (MHD_ALLOW_UPGRADE & daemon->options))\n  {\n    daemon->epoll_upgrade_fd = setup_epoll_fd (daemon);\n    if (MHD_INVALID_SOCKET == daemon->epoll_upgrade_fd)\n      return MHD_NO;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (epoll_itc_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        MHD_itc_r_fd_ (daemon->itc),\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe sub-expression (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) inside the mhd_assert performs an assignment to the local variable ls only for the purpose of the assertion. Later in the function ls is assigned again before any use. Thus, when the assertion is executed (e.g. in debug builds) the assignment is a redundant operation whose removal would not affect program behaviour \u2014 it is dead code. (Even if mhd_assert is compiled out in release builds, the fact that the assignment can be executed and is redundant when it is executed means Rule 2.2 is violated.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nafter_top_assert: daemon=0x56516f171a40 ls=-2\nbefore_listen_check: daemon=0x56516f171a40 ls=-2\ninside_listen_block_after_assignment: daemon=0x56516f171a40 ls=3\nafter_top_assert: daemon=0x56516f172060 ls=-2\nbefore_listen_check: daemon=0x56516f172060 ls=-2\ninside_listen_block_after_assignment: daemon=0x56516f172060 ls=3\nafter_top_assert: daemon=0x56516f172308 ls=-2\nbefore_listen_check: daemon=0x56516f172308 ls=-2\ninside_listen_block_after_assignment: daemon=0x56516f172308 ls=3\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The assignment (ls = daemon->listen_fd) that appears inside the third mhd_assert is executed in assertion-enabled builds and its only effect is to set the local variable ls for the purpose of the assertion\u2019s boolean expression. ls is then assigned again in the later if-condition before any use. Therefore the earlier assignment has no effect on program behaviour when it is executed \u2014 it is redundant. Under MISRA C 2023 Rule 2.2 (\u201cA project shall not contain dead code\u201d), an operation that is executed but whose removal would not affect program behaviour is dead code; the assert-time assignment meets that definition.\n\nNotes/caveats: if reading daemon->listen_fd had observable side-effects (e.g. it is volatile or the getter has side-effects) or if the mhd_assert macro used the evaluated value in some logging side-effect, then the situation could differ. From the presented code and typical assert semantics, however, the assignment is a redundant operation and constitutes dead code. A simple remedy is to avoid performing assignments inside the assertion expression \u2014 for example, perform a single ls = daemon->listen_fd at the start of the function (and use that value both in the assert and later) or change the assert to test daemon->listen_fd without assigning to ls."
}