{
  "user_message": "An agent A claimed that the following MHD_check_response_header_token_ci code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_check_response_header_token_ci.\n```c\nbool\nMHD_check_response_header_token_ci (const struct MHD_Response *response,\n                                    const char *key,\n                                    size_t key_len,\n                                    const char *token,\n                                    size_t token_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if ( (NULL == key) ||\n       ('\\0' == key[0]) ||\n       (NULL == token) ||\n       ('\\0' == token[0]) )\n    return false;\n\n  /* Token must not contain binary zero! */\n  mhd_assert (strlen (token) == token_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ( (pos->kind == MHD_HEADER_KIND) &&\n         (key_len == pos->header_size) &&\n         MHD_str_equal_caseless_bin_n_ (pos->header,\n                                        key,\n                                        key_len) &&\n         MHD_str_has_token_caseless_ (pos->value,\n                                      token,\n                                      token_len) )\n      return true;\n  }\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(token) assumes token is null-terminated. If token points to a buffer of length token_len that is not null-terminated (e.g. a substring or binary buffer), strlen will read past the buffer until a NUL is found, causing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17. The use of mhd_assert here does not prevent the unsafe access when assertions are enabled (and if assertions are disabled the check is omitted altogether).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call to strlen(token) assumes token is null\u2011terminated and will scan memory until it finds a NUL. If the caller passed a buffer whose valid length is token_len and it is not NUL\u2011terminated (e.g. a substring or binary buffer), strlen can read past the end of that buffer, causing an out\u2011of\u2011bounds access. That is exactly what MISRA C:2023 Rule 21.17 forbids (use of string.h functions must not result in accesses beyond the bounds of the referenced objects).\n\nThe fact the strlen call is wrapped in mhd_assert does not avoid the problem: when assertions are enabled the unsafe access can occur at runtime, and when assertions are disabled the check is omitted \u2014 either way the presence of strlen that can read out of bounds makes the code non\u2011compliant with 21.17. A safe alternative is to avoid strlen here and instead use bounded operations (for example, check for embedded NULs with memchr(token, '\\0', token_len) or otherwise rely solely on the provided length without calling strlen)."
}