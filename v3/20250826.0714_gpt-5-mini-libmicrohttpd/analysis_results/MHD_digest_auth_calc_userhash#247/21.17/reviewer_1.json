{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userhash code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userhash.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the caller passes realm == NULL (or passes a pointer to a character array that is not NUL-terminated within its allocated bounds), the call strlen(realm) will read beyond the valid object (or dereference a NULL pointer). The function does not check realm for NULL or otherwise ensure it is NUL-terminated before calling strlen, so this can result in out-of-bounds access.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_digest_auth_calc_userhash: entry\n  algo3=66\n  username_ptr=0x5638405ca0fa\n  realm_ptr=0x5638405ca122\n  userhash_bin_ptr=0x7ffe12dbffe0\n  bin_buf_size=31\n  digest_get_size=32\n  comparing digest_get_size > bin_buf_size -> true\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_NO\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=66\n  username_ptr=0x5638405ca0fa\n  realm_ptr=0x5638405ca122\n  userhash_bin_ptr=0x7ffe12dbffe0\n  bin_buf_size=0\n  digest_get_size=32\n  comparing digest_get_size > bin_buf_size -> true\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_NO\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=68\n  username_ptr=0x5638405ca0fa\n  realm_ptr=0x5638405ca122\n  userhash_bin_ptr=0x7ffe12dbffe0\n  bin_buf_size=31\n  digest_get_size=32\n  comparing digest_get_size > bin_buf_size -> true\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_NO\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=68\n  username_ptr=0x5638405ca0fa\n  realm_ptr=0x5638405ca122\n  userhash_bin_ptr=0x7ffe12dbffe0\n  bin_buf_size=0\n  digest_get_size=32\n  comparing digest_get_size > bin_buf_size -> true\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_NO\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3171\n  realm_ptr=0x559c2b1c318e\n  userhash_bin_ptr=0x7ffc4bb73af0\n  bin_buf_size=16\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3171\n    realm_ptr=0x559c2b1c318e\n    NOTE: the next operations will call strlen(username) and strlen(realm) as in the original code\n  calc_userhash returned; provisional ret=MHD_YES\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_YES\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3171\n  realm_ptr=0x559c2b1c318e\n  userhash_bin_ptr=0x7ffc4bb73a00\n  bin_buf_size=32\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3171\n    realm_ptr=0x559c2b1c318e\n    NOTE: the next operations will call strlen(username) and strlen(realm) as in the original code\n  calc_userhash returned; provisional ret=MHD_YES\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_YES\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3173\n  realm_ptr=0x559c2b1c317c\n  userhash_bin_ptr=0x7ffc4bb73af0\n  bin_buf_size=16\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3173\n    realm_ptr=0x559c2b1c317c\n    NOTE: the next operations will call strlen(username) and strlen(realm) as in the original code\n  calc_userhash returned; provisional ret=MHD_YES\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_YES\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3173\n  realm_ptr=0x559c2b1c317c\n  userhash_bin_ptr=0x7ffc4bb73a00\n  bin_buf_size=32\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3173\n    realm_ptr=0x559c2b1c317c\n    NOTE: the next operations will call strlen(username) and strlen(realm) as in the original code\n  calc_userhash returned; provisional ret=MHD_YES\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_YES\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3186\n  realm_ptr=0x559c2b1c3190\n  userhash_bin_ptr=0x7ffc4bb73af0\n  bin_buf_size=16\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3186\n    realm_ptr=0x559c2b1c3190\n    NOTE: the next operations will call strlen(username) and strlen(realm) as in the original code\n  calc_userhash returned; provisional ret=MHD_YES\nMHD_digest_auth_calc_userhash: exit -> ret=MHD_YES\n\nMHD_digest_auth_calc_userhash: entry\n  algo3=65\n  username_ptr=0x559c2b1c3186\n  realm_ptr=0x559c2b1c3190\n  userhash_bin_ptr=0x7ffc4bb73a00\n  bin_buf_size=32\n  digest_get_size=16\n  comparing digest_get_size > bin_buf_size -> false\n  about to call calc_userhash\n    username_ptr=0x559c2b1c3186\n    realm_ptr=0x559c2b1c3190\n    NOTE: the next operations will call strlen(\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls strlen(username) and strlen(realm) without validating that those pointer parameters are non-NULL and refer to NUL-terminated character arrays. strlen requires a valid pointer to a NUL-terminated object; if a caller passes realm == NULL (or a pointer to memory that is not NUL-terminated within its bounds) the strlen call will dereference beyond the object (or dereference NULL), which is exactly the sort of out-of-bounds access MISRA C 2023 Rule 21.17 forbids. The execution log only shows cases where valid pointers were passed, but that does not eliminate the potential violation in the code. Note: if the external API contract for MHD_digest_auth_calc_userhash explicitly and verifiably requires username and realm to be non-NULL and NUL-terminated and that contract is enforced by callers, the use could be acceptable; absent such an enforced contract or in-function validation, the code violates 21.17. Recommended fixes: check parameters for NULL and validate lengths before calling strlen, or require/enforce and document the precondition and/or use bounded string APIs that take lengths."
}