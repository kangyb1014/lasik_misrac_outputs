{
  "user_message": "An agent A claimed that the following get_unquoted_param code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen param->quoted is false the code sets unquoted->str = param->value.str. The source storage comes from a const-qualified parameter (param is const struct ... *), so the pointer returned is effectively pointing to data that should be treated as read-only. Assigning that to a non-const char * (unquoted->str) allows modification through the pointer and thus fails the 'pointer should point to a const-qualified type whenever possible' requirement. To comply, unquoted->str should be declared as const char * (or an explicit justification/cast provided where mutation is required).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA 8.13 asks that pointers point to const-qualified types when that is possible \u2014 i.e. when the pointed-to object is inherently read-only. In this function unquoted->str must sometimes point to a mutable buffer (the result of get_buffer_for_size and MHD_str_unquote) and sometimes to the existing parameter value. Because the pointer needs to refer to mutable storage in the quoted case it cannot be declared const char * without forcing casts in the mutable case.\n\nAlso, the fact that the function parameter is declared as const struct MHD_RqDAuthParam *param does not automatically make the pointee type of param->value.str a const-qualified char *. The const applies to the struct object (preventing modification of its members through param), not to the type that value.str points at unless value.str itself is declared as const char * in the struct. Assigning param->value.str (whose declared type is presumably char *) to unquoted->str (char *) is therefore type-correct and not a violation of 8.13. If value.str were declared as const char * in the struct, then copying it into a non-const char * would indeed discard const and should be fixed; but that is a property of the struct definition, not of this assignment alone.\n\nTherefore, given the function must yield a pointer that can refer to mutable storage in the quoted case, the reported violation is not valid."
}