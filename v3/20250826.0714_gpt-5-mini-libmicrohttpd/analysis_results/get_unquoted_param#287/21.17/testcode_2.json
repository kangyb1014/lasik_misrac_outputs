{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: MHD_str_unquote(param->value.str, param->value.len, str) may internally call standard <string.h> functions (e.g. memcpy/strcpy/strncpy) and either read or write out of bounds. Example specific scenario: get_buffer_for_size returns a buffer of size param->value.len (N). If MHD_str_unquote does memcpy(str, param->value.str, N) and then appends a terminating '\\0' it writes N+1 bytes into an N-sized buffer (write out-of-bounds). Or if MHD_str_unquote uses strcpy on a non-NUL-terminated source it can read beyond param->value.str + param->value.len (read out-of-bounds). Because the callee\u2019s behavior and its use of standard string.h functions are not shown, this call can lead to accesses beyond object bounds and thus violates MISRA C 2023 Rule 21.17 unless MHD_str_unquote is proven to respect both source and destination bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_unquoted_param code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2879.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_unquoted_param as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_unquoted_param:\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\nPlease provide the modified get_unquoted_param code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe logging helpers. These keep the original logic intact and only\n   append information to /tmp/logs/2879.txt for post-mortem analysis. */\nstatic void mhd_probe_log_printf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2879.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nstatic void mhd_probe_log_hex_snippet(const char *label, const char *buf, size_t buflen)\n{\n    size_t i;\n    const size_t max_snippet = 32u;\n    size_t n = (buflen < max_snippet) ? buflen : max_snippet;\n    mhd_probe_log_printf(\"%s: (len=%zu) first %zu bytes:\", label, buflen, n);\n    for (i = 0; i < n; ++i)\n    {\n        /* print as two-digit hex */\n        mhd_probe_log_printf(\"%02x\", (unsigned char)buf[i]);\n    }\n    if (buflen > n)\n        mhd_probe_log_printf(\"... (truncated)\");\n}\n\n/* Modified get_unquoted_param with probes. Original logic preserved. */\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* Log entry state */\n  mhd_probe_log_printf(\"ENTER get_unquoted_param: param=%p, value.str=%p, value.len=%zu, quoted=%d\",\n                       (const void *)param,\n                       (const void *)param->value.str,\n                       (size_t)param->value.len,\n                       (int)param->quoted);\n  mhd_probe_log_printf(\"tmp1=%p, ptmp2=%p, ptmp2_size=%p\",\n                       (void *)tmp1, (void *)ptmp2, (void *)ptmp2_size);\n  if (ptmp2_size != NULL)\n  {\n    mhd_probe_log_printf(\"*ptmp2_size=%zu\", (size_t)*ptmp2_size);\n  }\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    mhd_probe_log_printf(\"UNQUOTED (no quotes): returning original pointer %p len=%zu\",\n                         (void *)unquoted->str, (size_t)unquoted->len);\n    /* log a safe snippet of the source bytes */\n    mhd_probe_log_hex_snippet(\"source_snippet\", param->value.str, param->value.len);\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  mhd_probe_log_printf(\"QUOTED: requesting buffer for size=%zu\", (size_t)param->value.len);\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  mhd_probe_log_printf(\"get_buffer_for_size returned str=%p\", (void *)str);\n  if (ptmp2_size != NULL)\n  {\n    mhd_probe_log_printf(\"after alloc: *ptmp2_size=%zu\", (size_t)*ptmp2_size);\n  }\n\n  if (NULL == str)\n  {\n    mhd_probe_log_printf(\"Allocation failed: param->value.len=%zu, AUTH_MAX=%u\",\n                         (size_t)param->value.len,\n                         (unsigned)_MHD_AUTH_DIGEST_MAX_PARAM_SIZE);\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n  }\n\n  /* Before calling the unquote routine, log the relevant pointers and lengths. */\n  mhd_probe_log_printf(\"Calling MHD_str_unquote(src=%p, src_len=%zu, dst=%p)\",\n                       (void *)param->value.str, (size_t)param->value.len, (void *)str);\n  /* Log a safe snippet of the source bytes (will not read past param->value.len) */\n  mhd_probe_log_hex_snippet(\"source_snippet_before_unquote\", param->value.str, param->value.len);\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n\n  /* After unquote, log resulting length and destination buffer pointer. */\n  mhd_probe_log_printf(\"MHD_str_unquote returned len=%zu\", (size_t)len);\n  mhd_probe_log_printf(\"destination buffer ptr=%p\", (void *)str);\n\n  /* Log a safe snippet of the destination bytes. We limit the read to the lesser of\n     param->value.len and the available ptmp2_size (if provided) to avoid reading\n     beyond allocated destination storage while probing. */\n  if (ptmp2_size != NULL)\n  {\n    size_t safe_len = (param->value.len < *ptmp2_size) ? param->value.len : *ptmp2_size;\n    mhd_probe_log_hex_snippet(\"dest_snippet_after_unquote\", str, safe_len);\n  }\n  else\n  {\n    /* We don't know the allocated size; only log up to the returned len (which should be safe)\n       but guard to a small cap to avoid large dumps. */\n    size_t safe_len = (len < 32u) ? len : 32u;\n    mhd_probe_log_hex_snippet(\"dest_snippet_after_unquote_unknown_size\", str, safe_len);\n  }\n\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  mhd_probe_log_printf(\"EXIT get_unquoted_param: success, unquoted->str=%p, unquoted->len=%zu\",\n                       (void *)unquoted->str, (size_t)unquoted->len);\n  return _MHD_UNQ_OK;\n}\n"
}