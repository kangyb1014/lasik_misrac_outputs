{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strlen(value) can read beyond the bounds of the object pointed to by value if value is NULL or not terminated by a NUL character. For example, if the caller passes a non-NUL-terminated buffer or NULL, strlen(value) will scan out-of-bounds (or dereference NULL), violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified del_response_header_connection code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2209.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of del_response_header_connection as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of del_response_header_connection:\n```c\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;\n  if (0 == hdr->value_size)\n  {\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n  }\n  else\n  {\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }\n  }\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified del_response_header_connection code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <time.h>\n#include <inttypes.h>\n\n/* Probe logging helper: append human-readable logs to /tmp/logs/2209.txt */\nstatic void probe_log_printf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2209.txt\", \"a\");\n  if (!f)\n    return;\n\n  time_t t = time(NULL);\n  struct tm tm_buf;\n#if defined(_WIN32)\n  localtime_s(&tm_buf, &t);\n#else\n  localtime_r(&t, &tm_buf);\n#endif\n  char timestr[32];\n  if (0 == strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n    timestr[0] = '\\0';\n\n  fprintf(f, \"[%s] \", timestr);\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n/* Modified function with inserted probes. Original logic is preserved; probes only log state. */\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  probe_log_printf(\"enter del_response_header_connection: response=%p value=%p\",\n                   (void *) response, (const void *) value);\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  probe_log_printf(\"MHD_get_response_element_n_ returned hdr=%p\", (void *) hdr);\n\n  if (NULL == hdr)\n  {\n    probe_log_printf(\"no Connection header found; returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  probe_log_printf(\"hdr=%p hdr->value=%p hdr->value_size=%zu response->flags_auto=0x%llx\",\n                   (void *) hdr, (void *) hdr->value, hdr->value_size,\n                   (unsigned long long) response->flags_auto);\n\n  probe_log_printf(\"about to call strlen(value) with value=%p\", (const void *) value);\n  if (NULL == value)\n    probe_log_printf(\"value is NULL (strlen(value) will dereference NULL if called)\");\n\n  /* Original call retained: this is the site reported to potentially read beyond bounds. */\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n  {\n    probe_log_printf(\"MHD_str_remove_tokens_caseless_ returned false; hdr->value_size=%zu\",\n                     hdr->value_size);\n    return MHD_NO;\n  }\n\n  probe_log_printf(\"MHD_str_remove_tokens_caseless_ returned true; hdr->value_size=%zu\",\n                   hdr->value_size);\n\n  if (0 == hdr->value_size)\n  {\n    probe_log_printf(\"hdr->value_size == 0: removing header and freeing resources\");\n    _MHD_remove_header (response, hdr);\n    probe_log_printf(\"_MHD_remove_header called\");\n    free (hdr->value);\n    probe_log_printf(\"freed hdr->value\");\n    free (hdr->header);\n    probe_log_printf(\"freed hdr->header\");\n    free (hdr);\n    probe_log_printf(\"freed hdr\");\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    probe_log_printf(\"updated response->flags_auto after removal: 0x%llx\",\n                     (unsigned long long) response->flags_auto);\n  }\n  else\n  {\n    probe_log_printf(\"hdr->value_size != 0: null-terminating at index %zu (hdr->value=%p)\",\n                     hdr->value_size, (void *) hdr->value);\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    probe_log_printf(\"null-termination done; hdr->value[hdr->value_size]=0\");\n\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      probe_log_printf(\"response->flags_auto indicates more than just HAS_CONNECTION_CLOSE (flags_auto=0x%llx)\",\n                       (unsigned long long) response->flags_auto);\n\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        probe_log_printf(\"hdr->value_size equals length of \\\"close\\\"; comparing first %zu bytes\",\n                         (size_t) MHD_STATICSTR_LEN_ (\"close\"));\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n        {\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n          probe_log_printf(\"memcmp != 0: cleared HAS_CONNECTION_CLOSE; new flags_auto=0x%llx\",\n                           (unsigned long long) response->flags_auto);\n        }\n        else\n        {\n          probe_log_printf(\"memcmp == 0: hdr->value equals \\\"close\\\"\");\n        }\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        probe_log_printf(\"hdr->value_size > length of \\\"close, \\\"; comparing first %zu bytes\",\n                         (size_t) MHD_STATICSTR_LEN_ (\"close, \"));\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n        {\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n          probe_log_printf(\"memcmp != 0 for \\\"close, \\\": cleared HAS_CONNECTION_CLOSE; new flags_auto=0x%llx\",\n                           (unsigned long long) response->flags_auto);\n        }\n        else\n        {\n          probe_log_printf(\"memcmp == 0 for \\\"close, \\\"\");\n        }\n      }\n      else\n      {\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n        probe_log_printf(\"other case: cleared HAS_CONNECTION_CLOSE; new flags_auto=0x%llx\",\n                         (unsigned long long) response->flags_auto);\n      }\n    }\n  }\n\n  probe_log_printf(\"exiting del_response_header_connection with MHD_YES; response=%p final_flags=0x%llx\",\n                   (void *) response, (unsigned long long) response->flags_auto);\n  return MHD_YES;\n}\n"
}