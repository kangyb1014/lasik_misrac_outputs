{
  "user_message": "An agent A claimed that the following is_reply_body_needed code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_reply_body_needed.\n```c\nstatic enum replyBodyUse\nis_reply_body_needed (struct MHD_Connection *connection,\n                      unsigned int rcode)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n\n  mhd_assert (100 <= rcode);\n  mhd_assert (999 >= rcode);\n\n  if (199 >= rcode)\n    return RP_BODY_NONE;\n\n  if (MHD_HTTP_NO_CONTENT == rcode)\n    return RP_BODY_NONE;\n\n#if 0\n  /* This check is not needed as upgrade handler is used only with code 101 */\n#ifdef UPGRADE_SUPPORT\n  if (NULL != rp.response->upgrade_handler)\n    return RP_BODY_NONE;\n#endif /* UPGRADE_SUPPORT */\n#endif\n\n#if 0\n  /* CONNECT is not supported by MHD */\n  /* Successful responses for connect requests are filtered by\n   * MHD_queue_response() */\n  if ( (MHD_HTTP_MTHD_CONNECT == c->rq.http_mthd) &&\n       (2 == rcode / 100) )\n    return false; /* Actually pass-through CONNECT is not supported by MHD */\n#endif\n\n  /* Reply body headers could be used.\n   * Check whether reply body itself must be used. */\n\n  if (MHD_HTTP_MTHD_HEAD == c->rq.http_mthd)\n    return RP_BODY_HEADERS_ONLY;\n\n  if (MHD_HTTP_NOT_MODIFIED == rcode)\n    return RP_BODY_HEADERS_ONLY;\n\n  /* Reply body must be sent. The body may have zero length, but body size\n   * must be indicated by headers ('Content-Length:' or\n   * 'Transfer-Encoding: chunked'). */\n  return RP_BODY_SEND;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local alias is declared as 'struct MHD_Connection *const c = connection;' so the pointer points to a non-const-qualified type. In the fragment only read access is performed (c->rq.http_mthd), so the pointer could and should be declared to point to a const-qualified type (for example 'const struct MHD_Connection *const c'). Therefore Rule 8.13 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: conn=0x55dd5bc04df0 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55dd5bc04df0 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x55dd5bc0da80 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55dd5bc0da80 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x55dd5bc05090 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55dd5bc05090 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f138c001070 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f138c001070 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f138c000b70 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f138c000b70 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f138c000b70 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f138c000b70 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f138c000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f138c000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f1394000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x55c03df2d610 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55c03df2d610 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x55c03df2f2a0 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55c03df2f2a0 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x55c03df2d8b0 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x55c03df2d8b0 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bcc000b90 rcode=101 http_mthd=1 decision=RP_BODY_NONE (rcode<=199)\nENTRY: conn=0x7f4bd4000b90 rcode=101 http_mthd=1 decision=(pending)\nBRANCH: conn=0x7f4bd4000b90 rcode=101 http_mthd=1 \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the function the local alias is declared as \"struct MHD_Connection *const c = connection;\" (a const pointer to a mutable object) but the code only reads from the object (c->rq.http_mthd etc.). MISRA C 2023 Rule 8.13 recommends that pointers should point to a const\u2011qualified type whenever possible, so the alias should be declared to point to a const qualified type, for example:\n\n  const struct MHD_Connection *const c = connection;\n\n(or better, make the parameter itself const if the function never modifies the object). If the function later needs to modify the object or pass it to an API that requires a non\u2011const pointer, then adding const would be inappropriate; given the shown fragment, however, making the pointed\u2011to type const is possible and therefore the reported violation is valid."
}