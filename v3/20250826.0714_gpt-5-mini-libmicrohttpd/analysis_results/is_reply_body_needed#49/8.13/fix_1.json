{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nmhd_assert (int cond)\n{\n  if (!cond)\n    {\n      FILE *f = fopen(\"/tmp/logs/493.txt\", \"a\");\n      if (f)\n        {\n          fprintf (f, \"mhd_assert failed\\n\");\n          fclose (f);\n        }\n      abort ();\n    }\n}\nstatic void\nlog_probe (const struct MHD_Connection *const c, unsigned int rcode, const char *event)\n{\n  FILE *f = fopen (\"/tmp/logs/493.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  if (NULL == c)\n    {\n      fprintf (f, \"%s: connection=NULL, rcode=%u\\n\", event, rcode);\n    }\n  else\n    {\n      fprintf (f, \"%s: connection=%p, rq.http_mthd=%d, rcode=%u\\n\",\n               event, (const void *) c, c->rq.http_mthd, rcode);\n    }\n\n  fclose (f);\n}\n\nstatic enum replyBodyUse\nis_reply_body_needed (struct MHD_Connection *connection,\n                      unsigned int rcode)\n{\n  /* Keep the original local alias that is the subject of the reported\n   * violation: a const pointer to a non-const pointee. This is intentionally\n   * left as in the original code to allow reproduction of the rule 8.13\n   * scenario. */\n  struct MHD_Connection *const c = connection; /**< a short alias */\n\n  /* Log entry into the function with initial state. */\n  log_probe (c, rcode, \"enter\");\n\n  mhd_assert (100 <= rcode);\n  mhd_assert (999 >= rcode);\n\n  if (199 >= rcode)\n    {\n      log_probe (c, rcode, \"early_return_RP_BODY_NONE_1\");\n      return RP_BODY_NONE;\n    }\n\n  if (MHD_HTTP_NO_CONTENT == rcode)\n    {\n      log_probe (c, rcode, \"early_return_RP_BODY_NONE_2_NO_CONTENT\");\n      return RP_BODY_NONE;\n    }\n\n#if 0\n  /* This check is not needed as upgrade handler is used only with code 101 */\n#ifdef UPGRADE_SUPPORT\n  if (NULL != rp.response->upgrade_handler)\n    return RP_BODY_NONE;\n#endif /* UPGRADE_SUPPORT */\n#endif\n\n#if 0\n  /* CONNECT is not supported by MHD */\n  /* Successful responses for connect requests are filtered by\n   * MHD_queue_response() */\n  if ( (MHD_HTTP_MTHD_CONNECT == c->rq.http_mthd) &&\n       (2 == rcode / 100) )\n    return false; /* Actually pass-through CONNECT is not supported by MHD */\n#endif\n\n  /* Reply body headers could be used.\n   * Check whether reply body itself must be used. */\n\n  if (MHD_HTTP_MTHD_HEAD == c->rq.http_mthd)\n    {\n      log_probe (c, rcode, \"return_RP_BODY_HEADERS_ONLY_head_method\");\n      return RP_BODY_HEADERS_ONLY;\n    }\n\n  if (MHD_HTTP_NOT_MODIFIED == rcode)\n    {\n      log_probe (c, rcode, \"return_RP_BODY_HEADERS_ONLY_not_modified\");\n      return RP_BODY_HEADERS_ONLY;\n    }\n\n  /* Reply body must be sent. The body may have zero length, but body size\n   * must be indicated by headers ('Content-Length:' or\n   * 'Transfer-Encoding: chunked'). */\n  log_probe (c, rcode, \"return_RP_BODY_SEND\");\n  return RP_BODY_SEND;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nconnection.c:2147:1: error: expected identifier or '('\n 2147 | mhd_assert (int cond)\n      | ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nconnection.c:2147:1: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nconnection.c:2147:1: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\nconnection.c:2147:1: error: expected ')'\n 2147 | mhd_assert (int cond)\n      | ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nconnection.c:2147:1: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2098: libmicrohttpd_la-connection.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of is_reply_body_needed as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n\n/* Minimal stand-ins for types/constants used by the function so this\n * translation unit compiles independently. These are not macros (per\n * the constraints) and are only intended to allow compilation of the\n * test code. */\n\nstruct MHD_Connection\n{\n  struct { int http_mthd; } rq;\n};\n\nenum replyBodyUse { RP_BODY_NONE, RP_BODY_HEADERS_ONLY, RP_BODY_SEND };\n\nstatic const unsigned int MHD_HTTP_NO_CONTENT = 204u;\nstatic const unsigned int MHD_HTTP_NOT_MODIFIED = 304u;\nstatic const int MHD_HTTP_MTHD_HEAD = 3; /* arbitrary distinct value */\n\n/* Renamed the local assert helper to avoid colliding with a possible\n * mhd_assert macro from included headers. The original logic is\n * preserved, but the function name differs so the macro does not\n * expand and break the definition. */\nstatic void\nmhd_assert_local (int cond)\n{\n  if (!cond)\n    {\n      FILE *f = fopen(\"/tmp/logs/493.txt\", \"a\");\n      if (f)\n        {\n          fprintf (f, \"mhd_assert failed\\n\");\n          fclose (f);\n        }\n      abort ();\n    }\n}\n\nstatic void\nlog_probe (const struct MHD_Connection *const c, unsigned int rcode, const char *event)\n{\n  FILE *f = fopen (\"/tmp/logs/493.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  if (NULL == c)\n    {\n      fprintf (f, \"%s: connection=NULL, rcode=%u\\n\", event, rcode);\n    }\n  else\n    {\n      fprintf (f, \"%s: connection=%p, rq.http_mthd=%d, rcode=%u\\n\",\n               event, (const void *) c, c->rq.http_mthd, rcode);\n    }\n\n  fclose (f);\n}\n\nstatic enum replyBodyUse\nis_reply_body_needed (struct MHD_Connection *connection,\n                      unsigned int rcode)\n{\n  /* Keep the original local alias that is the subject of the reported\n   * violation: a const pointer to a non-const pointee. This is intentionally\n   * left as in the original code to allow reproduction of the rule 8.13\n   * scenario. */\n  struct MHD_Connection *const c = connection; /**< a short alias */\n\n  /* Log entry into the function with initial state. */\n  log_probe (c, rcode, \"enter\");\n\n  /* Call the renamed assert helper to avoid macro collisions. */\n  mhd_assert_local (100 <= rcode);\n  mhd_assert_local (999 >= rcode);\n\n  if (199 >= rcode)\n    {\n      log_probe (c, rcode, \"early_return_RP_BODY_NONE_1\");\n      return RP_BODY_NONE;\n    }\n\n  if (MHD_HTTP_NO_CONTENT == rcode)\n    {\n      log_probe (c, rcode, \"early_return_RP_BODY_NONE_2_NO_CONTENT\");\n      return RP_BODY_NONE;\n    }\n\n#if 0\n  /* This check is not needed as upgrade handler is used only with code 101 */\n#ifdef UPGRADE_SUPPORT\n  if (NULL != rp.response->upgrade_handler)\n    return RP_BODY_NONE;\n#endif /* UPGRADE_SUPPORT */\n#endif\n\n#if 0\n  /* CONNECT is not supported by MHD */\n  /* Successful responses for connect requests are filtered by\n   * MHD_queue_response() */\n  if ( (MHD_HTTP_MTHD_CONNECT == c->rq.http_mthd) &&\n       (2 == rcode / 100) )\n    return false; /* Actually pass-through CONNECT is not supported by MHD */\n#endif\n\n  /* Reply body headers could be used.\n   * Check whether reply body itself must be used. */\n\n  if (MHD_HTTP_MTHD_HEAD == c->rq.http_mthd)\n    {\n      log_probe (c, rcode, \"return_RP_BODY_HEADERS_ONLY_head_method\");\n      return RP_BODY_HEADERS_ONLY;\n    }\n\n  if (MHD_HTTP_NOT_MODIFIED == rcode)\n    {\n      log_probe (c, rcode, \"return_RP_BODY_HEADERS_ONLY_not_modified\");\n      return RP_BODY_HEADERS_ONLY;\n    }\n\n  /* Reply body must be sent. The body may have zero length, but body size\n   * must be indicated by headers ('Content-Length:' or\n   * 'Transfer-Encoding: chunked'). */\n  log_probe (c, rcode, \"return_RP_BODY_SEND\");\n  return RP_BODY_SEND;\n}\n",
  "explanation": "The compilation error was caused by a name collision with an existing mhd_assert macro from an included header. I renamed the local assert function to mhd_assert_local and updated the two calls accordingly so the macro does not expand into an invalid function definition. To make this translation unit self-contained and compilable, I also added minimal type and constant definitions (struct MHD_Connection, enum replyBodyUse, and relevant HTTP constants) instead of using macros. No macros were defined in the fix, and the original logic of is_reply_body_needed was preserved."
}