{
  "user_message": "An agent A claimed that the following internal_get_fdset2 code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of internal_get_fdset2.\n```c\nstatic enum MHD_Result\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     int fd_setsize)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  enum MHD_Result result = MHD_YES;\n  MHD_socket ls;\n  bool itc_added;\n\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize;  /* Mute compiler warning */\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (daemon->shutdown)\n    return MHD_YES;\n\n  /* The order of FDs added is important for W32 sockets as W32 fd_set has\n     limits for number of added FDs instead of the limit for the higher\n     FD value. */\n\n  /* Add ITC FD first. The daemon must be able to respond on application\n     commands issued in other threads. */\n  itc_added = false;\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize);\n    if (! itc_added)\n      result = MHD_NO;\n  }\n\n  ls = daemon->was_quiesced ? MHD_INVALID_SOCKET : daemon->listen_fd;\n  if (! itc_added &&\n      (MHD_INVALID_SOCKET != ls))\n  {\n    /* Add listen FD if ITC was not added. Listen FD could be used to signal\n       the daemon shutdown. */\n    if (MHD_add_to_fd_set_ (ls,\n                            read_fd_set,\n                            max_fd,\n                            fd_setsize))\n      ls = MHD_INVALID_SOCKET;   /* Already added */\n    else\n      result = MHD_NO;\n  }\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n  {\n    posn = pos->prev;\n\n    switch (pos->event_loop_info)\n    {\n    case MHD_EVENT_LOOP_INFO_READ:\n    case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_WRITE:\n      if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                write_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n      if (NULL != except_fd_set)\n        (void) MHD_add_to_fd_set_ (pos->socket_fd,\n                                   except_fd_set,\n                                   max_fd,\n                                   fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n      break;\n    case MHD_EVENT_LOOP_INFO_PROCESS:\n      if ( (NULL == except_fd_set) ||\n           ! MHD_add_to_fd_set_ (pos->socket_fd,\n                                 except_fd_set,\n                                 max_fd,\n                                 fd_setsize))\n        result = MHD_NO;\n      break;\n    case MHD_EVENT_LOOP_INFO_CLEANUP:\n      /* this should never happen */\n      break;\n    }\n  }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  if (NULL != except_fd_set)\n  {\n    for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n  }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (1)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      if (MHD_NO ==\n          urh_to_fdset (urh,\n                        read_fd_set,\n                        write_fd_set,\n                        except_fd_set,\n                        max_fd,\n                        fd_setsize))\n        result = MHD_NO;\n    }\n  }\n#endif\n\n  if (MHD_INVALID_SOCKET != ls)\n  {\n    /* The listen socket is present and hasn't been added */\n    if ((daemon->connections < daemon->connection_limit) &&\n        ! daemon->at_limit)\n    {\n      if (! MHD_add_to_fd_set_ (ls,\n                                read_fd_set,\n                                max_fd,\n                                fd_setsize))\n        result = MHD_NO;\n    }\n  }\n\n#if _MHD_DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _ (\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code assigns to the function parameter fd_setsize (fd_setsize = (int) FD_SETSIZE;), which modifies a non\u2011pointer parameter inside the function. This directly violates MISRA C 2023 Rule 17.8 (function parameters shall not be modified). (Use a local variable instead to avoid the violation.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aaae0 write_fd_set=0x7ffd426aaae0 except_fd_set=0x7ffd426aaae0 max_fd=0x7ffd426aaadc fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aa9b8 write_fd_set=0x7ffd426aa938 except_fd_set=0x7ffd426aa8b8 max_fd=0x7ffd426aa8b4 fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aaae0 write_fd_set=0x7ffd426aaae0 except_fd_set=0x7ffd426aaae0 max_fd=0x7ffd426aaadc fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aa9b8 write_fd_set=0x7ffd426aa938 except_fd_set=0x7ffd426aa8b8 max_fd=0x7ffd426aa8b4 fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aaae0 write_fd_set=0x7ffd426aaae0 except_fd_set=0x7ffd426aaae0 max_fd=0x7ffd426aaadc fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aa9b8 write_fd_set=0x7ffd426aa938 except_fd_set=0x7ffd426aa8b8 max_fd=0x7ffd426aa8b4 fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aaae0 write_fd_set=0x7ffd426aaae0 except_fd_set=0x7ffd426aaae0 max_fd=0x7ffd426aaadc fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aa9b8 write_fd_set=0x7ffd426aa938 except_fd_set=0x7ffd426aa8b8 max_fd=0x7ffd426aa8b4 fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aaae0 write_fd_set=0x7ffd426aaae0 except_fd_set=0x7ffd426aaae0 max_fd=0x7ffd426aaadc fd_setsize=1024\ninternal_get_fdset2: about to assign fd_setsize (parameter) with FD_SETSIZE, current fd_setsize=1024\ninternal_get_fdset2: fd_setsize change: before=0 after=1024\ninternal_get_fdset2: computed ls=3 itc_added=0\ninternal_get_fdset2: exit result=1 final_fd_setsize=1024\ninternal_get_fdset2: entry daemon=0x55790585ede0 read_fd_set=0x7ffd426aa9b8 write_fd_set=0x7ffd426aa938 except_fd_set=0x7ffd426aa8b8 max_fd=0x7ffd426aa8b4 fd_setsize=1024\ni\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified (the object referred to by a pointer parameter may be modified but the pointer itself shall not). In the code the non\u2011pointer parameter fd_setsize is assigned to: fd_setsize = (int) FD_SETSIZE; \u2014 this is a direct modification of a function parameter and therefore violates Rule 17.8. To comply, use a local copy (for example, int local_fd_setsize = fd_setsize; and use local_fd_setsize thereafter) or avoid assigning to the parameter."
}