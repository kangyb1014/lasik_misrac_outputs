{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_pool_allocate:\n```c\nvoid *\nMHD_pool_allocate (struct MemoryPool *pool,\n                   size_t size,\n                   bool from_end)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n    return NULL; /* size too close to SIZE_MAX */\n  if (asize > pool->end - pool->pos)\n    return NULL;\n  if (from_end)\n  {\n    ret = &pool->memory[pool->end - asize];\n    pool->end -= asize;\n  }\n  else\n  {\n    ret = &pool->memory[pool->pos];\n    pool->pos += asize;\n  }\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n_MHD_UNPOISON_MEMORY (ret, size);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the fragment does not call any <string.h> functions itself. The surrounding code guarantees that 'ret' points to an allocated block of size 'asize' where asize = ROUND_TO_ALIGN_PLUS_RED_ZONE(size) and the function returns early on failure (including the case asize==0 for non\u2011zero size or asize > available space). Therefore any operation inside _MHD_UNPOISON_MEMORY that touches at most 'size' bytes will not access beyond the allocated block. (If _MHD_UNPOISON_MEMORY internally used a <string.h> routine and used a length greater than the allocated asize, that internal implementation could violate Rule 21.17, but there is no evidence of that here.)"
}