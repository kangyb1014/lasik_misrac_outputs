{
  "user_message": "An agent A claimed that the following MHD_str_has_token_caseless_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_has_token_caseless_.\n```c\nbool\nMHD_str_has_token_caseless_ (const char *str,\n                             const char *const token,\n                             size_t token_len)\n{\n  if (0 == token_len)\n    return false;\n\n  while (0 != *str)\n  {\n    size_t i;\n    /* Skip all whitespaces and empty tokens. */\n    while (' ' == *str || '\\t' == *str || ',' == *str)\n      str++;\n\n    /* Check for token match. */\n    i = 0;\n    while (1)\n    {\n      const char sc = *(str++);\n      const char tc = token[i++];\n\n      if (0 == sc)\n        return false;\n      if (! charsequalcaseless (sc, tc))\n        break;\n      if (i >= token_len)\n      {\n        /* Check whether substring match token fully or\n         * has additional unmatched chars at tail. */\n        while (' ' == *str || '\\t' == *str)\n          str++;\n        /* End of (sub)string? */\n        if ((0 == *str) || (',' == *str) )\n          return true;\n        /* Unmatched chars at end of substring. */\n        break;\n      }\n    }\n    /* Find next substring. */\n    while (0 != *str && ',' != *str)\n      str++;\n  }\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: the function parameter 'str' is declared as 'const char *str'. The expression '*(str++)' uses post-increment on the parameter, which modifies the pointer itself. MISRA C 2023 Rule 17.8 forbids modifying a pointer parameter (the object it points to may be modified, but not the pointer), so this fragment violates the rule.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nEVENT: ENTRY\n  token_len=6 idx=0\n  str_ptr=0x561423a41197 token_ptr=0x561423a41197\n  *str (current) = 's' (0x73)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: OUTER_LOOP_START\n  token_len=6 idx=0\n  str_ptr=0x561423a41197 token_ptr=0x561423a41197\n  *str (current) = 's' (0x73)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: INNER_ITER\n  i=1 prev_str=0x561423a41197 str(after)=0x561423a41198 token_ptr=0x561423a41197\n  *prev_str = 's' (0x73)\n  sc = 's' (0x73)\n  tc = 's' (0x73)\n  ----\nEVENT: INNER_ITER\n  i=2 prev_str=0x561423a41198 str(after)=0x561423a41199 token_ptr=0x561423a41197\n  *prev_str = 't' (0x74)\n  sc = 't' (0x74)\n  tc = 't' (0x74)\n  ----\nEVENT: INNER_ITER\n  i=3 prev_str=0x561423a41199 str(after)=0x561423a4119a token_ptr=0x561423a41197\n  *prev_str = 'r' (0x72)\n  sc = 'r' (0x72)\n  tc = 'r' (0x72)\n  ----\nEVENT: INNER_ITER\n  i=4 prev_str=0x561423a4119a str(after)=0x561423a4119b token_ptr=0x561423a41197\n  *prev_str = 'i' (0x69)\n  sc = 'i' (0x69)\n  tc = 'i' (0x69)\n  ----\nEVENT: INNER_ITER\n  i=5 prev_str=0x561423a4119b str(after)=0x561423a4119c token_ptr=0x561423a41197\n  *prev_str = 'n' (0x6E)\n  sc = 'n' (0x6E)\n  tc = 'n' (0x6E)\n  ----\nEVENT: INNER_ITER\n  i=6 prev_str=0x561423a4119c str(after)=0x561423a4119d token_ptr=0x561423a41197\n  *prev_str = 'g' (0x67)\n  sc = 'g' (0x67)\n  tc = 'g' (0x67)\n  ----\nEVENT: MATCH_SUCCESS_RETURN_TRUE\n  token_len=6 idx=6\n  str_ptr=0x561423a4119d token_ptr=0x561423a41197\n  *str (current) = <NUL>\n  sc (consumed char) = 'g' (0x67)\n  tc (token char)    = 'g' (0x67)\n  ----\nEVENT: ENTRY\n  token_len=6 idx=0\n  str_ptr=0x561423a41004 token_ptr=0x561423a41197\n  *str (current) = 'S' (0x53)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: OUTER_LOOP_START\n  token_len=6 idx=0\n  str_ptr=0x561423a41004 token_ptr=0x561423a41197\n  *str (current) = 'S' (0x53)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: INNER_ITER\n  i=1 prev_str=0x561423a41004 str(after)=0x561423a41005 token_ptr=0x561423a41197\n  *prev_str = 'S' (0x53)\n  sc = 'S' (0x53)\n  tc = 's' (0x73)\n  ----\nEVENT: INNER_ITER\n  i=2 prev_str=0x561423a41005 str(after)=0x561423a41006 token_ptr=0x561423a41197\n  *prev_str = 't' (0x74)\n  sc = 't' (0x74)\n  tc = 't' (0x74)\n  ----\nEVENT: INNER_ITER\n  i=3 prev_str=0x561423a41006 str(after)=0x561423a41007 token_ptr=0x561423a41197\n  *prev_str = 'r' (0x72)\n  sc = 'r' (0x72)\n  tc = 'r' (0x72)\n  ----\nEVENT: INNER_ITER\n  i=4 prev_str=0x561423a41007 str(after)=0x561423a41008 token_ptr=0x561423a41197\n  *prev_str = 'i' (0x69)\n  sc = 'i' (0x69)\n  tc = 'i' (0x69)\n  ----\nEVENT: INNER_ITER\n  i=5 prev_str=0x561423a41008 str(after)=0x561423a41009 token_ptr=0x561423a41197\n  *prev_str = 'n' (0x6E)\n  sc = 'n' (0x6E)\n  tc = 'n' (0x6E)\n  ----\nEVENT: INNER_ITER\n  i=6 prev_str=0x561423a41009 str(after)=0x561423a4100a token_ptr=0x561423a41197\n  *prev_str = 'g' (0x67)\n  sc = 'g' (0x67)\n  tc = 'g' (0x67)\n  ----\nEVENT: MATCH_SUCCESS_RETURN_TRUE\n  token_len=6 idx=6\n  str_ptr=0x561423a4100a token_ptr=0x561423a41197\n  *str (current) = <NUL>\n  sc (consumed char) = 'g' (0x67)\n  tc (token char)    = 'g' (0x67)\n  ----\nEVENT: ENTRY\n  token_len=6 idx=0\n  str_ptr=0x561423a41197 token_ptr=0x561423a41004\n  *str (current) = 's' (0x73)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: OUTER_LOOP_START\n  token_len=6 idx=0\n  str_ptr=0x561423a41197 token_ptr=0x561423a41004\n  *str (current) = 's' (0x73)\n  sc (consumed char) = <NUL>\n  tc (token char)    = <NUL>\n  ----\nEVENT: INNER_ITER\n  i=1 prev_str=0x561423a41197 str(after)=0x561423a41198 token_ptr=0x561423a41004\n  *prev_str = 's' (0x73)\n  sc = 's' (0x73)\n  tc = 'S' (0x53)\n  ----\nEVENT: INNER_ITER\n  i=2 prev_str=0x561423a41198 str(after)=0x561423a41199 token_ptr=0x561423a41004\n  *prev_str = 't' (0x74)\n  sc = 't' (0x74)\n  tc = 't' (0x74)\n  ----\nEVENT: INNER_ITER\n  i=3 prev_str=0x561423a41199 str(after)=0x561423a4119a token_ptr=0x561423a41004\n  *prev_str = 'r' (0x72)\n  sc = 'r' (0x72)\n  tc = 'r' (0x72)\n  ----\nEVENT: INNER_ITER\n  i=4 prev_str=0x561423a4119a str(after)=0x561423a4119b token_ptr=\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The parameter is declared as const char *str (pointer to const char), so the pointed-to characters may not be modified but the pointer itself is a modifiable parameter. The code uses post-increment on that parameter (e.g. const char sc = *(str++); and multiple occurrences of str++ / str++/ str++ in the loops), which modifies the parameter variable. MISRA C:2023 Rule 17.8 states a function parameter shall not be modified (the object referred to by a pointer parameter may be modified, but not the pointer itself), so these increments violate the rule.\n\nSuggested fixes: iterate using a local pointer (e.g. const char *p = str; use p++ throughout) or change the function prototype to make the pointer itself const (const char * const str) and use a local copy for traversal; either approach avoids modifying the parameter."
}