{
  "user_message": "An agent A claimed that the following MHD_run_from_select2 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_from_select2.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select2 (struct MHD_Daemon *daemon,\n                      const fd_set *read_fd_set,\n                      const fd_set *write_fd_set,\n                      const fd_set *except_fd_set,\n                      unsigned int fd_setsize)\n{\n  if (MHD_D_IS_USING_POLL_ (daemon) ||\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n  if ((NULL == read_fd_set) || (NULL == write_fd_set))\n    return MHD_NO;\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_run_from_select() called with except_fd_set \"\n                 \"set to NULL. Such behavior is deprecated.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_run_from_select2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n#ifdef EPOLL_SUPPORT\n    enum MHD_Result ret = MHD_epoll (daemon,\n                                     0);\n\n    MHD_cleanup_connections (daemon);\n    return ret;\n#else  /* ! EPOLL_SUPPORT */\n    return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n  }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon,\n                                   read_fd_set,\n                                   write_fd_set,\n                                   except_fd_set,\n                                   (int) fd_setsize);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the macro/function MHD_D_IS_USING_THREADS_ is declared to take a non-const pointer (e.g. 'struct MHD_Daemon *daemon') but only reads fields from daemon, then it violates MISRA C 2023 Rule 8.13 \u2014 the parameter should be 'const struct MHD_Daemon *'. The fragment 'MHD_D_IS_USING_THREADS_(daemon)' therefore indicates a potential violation when the underlying declaration is non-const-qualified.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_threads_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] using_epoll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] call_internal_run_from_select: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2] entry: daemon=0x55d3fe34b8d0 detail=read_fd_set=0x7ffcdf229250 write_fd_set=0x7ffcdf2291d0 except_fd_set=0x7ffcdf229150 fd_setsize=1024\n[MHD_run_from_select2] using_poll_false: daemon=0x55d3fe34b8d0\n[MHD_run_from_select2]\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 8.13 recommends using const-qualified pointer types where possible, but it applies to declarations where the pointee can actually be const. MHD_run_from_select2 takes a non-const struct MHD_Daemon *daemon and subsequently calls functions that plausibly modify or forward that pointer to non-const APIs (e.g. MHD_cleanup_connections(daemon), resume_suspended_connections(daemon), and internal_run_from_select(daemon,...)). Because the daemon object is used in contexts that may require mutation or non-const parameters, it cannot sensibly be changed to const in this function. The fact that MHD_D_IS_USING_THREADS_(daemon) only reads fields does not by itself make the surrounding function wrong \u2014 it would only indicate that the IS_USING_THREADS_ macro/function itself could accept a pointer-to-const if appropriate. Thus the claimed violation of MISRA C 2023 Rule 8.13 for MHD_run_from_select2 is not supported."
}