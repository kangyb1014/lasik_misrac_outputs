{
  "user_message": "An agent A claimed that the following MHD_run_from_select2 code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_from_select2.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_from_select2 (struct MHD_Daemon *daemon,\n                      const fd_set *read_fd_set,\n                      const fd_set *write_fd_set,\n                      const fd_set *except_fd_set,\n                      unsigned int fd_setsize)\n{\n  if (MHD_D_IS_USING_POLL_ (daemon) ||\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n  if ((NULL == read_fd_set) || (NULL == write_fd_set))\n    return MHD_NO;\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_run_from_select() called with except_fd_set \"\n                 \"set to NULL. Such behavior is deprecated.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_run_from_select2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_run_from_select2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n#ifdef EPOLL_SUPPORT\n    enum MHD_Result ret = MHD_epoll (daemon,\n                                     0);\n\n    MHD_cleanup_connections (daemon);\n    return ret;\n#else  /* ! EPOLL_SUPPORT */\n    return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n  }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon,\n                                   read_fd_set,\n                                   write_fd_set,\n                                   except_fd_set,\n                                   (int) fd_setsize);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment passes string literals (\"MHD_run_from_select2\") and the result of _(...) (a translation macro returning a char pointer) to MHD_DLOG. If MHD_DLOG\u2019s prototype (or the macros it expands to) declares these parameters as pointer-to-non-const (e.g. char *), then immutable string data is being referred to via non-const pointers \u2014 violating MISRA C 2023 Rule 8.13. To avoid the violation the logging API parameters (format and string arguments) should be declared as const char * (or the arguments cast to const char *), so pointers point to const-qualified types whenever possible.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTERNAL: about to call internal_run_from_select ptr=0x7ffee022de34\nENTRY: daemon=0x55d66e9c68d0 read_fd_set=0x7ffee022dfc0 write_fd_set=0x7ffee022df40 except_fd_set=0x7ffee022dec0 fd_setsize=1024 daemon_fdset_size=0 fdset_set_by_app=0 options=0x00080001\nCALL_INTE\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The scenario described by agent A is plausible but cannot be confirmed from the snippet alone. MISRA C 2023 Rule 8.13 concerns pointer declarations (including function parameter types): pointers should point to const-qualified types whenever possible. If MHD_DLOG (or the macros it expands to) is declared to take char * (non-const) for its format/string parameters, then that declaration would be contrary to Rule 8.13 and passing string literals or translated strings would surface the issue. However, the shown code only contains calls to MHD_DLOG; the actual declaration of MHD_DLOG (and of the translation macro _()) is not provided. If those declarations already use const char * for format/strings, there is no violation. Therefore the report is not verifiably correct based on the supplied code: it is only correct if (and only if) the logging API is declared with non-const pointer parameters. Recommended action: inspect the prototype/definition of MHD_DLOG and the _() macro \u2014 if they use non-const char * for strings, change them to const char * (preferred) or cast the arguments to const char * as a workaround."
}