{
  "user_message": "An agent A claimed that the following find_auth_rq_header_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_auth_rq_header_.\n```c\nstatic bool\nfind_auth_rq_header_ (const struct MHD_Connection *c, enum MHD_AuthType type,\n                      struct _MHD_str_w_len *auth_value)\n{\n  const struct MHD_HTTP_Req_Header *h;\n  const char *token;\n  size_t token_len;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= c->state);\n  if (MHD_CONNECTION_HEADERS_PROCESSED > c->state)\n    return false;\n\n#ifdef DAUTH_SUPPORT\n  if (MHD_AUTHTYPE_DIGEST == type)\n  {\n    token = _MHD_AUTH_DIGEST_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  }\n  else /* combined with the next line */\n#endif /* DAUTH_SUPPORT */\n#ifdef BAUTH_SUPPORT\n  if (MHD_AUTHTYPE_BASIC == type)\n  {\n    token = _MHD_AUTH_BASIC_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_BASIC_BASE);\n  }\n  else /* combined with the next line */\n#endif /* BAUTH_SUPPORT */\n  {\n    mhd_assert (0);\n    return false;\n  }\n\n  for (h = c->rq.headers_received; NULL != h; h = h->next)\n  {\n    if (MHD_HEADER_KIND != h->kind)\n      continue;\n    if (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_AUTHORIZATION) != h->header_size)\n      continue;\n    if (token_len > h->value_size)\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_AUTHORIZATION,\n                                         h->header,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_AUTHORIZATION)))\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (h->value, token, token_len))\n      continue;\n    /* Match only if token string is full header value or token is\n     * followed by space or tab\n     * Note: RFC 9110 (and RFC 7234) allows only space character, but\n     * tab is supported here as well for additional flexibility and uniformity\n     * as tabs are supported as separators between parameters.\n     */\n    if ((token_len == h->value_size) ||\n        (' ' == h->value[token_len]) || ('\\t'  == h->value[token_len]))\n    {\n      if (token_len != h->value_size)\n      { /* Skip whitespace */\n        auth_value->str = h->value + token_len + 1;\n        auth_value->len = h->value_size - (token_len + 1);\n      }\n      else\n      { /* No whitespace to skip */\n        auth_value->str = h->value + token_len;\n        auth_value->len = h->value_size - token_len;\n      }\n      return true; /* Found a match */\n    }\n  }\n  return false; /* No matching header has been found */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf auth_value->str is declared as a non-const pointer (e.g. char *str in struct _MHD_str_w_len) while h->value refers to data that should be const (e.g. const char *value in the request header), then the assignment auth_value->str = h->value + token_len + 1; discards const-qualification. In that case Rule 8.13 is violated: auth_value->str should be declared as const char * (or otherwise const-qualified) to avoid removing const from the source pointer.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- find_auth_rq_header_ probe: entry ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=(nil) token_len=0\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (entry) ---\n\n--- find_auth_rq_header_ probe: token_selected ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (token_selected) ---\n\n--- find_auth_rq_header_ probe: no_match_found ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (no_match_found) ---\n\n--- find_auth_rq_header_ probe: entry ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=(nil) token_len=0\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (entry) ---\n\n--- find_auth_rq_header_ probe: token_selected ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=0x55dbfc41d487 token_len=6\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (token_selected) ---\n\n--- find_auth_rq_header_ probe: no_match_found ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=0x55dbfc41d487 token_len=6\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (no_match_found) ---\n\n--- find_auth_rq_header_ probe: entry ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=(nil) token_len=0\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (entry) ---\n\n--- find_auth_rq_header_ probe: token_selected ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (token_selected) ---\n\n--- find_auth_rq_header_ probe: header_loop_iter ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=0x55dbfc4253d8 kind=1 header_size=13 value_size=0\nheader_ptr=0x55dbfc41e0e4 value_ptr=0x55dbfc41d45e\nheader_preview=\"Authorization\"\nauth_value pre str=(nil) len=0\n--- end probe (header_loop_iter) ---\n\n--- find_auth_rq_header_ probe: no_match_found ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (no_match_found) ---\n\n--- find_auth_rq_header_ probe: entry ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=(nil) token_len=0\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (entry) ---\n\n--- find_auth_rq_header_ probe: token_selected ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=0x55dbfc41d487 token_len=6\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (token_selected) ---\n\n--- find_auth_rq_header_ probe: header_loop_iter ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=0x55dbfc41d487 token_len=6\nheader struct=0x55dbfc4253d8 kind=1 header_size=13 value_size=0\nheader_ptr=0x55dbfc41e0e4 value_ptr=0x55dbfc41d45e\nheader_preview=\"Authorization\"\nauth_value pre str=(nil) len=0\n--- end probe (header_loop_iter) ---\n\n--- find_auth_rq_header_ probe: no_match_found ---\nconnection=0x55dbfc425190 state=11\nauth type=2 token=0x55dbfc41d487 token_len=6\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (no_match_found) ---\n\n--- find_auth_rq_header_ probe: entry ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=(nil) token_len=0\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (entry) ---\n\n--- find_auth_rq_header_ probe: token_selected ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\nauth_value pre str=(nil) len=0\n--- end probe (token_selected) ---\n\n--- find_auth_rq_header_ probe: header_loop_iter ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=0x55dbfc4253d8 kind=1 header_size=13 value_size=0\nheader_ptr=0x55dbfc41e0e4 value_ptr=0x55dbfc41d18c\nheader_preview=\"Authorization\"\nauth_value pre str=(nil) len=0\n--- end probe (header_loop_iter) ---\n\n--- find_auth_rq_header_ probe: no_match_found ---\nconnection=0x55dbfc425190 state=11\nauth type=1 token=0x55dbfc41d19a token_len=5\nheader struct=NULL\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct in principle: the assignment auth_value->str = h->value + token_len + 1; would discard a const qualifier if h->value has type 'const char *' while auth_value->str has type 'char *'. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible, and discarding const-qualified data via assignment is exactly the kind of situation the rule is intended to avoid. However, whether a real violation actually occurs depends on the declarations of the involved struct members, which are not shown in the snippet. Note: declaring 'const struct MHD_HTTP_Req_Header *h' makes the pointer to the struct const (i.e. you may not modify the struct via h) but does not change the declared types of the struct members themselves \u2014 h->value will be const-qualified only if the MHD_HTTP_Req_Header member is declared as 'const char *value'. If that member is already non-const ('char *value') then no const is discarded and there is no Rule 8.13 violation. If the header member is 'const char *' and auth_value->str is 'char *', then Agent A's report is correct and the proper remedy is to make auth_value->str a 'const char *' (or otherwise preserve const qualification) to avoid discarding const."
}