{
  "user_message": "An agent A claimed that the following post_iterator code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of post_iterator.\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: integer-wrap allows memcpy to write past destination. Although the code attempts to bound the copy by checking off and reducing size when size + off >= sizeof(session->value_1), it does not prevent unsigned integer wrap of the expression size + off. off is uint64_t and size is size_t; if size is very large (e.g. near UINT64_MAX) then size + off can wrap around and become a small value that is < sizeof(session->value_1), so the crop branch is not taken and memcpy is called with a size that is much larger than the remaining space in session->value_1. This can cause accesses beyond the bounds of the destination buffer and therefore violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code mixes two unsigned types (off is uint64_t, size is size_t) so the expression size + off is evaluated in uint64_t (size is promoted). If size and off are large enough their sum can wrap modulo 2^64; a wrapped (small) value can make the test (size + off >= sizeof(session->value_1)) evaluate false even though the true mathematical sum would be larger than the destination buffer. As a result memcpy is called with an unbounded size (possibly very large after cast back to size_t) and can write beyond the bounds of session->value_1; the subsequent session->value_1[size + off] = '\\0' also relies on the same potentially-wrapped sum. This permits out-of-bounds accesses and therefore violates MISRA C 2023 Rule 21.17. To fix: perform all bounds arithmetic in a single unsigned type that is at least as wide as both operands (or convert off to size_t if that is known safe), explicitly check for sum overflow (e.g. if (size > SIZE_MAX - (size_t)off) handle), or compute remaining = sizeof(...) > off ? sizeof(...) - (size_t)off - 1 : 0 and limit size to remaining before calling memcpy."
}