{
  "user_message": "An agent A claimed that the following post_iterator code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of post_iterator.\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The expression 'size + off >= sizeof(session->value_1)' can overflow and thus incorrectly pass the bounds check, leading to out\u2011of\u2011bounds access by the subsequent memcpy. For example, if sizeof(session->value_1) == 64, off == 10 (so the earlier off check passes) and size == SIZE_MAX - 5, then size + off wraps to a small value (<64), the condition is false, and memcpy(&session->value_1[off], data, size) will copy a huge number of bytes past the buffer. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code adds size (size_t) and off (uint64_t) and relies on the sum to detect overflow beyond the destination buffer, but that addition can wrap (unsigned overflow) and thus make the bounds test succeed incorrectly. For example, with sizeof(session->value_1) == 64, off == 10 and size == SIZE_MAX - 5 the expression size + off will wrap to a small value (<64) and the condition if (size + off >= sizeof(...)) will be false, so memcpy(&session->value_1[off], data, size) will copy a huge number of bytes past the buffer. This is a genuine out\u2011of\u2011bounds risk involving the use of memcpy and therefore violates MISRA C 2023 Rule 21.17. The root causes are (a) lack of protection against unsigned wraparound when computing size+off and (b) mixed-width unsigned arithmetic (uint64_t vs size_t) that can obscure the problem. A safe fix is to check for overflow explicitly before the addition (for example check if size > SIZE_MAX - (size_t)off or compute available = sizeof(...)-1 - (size_t)off after validating off fits into size_t, then clamp size = min(size, available)), so that memcpy is never called with a length that can write past the buffer."
}