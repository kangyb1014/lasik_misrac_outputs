{
  "user_message": "An agent A claimed that the following get_rq_nc code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_nc.\n```c\nstatic enum MHD_GetRqNCResult\nget_rq_nc (const struct MHD_RqDAuth *params,\n           uint32_t *nc)\n{\n  const struct MHD_RqDAuthParam *const nc_param =\n    &params->nc;\n  char unq[16];\n  const char *val;\n  size_t val_len;\n  size_t res;\n  uint64_t nc_val;\n\n  if (NULL == nc_param->value.str)\n    return MHD_GET_RQ_NC_NONE;\n\n  if (0 == nc_param->value.len)\n    return MHD_GET_RQ_NC_BROKEN;\n\n  if (! nc_param->quoted)\n  {\n    val = nc_param->value.str;\n    val_len = nc_param->value.len;\n  }\n  else\n  {\n    /* Actually no backslashes must be used in 'nc' */\n    if (sizeof(unq) < params->nc.value.len)\n      return MHD_GET_RQ_NC_TOO_LONG;\n    val_len = MHD_str_unquote (nc_param->value.str, nc_param->value.len, unq);\n    if (0 == val_len)\n      return MHD_GET_RQ_NC_BROKEN;\n    val = unq;\n  }\n\n  res = MHD_strx_to_uint64_n_ (val, val_len, &nc_val);\n  if (0 == res)\n  {\n    const char f = val[0];\n    if ( (('9' >= f) && ('0' <= f)) ||\n         (('F' >= f) && ('A' <= f)) ||\n         (('a' <= f) && ('f' >= f)) )\n      return MHD_GET_RQ_NC_TOO_LARGE;\n    else\n      return MHD_GET_RQ_NC_BROKEN;\n  }\n  if (val_len != res)\n    return MHD_GET_RQ_NC_BROKEN;\n  if (UINT32_MAX < nc_val)\n    return MHD_GET_RQ_NC_TOO_LARGE;\n  *nc = (uint32_t) nc_val;\n  return MHD_GET_RQ_NC_VALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential buffer overflow if MHD_str_unquote writes a terminating NUL (or otherwise copies value.len+1 bytes) into 'unq'. The code allows val_len == sizeof(unq) (check uses '<' not '<='), so when params->nc.value.len == sizeof(unq) the destination 'unq' has exactly value.len bytes of space; if MHD_str_unquote copies value.len bytes plus a NUL (or internally calls memcpy/strcpy/memmove with value.len+1), that will write past the end of 'unq' and thus violate the requirement that string handling calls from <string.h> do not access beyond object bounds. If, however, MHD_str_unquote only copies exactly value.len bytes and does not use <string.h> routines in an overflowing way, no violation occurs.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct as a potential MISRA 21.17 violation. The code allows params->nc.value.len to be equal to sizeof(unq) because the check is sizeof(unq) < params->nc.value.len (i.e. it only rejects lengths strictly greater than the buffer). If MHD_str_unquote writes a terminating NUL or otherwise copies value.len+1 bytes into unq (or internally calls a <string.h> routine that does so), that will write one byte past the end of unq and thus cause an out-of-bounds access. MISRA 21.17 prohibits such accesses arising from string.h routines. The only way this code would be provably compliant is if MHD_str_unquote is guaranteed to never write more than value.len bytes (and never write a NUL), or if it documents that it will not call any <string.h> function that could perform an out-of-bounds write; absent that guarantee the code is unsafe.\n\nRecommended fixes: (a) change the check to reject value.len >= sizeof(unq) (i.e. use '<='), or (b) make unq one byte larger (char unq[17]) to allow a terminating NUL, or (c) use an interface to MHD_str_unquote that takes the destination buffer length and cannot overflow. Any of these removes the potential out-of-bounds write and satisfies MISRA 21.17."
}