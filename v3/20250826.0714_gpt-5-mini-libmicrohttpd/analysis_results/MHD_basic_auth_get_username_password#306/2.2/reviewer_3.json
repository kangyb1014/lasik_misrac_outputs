{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password.\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf mhd_assert is a diagnostics-only macro that expands to a no-op in production builds (for example, #define mhd_assert(expr) ((void)0) when NDEBUG or equivalent is set), then the statement mhd_assert(0 == (*password)[info->password_len]); is executed but has no effect; removing it would not change program behaviour. In that configuration the statement is dead code and thus violates MISRA C 2023 Rule 2.2. (If, instead, mhd_assert performs a runtime check that can alter control flow \u2014 e.g. aborts on failure \u2014 then the statement is not dead and does not violate the rule.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's assessment is correct in the relevant configuration. MISRA C 2023 Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. If mhd_assert is a diagnostics-only macro that expands to a no-op in the production build (for example #define mhd_assert(expr) ((void)0)), then the statement mhd_assert(0 == (*password)[info->password_len]); has no effect at runtime and removing that statement would not change program behaviour \u2014 it therefore meets the definition of dead code and would violate Rule 2.2. Conversely, if mhd_assert performs a runtime action (e.g. checks and aborts, logs, or otherwise has observable side effects), the statement is not dead and no violation occurs. Thus the report is correct but conditional on how mhd_assert is defined in the project configuration."
}