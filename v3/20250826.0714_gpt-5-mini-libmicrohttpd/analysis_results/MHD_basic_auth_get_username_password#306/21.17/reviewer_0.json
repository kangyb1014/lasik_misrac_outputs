{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password.\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe calls to memcpy(copy_size = info->username_len + 1 and info->password_len + 1) assume the source buffers (info->username and info->password) are at least that large (i.e. include the terminating NUL). The function does not validate those source buffer bounds here. If, for example, info->username actually points to a buffer of size info->username_len (no stored NUL) or info->username_len is incorrect, memcpy will read one byte past the end of the source and thus access out-of-bounds. The same applies to the password copy path.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memcpy(username, info->username, info->username_len + 1) (and similarly for password) without verifying that the source buffers pointed to by info->username / info->password actually have at least info->username_len + 1 / info->password_len + 1 bytes. If the length fields are wrong or the source strings are not NUL-terminated, memcpy will read one byte past the source object and cause out-of-bounds access (undefined behavior). The subsequent mhd_assert only checks the destination after the copy and does not prevent the out-of-bounds access during memcpy. Therefore, unless there is an external, provable contract (from MHD_basic_auth_get_username_password3 and the MHD_BasicAuthInfo definition) that guarantees the source buffers include the terminating NUL and are at least length+1 bytes, the shown code violates MISRA C 2023 Rule 21.17."
}