{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password.\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code uses info->password as the read-only source in memcpy but (as in the likely struct definition) info->password is a non-const char *; since the pointer is only used for reading it should be declared const char *password in struct MHD_BasicAuthInfo. This mismatch (a non-const pointer used only for reading) violates MISRA C 2023 Rule 8.13. (If info->password were already declared as const char *, there would be no violation.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a violation. MISRA C 2023 Rule 8.13 applies to declarations: a pointer object should be declared to point to a const-qualified type when it is never used to modify the referent. The excerpt only shows read-only uses of info->password (memcpy reads it), but it does not show the definition of struct MHD_BasicAuthInfo nor all other uses of those members. If info->password (and/or info->username) is actually modified elsewhere or ownership semantics require non-const, then the non-const declaration is appropriate. Therefore the agent\u2019s claim is speculative. To determine a real violation you must inspect the declaration of MHD_BasicAuthInfo and all its uses; if those show the members are never modified, then they should be declared as const char * and the change would satisfy Rule 8.13."
}