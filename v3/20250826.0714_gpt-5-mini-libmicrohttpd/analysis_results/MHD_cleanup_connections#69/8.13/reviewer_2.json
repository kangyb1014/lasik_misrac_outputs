{
  "user_message": "An agent A claimed that the following MHD_cleanup_connections code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_cleanup_connections.\n```c\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes a non-const pointer (pos of type struct MHD_Connection *) to a callback (daemon->notify_connection). If the notify_connection callback is declared as taking a non-const struct MHD_Connection * but does not need to modify the connection, this violates MISRA C 2023 Rule 8.13 \u2014 the pointer parameter (and/or the local pointer) should be to a const-qualified type. To determine definitively you must inspect the prototype of notify_connection; if it is declared to accept a const-qualified pointer (e.g. const struct MHD_Connection *), there is no violation. Otherwise (prototype uses a non-const pointer when mutation is not required) this is a rule violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d75820 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d75820 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d75de0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d75de0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d76988 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d76988 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d766e0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d766e0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d766e0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d766e0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d76f60 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d76f60 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d773a0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d773a0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d777e0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d777e0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d78308 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d78308 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d78060 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d78060 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d77c20 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d77c20 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d78308 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d78308 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x563ca3d78060 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x563ca3d78060 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x5622aa630820 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x5622aa630820 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x5622aa630de0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x5622aa630de0 cleanup_tail=(nil) connections=0\n[probe] MHD_cleanup_connections enter: daemon=0x5622aa630de0 cleanup_tail=(nil) cleanup_head=(nil) notify_connection=(nil) notify_connection_cls=(nil) connections=0\n[probe] MHD_cleanup_connections exit: daemon=0x5622aa630de0 c\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 8.13 encourages using const-qualified pointer types where possible, but a conclusive violation requires knowing the declaration and intended semantics of the callback. In the provided MHD_cleanup_connections body we only see pos of type struct MHD_Connection * being passed to daemon->notify_connection; we do not see the prototype/declaration of daemon->notify_connection in the snippet. If the notify_connection function pointer is declared to take a const struct MHD_Connection * (or otherwise const-qualified), then there is no violation. If the prototype takes a non-const pointer but the callback must not and does not modify the connection, then that prototype would be non-const and could be considered a violation \u2014 but that is a problem in the callback's declaration, not in this call site per se. The execution log shows notify_connection is NULL at runtime in the probes, which only shows the callback was not used; it does not affect the static analysis of types. Therefore, based on the provided code and information, Agent A\u2019s report is not supported: you cannot conclude a Rule 8.13 violation without inspecting the notify_connection declaration. To resolve this definitively, inspect the type of daemon->notify_connection in the declaration of struct MHD_Daemon; if it is declared as taking a non-const pointer but does not need to modify the connection, consider changing that API to use a const-qualified pointer."
}