{
  "user_message": "An agent A claimed that the following MHD_cleanup_connections code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_cleanup_connections.\n```c\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes pos->addr (a non-const pointer field of struct MHD_Connection) to MHD_ip_limit_del. If pos->addr is declared as a non-const pointer (e.g. void *addr or struct sockaddr *addr) but the data it points to is only read (MHD_ip_limit_del does not modify the pointed memory), then the pointer should be declared to point to a const-qualified type (e.g. const void * or const struct sockaddr *) per MISRA C 2023 Rule 8.13. Without the declaration of pos->addr or the prototype of MHD_ip_limit_del it cannot be proven here, but in the common case where pos->addr is non-const and only read, this is a violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d71e0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 52 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d71e0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 52 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d86b0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 56 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d86b0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 56 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d8900\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 60 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d8900\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 60 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d8b50\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 66 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d8b50\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 66 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d8da0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 70 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d8da0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 70 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d8ff0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 7c 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d8ff0\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 7c 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d9240\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 8a 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d9240\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 8a 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d9490\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 90 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_limit_del: daemon=0x563bd32d68d0 pos=0x563bd32d9490\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  post-call first 16 bytes:\n  02 00 c9 90 7f 00 00 01 00 00 00 00 00 00 00 00\n  -> contents unchanged (first 16 bytes)\n[MHD_cleanup_connections] entering iteration: daemon=0x563bd32d68d0 pos=0x563bd32d9490\n  pos->addr=0x563bd32d7430 pos->addr_len=16\n  snapshot_len=16 snapshot(first 16 bytes):\n  02 00 c9 a0 7f 00 00 01 00 00 00 00 00 00 00 00\n[MHD_cleanup_connections] after MHD_ip_\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a violation. MISRA C 2023 Rule 8.13 concerns the declarations of pointer types (they should be const-qualified when the pointed-to object is not intended to be modified). The snippet only shows uses of pos->addr (including a call to MHD_ip_limit_del and a later free(pos->addr)), but does not show the declaration of pos->addr nor the prototype of MHD_ip_limit_del. The execution log demonstrates that MHD_ip_limit_del does not modify the memory at runtime, but runtime behavior alone cannot prove that the pointer should have been declared const. Furthermore, this function calls free(pos->addr) \u2014 free has the prototype void free(void *), so making pos->addr a const-qualified pointer would either force an explicit cast to free or a change elsewhere; that indicates the current non-const type may be deliberate. Finally, other parts of the code (not shown) might legitimately modify the memory via pos->addr, which would also rule out declaring it const. Given the missing declarations and prototypes, and the presence of free(pos->addr), Agent A\u2019s claim is speculative and not provable from the provided code. Therefore the reported violation is not established."
}