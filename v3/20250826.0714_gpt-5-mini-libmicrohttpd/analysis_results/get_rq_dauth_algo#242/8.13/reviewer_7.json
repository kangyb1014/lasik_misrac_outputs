{
  "user_message": "An agent A claimed that the following get_rq_dauth_algo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_dauth_algo.\n```c\nstatic enum MHD_DigestAuthAlgo3\nget_rq_dauth_algo (const struct MHD_RqDAuthParam *const algo_param)\n{\n  if (NULL == algo_param->value.str)\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Assume MD5 by default */\n\n  if (algo_param->quoted)\n  {\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_MD5_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_MD5;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA256_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_MD5_TOKEN _MHD_SESS_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA512_256_TOKEN \\\n                                               _MHD_SESS_TOKEN))\n\n      /* Algorithms below are not supported by MHD for authentication */\n\n      return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA256_TOKEN \\\n                                               _MHD_SESS_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA512_256_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n    /* No known algorithm has been detected */\n    return MHD_DIGEST_AUTH_ALGO3_INVALID;\n  }\n  /* The algorithm value is not quoted */\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_MD5_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_MD5;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA256_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA512_256_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n\n  /* Algorithms below are not supported by MHD for authentication */\n\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_MD5_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA256_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n  /* No known algorithm has been detected */\n  return MHD_DIGEST_AUTH_ALGO3_INVALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe rule is violated if the member algo_param->value.str is declared as a non-const pointer (e.g. char *). In that case the code is passing a pointer that points to a non-const char array to string-comparison routines even though the data is not being modified \u2014 Rule 8.13 requires such pointers to point to const-qualified types when possible. If value.str is declared as const char * (or the comparison function parameter expects a const char *), there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=null-value detail=default to MD5 ptr=0x7ffd568cd240 quoted=0 len=0\n[dauth] value_preview=(null)\n[dauth] event=entry detail=start get_rq_dauth_algo ptr=0x7ffd568\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not verifiably true from the snippet alone. get_rq_dauth_algo takes a pointer to a const struct (const struct MHD_RqDAuthParam *const), so the function itself treats the structure as const. MISRA C:2023 Rule 8.13 requires pointer types to point to const-qualified objects when possible \u2014 this would be violated only if the member algo_param->value.str is declared as a non-const pointer (e.g. char *), and that pointer could reasonably be const because the pointed characters are never modified. In other words: \u2022 If value.str is declared as const char * (or the string-comparison functions accept a const char *), there is no violation. \u2022 If value.str is declared as char * but the data it points to is never modified anywhere (and could be made const), then the codebase would be violating Rule 8.13 and value.str should be changed to const char *. \u2022 If value.str is declared as char * because the data is legitimately modified elsewhere, then keeping it non-const is appropriate and there is no Rule 8.13 violation. Because the declaration/usage of value.str elsewhere is not shown, the report\u2019s assertion cannot be confirmed \u2014 it is only conditionally correct. Recommended action: inspect the declaration and all uses of value.str; if it is not modified, change it to const char * (and ensure called helpers take const), otherwise document why it must remain non-const."
}