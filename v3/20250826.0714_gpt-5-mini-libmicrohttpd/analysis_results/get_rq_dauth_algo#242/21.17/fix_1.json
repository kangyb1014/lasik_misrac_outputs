{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern int MHD_str_equal_caseless_quoted_s_bin_n(const char *s, size_t len, const char *token);\nextern int MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s, size_t len);\nstatic void log_prefix(void)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"--- get_rq_dauth_algo probe run ---\\n\");\n        fclose(f);\n    }\n}\nstatic void log_state_initial(const void *algo_param_ptr, const char *s, size_t len, int quoted)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n\n    fprintf(f, \"get_rq_dauth_algo: algo_param=%p value.str=%p value.len=%zu quoted=%d\\n\",\n            algo_param_ptr, (const void *)s, len, quoted);\n\n    /* Print up to a reasonable cap of bytes from the provided buffer -- do not read past len. */\n    if (s != NULL && len > 0) {\n        size_t cap = (len > 1024) ? 1024 : len;\n        fprintf(f, \"value.str (first %zu bytes): \\\"\", cap);\n        fwrite(s, 1, cap, f);\n        if (cap < len) fprintf(f, \"...\");\n        fprintf(f, \"\\\"\\n\");\n    }\n    fclose(f);\n}\nstatic void log_probe_call(const char *where, const char *token_name, const char *token_literal,\n                           const char *s, size_t len)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"probe: %s called with token_name=%s token_literal=\\\"%s\\\" s=%p len=%zu\\n\",\n            where, token_name, token_literal ? token_literal : \"(null)\", (const void *)s, len);\n    if (s && len > 0) {\n        size_t cap = (len > 256) ? 256 : len; /* show a shorter prefix here */\n        fprintf(f, \"probe: s (prefix %zu): \\\"\", cap);\n        fwrite(s, 1, cap, f);\n        if (cap < len) fprintf(f, \"...\");\n        fprintf(f, \"\\\"\\n\");\n    }\n    fclose(f);\n}\nstatic void log_probe_result(const char *where, const char *token_name, int result)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"probe: %s token_name=%s result=%d\\n\", where, token_name, result);\n    fclose(f);\n}\nstatic int probe_MHD_str_equal_caseless_quoted_s_bin_n(const char *s, size_t len,\n                                                      const char *token, const char *token_name)\n{\n    log_probe_call(\"MHD_str_equal_caseless_quoted_s_bin_n\", token_name, token, s, len);\n    int res = MHD_str_equal_caseless_quoted_s_bin_n(s, len, token);\n    log_probe_result(\"MHD_str_equal_caseless_quoted_s_bin_n\", token_name, res);\n    return res;\n}\nstatic int probe_MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s,\n                                                 size_t len, const char *token_name)\n{\n    log_probe_call(\"MHD_str_equal_caseless_s_bin_n_\", token_name, token, s, len);\n    int res = MHD_str_equal_caseless_s_bin_n_(token, s, len);\n    log_probe_result(\"MHD_str_equal_caseless_s_bin_n_\", token_name, res);\n    return res;\n}\n\nstatic enum MHD_DigestAuthAlgo3\nget_rq_dauth_algo (const struct MHD_RqDAuthParam *const algo_param)\n{\n  /* Log function entry and initial state */\n  log_prefix();\n  if (algo_param == NULL) {\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (f) {\n      fprintf(f, \"get_rq_dauth_algo: algo_param is NULL -> default MD5 returned\\n\");\n      fclose(f);\n    }\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Preserve original assumption */\n  }\n\n  log_state_initial(algo_param, algo_param->value.str, algo_param->value.len, algo_param->quoted);\n\n  if (NULL == algo_param->value.str)\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Assume MD5 by default */\n\n  if (algo_param->quoted)\n  {\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_MD5_TOKEN,\n                                                   \"_MHD_MD5_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_MD5;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA256_TOKEN,\n                                                   \"_MHD_SHA256_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_MD5_TOKEN _MHD_SESS_TOKEN,\n                                                   \"_MHD_MD5_TOKEN _MHD_SESS_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA512_256_TOKEN \\\n                                                   _MHD_SESS_TOKEN,\n                                                   \"_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN\"))\n\n      /* Algorithms below are not supported by MHD for authentication */\n\n      return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA256_TOKEN \\\n                                                   _MHD_SESS_TOKEN,\n                                                   \"_MHD_SHA256_TOKEN _MHD_SESS_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA512_256_TOKEN,\n                                                   \"_MHD_SHA512_256_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n    /* No known algorithm has been detected */\n    return MHD_DIGEST_AUTH_ALGO3_INVALID;\n  }\n  /* The algorithm value is not quoted */\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_MD5_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_MD5_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_MD5;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA256_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA256_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA512_256_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA512_256_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n\n  /* Algorithms below are not supported by MHD for authentication */\n\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_MD5_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_MD5_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA256_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA256_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n  /* No known algorithm has been detected */\n  return MHD_DIGEST_AUTH_ALGO3_INVALID;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ngen_auth.c:282:12: error: expected ')'\n  282 | extern int MHD_str_equal_caseless_quoted_s_bin_n(const char *s, size_t len, const char *token);\n      |            ^\n./mhd_str.h:691:47: note: expanded from macro 'MHD_str_equal_caseless_quoted_s_bin_n'\n  691 |     MHD_str_equal_caseless_quoted_bin_n(q,l,u,MHD_STATICSTR_LEN_(u))\n      |                                               ^\n./mhd_str_types.h:33:36: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ^\ngen_auth.c:282:12: note: to match this '('\n./mhd_str.h:691:47: note: expanded from macro 'MHD_str_equal_caseless_quoted_s_bin_n'\n  691 |     MHD_str_equal_caseless_quoted_bin_n(q,l,u,MHD_STATICSTR_LEN_(u))\n      |                                               ^\n./mhd_str_types.h:33:35: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                   ^\ngen_auth.c:282:12: error: type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int [-Wimplicit-int]\n  282 | extern int MHD_str_equal_caseless_quoted_s_bin_n(const char *s, size_t len, const char *token);\n      |            ^\n./mhd_str.h:691:47: note: expanded from macro 'MHD_str_equal_caseless_quoted_s_bin_n'\n  691 |     MHD_str_equal_caseless_quoted_bin_n(q,l,u,MHD_STATICSTR_LEN_(u))\n      |                                               ^\n./mhd_str_types.h:33:36: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ^\ngen_auth.c:282:12: error: conflicting types for 'MHD_str_equal_caseless_quoted_bin_n'\n./mhd_str.h:691:5: note: expanded from macro 'MHD_str_equal_caseless_quoted_s_bin_n'\n  691 |     MHD_str_equal_caseless_quoted_bin_n(q,l,u,MHD_STATICSTR_LEN_(u))\n      |     ^\n./mhd_str.h:668:1: note: previous declaration is here\n  668 | MHD_str_equal_caseless_quoted_bin_n (const char *quoted,\n      | ^\ngen_auth.c:283:12: error: expected identifier or '('\n  283 | extern int MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s, size_t len);\n      |            ^\n./mhd_str.h:123:5: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |     ^\n./mhd_str_types.h:33:36: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ^\ngen_auth.c:283:12: error: expected ')'\n./mhd_str.h:123:5: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |     ^\n./mhd_str_types.h:33:36: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ^\ngen_auth.c:283:12: note: to match this '('\n./mhd_str.h:123:5: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |     ^\n./mhd_str_types.h:33:35: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                   ^\ngen_auth.c:283:12: error: expected ')'\n  283 | extern int MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s, size_t len);\n      |            ^\n./mhd_str.h:123:27: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |                           ^\ngen_auth.c:283:12: note: to match this '('\n./mhd_str.h:123:4: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |    ^\ngen_auth.c:283:12: error: expected ')'\n  283 | extern int MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s, size_t len);\n      |            ^\n./mhd_str.h:124:4: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  124 |    && MHD_str_equal_caseless_bin_n_(a,s,l))\n      |    ^\ngen_auth.c:283:12: note: to match this '('\n./mhd_str.h:123:3: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |   ^\ngen_auth.c:337:15: warning: 'sizeof (token)' will return the size of the pointer, not the array itself [-Wsizeof-pointer-div]\n  337 |     int res = MHD_str_equal_caseless_quoted_s_bin_n(s, len, token);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n./mhd_str.h:691:47: note: expanded from macro 'MHD_str_equal_caseless_quoted_s_bin_n'\n  691 |     MHD_str_equal_caseless_quoted_bin_n(q,l,u,MHD_STATICSTR_LEN_(u))\n      |                                               ^~~~~~~~~~~~~~~~~~~~~\n./mhd_str_types.h:33:50: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ~~~~~~~~~~~~~ ^\ngen_auth.c:334:67: note: pointer 'token' declared here\n  334 |                                                       const char *token, const char *token_name)\n      |                                                                   ^\ngen_auth.c:345:15: warning: 'sizeof (token)' will return the size of the pointer, not the array itself [-Wsizeof-pointer-div]\n  345 |     int res = MHD_str_equal_caseless_s_bin_n_(token, s, len);\n      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n./mhd_str.h:123:5: note: expanded from macro 'MHD_str_equal_caseless_s_bin_n_'\n  123 |   ((MHD_STATICSTR_LEN_(a) == (l)) \\\n      |     ^~~~~~~~~~~~~~~~~~~~~\n./mhd_str_types.h:33:50: note: expanded from macro 'MHD_STATICSTR_LEN_'\n   33 | #define MHD_STATICSTR_LEN_(macro) (sizeof(macro) / sizeof(char) - 1)\n      |                                    ~~~~~~~~~~~~~ ^\ngen_auth.c:341:62: note: pointer 'token' declared here\n  341 | static int probe_MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s,\n      |                                                              ^\n2 warnings and 7 errors generated.\nmake[3]: *** [Makefile:2217: libmicrohttpd_la-gen_auth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_dauth_algo as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n\nstatic void log_prefix(void)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"--- get_rq_dauth_algo probe run ---\\n\");\n        fclose(f);\n    }\n}\nstatic void log_state_initial(const void *algo_param_ptr, const char *s, size_t len, int quoted)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n\n    fprintf(f, \"get_rq_dauth_algo: algo_param=%p value.str=%p value.len=%zu quoted=%d\\n\",\n            algo_param_ptr, (const void *)s, len, quoted);\n\n    /* Print up to a reasonable cap of bytes from the provided buffer -- do not read past len. */\n    if (s != NULL && len > 0) {\n        size_t cap = (len > 1024) ? 1024 : len;\n        fprintf(f, \"value.str (first %zu bytes): \\\"\", cap);\n        fwrite(s, 1, cap, f);\n        if (cap < len) fprintf(f, \"...\");\n        fprintf(f, \"\\\"\\n\");\n    }\n    fclose(f);\n}\nstatic void log_probe_call(const char *where, const char *token_name, const char *token_literal,\n                           const char *s, size_t len)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"probe: %s called with token_name=%s token_literal=\\\"%s\\\" s=%p len=%zu\\n\",\n            where, token_name, token_literal ? token_literal : \"(null)\", (const void *)s, len);\n    if (s && len > 0) {\n        size_t cap = (len > 256) ? 256 : len; /* show a shorter prefix here */\n        fprintf(f, \"probe: s (prefix %zu): \\\"\", cap);\n        fwrite(s, 1, cap, f);\n        if (cap < len) fprintf(f, \"...\");\n        fprintf(f, \"\\\"\\n\");\n    }\n    fclose(f);\n}\nstatic void log_probe_result(const char *where, const char *token_name, int result)\n{\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"probe: %s token_name=%s result=%d\\n\", where, token_name, result);\n    fclose(f);\n}\n\n/*\n * NOTE: Do NOT declare prototypes that match macro names from included headers.\n * The names MHD_str_equal_caseless_quoted_s_bin_n and MHD_str_equal_caseless_s_bin_n_\n * are macros in the microhttpd headers that expand to calls to the underlying\n * \"*_bin_n\" variants (and may rely on token being a compile-time literal).\n * To avoid unwanted macro expansion when the token is a runtime pointer, call\n * the underlying functions directly (their names do not trigger the macro).\n */\nstatic int probe_MHD_str_equal_caseless_quoted_s_bin_n(const char *s, size_t len,\n                                                      const char *token, const char *token_name)\n{\n    log_probe_call(\"MHD_str_equal_caseless_quoted_s_bin_n\", token_name, token, s, len);\n    /* Call the underlying binary-length variant to avoid macro expansion issues. */\n    int res = MHD_str_equal_caseless_quoted_bin_n(s, len, token, token ? strlen(token) : 0);\n    log_probe_result(\"MHD_str_equal_caseless_quoted_s_bin_n\", token_name, res);\n    return res;\n}\nstatic int probe_MHD_str_equal_caseless_s_bin_n_(const char *token, const char *s,\n                                                 size_t len, const char *token_name)\n{\n    log_probe_call(\"MHD_str_equal_caseless_s_bin_n_\", token_name, token, s, len);\n    /* Call the underlying binary-length variant to avoid macro expansion issues. */\n    int res = MHD_str_equal_caseless_bin_n_(token, s, len);\n    log_probe_result(\"MHD_str_equal_caseless_s_bin_n_\", token_name, res);\n    return res;\n}\n\nstatic enum MHD_DigestAuthAlgo3\nget_rq_dauth_algo (const struct MHD_RqDAuthParam *const algo_param)\n{\n  /* Log function entry and initial state */\n  log_prefix();\n  if (algo_param == NULL) {\n    FILE *f = fopen(\"/tmp/logs/2429.txt\", \"a\");\n    if (f) {\n      fprintf(f, \"get_rq_dauth_algo: algo_param is NULL -> default MD5 returned\\n\");\n      fclose(f);\n    }\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Preserve original assumption */\n  }\n\n  log_state_initial(algo_param, algo_param->value.str, algo_param->value.len, algo_param->quoted);\n\n  if (NULL == algo_param->value.str)\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Assume MD5 by default */\n\n  if (algo_param->quoted)\n  {\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_MD5_TOKEN,\n                                                   \"_MHD_MD5_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_MD5;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA256_TOKEN,\n                                                   \"_MHD_SHA256_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_MD5_TOKEN _MHD_SESS_TOKEN,\n                                                   \"_MHD_MD5_TOKEN _MHD_SESS_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA512_256_TOKEN \\\n                                                   _MHD_SESS_TOKEN,\n                                                   \"_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN\"))\n\n      /* Algorithms below are not supported by MHD for authentication */\n\n      return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA256_TOKEN \\\n                                                   _MHD_SESS_TOKEN,\n                                                   \"_MHD_SHA256_TOKEN _MHD_SESS_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n    if (probe_MHD_str_equal_caseless_quoted_s_bin_n(algo_param->value.str, \\\n                                                   algo_param->value.len, \\\n                                                   _MHD_SHA512_256_TOKEN,\n                                                   \"_MHD_SHA512_256_TOKEN\"))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n    /* No known algorithm has been detected */\n    return MHD_DIGEST_AUTH_ALGO3_INVALID;\n  }\n  /* The algorithm value is not quoted */\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_MD5_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_MD5_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_MD5;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA256_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA256_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA512_256_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA512_256_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n\n  /* Algorithms below are not supported by MHD for authentication */\n\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_MD5_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_MD5_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA256_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA256_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n  if (probe_MHD_str_equal_caseless_s_bin_n_(_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN, \\\n                                           algo_param->value.str, \\\n                                           algo_param->value.len,\n                                           \"_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN\"))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n  /* No known algorithm has been detected */\n  return MHD_DIGEST_AUTH_ALGO3_INVALID;\n}\n",
  "explanation": "Removed the two conflicting extern prototype lines (they collided with macros from the microhttpd headers) and avoided invoking those macros with runtime token pointers. Instead, the probe wrappers now call the underlying \"_bin_n\" functions directly:\n\n- probe_MHD_str_equal_caseless_quoted_s_bin_n now calls MHD_str_equal_caseless_quoted_bin_n(..., token, strlen(token)).\n- probe_MHD_str_equal_caseless_s_bin_n_ now calls MHD_str_equal_caseless_bin_n_(token, s, len).\n\nThis prevents macro expansion that produced syntax errors and sizeof-pointer warnings. I also included <string.h> for strlen and left the rest of get_rq_dauth_algo logic unchanged."
}