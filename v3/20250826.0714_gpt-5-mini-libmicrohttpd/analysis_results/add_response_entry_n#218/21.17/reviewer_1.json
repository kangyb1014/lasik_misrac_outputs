{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memchr(content, '\\r', content_len) can access memory when content is a NULL pointer and content_len > 0. The function checks only content_len != 0 but does not validate content != NULL, so if a caller passes content == NULL with a non\u2011zero content_len, memchr will dereference an invalid pointer (out\u2011of\u2011bounds access / undefined behavior).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memchr(content, ..., content_len) and memchr(header, ..., header_len) without first ensuring the corresponding pointer is non-NULL. The function only checks that content_len and header_len are non-zero, so if a caller passes content == NULL (or header == NULL) with a non-zero length, memchr will attempt to read through a NULL (invalid) pointer, producing undefined behaviour and therefore potentially accessing out-of-bounds memory. This violates MISRA C 2023 Rule 21.17 (use of <string.h> functions must not result in accesses beyond the bounds of the referenced objects). Recommended fixes: ensure content != NULL and header != NULL whenever the respective length is non-zero (e.g. return false if pointer is NULL and length != 0), or reorder checks to validate pointers before calling memchr."
}