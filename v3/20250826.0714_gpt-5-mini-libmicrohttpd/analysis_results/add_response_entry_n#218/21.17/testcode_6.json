{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: the call passes 'header' and 'content' pointers with explicit lengths, but there is no guarantee these buffers are NUL-terminated. If MHD_add_response_entry_no_check_ internally uses any <string.h> functions that expect NUL-terminated strings (e.g. strlen, strcpy, strcat, strncat) or otherwise reads beyond the provided header_len/content_len, that would result in out\u2011of\u2011bounds accesses. The wrapper did not enforce NUL-termination or the actual object sizes, so a callee that ignores the provided lengths can violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified add_response_entry_n code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2189.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of add_response_entry_n as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of add_response_entry_n:\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\nPlease provide the modified add_response_entry_n code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstatic void\nlog_state(const char *event,\n          const struct MHD_Response *response,\n          int kind_placeholder,\n          const char *header,\n          size_t header_len,\n          const char *content,\n          size_t content_len,\n          const char *note)\n{\n  FILE *fp = fopen(\"/tmp/logs/2189.txt\", \"a\");\n  if (NULL == fp)\n    return;\n\n  fprintf(fp, \"EVENT: %s\\n\", event);\n  fprintf(fp, \"NOTE: %s\\n\", note ? note : \"(none)\");\n  fprintf(fp, \"response_ptr=%p kind=%d\\n\", (const void *) response, kind_placeholder);\n  fprintf(fp, \"header_ptr=%p header_len=%zu\\n\", (const void *) header, header_len);\n  fprintf(fp, \"content_ptr=%p content_len=%zu\\n\", (const void *) content, content_len);\n\n  /* Flag suspicious states without dereferencing pointers beyond given lengths. */\n  if (header == NULL && header_len > 0)\n    fprintf(fp, \"WARNING: header is NULL but header_len > 0 (possible bad caller)\\n\");\n  if (content == NULL && content_len > 0)\n    fprintf(fp, \"WARNING: content is NULL but content_len > 0 (possible bad caller)\\n\");\n\n  /* Check for embedded NUL within the provided lengths (safe: only reads up to header_len/content_len). */\n  if (header != NULL && header_len > 0) {\n    void *p = memchr(header, '\\0', header_len);\n    fprintf(fp, \"header_has_nul_within_len=%s\\n\", (p != NULL) ? \"yes\" : \"no\");\n\n    /* Dump a limited hex sample of the header (up to 64 bytes) without assuming NUL-termination. */\n    size_t sample = header_len < 64 ? header_len : 64;\n    fprintf(fp, \"header_sample_hex:\");\n    for (size_t i = 0; i < sample; ++i)\n      fprintf(fp, \" %02X\", (unsigned char) header[i]);\n    if (header_len > sample)\n      fprintf(fp, \" ... (truncated)\");\n    fprintf(fp, \"\\n\");\n  }\n\n  if (content != NULL && content_len > 0) {\n    void *p = memchr(content, '\\0', content_len);\n    fprintf(fp, \"content_has_nul_within_len=%s\\n\", (p != NULL) ? \"yes\" : \"no\");\n\n    size_t sample = content_len < 64 ? content_len : 64;\n    fprintf(fp, \"content_sample_hex:\");\n    for (size_t i = 0; i < sample; ++i)\n      fprintf(fp, \" %02X\", (unsigned char) content[i]);\n    if (content_len > sample)\n      fprintf(fp, \" ... (truncated)\");\n    fprintf(fp, \"\\n\");\n  }\n\n  fprintf(fp, \"----\\n\");\n  fclose(fp);\n}\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  /* Log entry state (do not dereference header/content beyond their lengths). */\n  log_state(\"entry\", response, (int) kind, header, header_len, content, content_len, \"function entry\");\n\n  if (NULL == response) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"response NULL - returning false\");\n    return false;\n  }\n  if (0 == header_len) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"header_len == 0 - returning false\");\n    return false;\n  }\n  if (0 == content_len) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"content_len == 0 - returning false\");\n    return false;\n  }\n\n  /* Perform the same memchr checks as original, but capture the result so we can log before returning. */\n  if (NULL != memchr (header, '\\t', header_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"header contains '\\t' - returning false\");\n    return false;\n  }\n  if (NULL != memchr (header, ' ', header_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"header contains ' ' - returning false\");\n    return false;\n  }\n  if (NULL != memchr (header, '\\r', header_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"header contains '\\r' - returning false\");\n    return false;\n  }\n  if (NULL != memchr (header, '\\n', header_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"header contains '\\n' - returning false\");\n    return false;\n  }\n  if (NULL != memchr (content, '\\r', content_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"content contains '\\r' - returning false\");\n    return false;\n  }\n  if (NULL != memchr (content, '\\n', content_len)) {\n    log_state(\"early_return\", response, (int) kind, header, header_len, content, content_len, \"content contains '\\n' - returning false\");\n    return false;\n  }\n\n  /* About to call the unchecked API - log the event. */\n  log_state(\"call_downstream\", response, (int) kind, header, header_len, content, content_len, \"calling MHD_add_response_entry_no_check_\");\n\n  bool result = MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                                   content, content_len);\n\n  /* Log the downstream result. */\n  log_state(\"downstream_return\", response, (int) kind, header, header_len, content, content_len, result ? \"downstream returned true\" : \"downstream returned false\");\n\n  return result;\n}\n"
}