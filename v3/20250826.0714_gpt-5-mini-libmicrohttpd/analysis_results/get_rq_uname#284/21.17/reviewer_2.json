{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nA buffer-overflow can occur if get_rq_extended_uname_copy_z writes more bytes (including the terminating NUL) than the provided remaining space. The fragment passes (char *)(buf + buf_used) and size (buf_size - buf_used) to the callee and, on a non-negative return value res, assumes the callee copied exactly res bytes plus a terminating NUL and that those res+1 bytes fit into the remaining buffer. If buf_size == buf_used (so the size argument is 0) or if the callee does not enforce the provided size and writes/data-terminator beyond buf_size - buf_used, the code will have performed an access beyond the bounds of buf. Therefore Rule 21.17 is violated unless get_rq_extended_uname_copy_z is implemented to guarantee it never writes more than the supplied size (and returns negative on truncation).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for MISRA C 2023 Rule 21.17. Rule 21.17 specifically concerns the use of the Standard Library string-handling functions from <string.h> (memcpy, strcpy, strlen, etc.) and requires that their use must not access beyond the bounds of the objects passed. The code shown does not call any <string.h> functions directly \u2014 it calls project-specific helpers (get_rq_param_unquoted_copy_z, MHD_hex_to_bin, get_rq_extended_uname_copy_z). Therefore a violation of 21.17 cannot be established from this caller alone.\n\nThat said, the scenario described by agent A correctly identifies a potential buffer-overflow risk: the caller assumes that a non-negative res from get_rq_extended_uname_copy_z implies that res+1 bytes (the returned length plus a terminating NUL) were written and fit into the remaining buffer (buf_size - buf_used). If the callee does not honor the provided size and writes beyond that bound (or returns a value that implies there was space when there was not), a buffer overrun would occur \u2014 but that would be a bug in the callee (or in the contract between caller and callee), not a direct invocation of a <string.h> function violating Rule 21.17 in this caller. If the callee internally uses string.h functions incorrectly, the violation would be in that implementation.\n\nConclusion: Agent A\u2019s claim that this code violates MISRA C 2023 Rule 21.17 is false (is_report_correct = false). However, the caller does rely on the callee to respect the supplied size, so there is a separate safety/robustness concern that should be addressed (e.g. document/verify the callee\u2019s contract or add an explicit pre-check)."
}