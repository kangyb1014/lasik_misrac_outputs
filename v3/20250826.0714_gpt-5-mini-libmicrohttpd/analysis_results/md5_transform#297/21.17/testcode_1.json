{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe function calls memcpy(X, M, sizeof(X)) earlier in md5_transform to copy 64 bytes from M into X when M is unaligned. If the caller passes an M pointer that does not reference at least 64 bytes (for example a buffer shorter than one MD5 block), memcpy will read past the end of the object pointed to by M, causing an out\u2011of\u2011bounds access. This also implies subsequent GET_X_FROM_DATA reads (which index up to 15) would read beyond M if no copy was performed.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified md5_transform code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2979.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of md5_transform as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of md5_transform:\n```c\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    memcpy (X, M, sizeof(X));\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n}\n```\n</target_code>\nPlease provide the modified md5_transform code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Helper logging function that appends messages to the required log file. */\nstatic void\nmd5_log_printf (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/2979.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\n/* Probe wrapper around GET_X_FROM_DATA so every data read is logged. */\nstatic uint32_t\nprobe_GET_X_FROM_DATA (const void *buf, unsigned t)\n{\n  /* Calculate the byte address that will be read (assuming 32-bit words). */\n  const void *addr = (const void *) ((((const uint32_t *) buf) + t));\n  md5_log_printf (\"probe_GET_X_FROM_DATA: buf=%p index=%u addr=%p\\n\",\n                  buf, t, addr);\n  /* Use the original macro to obtain the value (preserve original logic). */\n  uint32_t v = GET_X_FROM_DATA (buf, t);\n  md5_log_printf (\"probe_GET_X_FROM_DATA: val=0x%08\" PRIx32 \" index=%u\\n\",\n                  v, t);\n  return v;\n}\n\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n  md5_log_printf (\"md5_transform: enter H=[0x%08\" PRIx32 \",0x%08\" PRIx32 \",0x%08\" PRIx32 \",0x%08\" PRIx32 \"] M=%p\\n\",\n                  H[0], H[1], H[2], H[3], M);\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    md5_log_printf (\"md5_transform: detected unaligned input M=%p (alignment modulus=%zu).\\n\",\n                    M, (size_t) (((uintptr_t) M) % _MHD_UINT32_ALIGN));\n    md5_log_printf (\"md5_transform: about to memcpy X(%p) <- M(%p) size=%zu\\n\",\n                    (void *) X, M, sizeof (X));\n    memcpy (X, M, sizeof (X));\n    md5_log_printf (\"md5_transform: memcpy done. X=%p now used as source.\\n\",\n                    (void *) X);\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n  else\n  {\n    md5_log_printf (\"md5_transform: input M=%p is aligned (modulus 0).\\n\", M);\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = probe_GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = probe_GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = probe_GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = probe_GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = probe_GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = probe_GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = probe_GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = probe_GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = probe_GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = probe_GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = probe_GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = probe_GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = probe_GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = probe_GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = probe_GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = probe_GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = probe_GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = probe_GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = probe_GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = probe_GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n\n  md5_log_printf (\"md5_transform: exit H=[0x%08\" PRIx32 \",0x%08\" PRIx32 \",0x%08\" PRIx32 \",0x%08\" PRIx32 \"]\\n\",\n                  H[0], H[1], H[2], H[3]);\n}\n"
}