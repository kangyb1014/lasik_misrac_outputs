{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_pool_try_alloc:\n```c\nvoid *\nMHD_pool_try_alloc (struct MemoryPool *pool,\n                    size_t size,\n                    size_t *required_bytes)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n  { /* size is too close to SIZE_MAX, very unlikely */\n    *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  if (asize > pool->end - pool->pos)\n  {\n    mhd_assert ((pool->end - pool->pos) == \\\n                ROUND_TO_ALIGN (pool->end - pool->pos));\n    if (asize <= pool->end)\n      *required_bytes = asize - (pool->end - pool->pos);\n    else\n      *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  *required_bytes = 0;\n  ret = &pool->memory[pool->end - asize];\n  pool->end -= asize;\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n_MHD_UNPOISON_MEMORY (ret, size);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The call _MHD_UNPOISON_MEMORY(ret, size) is not itself one of the <string.h> functions covered by Rule 21.17; and even if the macro expands to a string-handle like memset(ret,0,size) the code ensures the access is within bounds: asize = ROUND_TO_ALIGN_PLUS_RED_ZONE(size) is >= size, the allocation checks (returns NULL on insufficient space or overflow) guarantee that ret points into pool->memory with at least asize bytes available, and asize is used to carve out the block before calling _MHD_UNPOISON_MEMORY. Therefore the call cannot access beyond the object bounds and the rule is not violated."
}