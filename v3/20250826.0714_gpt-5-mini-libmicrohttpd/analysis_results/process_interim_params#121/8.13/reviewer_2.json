{
  "user_message": "An agent A claimed that the following process_interim_params code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of process_interim_params.\n```c\nstatic bool\nprocess_interim_params (struct MHD_Daemon *d,\n                        const struct sockaddr **ppsockaddr,\n                        socklen_t *psockaddr_len,\n                        struct MHD_InterimParams_ *params)\n{\n  if (params->fdset_size_set)\n  {\n    if (0 >= params->fdset_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) is not positive.\\n\"),\n                params->fdset_size);\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    if (MHD_D_IS_USING_THREADS_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else if (MHD_D_IS_USING_POLL_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_POLL.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else\n    { /* The daemon without internal threads, external sockets polling */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n      if (((int) FD_SETSIZE) != params->fdset_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (d,\n                  _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) does not match \" \\\n                     \"the platform FD_SETSIZE value (%d) and this platform \" \\\n                     \"does not support overriding of FD_SETSIZE.\\n\"),\n                  params->fdset_size, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n        return false;\n      }\n#else  /* HAS_FD_SETSIZE_OVERRIDABLE */\n      d->fdset_size = params->fdset_size;\n      d->fdset_size_set_by_app = true;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n    }\n  }\n\n  if (params->listen_fd_set)\n  {\n    if (MHD_INVALID_SOCKET == params->listen_fd)\n    {\n      (void) 0; /* Use MHD-created socket */\n    }\n#ifdef HAS_SIGNED_SOCKET\n    else if (0 > params->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"The value provided for MHD_OPTION_LISTEN_SOCKET \" \\\n                   \"is invalid.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n#endif /* HAS_SIGNED_SOCKET */\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET specified for daemon \"\n                   \"with MHD_USE_NO_LISTEN_SOCKET flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) MHD_socket_close_ (params->listen_fd);\n      return false;\n    }\n    else\n    {\n      d->listen_fd = params->listen_fd;\n      d->listen_is_unix = _MHD_UNKNOWN;\n#ifdef MHD_USE_GETSOCKNAME\n      d->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n    }\n  }\n\n  mhd_assert (! params->server_addr_len_set || params->pserver_addr_set);\n  if (params->pserver_addr_set)\n  {\n    if (NULL == params->pserver_addr)\n    {\n      /* The size must be zero if set */\n      if (params->server_addr_len_set && (0 != params->server_addr_len))\n        return false;\n      /* Ignore parameter if it is NULL */\n    }\n    else if (MHD_INVALID_SOCKET != d->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET cannot be used together with \" \\\n                   \"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR \" \\\n                   \"specified for daemon with MHD_USE_NO_LISTEN_SOCKET \" \\\n                   \"flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      if (MHD_INVALID_SOCKET != d->listen_fd)\n      {\n        (void) MHD_socket_close_ (params->listen_fd);\n        params->listen_fd = MHD_INVALID_SOCKET;\n      }\n      return false;\n    }\n    else\n    {\n      *ppsockaddr = params->pserver_addr;\n      if (params->server_addr_len_set)\n      {\n        /* The size must be non-zero if set */\n        if (0 == params->server_addr_len)\n          return false;\n        *psockaddr_len = params->server_addr_len;\n      }\n      else\n        *psockaddr_len = 0;\n    }\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code checks params->pserver_addr for NULL and later assigns it to *ppsockaddr (a const struct sockaddr *). If params->pserver_addr is declared as a non-const pointer (e.g. struct sockaddr *pserver_addr) then Rule 8.13 is violated because the pointer should be declared to point to a const-qualified type (const struct sockaddr *) since it is used only for input. Change the declaration to const struct sockaddr *pserver_addr to comply.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x9, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0xd, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x9, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x1, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x49, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x4d, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x49, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x209, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x209, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x9, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x1, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x9, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0xd, fdset_size_set=0, fdset_size=0\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size=1024\nEXIT process_interim_params: true\nENTER process_interim_params: pserver_addr_set=0, pserver_addr=(nil), server_addr_len_set=0, server_addr_len=0, listen_fd=-1, options=0x80001, fdset_size_set=1, fdset_size\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 8.13 requires that pointer types be const-qualified when the pointed-to object is not modified. In process_interim_params the member params->pserver_addr is only read (tested for NULL and then copied into *ppsockaddr, which is a const struct sockaddr *). If the member MHD_InterimParams_.pserver_addr is declared as a non-const pointer (e.g. struct sockaddr *pserver_addr) then Agent A\u2019s observation is correct: the code exhibits a breach of the intent of Rule 8.13 (the pointer should be declared as const struct sockaddr *). Note that converting a non-const pointer value to a const-qualified pointer is allowed by C, but MISRA 8.13 concerns the declaration/site where the pointer type is defined, not the implicit conversion. If, however, the struct already declares pserver_addr as const struct sockaddr * then there is no violation. Recommended remedy: change the MHD_InterimParams_ member declaration to const struct sockaddr *pserver_addr (and update any other code that mutates that member if such mutation actually occurs)."
}