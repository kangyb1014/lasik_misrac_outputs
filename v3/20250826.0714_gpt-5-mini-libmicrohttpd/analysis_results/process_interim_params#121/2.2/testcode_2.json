{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe expression-statement \"(void) 0;\" in the branch 'else if (MHD_D_IS_USING_POLL_(d))' is a no-op that is executed when that branch is taken. Its removal would not change program behaviour, so it constitutes dead code (violates MISRA C 2023 Rule 2.2).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_interim_params code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1212.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_interim_params as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_interim_params:\n```c\nstatic bool\nprocess_interim_params (struct MHD_Daemon *d,\n                        const struct sockaddr **ppsockaddr,\n                        socklen_t *psockaddr_len,\n                        struct MHD_InterimParams_ *params)\n{\n  if (params->fdset_size_set)\n  {\n    if (0 >= params->fdset_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) is not positive.\\n\"),\n                params->fdset_size);\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    if (MHD_D_IS_USING_THREADS_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else if (MHD_D_IS_USING_POLL_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_POLL.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) 0;\n    }\n    else\n    { /* The daemon without internal threads, external sockets polling */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n      if (((int) FD_SETSIZE) != params->fdset_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (d,\n                  _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) does not match \" \\\n                     \"the platform FD_SETSIZE value (%d) and this platform \" \\\n                     \"does not support overriding of FD_SETSIZE.\\n\"),\n                  params->fdset_size, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n        return false;\n      }\n#else  /* HAS_FD_SETSIZE_OVERRIDABLE */\n      d->fdset_size = params->fdset_size;\n      d->fdset_size_set_by_app = true;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n    }\n  }\n\n  if (params->listen_fd_set)\n  {\n    if (MHD_INVALID_SOCKET == params->listen_fd)\n    {\n      (void) 0; /* Use MHD-created socket */\n    }\n#ifdef HAS_SIGNED_SOCKET\n    else if (0 > params->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"The value provided for MHD_OPTION_LISTEN_SOCKET \" \\\n                   \"is invalid.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n#endif /* HAS_SIGNED_SOCKET */\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET specified for daemon \"\n                   \"with MHD_USE_NO_LISTEN_SOCKET flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      (void) MHD_socket_close_ (params->listen_fd);\n      return false;\n    }\n    else\n    {\n      d->listen_fd = params->listen_fd;\n      d->listen_is_unix = _MHD_UNKNOWN;\n#ifdef MHD_USE_GETSOCKNAME\n      d->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n    }\n  }\n\n  mhd_assert (! params->server_addr_len_set || params->pserver_addr_set);\n  if (params->pserver_addr_set)\n  {\n    if (NULL == params->pserver_addr)\n    {\n      /* The size must be zero if set */\n      if (params->server_addr_len_set && (0 != params->server_addr_len))\n        return false;\n      /* Ignore parameter if it is NULL */\n    }\n    else if (MHD_INVALID_SOCKET != d->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET cannot be used together with \" \\\n                   \"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return false;\n    }\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR \" \\\n                   \"specified for daemon with MHD_USE_NO_LISTEN_SOCKET \" \\\n                   \"flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      if (MHD_INVALID_SOCKET != d->listen_fd)\n      {\n        (void) MHD_socket_close_ (params->listen_fd);\n        params->listen_fd = MHD_INVALID_SOCKET;\n      }\n      return false;\n    }\n    else\n    {\n      *ppsockaddr = params->pserver_addr;\n      if (params->server_addr_len_set)\n      {\n        /* The size must be non-zero if set */\n        if (0 == params->server_addr_len)\n          return false;\n        *psockaddr_len = params->server_addr_len;\n      }\n      else\n        *psockaddr_len = 0;\n    }\n  }\n  return true;\n}\n```\n</target_code>\nPlease provide the modified process_interim_params code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n/* Probe logging helper: appends messages to /tmp/logs/1212.txt\n   Keeps side-effects limited to logging only. */\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/1212.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  time_t t = time(NULL);\n  if (t != (time_t)-1)\n  {\n    struct tm *tm = localtime(&t);\n    if (tm != NULL)\n      fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \",\n              tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n              tm->tm_hour, tm->tm_min, tm->tm_sec);\n  }\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic void\nmhd_probe_log_state_start (const struct MHD_Daemon *d,\n                           const struct MHD_InterimParams_ *params)\n{\n  /* Log entry state: pointer addresses and key param values. */\n  mhd_probe_log(\"ENTER process_interim_params: d=%p, params=%p, fdset_size_set=%d, fdset_size=%lld, listen_fd_set=%d, listen_fd=%lld, server_addr_len_set=%d, pserver_addr_set=%d, server_addr_len=%lld\",\n                (const void *)d, (const void *)params,\n                (int) (params ? params->fdset_size_set : 0),\n                (long long) (params ? params->fdset_size : 0),\n                (int) (params ? params->listen_fd_set : 0),\n                (long long) (params ? params->listen_fd : 0),\n                (int) (params ? params->server_addr_len_set : 0),\n                (int) (params ? params->pserver_addr_set : 0),\n                (long long) (params ? params->server_addr_len : 0));\n}\n\nstatic void\nmhd_probe_log_state_end (const struct MHD_Daemon *d, bool result)\n{\n  mhd_probe_log(\"EXIT process_interim_params: d=%p, result=%d\",\n                (const void *)d, (int) result);\n}\n\nstatic bool\nprocess_interim_params (struct MHD_Daemon *d,\n                        const struct sockaddr **ppsockaddr,\n                        socklen_t *psockaddr_len,\n                        struct MHD_InterimParams_ *params)\n{\n  /* Log start state */\n  mhd_probe_log_state_start (d, params);\n\n  if (params->fdset_size_set)\n  {\n    if (0 >= params->fdset_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) is not positive.\\n\"),\n                params->fdset_size);\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"branch: fdset_size_set && fdset_size <= 0 -> returning false; fdset_size=%lld\",\n                    (long long) params->fdset_size);\n      mhd_probe_log_state_end (d, false);\n      return false;\n    }\n    if (MHD_D_IS_USING_THREADS_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif /* HAVE_MESSAGES */\n      /* Original no-op retained; add probe before it to record the path */\n      mhd_probe_log(\"branch: MHD_D_IS_USING_THREADS_ taken; executing no-op\");\n      (void) 0;\n    }\n    else if (MHD_D_IS_USING_POLL_ (d))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_APP_FD_SETSIZE is ignored for daemon started \" \\\n                   \"with MHD_USE_POLL.\\n\"));\n#endif /* HAVE_MESSAGES */\n      /* This is the location reported as the violation scenario: the no-op\n         is executed when this branch is taken. Record that occurrence. */\n      mhd_probe_log(\"branch: MHD_D_IS_USING_POLL_ taken; original code had a no-op '(void) 0;' here\");\n      (void) 0;\n    }\n    else\n    { /* The daemon without internal threads, external sockets polling */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n      if (((int) FD_SETSIZE) != params->fdset_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (d,\n                  _ (\"MHD_OPTION_APP_FD_SETSIZE value (%d) does not match \" \\\n                     \"the platform FD_SETSIZE value (%d) and this platform \" \\\n                     \"does not support overriding of FD_SETSIZE.\\n\"),\n                  params->fdset_size, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n        mhd_probe_log(\"branch: no-threads-no-poll and FD_SETSIZE mismatch -> returning false; params->fdset_size=%lld, FD_SETSIZE=%d\",\n                      (long long) params->fdset_size, (int) FD_SETSIZE);\n        mhd_probe_log_state_end (d, false);\n        return false;\n      }\n#else  /* HAS_FD_SETSIZE_OVERRIDABLE */\n      d->fdset_size = params->fdset_size;\n      d->fdset_size_set_by_app = true;\n      mhd_probe_log(\"action: FD_SETSIZE overridable -> set d->fdset_size=%lld, d->fdset_size_set_by_app=true\",\n                    (long long) params->fdset_size);\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n    }\n  }\n\n  if (params->listen_fd_set)\n  {\n    if (MHD_INVALID_SOCKET == params->listen_fd)\n    {\n      (void) 0; /* Use MHD-created socket */\n      mhd_probe_log(\"branch: listen_fd_set && listen_fd == MHD_INVALID_SOCKET -> use MHD-created socket\");\n    }\n#ifdef HAS_SIGNED_SOCKET\n    else if (0 > params->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"The value provided for MHD_OPTION_LISTEN_SOCKET \" \\\n                   \"is invalid.\\n\"));\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"branch: listen_fd_set && listen_fd < 0 -> returning false; listen_fd=%lld\",\n                    (long long) params->listen_fd);\n      mhd_probe_log_state_end (d, false);\n      return false;\n    }\n#endif /* HAS_SIGNED_SOCKET */\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET specified for daemon \"\n                   \"with MHD_USE_NO_LISTEN_SOCKET flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"branch: listen_fd_set but MHD_USE_NO_LISTEN_SOCKET set -> closing provided listen_fd=%lld and returning false\",\n                    (long long) params->listen_fd);\n      (void) MHD_socket_close_ (params->listen_fd);\n      mhd_probe_log_state_end (d, false);\n      return false;\n    }\n    else\n    {\n      d->listen_fd = params->listen_fd;\n      d->listen_is_unix = _MHD_UNKNOWN;\n#ifdef MHD_USE_GETSOCKNAME\n      d->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n      mhd_probe_log(\"action: listen_fd accepted and set on daemon: d->listen_fd=%lld\",\n                    (long long) d->listen_fd);\n    }\n  }\n\n  mhd_assert (! params->server_addr_len_set || params->pserver_addr_set);\n  if (params->pserver_addr_set)\n  {\n    if (NULL == params->pserver_addr)\n    {\n      /* The size must be zero if set */\n      if (params->server_addr_len_set && (0 != params->server_addr_len))\n      {\n        mhd_probe_log(\"branch: pserver_addr_set && pserver_addr == NULL but server_addr_len_set && server_addr_len != 0 -> returning false; server_addr_len=%lld\",\n                      (long long) params->server_addr_len);\n        mhd_probe_log_state_end (d, false);\n        return false;\n      }\n      /* Ignore parameter if it is NULL */\n      mhd_probe_log(\"branch: pserver_addr_set && pserver_addr == NULL -> ignoring parameter\");\n    }\n    else if (MHD_INVALID_SOCKET != d->listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_LISTEN_SOCKET cannot be used together with \" \\\n                   \"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR.\\n\"));\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"branch: pserver_addr_set && pserver_addr != NULL but d->listen_fd is already set -> returning false\");\n      mhd_probe_log_state_end (d, false);\n      return false;\n    }\n    else if (0 != (d->options & MHD_USE_NO_LISTEN_SOCKET))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (d,\n                _ (\"MHD_OPTION_SOCK_ADDR_LEN or MHD_OPTION_SOCK_ADDR \" \\\n                   \"specified for daemon with MHD_USE_NO_LISTEN_SOCKET \" \\\n                   \"flag set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"branch: pserver_addr_set && MHD_USE_NO_LISTEN_SOCKET set -> cleaning up and returning false\");\n      if (MHD_INVALID_SOCKET != d->listen_fd)\n      {\n        (void) MHD_socket_close_ (params->listen_fd);\n        params->listen_fd = MHD_INVALID_SOCKET;\n      }\n      mhd_probe_log_state_end (d, false);\n      return false;\n    }\n    else\n    {\n      *ppsockaddr = params->pserver_addr;\n      if (params->server_addr_len_set)\n      {\n        /* The size must be non-zero if set */\n        if (0 == params->server_addr_len)\n        {\n          mhd_probe_log(\"branch: pserver_addr_set && server_addr_len_set but server_addr_len == 0 -> returning false\");\n          mhd_probe_log_state_end (d, false);\n          return false;\n        }\n        *psockaddr_len = params->server_addr_len;\n        mhd_probe_log(\"action: pserver_addr accepted; psockaddr set, psockaddr_len=%lld\",\n                      (long long) params->server_addr_len);\n      }\n      else\n        *psockaddr_len = 0;\n    }\n  }\n  mhd_probe_log_state_end (d, true);\n  return true;\n}\n"
}