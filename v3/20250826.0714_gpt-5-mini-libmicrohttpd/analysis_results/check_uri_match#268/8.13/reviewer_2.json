{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code declares a const pointer to a non-const object: 'struct MHD_Daemon *const daemon = connection->daemon;'. The function only reads members of *daemon (calls daemon->unescape_callback and uses daemon for logging) and does not modify the pointed-to object, so the pointer should point to a const-qualified type. Replace with 'const struct MHD_Daemon *const daemon = connection->daemon;' (or 'const struct MHD_Daemon *daemon') to satisfy MISRA C 2023 Rule 8.13. Note: if the function actually needs to modify the daemon object, then leaving it non-const is acceptable; otherwise this is a violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Rule 8.13 asks that a pointer should point to a const-qualified type whenever possible. In the function the local is declared as a const pointer to a non-const object: 'struct MHD_Daemon *const daemon = connection->daemon;'. The function only reads members of *daemon (invoking the unescape_callback function pointer and using daemon for logging) and does not modify the daemon object through this pointer, so the pointed-to type can and should be const-qualified. Changing the declaration to 'const struct MHD_Daemon *const daemon' (or 'const struct MHD_Daemon *daemon') would satisfy the rule. The only caveat is if any code invoked here (or elsewhere in the function) needs to modify the daemon object via this pointer or if the callback semantics require a non-const access \u2014 in that case the non-const pointed-to type would be necessary. Given the shown code, no such modification occurs, so the report of a Rule 8.13 violation is correct."
}