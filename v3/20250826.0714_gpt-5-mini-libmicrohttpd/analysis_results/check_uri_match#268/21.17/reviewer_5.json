{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the caller provided a buffer of size uri_len (valid indices 0..uri_len-1), the code writes uri[uri_len] = 0 just before the memchr call which already writes out of bounds. More generally, memchr(uri, '?', uri_len) will read uri_len bytes starting at uri \u2014 if uri_len exceeds the actual allocated size of the object pointed to by uri (e.g. caller passed a pointer to an N-byte buffer but uri_len > N), memchr will access beyond the object. Therefore the use of memchr here can violate Rule 21.17 when uri_len is not guaranteed to be <= the buffer size.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[ENTRY] connection=0x7f77cc000b70, daemon=0x55ebcc22c0e0, uri=0x7f77d1202f70, uri_len=71, qmark=(nil)\n[ENTRY] connection->rq.url_len=8\n[ENTRY] daemon->unescape_callback=0x7f77d2417ff0, daemon->unescape_callback_cls=(nil)\nAbout to write '\\0' at address 0x7f77d1202fb7 (uri + uri_len)\nWrote termination byte at uri + uri_len\nmemchr returned qmark=0x7f77d1202f7a\n[AFTER_QMARK_AND_TERMINATE] connection=0x7f77cc000b70, daemon=0x55ebcc22c0e0, uri=0x7f77d1202f70, uri_len=71, qmark=0x7f77d1202f7a\n[AFTER_QMARK_AND_TERMINATE] connection->rq.url_len=8\n[AFTER_QMARK_AND_TERMINATE] daemon->unescape_callback=0x7f77d2417ff0, daemon->unescape_callback_cls=(nil)\nCalling unescape_callback\nunescape_callback returned new uri_len=8\n[AFTER_UNESCAPE] connection=0x7f77cc000b70, daemon=0x55ebcc22c0e0, uri=0x7f77d1202f70, uri_len=8, qmark=0x7f77d1202f7a\n[AFTER_UNESCAPE] connection->rq.url_len=8\n[AFTER_UNESCAPE] daemon->unescape_callback=0x7f77d2417ff0, daemon->unescape_callback_cls=(nil)\nArguments start at args=0x7f77d1202f7b (qmark=0x7f77d1202f7a)\nAuthentication succeeded: URI and arguments match\n[ENTRY] connection=0x7fe4d0000b70, daemon=0x56330fe100e0, uri=0x7fe4d727ff70, uri_len=20, qmark=(nil)\n[ENTRY] connection->rq.url_len=8\n[ENTRY] daemon->unescape_callback=0x7fe4d8494ff0, daemon->unescape_callback_cls=(nil)\nAbout to write '\\0' at address 0x7fe4d727ff84 (uri + uri_len)\nWrote termination byte at uri + uri_len\nmemchr returned qmark=0x7fe4d727ff7a\n[AFTER_QMARK_AND_TERMINATE] connection=0x7fe4d0000b70, daemon=0x56330fe100e0, uri=0x7fe4d727ff70, uri_len=20, qmark=0x7fe4d727ff7a\n[AFTER_QMARK_AND_TERMINATE] connection->rq.url_len=8\n[AFTER_QMARK_AND_TERMINATE] daemon->unescape_callback=0x7fe4d8494ff0, daemon->unescape_callback_cls=(nil)\nCalling unescape_callback\nunescape_callback returned new uri_len=8\n[AFTER_UNESCAPE] connection=0x7fe4d0000b70, daemon=0x56330fe100e0, uri=0x7fe4d727ff70, uri_len=8, qmark=0x7fe4d727ff7a\n[AFTER_UNESCAPE] connection->rq.url_len=8\n[AFTER_UNESCAPE] daemon->unescape_callback=0x7fe4d8494ff0, daemon->unescape_callback_cls=(nil)\nArguments start at args=0x7fe4d727ff7b (qmark=0x7fe4d727ff7a)\nAuthentication succeeded: URI and arguments match\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls memchr(uri, '?', uri_len) which will read uri_len bytes starting at uri \u2014 this is a direct use of a <string.h> function that can access beyond the object if the actual buffer is smaller than uri_len. Moreover the code immediately writes uri[uri_len] = 0 (a store at index uri_len), which is an out\u2011of\u2011bounds write when the caller provided a buffer of size uri_len (valid indices 0..uri_len-1). Unless there is a documented and enforced precondition that the object pointed to by uri has at least uri_len+1 bytes (and at least uri_len bytes for memchr), the usage can result in accesses beyond object bounds and therefore violates MISRA C 2023 Rule 21.17."
}