{
  "user_message": "An agent A claimed that the following check_uri_match code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of check_uri_match.\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe write uri[uri_len] = 0 may write one past the end of the buffer if the caller supplied a buffer whose allocated size equals uri_len (i.e. no space for a terminating NUL). In that case the code performs an out-of-bounds write and can lead to subsequent string-handling calls (memchr/memcmp) accessing memory beyond the object bounds. Because the buffer size is not guaranteed by the function signature, this is a potential violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The line uri[uri_len] = 0 performs an unchecked write at index uri_len and therefore requires that the caller provided a buffer of size at least uri_len + 1. That requirement is not enforced by the function signature or checked in the function. If the caller supplied a buffer whose allocated size equals uri_len, that write is out-of-bounds. In addition, the code then calls memchr/memcmp with uri and lengths derived from uri_len (and later from the unescape_callback result). If the buffer is smaller than the length passed to these functions (either because the original buffer was exactly uri_len long or because unescape_callback returns a larger length), memchr/memcmp can access beyond the object bounds. MISRA C:2023 Rule 21.17 forbids uses of the <string.h> functions that can result in accesses beyond the bounds of the referenced objects, so this code can violate that rule. Remediation: ensure the buffer has at least uri_len+1 bytes (or pass the buffer capacity into the function and check it), or avoid writing the terminating NUL and use length-limited operations that do not require it."
}