{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf 'value' points to a non-NULL char array that is not NUL-terminated (for example: char buf[3] = {'a','b','c'}; value = buf;), strlen(value) will scan past the bounds looking for '\\0' and thus access memory beyond the object. The NULL check does not guarantee a valid NUL-terminated string, so this use of strlen can lead to out-of-bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_set_connection_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/179.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_set_connection_value as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_set_connection_value:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value (struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          const char *value)\n{\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              NULL != key\n                                              ? strlen (key)\n                                              : 0,\n                                              value,\n                                              NULL != value\n                                              ? strlen (value)\n                                              : 0);\n}\n```\n</target_code>\nPlease provide the modified MHD_set_connection_value code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/* Probe logger: append structured runtime info to /tmp/logs/179.txt */\nstatic void mhd_log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/179.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value (struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          const char *value)\n{\n  /* Log entry and pointer state. We compute the lengths exactly once to preserve\n     the original behaviour (strlen may scan memory looking for '\\0'). Do not\n     perform additional dereferences of key/value to avoid introducing new\n     out-of-bounds accesses beyond what the original code performs. */\n  size_t key_len = 0;\n  size_t value_len = 0;\n\n  mhd_log_probe(\"MHD_set_connection_value ENTRY: connection=%p, kind=%d, key=%p, value=%p\",\n                (void *) connection, (int) kind, (const void *) key, (const void *) value);\n\n  if (NULL != key)\n    {\n      /* This strlen mirrors the original code's potential scan beyond bounds\n         if 'key' does not point to a NUL-terminated array. Logging the length\n         afterwards provides evidence of what strlen discovered. */\n      key_len = strlen(key);\n    }\n  mhd_log_probe(\"key pointer=%p, key_is_nonNULL=%d, key_len=%zu\",\n                (const void *) key, NULL != key, key_len);\n\n  if (NULL != value)\n    {\n      /* This strlen mirrors the original code's potential scan beyond bounds\n         if 'value' does not point to a NUL-terminated array. This single\n         call preserves the original control flow and is not duplicated. */\n      value_len = strlen(value);\n    }\n  mhd_log_probe(\"value pointer=%p, value_is_nonNULL=%d, value_len=%zu\",\n                (const void *) value, NULL != value, value_len);\n\n  enum MHD_Result result = MHD_set_connection_value_n_nocheck_ (connection,\n                                                               kind,\n                                                               key,\n                                                               NULL != key\n                                                               ? key_len\n                                                               : 0,\n                                                               value,\n                                                               NULL != value\n                                                               ? value_len\n                                                               : 0);\n\n  mhd_log_probe(\"MHD_set_connection_value EXIT: result=%d\", (int) result);\n  return result;\n}\n"
}