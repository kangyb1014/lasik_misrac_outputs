{
  "user_message": "An agent A claimed that the following MHD_lookup_connection_value_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_lookup_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment reads and compares pos->header but does not modify it. If the struct member pos->header is declared as a non-const pointer (e.g. char *header), then Rule 8.13 is violated: a pointer that is only used for reading (compared to the const char *key and passed to MHD_str_equal_caseless_bin_n_) should be declared const (const char *header). The exact locations are the pointer-equality test (key == pos->header) and the call MHD_str_equal_caseless_bin_n_(key, pos->header, key_size).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTRY: MHD_lookup_connection_value_n(connection=0x55f3996d2270, kind=0x1, key=0x7feb9f0c9a7f, key_size=6, value_ptr=0x7fff7ef0b968, value_size_ptr=0x7fff7ef0b960)\nLOOP(key): pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->header_size=4, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=4) (pos=0x55f3996da480)\nLOOP(key): pos=0x55f3996da440, pos->header=0x55f3996d24e2, pos->header_size=10, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=10) (pos=0x55f3996da440)\nLOOP(key): pos=0x55f3996da400, pos->header=0x55f3996d24ff, pos->header_size=14, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=14) (pos=0x55f3996da400)\nLOOP(key): pos=0x55f3996da3c0, pos->header=0x55f3996d2513, pos->header_size=12, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=12) (pos=0x55f3996da3c0)\nEXIT: no matching header found -> MHD_NO\nENTRY: MHD_lookup_connection_value_n(connection=0x55f3996d2270, kind=0x1, key=0x7feb9f0c94b0, key_size=4, value_ptr=(nil), value_size_ptr=(nil))\nLOOP(key): pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->header_size=4, pos->kind=0x1\nSTRING COMPARE: key=0x7feb9f0c94b0 pos->header=0x55f3996d24d1 key_size=4 -> MHD_str_equal_caseless_bin_n_ result=1 (pos=0x55f3996da480)\nFOUND: pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->value=0x55f3996d24d7, pos->value_size=9\nEXIT: returning MHD_YES\nENTRY: MHD_lookup_connection_value_n(connection=0x55f3996d2270, kind=0x1, key=0x7feb9f0c970f, key_size=17, value_ptr=0x7fff7ef0b9b8, value_size_ptr=(nil))\nLOOP(key): pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->header_size=4, pos->kind=0x1\nSKIP: header_size mismatch (key_size=17 != pos->header_size=4) (pos=0x55f3996da480)\nLOOP(key): pos=0x55f3996da440, pos->header=0x55f3996d24e2, pos->header_size=10, pos->kind=0x1\nSKIP: header_size mismatch (key_size=17 != pos->header_size=10) (pos=0x55f3996da440)\nLOOP(key): pos=0x55f3996da400, pos->header=0x55f3996d24ff, pos->header_size=14, pos->kind=0x1\nSKIP: header_size mismatch (key_size=17 != pos->header_size=14) (pos=0x55f3996da400)\nLOOP(key): pos=0x55f3996da3c0, pos->header=0x55f3996d2513, pos->header_size=12, pos->kind=0x1\nSKIP: header_size mismatch (key_size=17 != pos->header_size=12) (pos=0x55f3996da3c0)\nEXIT: no matching header found -> MHD_NO\nENTRY: MHD_lookup_connection_value_n(connection=0x55f3996d2270, kind=0x1, key=0x7feb9f0c97b4, key_size=14, value_ptr=0x7fff7ef0b9c0, value_size_ptr=0x7fff7ef0b9b0)\nLOOP(key): pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->header_size=4, pos->kind=0x1\nSKIP: header_size mismatch (key_size=14 != pos->header_size=4) (pos=0x55f3996da480)\nLOOP(key): pos=0x55f3996da440, pos->header=0x55f3996d24e2, pos->header_size=10, pos->kind=0x1\nSKIP: header_size mismatch (key_size=14 != pos->header_size=10) (pos=0x55f3996da440)\nLOOP(key): pos=0x55f3996da400, pos->header=0x55f3996d24ff, pos->header_size=14, pos->kind=0x1\nSTRING COMPARE: key=0x7feb9f0c97b4 pos->header=0x55f3996d24ff key_size=14 -> MHD_str_equal_caseless_bin_n_ result=1 (pos=0x55f3996da400)\nFOUND: pos=0x55f3996da400, pos->header=0x55f3996d24ff, pos->value=0x55f3996d250f, pos->value_size=2\nEXIT: returning MHD_YES\nENTRY: MHD_lookup_connection_value_n(connection=0x55f3996d2270, kind=0x1, key=0x7feb9f0c9da9, key_size=6, value_ptr=0x7fff7ef0b9b8, value_size_ptr=(nil))\nLOOP(key): pos=0x55f3996da480, pos->header=0x55f3996d24d1, pos->header_size=4, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=4) (pos=0x55f3996da480)\nLOOP(key): pos=0x55f3996da440, pos->header=0x55f3996d24e2, pos->header_size=10, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=10) (pos=0x55f3996da440)\nLOOP(key): pos=0x55f3996da400, pos->header=0x55f3996d24ff, pos->header_size=14, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=14) (pos=0x55f3996da400)\nLOOP(key): pos=0x55f3996da3c0, pos->header=0x55f3996d2513, pos->header_size=12, pos->kind=0x1\nSKIP: header_size mismatch (key_size=6 != pos->header_size=12) (pos=0x55f3996da3c0)\nEXIT: no matching header found -> M\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim cannot be confirmed from the provided snippet alone. Rule 8.13 says a pointer type should be const-qualified when it only needs read access. In the shown function pos->header is only read (compared and passed to MHD_str_equal_caseless_bin_n_) and pos->value is returned via a const char **, so if the struct member MHD_HTTP_Req_Header::header is declared as non-const (e.g. char *header) and there are no other uses that require mutation, then that declaration would be a violation of Rule 8.13 and the agent A report would be correct. However, the struct definition and other uses of header/value are not provided \u2014 if the members are already declared const char * (or if they must be non-const because other code modifies them), there is no violation. Therefore the report as stated is not provably correct from the given code alone; verification requires inspecting the declaration of struct MHD_HTTP_Req_Header and its other uses."
}