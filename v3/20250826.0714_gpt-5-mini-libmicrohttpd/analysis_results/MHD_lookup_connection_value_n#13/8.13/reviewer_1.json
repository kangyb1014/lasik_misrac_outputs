{
  "user_message": "An agent A claimed that the following MHD_lookup_connection_value_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_lookup_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes a non-const pointer to the connection (struct MHD_Connection *connection) and uses a non-const iterator (struct MHD_HTTP_Req_Header *pos) even though the function only reads from those objects. Neither the connection nor the header nodes are modified in the body. According to MISRA C 2023 Rule 8.13 these should be const-qualified (e.g. const struct MHD_Connection *connection and const struct MHD_HTTP_Req_Header *pos). The other parameters (const char *key, const char **value_ptr) are appropriately const; value_size_ptr cannot be const because it is used as an output parameter.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_lookup_connection_value_n: entry: connection=0x5555ad11f270, kind=1, key=0x7fa9e2e6cad1, key_size=6, value_ptr=0x7fff2b48ca08, value_size_ptr=0x7fff2b48ca00\nMHD_lookup_connection_value_n: searching for header named key='Cookie' (size=6)\niter: pos=0x5555ad127480, header=0x5555ad11f4d1, header_size=4, kind=1, pos->kind=1, value=0x5555ad11f4d7, value_size=9\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127440, header=0x5555ad11f4e2, header_size=10, kind=1, pos->kind=1, value=0x5555ad11f4ee, value_size=15\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127400, header=0x5555ad11f4ff, header_size=14, kind=1, pos->kind=1, value=0x5555ad11f50f, value_size=2\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad1273c0, header=0x5555ad11f513, header_size=12, kind=1, pos->kind=1, value=0x5555ad11f521, value_size=10\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\nMHD_lookup_connection_value_n: no matching header found -> returning MHD_NO\nMHD_lookup_connection_value_n: entry: connection=0x5555ad11f270, kind=1, key=0x7fa9e2e6c502, key_size=4, value_ptr=(nil), value_size_ptr=(nil)\nMHD_lookup_connection_value_n: searching for header named key='Host' (size=4)\niter: pos=0x5555ad127480, header=0x5555ad11f4d1, header_size=4, kind=1, pos->kind=1, value=0x5555ad11f4d7, value_size=9\niter: match (key comparison succeeded) at pos=0x5555ad127480 -> breaking\nMHD_lookup_connection_value_n: match found at pos=0x5555ad127480 -> returning MHD_YES\nMHD_lookup_connection_value_n: entry: connection=0x5555ad11f270, kind=1, key=0x7fa9e2e6c761, key_size=17, value_ptr=0x7fff2b48ca58, value_size_ptr=(nil)\nMHD_lookup_connection_value_n: searching for header named key='Transfer-Encoding' (size=17)\niter: pos=0x5555ad127480, header=0x5555ad11f4d1, header_size=4, kind=1, pos->kind=1, value=0x5555ad11f4d7, value_size=9\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127440, header=0x5555ad11f4e2, header_size=10, kind=1, pos->kind=1, value=0x5555ad11f4ee, value_size=15\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127400, header=0x5555ad11f4ff, header_size=14, kind=1, pos->kind=1, value=0x5555ad11f50f, value_size=2\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad1273c0, header=0x5555ad11f513, header_size=12, kind=1, pos->kind=1, value=0x5555ad11f521, value_size=10\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\nMHD_lookup_connection_value_n: no matching header found -> returning MHD_NO\nMHD_lookup_connection_value_n: entry: connection=0x5555ad11f270, kind=1, key=0x7fa9e2e6c806, key_size=14, value_ptr=0x7fff2b48ca60, value_size_ptr=0x7fff2b48ca50\nMHD_lookup_connection_value_n: searching for header named key='Content-Length' (size=14)\niter: pos=0x5555ad127480, header=0x5555ad11f4d1, header_size=4, kind=1, pos->kind=1, value=0x5555ad11f4d7, value_size=9\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127440, header=0x5555ad11f4e2, header_size=10, kind=1, pos->kind=1, value=0x5555ad11f4ee, value_size=15\niter: conditions: kind_match=1, size_match=0, ptr_equal=0, caseless_eq=0\niter: pos=0x5555ad127400, header=0x5555ad11f4ff, header_size=14, kind=1, pos->kind=1, value=0x5555ad11f50f, value_size=2\niter: match (key comparison succeeded) at pos=0x5555ad127400 -> breaking\nMHD_lookup_connection_value_n: setting *value_ptr=0x5555ad11f50f\nMHD_lookup_connection_value_n: setting *value_size_ptr=2\nMHD_lookup_connection_value_n: match found at pos=0x5555ad127400 -> returning MHD_YES\nMHD_lookup_connection_value_n: entry: connection=0x5555ad11f270, kind=1, key=0x7fa9e2e6cdfb, key_size=6, value_ptr=0x7fff2b48ca58, value_size_ptr=(nil)\nMHD_lookup_connection_value_n: searching for header named key='Expect' (size=6)\niter: pos=0x5555ad127480, header=0x5555ad11f4d1, header_size=4, kind=1, pos->kind=1, value=0x5555ad11f4d7, value_size=9\niter: condi\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In MHD_lookup_connection_value_n the function never modifies the object pointed to by the connection parameter nor the headers it iterates: all accesses are reads (comparisons, reading members, following next pointers, returning pos->value/pos->value_size). According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the formal parameter could be declared const struct MHD_Connection *connection and the local iterator as const struct MHD_HTTP_Req_Header *pos. The existing const qualifications on key and the value pointee are appropriate; value_size_ptr cannot be const because it is an output. One practical caveat: changing the function signature is an API change \u2014 if this is part of a published API/ABI that must remain unchanged, the deviation may be justified. Absent that justification, the code violates Rule 8.13."
}