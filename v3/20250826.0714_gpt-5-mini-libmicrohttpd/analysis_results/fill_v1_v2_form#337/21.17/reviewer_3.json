{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the format string SECOND_PAGE contains conversion specifications that are not a simple pair of %s replacements (for example extra %s specifiers, width/precision specifiers, or other conversions), the call can invoke undefined behaviour and may access memory out of bounds. Concrete examples: (1) SECOND_PAGE = \"%s%s%s\" \u2014 only two arguments are supplied, so the third %s causes snprintf to read an unintended pointer from the stack (out\u2011of\u2011bounds access). (2) SECOND_PAGE = \"...%20s...%s...\" \u2014 field width/precision or other format modifiers can make the produced output longer than the computed slen, leading to mismatch between allocated buffer and required content (and thus potential invalid accesses or truncation/UB depending on usage). Therefore the fragment can violate the rule.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identifies a real correctness/UB risk in the code: the computed slen assumes SECOND_PAGE expands to exactly the concatenation of two %s replacements, and if SECOND_PAGE contains extra/mismatched conversion specifiers or uses width/precision modifiers the snprintf call can (a) attempt to read nonexistent varargs (undefined behavior) and/or (b) produce output longer than the allocated buffer (buffer overflow/truncation). Those examples are valid problems in the code. However, MISRA C 2023 Rule 21.17 (as quoted) is specifically about use of the string.h functions (it explicitly lists functions such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn). The UB risk here is caused by misuse of printf-style formatting (snprintf, from <stdio.h>), not by a string.h routine exceeding the bounds of the objects referenced by its pointer parameters. Therefore the reported rule number is not correctly applied: the code does have a format/size mismatch bug, but this is not a violation of MISRA C 2023 Rule 21.17 as stated. It may, however, violate other MISRA guidelines about format-string/argument matching and buffer-size calculation. Recommended fixes: ensure SECOND_PAGE is a fixed literal with exactly the expected two %s (no other conversions or width modifiers), or avoid printf formatting by composing the reply safely (e.g. precompute required size with vsnprintf using the same format and arguments or use functions that guarantee bounds), and validate that session->value_1/2 are NUL-terminated."
}