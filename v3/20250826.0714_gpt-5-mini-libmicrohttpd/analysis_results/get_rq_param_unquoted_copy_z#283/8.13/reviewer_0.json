{
  "user_message": "An agent A claimed that the following get_rq_param_unquoted_copy_z code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_param_unquoted_copy_z.\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nparam->value.str is used only for reading (passed to memcpy and MHD_str_unquote) but is likely declared as char * (pointer to non-const data). The MISRA rule 8.13 requires pointers to point to const-qualified types whenever possible, so the struct field should be declared as const char * (or equivalent) to show the pointee is not modified. Passing param->value.str as shown indicates the pointee is not const-qualified \u2014 violation: change the field to const char * so the pointer points to a const-qualified type.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim cannot be decided from the snippet alone. MISRA 8.13 concerns how pointers are declared; it requires that a pointer type be declared to point to a const-qualified target when that pointee is never modified. The code here only reads param->value.str (passes it to memcpy/MHD_str_unquote) so the usage in this function is read-only, but the rule applies to the declaration of the member (and to its use across the whole program), not to this call site.\n\nTwo important points:\n- The function parameter is const struct MHD_RqDAuthParam *param. That makes the struct object const in this function, but it does not change the declared pointee type of the member. If value.str is declared as char * inside the struct, the expression param->value.str has type char * const (the pointer is const, the pointee is not). That will still implicitly convert to const char * for calls that expect a const source, so the calls here compile, but the declared member would still be non-const.\n- Whether a MISRA 8.13 violation actually exists depends on the declaration and the broader use of that member: if the struct member is indeed declared as char * and the pointee is never modified anywhere, then MISRA 8.13 would require changing the declaration to const char *. If the pointee is modified elsewhere (or must remain non-const for other reasons), then keeping char * may be justified and not a violation.\n\nConclusion: you cannot conclude a definitive MISRA 8.13 violation from the provided function alone. To verify the report, inspect the declaration of MHD_RqDAuthParam.value.str and its uses across the code base; if it is declared as char * and the pointed data is never written, then the report is correct and the member should be changed to const char *."
}