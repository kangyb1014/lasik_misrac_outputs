{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code calls memcpy(buf, param->value.str, param->value.len) and then writes buf[param->value.len] = 0 without any guarantee that buf has space for an additional NUL. If buf refers to an object sized exactly param->value.len (or smaller), the subsequent write (and possibly the memcpy itself if buf is smaller than param->value.len) will access beyond the bounds of the object. Since memcpy (from <string.h>) is used, this can violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_rq_param_unquoted_copy_z code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2839.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_rq_param_unquoted_copy_z as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_rq_param_unquoted_copy_z:\n```c\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n```\n</target_code>\nPlease provide the modified get_rq_param_unquoted_copy_z code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n\n/* Minimal test-friendly definitions to allow compilation and logging probes. */\nstruct MHD_RqDAuthParam {\n  struct {\n    const char *str;\n    size_t len;\n  } value;\n  int quoted; /* non-zero if the value is quoted */\n};\n\n/* Simple assert replacement as a function (keeps call site unchanged). */\nstatic void mhd_assert (int cond)\n{\n  if (! cond)\n  {\n    FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"mhd_assert failed\\n\");\n      fclose(f);\n    }\n    abort();\n  }\n}\n\n/* A small helper that attempts to unquote a string. This is a test stub\n   that preserves behavior expected by get_rq_param_unquoted_copy_z: it\n   returns the unquoted length and writes the unquoted data into buf. */\nstatic size_t\nMHD_str_unquote (const char *src, size_t srclen, char *buf)\n{\n  if (srclen == 0)\n    return 0;\n\n  /* If string starts and ends with a double quote and length >= 2,\n     strip them. Otherwise copy as-is. */\n  if (srclen >= 2 && src[0] == '\"' && src[srclen - 1] == '\"')\n  {\n    size_t outlen = srclen - 2;\n    if (outlen > 0)\n      memcpy(buf, src + 1, outlen);\n    return outlen;\n  }\n\n  /* No surrounding quotes: copy as-is. */\n  if (srclen > 0)\n    memcpy(buf, src, srclen);\n  return srclen;\n}\n\n/* Logging probe: appends a single structured log entry to the file. The\n   function is intentionally conservative: it only inspects param->value.str\n   up to a small prefix (no more than 16 bytes) to avoid reading large\n   amounts of memory. */\nstatic void\nlog_probe (const char *event, const struct MHD_RqDAuthParam *param, const char *buf)\n{\n  FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \"  param=%p\\n\", (void *) param);\n  if (param != NULL)\n  {\n    fprintf(f, \"  value.str=%p\\n\", (void *) param->value.str);\n    fprintf(f, \"  value.len=%zu\\n\", param->value.len);\n    fprintf(f, \"  quoted=%d\\n\", param->quoted);\n  }\n  fprintf(f, \"  buf=%p\\n\", (void *) buf);\n\n  /* Dump a short hex/text prefix of the source value (safe: bounded). */\n  if (param != NULL && param->value.str != NULL)\n  {\n    size_t i, lim = param->value.len < 16 ? param->value.len : 16;\n    fprintf(f, \"  value.prefix=\");\n    for (i = 0; i < lim; ++i)\n    {\n      unsigned char c = (unsigned char) param->value.str[i];\n      if (c >= 32 && c < 127)\n        fputc((char) c, f);\n      else\n        fprintf(f, \"\\\\x%02x\", c);\n    }\n    if (param->value.len > lim)\n      fprintf(f, \"... (total %zu bytes)\", param->value.len);\n    fprintf(f, \"\\n\");\n  }\n\n  fclose(f);\n}\n\n/* Modified function with logging probes inserted around the risky calls. */\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n\n  /* Log entry before any copy occurs. */\n  log_probe(\"enter_get_rq_param_unquoted_copy_z\", param, buf);\n\n  if (! param->quoted)\n  {\n    log_probe(\"about_to_memcpy_unquoted\", param, buf);\n\n    /* Original logic preserved: copy raw bytes and NUL-terminate. */\n    memcpy (buf, param->value.str, param->value.len);\n\n    /* Log state just after memcpy and before NUL write. */\n    log_probe(\"after_memcpy_before_nul_unquoted\", param, buf);\n\n    buf [param->value.len] = 0;\n\n    /* Log final state for this control path. */\n    log_probe(\"exit_get_rq_param_unquoted_copy_z_unquoted\", param, buf);\n    return param->value.len;\n  }\n\n  log_probe(\"about_to_unquote\", param, buf);\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n\n  /* Log the returned length and relevant sizes. */\n  log_probe(\"after_unquote_before_nul\", param, buf);\n\n  buf[len] = 0;\n\n  log_probe(\"exit_get_rq_param_unquoted_copy_z_quoted\", param, buf);\n  return len;\n}\n"
}