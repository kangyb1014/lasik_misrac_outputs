{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_assert (int cond)\n{\n  if (! cond)\n  {\n    FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"mhd_assert failed\\n\");\n      fclose(f);\n    }\n    abort();\n  }\n}\nstatic void\nlog_probe (const char *event, const struct MHD_RqDAuthParam *param, const char *buf)\n{\n  FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \"  param=%p\\n\", (void *) param);\n  if (param != NULL)\n  {\n    fprintf(f, \"  value.str=%p\\n\", (void *) param->value.str);\n    fprintf(f, \"  value.len=%zu\\n\", param->value.len);\n    fprintf(f, \"  quoted=%d\\n\", param->quoted);\n  }\n  fprintf(f, \"  buf=%p\\n\", (void *) buf);\n\n  /* Dump a short hex/text prefix of the source value (safe: bounded). */\n  if (param != NULL && param->value.str != NULL)\n  {\n    size_t i, lim = param->value.len < 16 ? param->value.len : 16;\n    fprintf(f, \"  value.prefix=\");\n    for (i = 0; i < lim; ++i)\n    {\n      unsigned char c = (unsigned char) param->value.str[i];\n      if (c >= 32 && c < 127)\n        fputc((char) c, f);\n      else\n        fprintf(f, \"\\\\x%02x\", c);\n    }\n    if (param->value.len > lim)\n      fprintf(f, \"... (total %zu bytes)\", param->value.len);\n    fprintf(f, \"\\n\");\n  }\n\n  fclose(f);\n}\n\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n\n  /* Log entry before any copy occurs. */\n  log_probe(\"enter_get_rq_param_unquoted_copy_z\", param, buf);\n\n  if (! param->quoted)\n  {\n    log_probe(\"about_to_memcpy_unquoted\", param, buf);\n\n    /* Original logic preserved: copy raw bytes and NUL-terminate. */\n    memcpy (buf, param->value.str, param->value.len);\n\n    /* Log state just after memcpy and before NUL write. */\n    log_probe(\"after_memcpy_before_nul_unquoted\", param, buf);\n\n    buf [param->value.len] = 0;\n\n    /* Log final state for this control path. */\n    log_probe(\"exit_get_rq_param_unquoted_copy_z_unquoted\", param, buf);\n    return param->value.len;\n  }\n\n  log_probe(\"about_to_unquote\", param, buf);\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n\n  /* Log the returned length and relevant sizes. */\n  log_probe(\"after_unquote_before_nul\", param, buf);\n\n  buf[len] = 0;\n\n  log_probe(\"exit_get_rq_param_unquoted_copy_z_quoted\", param, buf);\n  return len;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c:1030:13: error: expected identifier or '('\n 1030 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1030:13: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ndigestauth.c:1030:13: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\ndigestauth.c:1030:13: error: expected ')'\n 1030 | static void mhd_assert (int cond)\n      |             ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\ndigestauth.c:1030:13: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_param_unquoted_copy_z as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal type declarations so this snippet compiles standalone.\n   These mirror the members used by the original code.\n*/\nstruct MHD_RqDAuthParam {\n  struct {\n    const char *str;\n    size_t len;\n  } value;\n  int quoted;\n};\n\n/* Declare external unquote function (implementation provided elsewhere). */\nsize_t MHD_str_unquote (const char *src, size_t src_len, char *dst);\n\n/* Renamed from mhd_assert to avoid clash with a macro of the same name. */\nstatic void mhd_assert_local (int cond)\n{\n  if (! cond)\n  {\n    FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"mhd_assert failed\\n\");\n      fclose(f);\n    }\n    abort();\n  }\n}\n\nstatic void\nlog_probe (const char *event, const struct MHD_RqDAuthParam *param, const char *buf)\n{\n  FILE *f = fopen(\"/tmp/logs/2839.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \"  param=%p\\n\", (void *) param);\n  if (param != NULL)\n  {\n    fprintf(f, \"  value.str=%p\\n\", (void *) param->value.str);\n    fprintf(f, \"  value.len=%zu\\n\", param->value.len);\n    fprintf(f, \"  quoted=%d\\n\", param->quoted);\n  }\n  fprintf(f, \"  buf=%p\\n\", (void *) buf);\n\n  /* Dump a short hex/text prefix of the source value (safe: bounded). */\n  if (param != NULL && param->value.str != NULL)\n  {\n    size_t i, lim = param->value.len < 16 ? param->value.len : 16;\n    fprintf(f, \"  value.prefix=\");\n    for (i = 0; i < lim; ++i)\n    {\n      unsigned char c = (unsigned char) param->value.str[i];\n      if (c >= 32 && c < 127)\n        fputc((char) c, f);\n      else\n        fprintf(f, \"\\\\x%02x\", c);\n    }\n    if (param->value.len > lim)\n      fprintf(f, \"... (total %zu bytes)\", param->value.len);\n    fprintf(f, \"\\n\");\n  }\n\n  fclose(f);\n}\n\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert_local (NULL != param->value.str);\n\n  /* Log entry before any copy occurs. */\n  log_probe(\"enter_get_rq_param_unquoted_copy_z\", param, buf);\n\n  if (! param->quoted)\n  {\n    log_probe(\"about_to_memcpy_unquoted\", param, buf);\n\n    /* Original logic preserved: copy raw bytes and NUL-terminate. */\n    memcpy (buf, param->value.str, param->value.len);\n\n    /* Log state just after memcpy and before NUL write. */\n    log_probe(\"after_memcpy_before_nul_unquoted\", param, buf);\n\n    buf [param->value.len] = 0;\n\n    /* Log final state for this control path. */\n    log_probe(\"exit_get_rq_param_unquoted_copy_z_unquoted\", param, buf);\n    return param->value.len;\n  }\n\n  log_probe(\"about_to_unquote\", param, buf);\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert_local (0 != len);\n  mhd_assert_local (len < param->value.len);\n\n  /* Log the returned length and relevant sizes. */\n  log_probe(\"after_unquote_before_nul\", param, buf);\n\n  buf[len] = 0;\n\n  log_probe(\"exit_get_rq_param_unquoted_copy_z_quoted\", param, buf);\n  return len;\n}\n",
  "explanation": "The compilation error was caused by a macro named mhd_assert already defined (from mhd_assert.h), which conflicted with the function name. I renamed the local assertion function to mhd_assert_local and updated all calls to use that name. To make the snippet self-contained and compilable, I added minimal declarations for struct MHD_RqDAuthParam and a prototype for MHD_str_unquote; I did not define any macros or mock functions. The logic of get_rq_param_unquoted_copy_z is preserved exactly, only using the renamed assert helper."
}