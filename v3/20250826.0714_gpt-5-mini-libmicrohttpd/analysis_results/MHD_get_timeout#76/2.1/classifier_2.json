{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_timeout:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout (struct MHD_Daemon *daemon,\n                 MHD_UNSIGNED_LONG_LONG *timeout)\n{\n  uint64_t t64;\n  if (MHD_NO == MHD_get_timeout64 (daemon, &t64))\n    return MHD_NO;\n\n#if SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG\n  if (ULLONG_MAX <= t64)\n    *timeout = ULLONG_MAX;\n  else\n#endif /* SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG */\n  *timeout = (MHD_UNSIGNED_LONG_LONG) t64;\n  return MHD_YES;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  return MHD_YES;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The final 'return MHD_YES;' is reachable in all build configurations: if MHD_get_timeout64() returns MHD_NO the function returns earlier (intended), otherwise execution reaches the assignment of *timeout (either via the #if branch or the #else branch) and then reaches 'return MHD_YES;'. For SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG the code compiles to an if/else that sets *timeout and falls through to the return; for the opposite case the code compiles to a single assignment and the return. Thus there is no unreachable code here."
}