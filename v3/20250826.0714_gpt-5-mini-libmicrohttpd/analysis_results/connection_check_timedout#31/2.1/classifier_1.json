{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of connection_check_timedout:\n```c\nstatic bool\nconnection_check_timedout (struct MHD_Connection *c)\n{\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t now;\n  uint64_t since_actv;\n\n  if (c->suspended)\n    return false;\n  if (0 == timeout)\n    return false;\n  now = MHD_monotonic_msec_counter ();\n  since_actv = now - c->last_activity;\n  /* Keep the next lines in sync with #connection_get_wait() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Detected system clock %u milliseconds jump back.\\n\"),\n                  (unsigned int) jump_back);\n#endif\n        return false;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (c->daemon,\n                _ (\"Detected too large system clock %\" PRIu64 \" milliseconds \"\n                   \"jump back.\\n\"),\n                jump_back);\n#endif\n    }\n    return true;\n  }\n  return false;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (UINT64_MAX / 2 < since_actv)\n  {\n    const uint64_t jump_back = c->last_activity - now;\n    /* Very unlikely that it is more than quarter-million years pause.\n     * More likely that system clock jumps back. */\n    if (5000 >= jump_back)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (c->daemon,\n                _ (\"Detected system clock %u milliseconds jump back.\\n\"),\n                (unsigned int) jump_back);\n#endif\n      return false;\n    }\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (c->daemon,\n              _ (\"Detected too large system clock %\" PRIu64 \" milliseconds \"\n                 \"jump back.\\n\"),\n              jump_back);\n#endif\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The inner block guarded by if (UINT64_MAX / 2 < since_actv) is reachable when since_actv is large (wrap-around case). In that case jump_back = c->last_activity - now will be the 2^64 complement of since_actv and can be small (\u22645000) or larger, so both the if (5000 >= jump_back) true-path (return false) and the subsequent DLOG path are potentially reachable. The #ifdef HAVE_MESSAGES sections only affect logging being compiled-in, not reachability of the control-flow. Therefore there is no unreachable code in the fragment."
}