{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2442.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void mhd_assert(int cond)\n{\n  if (!cond)\n  {\n    probe_log(\"ASSERTION FAILED: mhd_assert(%d)\", cond);\n    /* Preserve the usual assert behaviour by terminating the program. */\n    abort();\n  }\n}\n\nstatic bool\nparse_bauth_params (const char *str,\n                    size_t str_len,\n                    struct MHD_RqBAuth *pbauth)\n{\n  size_t i;\n\n  i = 0;\n\n  probe_log(\"parse_bauth_params: called with str_len=%zu\", str_len);\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n  {\n    probe_log(\"skipping whitespace at index=%zu char=%02x\", i, (unsigned char)str[i]);\n    i++;\n  }\n\n  probe_log(\"after initial skip i=%zu\", i);\n\n  if (str_len > i)\n  {\n    size_t token68_start;\n    size_t token68_len;\n\n    /* 'i' points to the first non-whitespace char after scheme token */\n    token68_start = i;\n    probe_log(\"token68_start=%zu (char=%02x)\", token68_start, (unsigned char)str[token68_start]);\n    /* Find end of the token. Token cannot contain whitespace. */\n    while (i < str_len && ' ' != str[i] && '\\t' != str[i])\n    {\n      probe_log(\"scanning token at index=%zu char=%02x\", i, (unsigned char)str[i]);\n      if (0 == str[i])\n      {\n        probe_log(\"binary zero encountered at index=%zu -> returning false\", i);\n        return false;  /* Binary zero is not allowed */\n      }\n      if ((',' == str[i]) || (';' == str[i]))\n      {\n        probe_log(\"separator char '%c' (0x%02x) encountered at index=%zu -> returning false\", str[i], (unsigned char)str[i], i);\n        return false;  /* Only single token68 is allowed */\n      }\n      i++;\n    }\n    token68_len = i - token68_start;\n    probe_log(\"computed token68_len=%zu (i=%zu token68_start=%zu)\", token68_len, i, token68_start);\n\n    /* Log before the assertion so callers can see the value that makes the assert redundant. */\n    probe_log(\"about to assert token68_len != 0 (observed %zu)\", token68_len);\n    mhd_assert (0 != token68_len);\n\n    /* Skip all whitespaces */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    {\n      probe_log(\"skipping trailing whitespace at index=%zu char=%02x\", i, (unsigned char)str[i]);\n      i++;\n    }\n    /* Check whether any garbage is present at the end of the string */\n    if (str_len != i)\n    {\n      probe_log(\"garbage at end of string: str_len=%zu i=%zu -> returning false\", str_len, i);\n      return false;\n    }\n    else\n    {\n      /* No more data in the string, only single token68. */\n      pbauth->token68.str = str + token68_start;\n      pbauth->token68.len = token68_len;\n      probe_log(\"success: token68 at offset=%zu len=%zu\", token68_start, token68_len);\n    }\n  }\n  else\n  {\n    probe_log(\"no token present (str_len=%zu i=%zu) -> considered success\", str_len, i);\n  }\n  probe_log(\"parse_bauth_params: returning true\");\n  return true;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ngen_auth.c:172:13: error: expected identifier or '('\n  172 | static void mhd_assert(int cond)\n      |             ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ngen_auth.c:172:13: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\ngen_auth.c:172:13: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\ngen_auth.c:172:13: error: expected ')'\n  172 | static void mhd_assert(int cond)\n      |             ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\ngen_auth.c:172:13: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2217: libmicrohttpd_la-gen_auth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of parse_bauth_params as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct MHD_RqBAuth {\n  struct {\n    const char *str;\n    size_t len;\n  } token68;\n};\n\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2442.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n/* renamed to avoid potential macro collision with a header-defined macro named mhd_assert */\nstatic void mhd_assert_local(int cond)\n{\n  if (!cond)\n  {\n    probe_log(\"ASSERTION FAILED: mhd_assert(%d)\", cond);\n    /* Preserve the usual assert behaviour by terminating the program. */\n    abort();\n  }\n}\n\nstatic bool\nparse_bauth_params (const char *str,\n                    size_t str_len,\n                    struct MHD_RqBAuth *pbauth)\n{\n  size_t i;\n\n  i = 0;\n\n  probe_log(\"parse_bauth_params: called with str_len=%zu\", str_len);\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n  {\n    probe_log(\"skipping whitespace at index=%zu char=%02x\", i, (unsigned char)str[i]);\n    i++;\n  }\n\n  probe_log(\"after initial skip i=%zu\", i);\n\n  if (str_len > i)\n  {\n    size_t token68_start;\n    size_t token68_len;\n\n    /* 'i' points to the first non-whitespace char after scheme token */\n    token68_start = i;\n    probe_log(\"token68_start=%zu (char=%02x)\", token68_start, (unsigned char)str[token68_start]);\n    /* Find end of the token. Token cannot contain whitespace. */\n    while (i < str_len && ' ' != str[i] && '\\t' != str[i])\n    {\n      probe_log(\"scanning token at index=%zu char=%02x\", i, (unsigned char)str[i]);\n      if (0 == str[i])\n      {\n        probe_log(\"binary zero encountered at index=%zu -> returning false\", i);\n        return false;  /* Binary zero is not allowed */\n      }\n      if ((',' == str[i]) || (';' == str[i]))\n      {\n        probe_log(\"separator char '%c' (0x%02x) encountered at index=%zu -> returning false\", str[i], (unsigned char)str[i], i);\n        return false;  /* Only single token68 is allowed */\n      }\n      i++;\n    }\n    token68_len = i - token68_start;\n    probe_log(\"computed token68_len=%zu (i=%zu token68_start=%zu)\", token68_len, i, token68_start);\n\n    /* Log before the assertion so callers can see the value that makes the assert redundant. */\n    probe_log(\"about to assert token68_len != 0 (observed %zu)\", token68_len);\n    mhd_assert_local (0 != token68_len);\n\n    /* Skip all whitespaces */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    {\n      probe_log(\"skipping trailing whitespace at index=%zu char=%02x\", i, (unsigned char)str[i]);\n      i++;\n    }\n    /* Check whether any garbage is present at the end of the string */\n    if (str_len != i)\n    {\n      probe_log(\"garbage at end of string: str_len=%zu i=%zu -> returning false\", str_len, i);\n      return false;\n    }\n    else\n    {\n      /* No more data in the string, only single token68. */\n      pbauth->token68.str = str + token68_start;\n      pbauth->token68.len = token68_len;\n      probe_log(\"success: token68 at offset=%zu len=%zu\", token68_start, token68_len);\n    }\n  }\n  else\n  {\n    probe_log(\"no token present (str_len=%zu i=%zu) -> considered success\", str_len, i);\n  }\n  probe_log(\"parse_bauth_params: returning true\");\n  return true;\n}\n",
  "explanation": "The original code declared a function named mhd_assert which conflicted with a macro of the same name supplied by an included header (causing a preprocessor expansion error). To avoid that collision I renamed the function to mhd_assert_local and updated the single call site to use the new name. No macros were added or changed, and the parse_bauth_params logic is preserved exactly (only the assertion call was redirected to the renamed function). I also added the minimal necessary includes and a definition of struct MHD_RqBAuth so the snippet is self-contained and compiles."
}