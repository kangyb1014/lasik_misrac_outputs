{
  "user_message": "An agent A claimed that the following MHD_strx_to_uint32_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_strx_to_uint32_.\n```c\nsize_t\nMHD_strx_to_uint32_ (const char *str,\n                     uint32_t *out_val)\n{\n  const char *const start = str;\n  uint32_t res;\n  int digit;\n\n  if (! str || ! out_val)\n    return 0;\n\n  res = 0;\n  digit = toxdigitvalue (*str);\n  while (digit >= 0)\n  {\n    if ( (res < (UINT32_MAX / 16)) ||\n         ((res == (UINT32_MAX / 16)) &&\n          ( (uint32_t) digit <= (UINT32_MAX % 16)) ) )\n    {\n      res *= 16;\n      res += (unsigned int) digit;\n    }\n    else\n      return 0;\n    str++;\n    digit = toxdigitvalue (*str);\n  }\n\n  if (str - start > 0)\n    *out_val = res;\n  return (size_t) (str - start);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer parameter 'str' is modified inside the function (str++ in the while loop). MISRA C 2023 Rule 17.8 prohibits modifying a pointer function parameter itself (only the object pointed to may be modified). The write to *out_val is permitted (it modifies the pointed object), but incrementing the parameter 'str' violates the rule.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: MHD_strx_to_uint32_: str=0x5645e5ad26dc, first_char=(int)49, out_val=0x7ffffda670ac\nINIT: res=0, digit=1, str=0x5645e5ad26dc, char=(int)49\nLOOP TOP: res=0, digit=1, str=0x5645e5ad26dc, char=(int)49\nRES UPDATED: res=1 (after incorporating digit 1)\nSTR INCREMENT: before str=0x5645e5ad26dc\nSTR INCREMENT: after  str=0x5645e5ad26dd, moved_by=1\nNEXT DIGIT: digit=-1, str=0x5645e5ad26dd, char=(int)0\nASSIGN OUT: out_val=0x7ffffda670ac assigned 1, consumed=1\nEXIT: returning 1 (str=0x5645e5ad26dd, start=0x5645e5ad26dc, consumed=1)\nENTER: MHD_strx_to_uint32_: str=0x5645e5ad77e4, first_char=(int)48, out_val=0x7ffffda670ac\nINIT: res=0, digit=0, str=0x5645e5ad77e4, char=(int)48\nLOOP TOP: res=0, digit=0, str=0x5645e5ad77e4, char=(int)48\nRES UPDATED: res=0 (after incorporating digit 0)\nSTR INCREMENT: before str=0x5645e5ad77e4\nSTR INCREMENT: after  str=0x5645e5ad77e5, moved_by=1\nNEXT DIGIT: digit=-1, str=0x5645e5ad77e5, char=(int)0\nASSIGN OUT: out_val=0x7ffffda670ac assigned 0, consumed=1\nEXIT: returning 1 (str=0x5645e5ad77e5, start=0x5645e5ad77e4, consumed=1)\nENTER: MHD_strx_to_uint32_: str=0x5645e5ad256b, first_char=(int)49, out_val=0x7ffffda670ac\nINIT: res=0, digit=1, str=0x5645e5ad256b, char=(int)49\nLOOP TOP: res=0, digit=1, str=0x5645e5ad256b, char=(int)49\nRES UPDATED: res=1 (after incorporating digit 1)\nSTR INCREMENT: before str=0x5645e5ad256b\nSTR INCREMENT: after  str=0x5645e5ad256c, moved_by=1\nNEXT DIGIT: digit=0, str=0x5645e5ad256c, char=(int)48\nLOOP TOP: res=1, digit=0, str=0x5645e5ad256c, char=(int)48\nRES UPDATED: res=16 (after incorporating digit 0)\nSTR INCREMENT: before str=0x5645e5ad256c\nSTR INCREMENT: after  str=0x5645e5ad256d, moved_by=2\nNEXT DIGIT: digit=0, str=0x5645e5ad256d, char=(int)48\nLOOP TOP: res=16, digit=0, str=0x5645e5ad256d, char=(int)48\nRES UPDATED: res=256 (after incorporating digit 0)\nSTR INCREMENT: before str=0x5645e5ad256d\nSTR INCREMENT: after  str=0x5645e5ad256e, moved_by=3\nNEXT DIGIT: digit=0, str=0x5645e5ad256e, char=(int)48\nLOOP TOP: res=256, digit=0, str=0x5645e5ad256e, char=(int)48\nRES UPDATED: res=4096 (after incorporating digit 0)\nSTR INCREMENT: before str=0x5645e5ad256e\nSTR INCREMENT: after  str=0x5645e5ad256f, moved_by=4\nNEXT DIGIT: digit=0, str=0x5645e5ad256f, char=(int)48\nLOOP TOP: res=4096, digit=0, str=0x5645e5ad256f, char=(int)48\nRES UPDATED: res=65536 (after incorporating digit 0)\nSTR INCREMENT: before str=0x5645e5ad256f\nSTR INCREMENT: after  str=0x5645e5ad2570, moved_by=5\nNEXT DIGIT: digit=-1, str=0x5645e5ad2570, char=(int)0\nASSIGN OUT: out_val=0x7ffffda670ac assigned 65536, consumed=5\nEXIT: returning 5 (str=0x5645e5ad2570, start=0x5645e5ad256b, consumed=5)\nENTER: MHD_strx_to_uint32_: str=0x5645e5ad2571, first_char=(int)49, out_val=0x7ffffda670ac\nINIT: res=0, digit=1, str=0x5645e5ad2571, char=(int)49\nLOOP TOP: res=0, digit=1, str=0x5645e5ad2571, char=(int)49\nRES UPDATED: res=1 (after incorporating digit 1)\nSTR INCREMENT: before str=0x5645e5ad2571\nSTR INCREMENT: after  str=0x5645e5ad2572, moved_by=1\nNEXT DIGIT: digit=2, str=0x5645e5ad2572, char=(int)50\nLOOP TOP: res=1, digit=2, str=0x5645e5ad2572, char=(int)50\nRES UPDATED: res=18 (after incorporating digit 2)\nSTR INCREMENT: before str=0x5645e5ad2572\nSTR INCREMENT: after  str=0x5645e5ad2573, moved_by=2\nNEXT DIGIT: digit=3, str=0x5645e5ad2573, char=(int)51\nLOOP TOP: res=18, digit=3, str=0x5645e5ad2573, char=(int)51\nRES UPDATED: res=291 (after incorporating digit 3)\nSTR INCREMENT: before str=0x5645e5ad2573\nSTR INCREMENT: after  str=0x5645e5ad2574, moved_by=3\nNEXT DIGIT: digit=4, str=0x5645e5ad2574, char=(int)52\nLOOP TOP: res=291, digit=4, str=0x5645e5ad2574, char=(int)52\nRES UPDATED: res=4660 (after incorporating digit 4)\nSTR INCREMENT: before str=0x5645e5ad2574\nSTR INCREMENT: after  str=0x5645e5ad2575, moved_by=4\nNEXT DIGIT: digit=-1, str=0x5645e5ad2575, char=(int)0\nASSIGN OUT: out_val=0x7ffffda670ac assigned 4660, consumed=4\nEXIT: returning 4 (str=0x5645e5ad2575, start=0x5645e5ad2571, consumed=4)\nENTER: MHD_strx_to_uint32_: str=0x5645e5ad2576, first_char=(int)52, out_val=0x7ffffda670ac\nINIT: res=0, digit=4, str=0x5645e5ad2576, char=(i\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters; for pointer parameters the pointer itself shall not be modified (only the object it points to may be). In the function MHD_strx_to_uint32_ the parameter 'str' is incremented (str++) inside the loop, which modifies the pointer parameter and therefore violates Rule 17.8. \n\nA simple fix is to use a local pointer variable for traversal, for example:\n- const char *const start = str; const char *p = str; ... use p++ instead of str++ and compute (p - start) when returning. Alternatively, declare the parameter as const char *const str to make modification a compile-time error (but changing the caller signature may be undesirable)."
}