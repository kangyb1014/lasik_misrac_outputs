{
  "user_message": "An agent A claimed that the following MHD_str_to_uint64_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_to_uint64_.\n```c\nsize_t\nMHD_str_to_uint64_ (const char *str,\n                    uint64_t *out_val)\n{\n  const char *const start = str;\n  uint64_t res;\n\n  if (! str || ! out_val || ! isasciidigit (str[0]))\n    return 0;\n\n  res = 0;\n  do\n  {\n    const int digit = (unsigned char) (*str) - '0';\n    if ( (res > (UINT64_MAX / 10)) ||\n         ( (res == (UINT64_MAX / 10)) &&\n           ((uint64_t) digit > (UINT64_MAX % 10)) ) )\n      return 0;\n\n    res *= 10;\n    res += (unsigned int) digit;\n    str++;\n  } while (isasciidigit (*str));\n\n  *out_val = res;\n  return (size_t) (str - start);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code increments the function parameter pointer 'str' (str++ in the loop). MISRA C 2023 Rule 17.8 forbids modifying a function parameter itself (the pointer variable); although the pointed-to object may be modified, the pointer shall not be changed. Therefore this fragment violates Rule 17.8. (Note: writing '*out_val = res;' is permitted because it modifies the object pointed to, not the pointer.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nentry-ok: str=0x55e1bdaec6d9 char=0x31 '1' start=0x55e1bdaec6d9 res=0 digit=1 note=start parsing\nbefore-check: str=0x55e1bdaec6d9 char=0x31 '1' start=0x55e1bdaec6d9 res=0 digit=1 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec6d9 char=0x31 '1' start=0x55e1bdaec6d9 res=1 digit=1 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec6da char=0x00 '.' start=0x55e1bdaec6d9 res=1 digit=-1 note=str was incremented\nsuccess: out_val=1 len=1 str=0x55e1bdaec6da start=0x55e1bdaec6d9\nentry-ok: str=0x55e1bdaf1717 char=0x30 '0' start=0x55e1bdaf1717 res=0 digit=0 note=start parsing\nbefore-check: str=0x55e1bdaf1717 char=0x30 '0' start=0x55e1bdaf1717 res=0 digit=0 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaf1717 char=0x30 '0' start=0x55e1bdaf1717 res=0 digit=0 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaf1718 char=0x00 '.' start=0x55e1bdaf1717 res=0 digit=-1 note=str was incremented\nsuccess: out_val=0 len=1 str=0x55e1bdaf1718 start=0x55e1bdaf1717\nentry-ok: str=0x55e1bdaec568 char=0x31 '1' start=0x55e1bdaec568 res=0 digit=1 note=start parsing\nbefore-check: str=0x55e1bdaec568 char=0x31 '1' start=0x55e1bdaec568 res=0 digit=1 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec568 char=0x31 '1' start=0x55e1bdaec568 res=1 digit=1 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec569 char=0x30 '0' start=0x55e1bdaec568 res=1 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec569 char=0x30 '0' start=0x55e1bdaec568 res=1 digit=0 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec569 char=0x30 '0' start=0x55e1bdaec568 res=10 digit=0 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec56a char=0x30 '0' start=0x55e1bdaec568 res=10 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec56a char=0x30 '0' start=0x55e1bdaec568 res=10 digit=0 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec56a char=0x30 '0' start=0x55e1bdaec568 res=100 digit=0 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec56b char=0x30 '0' start=0x55e1bdaec568 res=100 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec56b char=0x30 '0' start=0x55e1bdaec568 res=100 digit=0 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec56b char=0x30 '0' start=0x55e1bdaec568 res=1000 digit=0 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec56c char=0x30 '0' start=0x55e1bdaec568 res=1000 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec56c char=0x30 '0' start=0x55e1bdaec568 res=1000 digit=0 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec56c char=0x30 '0' start=0x55e1bdaec568 res=10000 digit=0 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec56d char=0x00 '.' start=0x55e1bdaec568 res=10000 digit=-1 note=str was incremented\nsuccess: out_val=10000 len=5 str=0x55e1bdaec56d start=0x55e1bdaec568\nentry-ok: str=0x55e1bdaec56e char=0x31 '1' start=0x55e1bdaec56e res=0 digit=1 note=start parsing\nbefore-check: str=0x55e1bdaec56e char=0x31 '1' start=0x55e1bdaec56e res=0 digit=1 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec56e char=0x31 '1' start=0x55e1bdaec56e res=1 digit=1 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec56f char=0x32 '2' start=0x55e1bdaec56e res=1 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec56f char=0x32 '2' start=0x55e1bdaec56e res=1 digit=2 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec56f char=0x32 '2' start=0x55e1bdaec56e res=12 digit=2 note=accumulated digit, will increment str\nafter-increment: str=0x55e1bdaec570 char=0x33 '3' start=0x55e1bdaec56e res=12 digit=-1 note=str was incremented\nbefore-check: str=0x55e1bdaec570 char=0x33 '3' start=0x55e1bdaec56e res=12 digit=3 note=about to check overflow\nafter-accumulate-before-increment: str=0x55e1bdaec570 cha\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states a function parameter shall not be modified; while the object pointed-to may be changed, the pointer parameter itself must not be altered. In the function MHD_str_to_uint64_ the parameter 'str' (type const char *) is incremented (str++) inside the loop, which modifies the pointer parameter and therefore violates Rule 17.8. Note that the const in 'const char *str' only prevents modification of the characters referred to, it does not permit modifying the pointer variable itself. The write to '*out_val' is permitted because it modifies the object pointed to, not the pointer. Suggested fix: use a local copy (e.g. const char *p = str; const char *const start = p;) and advance p instead of str, then return (size_t)(p - start)."
}