{
  "user_message": "An agent A claimed that the following is_param_equal_caseless code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal_caseless.\n```c\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf struct MHD_RqDAuthParam::value.str is declared as a non-const pointer (e.g. char *str) then this use is read-only and the pointer should be declared to point to a const-qualified type (const char *). In that case the code violates MISRA C:2023 Rule 8.13. The fragment alone does not show the declaration, but if value.str is non-const then change it to const char * to comply.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 concerns how pointers are declared: a pointer type should be const-qualified when the pointed-to object is not modified. The fragment of is_param_equal_caseless itself does not show the declaration of value.str, so you cannot conclude a violation solely from this function. If struct MHD_RqDAuthParam::value.str is declared as char * but is never used to modify the pointed data (only read, as in this function), then the declaration should indeed be changed to const char * to satisfy Rule 8.13. In other words, the actual violation (if any) would be in the type declaration of value.str, not in this call site. Because the provided fragment does not include that declaration, the agent's blanket claim that \u201cthe code violates Rule 8.13\u201d is not provable from the snippet alone. If value.str is already declared const char * then there is no violation; if it is declared non-const but truly never modified, then the project would be non-compliant and should be fixed."
}