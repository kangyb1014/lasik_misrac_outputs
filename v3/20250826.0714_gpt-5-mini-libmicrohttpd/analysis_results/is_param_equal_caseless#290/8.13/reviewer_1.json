{
  "user_message": "An agent A claimed that the following is_param_equal_caseless code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal_caseless.\n```c\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf struct MHD_RqDAuthParam::value.str is declared as a non-const pointer (e.g. char *str), then Rule 8.13 is violated: the code only reads from the pointed data but the pointer type does not point to a const-qualified type. The member should be declared as const char *str (or equivalent) so pointers to read-only data are const-qualified.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s observation is plausible but not demonstrated by the code shown. MISRA C 2023 Rule 8.13 concerns how pointers are declared (they should point to const-qualified types when possible). The snippet only shows a function that reads from param->value.str; it does not show the declaration of struct MHD_RqDAuthParam or the type of value.str. If value.str is declared as char * (non-const), then that declaration would be a candidate MISRA 8.13 violation because the code only reads through the pointer and therefore the pointer\u2019s target could (and should) be const-qualified (e.g. const char *). However the function itself does not prove a violation \u2014 the violation would be in the struct member declaration. Therefore the report as stated (that the given code violates 8.13) is not definitively correct unless you confirm that value.str is declared non-const. If value.str is already declared as const char * (or otherwise const-qualified), there is no violation."
}