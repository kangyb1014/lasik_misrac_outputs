{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_num_threads:\n```c\nstatic unsigned int\nget_num_threads (void)\n{\n#if 0  /* disalbed code */\n  static const unsigned int max_threads = 32;\n#endif /* disalbed code */\n  if (0 < num_threads)\n    return num_threads;\n\n  num_threads = get_cpu_core_count () / 2;\n  if (0 == num_threads)\n    num_threads = 1;\n  else\n  {\n    unsigned int num_proc_cpus;\n    num_proc_cpus = get_process_cpu_core_count ();\n    if (num_proc_cpus >= num_threads)\n    {\n      printf (\"Using half of all available CPU cores, assuming the other half \"\n              \"is used by client / requests generator.\\n\");\n    }\n    else\n    {\n      printf (\"Using all CPU cores available for this process as more than \"\n              \"half of CPU cores on this system are still available for use \"\n              \"by client / requests generator.\\n\");\n      num_threads = num_proc_cpus;\n    }\n  }\n#if 0  /* disalbed code */\n  if (max_threads < num_threads)\n  {\n    printf (\"Number of threads are limited to %u as more threads \"\n            \"are unlikely to improve the performance.\\n\", max_threads);\n    num_threads = max_threads;\n  }\n#endif /* disalbed code */\n\n  return num_threads;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nprintf (\"Using all CPU cores available for this process as more than \"\n              \"half of CPU cores on this system are still available for use \"\n              \"by client / requests generator.\\n\");\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown code. The fragment calls printf with an adjacent string literal; this does not make get_num_threads call itself. A possible violation would occur only if printf (or a function it invokes) were implemented to call get_num_threads (e.g. a custom wrapper/macro such that get_num_threads -> printf -> get_num_threads), which would create indirect recursion and violate Rule 17.2."
}