{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nIf mhd_assert is a typical diagnostic macro that expands to nothing in production (for example to ((void)0) when assertions are disabled), the statement mhd_assert(str_len == i || ',' == str[i]); has no side effects and is removed in release builds. Its removal would not affect program behaviour (it only performs a runtime check used for diagnostics), so the operation constitutes dead code and violates MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified parse_dauth_params code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2452.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of parse_dauth_params as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of parse_dauth_params:\n```c\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    left = str_len - i;\n    if ('=' == str[i])\n      return false; /* The equal sign is not allowed as the first character */\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n          return false; /* No equal sign after parameter name, broken data */\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n          return false; /* No equal sign, broken data */\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n              return false; /* Binary zero in parameter value */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero in parameter value */\n            i++;\n          }\n          if (';' == str[i])\n            return false;  /* Semicolon in parameter value */\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n          return false; /* Garbage after parameter value */\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n          return false; /* Not allowed characters */\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n              return false;  /* Binary zero is not allowed */\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n            return false; /* No closing quote */\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n  }\n  else\n    pdauth->userhash = false;\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  return true;\n}\n```\n</target_code>\nPlease provide the modified parse_dauth_params code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* Probe helpers: write diagnostic traces to /tmp/logs/2452.txt. */\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2452.txt\", \"a\");\n  if (NULL == f)\n    return; /* Do not change program logic on logging failure */\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void\nmhd_probe_bytes (const char *tag, const char *str, size_t off, size_t len)\n{\n  /* Log up to 32 bytes from str+off for context (safe if off >= len caller must check). */\n  FILE *f = fopen(\"/tmp/logs/2452.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s: offset=%zu sample=\\\"\", tag, off);\n  size_t i;\n  for (i = 0; i < 32 && off + i < len; ++i)\n  {\n    int c = (unsigned char) str[off + i];\n    if (c >= 32 && c < 127)\n      fputc (c, f);\n    else\n      fprintf (f, \"\\\\x%02x\", c);\n  }\n  fprintf (f, \"\\\"\\n\");\n  fclose (f);\n}\n\nstatic bool\nparse_dauth_params (const char *str,\n                    const size_t str_len,\n                    struct MHD_RqDAuth *pdauth)\n{\n  /* The tokens */\n  static const struct _MHD_cstr_w_len nonce_tk = _MHD_S_STR_W_LEN (\"nonce\");\n  static const struct _MHD_cstr_w_len opaque_tk = _MHD_S_STR_W_LEN (\"opaque\");\n  static const struct _MHD_cstr_w_len algorithm_tk =\n    _MHD_S_STR_W_LEN (\"algorithm\");\n  static const struct _MHD_cstr_w_len response_tk =\n    _MHD_S_STR_W_LEN (\"response\");\n  static const struct _MHD_cstr_w_len username_tk =\n    _MHD_S_STR_W_LEN (\"username\");\n  static const struct _MHD_cstr_w_len username_ext_tk =\n    _MHD_S_STR_W_LEN (\"username*\");\n  static const struct _MHD_cstr_w_len realm_tk = _MHD_S_STR_W_LEN (\"realm\");\n  static const struct _MHD_cstr_w_len uri_tk = _MHD_S_STR_W_LEN (\"uri\");\n  static const struct _MHD_cstr_w_len qop_tk = _MHD_S_STR_W_LEN (\"qop\");\n  static const struct _MHD_cstr_w_len cnonce_tk = _MHD_S_STR_W_LEN (\"cnonce\");\n  static const struct _MHD_cstr_w_len nc_tk = _MHD_S_STR_W_LEN (\"nc\");\n  static const struct _MHD_cstr_w_len userhash_tk =\n    _MHD_S_STR_W_LEN (\"userhash\");\n  /* The locally processed parameters */\n  struct MHD_RqDAuthParam userhash;\n  struct MHD_RqDAuthParam algorithm;\n  /* Indexes */\n  size_t i;\n  size_t p;\n  /* The list of the tokens.\n     The order of the elements matches the next array. */\n  static const struct _MHD_cstr_w_len *const tk_names[] = {\n    &nonce_tk,          /* 0 */\n    &opaque_tk,         /* 1 */\n    &algorithm_tk,      /* 2 */\n    &response_tk,       /* 3 */\n    &username_tk,       /* 4 */\n    &username_ext_tk,   /* 5 */\n    &realm_tk,          /* 6 */\n    &uri_tk,            /* 7 */\n    &qop_tk,            /* 8 */\n    &cnonce_tk,         /* 9 */\n    &nc_tk,             /* 10 */\n    &userhash_tk        /* 11 */\n  };\n  /* The list of the parameters.\n     The order of the elements matches the previous array. */\n  struct MHD_RqDAuthParam *params[sizeof(tk_names) / sizeof(tk_names[0])];\n\n  params[0 ] = &(pdauth->nonce);           /* 0 */\n  params[1 ] = &(pdauth->opaque);          /* 1 */\n  params[2 ] = &algorithm;                 /* 2 */\n  params[3 ] = &(pdauth->response);        /* 3 */\n  params[4 ] = &(pdauth->username);        /* 4 */\n  params[5 ] = &(pdauth->username_ext);    /* 5 */\n  params[6 ] = &(pdauth->realm);           /* 6 */\n  params[7 ] = &(pdauth->uri);             /* 7 */\n  params[8 ] = &(pdauth->qop_raw);         /* 8 */\n  params[9 ] = &(pdauth->cnonce);          /* 9 */\n  params[10] = &(pdauth->nc);              /* 10 */\n  params[11] = &userhash;                  /* 11 */\n\n  mhd_assert ((sizeof(tk_names) / sizeof(tk_names[0])) == \\\n              (sizeof(params) / sizeof(params[0])));\n  memset (&userhash, 0, sizeof(userhash));\n  memset (&algorithm, 0, sizeof(algorithm));\n  i = 0;\n\n  /* Entry probe */\n  mhd_probe_log (\"parse_dauth_params entry: str_len=%zu\", str_len);\n  mhd_probe_bytes (\"input_prefix\", str, 0, str_len);\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  while (str_len > i)\n  {\n    size_t left;\n    mhd_assert (' ' != str[i]);\n    mhd_assert ('\\t' != str[i]);\n\n    /* Probe current position */\n    if (i < str_len)\n      mhd_probe_log (\"loop start: i=%zu left_bytes=%zu current_char=0x%02x\", i, (size_t)(str_len - i), (unsigned char)str[i]);\n    else\n      mhd_probe_log (\"loop start: i=%zu left_bytes=0\", i);\n\n    left = str_len - i;\n    if ('=' == str[i])\n    {\n      mhd_probe_log (\"early error: '=' at start position i=%zu\", i);\n      return false; /* The equal sign is not allowed as the first character */\n    }\n    for (p = 0; p < (sizeof(tk_names) / sizeof(tk_names[0])); ++p)\n    {\n      const struct _MHD_cstr_w_len *const tk_name = tk_names[p];\n      struct MHD_RqDAuthParam *const param = params[p];\n      if ( (tk_name->len <= left) &&\n           MHD_str_equal_caseless_bin_n_ (str + i, tk_name->str,\n                                          tk_name->len) &&\n           ((tk_name->len == left) ||\n            ('=' == str[i + tk_name->len]) ||\n            (' ' == str[i + tk_name->len]) ||\n            ('\\t' == str[i + tk_name->len]) ||\n            (',' == str[i + tk_name->len]) ||\n            (';' == str[i + tk_name->len])) )\n      {\n        size_t value_start;\n        size_t value_len;\n        bool quoted; /* Only mark as \"quoted\" if backslash-escape used */\n\n        if (tk_name->len == left)\n        {\n          mhd_probe_log (\"error: token present at end with no '=' token='%.*s' p=%zu i=%zu\", (int)tk_name->len, tk_name->str, p, i);\n          return false; /* No equal sign after parameter name, broken data */\n        }\n\n        quoted = false;\n        i += tk_name->len;\n        /* Skip all whitespaces before '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((i == str_len) || ('=' != str[i]))\n        {\n          mhd_probe_log (\"error: no '=' after token '%.*s' at i=%zu\", (int)tk_name->len, tk_name->str, i);\n          return false; /* No equal sign, broken data */\n        }\n        i++;\n        /* Skip all whitespaces after '=' */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && ('\"' == str[i]))\n        { /* Value is in quotation marks */\n          i++; /* Advance after the opening quote */\n          value_start = i;\n          while (str_len > i && '\"' != str[i])\n          {\n            if ('\\\\' == str[i])\n            {\n              i++;\n              quoted = true; /* Have escaped chars */\n            }\n            if (0 == str[i])\n            {\n              mhd_probe_log (\"error: binary zero in quoted value for token '%.*s' at i=%zu\", (int)tk_name->len, tk_name->str, i);\n              return false; /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_probe_log (\"error: no closing quote for token '%.*s' starting at %zu\", (int)tk_name->len, tk_name->str, value_start - 1);\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n          value_len = i - value_start;\n          i++; /* Advance after the closing quote */\n        }\n        else\n        {\n          value_start = i;\n          while (str_len > i && ',' != str[i] &&\n                 ' ' != str[i] && '\\t' != str[i] && ';' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_probe_log (\"error: binary zero in unquoted value for token '%.*s' at i=%zu\", (int)tk_name->len, tk_name->str, i);\n              return false;  /* Binary zero in parameter value */\n            }\n            i++;\n          }\n          if (';' == str[i])\n          {\n            mhd_probe_log (\"error: semicolon in parameter value for token '%.*s' at i=%zu\", (int)tk_name->len, tk_name->str, i);\n            return false;  /* Semicolon in parameter value */\n          }\n          value_len = i - value_start;\n        }\n        /* Skip all whitespaces after parameter value */\n        while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n          i++;\n        if ((str_len > i) && (',' != str[i]))\n        {\n          mhd_probe_log (\"error: garbage after parameter value for token '%.*s' at i=%zu char=0x%02x\", (int)tk_name->len, tk_name->str, i, (unsigned char)str[i]);\n          return false; /* Garbage after parameter value */\n        }\n\n        /* Have valid parameter name and value */\n        mhd_assert (! quoted || 0 != value_len);\n        param->value.str = str + value_start;\n        param->value.len = value_len;\n        param->quoted = quoted;\n\n        /* Probe found parameter */\n        mhd_probe_log (\"found param p=%zu name='%.*s' value_start=%zu value_len=%zu quoted=%d\", p, (int)tk_name->len, tk_name->str, value_start, value_len, quoted);\n        mhd_probe_bytes (\"value_sample\", str, value_start, str_len);\n\n        break; /* Found matching parameter name */\n      }\n    }\n    if (p == (sizeof(tk_names) / sizeof(tk_names[0])))\n    {\n      /* No matching parameter name */\n      mhd_probe_log (\"no matching parameter name at i=%zu left=%zu\", i, (size_t)(str_len - i));\n      while (str_len > i && ',' != str[i])\n      {\n        if ((0 == str[i]) || (';' == str[i]))\n        {\n          mhd_probe_log (\"error: not allowed character while skipping unknown param at i=%zu char=0x%02x\", i, (unsigned char)str[i]);\n          return false; /* Not allowed characters */\n        }\n        if ('\"' == str[i])\n        { /* Skip quoted part */\n          i++; /* Advance after the opening quote */\n          while (str_len > i && '\"' != str[i])\n          {\n            if (0 == str[i])\n            {\n              mhd_probe_log (\"error: binary zero inside skipped quoted unknown param at i=%zu\", i);\n              return false;  /* Binary zero is not allowed */\n            }\n            if ('\\\\' == str[i])\n              i++;           /* Skip escaped char */\n            i++;\n          }\n          if (str_len <= i)\n          {\n            mhd_probe_log (\"error: no closing quote while skipping unknown param starting earlier, i=%zu\", i);\n            return false; /* No closing quote */\n          }\n          mhd_assert ('\"' == str[i]);\n        }\n        i++;\n      }\n    }\n    /* This is the assertion the other agent flagged as dead code when mhd_assert expands to nothing. */\n    mhd_probe_log (\"assert_check_before_comma: i=%zu str_len=%zu (char_at_i=0x%02x if_valid=%d)\", i, str_len, (unsigned int)(i < str_len ? (unsigned char)str[i] : 0), (int)((i < str_len) ? (',' == str[i]) : 0));\n    mhd_assert (str_len == i || ',' == str[i]);\n    if (str_len > i)\n      i++; /* Advance after ',' */\n    /* Skip all whitespaces before next parameter name */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n  }\n\n  /* Postprocess values */\n\n  if (NULL != userhash.value.str)\n  {\n    if (userhash.quoted)\n      pdauth->userhash =\n        MHD_str_equal_caseless_quoted_s_bin_n (userhash.value.str, \\\n                                               userhash.value.len, \\\n                                               \"true\");\n    else\n      pdauth->userhash =\n        MHD_str_equal_caseless_s_bin_n_ (\"true\", userhash.value.str, \\\n                                         userhash.value.len);\n\n    mhd_probe_log (\"postprocess: userhash present quoted=%d len=%zu\", userhash.quoted, userhash.value.len);\n    mhd_probe_bytes (\"userhash_value\", userhash.value.str, 0, userhash.value.len);\n  }\n  else\n  {\n    pdauth->userhash = false;\n    mhd_probe_log (\"postprocess: userhash absent\");\n  }\n\n  pdauth->algo3 = get_rq_dauth_algo (&algorithm);\n  pdauth->qop = get_rq_dauth_qop (&pdauth->qop_raw);\n\n  mhd_probe_log (\"parse_dauth_params exit: algo3=%d qop=%d userhash=%d\", (int)pdauth->algo3, (int)pdauth->qop, (int)pdauth->userhash);\n\n  return true;\n}\n"
}