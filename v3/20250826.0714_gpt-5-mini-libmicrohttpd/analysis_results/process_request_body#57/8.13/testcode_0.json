{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe pointer variable 'buffer_head' is declared as 'char *buffer_head' but is only used for read-only operations in the shown fragment (indexing and comparisons: buffer_head[num_dig], buffer_head[0], etc.) and passed to functions that accept const data. According to MISRA C 2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. 'const char *buffer_head').\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified process_request_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/573.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of process_request_body as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of process_request_body:\n```c\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n```\n</target_code>\nPlease provide the modified process_request_body code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <ctype.h>\n\n/* Probe helpers: append logs to /tmp/logs/573.txt */\nstatic void\nprobe_log_append (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/573.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic void\nprobe_dump_buffer (const char *tag, const char *buffer, size_t available, size_t maxdump)\n{\n  size_t i;\n  size_t dump = (available < maxdump) ? available : maxdump;\n  probe_log_append (\"[%s] buffer=%p available=%zu dump=%zu\\n\", tag, (const void *)buffer, available, dump);\n  for (i = 0; i < dump; ++i)\n  {\n    unsigned char c = (unsigned char)buffer[i];\n    probe_log_append (\"%02x\", c);\n    if ( (i + 1) % 16 == 0 )\n      probe_log_append (\"\\n\");\n  }\n  if (dump % 16 != 0)\n    probe_log_append (\"\\n\");\n  probe_log_append (\"[%s] chars: \", tag);\n  for (i = 0; i < dump; ++i)\n  {\n    unsigned char c = (unsigned char)buffer[i];\n    probe_log_append (\"%c\", isprint(c) ? c : '.');\n  }\n  probe_log_append (\"\\n\");\n}\n\n/* Modified process_request_body with probes added. */\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n\n  /* Probe initial state of buffer_head */\n  probe_log_append (\"ENTER process_request_body: connection=%p daemon=%p\\n\", (void *)connection, (void *)daemon);\n  probe_dump_buffer (\"init\", buffer_head, available, 64);\n\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        probe_log_append (\"chunk-end: before CRLF-check buffer_head=%p available=%zu\\n\", (void *)buffer_head, available);\n        probe_dump_buffer (\"chunk-end-before\", buffer_head, available, 8);\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          probe_log_append (\"chunk-end: malformed CRLF at buffer=%p available=%zu\\n\", (void *)buffer_head, available);\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          probe_log_append (\"RETURN (malformed chunk-end)\\n\");\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        probe_log_append (\"chunk-end: skipped=%zu new_buffer_head=%p available=%zu\\n\", i, (void *)buffer_head, available);\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n        probe_log_append (\"in-chunk: cur_chunk_left=%\" PRIu64 \" to_be_processed=%zu instant_retry=%d buffer_head=%p available=%zu\\n\",\n                          cur_chunk_left, to_be_processed, instant_retry, (void *)buffer_head, available);\n        probe_dump_buffer (\"in-chunk\", buffer_head, available, 32);\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        probe_log_append (\"parse-chunk-size: calling MHD_strx_to_uint64_n_ buffer_head=%p available=%zu\\n\",\n                          (void *)buffer_head, available);\n        probe_dump_buffer (\"parse-chunk-before\", buffer_head, available, 64);\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        probe_log_append (\"parse-chunk-size: returned num_dig=%zu chunk_size=%\" PRIu64 \"\\n\",\n                          num_dig, chunk_size);\n\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            probe_log_append (\"chunk-size-line: chunk_size=%\" PRIu64 \" line_len=%zu new_buffer_head=%p available=%zu\\n\",\n                              chunk_size, chunk_size_line_len, (void *)buffer_head, available);\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n        {\n          probe_log_append (\"parse-chunk-size: invalid chunk format (not overflow). buffer_head=%p\\n\", (void *)buffer_head);\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        }\n        else\n        {\n          probe_log_append (\"parse-chunk-size: overflow detected. buffer_head=%p\\n\", (void *)buffer_head);\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        }\n        probe_log_append (\"RETURN (parse-chunk-size error)\\n\");\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n\n    probe_log_append (\"calling default_handler: buffer_head=%p to_be_processed=%zu left_unprocessed(before)=%zu\\n\",\n                      (void *)buffer_head, to_be_processed, left_unprocessed);\n    probe_dump_buffer (\"before-default-handler\", buffer_head, left_unprocessed, 64);\n\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      probe_log_append (\"default_handler returned MHD_NO. Closing connection.\\n\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      probe_log_append (\"RETURN (default_handler error)\\n\");\n      return;\n    }\n    connection->in_access_handler = false;\n\n    probe_log_append (\"default_handler returned. left_unprocessed(after)=%zu to_be_processed=%zu\\n\",\n                      left_unprocessed, to_be_processed);\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n\n    probe_log_append (\"after-processing: processed_size=%zu new_buffer_head=%p available=%zu\\n\",\n                      processed_size, (void *)buffer_head, available);\n\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n  {\n    probe_log_append (\"memmove: moving %zu bytes from %p to %p\\n\", available, (void *)buffer_head, (void *)connection->read_buffer);\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  }\n  else\n  {\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  }\n  connection->read_buffer_offset = available;\n\n  probe_log_append (\"EXIT process_request_body: final buffer_head=%p available=%zu read_buffer=%p read_buffer_offset=%zu\\n\",\n                    (void *)buffer_head, available, (void *)connection->read_buffer, connection->read_buffer_offset);\n}\n"
}