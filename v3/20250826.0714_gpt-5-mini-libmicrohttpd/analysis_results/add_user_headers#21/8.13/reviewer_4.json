{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes header name data and a string literal to a case-insensitive compare. If the struct member hdr->header is declared as a non-const pointer (e.g. char *header) or the macro MHD_HTTP_HEADER_TRANSFER_ENCODING expands to a non-const char array/pointer, this violates MISRA C 2023 Rule 8.13 because these pointers point to objects that are not modified and therefore should be const-qualified (const char *). For example, if struct MHD_HTTP_Res_Header declares header as 'char *header' (not 'const char *header'), that is a rule violation. Recommended fix: declare header and static string macros as const char * (and ensure comparison functions accept const char *).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nadd_user_headers: entry: response=0x55af2052b0c0, buf=0x55af205230d0, *ppos=71, buf_size=32576\nflags_auto=0x00000001, flags=0x00000000, filter_transf_enc=1, filter_content_len=1, add_close=0, add_keep_alive=0\npost-filter adjust: filter_transf_enc=0, filter_content_len=0, add_close=0, add_keep_alive=0\niter header: hdr=0x55af2052b1a0, kind=1, hdr->header=0x55af2052b1e0, hdr->header_size=10, hdr->value=0x55af2052b180, hdr->value_size=7\nheader_written: len=10, data=\"Connection\"\nvalue_written: len=7, data=\"Upgrade\"\ncompleted header iteration: hdr=0x55af2052b1a0, new *ppos=92, expected_end=92\niter header: hdr=0x55af2052b240, kind=1, hdr->header=0x55af2052b200, hdr->header_size=7, hdr->value=0x55af2052b220, hdr->value_size=20\nheader_written: len=7, data=\"Upgrade\"\nvalue_written: len=20, data=\"Hello World Protocol\"\ncompleted header iteration: hdr=0x55af2052b240, new *ppos=123, expected_end=123\nadd_user_headers: exit returning true, final *ppos=123\nadd_user_headers: entry: response=0x55af2052bcd0, buf=0x55af205230d0, *ppos=71, buf_size=32576\nflags_auto=0x00000001, flags=0x00000000, filter_transf_enc=1, filter_content_len=1, add_close=0, add_keep_alive=0\npost-filter adjust: filter_transf_enc=0, filter_content_len=0, add_close=0, add_keep_alive=0\niter header: hdr=0x55af2052bd90, kind=1, hdr->header=0x55af2052b200, hdr->header_size=10, hdr->value=0x55af2052b220, hdr->value_size=7\nheader_written: len=10, data=\"Connection\"\nvalue_written: len=7, data=\"Upgrade\"\ncompleted header iteration: hdr=0x55af2052bd90, new *ppos=92, expected_end=92\niter header: hdr=0x55af2052bdd0, kind=1, hdr->header=0x55af2052b180, hdr->header_size=7, hdr->value=0x55af2052b1e0, hdr->value_size=20\nheader_written: len=7, data=\"Upgrade\"\nvalue_written: len=20, data=\"Hello World Protocol\"\ncompleted header iteration: hdr=0x55af2052bdd0, new *ppos=123, expected_end=123\nadd_user_headers: exit returning true, final *ppos=123\nadd_user_headers: entry: response=0x55af2052c290, buf=0x55af2052c4f0, *ppos=71, buf_size=32576\nflags_auto=0x00000001, flags=0x00000000, filter_transf_enc=1, filter_content_len=1, add_close=0, add_keep_alive=0\npost-filter adjust: filter_transf_enc=0, filter_content_len=0, add_close=0, add_keep_alive=0\niter header: hdr=0x55af2052c350, kind=1, hdr->header=0x55af2052b180, hdr->header_size=10, hdr->value=0x55af2052b1e0, hdr->value_size=7\nheader_written: len=10, data=\"Connection\"\nvalue_written: len=7, data=\"Upgrade\"\ncompleted header iteration: hdr=0x55af2052c350, new *ppos=92, expected_end=92\niter header: hdr=0x55af2052c390, kind=1, hdr->header=0x55af2052b220, hdr->header_size=7, hdr->value=0x55af2052b200, hdr->value_size=20\nheader_written: len=7, data=\"Upgrade\"\nvalue_written: len=20, data=\"Hello World Protocol\"\ncompleted header iteration: hdr=0x55af2052c390, new *ppos=123, expected_end=123\nadd_user_headers: exit returning true, final *ppos=123\nadd_user_headers: entry: response=0x7f68e4000b90, buf=0x7f68dc000e50, *ppos=71, buf_size=32576\nflags_auto=0x00000001, flags=0x00000000, filter_transf_enc=1, filter_content_len=1, add_close=0, add_keep_alive=0\npost-filter adjust: filter_transf_enc=0, filter_content_len=0, add_close=0, add_keep_alive=0\niter header: hdr=0x7f68e4000c50, kind=1, hdr->header=0x7f68e4000c90, hdr->header_size=10, hdr->value=0x7f68e4000b70, hdr->value_size=7\nheader_written: len=10, data=\"Connection\"\nvalue_written: len=7, data=\"Upgrade\"\ncompleted header iteration: hdr=0x7f68e4000c50, new *ppos=92, expected_end=92\niter header: hdr=0x7f68e4000cf0, kind=1, hdr->header=0x7f68e4000cb0, hdr->header_size=7, hdr->value=0x7f68e4000cd0, hdr->value_size=20\nheader_written: len=7, data=\"Upgrade\"\nvalue_written: len=20, data=\"Hello World Protocol\"\ncompleted header iteration: hdr=0x7f68e4000cf0, new *ppos=123, expected_end=123\nadd_user_headers: exit returning true, final *ppos=123\nadd_user_headers: entry: response=0x7f68d8000b90, buf=0x7f68dc000e50, *ppos=71, buf_size=32576\nflags_auto=0x00000001, flags=0x00000000, filter_transf_enc=1, filter_content_len=1, add_close=0, add_keep_alive=0\npost-filter adjust: filter_transf_enc=0, filter_content_len=0, add_close=0,\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s finding is correct in the scenario described. MISRA C 2023 Rule 8.13 says pointers should point to const-qualified types whenever possible. In add_user_headers the function only reads from response, the header structures and their header/value character data \u2014 it does not modify those objects. Yet the code (as shown) uses non-const pointee types: for example r is declared as struct MHD_Response *const r (the pointer is const but the pointee is not), and the function uses hdr->header and hdr->value as read-only buffers (passed to case-insensitive compare routines and to memcpy as sources). If the actual declaration of struct MHD_HTTP_Res_Header uses non-const char *header or char *value (or if the macros like MHD_HTTP_HEADER_TRANSFER_ENCODING expand to a non-const char *), that is a violation of Rule 8.13 because those pointers refer to objects that the function does not modify and therefore should be const-qualified (const char * or const struct ... *).\n\nNotes and recommended fixes:\n- If struct MHD_HTTP_Res_Header currently declares header and value as char *header, char *value, change them to const char *header, const char *value.\n- Change the local iterator declaration to const struct MHD_HTTP_Res_Header *hdr (or const struct ... * const hdr if you also want the pointer itself non-modifiable). Likewise, r should be declared as const struct MHD_Response *const r if response is not modified here.\n- Ensure any comparison or helper functions accept const char * for their string arguments (or add const casts only if the callee API cannot be changed, but better to update APIs to use const correctness).\n\nCaveat: whether a rule violation actually exists depends on the real declarations in the project. If the structure members and macros are already const-qualified, there is no violation. Given the scenario Agent A presented (members declared as non-const), the report is correct."
}