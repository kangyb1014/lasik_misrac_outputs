{
  "user_message": "An agent A claimed that the following add_user_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of add_user_headers.\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes hdr->header (a non-const pointer to header bytes) into a string-comparison using a string literal (MHD_HTTP_HEADER_CONTENT_LENGTH). The header data is only read, not modified, so the member should be declared as pointing to const-qualified data (e.g. const char *header). Because hdr->header is not const-qualified even though it could and should be, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nadd_user_headers: entry r=0x55b4fc9a10c0 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x55b4fc9a11a0 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 copying to buf+71\nwriting header value: value_size=7 to buf+83 header_value=\"Upgrade\"\nfinished header iteration: initial_pos=71 el_size=21 new_ppos=92\niter header: hdr=0x55b4fc9a1240 kind=1 header_size=7 value_size=20\nwriting header bytes: hdr->header_size=7 copying to buf+92\nwriting header value: value_size=20 to buf+101 header_value=\"Hello World Protocol\"\nfinished header iteration: initial_pos=92 el_size=31 new_ppos=123\nadd_user_headers: exit returning true final_ppos=123\nadd_user_headers: entry r=0x55b4fc9a1cd0 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x55b4fc9a1d90 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 copying to buf+71\nwriting header value: value_size=7 to buf+83 header_value=\"Upgrade\"\nfinished header iteration: initial_pos=71 el_size=21 new_ppos=92\niter header: hdr=0x55b4fc9a1dd0 kind=1 header_size=7 value_size=20\nwriting header bytes: hdr->header_size=7 copying to buf+92\nwriting header value: value_size=20 to buf+101 header_value=\"Hello World Protocol\"\nfinished header iteration: initial_pos=92 el_size=31 new_ppos=123\nadd_user_headers: exit returning true final_ppos=123\nadd_user_headers: entry r=0x55b4fc9a2290 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x55b4fc9a2350 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 copying to buf+71\nwriting header value: value_size=7 to buf+83 header_value=\"Upgrade\"\nfinished header iteration: initial_pos=71 el_size=21 new_ppos=92\niter header: hdr=0x55b4fc9a2390 kind=1 header_size=7 value_size=20\nwriting header bytes: hdr->header_size=7 copying to buf+92\nwriting header value: value_size=20 to buf+101 header_value=\"Hello World Protocol\"\nfinished header iteration: initial_pos=92 el_size=31 new_ppos=123\nadd_user_headers: exit returning true final_ppos=123\nadd_user_headers: entry r=0x7ffa88000b90 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x7ffa88000c50 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 copying to buf+71\nwriting header value: value_size=7 to buf+83 header_value=\"Upgrade\"\nfinished header iteration: initial_pos=71 el_size=21 new_ppos=92\niter header: hdr=0x7ffa88000cf0 kind=1 header_size=7 value_size=20\nwriting header bytes: hdr->header_size=7 copying to buf+92\nwriting header value: value_size=20 to buf+101 header_value=\"Hello World Protocol\"\nfinished header iteration: initial_pos=92 el_size=31 new_ppos=123\nadd_user_headers: exit returning true final_ppos=123\nadd_user_headers: entry r=0x7ffa88000b90 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x7ffa88000c50 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 copying to buf+71\nwriting header value: value_size=7 to buf+83 header_value=\"Upgrade\"\nfinished header iteration: initial_pos=71 el_size=21 new_ppos=92\niter header: hdr=0x7ffa88000d30 kind=1 header_size=7 value_size=20\nwriting header bytes: hdr->header_size=7 copying to buf+92\nwriting header value: value_size=20 to buf+101 header_value=\"Hello World Protocol\"\nfinished header iteration: initial_pos=92 el_size=31 new_ppos=123\nadd_user_headers: exit returning true final_ppos=123\nadd_user_headers: entry r=0x7ffa88000db0 flags_auto=0x00000001 flags=0x00000000 filter_transf_enc=1 filter_content_len=1 add_close=0 add_keep_alive=0 *ppos=71 buf_size=32576\niter header: hdr=0x7ffa88000e70 kind=1 header_size=10 value_size=7\nwriting header bytes: hdr->header_size=10 cop\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 says that pointers should point to const-qualified types whenever possible. In the shown function all uses of hdr->header are read-only (passed to memcpy and string-compare helpers), so from this function\u2019s perspective the header bytes could be pointed to by a const char *. However, the code snippet does not include the declaration of struct MHD_HTTP_Res_Header (the actual type of hdr->header). The rule applies to the declarations of pointer types (including struct members), not to each use-site. Therefore the agent\u2019s report can only be validated if the struct member is actually declared as a non-const pointer (for example: char *header). If the member is declared as const char *header then there is no violation. Conversely, if the member is declared as char *header and the implementation never mutates the pointed-to data anywhere, that declaration would violate 8.13 and the agent\u2019s report would be correct. Given only the function body we cannot determine the member\u2019s declaration \u2014 so the claim is plausible but not provable from the provided code. I therefore do not mark the report as definitely correct; you must inspect the struct definition (or other code that legitimately needs to modify header bytes) to decide whether the member should be const."
}