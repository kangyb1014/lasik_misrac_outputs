{
  "user_message": "An agent A claimed that the following MHD_str_remove_tokens_caseless_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_remove_tokens_caseless_.\n```c\nbool\nMHD_str_remove_tokens_caseless_ (char *str,\n                                 size_t *str_len,\n                                 const char *const tokens,\n                                 const size_t tokens_len)\n{\n  const char *const t = tokens;   /**< a short alias for @a tokens */\n  size_t pt;                      /**< position in @a tokens */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (tokens, 0, tokens_len));\n\n  token_removed = false;\n  pt = 0;\n\n  while (pt < tokens_len && *str_len != 0)\n  {\n    const char *tkn; /**< the current token */\n    size_t tkn_len;\n\n    /* Skip any initial whitespaces and empty tokens in 'tokens' */\n    while ( (pt < tokens_len) &&\n            ((' ' == t[pt]) || ('\\t' == t[pt]) || (',' == t[pt])) )\n      pt++;\n\n    if (pt >= tokens_len)\n      break; /* No more tokens, nothing to remove */\n\n    /* Found non-whitespace char which is not a comma */\n    tkn = t + pt;\n    do\n    {\n      do\n      {\n        pt++;\n      } while (pt < tokens_len &&\n               (' ' != t[pt] && '\\t' != t[pt] && ',' != t[pt]));\n      /* Found end of the token string, space, tab, or comma */\n      tkn_len = pt - (size_t) (tkn - t);\n\n      /* Skip all spaces and tabs */\n      while (pt < tokens_len && (' ' == t[pt] || '\\t' == t[pt]))\n        pt++;\n      /* Found end of the token string or non-whitespace char */\n    } while (pt < tokens_len && ',' != t[pt]);\n\n    /* 'tkn' is the input token with 'tkn_len' chars */\n    mhd_assert (0 != tkn_len);\n\n    if (*str_len == tkn_len)\n    {\n      if (MHD_str_equal_caseless_bin_n_ (str, tkn, tkn_len))\n      {\n        *str_len = 0;\n        token_removed = true;\n      }\n      continue;\n    }\n    /* 'tkn' cannot match part of 'str' if length of 'tkn' is larger\n     * than length of 'str'.\n     * It's know that 'tkn' is not equal to the 'str' (was checked previously).\n     * As 'str' is normalized when 'tkn' is not equal to the 'str'\n     * it is required that 'str' to be at least 3 chars larger then 'tkn'\n     * (the comma, the space and at least one additional character for the next\n     * token) to remove 'tkn' from the 'str'. */\n    if (*str_len > tkn_len + 2)\n    { /* Remove 'tkn' from the input string */\n      size_t pr;    /**< the 'read' position in the @a str */\n      size_t pw;    /**< the 'write' position in the @a str */\n\n      pr = 0;\n      pw = 0;\n\n      do\n      {\n        mhd_assert (pr >= pw);\n        mhd_assert ((*str_len) >= (pr + tkn_len));\n        if ( ( ((*str_len) == (pr + tkn_len)) || (',' == str[pr + tkn_len]) ) &&\n             MHD_str_equal_caseless_bin_n_ (str + pr, tkn, tkn_len) )\n        {\n          /* current token in the input string matches the 'tkn', skip it */\n          mhd_assert ((*str_len == pr + tkn_len) || \\\n                      (' ' == str[pr + tkn_len + 1])); /* 'str' must be normalized */\n          token_removed = true;\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += tkn_len + 2;\n        }\n        else\n        {\n          /* current token in the input string does not match the 'tkn',\n           * copy to the output */\n          if (0 != pw)\n          { /* not the first output token, add \", \" to separate */\n            if (pr != pw + 2)\n            {\n              str[pw++] = ',';\n              str[pw++] = ' ';\n            }\n            else\n              pw += 2; /* 'str' is not yet modified in this round */\n          }\n          do\n          {\n            if (pr != pw)\n              str[pw] = str[pr];\n            pr++;\n            pw++;\n          } while (pr < *str_len && ',' != str[pr]);\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += 2;\n        }\n        /* 'pr' should point to the next token in the input string or beyond\n         * the end of the input string */\n        if ((*str_len) < (pr + tkn_len))\n        { /* The rest of the 'str + pr' is too small to match 'tkn' */\n          if ((*str_len) > pr)\n          { /* Copy the rest of the string */\n            size_t copy_size;\n            copy_size = *str_len - pr;\n            if (0 != pw)\n            { /* not the first output token, add \", \" to separate */\n              if (pr != pw + 2)\n              {\n                str[pw++] = ',';\n                str[pw++] = ' ';\n              }\n              else\n                pw += 2; /* 'str' is not yet modified in this round */\n            }\n            if (pr != pw)\n              memmove (str + pw, str + pr, copy_size);\n            pw += copy_size;\n          }\n          *str_len = pw;\n          break;\n        }\n        mhd_assert ((' ' != str[0]) && ('\\t' != str[0]));\n        mhd_assert ((0 == pr) || (3 <= pr));\n        mhd_assert ((0 == pr) || (' ' == str[pr - 1]));\n        mhd_assert ((0 == pr) || (',' == str[pr - 2]));\n      } while (1);\n    }\n  }\n\n  return token_removed;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memchr(tokens, 0, tokens_len) will read tokens[0]..tokens[tokens_len-1]. If tokens_len can be larger than the actual size of the object pointed to by tokens (for example tokens points to a short string or buffer of length 3 but tokens_len is 10), memchr will access beyond the object bounds causing undefined behavior. The subsequent mhd_assert(...) does not prevent the out-of-bounds read because memchr is invoked with the possibly-too-large length. Therefore this usage can violate Rule 21.17 when tokens_len does not accurately reflect the object size.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=6\nmemchr called on tokens=0x7ffdbb2f0470 with len=6 -> result=(nil)\nLOOP_START: pt=0, tokens_len=6, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=6\nmemchr called on tokens=0x7ffdbb2f0470 with len=6 -> result=(nil)\nLOOP_START: pt=0, tokens_len=6, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=6\nmemchr called on tokens=0x7ffdbb2f0470 with len=6 -> result=(nil)\nLOOP_START: pt=0, tokens_len=6, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=6\nmemchr called on tokens=0x7ffdbb2f0470 with len=6 -> result=(nil)\nLOOP_START: pt=0, tokens_len=6, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=7\nmemchr called on tokens=0x7ffdbb2f0470 with len=7 -> result=(nil)\nLOOP_START: pt=0, tokens_len=7, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=6, tokens=0x7ffdbb2f0470, tokens_len=7\nmemchr called on tokens=0x7ffdbb2f0470 with len=7 -> result=(nil)\nLOOP_START: pt=0, tokens_len=7, *str_len=6\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0471, tkn_offset=1, tkn_len=6\nCOMPARE_EQ_LEN: *str_len==tkn_len==6, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=5, tokens=0x7ffdbb2f0470, tokens_len=10\nmemchr called on tokens=0x7ffdbb2f0470 with len=10 -> result=(nil)\nLOOP_START: pt=0, tokens_len=10, *str_len=5\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0473, tkn_offset=3, tkn_len=5\nCOMPARE_EQ_LEN: *str_len==tkn_len==5, comparing content\nTOKEN_REMOVED: exact match -> *str_len set to 0, token_removed=true\nEXIT: MHD_str_remove_tokens_caseless_: token_removed=1, final *str_len=0, str=0x7ffdbb2f0570\nENTER: MHD_str_remove_tokens_caseless_: str=0x7ffdbb2f0570, str_len_ptr=0x7ffdbb2f0460, *str_len=16, tokens=0x7ffdbb2f0470, tokens_len=5\nmemchr called on tokens=0x7ffdbb2f0470 with len=5 -> result=(nil)\nLOOP_START: pt=0, tokens_len=5, *str_len=16\nTOKEN_FOUND: tkn_ptr=0x7ffdbb2f0470, tkn_offset=0, tkn_len=5\nREMOVE_PHASE_START: initial pr=0, pw=0, *str_len=16, tkn_len=5\nCOPY_TOKEN: copied up to pr=11, pw=9\nMATCH_IN_STR: pr=11, mat\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call memchr(tokens, 0, tokens_len) will read exactly tokens_len bytes starting at tokens; if the caller supplies a tokens_len larger than the actual allocated/valid size of the tokens object, memchr will access out\u2011of\u2011bounds and cause undefined behaviour. The subsequent mhd_assert does not prevent this because it is evaluated after memchr has already been invoked. MISRA Rule 21.17 requires that uses of functions from <string.h> must not result in accesses beyond the bounds of the referenced objects. Unless there is an external/guaranteed contract that tokens actually points to at least tokens_len bytes (i.e. a documented precondition that callers must ensure), this code can violate Rule 21.17. (By contrast, the later memmove usage appears bounded by *str_len and pr, but that does not mitigate the memchr issue.)"
}