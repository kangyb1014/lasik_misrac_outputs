{
  "user_message": "An agent A claimed that the following MHD_str_remove_tokens_caseless_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_remove_tokens_caseless_.\n```c\nbool\nMHD_str_remove_tokens_caseless_ (char *str,\n                                 size_t *str_len,\n                                 const char *const tokens,\n                                 const size_t tokens_len)\n{\n  const char *const t = tokens;   /**< a short alias for @a tokens */\n  size_t pt;                      /**< position in @a tokens */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (tokens, 0, tokens_len));\n\n  token_removed = false;\n  pt = 0;\n\n  while (pt < tokens_len && *str_len != 0)\n  {\n    const char *tkn; /**< the current token */\n    size_t tkn_len;\n\n    /* Skip any initial whitespaces and empty tokens in 'tokens' */\n    while ( (pt < tokens_len) &&\n            ((' ' == t[pt]) || ('\\t' == t[pt]) || (',' == t[pt])) )\n      pt++;\n\n    if (pt >= tokens_len)\n      break; /* No more tokens, nothing to remove */\n\n    /* Found non-whitespace char which is not a comma */\n    tkn = t + pt;\n    do\n    {\n      do\n      {\n        pt++;\n      } while (pt < tokens_len &&\n               (' ' != t[pt] && '\\t' != t[pt] && ',' != t[pt]));\n      /* Found end of the token string, space, tab, or comma */\n      tkn_len = pt - (size_t) (tkn - t);\n\n      /* Skip all spaces and tabs */\n      while (pt < tokens_len && (' ' == t[pt] || '\\t' == t[pt]))\n        pt++;\n      /* Found end of the token string or non-whitespace char */\n    } while (pt < tokens_len && ',' != t[pt]);\n\n    /* 'tkn' is the input token with 'tkn_len' chars */\n    mhd_assert (0 != tkn_len);\n\n    if (*str_len == tkn_len)\n    {\n      if (MHD_str_equal_caseless_bin_n_ (str, tkn, tkn_len))\n      {\n        *str_len = 0;\n        token_removed = true;\n      }\n      continue;\n    }\n    /* 'tkn' cannot match part of 'str' if length of 'tkn' is larger\n     * than length of 'str'.\n     * It's know that 'tkn' is not equal to the 'str' (was checked previously).\n     * As 'str' is normalized when 'tkn' is not equal to the 'str'\n     * it is required that 'str' to be at least 3 chars larger then 'tkn'\n     * (the comma, the space and at least one additional character for the next\n     * token) to remove 'tkn' from the 'str'. */\n    if (*str_len > tkn_len + 2)\n    { /* Remove 'tkn' from the input string */\n      size_t pr;    /**< the 'read' position in the @a str */\n      size_t pw;    /**< the 'write' position in the @a str */\n\n      pr = 0;\n      pw = 0;\n\n      do\n      {\n        mhd_assert (pr >= pw);\n        mhd_assert ((*str_len) >= (pr + tkn_len));\n        if ( ( ((*str_len) == (pr + tkn_len)) || (',' == str[pr + tkn_len]) ) &&\n             MHD_str_equal_caseless_bin_n_ (str + pr, tkn, tkn_len) )\n        {\n          /* current token in the input string matches the 'tkn', skip it */\n          mhd_assert ((*str_len == pr + tkn_len) || \\\n                      (' ' == str[pr + tkn_len + 1])); /* 'str' must be normalized */\n          token_removed = true;\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += tkn_len + 2;\n        }\n        else\n        {\n          /* current token in the input string does not match the 'tkn',\n           * copy to the output */\n          if (0 != pw)\n          { /* not the first output token, add \", \" to separate */\n            if (pr != pw + 2)\n            {\n              str[pw++] = ',';\n              str[pw++] = ' ';\n            }\n            else\n              pw += 2; /* 'str' is not yet modified in this round */\n          }\n          do\n          {\n            if (pr != pw)\n              str[pw] = str[pr];\n            pr++;\n            pw++;\n          } while (pr < *str_len && ',' != str[pr]);\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += 2;\n        }\n        /* 'pr' should point to the next token in the input string or beyond\n         * the end of the input string */\n        if ((*str_len) < (pr + tkn_len))\n        { /* The rest of the 'str + pr' is too small to match 'tkn' */\n          if ((*str_len) > pr)\n          { /* Copy the rest of the string */\n            size_t copy_size;\n            copy_size = *str_len - pr;\n            if (0 != pw)\n            { /* not the first output token, add \", \" to separate */\n              if (pr != pw + 2)\n              {\n                str[pw++] = ',';\n                str[pw++] = ' ';\n              }\n              else\n                pw += 2; /* 'str' is not yet modified in this round */\n            }\n            if (pr != pw)\n              memmove (str + pw, str + pr, copy_size);\n            pw += copy_size;\n          }\n          *str_len = pw;\n          break;\n        }\n        mhd_assert ((' ' != str[0]) && ('\\t' != str[0]));\n        mhd_assert ((0 == pr) || (3 <= pr));\n        mhd_assert ((0 == pr) || (' ' == str[pr - 1]));\n        mhd_assert ((0 == pr) || (',' == str[pr - 2]));\n      } while (1);\n    }\n  }\n\n  return token_removed;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe mhd_assert call evaluates the condition (' ' != str[0]) && ('\\t' != str[0]) at run-time but does not alter program state. If the assertion handler is a no-op in the deployed build (or the condition is guaranteed true by the surrounding code), the statement is executed but its removal would not affect program behaviour \u2014 meeting the definition of dead code in MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=6\n  str(prefix 6)='string'\n  tokens(prefix 6)='string'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=6\n  str(prefix 6)='String'\n  tokens(prefix 6)='string'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=6\n  str(prefix 6)='string'\n  tokens(prefix 6)='String'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=6\n  str(prefix 6)='strinG'\n  tokens(prefix 6)='String'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=7\n  str(prefix 6)='strinG'\n  tokens(prefix 7)='String\t'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=7\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=6, tokens_len=7\n  str(prefix 6)='strinG'\n  tokens(prefix 7)='\tString'\ntokens: skipped ws, pt=1\nprocessing token: tkn_len=6, pt=7\n  compare whole string: str_len==tkn_len (6)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=5, tokens_len=10\n  str(prefix 5)='tOkEn'\n  tokens(prefix 10)=' \t toKEN  '\ntokens: skipped ws, pt=3\nprocessing token: tkn_len=5, pt=10\n  compare whole string: str_len==tkn_len (5)\n  token matched entire string -> removed, new str_len=0\nEXIT: token_removed=1, final str_len=0\nENTER: MHD_str_remove_tokens_caseless_: str_len=16, tokens_len=5\n  str(prefix 16)='not-token, tOkEn'\n  tokens(prefix 5)='token'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=5, pt=5\n  enter removal loop: pr=0, pw=0, str_len=16, tkn_len=5\n    assertion-probe: pr=11, pw=9, str[0]=0x6e('n'), str_len=16\n    matched token at pr=11, advancing by 7 (tkn_len+2)\n    rest too small, copied rest -> new str_len=9\nEXIT: token_removed=1, final str_len=9\nENTER: MHD_str_remove_tokens_caseless_: str_len=25, tokens_len=6\n  str(prefix 25)='not-token1, tOkEn1, token'\n  tokens(prefix 6)='token1'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  enter removal loop: pr=0, pw=0, str_len=25, tkn_len=6\n    assertion-probe: pr=12, pw=10, str[0]=0x6e('n'), str_len=25\n    matched token at pr=12, advancing by 8 (tkn_len+2)\n    rest too small, copied rest -> new str_len=17\nEXIT: token_removed=1, final str_len=17\nENTER: MHD_str_remove_tokens_caseless_: str_len=13, tokens_len=6\n  str(prefix 13)='token, tOkEn1'\n  tokens(prefix 6)='token1'\ntokens: skipped ws, pt=0\nprocessing token: tkn_len=6, pt=6\n  enter removal loop: pr=0, pw=0, str_len=13, tkn_len=6\n    assertion-probe: pr=7, pw=5, str[0]=0x74('t'), str_len=13\n    matched token at pr=7, advancing by 8 (tkn_len+2)\n    rest too small, copied rest -> new str_len=5\nEXIT: token_removed=1, final str_len=5\nENTER: MHD_str_remove_tokens_caseless_: str_len=16, tokens_len=8\n  str(prefix 16)='not-token, tOkEn'\n  tokens(prefix 8)=' \t toKEN'\ntokens: skipped ws, pt=3\nprocessing token: tkn_len=5, pt=8\n  enter removal loop: pr=0, pw=0, str_len=16, tkn_len=5\n    assertion-probe: pr=11, pw=9, str[0]=0x6e('n'), str_len=16\n    matched token at pr=11, advancing by 7 (tkn_len+2)\n    rest too small, copied rest -> new str_len=9\nEXIT: token_removed=1, final str_len=9\nENTER: MHD_str_remove_tokens_caseless_: str_len=28, tokens_len=6\n  s\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The mhd_assert invocations in this function are diagnostic checks \u2014 they either expand to code that may affect program behaviour (e.g. invoke an assertion handler, abort, log, etc.) or are omitted entirely by the build configuration. Under the rule text a construct is dead code only if it is executed and its removal would not affect program behaviour. If the assertion macro is enabled at run time then removing the assertion could change behaviour in the presence of a failed invariant (handler invocation/abort), so it is not dead. If the macro is disabled in the deployed build the assertion is not executed at all in that build, and therefore does not meet MISRA\u2019s definition of dead code (which requires execution). In short, ordinary assert-style diagnostics do not automatically constitute MISRA R2.2 violations: they either have potential behavioural effect when enabled or are not executed when disabled. Therefore Agent A\u2019s claim that this assertion constitutes dead code under Rule 2.2 is not correct."
}