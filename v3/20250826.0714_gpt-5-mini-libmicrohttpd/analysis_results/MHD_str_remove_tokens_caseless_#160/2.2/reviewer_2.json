{
  "user_message": "An agent A claimed that the following MHD_str_remove_tokens_caseless_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_remove_tokens_caseless_.\n```c\nbool\nMHD_str_remove_tokens_caseless_ (char *str,\n                                 size_t *str_len,\n                                 const char *const tokens,\n                                 const size_t tokens_len)\n{\n  const char *const t = tokens;   /**< a short alias for @a tokens */\n  size_t pt;                      /**< position in @a tokens */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (tokens, 0, tokens_len));\n\n  token_removed = false;\n  pt = 0;\n\n  while (pt < tokens_len && *str_len != 0)\n  {\n    const char *tkn; /**< the current token */\n    size_t tkn_len;\n\n    /* Skip any initial whitespaces and empty tokens in 'tokens' */\n    while ( (pt < tokens_len) &&\n            ((' ' == t[pt]) || ('\\t' == t[pt]) || (',' == t[pt])) )\n      pt++;\n\n    if (pt >= tokens_len)\n      break; /* No more tokens, nothing to remove */\n\n    /* Found non-whitespace char which is not a comma */\n    tkn = t + pt;\n    do\n    {\n      do\n      {\n        pt++;\n      } while (pt < tokens_len &&\n               (' ' != t[pt] && '\\t' != t[pt] && ',' != t[pt]));\n      /* Found end of the token string, space, tab, or comma */\n      tkn_len = pt - (size_t) (tkn - t);\n\n      /* Skip all spaces and tabs */\n      while (pt < tokens_len && (' ' == t[pt] || '\\t' == t[pt]))\n        pt++;\n      /* Found end of the token string or non-whitespace char */\n    } while (pt < tokens_len && ',' != t[pt]);\n\n    /* 'tkn' is the input token with 'tkn_len' chars */\n    mhd_assert (0 != tkn_len);\n\n    if (*str_len == tkn_len)\n    {\n      if (MHD_str_equal_caseless_bin_n_ (str, tkn, tkn_len))\n      {\n        *str_len = 0;\n        token_removed = true;\n      }\n      continue;\n    }\n    /* 'tkn' cannot match part of 'str' if length of 'tkn' is larger\n     * than length of 'str'.\n     * It's know that 'tkn' is not equal to the 'str' (was checked previously).\n     * As 'str' is normalized when 'tkn' is not equal to the 'str'\n     * it is required that 'str' to be at least 3 chars larger then 'tkn'\n     * (the comma, the space and at least one additional character for the next\n     * token) to remove 'tkn' from the 'str'. */\n    if (*str_len > tkn_len + 2)\n    { /* Remove 'tkn' from the input string */\n      size_t pr;    /**< the 'read' position in the @a str */\n      size_t pw;    /**< the 'write' position in the @a str */\n\n      pr = 0;\n      pw = 0;\n\n      do\n      {\n        mhd_assert (pr >= pw);\n        mhd_assert ((*str_len) >= (pr + tkn_len));\n        if ( ( ((*str_len) == (pr + tkn_len)) || (',' == str[pr + tkn_len]) ) &&\n             MHD_str_equal_caseless_bin_n_ (str + pr, tkn, tkn_len) )\n        {\n          /* current token in the input string matches the 'tkn', skip it */\n          mhd_assert ((*str_len == pr + tkn_len) || \\\n                      (' ' == str[pr + tkn_len + 1])); /* 'str' must be normalized */\n          token_removed = true;\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += tkn_len + 2;\n        }\n        else\n        {\n          /* current token in the input string does not match the 'tkn',\n           * copy to the output */\n          if (0 != pw)\n          { /* not the first output token, add \", \" to separate */\n            if (pr != pw + 2)\n            {\n              str[pw++] = ',';\n              str[pw++] = ' ';\n            }\n            else\n              pw += 2; /* 'str' is not yet modified in this round */\n          }\n          do\n          {\n            if (pr != pw)\n              str[pw] = str[pr];\n            pr++;\n            pw++;\n          } while (pr < *str_len && ',' != str[pr]);\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += 2;\n        }\n        /* 'pr' should point to the next token in the input string or beyond\n         * the end of the input string */\n        if ((*str_len) < (pr + tkn_len))\n        { /* The rest of the 'str + pr' is too small to match 'tkn' */\n          if ((*str_len) > pr)\n          { /* Copy the rest of the string */\n            size_t copy_size;\n            copy_size = *str_len - pr;\n            if (0 != pw)\n            { /* not the first output token, add \", \" to separate */\n              if (pr != pw + 2)\n              {\n                str[pw++] = ',';\n                str[pw++] = ' ';\n              }\n              else\n                pw += 2; /* 'str' is not yet modified in this round */\n            }\n            if (pr != pw)\n              memmove (str + pw, str + pr, copy_size);\n            pw += copy_size;\n          }\n          *str_len = pw;\n          break;\n        }\n        mhd_assert ((' ' != str[0]) && ('\\t' != str[0]));\n        mhd_assert ((0 == pr) || (3 <= pr));\n        mhd_assert ((0 == pr) || (' ' == str[pr - 1]));\n        mhd_assert ((0 == pr) || (',' == str[pr - 2]));\n      } while (1);\n    }\n  }\n\n  return token_removed;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe mhd_assert(0 != tkn_len); is a pure diagnostic check with no side-effects: it only validates an invariant and does not change program state. In normal (correct) operation tkn_len is always non-zero, so the assertion merely evaluates a condition and (if assertions are enabled) may abort on failure \u2014 otherwise it is effectively a no-op. Removing this statement would not affect the program\u2019s functional behaviour when the invariant holds, so it constitutes dead code and therefore violates Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=6 tkn_preview='string'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=6 tkn_preview='string'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=6 tkn_preview='String'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=6 tkn_preview='String'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=7\ntoken_parse: pt=7 tokens_len=7 tkn_len=6 str_len=6 tkn_preview='String'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=6 tokens=0x7ffdafa061a0 tokens_len=7\ntoken_parse: pt=7 tokens_len=7 tkn_len=6 str_len=6 tkn_preview='String'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: exact_match_removed str_len_set_to_0 token_len=6\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=5 tokens=0x7ffdafa061a0 tokens_len=10\ntoken_parse: pt=10 tokens_len=10 tkn_len=5 str_len=5 tkn_preview='toKEN'\nassert_check_before: (0 != tkn_len) -> tkn_len=5\nassert_ok: tkn_len_nonzero=5\naction: exact_match_removed str_len_set_to_0 token_len=5\nexit: token_removed=1 final_str_len=0\nenter: str=0x7ffdafa062a0 str_len=16 tokens=0x7ffdafa061a0 tokens_len=5\ntoken_parse: pt=5 tokens_len=5 tkn_len=5 str_len=16 tkn_preview='token'\nassert_check_before: (0 != tkn_len) -> tkn_len=5\nassert_ok: tkn_len_nonzero=5\naction: token_matched_and_skipped pr=11 pw=9 tkn_len=5\naction: finished_partial_copy final_str_len=9\nexit: token_removed=1 final_str_len=9\nenter: str=0x7ffdafa062a0 str_len=25 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=25 tkn_preview='token1'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: token_matched_and_skipped pr=12 pw=10 tkn_len=6\naction: finished_partial_copy final_str_len=17\nexit: token_removed=1 final_str_len=17\nenter: str=0x7ffdafa062a0 str_len=13 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=6 str_len=13 tkn_preview='token1'\nassert_check_before: (0 != tkn_len) -> tkn_len=6\nassert_ok: tkn_len_nonzero=6\naction: token_matched_and_skipped pr=7 pw=5 tkn_len=6\naction: finished_partial_copy final_str_len=5\nexit: token_removed=1 final_str_len=5\nenter: str=0x7ffdafa062a0 str_len=16 tokens=0x7ffdafa061a0 tokens_len=8\ntoken_parse: pt=8 tokens_len=8 tkn_len=5 str_len=16 tkn_preview='toKEN'\nassert_check_before: (0 != tkn_len) -> tkn_len=5\nassert_ok: tkn_len_nonzero=5\naction: token_matched_and_skipped pr=11 pw=9 tkn_len=5\naction: finished_partial_copy final_str_len=9\nexit: token_removed=1 final_str_len=9\nenter: str=0x7ffdafa062a0 str_len=28 tokens=0x7ffdafa061a0 tokens_len=6\ntoken_parse: pt=6 tokens_len=6 tkn_len=5 str_len=28 tkn_preview='toKEN'\nassert_check_before: (0 != tkn_len) -> tkn_len=5\nassert_ok: tkn_len_nonzero=5\naction: token_matched_and_skipped pr=11 pw=9 tkn_len=5\naction: finished_partial_copy final_str_len=21\nexit: token_removed=1 final_str_len=21\nenter: str=0x7ffdafa062a0 str_len=28 tokens=0x7ffdafa061a0 tokens_len=1\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s characterization is not correct. MISRA Rule 2.2 forbids dead code \u2014 operations that are executed but whose removal would not affect program behaviour. The single mhd_assert(0 != tkn_len); is a run\u2011time diagnostic that enforces an invariant; although in normal, correct operation the condition will be true and the assertion will have no effect, the assertion can change program behaviour when the invariant is violated (for example by logging or aborting). In other words the assertion is not purely inert in all configurations: it is intended to detect and react to errors and thus can affect behaviour. Moreover mhd_assert is a macro whose expansion may produce side effects (error reporting, abort) in some builds and be omitted in others; that potential effect is exactly why such checks are used and why they are not simply \u201cdead code\u201d under MISRA 2.2. For those reasons the report that this statement violates Rule 2.2 is not correct."
}