{
  "user_message": "An agent A claimed that the following digest_get_size code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of digest_get_size.\n```c\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\ndigest_get_size takes a non-const pointer (struct DigestAlgorithm *da) but only reads members (da->uninitialised, da->algo_selected, da->algo). According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified whenever possible. The signature should be: _MHD_static_inline unsigned int digest_get_size (const struct DigestAlgorithm *da);\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7eef0\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=branch_md5, da=0x7fffa8a7ef80\n  algo=1\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7eea0\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=branch_sha256, da=0x7fffa8a7ef80\n  algo=2\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=branch_sha512_256, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=branch_sha512_256, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=branch_sha512_256, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=entry, da=0x7fffa8a7eea0\n  algo=4\n[digest_get_size] stage=after_asserts, da=0x7fffa8a7eea0\n  algo\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The function digest_get_size only reads members of the pointed-to object (da->uninitialised, da->algo_selected, da->algo) and performs no modifications. Per MISRA C 2023 Rule 8.13 a pointer parameter that is only used for read access should be const-qualified; therefore the parameter could and should be declared as const struct DigestAlgorithm *da. The only plausible reasons this would not be a violation are external constraints not visible here (e.g. the function must match an existing non-const API or function-pointer type, or a macro used in the asserts requires a non-const type). Absent such constraints, Agent A's report is correct."
}