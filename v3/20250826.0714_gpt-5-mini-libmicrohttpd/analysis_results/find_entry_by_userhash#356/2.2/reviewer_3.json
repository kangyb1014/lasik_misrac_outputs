{
  "user_message": "An agent A claimed that the following find_entry_by_userhash code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userhash.\n```c\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe leading check if (MHD_digest_get_hash_size(algo3) != userhash_size) return NULL; already guarantees that userhash_size equals the algorithm's expected digest size for the selected algo3. If MHD_digest_get_hash_size(algo3) is guaranteed to match the compile-time size of user_ids[0].userhash_sha256, then the subsequent runtime check if (sizeof(user_ids[0].userhash_sha256) != userhash_size) is always false and its body (return NULL) will never affect program behaviour. That makes the check an executed but redundant operation (dead code) and thus violates MISRA C 2023 Rule 2.2. (If, however, the digest size and the sizeof(...) can legitimately differ across builds/definitions, the check would be meaningful; based on the code/comments it is redundant.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reporter\u2019s claim depends on an unproven, project\u2011wide invariant: that MHD_digest_get_hash_size(algo3) will always equal the corresponding sizeof(user_ids[0].userhash_...) for every build and every value of algo3. That invariant is not established by the snippet, so you cannot conclude the following checks are dead. Practical points:\n\n- MISRA Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. The additional sizeof checks are executed (the comparison runs) and could affect behaviour (they can return NULL) if the digest size and the storage size ever diverge. Removing them could therefore change behaviour in configurations where those sizes differ.\n\n- If, in the current build/configuration, the checks always evaluate false, then the return branch would never be taken; that is an instance of unreachable behavior for that configuration. Note 2 to Rule 2.2 explicitly distinguishes unreachable code (cannot be executed) from dead code (executed but redundant). You would need a project\u2011wide proof that the comparison is always false to claim a Rule 2.2 violation. Such a proof is outside the provided fragment.\n\n- The code comments suggest the checks are defensive (\"Extra check\") and the extra enum cases are present to silence compiler warnings or to be future\u2011proof. Defensive checks that are potentially meaningful in other builds or future changes are a legitimate reason to keep them; if a project does prove they are redundant, the appropriate action is to remove them or document/justify them as required by MISRA.\n\nConclusion: given only the shown code, the agent\u2019s assertion that these checks constitute dead code (and thus violate MISRA C:2023 Rule 2.2) is not justified. To prove a violation you would need project\u2011wide evidence that the comparisons are provably redundant in all builds; without that, the report is not correct."
}