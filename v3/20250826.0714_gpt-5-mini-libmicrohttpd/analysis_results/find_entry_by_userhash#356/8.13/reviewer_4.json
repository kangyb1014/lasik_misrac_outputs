{
  "user_message": "An agent A claimed that the following find_entry_by_userhash code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userhash.\n```c\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'entry' is declared as 'struct UserEntry *entry' and is assigned 'user_ids + i'. The function only reads fields from the array (memcmp) and never modifies them, so the pointer should point to a const-qualified type (const struct UserEntry *). As written this either discards constness (if user_ids is declared const) or fails to qualify the pointer as const when it could be, so the assignment 'entry = user_ids + i;' violates MISRA C 2023 Rule 8.13. A fix is to declare the pointer as 'const struct UserEntry *entry' (and adjust the function return type to a const pointer if appropriate).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. MISRA C 2023 Rule 8.13 indeed encourages pointers to be const-qualified where possible, but whether that applies here depends on the surrounding declarations and the API intent. In the provided code: - The function signature returns a non-const pointer (struct UserEntry *). That alone prevents making the local variable entry a const-qualified pointer without changing the API (returning const struct UserEntry * as well). Declaring entry as const struct UserEntry * and then returning it as a non-const struct UserEntry * would require casting away const, which is not acceptable. - The snippet does not show the declaration of user_ids. If user_ids is a non-const array of struct UserEntry, then entry having type struct UserEntry * is consistent and not a violation of 8.13. If user_ids were declared const, then the assignment user_ids + i to a non-const pointer would be a qualifier-discard (a different issue), but that situation is not proven by the snippet. In short: you cannot conclude a Rule 8.13 violation from the shown code alone. To comply with 8.13 you either change the API to return const struct UserEntry * (and make entry const) if the data are immutable, or keep the current non-const types if modification is intended. Thus the agent A\u2019s claim is not justified on the provided code."
}