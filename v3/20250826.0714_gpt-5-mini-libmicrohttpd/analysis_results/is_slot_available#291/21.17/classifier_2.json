{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of is_slot_available:\n```c\nstatic bool\nis_slot_available (const struct MHD_NonceNc *const nn,\n                   const uint64_t now,\n                   const char *const new_nonce,\n                   size_t new_nonce_len)\n{\n  uint64_t timestamp;\n  bool timestamp_valid;\n  mhd_assert (new_nonce_len <= NONCE_STD_LEN (MAX_DIGEST));\n  mhd_assert (NONCE_STD_LEN (MAX_DIGEST) <= MAX_DIGEST_NONCE_LENGTH);\n  if (0 == nn->nonce[0])\n    return true; /* The slot is empty */\n\n  if (0 == memcmp (nn->nonce, new_nonce, new_nonce_len))\n  {\n    /* The slot has the same nonce already. This nonce cannot be registered\n     * again as it would just clear 'nc' usage history. */\n    return false;\n  }\n\n  if (0 != nn->nc)\n    return true; /* Client already used the nonce in this slot at least\n                    one time, re-use the slot */\n\n  /* The nonce must be zero-terminated */\n  mhd_assert (0 == nn->nonce[sizeof(nn->nonce) - 1]);\n  if (0 != nn->nonce[sizeof(nn->nonce) - 1])\n    return true; /* Wrong nonce format in the slot */\n\n  timestamp_valid = get_nonce_timestamp (nn->nonce, 0, &timestamp);\n  mhd_assert (timestamp_valid);\n  if (! timestamp_valid)\n    return true; /* Invalid timestamp in nonce-nc, should not be possible */\n\n  if ((REUSE_TIMEOUT * 1000) < TRIM_TO_TIMESTAMP (now - timestamp))\n    return true;\n\n  return false;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n    /* The slot has the same nonce already. This nonce cannot be registered\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call memcmp(nn->nonce, new_nonce, new_nonce_len) will read new_nonce_len bytes from both nn->nonce and new_nonce. If new_nonce_len were greater than the size of nn->nonce or if new_nonce did not point to at least new_nonce_len bytes, memcmp would read beyond object bounds and violate Rule 21.17. In the shown function there are mhd_asserts: new_nonce_len <= NONCE_STD_LEN(MAX_DIGEST) and NONCE_STD_LEN(MAX_DIGEST) <= MAX_DIGEST_NONCE_LENGTH, and the code indexes nn->nonce[sizeof(nn->nonce)-1] (implying nn->nonce has size MAX_DIGEST_NONCE_LENGTH and is NUL-terminated). Given those invariants and assuming callers supply a new_nonce buffer at least new_nonce_len bytes long, the memcmp usage here does not violate Rule 21.17. Conversely, if those invariants or the caller contract are not met (new_nonce_len too large or new_nonce buffer too short), a violation would occur."
}