{
  "user_message": "An agent A claimed that the following try_match_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of try_match_header.\n```c\nstatic int\ntry_match_header (const char *prefix,\n                  size_t prefix_len,\n                  char *line,\n                  char **suffix)\n{\n  if (NULL != *suffix)\n    return MHD_NO;\n  while (0 != *line)\n  {\n    if (MHD_str_equal_caseless_n_ (prefix,\n                                   line,\n                                   prefix_len))\n    {\n      *suffix = strdup (&line[prefix_len]);\n      return MHD_YES;\n    }\n    ++line;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'line' is declared as 'char *line' but is only read (the code advances the pointer with '++line;' and never modifies the characters it points to). According to MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible. Here 'line' could and should be 'const char *line', so the current code violates the rule. A fix is to change the function signature to use 'const char *line'.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ntry_match_header entry: prefix=0x7f54bff27ea9 prefix_len=14 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=1\nmatch found: suffix=0x55609c78def0 value=\"text/plain\"\nreturning MHD_YES\ntry_match_header entry: prefix=0x7f54bff27eb8 prefix_len=27 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=0\nloop iter: line=0x55609c78d8c1 char='\\x6f' (o) eq=0\nloop iter: line=0x55609c78d8c2 char='\\x6e' (n) eq=0\nloop iter: line=0x55609c78d8c3 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8c4 char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8c5 char='\\x6e' (n) eq=0\nloop iter: line=0x55609c78d8c6 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8c7 char='\\x2d' (-) eq=0\nloop iter: line=0x55609c78d8c8 char='\\x54' (T) eq=0\nloop iter: line=0x55609c78d8c9 char='\\x79' (y) eq=0\nloop iter: line=0x55609c78d8ca char='\\x70' (p) eq=0\nloop iter: line=0x55609c78d8cb char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8cc char='\\x3a' (:) eq=0\nloop iter: line=0x55609c78d8cd char='\\x20' ( ) eq=0\nloop iter: line=0x55609c78d8ce char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8cf char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8d0 char='\\x78' (x) eq=0\nloop iter: line=0x55609c78d8d1 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8d2 char='\\x2f' (/) eq=0\nloop iter: line=0x55609c78d8d3 char='\\x70' (p) eq=0\nloop iter: line=0x55609c78d8d4 char='\\x6c' (l) eq=0\nloop iter: line=0x55609c78d8d5 char='\\x61' (a) eq=0\nloop iter: line=0x55609c78d8d6 char='\\x69' (i) eq=0\nloop iter: line=0x55609c78d8d7 char='\\x6e' (n) eq=0\nno match found: returning MHD_NO\ntry_match_header entry: prefix=0x7f54bff27ea9 prefix_len=14 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=0x55609c78def0\nearly return: suffix already set (suffix=0x55609c78def0)\ntry_match_header entry: prefix=0x7f54bff27eb8 prefix_len=27 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=1\nmatch found: suffix=0x55609c78df10 value=\"binary\"\nreturning MHD_YES\ntry_match_header entry: prefix=0x7f54bff27ea9 prefix_len=14 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=1\nmatch found: suffix=0x55609c78def0 value=\"text/plain\"\nreturning MHD_YES\ntry_match_header entry: prefix=0x7f54bff27eb8 prefix_len=27 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=0\nloop iter: line=0x55609c78d8c1 char='\\x6f' (o) eq=0\nloop iter: line=0x55609c78d8c2 char='\\x6e' (n) eq=0\nloop iter: line=0x55609c78d8c3 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8c4 char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8c5 char='\\x6e' (n) eq=0\nloop iter: line=0x55609c78d8c6 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8c7 char='\\x2d' (-) eq=0\nloop iter: line=0x55609c78d8c8 char='\\x54' (T) eq=0\nloop iter: line=0x55609c78d8c9 char='\\x79' (y) eq=0\nloop iter: line=0x55609c78d8ca char='\\x70' (p) eq=0\nloop iter: line=0x55609c78d8cb char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8cc char='\\x3a' (:) eq=0\nloop iter: line=0x55609c78d8cd char='\\x20' ( ) eq=0\nloop iter: line=0x55609c78d8ce char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8cf char='\\x65' (e) eq=0\nloop iter: line=0x55609c78d8d0 char='\\x78' (x) eq=0\nloop iter: line=0x55609c78d8d1 char='\\x74' (t) eq=0\nloop iter: line=0x55609c78d8d2 char='\\x2f' (/) eq=0\nloop iter: line=0x55609c78d8d3 char='\\x70' (p) eq=0\nloop iter: line=0x55609c78d8d4 char='\\x6c' (l) eq=0\nloop iter: line=0x55609c78d8d5 char='\\x61' (a) eq=0\nloop iter: line=0x55609c78d8d6 char='\\x69' (i) eq=0\nloop iter: line=0x55609c78d8d7 char='\\x6e' (n) eq=0\nno match found: returning MHD_NO\ntry_match_header entry: prefix=0x7f54bff27ea9 prefix_len=14 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=0x55609c78def0\nearly return: suffix already set (suffix=0x55609c78def0)\ntry_match_header entry: prefix=0x7f54bff27eb8 prefix_len=27 line=0x55609c78d8c0 suffix_ptr=0x7ffd9b83ef78 suffix_val=(nil)\nloop iter: line=0x55609c78d8c0 char='\\x43' (C) eq=\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function never modifies the characters pointed to by line \u2014 it only reads *line and advances the pointer (++line) \u2014 so the pointee type can and should be const-qualified. MISRA C 2023 Rule 8.13 therefore applies: line should be declared const char *line. Changing the signature to use const char *line is safe here (pointer arithmetic and passing &line[prefix_len] to strdup, which accepts a const char *, are both valid). Note: if the function signature is part of a public API and cannot be changed for compatibility reasons, that could be a justification for an exemption; otherwise update the signature to const char *line."
}