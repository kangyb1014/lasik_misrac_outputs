{
  "user_message": "An agent A claimed that the following try_match_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of try_match_header.\n```c\nstatic int\ntry_match_header (const char *prefix,\n                  size_t prefix_len,\n                  char *line,\n                  char **suffix)\n{\n  if (NULL != *suffix)\n    return MHD_NO;\n  while (0 != *line)\n  {\n    if (MHD_str_equal_caseless_n_ (prefix,\n                                   line,\n                                   prefix_len))\n    {\n      *suffix = strdup (&line[prefix_len]);\n      return MHD_YES;\n    }\n    ++line;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'line' is declared as 'char *' but is only read (not modified) and the call uses &line[prefix_len] as the source string for strdup. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type when possible. Here 'line' could and should be declared as 'const char *line', and the call would then pass a 'const char *' to strdup. As written, the non-const 'char *line' violates Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ntry_match_header ENTRY: prefix=0x7fe72d4f4ea9, prefix_len=14, line=0x557eb61e48c0, suffix=0x557eb61e4858\ntry_match_header: prefix content (up to 64 chars)='Content-type: '\ntry_match_header: *suffix (before) = (nil)\ntry_match_header: loop pos=0, line_ptr=0x557eb61e48c0, current_char='C', preview='Content-Type: text/plain'\ntry_match_header: prefix matched at pos=0; calling strdup on &line[14] (addr=0x557eb61e48ce)\ntry_match_header: strdup returned 0x557eb61e4ef0 for *suffix\ntry_match_header: returning MHD_YES\ntry_match_header ENTRY: prefix=0x7fe72d4f4eb8, prefix_len=27, line=0x557eb61e48c0, suffix=0x557eb61e4868\ntry_match_header: prefix content (up to 64 chars)='Content-Transfer-Encoding: '\ntry_match_header: *suffix (before) = (nil)\ntry_match_header: loop pos=0, line_ptr=0x557eb61e48c0, current_char='C', preview='Content-Type: text/plain'\ntry_match_header: loop pos=1, line_ptr=0x557eb61e48c1, current_char='o', preview='ontent-Type: text/plain'\ntry_match_header: loop pos=2, line_ptr=0x557eb61e48c2, current_char='n', preview='ntent-Type: text/plain'\ntry_match_header: loop pos=3, line_ptr=0x557eb61e48c3, current_char='t', preview='tent-Type: text/plain'\ntry_match_header: loop pos=4, line_ptr=0x557eb61e48c4, current_char='e', preview='ent-Type: text/plain'\ntry_match_header: loop pos=5, line_ptr=0x557eb61e48c5, current_char='n', preview='nt-Type: text/plain'\ntry_match_header: loop pos=6, line_ptr=0x557eb61e48c6, current_char='t', preview='t-Type: text/plain'\ntry_match_header: loop pos=7, line_ptr=0x557eb61e48c7, current_char='-', preview='-Type: text/plain'\ntry_match_header: loop pos=8, line_ptr=0x557eb61e48c8, current_char='T', preview='Type: text/plain'\ntry_match_header: loop pos=9, line_ptr=0x557eb61e48c9, current_char='y', preview='ype: text/plain'\ntry_match_header: loop pos=10, line_ptr=0x557eb61e48ca, current_char='p', preview='pe: text/plain'\ntry_match_header: loop pos=11, line_ptr=0x557eb61e48cb, current_char='e', preview='e: text/plain'\ntry_match_header: loop pos=12, line_ptr=0x557eb61e48cc, current_char=':', preview=': text/plain'\ntry_match_header: loop pos=13, line_ptr=0x557eb61e48cd, current_char=' ', preview=' text/plain'\ntry_match_header: loop pos=14, line_ptr=0x557eb61e48ce, current_char='t', preview='text/plain'\ntry_match_header: loop pos=15, line_ptr=0x557eb61e48cf, current_char='e', preview='ext/plain'\ntry_match_header: loop pos=16, line_ptr=0x557eb61e48d0, current_char='x', preview='xt/plain'\ntry_match_header: loop pos=17, line_ptr=0x557eb61e48d1, current_char='t', preview='t/plain'\ntry_match_header: loop pos=18, line_ptr=0x557eb61e48d2, current_char='/', preview='/plain'\ntry_match_header: loop pos=19, line_ptr=0x557eb61e48d3, current_char='p', preview='plain'\ntry_match_header: loop pos=20, line_ptr=0x557eb61e48d4, current_char='l', preview='lain'\ntry_match_header: loop pos=21, line_ptr=0x557eb61e48d5, current_char='a', preview='ain'\ntry_match_header: loop pos=22, line_ptr=0x557eb61e48d6, current_char='i', preview='in'\ntry_match_header: loop pos=23, line_ptr=0x557eb61e48d7, current_char='n', preview='n'\ntry_match_header: reached end of line without match; returning MHD_NO\ntry_match_header ENTRY: prefix=0x7fe72d4f4ea9, prefix_len=14, line=0x557eb61e48c0, suffix=0x557eb61e4858\ntry_match_header: prefix content (up to 64 chars)='Content-type: '\ntry_match_header: *suffix (before) = 0x557eb61e4ef0\ntry_match_header: early return because *suffix != NULL (0x557eb61e4ef0)\ntry_match_header ENTRY: prefix=0x7fe72d4f4eb8, prefix_len=27, line=0x557eb61e48c0, suffix=0x557eb61e4868\ntry_match_header: prefix content (up to 64 chars)='Content-Transfer-Encoding: '\ntry_match_header: *suffix (before) = (nil)\ntry_match_header: loop pos=0, line_ptr=0x557eb61e48c0, current_char='C', preview='Content-Transfer-Encoding: binary'\ntry_match_header: prefix matched at pos=0; calling strdup on &line[27] (addr=0x557eb61e48db)\ntry_match_header: strdup returned 0x557eb61e4f10 for *suffix\ntry_match_header: returning MHD_YES\ntry_match_header ENTRY: prefix=0x7fe72d4f4ea9, prefix_len=14, line=0x557eb61e48c0, suffix=0x557eb61e4858\ntry_match_header: p\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function never modifies the characters pointed to by the parameter line \u2014 it only reads *line and increments the pointer variable. According to MISRA C 2023 Rule 8.13, a pointer should point to a const-qualified type whenever possible; here the pointed-to characters can and should be const-qualified. Declaring the parameter as const char *line would satisfy the rule and is compatible with the uses inside the function (the pointer itself may still be incremented, and &line[prefix_len] yields a const char * which can be passed to strdup, whose prototype is char *strdup(const char *)). There is no compelling reason in the shown code to keep line as char *, so the original code violates Rule 8.13."
}