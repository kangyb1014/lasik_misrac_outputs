{
  "user_message": "An agent A claimed that the following MHD_run_wait code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run_wait.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run_wait (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  enum MHD_Result res;\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n\n  if (0 > millisec)\n    millisec = -1;\n#ifdef HAVE_POLL\n  if (MHD_D_IS_USING_POLL_ (daemon))\n  {\n    res = MHD_poll_all (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    res = MHD_epoll (daemon, millisec);\n    MHD_cleanup_connections (daemon);\n  }\n  else\n#endif\n  if (1)\n  {\n    mhd_assert (MHD_D_IS_USING_SELECT_ (daemon));\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n#ifdef HAVE_MESSAGES\n    if (daemon->fdset_size_set_by_app\n        && (((int) FD_SETSIZE) < daemon->fdset_size))\n    {\n      MHD_DLOG (daemon,\n                _ (\"MHD_run()/MHD_run_wait() called for daemon started with \" \\\n                   \"MHD_OPTION_APP_FD_SETSIZE option (%d). \" \\\n                   \"The library was compiled with smaller FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_run_from_select2() instead of MHD_run() or \" \\\n                   \"do not use MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                daemon->fdset_size, (int) FD_SETSIZE);\n    }\n#endif /* HAVE_MESSAGES */\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n    res = MHD_select (daemon, millisec);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return res;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe 'if (1)' conditional is a constant-true test. The evaluation of that conditional (the runtime check/branch) is executed but removing the if and leaving the block would not change program behaviour, so the conditional is redundant and constitutes dead code.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[1756196174] MHD_select returned: 1\n[1756196174] returning res=1 from MHD_run_wait\n[1756196174] enter: daemon=0x560bf399cde0 shutdown=0 tid=0x560bf399cf38 using_threads=0 millisec=0\n[1756196174] enter: using_poll=0\n[1756196174] enter: using_epoll=0\n[1756196174] enter: using_select=1\n[1756196174] early_return_condition: shutdown=0 using_threads=0 => early_return=0\n[1756196174] after_normalize_millisec: millisec=0\n[1756196174] entered constant-true branch: if (1) -> select path executed\n[1756196174] calling MHD_select\n[17\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The if (1) test is a constant-true runtime operation that is executed in normal builds. According to MISRA C 2023 Rule 2.2, any operation that is executed but whose removal would not affect program behaviour is dead code. Removing the if and leaving the block body would not change the behaviour in the build shown, so the conditional test itself qualifies as dead code. (I acknowledge the idiom is commonly used to form an else-chain across #ifdef blocks \u2014 which is a valid engineering reason \u2014 but that does not change the fact that the compiled code contains an executed, redundant test; thus the project contains dead code and a formal deviation/justification is required.)"
}