{
  "user_message": "An agent A claimed that the following MHD_strx_to_uint64_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_strx_to_uint64_.\n```c\nsize_t\nMHD_strx_to_uint64_ (const char *str,\n                     uint64_t *out_val)\n{\n  const char *const start = str;\n  uint64_t res;\n  int digit;\n  if (! str || ! out_val)\n    return 0;\n\n  res = 0;\n  digit = toxdigitvalue (*str);\n  while (digit >= 0)\n  {\n    if ( (res < (UINT64_MAX / 16)) ||\n         ((res == (UINT64_MAX / 16)) &&\n          ( (uint64_t) digit <= (UINT64_MAX % 16)) ) )\n    {\n      res *= 16;\n      res += (unsigned int) digit;\n    }\n    else\n      return 0;\n    str++;\n    digit = toxdigitvalue (*str);\n  }\n\n  if (str - start > 0)\n    *out_val = res;\n  return (size_t) (str - start);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function increments the pointer parameter 'str' (str++ and str = start comparisons). Modifying the pointer parameter itself violates MISRA C 2023 Rule 17.8. A local pointer copy (e.g. const char *p = str) or declaring the parameter as const char * const str would avoid the violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_strx_to_uint64_: entry start=0x56081b5b16dc str=0x56081b5b16dc out_val=0x7fff90eadff8\nMHD_strx_to_uint64_: initial char='\nMHD_strx_to_uint64_: loop iter=0 str=0x56081b5b16dc char='\nMHD_strx_to_uint64_: safe to accumulate (res=0)\nMHD_strx_to_uint64_: after accumulate res=1\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b16dd (start=0x56081b5b16dc) diff=1\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: parsed length=1 res=1 assigned to out_val\nMHD_strx_to_uint64_: exit returning length=1\nMHD_strx_to_uint64_: entry start=0x56081b5b67e5 str=0x56081b5b67e5 out_val=0x7fff90eadff8\nMHD_strx_to_uint64_: initial char='\nMHD_strx_to_uint64_: loop iter=0 str=0x56081b5b67e5 char='\nMHD_strx_to_uint64_: safe to accumulate (res=0)\nMHD_strx_to_uint64_: after accumulate res=0\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b67e6 (start=0x56081b5b67e5) diff=1\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: parsed length=1 res=0 assigned to out_val\nMHD_strx_to_uint64_: exit returning length=1\nMHD_strx_to_uint64_: entry start=0x56081b5b156b str=0x56081b5b156b out_val=0x7fff90eadff8\nMHD_strx_to_uint64_: initial char='\nMHD_strx_to_uint64_: loop iter=0 str=0x56081b5b156b char='\nMHD_strx_to_uint64_: safe to accumulate (res=0)\nMHD_strx_to_uint64_: after accumulate res=1\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b156c (start=0x56081b5b156b) diff=1\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=1 str=0x56081b5b156c char='\nMHD_strx_to_uint64_: safe to accumulate (res=1)\nMHD_strx_to_uint64_: after accumulate res=16\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b156d (start=0x56081b5b156b) diff=2\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=2 str=0x56081b5b156d char='\nMHD_strx_to_uint64_: safe to accumulate (res=16)\nMHD_strx_to_uint64_: after accumulate res=256\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b156e (start=0x56081b5b156b) diff=3\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=3 str=0x56081b5b156e char='\nMHD_strx_to_uint64_: safe to accumulate (res=256)\nMHD_strx_to_uint64_: after accumulate res=4096\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b156f (start=0x56081b5b156b) diff=4\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=4 str=0x56081b5b156f char='\nMHD_strx_to_uint64_: safe to accumulate (res=4096)\nMHD_strx_to_uint64_: after accumulate res=65536\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b1570 (start=0x56081b5b156b) diff=5\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: parsed length=5 res=65536 assigned to out_val\nMHD_strx_to_uint64_: exit returning length=5\nMHD_strx_to_uint64_: entry start=0x56081b5b1571 str=0x56081b5b1571 out_val=0x7fff90eadff8\nMHD_strx_to_uint64_: initial char='\nMHD_strx_to_uint64_: loop iter=0 str=0x56081b5b1571 char='\nMHD_strx_to_uint64_: safe to accumulate (res=0)\nMHD_strx_to_uint64_: after accumulate res=1\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b1572 (start=0x56081b5b1571) diff=1\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=1 str=0x56081b5b1572 char='\nMHD_strx_to_uint64_: safe to accumulate (res=1)\nMHD_strx_to_uint64_: after accumulate res=18\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b1573 (start=0x56081b5b1571) diff=2\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=2 str=0x56081b5b1573 char='\nMHD_strx_to_uint64_: safe to accumulate (res=18)\nMHD_strx_to_uint64_: after accumulate res=291\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b1574 (start=0x56081b5b1571) diff=3\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: loop iter=3 str=0x56081b5b1574 char='\nMHD_strx_to_uint64_: safe to accumulate (res=291)\nMHD_strx_to_uint64_: after accumulate res=4660\nMHD_strx_to_uint64_: advanced str -> 0x56081b5b1575 (start=0x56081b5b1571) diff=4\nMHD_strx_to_uint64_: next char='\nMHD_strx_to_uint64_: parsed length=4 res=4660 assigned to out_val\nMHD_strx_to_uint64_: exit returning length=4\nMHD_strx_to_uint64_: entry start=0x56081b5b1576 str=0x56081b5b1576 out_val=0x7fff90eadff8\nMHD_strx_to_uint64_: initial char='\nMHD_strx_to_uint64_: loop iter=0 str=0x56081b5b1576 char='\nMHD_strx_to_uint6\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified; while the object addressed by a pointer parameter may be modified, the pointer parameter itself must not be changed. In this function the parameter str is incremented (str++), i.e. the pointer parameter is modified, so the code violates Rule 17.8. (Writing through out_val via *out_val is allowed because that modifies the object pointed to, not the pointer parameter.)\n\nFixes: use a local pointer copy (e.g. const char *p = str; and advance p), or change the function prototype to take a const pointer-to-const (const char * const str) if the API permits \u2014 the local-copy approach is usually preferred to avoid changing the API.)"
}