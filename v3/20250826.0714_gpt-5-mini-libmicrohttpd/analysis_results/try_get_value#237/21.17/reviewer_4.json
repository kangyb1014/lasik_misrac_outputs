{
  "user_message": "An agent A claimed that the following try_get_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of try_get_value.\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf buf (or the substring starting at bpos) is not a NUL-terminated C string (for example, data read into a buffer of known length but not terminated), calling strstr(bpos, key) may scan past the allocated object searching for the terminator or the needle and thus access memory beyond the bounds. Similarly, if key is not NUL-terminated, strstr may read beyond its bounds. In such cases this use of strstr violates Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct that the code can violate MISRA C 2023 Rule 21.17. The function calls from <string.h> in try_get_value (strlen(key), strstr(bpos, key), strchr(&spos[klen + 2], '\"') and the subsequent memcpy) all assume that the char buffers they scan are NUL-terminated and that the search will terminate inside the bounds of the referenced objects. The implementation contains no checks or guarantees that buf (or the substring at bpos) or key are NUL-terminated or that the strings are bounded; if either is not NUL-terminated (for example when operating on a raw buffer with a known length but no terminator), these calls may read past the objects\u2019 bounds and thus violate Rule 21.17.\n\nNote: if the function\u2019s contract (precondition) explicitly and verifiably guarantees that buf and key always point to valid NUL-terminated C strings (and that any matching end-quote lies within the same object), then the use would be acceptable. Absent such a documented and enforced contract, the code is noncompliant. Recommended fixes include passing explicit lengths or using bounded/string-length-limited APIs and validating termination before calling the unbounded string functions."
}