{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n(0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len))\n```\nFocus on the above code fragment and judge whether it violates the rule 21.14 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The code checks (NULL == auth_info->password) and that auth_info->password_len == strlen(\"open sesame\") before calling memcmp with that explicit length. memcmp is therefore being used to compare two fixed-length memory sequences (the password buffer and the first auth_info->password_len bytes of the literal), not to compare null\u2011terminated strings; thus Rule 21.14 is not violated."
}