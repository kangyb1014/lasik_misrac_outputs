{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void **req_cls)\n{\n  static int aptr;\n  struct ResponseContentCallbackParam *callback_param;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n\n  callback_param = malloc (sizeof(struct ResponseContentCallbackParam));\n  if (NULL == callback_param)\n    return MHD_NO; /* Not enough memory. */\n\n  callback_param->response_data = simple_response_text;\n  callback_param->response_size = (sizeof(simple_response_text)\n                                   / sizeof(char)) - 1;\n\n  *req_cls = NULL;                  /* reset when done */\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                1024,\n                                                &callback,\n                                                callback_param,\n                                                &free_callback_param);\n  if (NULL == response)\n  {\n    free (callback_param);\n    return MHD_NO;\n  }\n  /* Enforce chunked response, even for non-keep-alive connection. */\n  if (MHD_NO == MHD_add_response_header (response,\n                                         MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                         \"chunked\"))\n  {\n    free (callback_param);\n    MHD_destroy_response (response);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code takes the address of a non-const object (static int aptr) and compares/stores it via a void* held in *req_cls. The address-of-aptr is used only as a sentinel and aptr is never modified, so the pointed-to object could be const-qualified (e.g. static const int aptr) or the pointer target type could be const (e.g. const void *). As written, a pointer is pointing to a non-const-qualified type where a const-qualified target would be possible, so Rule 8.13 is violated (or at least not respected). Note: if the API for req_cls (void **) cannot be changed, this may be an unavoidable deviation, but the code as shown does violate the guideline.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Rule 8.13 demands that pointers point to const-qualified types where possible. In this function the handler stores the address of a static object (aptr) in a void * (via the API parameter void **req_cls) and never modifies the object \u2014 i.e. the pointed\u2011to object could reasonably be const. As written the code uses a non-const pointer to refer to an object that could be const, so it does not meet the intent of Rule 8.13.\n\nThat said, this is a common interaction with a fixed external API: the function signature (void **req_cls) prevents using a const-qualified pointer type without changing the API (or using casts). If the API cannot be changed, this becomes an unavoidable and documentable deviation under MISRA. Possible remedies (if the API can be changed) are to use a const-qualified pointer (e.g. const void **) or declare aptr const; if the API cannot be changed, document the deviation and justify it (or use an alternative sentinel approach that does not require discarding const-qualification)."
}