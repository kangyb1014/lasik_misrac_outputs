{
  "user_message": "An agent A claimed that the following MHD_SHA256_update code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_update.\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen MHD_FAVOR_SMALL_CODE is not defined the earlier check \u2018if (0 == length) return;\u2019 guarantees that control reaches the later \u2018if (0 != length)\u2019 only when length is non\u2011zero, so the controlling expression is invariant (always true). This violates MISRA C 2023 Rule 14.3 (no applicable exceptions).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f101b length=3\nAfter count update: bytes_have=0 ctx->count=3\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 3 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=3 bytes_have=0 length=3\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f101f length=56\nAfter count update: bytes_have=0 ctx->count=56\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 56 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=56 bytes_have=0 length=56\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f2d09 length=0\nEarly return: length == 0 - no processing\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f1058 length=28\nAfter count update: bytes_have=0 ctx->count=28\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 28 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=28 bytes_have=0 length=28\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f1075 length=14\nAfter count update: bytes_have=0 ctx->count=14\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 14 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=14 bytes_have=0 length=14\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f1084 length=26\nAfter count update: bytes_have=0 ctx->count=26\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 26 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=26 bytes_have=0 length=26\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f10ed length=26\nAfter count update: bytes_have=0 ctx->count=26\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 26 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=26 bytes_have=0 length=26\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f109f length=104\nAfter count update: bytes_have=0 ctx->count=104\nbytes_have == 0 branch: no partial buffered data to combine\nLoop iteration 0: processing full block: data=0x55a7d53f109f length=104\nExited full-block loop after 1 iterations: remaining length=40\nFinal copy of remaining 40 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=104 bytes_have=0 length=40\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f1108 length=378\nAfter count update: bytes_have=0 ctx->count=378\nbytes_have == 0 branch: no partial buffered data to combine\nLoop iteration 0: processing full block: data=0x55a7d53f1108 length=378\nLoop iteration 1: processing full block: data=0x55a7d53f1148 length=314\nLoop iteration 2: processing full block: data=0x55a7d53f1188 length=250\nLoop iteration 3: processing full block: data=0x55a7d53f11c8 length=186\nLoop iteration 4: processing full block: data=0x55a7d53f1208 length=122\nExited full-block loop after 5 iterations: remaining length=58\nFinal copy of remaining 58 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=378 bytes_have=0 length=58\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f1380 length=26\nAfter count update: bytes_have=0 ctx->count=26\nbytes_have == 0 branch: no partial buffered data to combine\nSkipped full-block loop: no full blocks in input\nFinal copy of remaining 26 bytes into buffer at offset 0\nMHD_SHA256_update EXIT: final ctx->count=26 bytes_have=0 length=26\nMHD_SHA256_update ENTRY: ctx=0x7ffdfa44db30 data=0x55a7d53f15a8 length=72\nAfter count update: bytes_have=0 ctx->count=72\nbytes_have == 0 branch: no partial buffered data to combine\nLoop iteration 0: processing full block: data=0x55a7d53f15a8 length=72\nExited full-block loop after 1 iterations: remaining length=8\nFinal copy of remain\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is incorrect. The later controlling expression if (0 != length) is not invariant because the function modifies length before that check. After entry (and after the early-return that only skips the whole function when length==0), the code can subtract from length: in the bytes_have branch length -= bytes_left, and in the full-block loop length is reduced by SHA256_BLOCK_SIZE in each iteration (length -= SHA256_BLOCK_SIZE). For example, if length is an exact multiple of SHA256_BLOCK_SIZE the while loop will reduce length to 0 and the later if (0 != length) will be false. Thus the controlling expression can be either true or false at run time and is not invariant; no MISRA 14.3 violation occurs here."
}