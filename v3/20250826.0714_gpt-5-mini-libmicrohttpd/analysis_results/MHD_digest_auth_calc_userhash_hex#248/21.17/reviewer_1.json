{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userhash_hex code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userhash_hex.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash_hex (enum MHD_DigestAuthAlgo3 algo3,\n                                   const char *username,\n                                   const char *realm,\n                                   char *userhash_hex,\n                                   size_t hex_buf_size)\n{\n  uint8_t userhash_bin[MAX_DIGEST];\n  size_t digest_size;\n\n  digest_size = digest_get_hash_size (algo3);\n  if (digest_size * 2 + 1 > hex_buf_size)\n    return MHD_NO;\n  if (MHD_NO == MHD_digest_auth_calc_userhash (algo3, username, realm,\n                                               userhash_bin, MAX_DIGEST))\n    return MHD_NO;\n\n  MHD_bin_to_hex_z (userhash_bin, digest_size, userhash_hex);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe check uses digest_size * 2 + 1 without guarding against size_t overflow. If digest_size is large enough that (digest_size * 2 + 1) wraps around (i.e. digest_size > (SIZE_MAX - 1) / 2), the comparison can be bypassed and MHD_bin_to_hex_z(userhash_bin, digest_size, userhash_hex) may write 2*digest_size + 1 bytes into userhash_hex, overflowing it. Example on a 32-bit platform (SIZE_MAX = 4294967295): digest_size = 2147483648 -> digest_size*2 == 0 (wrap), +1 == 1, so the check (1 > hex_buf_size) is false even for small hex_buf_size; the subsequent call will attempt to produce 4294967297 bytes, causing out-of-bounds access.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. MISRA C 2023 Rule 21.17 specifically targets use of the standard <string.h> functions (memcpy, strcpy, strlen, etc.) that can access beyond object bounds. The shown function does not call any <string.h> routine directly; it calls MHD_bin_to_hex_z which is an internal/helper routine. If that helper itself uses <string.h> functions in a way that can access out of bounds because it was passed an undersized buffer, the violation would be located in the implementation/usage of that helper (or in the arithmetic/check that allowed a too-small buffer to be passed), not in this function under Rule 21.17 per se.\n\nThat said, the scenario correctly identifies a distinct problem: an unchecked size_t overflow in the expression digest_size * 2 + 1. If digest_size could be large enough to wrap, the capacity check can be bypassed and MHD_bin_to_hex_z may be asked to write more bytes than userhash_hex can hold, causing an out-of-bounds write. This is a genuine safety/robustness issue (integer overflow / bounds-checking), and should be fixed (for example by rearranging the test to avoid multiplication overflow: if (digest_size > (hex_buf_size - 1) / 2) return MHD_NO;). But that is a violation of integer/overflow/bounds-checking rules, not directly of MISRA Rule 21.17 as applied to this function.\n\nTherefore Agent A's claim that this function violates MISRA C 2023 Rule 21.17 is incorrect (false), although the code does have a separate potential integer overflow / buffer-overflow risk that should be fixed."
}