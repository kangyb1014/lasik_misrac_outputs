{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes pointers (username, realm, password) without validation and relies on the callee to respect the supplied destination size. If MHD_digest_auth_calc_userdigest internally calls string.h functions (e.g. strlen/strcpy/memcpy) on a NULL username/realm/password or writes more bytes than sizeof(entry->userdigest_sha512_256), an out\u2011of\u2011bounds access can occur. Example violating scenario: password is NULL (or the function computes a digest longer than the destination buffer and uses strcpy/memcpy without bounds checking), leading to dereference or buffer overflow inside the callee.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is speculative and not demonstrated by the shown code. MISRA C 2023 Rule 21.17 concerns uses of <string.h> functions that access beyond the bounds of the objects referenced by their pointer parameters. The function add_new_user_entry does not itself call any <string.h> functions; it merely forwards username, realm, password pointers and destination buffers plus their sizes to helper functions (MHD_digest_auth_calc_userhash / MHD_digest_auth_calc_userdigest). Whether Rule 21.17 is violated depends on the behavior (contract/implementation) of those helper functions: if they themselves call string.h functions unsafely (e.g. using strcpy/memcpy without bounds or dereferencing NULL pointers), the violation would be in those functions, not demonstrably in add_new_user_entry. Likewise, passing a NULL username/realm/password could lead to a problem only if the callee does not validate its inputs. The caller does provide the destination buffer sizes (sizeof(...)) which is the correct practice if the callee honours that parameter. Without evidence that the callee misuses string.h or that the caller is required (by documented contract) to validate the input pointers here, we cannot conclude a Rule 21.17 violation in add_new_user_entry. Recommendation: either document and rely on the callee\u2019s non-NULL and bounds-respecting contract or add input validation (non-NULL checks and/or length checks) before calling the digest functions to remove the ambiguity."
}