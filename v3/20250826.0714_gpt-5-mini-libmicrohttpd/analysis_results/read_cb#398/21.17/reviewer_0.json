{
  "user_message": "An agent A claimed that the following read_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of read_cb.\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\ncompress_buf takes &size and &buf and may modify them; the code then blindly does memcpy(mem, buf, size) without verifying that the resulting size does not exceed the capacity of mem or the allocated size of buf. For example, if the caller passed mem with capacity 1024 and initial size==1024 but compress_buf (by design or by bug) sets size to 2048 or returns a buf that was allocated with only 1024 bytes, the memcpy(mem, buf, size) will write beyond mem or read beyond buf. Because there is no check that the updated size fits the mem buffer or that buf actually contains at least size bytes, this can lead to out\u2011of\u2011bounds accesses and thus violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 21.17 prohibits calling string.h functions (like memcpy) in a way that can access beyond the bounds of the objects referenced by their pointer parameters. In the shown code memcpy(mem, buf, size) is called after compress_buf(&..., &buf, &size, ...), which is free to modify both buf and size. There is no check that the modified size is <= the original destination capacity (the caller-supplied mem buffer, whose capacity is the original size argument) or that buf actually points to an object at least size bytes long. Therefore memcpy may read beyond buf or write beyond mem, violating the rule. The only way this would not be a violation is if there is a provable, externally documented contract for compress_buf guaranteeing that it will never increase size beyond the original requested value and that buf will point to at least size bytes; no such guarantee is visible in the snippet. To comply, save the original requested size before the call and validate (e.g. size <= original_size and buf != NULL and buf allocation >= size) before memcpy (or constrain size to the original), or otherwise ensure the post-conditions of compress_buf are enforced and provable."
}