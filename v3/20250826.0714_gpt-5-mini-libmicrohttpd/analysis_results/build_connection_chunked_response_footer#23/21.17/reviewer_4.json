{
  "user_message": "An agent A claimed that the following build_connection_chunked_response_footer code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of build_connection_chunked_response_footer.\n```c\nstatic enum MHD_Result\nbuild_connection_chunked_response_footer (struct MHD_Connection *connection)\n{\n  char *buf;           /**< the buffer to write footers to */\n  size_t buf_size;     /**< the size of the @a buf */\n  size_t used_size;    /**< the used size of the @a buf */\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (connection->rp.props.chunked);\n  /* TODO: allow combining of the final footer with the last chunk,\n   * modify the next assert. */\n  mhd_assert (MHD_CONNECTION_CHUNKED_BODY_SENT == connection->state);\n  mhd_assert (NULL != c->rp.response);\n\n  buf_size = connection_maximize_write_buffer (c);\n  /* '5' is the minimal size of chunked footer (\"0\\r\\n\\r\\n\") */\n  if (buf_size < 5)\n    return MHD_NO;\n  mhd_assert (NULL != c->write_buffer);\n  buf = c->write_buffer + c->write_buffer_append_offset;\n  mhd_assert (NULL != buf);\n  used_size = 0;\n  buf[used_size++] = '0';\n  buf[used_size++] = '\\r';\n  buf[used_size++] = '\\n';\n\n  for (pos = c->rp.response->first_header; NULL != pos; pos = pos->next)\n  {\n    if (MHD_FOOTER_KIND == pos->kind)\n    {\n      size_t new_used_size; /* resulting size with this header */\n      /* '4' is colon, space, linefeeds */\n      new_used_size = used_size + pos->header_size + pos->value_size + 4;\n      if (new_used_size > buf_size)\n        return MHD_NO;\n      memcpy (buf + used_size, pos->header, pos->header_size);\n      used_size += pos->header_size;\n      buf[used_size++] = ':';\n      buf[used_size++] = ' ';\n      memcpy (buf + used_size, pos->value, pos->value_size);\n      used_size += pos->value_size;\n      buf[used_size++] = '\\r';\n      buf[used_size++] = '\\n';\n      mhd_assert (used_size == new_used_size);\n    }\n  }\n  if (used_size + 2 > buf_size)\n    return MHD_NO;\n  buf[used_size++] = '\\r';\n  buf[used_size++] = '\\n';\n\n  c->write_buffer_append_offset += used_size;\n  mhd_assert (c->write_buffer_append_offset <= c->write_buffer_size);\n\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code computes buf = c->write_buffer + c->write_buffer_append_offset without an explicit check that write_buffer_append_offset is within the allocated write_buffer. If write_buffer_append_offset > c->write_buffer_size (or otherwise points past the end of the allocated buffer) then buf will point outside the object and the subsequent memcpy/memset writes (used later in the function) can write beyond the bounds of the buffer, violating MISRA C 2023 Rule 21.17. Note: the code relies on connection_maximize_write_buffer and debug-only mhd_assert checks to prevent this, but those are not guaranteed at all times, so a concrete out\u2011of\u2011bounds scenario is possible.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function uses memcpy (and also directly writes bytes) to the location buf = c->write_buffer + c->write_buffer_append_offset. The code checks that buf_size (obtained from connection_maximize_write_buffer(c)) is large enough for the data that will be written, but it does not itself verify that c->write_buffer is non-NULL and that c->write_buffer_append_offset is within the bounds of the actual allocated buffer object. The only checks for those conditions are debug-only mhd_assert calls and an implicit assumption that connection_maximize_write_buffer establishes the necessary invariants. Under MISRA C 2023 Rule 21.17 the use of memcpy (and other memory writes) must not result in accesses beyond the bounds of the referenced objects in all builds; relying solely on asserts or an external function without a visible, guaranteed contract is insufficient. Therefore, unless connection_maximize_write_buffer is formally guaranteed to return the remaining space and to ensure write_buffer != NULL and append_offset <= write_buffer_size in all builds, the code can produce out-of-bounds accesses and violates Rule 21.17. Recommended fixes are to explicitly validate (in this function or by a provable contract) that c->write_buffer is valid and that c->write_buffer_append_offset <= c->write_buffer_size (and that buf_size reflects the remaining capacity) before performing memcpy/writes."
}