{
  "user_message": "An agent A claimed that the following MHD_connection_handle_read code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_read.\n```c\nvoid\nMHD_connection_handle_read (struct MHD_Connection *connection,\n                            bool socket_error)\n{\n  ssize_t bytes_read;\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n    return;\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  mhd_assert (NULL != connection->read_buffer);\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n    return; /* No space for receiving data. */\n\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size\n                                     - connection->read_buffer_offset);\n  if ((bytes_read < 0) || socket_error)\n  {\n    if ((MHD_ERR_AGAIN_ == bytes_read) && ! socket_error)\n      return;     /* No new data to process. */\n    if ((bytes_read > 0) && connection->sk_nonblck)\n    { /* Try to detect the socket error */\n      int dummy;\n      bytes_read = connection->recv_cls (connection, &dummy, sizeof (dummy));\n    }\n    if (MHD_ERR_CONNRESET_ == bytes_read)\n    {\n      if ( (MHD_CONNECTION_INIT < connection->state) &&\n           (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Socket has been disconnected when reading request.\\n\"));\n#endif\n        connection->discard_request = true;\n      }\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      return;\n    }\n\n#ifdef HAVE_MESSAGES\n    if (MHD_CONNECTION_INIT != connection->state)\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection socket is closed when reading \" \\\n                   \"request due to the error: %s\\n\"),\n                (bytes_read < 0) ? str_conn_error_ (bytes_read) :\n                \"detected connection closure\");\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            NULL);\n    return;\n  }\n\n  if (0 == bytes_read)\n  {   /* Remote side closed connection. */\n    connection->read_closed = true;\n    if ( (MHD_CONNECTION_INIT < connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection was closed by remote side with incomplete \"\n                   \"request.\\n\"));\n#endif\n      connection->discard_request = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n    }\n    else if (MHD_CONNECTION_INIT == connection->state)\n      /* This termination code cannot be reported to the application\n       * because application has not been informed yet about this request */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return;\n  }\n  connection->read_buffer_offset += (size_t) bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  /* TODO: check whether the next 'switch()' really needed */\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    /* nothing to do but default action */\n    if (connection->read_closed)\n    {\n      /* TODO: check whether this really needed */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n    }\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  case MHD_CONNECTION_START_REPLY:\n    /* shrink read buffer to how much is actually used */\n    /* TODO: remove shrink as it handled in special function */\n    if ((0 != connection->read_buffer_size) &&\n        (connection->read_buffer_size != connection->read_buffer_offset))\n    {\n      mhd_assert (NULL != connection->read_buffer);\n      connection->read_buffer =\n        MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             connection->read_buffer_offset);\n      connection->read_buffer_size = connection->read_buffer_offset;\n    }\n    break;\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n    /* Milestone state, no data should be read */\n    mhd_assert (0); /* Should not be possible */\n    break;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n  case MHD_CONNECTION_HEADERS_SENDING:\n  case MHD_CONNECTION_HEADERS_SENT:\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n  case MHD_CONNECTION_FOOTERS_SENDING:\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n  default:\n    mhd_assert (0); /* Should not be possible */\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls mhd_assert(0) in the default/fall\u2011through branch of the switch. If mhd_assert is defined as a no\u2011op in production builds (common when assertions are disabled), the call is an operation that is executed but has no effect; removing that call would not change program behaviour, so it is dead code. Thus, when assertions are compiled out and the branch can be reached, Rule 2.2 is violated. A concrete violating scenario: a release build where mhd_assert expands to ((void)0) and connection->state ever takes one of the listed cases or default, so the mhd_assert(0) statement executes but does nothing.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a491e0 state=0 socket_error=0 read_buf=0x5580d4a49480 read_buf_size=16384 read_buf_off=0 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a49480 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=1 socket_error=0\n2025-08-26 07:44:57 - About to switch on state: 0 (read_buffer_offset=1)\n2025-08-26 07:44:57 - RETURN from receiving states: state=0 read_closed=0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a491e0 state=1 socket_error=0 read_buf=0x5580d4a49480 read_buf_size=16384 read_buf_off=1 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a49480 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=0 socket_error=0\n2025-08-26 07:44:57 - Remote side closed connection: state=1 (read_closed set)\n2025-08-26 07:44:57 - Closed: TERMINATED_CLIENT_ABORT for conn=0x5580d4a491e0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51890 state=0 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=0 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=2 socket_error=0\n2025-08-26 07:44:57 - About to switch on state: 0 (read_buffer_offset=2)\n2025-08-26 07:44:57 - RETURN from receiving states: state=0 read_closed=0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51890 state=1 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=2 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=0 socket_error=0\n2025-08-26 07:44:57 - Remote side closed connection: state=1 (read_closed set)\n2025-08-26 07:44:57 - Closed: TERMINATED_CLIENT_ABORT for conn=0x5580d4a51890\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51ae0 state=0 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=0 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=3 socket_error=0\n2025-08-26 07:44:57 - About to switch on state: 0 (read_buffer_offset=3)\n2025-08-26 07:44:57 - RETURN from receiving states: state=0 read_closed=0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51ae0 state=1 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=3 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=0 socket_error=0\n2025-08-26 07:44:57 - Remote side closed connection: state=1 (read_closed set)\n2025-08-26 07:44:57 - Closed: TERMINATED_CLIENT_ABORT for conn=0x5580d4a51ae0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51d30 state=0 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=0 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=4 socket_error=0\n2025-08-26 07:44:57 - About to switch on state: 0 (read_buffer_offset=4)\n2025-08-26 07:44:57 - RETURN from receiving states: state=0 read_closed=0\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51d30 state=1 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=4 suspended=0\n2025-08-26 07:44:57 - ASSERT CHECK: read_buffer ptr=0x5580d4a528a0 (should be non-NULL in debug)\n2025-08-26 07:44:57 - recv_cls returned: bytes_read=0 socket_error=0\n2025-08-26 07:44:57 - Remote side closed connection: state=1 (read_closed set)\n2025-08-26 07:44:57 - Closed: TERMINATED_CLIENT_ABORT for conn=0x5580d4a51d30\n2025-08-26 07:44:57 - ENTER MHD_connection_handle_read: conn=0x5580d4a51f80 state=0 socket_error=0 read_buf=0x5580d4a528a0 read_buf_size=16384 read_buf_off=0 suspended=0\n2025-08-26 07:44:57 - \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent's report is correct in the circumstances described. The switch contains branches whose only executed statement is mhd_assert(0) (followed by break or return). If mhd_assert is implemented as a no-op in production builds (the common pattern #define mhd_assert(x) ((void)0)), those statements become operations that are executed but have no effect; removing them would not change program behaviour. That matches MISRA C 2023 Rule 2.2 (dead code). Note this is conditional: if mhd_assert has non\u2011trivial behaviour in production (logs, aborts, etc.), then those calls are not dead and there is no Rule 2.2 violation. Also, if it can be statically proven that those case labels are unreachable, note 2 of Rule 2.2 would apply (unreachable code is not dead code). But given typical builds where assertions are compiled out and the state values could be reached at runtime, the report identifies a valid dead\u2011code concern. \n\nRecommended fixes include: ensure those \u201cimpossible\u201d branches are truly unreachable (documented/guarded by configuration macros), keep the assert only under a conditional compilation (e.g. #ifdef DEBUG) so no null statements remain in production, or replace the assert with an explicit unreachable handler that has observable behaviour in production (logging/termination) so the statement is not a no\u2011op."
}