{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/42.txt\", \"a\");\n    if (!fp)\n        return;\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    if (localtime_r(&t, &tm_buf))\n    {\n        char timestr[64];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n            fprintf(fp, \"%s - \", timestr);\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nvoid\nMHD_connection_handle_read (struct MHD_Connection *connection,\n                            bool socket_error)\n{\n  ssize_t bytes_read;\n\n  /* ENTRY probe */\n  mhd_probe_log(\"ENTER MHD_connection_handle_read: conn=%p state=%lld socket_error=%d read_buf=%p read_buf_size=%llu read_buf_off=%llu tls_state=%lld suspended=%d\",\n                (void *)connection,\n                (long long)connection->state,\n                (int)socket_error,\n                (void *)connection->read_buffer,\n                (unsigned long long)connection->read_buffer_size,\n                (unsigned long long)connection->read_buffer_offset,\n                (long long)connection->tls_state,\n                (int)connection->suspended);\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n  {\n    mhd_probe_log(\"EARLY RETURN: connection closed or suspended: state=%lld suspended=%d\",\n                  (long long)connection->state,\n                  (int)connection->suspended);\n    return;\n  }\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        mhd_probe_log(\"TLS handshake not completed, returning: tls_state=%lld\",\n                      (long long)connection->tls_state);\n        return;\n      }\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  mhd_probe_log(\"ASSERT CHECK: read_buffer ptr=%p (should be non-NULL in debug)\",\n                (void *)connection->read_buffer);\n  mhd_assert (NULL != connection->read_buffer);\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n  {\n    mhd_probe_log(\"RETURN: No space for receiving data: size=%llu offset=%llu\",\n                  (unsigned long long)connection->read_buffer_size,\n                  (unsigned long long)connection->read_buffer_offset);\n    return; /* No space for receiving data. */\n  }\n\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size\n                                     - connection->read_buffer_offset);\n  mhd_probe_log(\"recv_cls returned: bytes_read=%lld socket_error=%d\",\n                (long long)bytes_read, (int)socket_error);\n\n  if ((bytes_read < 0) || socket_error)\n  {\n    if ((MHD_ERR_AGAIN_ == bytes_read) && ! socket_error)\n    {\n      mhd_probe_log(\"EAGAIN: no new data to process\");\n      return;     /* No new data to process. */\n    }\n    if ((bytes_read > 0) && connection->sk_nonblck)\n    { /* Try to detect the socket error */\n      int dummy;\n      mhd_probe_log(\"Non-blocking socket with bytes_read>0, probing for socket error\");\n      bytes_read = connection->recv_cls (connection, &dummy, sizeof (dummy));\n      mhd_probe_log(\"Retry recv returned: bytes_read=%lld\", (long long)bytes_read);\n    }\n    if (MHD_ERR_CONNRESET_ == bytes_read)\n    {\n      mhd_probe_log(\"Connection reset detected: bytes_read=%lld state=%lld\",\n                    (long long)bytes_read, (long long)connection->state);\n      if ( (MHD_CONNECTION_INIT < connection->state) &&\n           (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Socket has been disconnected when reading request.\\n\"));\n#endif\n        connection->discard_request = true;\n      }\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      mhd_probe_log(\"Connection closed due to reset: conn=%p\", (void *)connection);\n      return;\n    }\n\n#ifdef HAVE_MESSAGES\n    if (MHD_CONNECTION_INIT != connection->state)\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection socket is closed when reading \" \\\n                   \"request due to the error: %s\\n\"),\n                (bytes_read < 0) ? str_conn_error_ (bytes_read) :\n                \"detected connection closure\");\n#endif\n    mhd_probe_log(\"CONNECTION_CLOSE_ERROR invoked: bytes_read=%lld state=%lld\",\n                  (long long)bytes_read, (long long)connection->state);\n    CONNECTION_CLOSE_ERROR (connection,\n                            NULL);\n    return;\n  }\n\n  if (0 == bytes_read)\n  {   /* Remote side closed connection. */\n    connection->read_closed = true;\n    mhd_probe_log(\"Remote side closed connection: state=%lld (read_closed set)\",\n                  (long long)connection->state);\n    if ( (MHD_CONNECTION_INIT < connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection was closed by remote side with incomplete \"\n                   \"request.\\n\"));\n#endif\n      connection->discard_request = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n      mhd_probe_log(\"Closed: TERMINATED_CLIENT_ABORT for conn=%p\", (void *)connection);\n    }\n    else if (MHD_CONNECTION_INIT == connection->state)\n    {\n      /* This termination code cannot be reported to the application\n       * because application has not been informed yet about this request */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      mhd_probe_log(\"Closed: TERMINATED_COMPLETED_OK for conn=%p\", (void *)connection);\n    }\n    else\n    {\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n      mhd_probe_log(\"Closed: TERMINATED_WITH_ERROR for conn=%p\", (void *)connection);\n    }\n    return;\n  }\n  connection->read_buffer_offset += (size_t) bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  /* TODO: check whether the next 'switch()' really needed */\n  mhd_probe_log(\"About to switch on state: %lld (read_buffer_offset=%llu)\",\n                (long long)connection->state,\n                (unsigned long long)connection->read_buffer_offset);\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    /* nothing to do but default action */\n    if (connection->read_closed)\n    {\n      /* TODO: check whether this really needed */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      mhd_probe_log(\"Closed due to read_closed in receiving state: state=%lld\", (long long)connection->state);\n    }\n    mhd_probe_log(\"RETURN from receiving states: state=%lld read_closed=%d\",\n                  (long long)connection->state,\n                  (int)connection->read_closed);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    mhd_probe_log(\"RETURN: encountered MHD_CONNECTION_CLOSED in switch\");\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_probe_log(\"ASSERTION BRANCH: MHD_CONNECTION_UPGRADE reached: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0);\n    mhd_probe_log(\"After mhd_assert(0) in UPGRADE branch (note: may be no-op in production)\");\n    return;\n#endif /* UPGRADE_SUPPORT */\n  case MHD_CONNECTION_START_REPLY:\n    /* shrink read buffer to how much is actually used */\n    /* TODO: remove shrink as it handled in special function */\n    if ((0 != connection->read_buffer_size) &&\n        (connection->read_buffer_size != connection->read_buffer_offset))\n    {\n      mhd_probe_log(\"START_REPLY: shrinking read buffer from %llu to %llu\",\n                    (unsigned long long)connection->read_buffer_size,\n                    (unsigned long long)connection->read_buffer_offset);\n      mhd_assert (NULL != connection->read_buffer);\n      connection->read_buffer =\n        MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             connection->read_buffer_offset);\n      connection->read_buffer_size = connection->read_buffer_offset;\n    }\n    break;\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n    /* Milestone state, no data should be read */\n    mhd_probe_log(\"ASSERTION BRANCH: milestone state reached where no data should be read: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0); /* Should not be possible */\n    mhd_probe_log(\"After mhd_assert(0) in milestone branch (note: may be no-op in production)\");\n    break;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n  case MHD_CONNECTION_HEADERS_SENDING:\n  case MHD_CONNECTION_HEADERS_SENT:\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n  case MHD_CONNECTION_FOOTERS_SENDING:\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n  default:\n    mhd_probe_log(\"DEFAULT/ASSERTION BRANCH: unexpected state in read handler: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0); /* Should not be possible */\n    mhd_probe_log(\"After mhd_assert(0) in default branch (note: may be no-op in production)\");\n    break;\n  }\n  mhd_probe_log(\"EXIT MHD_connection_handle_read: conn=%p state=%lld\",\n                (void *)connection, (long long)connection->state);\n  return;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nconnection.c:6454:40: error: no member named 'tls_state' in 'struct MHD_Connection'\n 6454 |                 (long long)connection->tls_state,\n      |                            ~~~~~~~~~~  ^\n1 error generated.\nmake[3]: *** [Makefile:2098: libmicrohttpd_la-connection.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_connection_handle_read as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <sys/types.h>\n\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/42.txt\", \"a\");\n    if (!fp)\n        return;\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    if (localtime_r(&t, &tm_buf))\n    {\n        char timestr[64];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n            fprintf(fp, \"%s - \", timestr);\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nvoid\nMHD_connection_handle_read (struct MHD_Connection *connection,\n                            bool socket_error)\n{\n  ssize_t bytes_read;\n\n  /* ENTRY probe */\n#ifdef HTTPS_SUPPORT\n  mhd_probe_log(\"ENTER MHD_connection_handle_read: conn=%p state=%lld socket_error=%d read_buf=%p read_buf_size=%llu read_buf_off=%llu tls_state=%lld suspended=%d\",\n                (void *)connection,\n                (long long)connection->state,\n                (int)socket_error,\n                (void *)connection->read_buffer,\n                (unsigned long long)connection->read_buffer_size,\n                (unsigned long long)connection->read_buffer_offset,\n                (long long)connection->tls_state,\n                (int)connection->suspended);\n#else\n  /* If HTTPS_SUPPORT is not enabled, struct MHD_Connection may not have\n     tls_state; omit it from the probe to avoid referencing a non-existent\n     member while preserving the rest of the logged data. */\n  mhd_probe_log(\"ENTER MHD_connection_handle_read: conn=%p state=%lld socket_error=%d read_buf=%p read_buf_size=%llu read_buf_off=%llu suspended=%d\",\n                (void *)connection,\n                (long long)connection->state,\n                (int)socket_error,\n                (void *)connection->read_buffer,\n                (unsigned long long)connection->read_buffer_size,\n                (unsigned long long)connection->read_buffer_offset,\n                (int)connection->suspended);\n#endif\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n  {\n    mhd_probe_log(\"EARLY RETURN: connection closed or suspended: state=%lld suspended=%d\",\n                  (long long)connection->state,\n                  (int)connection->suspended);\n    return;\n  }\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        mhd_probe_log(\"TLS handshake not completed, returning: tls_state=%lld\",\n                      (long long)connection->tls_state);\n        return;\n      }\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  mhd_probe_log(\"ASSERT CHECK: read_buffer ptr=%p (should be non-NULL in debug)\",\n                (void *)connection->read_buffer);\n  mhd_assert (NULL != connection->read_buffer);\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n  {\n    mhd_probe_log(\"RETURN: No space for receiving data: size=%llu offset=%llu\",\n                  (unsigned long long)connection->read_buffer_size,\n                  (unsigned long long)connection->read_buffer_offset);\n    return; /* No space for receiving data. */\n  }\n\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size\n                                     - connection->read_buffer_offset);\n  mhd_probe_log(\"recv_cls returned: bytes_read=%lld socket_error=%d\",\n                (long long)bytes_read, (int)socket_error);\n\n  if ((bytes_read < 0) || socket_error)\n  {\n    if ((MHD_ERR_AGAIN_ == bytes_read) && ! socket_error)\n    {\n      mhd_probe_log(\"EAGAIN: no new data to process\");\n      return;     /* No new data to process. */\n    }\n    if ((bytes_read > 0) && connection->sk_nonblck)\n    { /* Try to detect the socket error */\n      int dummy;\n      mhd_probe_log(\"Non-blocking socket with bytes_read>0, probing for socket error\");\n      bytes_read = connection->recv_cls (connection, &dummy, sizeof (dummy));\n      mhd_probe_log(\"Retry recv returned: bytes_read=%lld\", (long long)bytes_read);\n    }\n    if (MHD_ERR_CONNRESET_ == bytes_read)\n    {\n      mhd_probe_log(\"Connection reset detected: bytes_read=%lld state=%lld\",\n                    (long long)bytes_read, (long long)connection->state);\n      if ( (MHD_CONNECTION_INIT < connection->state) &&\n           (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Socket has been disconnected when reading request.\\n\"));\n#endif\n        connection->discard_request = true;\n      }\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      mhd_probe_log(\"Connection closed due to reset: conn=%p\", (void *)connection);\n      return;\n    }\n\n#ifdef HAVE_MESSAGES\n    if (MHD_CONNECTION_INIT != connection->state)\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection socket is closed when reading \" \\\n                   \"request due to the error: %s\\n\"),\n                (bytes_read < 0) ? str_conn_error_ (bytes_read) :\n                \"detected connection closure\");\n#endif\n    mhd_probe_log(\"CONNECTION_CLOSE_ERROR invoked: bytes_read=%lld state=%lld\",\n                  (long long)bytes_read, (long long)connection->state);\n    CONNECTION_CLOSE_ERROR (connection,\n                            NULL);\n    return;\n  }\n\n  if (0 == bytes_read)\n  {   /* Remote side closed connection. */\n    connection->read_closed = true;\n    mhd_probe_log(\"Remote side closed connection: state=%lld (read_closed set)\",\n                  (long long)connection->state);\n    if ( (MHD_CONNECTION_INIT < connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection was closed by remote side with incomplete \"\n                   \"request.\\n\"));\n#endif\n      connection->discard_request = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n      mhd_probe_log(\"Closed: TERMINATED_CLIENT_ABORT for conn=%p\", (void *)connection);\n    }\n    else if (MHD_CONNECTION_INIT == connection->state)\n    {\n      /* This termination code cannot be reported to the application\n       * because application has not been informed yet about this request */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      mhd_probe_log(\"Closed: TERMINATED_COMPLETED_OK for conn=%p\", (void *)connection);\n    }\n    else\n    {\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n      mhd_probe_log(\"Closed: TERMINATED_WITH_ERROR for conn=%p\", (void *)connection);\n    }\n    return;\n  }\n  connection->read_buffer_offset += (size_t) bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  /* TODO: check whether the next 'switch()' really needed */\n  mhd_probe_log(\"About to switch on state: %lld (read_buffer_offset=%llu)\",\n                (long long)connection->state,\n                (unsigned long long)connection->read_buffer_offset);\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    /* nothing to do but default action */\n    if (connection->read_closed)\n    {\n      /* TODO: check whether this really needed */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      mhd_probe_log(\"Closed due to read_closed in receiving state: state=%lld\", (long long)connection->state);\n    }\n    mhd_probe_log(\"RETURN from receiving states: state=%lld read_closed=%d\",\n                  (long long)connection->state,\n                  (int)connection->read_closed);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    mhd_probe_log(\"RETURN: encountered MHD_CONNECTION_CLOSED in switch\");\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_probe_log(\"ASSERTION BRANCH: MHD_CONNECTION_UPGRADE reached: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0);\n    mhd_probe_log(\"After mhd_assert(0) in UPGRADE branch (note: may be no-op in production)\");\n    return;\n#endif /* UPGRADE_SUPPORT */\n  case MHD_CONNECTION_START_REPLY:\n    /* shrink read buffer to how much is actually used */\n    /* TODO: remove shrink as it handled in special function */\n    if ((0 != connection->read_buffer_size) &&\n        (connection->read_buffer_size != connection->read_buffer_offset))\n    {\n      mhd_probe_log(\"START_REPLY: shrinking read buffer from %llu to %llu\",\n                    (unsigned long long)connection->read_buffer_size,\n                    (unsigned long long)connection->read_buffer_offset);\n      mhd_assert (NULL != connection->read_buffer);\n      connection->read_buffer =\n        MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             connection->read_buffer_offset);\n      connection->read_buffer_size = connection->read_buffer_offset;\n    }\n    break;\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n    /* Milestone state, no data should be read */\n    mhd_probe_log(\"ASSERTION BRANCH: milestone state reached where no data should be read: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0); /* Should not be possible */\n    mhd_probe_log(\"After mhd_assert(0) in milestone branch (note: may be no-op in production)\");\n    break;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n  case MHD_CONNECTION_HEADERS_SENDING:\n  case MHD_CONNECTION_HEADERS_SENT:\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n  case MHD_CONNECTION_FOOTERS_SENDING:\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n  default:\n    mhd_probe_log(\"DEFAULT/ASSERTION BRANCH: unexpected state in read handler: state=%lld - will call mhd_assert(0)\",\n                  (long long)connection->state);\n    mhd_assert (0); /* Should not be possible */\n    mhd_probe_log(\"After mhd_assert(0) in default branch (note: may be no-op in production)\");\n    break;\n  }\n  mhd_probe_log(\"EXIT MHD_connection_handle_read: conn=%p state=%lld\",\n                (void *)connection, (long long)connection->state);\n  return;\n}\n",
  "explanation": "The compiler error was caused by referencing connection->tls_state unconditionally while the struct MHD_Connection in this build does not contain that member. I fixed it by splitting the initial ENTRY probe log into two variants: one that includes tls_state when HTTPS_SUPPORT is defined, and one that omits tls_state when HTTPS_SUPPORT is not defined. This preserves the original logic and logging detail when HTTPS support is enabled, and avoids referencing a non-existent member otherwise."
}