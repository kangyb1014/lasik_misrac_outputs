{
  "user_message": "An agent A claimed that the following MHD_create_thread_ code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_thread_.\n```c\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the start_routine argument points to MHD_create_thread_ itself (or to any function that eventually calls MHD_create_thread_), then the call to pthread_create will result in the start_routine being invoked and thus MHD_create_thread_ will indirectly cause itself to be called. This creates an indirect recursion (MHD_create_thread_ -> pthread_create -> start_routine -> ... -> MHD_create_thread_), violating MISRA C 2023 Rule 17.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61d978 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6770 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247707469376] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61dca0\n[2682707][tid=140247707469376] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61e138 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6770 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247707469376] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61dca0\n[2682707][tid=140247707469376] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61ea38 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6760 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61ece0 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61ee40\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6760 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61ee40\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247707469376] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61dca0\n[2682707][tid=140247707469376] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247699076672] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61ee40\n[2682707][tid=140247699076672] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61f538 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61ee40\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6770 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61ee40\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247699076672] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61ee40\n[2682707][tid=140247699076672] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc61f978 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6770 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61dca0\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247699076672] thread wrapper start: real_start=0x7f8df6f06710 real_arg=0x55e8cc61dca0\n[2682707][tid=140247699076672] thread wrapper end: real_start=0x7f8df6f06710 returned=(nil)\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc6201f8 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61dea0\n[2682707][tid=140247707473728] calling pthread_create (no attr) with wrapper: new_tid_ptr=0x7ffe057b6760 wrapper=0x7f8df6f06520 original_start=0x7f8df6f06710 original_arg=0x55e8cc61dea0\n[2682707][tid=140247707473728] MHD_create_thread_ exit: return=1\n[2682707][tid=140247707473728] MHD_create_thread_ entry: handle_id=0x55e8cc6204a0 stack_size=0 start_routine=0x7f8df6f06710 arg=0x55e8cc61ee20\n[2682707][tid=14024770747\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 17.2 forbids a function from calling itself (directly or via a call chain). The code shown does call pthread_create with a caller-supplied start_routine pointer, but that does not inherently create a direct or indirect self-call from MHD_create_thread_. pthread_create spawns a new thread which later invokes the supplied start_routine asynchronously; it does not synchronously call start_routine on the same call stack. Whether start_routine happens to be MHD_create_thread_ is a matter of how the API is used by the caller, not something this function unconditionally does. Static MISRA checking looks for call cycles in the program call graph; unless the pointer can be resolved at compile time to MHD_create_thread_ (or a chain that leads back to it), there is no provable indirect recursion introduced by this implementation. In short: the implementation itself does not create a guaranteed direct/indirect self-call, so flagging it as a Rule 17.2 violation is not correct. (Recommendation: document that callers must not pass MHD_create_thread_ as the thread start routine if recursion is undesired, and ensure static analysis resolves function-pointer targets where required.)"
}