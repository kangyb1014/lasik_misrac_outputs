{
  "user_message": "An agent A claimed that the following MHD_SHA256_finish code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_finish.\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen _MHD_PUT_32BIT_BE_UNALIGNED is not defined and MHD_FAVOR_SMALL_CODE is defined the preprocessor reduces the controlling statement to 'if (1) { ... }'. That makes the controlling expression a constant (invariant), which violates MISRA C 2023 Rule 14.3 (controlling expressions shall not be invariant).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0xb00361a3 H5=0x96177a9c H6=0xb410ff61\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0xa33ce459 H5=0x64ff2167 H6=0xf6ecedd4\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x27ae41e4 H5=0x649b934c H6=0xa495991b\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x5524354a H5=0x006f4272 H6=0x41c152a7\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0xfa7d534e H5=0xa1dab25a H6=0x75bb2c30\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x5e316218 H5=0xcf51fc8d H6=0x9ed832f2\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0xca37fd72 H5=0x8b0cd16c H6=0x55d58898\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x474d09ef H5=0x6d503512 H6=0x2572d868\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0xc7c75505 H5=0x2f7c6ffa H6=0xd1e3e17b\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x5e316218 H5=0xcf51fc8d H6=0x9ed832f2\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x7773ff3a H5=0xd93f43d4 H6=0xd4812c5b\nexit_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nenter_finish: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=0\nentered_direct_put_branch: ctx=0x7ffc0c614360 digest=0x7ffc0c614340 digest_addr=140720516186944 branch=2\ndirect_put_done: H4=0x637c391e H5=0xa80fa988 H6=0x0344980e\nexit_finish: ctx=0x7ffc\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. Expanding the relevant preprocessing branches shows that when _MHD_PUT_32BIT_BE_UNALIGNED is not defined and MHD_FAVOR_SMALL_CODE is defined the code reduces to a plain if (1) { ... } (the second if-block is excluded by the #if). The controlling expression is therefore the invariant constant 1. MISRA C:2023 Rule 14.3 prohibits invariant controlling expressions (the only permitted exceptions are infinite loops and the special do-while false case, neither of which applies here). Thus agent A\u2019s report is correct. A suitable remediation is to remove the runtime if and use preprocessor selection (#if/#else) so no invariant if remains, or restore the original runtime test instead of leaving if (1)."
}