{
  "user_message": "An agent A claimed that the following MHD_str_pct_decode_in_place_lenient_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_pct_decode_in_place_lenient_.\n```c\nsize_t\nMHD_str_pct_decode_in_place_lenient_ (char *str,\n                                      bool *broken_encoding)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  size_t len;\n  size_t res;\n\n  len = strlen (str);\n  res = MHD_str_pct_decode_lenient_n_ (str, len, str, len, broken_encoding);\n  str[res] = 0;\n\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  if (NULL != broken_encoding)\n    *broken_encoding = false;\n  r = 0;\n  w = 0;\n  while (0 != str[r])\n  {\n    const char chr = str[r++];\n    if ('%' == chr)\n    {\n      const char d1 = str[r++];\n      if (0 == d1)\n      {\n        if (NULL != broken_encoding)\n          *broken_encoding = true;\n        str[w++] = chr; /* Copy \"as is\" */\n        str[w] = 0;\n        return w;\n      }\n      else\n      {\n        const char d2 = str[r++];\n        if (0 == d2)\n        {\n          if (NULL != broken_encoding)\n            *broken_encoding = true;\n          str[w++] = chr; /* Copy \"as is\" */\n          str[w++] = d1; /* Copy \"as is\" */\n          str[w] = 0;\n          return w;\n        }\n        else\n        {\n          const int h = toxdigitvalue (d1);\n          const int l = toxdigitvalue (d2);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n          {\n            if (NULL != broken_encoding)\n              *broken_encoding = true;\n            str[w++] = chr; /* Copy \"as is\" */\n            str[w++] = d1;\n            str[w++] = d2;\n            continue;\n          }\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          str[w++] = (char) out;\n          continue;\n        }\n      }\n    }\n    str[w++] = chr;\n  }\n  str[w] = 0;\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nCalling strlen(str) without first ensuring that 'str' points to a valid, null\u2011terminated object can read beyond the object bounds. For example, if the caller passes (a) str == NULL or (b) a buffer that is not NUL\u2011terminated (or shorter than the intended length), strlen will scan past the buffer and thus access out of bounds.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nfinished loop: wrote terminating NUL at w=0; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='a' (0x61) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='a' (0x61) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='a' (0x61) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='b' (0x62) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='b' (0x62) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='b' (0x62) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='c' (0x63) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='c' (0x63) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='c' (0x63) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='d' (0x64) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='d' (0x64) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='d' (0x64) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='l' (0x6c) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='l' (0x6c) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='l' (0x6c) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='m' (0x6d) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='m' (0x6d) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='m' (0x6d) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='n' (0x6e) at index r-1=0; new r=1\ncopied non-percent char to out at w-1=0; new w=1\nloop: read chr='n' (0x6e) at index r-1=1; new r=2\ncopied non-percent char to out at w-1=1; new w=2\nloop: read chr='n' (0x6e) at index r-1=2; new r=3\ncopied non-percent char to out at w-1=2; new w=3\nfinished loop: wrote terminating NUL at w=3; returning w\nMHD_str_pct_decode_in_place_lenient_: entry (large code path). str=0x557991bda190, broken_encoding=0x7fff490612ab\nMHD_str_pct_decode_in_place_lenient_: initial r=0, w=0\nloop: read chr='o' (0x6f) at index r-1=0\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario (strlen(str) can scan beyond the buffer if str is NULL or not NUL\u2011terminated) is technically true as a possible runtime fault. However, MISRA Rule 21.17 constrains the source code\u2019s use of <string.h> functions so that they do not cause out\u2011of\u2011bounds accesses in actual usage; relying on a documented precondition that the caller supplies a valid, NUL\u2011terminated (and non\u2011NULL) string is an acceptable design approach. In this function the strlen call appears only in the MHD_FAVOR_SMALL_CODE path and the function otherwise assumes a C string; there is no evidence in the code that the routine itself violates 21.17 so long as the API contract requires a valid NUL\u2011terminated input. Therefore Agent A\u2019s report (that the code as shown violates MISRA C 2023 Rule 21.17) is not correct as a definite violation. If you want to be defensive and remove any doubt, either (a) document the precondition (str != NULL and NUL\u2011terminated) or (b) add an explicit check for NULL / a length parameter or use a bounded function to avoid any possible scan past the buffer."
}