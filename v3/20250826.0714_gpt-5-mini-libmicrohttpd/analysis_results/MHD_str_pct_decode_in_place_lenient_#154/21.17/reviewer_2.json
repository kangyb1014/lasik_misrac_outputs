{
  "user_message": "An agent A claimed that the following MHD_str_pct_decode_in_place_lenient_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_str_pct_decode_in_place_lenient_.\n```c\nsize_t\nMHD_str_pct_decode_in_place_lenient_ (char *str,\n                                      bool *broken_encoding)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  size_t len;\n  size_t res;\n\n  len = strlen (str);\n  res = MHD_str_pct_decode_lenient_n_ (str, len, str, len, broken_encoding);\n  str[res] = 0;\n\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  if (NULL != broken_encoding)\n    *broken_encoding = false;\n  r = 0;\n  w = 0;\n  while (0 != str[r])\n  {\n    const char chr = str[r++];\n    if ('%' == chr)\n    {\n      const char d1 = str[r++];\n      if (0 == d1)\n      {\n        if (NULL != broken_encoding)\n          *broken_encoding = true;\n        str[w++] = chr; /* Copy \"as is\" */\n        str[w] = 0;\n        return w;\n      }\n      else\n      {\n        const char d2 = str[r++];\n        if (0 == d2)\n        {\n          if (NULL != broken_encoding)\n            *broken_encoding = true;\n          str[w++] = chr; /* Copy \"as is\" */\n          str[w++] = d1; /* Copy \"as is\" */\n          str[w] = 0;\n          return w;\n        }\n        else\n        {\n          const int h = toxdigitvalue (d1);\n          const int l = toxdigitvalue (d2);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n          {\n            if (NULL != broken_encoding)\n              *broken_encoding = true;\n            str[w++] = chr; /* Copy \"as is\" */\n            str[w++] = d1;\n            str[w++] = d2;\n            continue;\n          }\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          str[w++] = (char) out;\n          continue;\n        }\n      }\n    }\n    str[w++] = chr;\n  }\n  str[w] = 0;\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen MHD_FAVOR_SMALL_CODE is defined: len is obtained from strlen(str) and then passed as the destination limit to MHD_str_pct_decode_lenient_n_. The code then performs str[res] = 0 without a local check that res <= len (or that the caller supplied buffer is larger than len). If MHD_str_pct_decode_lenient_n_ were to return a value greater than len (for example because it does not enforce the passed dest length or due to a bug), the write at str[res] would write past the object\u2019s bounds and therefore violate Rule 21.17. (Also, if str is not NUL-terminated, the earlier strlen call itself can read out of bounds.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 0\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 3\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encoding=0x7ffd2531968b)\nRETURN large: 6\nENTER large: MHD_str_pct_decode_in_place_lenient_(str=0x55a2f8360190, broken_encodin\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C 2023 Rule 21.17 is specifically about uses of the standard <string.h> functions (strlen, memcpy, strcpy, etc.) causing out\u2011of\u2011bounds accesses. In the MHD_FAVOR_SMALL_CODE branch the code calls strlen(str) \u2014 that call is only safe if the function\u2019s contract requires a NUL\u2011terminated string; if the caller violates that precondition then strlen may read out of bounds (which would be a misuse of strlen), but that is a separate issue of caller preconditions, not a new, demonstrable violation in the snippet itself. The subsequent potential out\u2011of\u2011bounds write str[res] = 0 would only occur if MHD_str_pct_decode_lenient_n_ returns a value > len. That overflow would be caused by the behaviour of MHD_str_pct_decode_lenient_n_ (or by an earlier incorrect strlen result), not by the use of a <string.h> function writing past its parameters. In short: the code does call strlen (so care must be taken that str is NUL\u2011terminated), but there is no direct Rule 21.17 violation shown by the provided code. Recommendation: document the precondition that str is NUL\u2011terminated and/or validate that res <= len (or ensure MHD_str_pct_decode_lenient_n_ cannot return > len) to make the code defensive against misuse."
}