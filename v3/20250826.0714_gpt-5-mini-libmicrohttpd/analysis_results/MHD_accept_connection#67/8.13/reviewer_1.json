{
  "user_message": "An agent A claimed that the following MHD_accept_connection code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_accept_connection.\n```c\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes &addrstorage (a non-const struct sockaddr_storage) into internal_add_connection. If internal_add_connection's prototype accepts a non-const pointer (e.g. struct sockaddr_storage * or struct sockaddr *) but does not modify the pointed-to address, then the function parameter should be declared to point to a const-qualified type (e.g. const struct sockaddr_storage * or const struct sockaddr *). In that situation Rule 8.13 is violated. If, however, internal_add_connection legitimately modifies the contents of the structure, then the non-const parameter is required and there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 0e 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 0e 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 10 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 10 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 1c 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 1c 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 22 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 22 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 28 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 28 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 34 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 34 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nBEFORE: addr bytes (first 16): 02 00 b9 3e 7f 00 00 01 00 00 00 00 00 00 00 00\n\nTIME=1756194536 PHASE=AFTER daemon=0x559cffc108d0 socket=5 addrptr=0x7fff3de895a8 addrlen=16 sk_nonbl=1 sk_spipe_supprs=0 sk_cloexec=1 sk_non_ip=0\nAFTER: addr bytes (first 16): 02 00 b9 3e 7f 00 00 01 00 00 00 00 00 00 00 00\n\nDIFF_CHECK daemon=0x559cffc108d0 addrptr=0x7fff3de895a8 addrlen=16 limit=16\nTotal differing bytes (first 16 bytes checked): 0\n\nTIME=1756194536 PHASE=BEFORE \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Summary: Agent A\u2019s claim is plausible but not proven from the snippet alone. MISRA C 2023 Rule 8.13 says a pointer parameter should be to a const-qualified type whenever the pointed-to object is not modified. The call here passes &addrstorage (a non-const struct sockaddr_storage) to internal_add_connection. Whether there is a Rule 8.13 violation depends on internal_add_connection\u2019s prototype/body:\n\n- If internal_add_connection is declared to accept a non-const pointer (e.g. struct sockaddr * or struct sockaddr_storage *) but its implementation does not modify the pointed-to memory, then the parameter should indeed be declared as a pointer to const and the current (non-const) prototype would be a violation of Rule 8.13. The provided execution log shows the bytes of addrstorage before and after the call are unchanged in multiple runs, which is strong runtime evidence that the function did not modify the buffer in those tests \u2014 supporting Agent A\u2019s scenario.\n\n- If internal_add_connection already declares the parameter as a pointer-to-const (e.g. const struct sockaddr * or const struct sockaddr_storage *), or if the function legitimately modifies the structure, then there is no Rule 8.13 violation.\n\nConclusion: you cannot confirm the reported violation from the MHD_accept_connection code alone. The correct way to decide is to inspect the declaration/definition of internal_add_connection. If that declaration uses a non-const pointer yet the function does not modify the data, Agent A\u2019s report is correct; otherwise it is not.\n\nRecommendation: check the prototype/definition of internal_add_connection and, if it does not modify the address, change its parameter type to a pointer-to-const to comply with Rule 8.13."
}