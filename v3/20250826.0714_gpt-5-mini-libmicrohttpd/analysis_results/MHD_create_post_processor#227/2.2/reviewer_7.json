{
  "user_message": "An agent A claimed that the following MHD_create_post_processor code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_post_processor.\n```c\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation when MHD_calloc_ zero-initialises the memory and RN_Inactive has the value 0. The code calls MHD_calloc_(1, ...) which yields zeroed storage; if RN_Inactive == 0 then ret->skip_rn = RN_Inactive merely writes the existing zero and can be removed without changing behaviour, so it is dead code. (If RN_Inactive != 0, the assignment is not dead.)\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n--- MHD_create_post_processor: pre_alloc\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n--- end pre_alloc\n\n--- MHD_create_post_processor: post_alloc_before_init\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=(nil) ikvi=(nil) cls=(nil)\n ret->encoding=(nil) ret->buffer_size=0 ret->state=0\n ret->blen=0 ret->boundary=(nil) ret->skip_rn=0\n--- end post_alloc_before_init\n\n--- MHD_create_post_processor: before_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end before_skip_rn_assign\n\n--- MHD_create_post_processor: after_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end after_skip_rn_assign\n\n--- MHD_create_post_processor: pre_alloc\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n--- end pre_alloc\n\n--- MHD_create_post_processor: post_alloc_before_init\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=(nil) ikvi=(nil) cls=(nil)\n ret->encoding=(nil) ret->buffer_size=0 ret->state=0\n ret->blen=0 ret->boundary=(nil) ret->skip_rn=0\n--- end post_alloc_before_init\n\n--- MHD_create_post_processor: before_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end before_skip_rn_assign\n\n--- MHD_create_post_processor: after_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end after_skip_rn_assign\n\n--- MHD_create_post_processor: pre_alloc\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n--- end pre_alloc\n\n--- MHD_create_post_processor: post_alloc_before_init\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=(nil) ikvi=(nil) cls=(nil)\n ret->encoding=(nil) ret->buffer_size=0 ret->state=0\n ret->blen=0 ret->boundary=(nil) ret->skip_rn=0\n--- end post_alloc_before_init\n\n--- MHD_create_post_processor: before_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end before_skip_rn_assign\n\n--- MHD_create_post_processor: after_skip_rn_assign\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=0x7fff5acf1b10 ikvi=0x562ccf85fad0 cls=0x7fff5acf1acc\n ret->encoding=0x562ccf863023 ret->buffer_size=1028 ret->state=2\n ret->blen=6 ret->boundary=0x562ccf863041 ret->skip_rn=0\n--- end after_skip_rn_assign\n\n--- MHD_create_post_processor: pre_alloc\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n--- end pre_alloc\n\n--- MHD_create_post_processor: post_alloc_before_init\n buffer_size=1028 blen=6\n boundary=0x562ccf863041 encoding=0x562ccf863023\n RN_Inactive=0\n ret=0x562cd2ccca00 connection=(nil) ikvi=(nil) cls=(nil)\n ret->encoding=(nil) re\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario points out a single run/configuration where the assignment ret->skip_rn = RN_Inactive is redundant (execution log shows RN_Inactive == 0 and MHD_calloc_ produced zeroed storage). However MISRA C 2023 Rule 2.2 forbids dead code in the project \u2013 i.e. operations that can be removed without affecting program behaviour in the project as a whole. The assignment cannot be proved to be dead for the project: its effect is necessary if RN_Inactive has a non\u2011zero value, if an alternative allocator/wrapper does not zero the storage, or under different build/configuration changes. The assignment also documents and explicitly establishes the initial state of the object and is not merely an artefact of a particular run. Therefore the presence of redundant behaviour in one execution trace does not imply a MISRA Rule 2.2 violation in the project. For these reasons the report is not correct."
}