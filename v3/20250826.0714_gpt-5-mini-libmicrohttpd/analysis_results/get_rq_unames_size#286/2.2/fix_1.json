{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n#include <stdio.h>\n#include <stddef.h>\n\n/* Probe helper: call get_rq_uname_type, log the call and result, and return whether it matches expected.\n   This helper is intended to be used inside the mhd_assert call so that it is executed only when the\n   assertion macro evaluates its argument (preserving the original conditional execution).\n*/\nstatic int\nmhd_probe_get_rq_uname_type (const struct MHD_RqDAuth *params,\n                             enum MHD_DigestAuthUsernameType expected)\n{\n  enum MHD_DigestAuthUsernameType got;\n  FILE *f;\n\n  /* Call the real function (as the original assertion did) */\n  got = get_rq_uname_type (params);\n\n  /* Log the call and values to the file for repro / evidence of the assertion-path execution */\n  f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"[probe] get_rq_uname_type called: params=%p, expected=%d, got=%d\\n\",\n             (void *) params, (int) expected, (int) got);\n    fclose (f);\n  }\n\n  return (got == expected);\n}\n\n_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  /* Preserve original assertion but evaluate via the probe helper so we can detect\n     whether the call to get_rq_uname_type actually happens (i.e. only when assertions are enabled). */\n  mhd_assert (mhd_probe_get_rq_uname_type (params, uname_type));\n\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      s += (params->username.value.len + 1) / 2;\n\n    /* Log control path and state for this branch */\n    {\n      FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n      if (f)\n      {\n        fprintf (f, \"[probe] branch=STANDARD/USERHASH, uname_type=%d, username_len=%zu, computed_s=%zu\\n\",\n                 (int) uname_type, (size_t) params->username.value.len, s);\n        fclose (f);\n      }\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    s += params->username_ext.value.len\n         - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n\n    /* Log control path and state for extended branch */\n    {\n      FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n      if (f)\n      {\n        fprintf (f, \"[probe] branch=EXTENDED, uname_type=%d, username_ext_len=%zu, computed_s=%zu\\n\",\n                 (int) uname_type, (size_t) params->username_ext.value.len, s);\n        fclose (f);\n      }\n    }\n  }\n  else\n  {\n    /* Log control path for unexpected uname_type */\n    FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"[probe] branch=OTHER, uname_type=%d, computed_s=%zu\\n\",\n               (int) uname_type, s);\n      fclose (f);\n    }\n  }\n\n  return s;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_unames_size as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Minimal type and constant definitions to allow this translation unit to compile\n   while preserving the original logic of get_rq_unames_size as much as possible. */\n\n/* Username type enum (values chosen to match the original branch checks). */\nenum MHD_DigestAuthUsernameType {\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD = 0,\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH = 1,\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED = 2\n};\n\n/* Minimal wrapped string types so that params->username.value.len compiles. */\nstruct MHD_String { size_t len; };\nstruct MHD_WrappedString { struct MHD_String value; };\n\n/* Request digest auth parameters structure (only fields used by the function). */\nstruct MHD_RqDAuth {\n  struct MHD_WrappedString username;\n  struct MHD_WrappedString username_ext;\n};\n\n/* External function used by the probe helper. We declare it so the file compiles;\n   its definition is expected to be provided at link time. */\nenum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params);\n\n/* Minimal constant used in extended-username branch calculations. */\nenum { MHD_DAUTH_EXT_PARAM_MIN_LEN = 3 };\n\n/* mhd_assert is typically a macro; define it as an inline function so the\n   assertion argument is still evaluated (preserving the original call semantics)\n   but without defining any macros (per constraints). */\nstatic inline void\nmhd_assert (int expr)\n{\n  (void) expr; /* no-op, but ensures expr is evaluated */\n}\n\n/* Probe helper: call get_rq_uname_type, log the call and result, and return whether it matches expected.\n   This helper is intended to be used inside the mhd_assert call so that it is executed only when the\n   assertion is evaluated (preserving the original conditional execution as much as possible). */\nstatic int\nmhd_probe_get_rq_uname_type (const struct MHD_RqDAuth *params,\n                             enum MHD_DigestAuthUsernameType expected)\n{\n  enum MHD_DigestAuthUsernameType got;\n  FILE *f;\n\n  /* Call the real function (as the original assertion did) */\n  got = get_rq_uname_type (params);\n\n  /* Log the call and values to the file for repro / evidence of the assertion-path execution */\n  f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"[probe] get_rq_uname_type called: params=%p, expected=%d, got=%d\\n\",\n             (void *) params, (int) expected, (int) got);\n    fclose (f);\n  }\n\n  return (got == expected);\n}\n\nstatic inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  /* Preserve original assertion but evaluate via the probe helper so we can detect\n     whether the call to get_rq_uname_type actually happens (i.e. only when assertions are enabled). */\n  mhd_assert (mhd_probe_get_rq_uname_type (params, uname_type));\n\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      s += (params->username.value.len + 1) / 2;\n\n    /* Log control path and state for this branch */\n    {\n      FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n      if (f)\n      {\n        fprintf (f, \"[probe] branch=STANDARD/USERHASH, uname_type=%d, username_len=%zu, computed_s=%zu\\n\",\n                 (int) uname_type, (size_t) params->username.value.len, s);\n        fclose (f);\n      }\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    s += params->username_ext.value.len\n         - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n\n    /* Log control path and state for extended branch */\n    {\n      FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n      if (f)\n      {\n        fprintf (f, \"[probe] branch=EXTENDED, uname_type=%d, username_ext_len=%zu, computed_s=%zu\\n\",\n                 (int) uname_type, (size_t) params->username_ext.value.len, s);\n        fclose (f);\n      }\n    }\n  }\n  else\n  {\n    /* Log control path for unexpected uname_type */\n    FILE *f = fopen(\"/tmp/logs/2862.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"[probe] branch=OTHER, uname_type=%d, computed_s=%zu\\n\",\n               (int) uname_type, s);\n      fclose (f);\n    }\n  }\n\n  return s;\n}\n",
  "explanation": "I added minimal type and constant definitions (enum MHD_DigestAuthUsernameType, wrapped string structs, MHD_RqDAuth, and MHD_DAUTH_EXT_PARAM_MIN_LEN) so the code can compile. I declared get_rq_uname_type (no body) so the probe helper can call it at compile time; the actual implementation may be provided at link time. I replaced the _MHD_static_inline token with standard static inline and provided an inline mhd_assert function (rather than a macro) so the assertion argument is still evaluated but no macros are defined, satisfying the constraints. The original logic and logging behavior of get_rq_unames_size are preserved."
}