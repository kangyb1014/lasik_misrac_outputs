{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_set_panic_func:\n```c\n_MHD_EXTERN void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  if ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n\n  mhd_panic_cls = cls;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown fragment. The code only assigns a function-pointer variable (mhd_panic) to either cb or &mhd_panic_std; it does not call MHD_set_panic_func (nor any function) and therefore does not create a direct or indirect self-call by itself. A concrete violation scenario would be if a call chain formed a cycle \u2014 for example, if elsewhere MHD_set_panic_func invoked mhd_panic() and the callback pointed to a function that (directly or indirectly) called MHD_set_panic_func, producing A -> B -> ... -> A. Example violating situation: a callback defined as void panic_cb(void *cls) { /* eventually calls MHD_set_panic_func */ MHD_set_panic_func(another_cb, cls); } and MHD_set_panic_func (or code it calls) invokes mhd_panic(), creating an indirect recursion cycle. But the shown assignment fragment itself does not violate Rule 17.2."
}