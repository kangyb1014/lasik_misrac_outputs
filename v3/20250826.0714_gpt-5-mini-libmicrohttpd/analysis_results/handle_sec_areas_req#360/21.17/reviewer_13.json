{
  "user_message": "An agent A claimed that the following handle_sec_areas_req code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of handle_sec_areas_req.\n```c\nstatic enum MHD_Result\nhandle_sec_areas_req (struct MHD_Connection *c, const char *url, unsigned int\n                      sec_area_num)\n{\n  struct MHD_DigestAuthUsernameInfo *username_info;\n  struct UserEntry *user_entry;\n  void *userdigest;\n  size_t userdigest_size;\n  enum MHD_DigestAuthResult auth_res;\n\n  username_info = MHD_digest_auth_get_username3 (c);\n\n  if (NULL == username_info)\n    return reply_with_auth_required (c, 0, 0);\n\n  user_entry = find_entry_by_userinfo (username_info);\n\n  if (NULL == user_entry)\n    return reply_with_auth_required (c, 0, 1);\n\n  switch (username_info->algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n    userdigest = user_entry->userdigest_md5;\n    userdigest_size = sizeof(user_entry->userdigest_md5);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n    userdigest = user_entry->userdigest_sha256;\n    userdigest_size = sizeof(user_entry->userdigest_sha256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n    userdigest = user_entry->userdigest_sha512_256;\n    userdigest_size = sizeof(user_entry->userdigest_sha512_256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION:\n    /* Not supported currently and not used by MHD.\n       The client incorrectly used algorithm not advertised by the server. */\n    return reply_with_auth_required (c, 0, 1);\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning */\n  default:\n    return MHD_NO; /* Should be unreachable */\n  }\n\n  auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM, /* Make sure to use the proper realm, not the realm provided by the client and returned by \"user_entry\" */\n    user_entry->username,\n    userdigest,\n    userdigest_size,\n    0, /* Use daemon's default value for nonce_timeout*/\n    0, /* Use daemon's default value for max_nc */\n    get_m_QOP (),\n    (enum MHD_DigestAuthMultiAlgo3) username_info->algo3 /* Direct cast from \"single algorithm\" to \"multi-algorithm\" is allowed */\n    );\n\n  if (MHD_DAUTH_OK != auth_res)\n  {\n    int need_just_refresh_nonce;\n    /* Actually MHD_DAUTH_NONCE_OTHER_COND should not be returned as\n       MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE is not used for the daemon.\n       To keep the code universal the MHD_DAUTH_NONCE_OTHER_COND is\n       still checked here. */\n    need_just_refresh_nonce =\n      (MHD_DAUTH_NONCE_STALE == auth_res)\n      || (MHD_DAUTH_NONCE_OTHER_COND == auth_res);\n    return reply_with_auth_required (c,\n                                     need_just_refresh_nonce,\n                                     ! need_just_refresh_nonce);\n  }\n\n  /* The user successfully authenticated */\n\n  /* Check whether access to the request area is allowed for the user */\n  if (1 == sec_area_num)\n  {\n    if (user_entry->allow_area_1)\n      return reply_with_area1_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n  else if (2 == sec_area_num)\n  {\n    if (user_entry->allow_area_2)\n      return reply_with_area2_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n\n  return MHD_NO; /* Should be unreachable */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf struct UserEntry declares userdigest_md5 as a pointer (e.g. unsigned char *userdigest_md5) or otherwise does not make sizeof(user_entry->userdigest_md5) equal to the actual allocated/valid digest length, the computed userdigest_size can be incorrect. That incorrect size is passed to MHD_digest_auth_check_digest3 which likely uses string.h routines (memcmp/memcpy/etc.) with that size; if userdigest_size is larger than the actual buffer allocation, the library calls will read/write beyond the buffer bounds (out\u2011of\u2011bounds access). Example: on a 64\u2011bit target sizeof(user_entry->userdigest_md5) == 8 (pointer size) but the dynamically allocated digest buffer is only 4 bytes \u2014 memcmp with size==8 will overrun the buffer.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent\u0002s report is correct as a potential MISRA Rule 21.17 violation. The code computes userdigest and userdigest_size using sizeof(user_entry->userdigest_md5) (and similar) and then passes those to MHD_digest_auth_check_digest3. If the fields in struct UserEntry are arrays with sizes equal to the actual digest length (e.g. unsigned char userdigest_md5[16]), sizeof yields the correct buffer length and there is no problem. However, if those fields are pointers (e.g. unsigned char *userdigest_md5) or otherwise do not reflect the actual allocated/valid digest length, sizeof(user_entry->userdigest_md5) yields the size of the pointer (or an incorrect value) and userdigest_size can be larger than the actual buffer. If MHD_digest_auth_check_digest3 uses string.h functions (memcmp/memcpy/etc.) with that size, that will result in out-of-bounds accesses and thus violate MISRA C 2023 Rule 21.17.\n\nTherefore the claim is valid as a real (conditional) violation: the code is unsafe unless the definition of UserEntry guarantees that the digest members are fixed-size arrays whose sizeof equals the true digest length. To fix: ensure UserEntry stores digests in fixed-size arrays of known length (use explicit constants) or explicitly store/compute the actual digest length in a separate field and pass that length to the call, rather than relying on sizeof on a member that could be a pointer."
}