{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_finish code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_finish.\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen compiled with _MHD_PUT_64BIT_BE_UNALIGNED not defined and MHD_FAVOR_SMALL_CODE defined, the preprocessor removes the second operand and the controlling expression becomes the constant 'if (1)' (an invariant true). This is a non\u2011permitted invariant controlling expression and therefore violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=3 count_bits_hi=0\nnum_bits computed=24\nbytes_have before pad=3\nwrote 0x80 at buffer index 3; bytes_have now=4\nno block-splitting needed: bytes_have=4, space_left=124\npadded rest of buffer with zeros from index 4 to 111\nput length hi=0 lo=24 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=5982062501088730873 H[1]=11181920792563449259 H[2]=16483967135840496966 H[3]=16204779602120781603\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=112 count_bits_hi=0\nnum_bits computed=896\nbytes_have before pad=112\nwrote 0x80 at buffer index 112; bytes_have now=113\nentering block-splitting branch: bytes_have=113, space_left=15\ncalling sha512_256_transform for full block (split case)\nstarted new block, bytes_have reset to 0\npadded rest of buffer with zeros from index 0 to 111\nput length hi=0 lo=896 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=4118789820502151416 H[1]=4673110819932549566 H[2]=7335129311881389588 H[3]=8064478405482731066\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=0 count_bits_hi=0\nnum_bits computed=0\nbytes_have before pad=0\nwrote 0x80 at buffer index 0; bytes_have now=1\nno block-splitting needed: bytes_have=1, space_left=127\npadded rest of buffer with zeros from index 1 to 111\nput length hi=0 lo=0 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=14299694978657873192 H[1]=12360062528759337990 H[2]=11231197743927620468 H[3]=11011512327474288250\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=28 count_bits_hi=0\nnum_bits computed=224\nbytes_have before pad=28\nwrote 0x80 at buffer index 28; bytes_have now=29\nno block-splitting needed: bytes_have=29, space_left=99\npadded rest of buffer with zeros from index 29 to 111\nput length hi=0 lo=224 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=14446521026478545895 H[1]=7583024354056567929 H[2]=16816617036619197295 H[3]=12212534725173581733\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=14 count_bits_hi=0\nnum_bits computed=112\nbytes_have before pad=14\nwrote 0x80 at buffer index 14; bytes_have now=15\nno block-splitting needed: bytes_have=15, space_left=113\npadded rest of buffer with zeros from index 15 to 111\nput length hi=0 lo=112 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=16053991823140167925 H[1]=17313362533049241077 H[2]=4081665001769008985 H[3]=13548097405206016598\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=26 count_bits_hi=0\nnum_bits computed=208\nbytes_have before pad=26\nwrote 0x80 at buffer index 26; bytes_have now=27\nno block-splitting needed: bytes_have=27, space_left=101\npadded rest of buffer with zeros from index 27 to 111\nput length hi=0 lo=208 into buffer positions 14 and 15\ncalling sha512_256_transform for final block\ntaking direct-write branch (in-place). digest=0x7ffc53634920\nH[0]=18172456897634641551 H[1]=7091737886136380391 H[2]=13197429682005127298 H[3]=2463799742315956774\ndirect-write branch completed\nMHD_SHA512_256_finish end: context cleared\nMHD_SHA512_256_finish start: ctx=0x7ffc53634948 digest=0x7ffc53634920 count=26 count_bits_hi=0\nnum_bits computed=208\nbytes_have before pad=26\nwrote 0x80 at buffer index 26; byte\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. With _MHD_PUT_64BIT_BE_UNALIGNED not defined and MHD_FAVOR_SMALL_CODE defined, the preprocessor removes the inner '&& ...' term and the first conditional becomes literally\n  if (1)\nwhich is an invariant (always-true) controlling expression in the compiled translation unit. MISRA C 2023 Rule 14.3 forbids invariant controlling expressions except for the specific permitted cases (infinite loops or the do-while false exception), neither of which applies here. The alternative branches that would make the condition non-invariant are removed by the preprocessor in the reported configuration, so the compiled code violates Rule 14.3."
}