{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe if statement uses a constant controlling expression 'if (1)' which is invariant (always true). This is not one of the permitted exceptions (it is not creating an infinite loop nor a do-while with a false integer constant expression). Therefore the conditional with invariant expression violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957417, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198967\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957417\nEXIT: gettime_start=1756198967, sys_clock_start=1756198967\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957417, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198967\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957417\nEXIT: gettime_start=1756198967, sys_clock_start=1756198967\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957418, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198967\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957418\nEXIT: gettime_start=1756198967, sys_clock_start=1756198967\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957418, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198968\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957418\nEXIT: gettime_start=1756198968, sys_clock_start=1756198968\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957418, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198968\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957418\nEXIT: gettime_start=1756198968, sys_clock_start=1756198968\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957418, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198968\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957418\nEXIT: gettime_start=1756198968, sys_clock_start=1756198968\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957421, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198971\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957421\nEXIT: gettime_start=1756198971, sys_clock_start=1756198971\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957422, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198972\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957422\nEXIT: gettime_start=1756198972, sys_clock_start=1756198972\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957423, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198973\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957423\nEXIT: gettime_start=1756198973, sys_clock_start=1756198973\n-----------------------------\nENTER: MHD_monotonic_sec_counter_init\ninitial mono_clock_source=0\ninitial mono_clock_id=0\nBRANCH: CLOCK_MONOTONIC_COARSE taken\nmono_clock_id=6, mono_clock_start=10957426, mono_clock_source=1\nTIMESPEC_GET: gettime_start=1756198976\nEXIT: final mono_clock_source=1\nEXIT: final mono_clock_id=6, mono_clock_start=10957426\nEXIT: gettime_start=1756198976, sys_clock_start=1756198976\n-----------------------------\nENTER: MHD_monotonic_sec_counter_ini\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function contains several if statements with constant controlling expressions (for example the initial if (0) used as a preprocessor/flow trick and multiple if (1) occurrences in the _WIN32, HAVE_GETHRTIME, and timespec_get/gettimeofday branches). MISRA C 2023 Rule 14.3 prohibits invariant controlling expressions except for the two listed exceptions (infinite loops via invariants, and a do-while with an essentially Boolean false integer constant expression). The invariant if (1) / if (0) constructs in this code are neither infinite loops nor a permitted do-while false constant, so they violate Rule 14.3. To remediate, replace these constant ifs with appropriate preprocessor conditionals (#if / #elif / #else) or rewrite using a do { ... } while (0) idiom where the Rule 14.3 exception for a false do-while applies, or otherwise restructure so the controlling expressions are not invariant."
}