{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment contains an if (1) { ... } else ... construct. Because the condition is a compile-time constant true, the else branch (and all code in the remainder of the chained if/else sequence that is intended to be the else-path) is unreachable at run time in this configuration. This yields unreachable code (e.g. the else-path that eventually would lead to the final fallback \"mono_clock_source = _MHD_CLOCK_NO_SOURCE;\"), violating MISRA C 2023 Rule 2.1.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958270\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199820\nsys_clock_start=1756199820\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958271\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199821\nsys_clock_start=1756199821\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958271\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199821\nsys_clock_start=1756199821\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958271\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199821\nsys_clock_start=1756199821\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958272\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199822\nsys_clock_start=1756199822\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958272\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199822\nsys_clock_start=1756199822\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958275\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199825\nsys_clock_start=1756199825\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958276\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199826\nsys_clock_start=1756199826\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958276\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199826\nsys_clock_start=1756199826\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958279\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199829\nsys_clock_start=1756199829\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958279\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199829\nsys_clock_start=1756199829\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958280\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199829\nsys_clock_start=1756199829\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958283\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199833\nsys_clock_start=1756199833\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958284\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199834\nsys_clock_start=1756199834\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958284\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199834\nsys_clock_start=1756199834\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958288\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199838\nsys_clock_start=1756199838\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLOCK_MONOTONIC_COARSE, ts.tv_sec=10958288\nPost selection mono_clock_source=1\ntimespec_get succeeded, gettime_start=1756199838\nsys_clock_start=1756199838\nMHD_monotonic_sec_counter_init: exit\nMHD_monotonic_sec_counter_init: enter\nSelected CLO\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function uses compile-time constant conditionals (for example the Win32 and gethrtime branches use if (1) { ... } else and the code is structured with preprocessor blocks to chain these if/else clauses). When those preprocessor symbols are set for a given build the compiled translation unit contains an if (1) with a corresponding else branch that can never be executed, so that else-path (and any code in the remainder of that chained if/else sequence that is intended as the else-path) is statically unreachable. MISRA C:2023 Rule 2.1 prohibits unreachable code in the project, so the presence of such compile-time-constant true conditionals producing unreachable else-branches violates the rule. If this is intended for portability, the correct remediation is to remove unreachable branches from the translation unit (e.g. resolve the selection with preprocessor conditionals rather than if (1)/else), or otherwise restructure to avoid compile-time-constant conditionals that leave dead code in the built project."
}