{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe conditional statement uses a constant true expression (if (1)) so the test and branch machinery are executed but have no effect on behaviour. The \u2018if (1)\u2019 is therefore dead code: removing the if and braces (leaving the enclosed gettimeofday call and assignments) would not change program behaviour. This violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957505, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957347, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957505, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957505, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199055\nsys_clock_start=1756199055\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957505\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957506, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957347, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957506, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957506, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199056\nsys_clock_start=1756199056\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957506\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957506, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957347, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957506, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957506, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199056\nsys_clock_start=1756199056\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957506\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957506, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957347, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957506, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957506, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199056\nsys_clock_start=1756199056\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957506\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957507, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957348, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957507, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957507, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199057\nsys_clock_start=1756199057\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957507\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957507, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957348, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957507, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957507, source=1\nno suitable clock source found: source=0\nevaluating timespec_get branch (if (1))\ntimespec_get succeeded: gettime_start=1756199057\nsys_clock_start=1756199057\nMHD_monotonic_sec_counter_init: exit with mono_clock_source=0, mono_clock_id=1, mono_clock_start=10957507\nMHD_monotonic_sec_counter_init: entry\ntrying CLOCK_MONOTONIC_COARSE\nselected CLOCK_MONOTONIC_COARSE: start=10957510, source=1\ntrying CLOCK_MONOTONIC_RAW\nselected CLOCK_MONOTONIC_RAW: start=10957351, source=1\ntrying CLOCK_BOOTTIME\nselected CLOCK_BOOTTIME: start=10957510, source=1\ntrying CLOCK_MONOTONIC\nselected CLOCK_MONOTONIC: start=10957510, source=1\nno suitable clock source found: source=0\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C 2023 Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. The occurrences of if (1) in this function are a deliberate syntactic device to build a long if/else-if chain across many #ifdef blocks (the initial if (0) { } else trick). Those constant-true tests are not merely gratuitous: they control the pairing of else clauses produced by the preprocessor and allow mutually-exclusive platform branches to be composed in source. Removing the if (1) tokens (or changing the branching structure) can change how the surrounding else keywords associate with preceding conditionals and thus can change which platform-specific branch is selected \u2014 so removal can affect program behaviour. In addition the guarded bodies contain side-effecting calls (e.g. gettimeofday, timespec_get, QueryPerformanceCounter etc.), so the enclosing if controls execution of code with effects. Therefore these if (1) constructs should not be considered dead code under Rule 2.2 and the reported violation is incorrect."
}