{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nTrue. The initializer is redundant in typical configurations: mono_clock_source is always assigned along the subsequent if/else/#ifdef chain (including the final fallback that sets _MHD_CLOCK_NO_SOURCE), or it is never used (when HAVE_CLOCK_GET_TIME is not defined the code only does (void) mono_clock_source). In those builds the initial assignment enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE; is executed but has no effect on program behaviour, so it constitutes dead code and thus violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955965 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197515\nfinal mono_clock_source = 1, sys_clock_start = 1756197515\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955965 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197515\nfinal mono_clock_source = 1, sys_clock_start = 1756197515\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955965 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197515\nfinal mono_clock_source = 1, sys_clock_start = 1756197515\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955966 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197516\nfinal mono_clock_source = 1, sys_clock_start = 1756197516\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955966 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197516\nfinal mono_clock_source = 1, sys_clock_start = 1756197516\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955966 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197516\nfinal mono_clock_source = 1, sys_clock_start = 1756197516\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955969 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197519\nfinal mono_clock_source = 1, sys_clock_start = 1756197519\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955970 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197520\nfinal mono_clock_source = 1, sys_clock_start = 1756197520\nMHD_monotonic_sec_counter_init: exit\n\nMHD_monotonic_sec_counter_init: enter\ninitial mono_clock_source = 0\nbranch: CLOCK_MONOTONIC_COARSE -> mono_clock_id=6 mono_clock_start=10955970 mono_clock_source=1\nnote: HAVE_CLOCK_GET_TIME not defined, mono_clock_source may be unused -> 1\ntimespec_get -> gettime_start=1756197520\nfinal mono_clock_source = 1, sys_clock_start = 1756197520\nMHD_monotonic_sec_counter_init: exit\n\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 2.2 excludes initializations from consideration as dead code (note 3: \u201cInitialization is not the same as an assignment operation and is therefore not a candidate for dead code\u201d). The statement\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\nis an initializer at definition, so it cannot be classified as dead code under Rule 2.2. Moreover, across different conditional-compilation configurations the initializer can be meaningful (and there is a final fallback path that explicitly sets the value). Even if in a particular build the variable is later overwritten or only used to suppress a warning ((void) mono_clock_source), that does not make the initializer a Rule 2.2 violation. Therefore the agent A claim is incorrect."
}