{
  "user_message": "An agent A claimed that the following calc_userdigest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of calc_userdigest.\n```c\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes 'password' which is declared as 'const char *' to digest_update_str. If digest_update_str is declared to take a non-const pointer (e.g. 'char *' or 'char []'), this discards the const qualifier and therefore violates MISRA C 2023 Rule 8.13. For example, a prototype like 'void digest_update_str(struct DigestAlgorithm *da, char *s);' would be a violation because the parameter should be 'const char *s' instead.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible. In the shown calc_userdigest implementation all string parameters (username, realm, password) are already declared const char *, so calc_userdigest itself complies with that intent.\n\nAgent A's claim hinges on the prototype of digest_update_str. If digest_update_str is declared to take a non-const pointer (for example: void digest_update_str(struct DigestAlgorithm *da, char *s)), then that declaration would be the actual rule violation (it should be void digest_update_str(..., const char *s) if the function does not modify the pointed data). Passing a const char * to a parameter declared as char * would also be incompatible with the C type system (qualifier discarded) and would typically require an explicit cast or produce a compiler diagnostic. However, the digest_update_str prototype is not shown in the provided code, so we cannot conclude that calc_userdigest violates Rule 8.13.\n\nConclusion: the report is not correct as stated \u2014 a violation would only exist if the callee's prototype lacks const, in which case the violation resides in that prototype (and the call would be ill-formed without a cast), not in calc_userdigest as shown. Recommendation: ensure digest_update_str is declared to take const char * if it does not modify the string argument."
}