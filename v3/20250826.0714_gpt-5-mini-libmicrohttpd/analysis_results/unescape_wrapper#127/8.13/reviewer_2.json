{
  "user_message": "An agent A claimed that the following unescape_wrapper code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of unescape_wrapper.\n```c\nstatic size_t\nunescape_wrapper (void *cls,\n                  struct MHD_Connection *connection,\n                  char *val)\n{\n  bool broken;\n  size_t res;\n  (void) cls; /* Mute compiler warning. */\n\n  /* TODO: add individual parameter */\n  if (0 <= connection->daemon->client_discipline)\n    return MHD_str_pct_decode_in_place_strict_ (val);\n\n  res = MHD_str_pct_decode_in_place_lenient_ (val, &broken);\n#ifdef HAVE_MESSAGES\n  if (broken)\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"The URL encoding is broken.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  return res;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter 'cls' is declared as 'void *cls' but is not used or modified in the function (it's only cast to void to suppress an unused-parameter warning). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible, so the parameter should be declared 'const void *cls' (or removed) rather than 'void *cls'. The '(void) cls;' cast only suppresses the warning and does not address the const-qualification requirement.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=2\n\n[unescape_wrapper] stage=entry note=cls is unused (cast to void)\n  connection=0x55fef1ea3270\n  daemon=0x55fef1ea08d0\n  client_discipline=0\n  val=0x55fef1ea34c4\n  broken=0 res=0\n\n[unescape_wrapper] stage=strict-path note=took strict path\n  connect\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not necessarily. MISRA C 2023 R.8.13 says a pointer should point to a const-qualified type whenever possible. If unescape_wrapper is a local function under your control and there is no external prototype it must match, then the parameter should indeed be declared const void *cls (or removed) and Agent A\u2019s point would be correct. However, the cast (void)cls only suppresses an unused-parameter warning and does not address const-qualification \u2014 but that alone doesn\u2019t prove a violation of R.8.13.\n\nIn practice unescape_wrapper appears to be a callback that must match an external API (the MHD_* family) whose callback prototype commonly takes void *cls (a user context pointer). When a function must conform to an externally dictated non-const prototype, it is not possible to change the parameter to const without breaking the required signature; MISRA\u2019s \u201cwhenever possible\u201d is understood to permit such necessary exceptions. In that situation the current declaration is acceptable and there is no R.8.13 violation. If, instead, this function is not constrained by an external prototype, then Agent A\u2019s report would be correct and the parameter should be const-qualified or removed.\n\nRecommendation: if the function must match an external callback type, document the justification for not making cls const (e.g. comment or MISRA deviation record). If it is not constrained, change the prototype to const void *cls (or remove the parameter) to satisfy R.8.13."
}