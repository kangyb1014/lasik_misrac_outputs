{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code only checks that content != NULL but does not ensure it is NUL-terminated or within a known length before calling strlen(content). If content points to a char buffer that lacks a terminating '\\0' within its allocated bounds (for example a buffer of size N filled by a previous operation without writing a terminator), strlen will scan past the buffer until it finds a '\\0', causing out-of-bounds reads. Those incorrect length results are then used in memcmp(content, ...) which can further read beyond the object's bounds. Therefore the use of strlen(content) can result in accesses beyond the bounds of the object and violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b01f, content=0x561418e5b02d\nMHD_del_response_header: computed header_len=13 for header@0x561418e5b01f\nMHD_del_response_header: about to call strlen(content) for content@0x561418e5b02d\nMHD_del_response_header: computed content_len=8 for content@0x561418e5b02d\nMHD_del_response_header: examining header node pos=0x561425caf920 header_size=13 value_size=8\nMHD_del_response_header: match found at pos=0x561425caf920; removing header\nMHD_del_response_header: header removed successfully; returning MHD_YES\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b01f, content=0x561418e5b087\nMHD_del_response_header: computed header_len=13 for header@0x561418e5b01f\nMHD_del_response_header: about to call strlen(content) for content@0x561418e5b087\nMHD_del_response_header: computed content_len=8 for content@0x561418e5b087\nMHD_del_response_header: examining header node pos=0x561425caf9a0 header_size=13 value_size=8\nMHD_del_response_header: examining header node pos=0x561425cafbc0 header_size=13 value_size=8\nMHD_del_response_header: match found at pos=0x561425cafbc0; removing header\nMHD_del_response_header: header removed successfully; returning MHD_YES\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b09e, content=0x561418e5b087\nMHD_del_response_header: computed header_len=13 for header@0x561418e5b09e\nMHD_del_response_header: about to call strlen(content) for content@0x561418e5b087\nMHD_del_response_header: computed content_len=8 for content@0x561418e5b087\nMHD_del_response_header: examining header node pos=0x561425caf9a0 header_size=13 value_size=8\nMHD_del_response_header: no matching header found; returning MHD_NO\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b01f, content=0x561418e5b0ca\nMHD_del_response_header: computed header_len=13 for header@0x561418e5b01f\nMHD_del_response_header: about to call strlen(content) for content@0x561418e5b0ca\nMHD_del_response_header: computed content_len=7 for content@0x561418e5b0ca\nMHD_del_response_header: examining header node pos=0x561425caf9a0 header_size=13 value_size=8\nMHD_del_response_header: no matching header found; returning MHD_NO\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b14d\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b18e\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b2e1\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b396\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b437\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b4a5\nMHD_del_response_header: computed header_len=10 for header@0x561418e5b0f6\nMHD_del_response_header: special-case CONNECTION header matched; delegating to del_response_header_connection\nMHD_del_response_header: entry; response=0x561425caf820, header=0x561418e5b0f6, content=0x561418e5b4a3\nMHD_del_response_header: computed\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 21.17 forbids calling the C string functions in a way that can read past the bounds of the object pointed to. In this function strlen(content) is called after only checking content != NULL; there is no local check that the object referenced by content actually contains a terminating '\\0' within its allocated bounds. If a caller passes a buffer that is not NUL-terminated (or otherwise not guaranteed to contain a terminating byte within its storage), strlen will scan past the buffer and perform out-of-bounds reads \u2014 and the resulting content_len is then used in memcmp, propagating the unsafe access. That is exactly the scenario described by the agent, so the report is correct unless there is an external, provable API contract (documented and enforced elsewhere) that guarantees content is a NUL-terminated string. Without such a guarantee this usage violates Rule 21.17."
}