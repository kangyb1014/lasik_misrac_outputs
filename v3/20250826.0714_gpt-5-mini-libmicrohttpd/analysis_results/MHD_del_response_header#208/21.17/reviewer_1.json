{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strlen(header) assumes 'header' points to a NUL-terminated char array. If the caller passes a non\u2011NUL\u2011terminated buffer (e.g. char h[3] = {'A','B','C'}; MHD_del_response_header(resp, h, \"content\");) strlen will read past the object bounds and cause an out\u2011of\u2011bounds access/UB. This violates Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb01f\n  content=0x5564335bb02d\n  response->first_header=0x5564513ec920 flags_auto=0x0\nafter strlen(header): header_len=13\nafter strlen(content): content_len=8\nmatch found: pos=0x5564513ec920 header_size=13 value_size=8\n  pos->header=0x5564513ec8e0 pos->value=0x5564513ec900\nreturning MHD_YES\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb01f\n  content=0x5564335bb087\n  response->first_header=0x5564513ec9a0 flags_auto=0x0\nafter strlen(header): header_len=13\nafter strlen(content): content_len=8\nmatch found: pos=0x5564513ecbc0 header_size=13 value_size=8\n  pos->header=0x5564513ec900 pos->value=0x5564513ec8e0\nreturning MHD_YES\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb09e\n  content=0x5564335bb087\n  response->first_header=0x5564513ec9a0 flags_auto=0x0\nafter strlen(header): header_len=13\nafter strlen(content): content_len=8\nno matching header found, returning MHD_NO\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb01f\n  content=0x5564335bb0ca\n  response->first_header=0x5564513ec9a0 flags_auto=0x0\nafter strlen(header): header_len=13\nafter strlen(content): content_len=7\nno matching header found, returning MHD_NO\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb14d\n  response->first_header=0x5564513ecc00 flags_auto=0x1\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb18e\n  response->first_header=0x5564513ecc70 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb2e1\n  response->first_header=0x5564513eccb0 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb396\n  response->first_header=0x5564513eccb0 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb437\n  response->first_header=0x5564513eccb0 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb4a5\n  response->first_header=0x5564513eccb0 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb4a3\n  response->first_header=0x5564513eccb0 flags_auto=0x1\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb95d\n  response->first_header=0x5564513ecd10 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb595\n  response->first_header=0x5564513ecd50 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb589\n  response->first_header=0x5564513ecd50 flags_auto=0x1\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  header=0x5564335bb0f6\n  content=0x5564335bb603\n  response->first_header=0x5564513ecd90 flags_auto=0x3\nafter strlen(header): header_len=10\ntaking special branch: del_response_header_connection\nENTER MHD_del_response_header\n  response=0x5564513ec820\n  head\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.17 requires that uses of string.h functions must not cause accesses beyond the bounds of the objects passed. In the posted function strlen() is invoked on both header and content; strlen will scan until a NUL byte and therefore will read out-of-bounds if the caller supplies a non\u2011NUL\u2011terminated buffer.\n\nHowever, that alone does not prove a MISRA violation in this function. The rule is about ensuring that, in the delivered code, those calls cannot result in out\u2011of\u2011bounds accesses. In typical C APIs that accept const char * for header and content, the established and intended contract is that the caller provides NUL\u2011terminated C strings. Given that contract the calls to strlen and the subsequent bounded memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) are consistent and do not themselves read beyond the computed lengths. The function also checks for NULL pointers before calling strlen.\n\nAgent A\u2019s scenario (a caller passing a non\u2011NUL\u2011terminated buffer) describes a caller misuse that would indeed lead to undefined behaviour, but that misuse does not automatically mean the implementation violates 21.17: compliance can be achieved by a documented precondition that the arguments are NUL\u2011terminated strings (or by other program-level invariants ensuring termination). There is no evidence in the code shown that the function is expected to accept non\u2011terminated buffers, nor that the implementation causes out\u2011of\u2011bounds accesses if the API contract is respected.\n\nTherefore the reported violation is not correct as a proven violation of MISRA Rule 21.17. If you want to be defensive or to satisfy stricter interpretation, you can (a) document the NUL\u2011terminated precondition explicitly, (b) add length parameters to the API, or (c) use safer/bounded string-handling patterns, but those are recommendations rather than proof that the existing code violates the rule.\n"
}