{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code computes header_len = strlen(header) (and content_len = strlen(content)) and then calls memcmp(header, pos->header, header_len) (and memcmp(content, pos->value, content_len)). Because header and content are null-terminated strings (strlen was used), using memcmp to compare them violates MISRA C 2023 Rule 21.14.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_del_response_header ENTRY: response=0x5580eefd3820 header=0x5580c814901f content=0x5580c814902d\nheader_len=13 flags_auto=0x00000000\ncontent_len=8\nheader (caller): len=13\n  bytes[0..13): 4865616465722d547970652d41\ncontent (caller): len=8\n  bytes[0..8): 76616c75652d6131\nvisiting pos=0x5580eefd3920 header_size=13 value_size=8 pos->header=0x5580eefd38e0 pos->value=0x5580eefd3900\npos->header (stored): len=13\n  bytes[0..13): 4865616465722d547970652d41\npos->value (stored): len=8\n  bytes[0..8): 76616c75652d6131\nAbout to evaluate match condition: (header_len==pos->header_size) && (content_len==pos->value_size) && memcmp(header,pos->header,header_len)==0 && memcmp(content,pos->value,pos->value_size)==0\nEvaluating sizes: header_len=13 pos->header_size=13 content_len=8 pos->value_size=8\nMatch found: removing header at pos=0x5580eefd3920\nAfter removal, flags_auto=0x00000000\nMHD_del_response_header ENTRY: response=0x5580eefd3820 header=0x5580c814901f content=0x5580c8149087\nheader_len=13 flags_auto=0x00000000\ncontent_len=8\nheader (caller): len=13\n  bytes[0..13): 4865616465722d547970652d41\ncontent (caller): len=8\n  bytes[0..8): 76616c75652d6133\nvisiting pos=0x5580eefd39a0 header_size=13 value_size=8 pos->header=0x5580eefd3960 pos->value=0x5580eefd3980\npos->header (stored): len=13\n  bytes[0..13): 4865616465722d547970652d41\npos->value (stored): len=8\n  bytes[0..8): 76616c75652d6132\nAbout to evaluate match condition: (header_len==pos->header_size) && (content_len==pos->value_size) && memcmp(header,pos->header,header_len)==0 && memcmp(content,pos->value,pos->value_size)==0\nEvaluating sizes: header_len=13 pos->header_size=13 content_len=8 pos->value_size=8\nvisiting pos=0x5580eefd3bc0 header_size=13 value_size=8 pos->header=0x5580eefd3900 pos->value=0x5580eefd38e0\npos->header (stored): len=13\n  bytes[0..13): 4865616465722d547970652d41\npos->value (stored): len=8\n  bytes[0..8): 76616c75652d6133\nAbout to evaluate match condition: (header_len==pos->header_size) && (content_len==pos->value_size) && memcmp(header,pos->header,header_len)==0 && memcmp(content,pos->value,pos->value_size)==0\nEvaluating sizes: header_len=13 pos->header_size=13 content_len=8 pos->value_size=8\nMatch found: removing header at pos=0x5580eefd3bc0\nAfter removal, flags_auto=0x00000000\nMHD_del_response_header ENTRY: response=0x5580eefd3820 header=0x5580c814909e content=0x5580c8149087\nheader_len=13 flags_auto=0x00000000\ncontent_len=8\nheader (caller): len=13\n  bytes[0..13): 4865616465722d547970652d43\ncontent (caller): len=8\n  bytes[0..8): 76616c75652d6133\nvisiting pos=0x5580eefd39a0 header_size=13 value_size=8 pos->header=0x5580eefd3960 pos->value=0x5580eefd3980\npos->header (stored): len=13\n  bytes[0..13): 4865616465722d547970652d41\npos->value (stored): len=8\n  bytes[0..8): 76616c75652d6132\nAbout to evaluate match condition: (header_len==pos->header_size) && (content_len==pos->value_size) && memcmp(header,pos->header,header_len)==0 && memcmp(content,pos->value,pos->value_size)==0\nEvaluating sizes: header_len=13 pos->header_size=13 content_len=8 pos->value_size=8\nNo matching header/value found -> return MHD_NO\nMHD_del_response_header ENTRY: response=0x5580eefd3820 header=0x5580c814901f content=0x5580c81490ca\nheader_len=13 flags_auto=0x00000000\ncontent_len=7\nheader (caller): len=13\n  bytes[0..13): 4865616465722d547970652d41\ncontent (caller): len=7\n  bytes[0..7): 76616c75652d63\nvisiting pos=0x5580eefd39a0 header_size=13 value_size=8 pos->header=0x5580eefd3960 pos->value=0x5580eefd3980\npos->header (stored): len=13\n  bytes[0..13): 4865616465722d547970652d41\npos->value (stored): len=8\n  bytes[0..8): 76616c75652d6132\nAbout to evaluate match condition: (header_len==pos->header_size) && (content_len==pos->value_size) && memcmp(header,pos->header,header_len)==0 && memcmp(content,pos->value,pos->value_size)==0\nEvaluating sizes: header_len=13 pos->header_size=13 content_len=7 pos->value_size=8\nNo matching header/value found -> return MHD_NO\nMHD_del_response_header ENTRY: response=0x5580eefd3820 header=0x5580c81490f6 content=0x5580c814914d\nheader_len=10 flags_auto=0x00000001\nSpecial-case:\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes header_len = strlen(header) and content_len = strlen(content) (i.e. header and content are treated as null\u2011terminated strings) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to test equality. MISRA C 2023 Rule 21.14 prohibits using the standard memcmp function to compare null\u2011terminated strings. Even though the code compares only the character bytes (not the terminating NUL) and guards the comparisons with explicit lengths, it is still using memcmp to compare values derived from strlen (null\u2011terminated strings), so this violates Rule 21.14.\n\nNote: if pos->header/pos->value are truly binary buffers (not NUL\u2011terminated) and the intent is a binary comparison, memcmp would be appropriate \u2014 however in this function the caller arguments are strings (strlen was used), so the intent is string comparison and memcmp is disallowed. To fix, use an appropriate string comparison (e.g. strcmp/strncmp or an existing MHD string comparison helper) or otherwise ensure both operands are non\u2011string binary buffers and document that intent."
}