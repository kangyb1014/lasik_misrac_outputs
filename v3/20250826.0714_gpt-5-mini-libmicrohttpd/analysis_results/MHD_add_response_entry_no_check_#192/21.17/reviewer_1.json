{
  "user_message": "An agent A claimed that the following MHD_add_response_entry_no_check_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_entry_no_check_.\n```c\nbool\nMHD_add_response_entry_no_check_ (struct MHD_Response *response,\n                                  enum MHD_ValueKind kind,\n                                  const char *header,\n                                  size_t header_len,\n                                  const char *content,\n                                  size_t content_len)\n{\n  char *header_malloced;\n  char *value_malloced;\n\n  mhd_assert (0 != header_len);\n  mhd_assert (0 != content_len);\n  header_malloced = malloc (header_len + 1);\n  if (NULL == header_malloced)\n    return false;\n\n  memcpy (header_malloced, header, header_len);\n  header_malloced[header_len] = 0;\n\n  value_malloced = malloc (content_len + 1);\n  if (NULL != value_malloced)\n  {\n    memcpy (value_malloced, content, content_len);\n    value_malloced[content_len] = 0;\n\n    if (MHD_add_response_entry_no_alloc_ (response, kind,\n                                          header_malloced, header_len,\n                                          value_malloced, content_len))\n      return true; /* Success exit point */\n\n    free (value_malloced);\n  }\n  free (header_malloced);\n\n  return false; /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe destination (header_malloced) is allocated with header_len+1 bytes, so the write side is safe. However the source pointer 'header' is not validated; if the caller passes a NULL pointer or a buffer shorter than header_len (e.g. header = \"short\" but header_len = 10), memcpy(header_malloced, header, header_len) will read beyond the bounds of the object referenced by 'header'. The mhd_assert(0 != header_len) does not protect against a NULL or too-small source when assertions are disabled. Thus the code can violate Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff19701f header_len=13 content=0x55edff19702d content_len=8\nmalloc(header_len+1=14) -> header_malloced=0x55ee139c2ac0\nAbout to memcpy(header_malloced=0x55ee139c2ac0, header=0x55edff19701f, header_len=13)\nCompleted memcpy into header_malloced=0x55ee139c2ac0; header_malloced[header_len]=0 set\nmalloc(content_len+1=9) -> value_malloced=0x55ee139c2ae0\nAbout to memcpy(value_malloced=0x55ee139c2ae0, content=0x55edff19702d, content_len=8)\nCompleted memcpy into value_malloced=0x55ee139c2ae0; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff19701f header_len=13 content=0x55edff19704d content_len=8\nmalloc(header_len+1=14) -> header_malloced=0x55ee139c2b40\nAbout to memcpy(header_malloced=0x55ee139c2b40, header=0x55edff19701f, header_len=13)\nCompleted memcpy into header_malloced=0x55ee139c2b40; header_malloced[header_len]=0 set\nmalloc(content_len+1=9) -> value_malloced=0x55ee139c2b60\nAbout to memcpy(value_malloced=0x55ee139c2b60, content=0x55edff19704d, content_len=8)\nCompleted memcpy into value_malloced=0x55ee139c2b60; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff19701f header_len=13 content=0x55edff197087 content_len=8\nmalloc(header_len+1=14) -> header_malloced=0x55ee139c2ae0\nAbout to memcpy(header_malloced=0x55ee139c2ae0, header=0x55edff19701f, header_len=13)\nCompleted memcpy into header_malloced=0x55ee139c2ae0; header_malloced[header_len]=0 set\nmalloc(content_len+1=9) -> value_malloced=0x55ee139c2ac0\nAbout to memcpy(value_malloced=0x55ee139c2ac0, content=0x55edff197087, content_len=8)\nCompleted memcpy into value_malloced=0x55ee139c2ac0; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff197a16 header_len=4 content=0x55edff197a1b content_len=29\nmalloc(header_len+1=5) -> header_malloced=0x55ee139c2ac0\nAbout to memcpy(header_malloced=0x55ee139c2ac0, header=0x55edff197a16, header_len=4)\nCompleted memcpy into header_malloced=0x55ee139c2ac0; header_malloced[header_len]=0 set\nmalloc(content_len+1=30) -> value_malloced=0x55ee139c2c40\nAbout to memcpy(value_malloced=0x55ee139c2c40, content=0x55edff197a1b, content_len=29)\nCompleted memcpy into value_malloced=0x55ee139c2c40; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff197a16 header_len=4 content=0x55edff197a79 content_len=29\nmalloc(header_len+1=5) -> header_malloced=0x55ee139c2ac0\nAbout to memcpy(header_malloced=0x55ee139c2ac0, header=0x55edff197a16, header_len=4)\nCompleted memcpy into header_malloced=0x55ee139c2ac0; header_malloced[header_len]=0 set\nmalloc(content_len+1=30) -> value_malloced=0x55ee139c2c40\nAbout to memcpy(value_malloced=0x55ee139c2c40, content=0x55edff197a79, content_len=29)\nCompleted memcpy into value_malloced=0x55ee139c2c40; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: response=0x55ee139c2820 kind=1 header=0x55edff197af5 header_len=17 content=0x55edff197b07 content_len=7\nmalloc(header_len+1=18) -> header_malloced=0x55ee139c2ac0\nAbout to memcpy(header_malloced=0x55ee139c2ac0, header=0x55edff197af5, header_len=17)\nCompleted memcpy into header_malloced=0x55ee139c2ac0; header_malloced[header_len]=0 set\nmalloc(content_len+1=8) -> value_malloced=0x55ee139c2ae0\nAbout to memcpy(value_malloced=0x55ee139c2ae0, content=0x55edff197b07, content_len=7)\nCompleted memcpy into value_malloced=0x55ee139c2ae0; value_malloced[content_len]=0 set\nEXIT MHD_add_response_entry_no_check_: success (added response entry)\nENTER MHD_add_response_entry_no_check_: \n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 forbids using string.h functions in ways that can access beyond the bounds of the objects referenced by their pointer parameters. In this function memcpy(header_malloced, header, header_len) and memcpy(value_malloced, content, content_len) read from the source pointers header and content for header_len/content_len bytes, but the code does not ensure that those source objects are valid and at least that large. The mhd_assert checks only header_len/content_len != 0 and is typically disabled in production, so it does not guarantee safety; there are no NULL checks or explicit bounds checks on the source buffers. Therefore the calls can result in out\u2011of\u2011bounds reads (or dereferencing NULL) and violate MISRA C 2023 Rule 21.17."
}