{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_req_headers:\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (! process_footers)\n  handle_req_headers_no_space (c, hdr_name.str, add_element_size);\nelse\n  handle_req_footers_no_space (c, hdr_name.str, add_element_size);",
    "res = get_req_header (c, process_footers, &hdr_name, &hdr_value);",
    "const char *last_elmnt_end;\nsize_t shift_back_size;\nif (NULL != c->rq.headers_received_tail)\n  last_elmnt_end =\n    c->rq.headers_received_tail->value\n    + c->rq.headers_received_tail->value_size;\nelse\n  last_elmnt_end = c->rq.version + HTTP_VER_LEN;",
    "if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n{\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n  mhd_assert (NULL != hdr_name.str);\n  mhd_assert (NULL != hdr_value.str);\n  /* Values must be zero-terminated and must not have binary zeros */\n  mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n  mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n  /* Values must not have whitespaces at the start or at the end */\n  mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n  mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n  mhd_assert ((hdr_name.len == 0) || \\\n              (hdr_name.str[hdr_name.len - 1] != ' '));\n  mhd_assert ((hdr_name.len == 0) || \\\n              (hdr_name.str[hdr_name.len - 1] != '\\t'));\n  mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n  mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n  mhd_assert ((hdr_value.len == 0) || \\\n              (hdr_value.str[hdr_value.len - 1] != ' '));\n  mhd_assert ((hdr_value.len == 0) || \\\n              (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n  if (MHD_NO ==\n      MHD_set_connection_value_n_nocheck_ (c,\n                                           (! process_footers) ?\n                                           MHD_HEADER_KIND :\n                                           MHD_FOOTER_KIND,\n                                           hdr_name.str, hdr_name.len,\n                                           hdr_value.str, hdr_value.len))\n  {\n    size_t add_element_size;\n\n    mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (c->daemon,\n              _ (\"Failed to allocate memory in the connection memory \" \\\n                 \"pool to store %s.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n    add_element_size = hdr_value.len\n                       + (size_t) (hdr_value.str - hdr_name.str);\n\n    if (! process_footers)\n      handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n    else\n      handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n    mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n    return true;\n  }\n  /* Reset processing state */\n  reset_rq_header_processing_state (c);\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n  /* Read the next header (field) line */\n  continue;\n}",
    "mhd_assert (c->rq.method < c->read_buffer);",
    "mhd_assert (NULL != c->rq.field_lines.start);\nc->rq.field_lines.size =\n  (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);",
    "c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);"
  ],
  "explanation": "I flagged fragments that expose or pass char *-style pointers (hdr_name.str, hdr_value.str, connection header/footer value pointers, request method/field_lines pointers) that are used solely for reading or passed to other APIs. These are the primary places where a pointer could potentially be made to point to a const-qualified type and therefore merit investigation for Rule 8.13.\n\nOther pointer usages in the function do not need investigation for this rule because they require writable/non-const pointers or are already const-qualified:\n- The function parameter 'struct MHD_Connection *c' and members accessed via c are modified in this routine (c->state, c->read_buffer, c->read_buffer_size, c->rq.header_size, etc.), so those pointers/objects cannot be const.\n- The read buffer (c->read_buffer) is altered (memmove, pointer adjustment, read_buffer_size update). The buffer is used as a modifiable destination/source; making those pointers point to const would be incorrect.\n- get_req_header is called with &hdr_name and &hdr_value; it is an output-producer for those structures (it initializes hdr_name.str/hdr_value.str and lengths), so the caller must provide mutable storage for those structures themselves (the function may return pointers into a mutable read buffer). That means the structure objects are not candidates for const qualification here.\n- The memmove and subsequent c->read_buffer -= shift_back_size clearly modify memory and pointer values; such pointers cannot be const-qualified.\n- The local variable last_elmnt_end is already declared const char * (and it is read-only), so it does not violate the rule; I included its assignment because it exposes member pointers (value, version) that might themselves be reviewed for const-qualification at their declarations, but the local use is already const.\n\nIn short: I focused on fragments where non-const char* pointers are used only for inspection/passing and thus could reasonably be const-qualified (hdr_name.str, hdr_value.str, values passed to MHD_set_connection_value_n_nocheck_, handle_req_* and the connection's stored header/footer value pointers). Other fragments are excluded because they either modify the pointed-to data or pointers (so const is inappropriate) or are already const."
}