{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern void mhd_assert (int cond);\nstatic void\nmhd_probe_log (const char *event,\n               uint64_t val,\n               uint64_t divisor,\n               int digit,\n               size_t buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Use casts to unsigned long long for portable printing of uint64_t. */\n  fprintf (f, \"%s: val=%llu divisor=%llu digit=%d buf_size=%zu\\n\",\n           event,\n           (unsigned long long) val,\n           (unsigned long long) divisor,\n           digit,\n           buf_size);\n  fclose (f);\n}\n\nsize_t\nMHD_uint64_to_str (uint64_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 18446744073709551615 */\n  uint64_t divisor = UINT64_C (10000000000000000000);\n  int digit;\n\n  /* Log entry state */\n  digit = (int) (val / divisor);\n  mhd_probe_log (\"entry (after initial digit)\", val, divisor, digit, buf_size);\n\n  chr = buf;\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    /* Log before changing divisor */\n    mhd_probe_log (\"leading-zero-loop (before divisor/=10)\", val, divisor, digit, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n\n    /* Log after updating divisor and digit */\n    mhd_probe_log (\"leading-zero-loop (after divisor/=10)\", val, divisor, digit, buf_size);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n    {\n      size_t len = (size_t) (chr - buf);\n      mhd_probe_log (\"return (finished, divisor==1)\", val, divisor, digit, buf_size);\n      /* Log the length as a final note */\n      {\n        FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n        if (NULL != f)\n        {\n          fprintf (f, \"length=%zu\\n\", len);\n          fclose (f);\n        }\n      }\n      return len;\n    }\n\n    /* Log just before the modification of the parameter 'val' (this is the\n       statement reported as violating MISRA C 2023 Rule 17.8).\n       We explicitly record the value before and after the operation for\n       forensic evidence. */\n    mhd_probe_log (\"before_val_mod\", val, divisor, digit, buf_size);\n\n    val %= divisor; /* <--- The reported modification of a function parameter */\n\n    mhd_probe_log (\"after_val_mod\", val, divisor, digit, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n\n    /* Log state at end of loop iteration */\n    mhd_probe_log (\"end_iteration\", val, divisor, digit, buf_size);\n  }\n\n  mhd_probe_log (\"return (buffer too small)\", val, divisor, digit, buf_size);\n  return 0; /* The buffer is too small */\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_str.c:1598:13: error: expected identifier or '('\n 1598 | extern void mhd_assert (int cond);\n      |             ^\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nmhd_str.c:1598:13: error: expected ')'\n./mhd_assert.h:45:32: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^\nmhd_str.c:1598:13: note: to match this '('\n./mhd_assert.h:45:31: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                               ^\nmhd_str.c:1598:13: error: expected ')'\n 1598 | extern void mhd_assert (int cond);\n      |             ^\n./mhd_assert.h:45:38: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nmhd_str.c:1598:13: note: to match this '('\n./mhd_assert.h:45:30: note: expanded from macro 'mhd_assert'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                              ^\n3 errors generated.\nmake[3]: *** [Makefile:2140: libmicrohttpd_la-mhd_str.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_uint64_to_str as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* If mhd_assert was defined as a macro earlier (for example as ((void)0)),\n   it would break the following extern declaration because the preprocessor\n   replaces the token. Undefine it here so we can declare the function\n   prototype as intended. This does not define any new macros. */\n#ifdef mhd_assert\n#undef mhd_assert\n#endif\n\nextern void mhd_assert (int cond);\n\nstatic void\nmhd_probe_log (const char *event,\n               uint64_t val,\n               uint64_t divisor,\n               int digit,\n               size_t buf_size)\n{\n  FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Use casts to unsigned long long for portable printing of uint64_t. */\n  fprintf (f, \"%s: val=%llu divisor=%llu digit=%d buf_size=%zu\\n\",\n           event,\n           (unsigned long long) val,\n           (unsigned long long) divisor,\n           digit,\n           buf_size);\n  fclose (f);\n}\n\nsize_t\nMHD_uint64_to_str (uint64_t val,\n                   char *buf,\n                   size_t buf_size)\n{\n  char *chr;  /**< pointer to the current printed digit */\n  /* The biggest printable number is 18446744073709551615 */\n  uint64_t divisor = UINT64_C (10000000000000000000);\n  int digit;\n\n  /* Log entry state */\n  digit = (int) (val / divisor);\n  mhd_probe_log (\"entry (after initial digit)\", val, divisor, digit, buf_size);\n\n  chr = buf;\n  mhd_assert (digit < 10);\n\n  /* Do not print leading zeros */\n  while ((0 == digit) && (1 < divisor))\n  {\n    /* Log before changing divisor */\n    mhd_probe_log (\"leading-zero-loop (before divisor/=10)\", val, divisor, digit, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n\n    /* Log after updating divisor and digit */\n    mhd_probe_log (\"leading-zero-loop (after divisor/=10)\", val, divisor, digit, buf_size);\n  }\n\n  while (0 != buf_size)\n  {\n    *chr = (char) ((char) digit + '0');\n    chr++;\n    buf_size--;\n    if (1 == divisor)\n    {\n      size_t len = (size_t) (chr - buf);\n      mhd_probe_log (\"return (finished, divisor==1)\", val, divisor, digit, buf_size);\n      /* Log the length as a final note */\n      {\n        FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n        if (NULL != f)\n        {\n          fprintf (f, \"length=%zu\\n\", len);\n          fclose (f);\n        }\n      }\n      return len;\n    }\n\n    /* Log just before the modification of the parameter 'val' (this is the\n       statement reported as violating MISRA C 2023 Rule 17.8).\n       We explicitly record the value before and after the operation for\n       forensic evidence. */\n    mhd_probe_log (\"before_val_mod\", val, divisor, digit, buf_size);\n\n    val %= divisor; /* <--- The reported modification of a function parameter */\n\n    mhd_probe_log (\"after_val_mod\", val, divisor, digit, buf_size);\n\n    divisor /= 10;\n    digit = (int) (val / divisor);\n    mhd_assert (digit < 10);\n\n    /* Log state at end of loop iteration */\n    mhd_probe_log (\"end_iteration\", val, divisor, digit, buf_size);\n  }\n\n  mhd_probe_log (\"return (buffer too small)\", val, divisor, digit, buf_size);\n  return 0; /* The buffer is too small */\n}\n",
  "explanation": "The build error was caused by a macro named mhd_assert already being defined (e.g. as ((void)0)), which made the subsequent \"extern void mhd_assert(int)\" declaration invalid after macro expansion. I added a conditional #undef mhd_assert before the extern declaration so the function prototype is parsed correctly. I also added the necessary standard headers (stdio.h, stdint.h, stddef.h). No macros were defined, the original logic of MHD_uint64_to_str was preserved, and no main or mock functions were added."
}