{
  "user_message": "An agent A claimed that the following MHD_basic_auth_get_username_password3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_basic_auth_get_username_password3.\n```c\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion mhd_assert(decoded_max_len >= decoded_len) can be dead code if the condition is guaranteed true (i.e. MHD_base64_to_bin_n never returns a value greater than decoded_max_len) and the macro has no side-effects. In that case the statement is executed but removal would not affect program behaviour, so it would violate Rule 2.2. (If the assertion can fail and alters behaviour when it fails, or if it is compiled out so it is not executed, then it is not dead code.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is not proven and therefore the report is not correct. Whether the mhd_assert(...) call is \"dead code\" under MISRA C:2023 Rule 2.2 depends on two facts that are not established by the snippet alone: (1) whether decoded_len can ever exceed decoded_max_len (i.e. whether MHD_base64_to_bin_n can ever return a value > decoded_max_len), and (2) whether the mhd_assert macro has observable side effects (e.g. logging, aborting) when the condition is false.\n\nIf MHD_base64_to_bin_n can never return > decoded_max_len (so the condition is always true) and mhd_assert has no side effects, then the assertion would be an operation that is executed but whose removal would not change program behaviour, which fits the definition of dead code. However, nothing in the provided code proves those two facts: decoded_max_len is computed by a helper and decoded_len is produced by another helper \u2014 you would need to examine/verify those functions (or their contracts/invariants) to conclude the condition is guaranteed. Conversely, if the assertion can fail and/or mhd_assert triggers a behavioral change (abort, log that influences timing, etc.), then removal would change behaviour and it is not dead code.\n\nAdditionally, mhd_assert is commonly a defensive check (and may expand to an assert that can abort or to a logging action), so treating it as dead without proof is unsound. Finally, if the assertion macro is compiled out (e.g. NDEBUG), it is simply not present/executed in that build, which is a different situation than being executed but dead.\n\nTherefore the agent's argument is speculative: it outlines a possible scenario under which the assertion would be dead, but does not demonstrate that the scenario holds for this project. Without proof that the condition is always true and that the assertion has no side effects, you cannot claim a Rule 2.2 violation."
}