{
  "user_message": "An agent A claimed that the following free_unmarked code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of free_unmarked.\n```c\nstatic void\nfree_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n  {\n    free (pp->content_name);\n    pp->content_name = NULL;\n  }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n  {\n    free (pp->content_type);\n    pp->content_type = NULL;\n  }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n  {\n    free (pp->content_filename);\n    pp->content_filename = NULL;\n  }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n  {\n    free (pp->content_transfer_encoding);\n    pp->content_transfer_encoding = NULL;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member pp->content_transfer_encoding is declared as a non-const pointer (e.g. char *content_transfer_encoding) but the object it points to is only read (not modified) throughout the program, then the pointer should be const-qualified (e.g. const char *). In that situation Rule 8.13 is violated because the pointer could and should point to a const-qualified type.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=entry, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_name, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_type, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_filename, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_transfer_encoding, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=exit, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=entry, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_name, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_type, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_filename, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_transfer_encoding, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=exit, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=entry, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_name, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_type, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_filename, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_transfer_encoding, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=exit, pp=0x5574b8bde3e0, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=entry, pp=0x7f2b766a4010, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_name, pp=0x7f2b766a4010, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_type, pp=0x7f2b766a4010, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_filename, pp=0x7f2b766a4010, have=0x00000000\n  content_name: ptr=(nil)\n  content_type: ptr=(nil)\n  content_filename: ptr=(nil)\n  content_transfer_encoding: ptr=(nil)\n\nstage=skipped content_transfer_encoding, pp=0x7f2b766a4010, have=0x00000000\n  c\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is speculative and cannot be established from the presented function alone. Rule 8.13 concerns how a pointer is declared (i.e. whether the pointee type should be const-qualified). The snippet only shows uses of struct members (free() and assigning NULL) and does not show the declaration of those members nor how they are used elsewhere. Assigning NULL to a pointer is allowed for a pointer-to-const (const char *p = ...; p = NULL;), so the function itself neither proves nor disproves that the pointee should be const. Moreover, if the members were changed to point-to-const, calls to free would require an explicit cast because free takes void*, so changing the declarations is not a purely mechanical transformation. In short: A\u2019s scenario (that the pointers ought to be const because they are only read) might be correct in some broader context, but there is no evidence in the shown code that Rule 8.13 is violated. Therefore the report is not correct based on the provided information."
}