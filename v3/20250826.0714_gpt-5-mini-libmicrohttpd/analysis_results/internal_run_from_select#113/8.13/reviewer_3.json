{
  "user_message": "An agent A claimed that the following internal_run_from_select code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of internal_run_from_select.\n```c\nstatic enum MHD_Result\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set,\n                          int fd_setsize)\n{\n  MHD_socket ds;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  mhd_assert (0 < fd_setsize);\n  (void) fd_setsize; /* Mute compiler warning */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize; /* Mute compiler warning */\n  mhd_assert (((int) FD_SETSIZE) <= fd_setsize);\n  fd_setsize = FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  { /* Have ITC */\n    bool need_to_clear_itc = true; /* ITC is always non-blocking, it is safe to clear even if ITC not activated */\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (MHD_itc_r_fd_ (daemon->itc),\n                                         NULL, fd_setsize))\n      need_to_clear_itc = FD_ISSET (MHD_itc_r_fd_ (daemon->itc), \\\n                                    (fd_set *) _MHD_DROP_CONST (read_fd_set)); /* Skip clearing, if not needed */\n    if (need_to_clear_itc)\n      MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  /* select connection thread handling type */\n  ds = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ds) &&\n       (! daemon->was_quiesced) )\n  {\n    bool need_to_accept;\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (ds, NULL, fd_setsize))\n      need_to_accept = FD_ISSET (ds,\n                                 (fd_set *) _MHD_DROP_CONST (read_fd_set));\n    else                                       /* Cannot check whether new connection are pending */\n      need_to_accept = daemon->listen_nonblk;  /* Try to accept if non-blocking */\n\n    if (need_to_accept)\n      (void) MHD_accept_connection (daemon);\n  }\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* do not have a thread per connection, process all connections now */\n    struct MHD_Connection *pos;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      MHD_socket cs;\n      bool r_ready;\n      bool w_ready;\n      bool has_err;\n\n      cs = pos->socket_fd;\n      if (MHD_INVALID_SOCKET == cs)\n        continue;\n\n      if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (cs, NULL, fd_setsize))\n      {\n        r_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (read_fd_set));\n        w_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (write_fd_set));\n        has_err = (NULL != except_fd_set) &&\n                  FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (except_fd_set));\n      }\n      else\n      { /* Cannot check the real readiness */\n        r_ready = pos->sk_nonblck;\n        w_ready = r_ready;\n        has_err = false;\n      }\n      call_handlers (pos,\n                     r_ready,\n                     w_ready,\n                     has_err);\n    }\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    urhn = urh->prev;\n    /* update urh state based on select() output */\n    urh_from_fdset (urh,\n                    read_fd_set,\n                    write_fd_set,\n                    except_fd_set,\n                    fd_setsize);\n    /* call generic forwarding function for passing data */\n    process_urh (urh);\n    /* Finished forwarding? */\n    if ( (0 == urh->in_buffer_size) &&\n         (0 == urh->out_buffer_size) &&\n         (0 == urh->in_buffer_used) &&\n         (0 == urh->out_buffer_used) )\n    {\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection (urh->connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter read_fd_set is declared as const fd_set * but the code casts away the const qualifier via _MHD_DROP_CONST and (fd_set *) and passes it to FD_ISSET. By removing the const qualification and using a non-const pointer to refer to data that could be const, this violates MISRA C 2023 Rule 8.13 (pointers should point to const-qualified types whenever possible).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (casted=0x7ffcbe2e2af8), FD_ISSET=0\ninternal_run_from_select: exit: daemon=0x55ecfa182de0 returning MHD_YES\ninternal_run_from_select: entry: daemon=0x55ecfa182de0, read_fd_set=0x7ffcbe2e2af8, write_fd_set=0x7ffcbe2e2a78, except_fd_set=0x7ffcbe2e29f8, fd_setsize=1024\ninternal_run_from_select: listen_fd check: listen_fd=3, read_fd_set=0x7ffcbe2e2af8 (cas\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for MISRA C 2023 Rule 8.13. Rule 8.13 requires that pointers should be declared to point to const-qualified types where possible. In the shown code the parameters are already declared as const fd_set * (read_fd_set, write_fd_set, except_fd_set), so the rule is satisfied. The code does cast away the const qualifier (via _MHD_DROP_CONST and (fd_set *)) when calling FD_ISSET, but that is an instance of removing a qualifier at the point of use \u2014 this would be a concern under MISRA rules that prohibit discarding const/volatile qualifiers (a different MISRA rule), not under 8.13 itself. Therefore agent A's claim that this code violates Rule 8.13 is incorrect (though the code may need review against the MISRA rule that forbids casting away qualifiers)."
}