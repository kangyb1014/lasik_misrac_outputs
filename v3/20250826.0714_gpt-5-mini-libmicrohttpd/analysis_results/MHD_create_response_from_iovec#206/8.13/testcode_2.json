{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code casts away constness when assigning a const uint8_t * ('buf') to a non-const iov_base: iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf); _MHD_DROP_CONST (buf) (and the explicit (char *) cast) removes the const qualifier so the pointer in iov_copy points to a non-const type even though the original data is const. This is a direct loss of const qualification and therefore violates MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_create_response_from_iovec code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2063.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_create_response_from_iovec as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_create_response_from_iovec:\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  if ((NULL == iov) && (0 < iovcnt))\n    return NULL;\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n    return NULL;\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    if (0 == iov[i].iov_len)\n      continue;     /* skip zero-sized elements */\n    if (NULL == iov[i].iov_base)\n    {\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      if (0 == element_size)\n        continue;         /* skip zero-sized elements */\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n  }\n  return response;\n}\n```\n</target_code>\nPlease provide the modified MHD_create_response_from_iovec code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Probe logging helper. Appends lines to /tmp/logs/2063.txt. */\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2063.txt\", \"a\");\n  if (NULL == f)\n    return; /* best-effort logging; do not alter program flow on failure */\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  mhd_probe_log(\"MHD_create_response_from_iovec: entry iov=%p iovcnt=%u free_cb=%p cls=%p\",\n                (const void *) iov, (unsigned int) iovcnt,\n                (const void *) free_cb, cls);\n\n  if ((NULL == iov) && (0 < iovcnt))\n  {\n    mhd_probe_log(\"MHD_create_response_from_iovec: invalid args: iov is NULL but iovcnt=%u\", iovcnt);\n    return NULL;\n  }\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n  {\n    mhd_probe_log(\"MHD_create_response_from_iovec: allocation failed for response\");\n    return NULL;\n  }\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    mhd_probe_log(\"MHD_create_response_from_iovec: mutex init failed\");\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    mhd_probe_log(\"loop: index=%u iov_len=%llu iov_base=%p\",\n                  (unsigned) i, (unsigned long long) iov[i].iov_len,\n                  (const void *) iov[i].iov_base);\n\n    if (0 == iov[i].iov_len)\n    {\n      mhd_probe_log(\"loop: skipping zero-sized element at index=%u\", (unsigned) i);\n      continue;     /* skip zero-sized elements */\n    }\n    if (NULL == iov[i].iov_base)\n    {\n      mhd_probe_log(\"loop: encountered NULL iov_base at index=%u -> error\", (unsigned) i);\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      mhd_probe_log(\"loop: overflow detected at index=%u total_size=%llu add=%llu i_cp=%d\",\n                    (unsigned) i,\n                    (unsigned long long) total_size,\n                    (unsigned long long) iov[i].iov_len,\n                    i_cp);\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        mhd_probe_log(\"loop: overflow (win64 path) detected at index=%u i_add=%lld i_cp=%d\",\n                      (unsigned) i, (long long) i_add, i_cp);\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    mhd_probe_log(\"MHD_create_response_from_iovec: aborting due to earlier error\");\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n\n  mhd_probe_log(\"MHD_create_response_from_iovec: computed total_size=%llu i_cp=%d\",\n                (unsigned long long) total_size, i_cp);\n\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    mhd_probe_log(\"MHD_create_response_from_iovec: zero elements after filtering -> returning empty response\");\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    mhd_probe_log(\"MHD_create_response_from_iovec: single-element optimization applied: data=%p data_size=%llu\",\n                  last_valid_buffer, (unsigned long long) response->data_size);\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      mhd_probe_log(\"MHD_create_response_from_iovec: failed to allocate iov_copy of %d elements\", num_copy_elements);\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    mhd_probe_log(\"MHD_create_response_from_iovec: allocated iov_copy=%p num_copy_elements=%d\",\n                  (void *) iov_copy, num_copy_elements);\n\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      mhd_probe_log(\"copy-loop: index=%u element_size=%llu buf=%p\",\n                    (unsigned) i, (unsigned long long) element_size, (const void *) buf);\n\n      if (0 == element_size)\n      {\n        mhd_probe_log(\"copy-loop: skipping zero-sized element at index=%u\", (unsigned) i);\n        continue;         /* skip zero-sized elements */\n      }\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        /* This is the spot where constness is explicitly dropped in the original implementation. */\n        mhd_probe_log(\"copy-loop-win64: splitting element index=%u i_cp=%d assigning iov_base from buf=%p (dropping constness via _MHD_DROP_CONST)\",\n                      (unsigned) i, i_cp, (const void *) buf);\n\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n\n        mhd_probe_log(\"copy-loop-win64: assigned iov_copy[%d].iov_base=%p iov_len=%lu\",\n                      i_cp, (const void *) iov_copy[i_cp].iov_base, (unsigned long) iov_copy[i_cp].iov_len);\n\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      /* Here the code drops const qualification when assigning into iov_copy. Log that event and the pointer values. */\n      mhd_probe_log(\"copy-loop: about to assign iov_copy[%d].iov_base from buf=%p (dropping constness via _MHD_DROP_CONST)\",\n                    i_cp, (const void *) buf);\n\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n\n      mhd_probe_log(\"copy-loop: assigned iov_copy[%d].iov_base=%p iov_len=%llu\",\n                    i_cp, (const void *) iov_copy[i_cp].iov_base, (unsigned long long) iov_copy[i_cp].iov_len);\n\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n\n    mhd_probe_log(\"MHD_create_response_from_iovec: finished building iov_copy=%p data_iovcnt=%u response->data_iov=%p\",\n                  (void *) iov_copy, response->data_iovcnt, (void *) response->data_iov);\n  }\n  mhd_probe_log(\"MHD_create_response_from_iovec: exit response=%p total_size=%llu data_iovcnt=%u\",\n                (void *) response, (unsigned long long) response->total_size, response->data_iovcnt);\n  return response;\n}\n"
}