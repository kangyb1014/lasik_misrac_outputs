{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe 'if (1)' conditional is a constant-true conditional. The evaluation of that condition (and the conditional construct itself) is executed but redundant \u2014 removing the 'if (1)' wrapper (or replacing it with a plain block '{ ... }') does not change program behaviour. Thus the conditional operation is dead code under Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_create_response_from_iovec code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2062.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_create_response_from_iovec as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_create_response_from_iovec:\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  if ((NULL == iov) && (0 < iovcnt))\n    return NULL;\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n    return NULL;\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    if (0 == iov[i].iov_len)\n      continue;     /* skip zero-sized elements */\n    if (NULL == iov[i].iov_base)\n    {\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      if (0 == element_size)\n        continue;         /* skip zero-sized elements */\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n  }\n  return response;\n}\n```\n</target_code>\nPlease provide the modified MHD_create_response_from_iovec code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n#ifndef _WIN32\n#include <sys/stat.h>\n#endif\n\n/* Probe logging helper. Writes append logs to /tmp/logs/2062.txt. */\nstatic void log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/2062.txt\", \"a\");\n  if (!f)\n  {\n    /* Try to create directory (best-effort). */\n#ifndef _WIN32\n    (void) mkdir(\"/tmp/logs\", 0777);\n#else\n    /* On Windows, skip directory creation here. */\n#endif\n    f = fopen(\"/tmp/logs/2062.txt\", \"a\");\n    if (!f)\n      return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fflush(f);\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  log_probe(\"ENTER: MHD_create_response_from_iovec(iov=%p, iovcnt=%u, free_cb=%p, cls=%p)\\n\",\n            (const void *) iov, iovcnt, (const void *) free_cb, cls);\n\n  if ((NULL == iov) && (0 < iovcnt))\n  {\n    log_probe(\"EARLY RETURN: iov is NULL but iovcnt=%u > 0\\n\", iovcnt);\n    return NULL;\n  }\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n  {\n    log_probe(\"ALLOC FAIL: MHD_calloc_ returned NULL\\n\");\n    return NULL;\n  }\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    log_probe(\"MUTEX INIT FAIL: destroying response and returning NULL\\n\");\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    log_probe(\"LOOP ITER: i=%u, iov_len=%zu, iov_base=%p, total_size=%\" PRIu64 \", i_cp=%d\\n\",\n              i, (size_t) iov[i].iov_len, iov[i].iov_base, total_size, i_cp);\n    if (0 == iov[i].iov_len)\n    {\n      log_probe(\"  SKIP: zero-sized element at index %u\\n\", i);\n      continue;     /* skip zero-sized elements */\n    }\n    if (NULL == iov[i].iov_base)\n    {\n      log_probe(\"  ERROR: NULL iov_base at index %u -> setting i_cp=-1 and break\\n\", i);\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      log_probe(\"  OVERFLOW: total_size=%\" PRIu64 \", iov_len=%zu, i_cp=%d -> overflow, set i_cp=-1\\n\",\n                total_size, (size_t) iov[i].iov_len, i_cp);\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        log_probe(\"  OVERFLOW (win64 path): i_add=%\" PRId64 \", i_cp=%d -> set i_cp=-1\\n\", i_add, i_cp);\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    log_probe(\"ERROR PATH: i_cp == -1 -> destroying mutex and response, returning NULL\\n\");\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    log_probe(\"RETURN ZERO-ELEMENTS: i_cp==0, total_size=%\" PRIu64 \"\\n\", total_size);\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    log_probe(\"RETURN SINGLE-ELEMENT: i_cp==1, last_valid_buffer=%p, data_size=%zu\\n\",\n              last_valid_buffer, (size_t) total_size);\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    log_probe(\"ENTER BRANCH: if(1) block executed (this condition is constant true in source). i_cp=%d\\n\", i_cp);\n\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      log_probe(\"ALLOC FAIL: iov_copy allocation returned NULL (num_copy_elements=%d)\\n\", num_copy_elements);\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      if (0 == element_size)\n      {\n        log_probe(\"  COPY LOOP SKIP: zero-sized element at index %u\\n\", i);\n        continue;         /* skip zero-sized elements */\n      }\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n        log_probe(\"  COPY PARTITION: created an entry with ULONG_MAX at i_cp=%d, remaining element_size=%zu\\n\", i_cp-1, element_size);\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n      log_probe(\"  COPY ELEMENT: i_cp=%d, base=%p, len=%zu\\n\", i_cp, iov_copy[i_cp].iov_base, (size_t) iov_copy[i_cp].iov_len);\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n    log_probe(\"EXIT BRANCH: built iov_copy with data_iovcnt=%u (num_copy_elements=%d)\\n\",\n              response->data_iovcnt, num_copy_elements);\n  }\n  log_probe(\"RETURN: final response=%p, total_size=%\" PRIu64 \"\\n\", (void *) response, total_size);\n  return response;\n}\n"
}