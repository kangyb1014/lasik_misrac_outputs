{
  "user_message": "An agent A claimed that the following MHD_get_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_header.\n```c\n_MHD_EXTERN const char *\nMHD_get_response_header (struct MHD_Response *response,\n                         const char *key)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t key_size;\n\n  if (NULL == key)\n    return NULL;\n\n  key_size = strlen (key);\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_size) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos->value;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code calls strlen(key) after only checking for NULL; there is no guarantee that the object pointed to by key is NUL-terminated. If the caller passes a pointer to a non-terminated char buffer (e.g. a char array of length N without a terminating '\\0' or a pointer into a larger object whose accessible region ends before a '\\0'), strlen will scan past the bounds of the object and cause an out-of-bounds access.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff01f\nMHD_get_response_header: calling strlen on key=0x55e54b6ff01f\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff01f\nInspecting header node: pos=0x55e58a70c920 header=0x55e58a70c8e0 header_size=13 value=0x55e58a70c900\nMHD_get_response_header: match found at pos=0x55e58a70c920 -> returning value=0x55e58a70c900\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff01f\nMHD_get_response_header: calling strlen on key=0x55e54b6ff01f\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff01f\nInspecting header node: pos=0x55e58a70c920 header=0x55e58a70c8e0 header_size=13 value=0x55e58a70c900\nMHD_get_response_header: match found at pos=0x55e58a70c920 -> returning value=0x55e58a70c900\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff01f\nMHD_get_response_header: calling strlen on key=0x55e54b6ff01f\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff01f\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: match found at pos=0x55e58a70cb80 -> returning value=0x55e58a70cb60\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff01f\nMHD_get_response_header: calling strlen on key=0x55e54b6ff01f\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff01f\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: match found at pos=0x55e58a70cb80 -> returning value=0x55e58a70cb60\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff01f\nMHD_get_response_header: calling strlen on key=0x55e54b6ff01f\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff01f\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: match found at pos=0x55e58a70cb80 -> returning value=0x55e58a70cb60\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff090\nMHD_get_response_header: calling strlen on key=0x55e54b6ff090\nMHD_get_response_header: strlen returned key_size=13 for key=0x55e54b6ff090\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: no matching header found -> returning NULL\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff0f6\nMHD_get_response_header: calling strlen on key=0x55e54b6ff0f6\nMHD_get_response_header: strlen returned key_size=10 for key=0x55e54b6ff0f6\nInspecting header node: pos=0x55e58a70cc00 header=0x55e58a70c900 header_size=10 value=0x55e58a70c8e0\nMHD_get_response_header: match found at pos=0x55e58a70cc00 -> returning value=0x55e58a70c8e0\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff0f6\nMHD_get_response_header: calling strlen on key=0x55e54b6ff0f6\nMHD_get_response_header: strlen returned key_size=10 for key=0x55e54b6ff0f6\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: no matching header found -> returning NULL\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff0f6\nMHD_get_response_header: calling strlen on key=0x55e54b6ff0f6\nMHD_get_response_header: strlen returned key_size=10 for key=0x55e54b6ff0f6\nInspecting header node: pos=0x55e58a70cc70 header=0x55e58a70c900 header_size=10 value=0x55e58a70cc40\nMHD_get_response_header: match found at pos=0x55e58a70cc70 -> returning value=0x55e58a70cc40\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff0f6\nMHD_get_response_header: calling strlen on key=0x55e54b6ff0f6\nMHD_get_response_header: strlen returned key_size=10 for key=0x55e54b6ff0f6\nInspecting header node: pos=0x55e58a70cb80 header=0x55e58a70cb40 header_size=13 value=0x55e58a70cb60\nMHD_get_response_header: no matching header found -> returning NULL\nMHD_get_response_header ENTRY: response=0x55e58a70c820 key=0x55e54b6ff0f6\nMHD_get_response_header: calling strl\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct: calling strlen(key) can scan memory until a NUL byte is found and therefore may access bytes beyond the bounds of the object referenced by key if the caller passes a non-terminated buffer or a pointer whose reachable region does not include a terminating '\\0'. MISRA C:2023 Rule 21.17 prohibits uses of <string.h> functions that may result in out\u2011of\u2011bounds accesses unless the code can guarantee the required object layout. The shown function only checks for NULL and does not itself guarantee or document that key is a NUL\u2011terminated C string, nor does it use a bounded alternative (e.g. strnlen with a known maximum from the caller). Therefore, absent an external, enforceable contract that key is NUL\u2011terminated, this use of strlen is a violation of Rule 21.17."
}