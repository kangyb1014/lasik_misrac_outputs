{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_date_str:\n```c\nstatic bool\nget_date_str (char *date)\n{\n  static const char *const days[] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char *const mons[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static const size_t buf_len = 29;\n  struct tm now;\n  time_t t;\n  const char *src;\n#if ! defined(HAVE_C11_GMTIME_S) && ! defined(HAVE_W32_GMTIME_S) && \\\n  ! defined(HAVE_GMTIME_R)\n  struct tm *pNow;\n#endif\n\n  if ((time_t) -1 == time (&t))\n    return false;\n#if defined(HAVE_C11_GMTIME_S)\n  if (NULL == gmtime_s (&t,\n                        &now))\n    return false;\n#elif defined(HAVE_W32_GMTIME_S)\n  if (0 != gmtime_s (&now,\n                     &t))\n    return false;\n#elif defined(HAVE_GMTIME_R)\n  if (NULL == gmtime_r (&t,\n                        &now))\n    return false;\n#else\n  pNow = gmtime (&t);\n  if (NULL == pNow)\n    return false;\n  now = *pNow;\n#endif\n\n  /* Day of the week */\n  src = days[now.tm_wday % 7];\n  date[0] = src[0];\n  date[1] = src[1];\n  date[2] = src[2];\n  date[3] = ',';\n  date[4] = ' ';\n  /* Day of the month */\n  if (2 != MHD_uint8_to_str_pad ((uint8_t) now.tm_mday, 2,\n                                 date + 5, buf_len - 5))\n    return false;\n  date[7] = ' ';\n  /* Month */\n  src = mons[now.tm_mon % 12];\n  date[8] = src[0];\n  date[9] = src[1];\n  date[10] = src[2];\n  date[11] = ' ';\n  /* Year */\n  if (4 != MHD_uint16_to_str ((uint16_t) (1900 + now.tm_year), date + 12,\n                              buf_len - 12))\n    return false;\n  date[16] = ' ';\n  /* Time */\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_hour, 2, date + 17, buf_len - 17);\n  date[19] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_min, 2, date + 20, buf_len - 20);\n  date[22] = ':';\n  MHD_uint8_to_str_pad ((uint8_t) now.tm_sec, 2, date + 23, buf_len - 23);\n  date[25] = ' ';\n  date[26] = 'G';\n  date[27] = 'M';\n  date[28] = 'T';\n\n  return true;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nMHD_uint8_to_str_pad ((uint8_t) now.tm_hour, 2, date + 17, buf_len - 17);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: date points to a 29-byte buffer (buf_len = 29). Passing date + 17 with length buf_len - 17 (29 - 17 = 12) gives room for indices 17..28 inclusive (12 bytes). The call MHD_uint8_to_str_pad((uint8_t)now.tm_hour, 2, date + 17, buf_len - 17) is intended to write 2 characters (and possibly a NUL) into that 12-byte region, so it does not access beyond the bounds of the date object. Also, MISRA C Rule 21.17 specifically concerns the standard <string.h> functions; this is a call to a custom helper. (Caveat: if MHD_uint8_to_str_pad itself internally misuses <string.h> routines or ignores the provided length and writes more than 12 bytes, that would violate the rule.)"
}