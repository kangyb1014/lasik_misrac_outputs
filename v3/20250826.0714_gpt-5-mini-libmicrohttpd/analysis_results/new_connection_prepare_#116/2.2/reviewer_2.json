{
  "user_message": "An agent A claimed that the following new_connection_prepare_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_prepare_.\n```c\nstatic struct MHD_Connection *\nnew_connection_prepare_ (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n  int eno = 0;\n\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d.\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n  {\n    /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Server reached connection limit. \" \\\n                 \"Closing inbound connection.\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return NULL;\n  }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n                               (const struct sockaddr *) addr,\n                               addrlen)) )\n  {\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n#if defined(EACCESS) && (EACCESS + 0 != 0)\n    errno = EACCESS;\n#endif\n    return NULL;\n  }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n  {\n    eno = errno;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    errno = eno;\n    return NULL;\n  }\n\n  if (! external_add)\n  {\n    connection->sk_corked = _MHD_OFF;\n    connection->sk_nodelay = _MHD_OFF;\n  }\n  else\n  {\n    connection->sk_corked = _MHD_UNKNOWN;\n    connection->sk_nodelay = _MHD_UNKNOWN;\n  }\n\n  if (0 < addrlen)\n  {\n    if (NULL == (connection->addr = malloc ((size_t) addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n      errno = eno;\n      return NULL;\n    }\n    memcpy (connection->addr,\n            addr,\n            (size_t) addrlen);\n  }\n  else\n    connection->addr = NULL;\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->is_nonip = sk_is_nonip;\n  connection->sk_spipe_suppress = sk_spipe_supprs;\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&connection->tid);\n#endif /* MHD_USE_THREADS */\n  connection->daemon = daemon;\n  connection->connection_timeout_ms = daemon->connection_timeout_ms;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n  if (0 != connection->connection_timeout_ms)\n    connection->last_activity = MHD_monotonic_msec_counter ();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n  {\n    /* set default connection handlers  */\n    MHD_set_http_callbacks_ (connection);\n  }\n  else\n  {\n#ifdef HTTPS_SUPPORT\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030500)\n    gnutls_init_flags_t\n#else\n    unsigned int\n#endif\n    flags;\n\n    flags = GNUTLS_SERVER;\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030402)\n    flags |= GNUTLS_NO_SIGNAL;\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n    flags |= GNUTLS_NONBLOCK;\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030603)\n    if (0 != (daemon->options & MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT))\n      flags |= GNUTLS_POST_HANDSHAKE_AUTH;\n#endif\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030605)\n    if (0 != (daemon->options & MHD_USE_INSECURE_TLS_EARLY_DATA))\n      flags |= GNUTLS_ENABLE_EARLY_DATA;\n#endif\n    connection->tls_state = MHD_TLS_CONN_INIT;\n    MHD_set_https_callbacks (connection);\n    if ((GNUTLS_E_SUCCESS != gnutls_init (&connection->tls_session, flags)) ||\n        (GNUTLS_E_SUCCESS != gnutls_priority_set (connection->tls_session,\n                                                  daemon->priority_cache)))\n    {\n      if (NULL != connection->tls_session)\n        gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise TLS session.\\n\"));\n#endif\n#if defined(EPROTO) && (EPROTO + 0 != 0)\n      errno = EPROTO;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030200)\n    if (! daemon->disable_alpn)\n    {\n      static const char prt1[] = \"http/1.1\"; /* Registered code for HTTP/1.1 */\n      static const char prt2[] = \"http/1.0\"; /* Registered code for HTTP/1.0 */\n      static const gnutls_datum_t prts[2] =\n      { {_MHD_DROP_CONST (prt1), MHD_STATICSTR_LEN_ (prt1)},\n        {_MHD_DROP_CONST (prt2), MHD_STATICSTR_LEN_ (prt2)} };\n\n      if (GNUTLS_E_SUCCESS !=\n          gnutls_alpn_set_protocols (connection->tls_session,\n                                     prts,\n                                     sizeof(prts) / sizeof(prts[0]),\n                                     0 /* | GNUTLS_ALPN_SERVER_PRECEDENCE */))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to set ALPN protocols.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n        (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n      }\n    }\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030200 */\n    gnutls_session_set_ptr (connection->tls_session,\n                            connection);\n    switch (daemon->cred_type)\n    {\n    /* set needed credentials for certificate authentication. */\n    case GNUTLS_CRD_CERTIFICATE:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_CERTIFICATE,\n                              daemon->x509_cred);\n      break;\n    case GNUTLS_CRD_PSK:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_PSK,\n                              daemon->psk_cred);\n      gnutls_psk_set_server_credentials_function (daemon->psk_cred,\n                                                  &psk_gnutls_adapter);\n      break;\n    case GNUTLS_CRD_ANON:\n    case GNUTLS_CRD_SRP:\n    case GNUTLS_CRD_IA:\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to setup TLS credentials: \" \\\n                   \"unknown credential type %d.\\n\"),\n                daemon->cred_type);\n#endif\n      gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n      MHD_PANIC (_ (\"Unknown credential type.\\n\"));\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n      errno = EINVAL;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030109) && ! defined(_WIN64)\n    gnutls_transport_set_int (connection->tls_session,\n                              (int) (client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n    gnutls_transport_set_ptr (connection->tls_session,\n                              (gnutls_transport_ptr_t) \\\n                              (intptr_t) client_socket);\n#endif /* GnuTLS before 3.1.9 or Win x64 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n    gnutls_transport_set_push_function (connection->tls_session,\n                                        MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n    if (daemon->https_mem_trust)\n      gnutls_certificate_server_set_request (connection->tls_session,\n                                             GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    free (connection->addr);\n    free (connection);\n    MHD_PANIC (_ (\"TLS connection on non-TLS daemon.\\n\"));\n#if 0\n    /* Unreachable code */\n    eno = EINVAL;\n    return NULL;\n#endif\n#endif /* ! HTTPS_SUPPORT */\n  }\n\n  return connection;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement '(void) 0; /* Mute compiler warning */' is a no-op expression statement placed in the #else branch for when HAVE_MESSAGES is not defined (inside the ALPN failure handling). It is an operation that, if removed, would not affect program behaviour (it performs no observable action). Therefore this constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_connection daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=entry daemon=0x55c00f66b8d0 client_socket=5 addr=0x7fffea25faf0 addrlen=16\nstage=return_\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The statement \u201c(void) 0; /* Mute compiler warning */\u201d is an executed no\u2011op when compiled into the binary (it sits in the #else branch taken when HAVE_MESSAGES is not defined and the ALPN failure path occurs). According to MISRA C 2023 Rule 2.2, dead code is any operation that is executed but whose removal would not affect program behaviour. The (void)0 expression has no side effects and removing it would not change the program\u2019s behaviour (other than eliminating an executed no\u2011op), so it meets the definition of dead code and thus violates Rule 2.2. Note that this is distinct from unreachable code; the no\u2011op is reachable and can be executed. A proper remediation is to avoid placing an executed no\u2011op in the production code (for example restructure the preprocessor branches so no statement is required, or document/justify the construct with a project\u2011specific deviation if suppression of a compiler warning is required)."
}