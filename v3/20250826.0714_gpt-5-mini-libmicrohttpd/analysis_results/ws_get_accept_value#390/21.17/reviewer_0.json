{
  "user_message": "An agent A claimed that the following ws_get_accept_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of ws_get_accept_value.\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strlen(key) can read beyond the bounds of the object pointed to by key if that object is not NUL-terminated or its size is not known to be large enough to contain a terminator. Although the code tests key for NULL first (so there is no NULL dereference), it does not guarantee that key points to a NUL-terminated array (for example, key could be a char buf[WS_KEY_LEN] with no '\\0'). In that case strlen will overrun the buffer \u2014 violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 forbids using string.h functions in ways that can access memory beyond the bounds of the objects referenced by their pointer parameters. In ws_get_accept_value the code calls strlen(key) after only checking key for NULL; there is no guarantee that the object pointed to by key is NUL-terminated (for example, it could be a char buf[WS_KEY_LEN] without a terminating '\\0'). In that case strlen will scan past the buffer and may read out of bounds, violating Rule 21.17. Additionally, the subsequent calls to strncpy(str, key, WS_KEY_LEN + 1) and strncpy(str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1) are also uses of string.h functions listed by the rule and could similarly read beyond the source buffer if the source is not properly NUL-terminated or large enough. To comply with MISRA C 2023, the code must ensure the maximum scanned/copy length is bounded by the actual object size (for example use a bounded-length routine such as strnlen with a known limit or memchr to detect a NUL within WS_KEY_LEN, or require the caller to provide an explicit length and use memcpy with that length), or otherwise guarantee the pointer refers to a NUL-terminated array large enough for the operations."
}