{
  "user_message": "An agent A claimed that the following get_unquoted_param_copy code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param_copy.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assertion is executed solely to check a condition that is already guaranteed by the function contract or earlier checks. If param->value.str is always non-NULL in normal operation, the mhd_assert(NULL != param->value.str); has no side effects and its removal would not affect program behaviour \u2014 therefore it is dead code. (Also, if mhd_assert is a debug-only macro that expands to no code in production, the check is redundant in builds where it is enabled and has no effect on program state when the condition is true.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA 2.2 defines dead code as code that is executed and whose removal would not affect program behaviour. The mhd_assert invocation is a runtime check that can alter behaviour (e.g. abort, log, trap) when the condition fails. Therefore its presence can affect program behaviour and it is not \u201cdead\u201d in builds where assertions are enabled. In builds where the assertion macro expands to nothing, the assertion is not executed and so does not meet the MISRA 2.2 definition of dead code (dead code must be executed). Even if the condition is guaranteed by the function contract, the assertion is a defensive runtime check and cannot be assumed dead by the rule. If your project policy disallows debug-only asserts, that is a separate conformance issue, but the claim that this particular assert constitutes a MISRA 2.2 violation is not correct."
}