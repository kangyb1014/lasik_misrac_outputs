{
  "user_message": "An agent A claimed that the following get_unquoted_param_copy code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_unquoted_param_copy.\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 potential out-of-bounds when memcpy copies param->value.len bytes. The code allocates unquoted->str using get_buffer_for_size(..., param->value.len + 1) but does not check for size_t overflow of (param->value.len + 1). If param->value.len is SIZE_MAX (or otherwise large enough to cause wraparound), the requested size can wrap to a much smaller value (even 0), causing get_buffer_for_size to return a buffer smaller than param->value.len. The subsequent memcpy(unquoted->str, param->value.str, param->value.len) would then write beyond the destination buffer (and/or read beyond the source), violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes param->value.len + 1 and passes that to get_buffer_for_size without first ensuring the addition cannot wrap (param->value.len is a size_t and only asserted non-zero). If param->value.len == SIZE_MAX (or otherwise large enough that +1 wraps), the requested size can wrap to a much smaller value (e.g. 0), so get_buffer_for_size may return a buffer smaller than param->value.len. The subsequent memcpy(unquoted->str, param->value.str, param->value.len) can then write beyond the destination (and/or read beyond the source), which is exactly what MISRA C 2023 Rule 21.17 forbids. The existing check that uses (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) suffers the same wrap problem and is not a safe guard. To fix: perform the overflow-safe test (e.g. if (param->value.len >= _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) /* too large */) or check SIZE_MAX - param->value.len >= 1 before adding, or otherwise validate param->value.len against acceptable maxima before computing +1."
}