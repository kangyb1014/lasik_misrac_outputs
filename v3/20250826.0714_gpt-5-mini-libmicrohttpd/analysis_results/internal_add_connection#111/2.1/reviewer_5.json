{
  "user_message": "An agent A claimed that the following internal_add_connection code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of internal_add_connection.\n```c\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the build configuration defines MHD_D_IS_USING_EPOLL_ as a compile-time constant 0 (for example on platforms without epoll support), the condition reduces to (0 && (! non_blck)) which is always false and the entire if-body (including the socket close, errno assignment and return MHD_NO) can never be executed. In that configuration the code inside the if is unreachable and thus violates MISRA C 2023 Rule 2.1.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d903c0\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d91670\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d918c0\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d91b10\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d91d60\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d91fb0\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d92200\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prepare_ succeeded connection=0x55d6f2d92450\ninternal_add_connection: calling new_connection_process_\ninternal_add_connection: entry: daemon=0x55d6f2d8f8d0 client_socket=5 external_add=0 non_blck=1 sk_spipe_supprs=0 sk_is_nonip=0\ninternal_add_connection: MHD_D_IS_USING_SELECT_=1 MHD_D_DOES_SCKT_FIT_FDSET_=1\ninternal_add_connection: MHD_D_IS_USING_EPOLL_=0 non_blck=1\ninternal_add_connection: calling new_connection_prepare_\ninternal_add_connection: new_connection_prep\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A\u2019s report is not generally correct for the code as shown. Whether the if-body is unreachable depends on what MHD_D_IS_USING_EPOLL_(daemon) is in the actual build: \u2022 If MHD_D_IS_USING_EPOLL_ is implemented as a compile\u2011time constant macro that expands to 0 in the current project/configuration, then the condition becomes 0 && \u2026 and the body really is unreachable in that build \u2014 that would violate MISRA C 2023 Rule 2.1 for that project configuration. \u2022 If, as is typical in this codebase, MHD_D_IS_USING_EPOLL_(daemon) is a runtime check (macro/inline that inspects daemon state) then the condition is not a compile\u2011time constant and the if\u2011body can be reached on builds that enable epoll; in that case the code is not unreachable and no MISRA 2.1 violation occurs. The provided execution log shows MHD_D_IS_USING_EPOLL_=0 printed at runtime, which indicates the test is evaluated at runtime in that build rather than being a compile\u2011time constant 0. Therefore, given the evidence, the claim cannot be accepted as a definite MISRA 2.1 violation. Recommendation: if the project truly compiles MHD_D_IS_USING_EPOLL_ to a constant 0 on some configurations, either remove the epoll branch with a preprocessor guard (#if HAVE_EPOLL \u2026 #endif) or make the test a runtime check so the code is reachable on epoll builds; that will avoid an unreachable\u2011code finding."
}