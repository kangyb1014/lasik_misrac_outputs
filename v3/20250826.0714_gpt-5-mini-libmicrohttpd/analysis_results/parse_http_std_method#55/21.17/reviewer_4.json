{
  "user_message": "An agent A claimed that the following parse_http_std_method code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of parse_http_std_method.\n```c\nstatic void\nparse_http_std_method (struct MHD_Connection *connection,\n                       const char *method,\n                       size_t len)\n{\n  const char *const m = method; /**< short alias */\n  mhd_assert (NULL != m);\n  mhd_assert (0 != len);\n\n  if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_GET) == len) &&\n      (0 == memcmp (m, MHD_HTTP_METHOD_GET, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_GET;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_HEAD) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_HEAD, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_HEAD;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_POST) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_POST, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_POST;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_PUT) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_PUT, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_PUT;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_DELETE) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_DELETE, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_DELETE;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_CONNECT) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_CONNECT, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_CONNECT;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_OPTIONS) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_OPTIONS, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_OPTIONS;\n  else if ((MHD_STATICSTR_LEN_ (MHD_HTTP_METHOD_TRACE) == len) &&\n           (0 == memcmp (m, MHD_HTTP_METHOD_TRACE, len)))\n    connection->rq.http_mthd = MHD_HTTP_MTHD_TRACE;\n  else\n    connection->rq.http_mthd = MHD_HTTP_MTHD_OTHER;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes \u2014 memcmp(m, MHD_HTTP_METHOD_HEAD, len) will read len bytes from the caller-supplied pointer m. The code only checks that len equals the length of the static literal, not that the object pointed to by method has at least len bytes. If the caller passes a method pointer whose accessible/storage size is smaller than len (for example method points to \"HE\\0\" but len==4), memcmp will read past the end of the object referenced by m and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nprobe_memcmp: label=GET m=0x5593b0e84b80 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e84b80 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e84b80 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\nprobe_memcmp: label=GET memcmp_result=9\nprobe_memcmp: label=PUT m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb4a2 exp_len=3\nprobe_memcmp: label=PUT memcmp_result=0\nparse_http_std_method: matched=PUT m=0x5593b0e8cd70 len=3 assigned=4\nprobe_memcmp: label=GET m=0x5593b0e8cd70 len=3 exp_ptr=0x7f2f055bb494 exp_len=3\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Each memcmp(m, LIT, len) call will read len bytes from the caller-supplied pointer m. The function only asserts m != NULL and len != 0 and checks len against the length of the static literal; it does not verify that the object referenced by m actually has at least len accessible bytes. Reading len bytes from m is therefore potentially out-of-bounds if the caller supplies an inconsistent method/len pair (for example a short buffer or a pointer to a shorter string with a too-large len). The second memcmp argument (the static literal) is safe because len is compared to the literal length, but that does not guarantee safety for the first argument. Under MISRA C 2023 Rule 21.17 this is a violation unless the code can otherwise prove (or check) that m points to an object of at least len bytes. The provided execution log only shows memcmp invocations and results; it does not establish that the object referenced by m is always large enough. Consequently the reported violation is correct."
}