{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code passes pos->header to memcmp while key is const char *. If the struct member pos->header is declared as a non-const char * (i.e. it is only read from here), Rule 8.13 is violated because the pointer should be const-qualified (e.g. const char *header). Change the declaration of pos->header to const char * (and similarly for pos->value) to comply.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s reasoning is partly correct but the report as stated is not provably correct from the snippet alone. MISRA C:2023 R8.13 requires pointers to point to const-qualified types whenever possible. In this function the members pos->header and pos->value are only read (passed to memcmp), and the local iterator pos itself is never used to modify the pointed-at structure \u2014 so from a MISRA perspective both the struct members and the local pointer could/should be const-qualified if their declarations permit it. However, the snippet does not show the declaration of struct MHD_HTTP_Req_Header (nor its header and value members). The actual violation, if any, would be in the declaration of the struct members (or in the declaration of pos) rather than in the shown function body. Also note that passing a non-const pointer to a function parameter declared as const (memcmp) is allowed by C (it adds const), so the call itself is not the violation; the issue would be that the struct member types are not const-qualified even though they could be.\n\nRecommendation: inspect the definition of struct MHD_HTTP_Req_Header. If its members header and value are declared as non-const char * but are only used for read-only access, change them to const char * (and consider declaring the iterator as const struct MHD_HTTP_Req_Header *pos) to conform with R8.13."
}