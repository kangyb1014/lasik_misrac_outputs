{
  "user_message": "An agent A claimed that the following test_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of test_header.\n```c\nstatic enum MHD_Result\ntest_header (void *cls,\n             const char *key,\n             size_t key_size,\n             const char *value,\n             size_t value_size,\n             enum MHD_ValueKind kind)\n{\n  struct test_header_param *const param = (struct test_header_param *) cls;\n  struct MHD_Connection *connection = param->connection;\n  struct MHD_HTTP_Req_Header *pos;\n  size_t i;\n\n  param->num_headers++;\n  i = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (kind != pos->kind)\n      continue;\n    if (++i == param->num_headers)\n    {\n      if (key_size != pos->header_size)\n        return MHD_NO;\n      if (value_size != pos->value_size)\n        return MHD_NO;\n      if (0 != key_size)\n      {\n        mhd_assert (NULL != key);\n        mhd_assert (NULL != pos->header);\n        if (0 != memcmp (key,\n                         pos->header,\n                         key_size))\n          return MHD_NO;\n      }\n      if (0 != value_size)\n      {\n        mhd_assert (NULL != value);\n        mhd_assert (NULL != pos->value);\n        if (0 != memcmp (value,\n                         pos->value,\n                         value_size))\n          return MHD_NO;\n      }\n      return MHD_YES;\n    }\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe loop uses a non-const pointer 'pos' to traverse and read fields of the headers list (pos = connection->rq.headers_received; ...). The function only reads members of the list (checks kind, sizes, header/value pointers) and does not modify the pointed-to objects, so 'pos' could be declared as 'const struct MHD_HTTP_Req_Header *pos'. Declaring it non-const therefore violates MISRA C 2023 Rule 8.13. Suggested fix: change the declaration to 'const struct MHD_HTTP_Req_Header *pos;'.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f9610000b70 key=0x7f961673ef7b key_size=3 value=0x7f961673ef7f value_size=5 kind=8 num_headers(before)=0\nVisiting header node: pos=0x7f9610008db0 next=0x7f9610008d70 kind=8 header=0x7f9610000dff header_size=3 value=0x7f9610000e03 value_size=5\n  Header index match: i=1 (target num_headers=1)\n  header preview (first 3 bytes):\n    key(bytes): 6B 65 79\n    pos->header(bytes): 6B 65 79\n  memcmp header == 0\n    value(bytes): 76 61 6C 75 65\n    pos->value(bytes): 76 61 6C 75 65\n  memcmp value == 0\n  Matched header fully -> return MHD_YES\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f9610000b70 key=0x7f961673ef85 key_size=4 value=0x7f961673ef8a value_size=9 kind=8 num_headers(before)=1\nVisiting header node: pos=0x7f9610008db0 next=0x7f9610008d70 kind=8 header=0x7f9610000dff header_size=3 value=0x7f9610000e03 value_size=5\nVisiting header node: pos=0x7f9610008d70 next=0x7f9610008d30 kind=8 header=0x7f9610000e09 header_size=4 value=0x7f9610000e0e value_size=9\n  Header index match: i=2 (target num_headers=2)\n  header preview (first 4 bytes):\n    key(bytes): 6D 6F 72 65\n    pos->header(bytes): 6D 6F 72 65\n  memcmp header == 0\n    value(bytes): 65 76 65 6E 20 6D 6F 72 65\n    pos->value(bytes): 65 76 65 6E 20 6D 6F 72 65\n  memcmp value == 0\n  Matched header fully -> return MHD_YES\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f9610000b70 key=0x7f961673ef96 key_size=5 value=(nil) value_size=0 kind=8 num_headers(before)=2\nVisiting header node: pos=0x7f9610008db0 next=0x7f9610008d70 kind=8 header=0x7f9610000dff header_size=3 value=0x7f9610000e03 value_size=5\nVisiting header node: pos=0x7f9610008d70 next=0x7f9610008d30 kind=8 header=0x7f9610000e09 header_size=4 value=0x7f9610000e0e value_size=9\nVisiting header node: pos=0x7f9610008d30 next=0x7f9610008cf0 kind=8 header=0x7f9610000e1a header_size=5 value=(nil) value_size=0\n  Header index match: i=3 (target num_headers=3)\n  header preview (first 5 bytes):\n    key(bytes): 65 6D 70 74 79\n    pos->header(bytes): 65 6D 70 74 79\n  memcmp header == 0\n  Matched header fully -> return MHD_YES\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f9610000b70 key=0x7f961673ef9c key_size=0 value=0x7f961673ef9d value_size=6 kind=8 num_headers(before)=3\nVisiting header node: pos=0x7f9610008db0 next=0x7f9610008d70 kind=8 header=0x7f9610000dff header_size=3 value=0x7f9610000e03 value_size=5\nVisiting header node: pos=0x7f9610008d70 next=0x7f9610008d30 kind=8 header=0x7f9610000e09 header_size=4 value=0x7f9610000e0e value_size=9\nVisiting header node: pos=0x7f9610008d30 next=0x7f9610008cf0 kind=8 header=0x7f9610000e1a header_size=5 value=(nil) value_size=0\nVisiting header node: pos=0x7f9610008cf0 next=0x7f9610008cb0 kind=8 header=0x7f9610000e20 header_size=0 value=0x7f9610000e21 value_size=6\n  Header index match: i=4 (target num_headers=4)\n    value(bytes): 6E 6F 5F 6B 65 79\n    pos->value(bytes): 6E 6F 5F 6B 65 79\n  memcmp value == 0\n  Matched header fully -> return MHD_YES\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f9610000b70 key=0x7f961673efa4 key_size=0 value=(nil) value_size=0 kind=8 num_headers(before)=4\nVisiting header node: pos=0x7f9610008db0 next=0x7f9610008d70 kind=8 header=0x7f9610000dff header_size=3 value=0x7f9610000e03 value_size=5\nVisiting header node: pos=0x7f9610008d70 next=0x7f9610008d30 kind=8 header=0x7f9610000e09 header_size=4 value=0x7f9610000e0e value_size=9\nVisiting header node: pos=0x7f9610008d30 next=0x7f9610008cf0 kind=8 header=0x7f9610000e1a header_size=5 value=(nil) value_size=0\nVisiting header node: pos=0x7f9610008cf0 next=0x7f9610008cb0 kind=8 header=0x7f9610000e20 header_size=0 value=0x7f9610000e21 value_size=6\nVisiting header node: pos=0x7f9610008cb0 next=0x7f9610008c70 kind=8 header=0x7f9610000e28 header_size=0 value=(nil) value_size=0\n  Header index match: i=5 (target num_headers=5)\n  Matched header fully -> return MHD_YES\ntest_header ENTRY: cls=0x7f961673edf8 param=0x7f961673edf8 connection=0x7f961000\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In test_header the variable pos is only used to read the header list (inspect pos->kind, pos->header_size, pos->value_size, pos->header, pos->value and pos->next) and the function does not modify the objects pointed to by pos. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible. Declaring pos as const struct MHD_HTTP_Req_Header *pos; is valid: assigning connection->rq.headers_received (a non-const pointer) to a const-qualified pointer and assigning pos = pos->next are allowed (the non-const pointer is implicitly converted to a pointer-to-const). Thus the code as written violates Rule 8.13 and the suggested fix (make pos a pointer to const) is appropriate."
}