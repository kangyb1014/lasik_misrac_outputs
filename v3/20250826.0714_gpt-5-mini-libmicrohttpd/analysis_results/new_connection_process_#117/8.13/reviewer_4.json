{
  "user_message": "An agent A claimed that the following new_connection_process_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_process_.\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes connection->addr (a non-const pointer) to MHD_ip_limit_del. If MHD_ip_limit_del is declared to take a non-const pointer type (e.g. void * / char * / struct sockaddr *) but does not need to modify the pointed-to data, this is a violation of MISRA C 2023 Rule 8.13 \u2014 the parameter should be const-qualified (e.g. const void * / const struct sockaddr *). If, instead, MHD_ip_limit_del legitimately modifies the memory pointed to by connection->addr, then no violation occurs.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x5592295231e0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6267f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x5592295231e0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6267f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229524670 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d62a7f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229524670 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d62a7f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x5592295248c0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6387f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x5592295248c0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6387f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229524b10 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6407f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229524b10 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6407f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229524d60 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6427f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229524d60 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6427f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229524fb0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6467f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229524fb0 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6467f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229525200 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d64e7f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229525200 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d64e7f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229525450 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d65c7f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229525450 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d65c7f0000010000000000000000\n[mhd_log] stage=entry daemon=0x5592295228d0 connection=0x559229525450 socket_fd=5 addr=0x559229523430 addr_len=16 pool=(nil) connections=0 connection_limit=1019\n[mhd_log] addr_bytes=0200d6607f0000010000000000000000\n[mhd_log] stage=return_success_no_epoll daemon=0x5592295228d0 connection=0x559229525450 socket_fd=5 addr=0x559229523430 addr_len=16 pool=0x559229523630 connections=1 connection_limit=1019\n[mhd_log] addr_bytes=0200d6607f000001\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not provably correct based on the code shown. MISRA C:2023 Rule 8.13 speaks to how pointer types should be declared \u2014 a pointer should point to a const-qualified type whenever it is not intended to allow modification of the pointed-to object. The call site in new_connection_process_ simply passes connection->addr to MHD_ip_limit_del; whether a rule violation exists depends on the declaration/definition of MHD_ip_limit_del and whether that function legitimately modifies the memory pointed to by its pointer parameter.\n\n- If MHD_ip_limit_del is declared to take a non-const pointer (e.g. void * / struct sockaddr *) but does not actually modify the memory, then the function\u2019s parameter declaration should be changed to a const-qualified pointer and that would satisfy Rule 8.13. In that case agent A\u2019s reported issue would be correct (the API should use const).\n- If MHD_ip_limit_del genuinely modifies the memory pointed to by the parameter, then the non-const parameter is appropriate and there is no violation.\n\nFrom the new_connection_process_ code and the provided log alone there is no evidence whether MHD_ip_limit_del modifies the buffer. Thus the report is inconclusive; you must inspect the prototype/definition of MHD_ip_limit_del (or its intended semantics) to determine whether its pointer parameter should be const. If it can be const, update the function\u2019s parameter to const and the call site will then comply with Rule 8.13."
}