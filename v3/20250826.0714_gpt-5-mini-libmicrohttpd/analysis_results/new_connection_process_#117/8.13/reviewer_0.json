{
  "user_message": "An agent A claimed that the following new_connection_process_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_process_.\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call MHD_strerror_(eno) (and similarly the result of _(\"Failed to create a thread: %s\\n\")) likely yields a char * that points to an immutable/static error/string message. Such functions historically return char * for C compatibility, but per MISRA C 2023 Rule 8.13 these pointers should be const-qualified (const char *) whenever possible. If MHD_strerror_ (or _()) is declared to return a non-const char * while actually returning an immutable/static string, this is a violation of Rule 8.13.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddac1e0 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddac1e0\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddad670 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddad670\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddad8c0 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddad8c0\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddadb10 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddadb10\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddadd60 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddadd60\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddadfb0 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddadfb0\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae200 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae200\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x56096ddae450 initial_errno=107\nRETURN MHD_YES: non-epoll path, connection=0x56096ddae450\nENTER new_connection_process_: daemon=0x56096ddab8d0 connection=0x\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The presented function new_connection_process_ itself does not declare any pointer-to-non-const that could obviously be made const, so there is no direct violation of MISRA C 2023 Rule 8.13 in the shown code. Agent A\u2019s argument hinges on the return types of external functions (MHD_strerror_ and _/gettext) being declared as char * even though they return immutable/static strings. That would be a deficiency in those function prototypes (they ought to return const char * where possible), but that is not visible in the snippet and is an issue in the library/API declarations rather than in new_connection_process_. In short: you must inspect the declarations of MHD_strerror_ and _() to determine a real Rule 8.13 violation. If those functions are declared to return non-const char * within the project\u2019s source, then those declarations would be non\u2011conforming to 8.13 (or require a documented deviation). But based on the code shown, Agent A\u2019s report is not correct \u2014 the function here does not itself violate 8.13."
}