{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n  /* reentrancy probe counter (file-scope would be fine too). */\n  static int new_connection_process_reentrancy = 0;\n  FILE *logf = NULL;\n\n  /* Enter probe: increment depth and log state */\n  new_connection_process_reentrancy++;\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTER new_connection_process_: depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p connections=%d connection_limit=%d socket_fd=%d\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon,\n            (void *) connection,\n            (void *) (daemon ? daemon->notify_connection : NULL),\n            (void *) (daemon ? daemon->notify_connection_cls : NULL),\n            (int) (daemon ? daemon->connections : -1),\n            (int) (daemon ? daemon->connection_limit : -1),\n            (int) (connection ? connection->socket_fd : -1));\n    if (new_connection_process_reentrancy > 1)\n      fprintf(logf, \"POTENTIAL RECURSION DETECTED: new_connection_process_ re-entered (depth=%d)\\n\",\n              new_connection_process_reentrancy);\n    fclose(logf);\n    logf = NULL;\n  }\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n\n    /* Log pool creation failure */\n    logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n    if (logf)\n    {\n      fprintf(logf, \"POOL_CREATION_FAILED depth=%d daemon=%p connection=%p errno=%d\\n\",\n              new_connection_process_reentrancy,\n              (void *) daemon,\n              (void *) connection,\n              errno);\n      fclose(logf);\n    }\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n\n      /* Log connection limit reached */\n      logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n      if (logf)\n      {\n        fprintf(logf, \"CONNECTION_LIMIT depth=%d daemon=%p connection=%p connections=%d limit=%d\\n\",\n                new_connection_process_reentrancy,\n                (void *) daemon,\n                (void *) connection,\n                daemon->connections,\n                daemon->connection_limit);\n        fclose(logf);\n      }\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_STARTED depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p socket_ctx=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection,\n                  (void *) daemon->notify_connection_cls,\n                  (void *) &connection->socket_context);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n\n        /* Log after notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_STARTED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n        {\n          /* Log success thread creation and then return (preserve logic) */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            fprintf(logf, \"THREAD_CREATED return MHD_YES depth=%d daemon=%p connection=%p tid=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection,\n                    (void *) (intptr_t) connection->tid);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;  /* *** Function success exit point *** */\n        }\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              /* Log epoll add success and then return */\n              logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n              if (logf)\n              {\n                fprintf(logf, \"EPOLL_ADDED return MHD_YES depth=%d daemon=%p connection=%p epoll_fd=%d socket_fd=%d\\n\",\n                        new_connection_process_reentrancy,\n                        (void *) daemon,\n                        (void *) connection,\n                        daemon->epoll_fd,\n                        connection->socket_fd);\n                fclose(logf);\n              }\n\n              new_connection_process_reentrancy--;\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            /* Log turbo-path success and return */\n            logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n            if (logf)\n            {\n              fprintf(logf, \"TURBO_EPOLL_INSERT return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                      new_connection_process_reentrancy,\n                      (void *) daemon,\n                      (void *) connection);\n              fclose(logf);\n            }\n\n            new_connection_process_reentrancy--;\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        {\n          /* Log no-epoll success return */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            fprintf(logf, \"NO_EPOLL return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;    /* *** Function success exit point *** */\n        }\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_CLOSED depth=%d daemon=%p connection=%p notify_fn=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n\n        /* Log after notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_CLOSED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n\n  /* Log function exit (failure path) and decrement depth */\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"EXIT new_connection_process_ failure return MHD_NO depth=%d daemon=%p\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon);\n    fclose(logf);\n  }\n  new_connection_process_reentrancy--;\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndaemon.c:3049:41: error: operand of type 'MHD_thread_handle_ID_' (aka 'struct _MHD_thread_handle_ID_') where arithmetic or pointer type is required\n 3049 |                     (void *) (intptr_t) connection->tid);\n      |                                         ^~~~~~~~~~~~~~~\n1 error generated.\nmake[3]: *** [Makefile:2112: libmicrohttpd_la-daemon.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of new_connection_process_ as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n  /* reentrancy probe counter (file-scope would be fine too). */\n  static int new_connection_process_reentrancy = 0;\n  FILE *logf = NULL;\n\n  /* Enter probe: increment depth and log state */\n  new_connection_process_reentrancy++;\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTER new_connection_process_: depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p connections=%d connection_limit=%d socket_fd=%d\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon,\n            (void *) connection,\n            (void *) (daemon ? daemon->notify_connection : NULL),\n            (void *) (daemon ? daemon->notify_connection_cls : NULL),\n            (int) (daemon ? daemon->connections : -1),\n            (int) (daemon ? daemon->connection_limit : -1),\n            (int) (connection ? connection->socket_fd : -1));\n    if (new_connection_process_reentrancy > 1)\n      fprintf(logf, \"POTENTIAL RECURSION DETECTED: new_connection_process_ re-entered (depth=%d)\\n\",\n              new_connection_process_reentrancy);\n    fclose(logf);\n    logf = NULL;\n  }\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n\n    /* Log pool creation failure */\n    logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n    if (logf)\n    {\n      fprintf(logf, \"POOL_CREATION_FAILED depth=%d daemon=%p connection=%p errno=%d\\n\",\n              new_connection_process_reentrancy,\n              (void *) daemon,\n              (void *) connection,\n              errno);\n      fclose(logf);\n    }\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n\n      /* Log connection limit reached */\n      logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n      if (logf)\n      {\n        fprintf(logf, \"CONNECTION_LIMIT depth=%d daemon=%p connection=%p connections=%d limit=%d\\n\",\n                new_connection_process_reentrancy,\n                (void *) daemon,\n                (void *) connection,\n                daemon->connections,\n                daemon->connection_limit);\n        fclose(logf);\n      }\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_STARTED depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p socket_ctx=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection,\n                  (void *) daemon->notify_connection_cls,\n                  (void *) &connection->socket_context);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n\n        /* Log after notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_STARTED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n        {\n          /* Log success thread creation and then return (preserve logic) */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            /* Print the address of the thread handle structure instead of\n             * attempting to cast the structure value to an integer type. */\n            fprintf(logf, \"THREAD_CREATED return MHD_YES depth=%d daemon=%p connection=%p tid=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection,\n                    (void *) &connection->tid);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;  /* *** Function success exit point *** */\n        }\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              /* Log epoll add success and then return */\n              logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n              if (logf)\n              {\n                fprintf(logf, \"EPOLL_ADDED return MHD_YES depth=%d daemon=%p connection=%p epoll_fd=%d socket_fd=%d\\n\",\n                        new_connection_process_reentrancy,\n                        (void *) daemon,\n                        (void *) connection,\n                        daemon->epoll_fd,\n                        connection->socket_fd);\n                fclose(logf);\n              }\n\n              new_connection_process_reentrancy--;\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            /* Log turbo-path success and return */\n            logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n            if (logf)\n            {\n              fprintf(logf, \"TURBO_EPOLL_INSERT return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                      new_connection_process_reentrancy,\n                      (void *) daemon,\n                      (void *) connection);\n              fclose(logf);\n            }\n\n            new_connection_process_reentrancy--;\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        {\n          /* Log no-epoll success return */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            fprintf(logf, \"NO_EPOLL return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;    /* *** Function success exit point *** */\n        }\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_CLOSED depth=%d daemon=%p connection=%p notify_fn=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n\n        /* Log after notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_CLOSED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n\n  /* Log function exit (failure path) and decrement depth */\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"EXIT new_connection_process_ failure return MHD_NO depth=%d daemon=%p\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon);\n    fclose(logf);\n  }\n  new_connection_process_reentrancy--;\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n",
  "explanation": "The build error was caused by attempting to cast a structure type (MHD_thread_handle_ID_) to an integer type (intptr_t) for printing, which is invalid. I changed the fprintf argument to print the address of the thread handle structure instead: (void *)&connection->tid. This preserves the original intent of logging the thread identifier while avoiding an illegal cast, and it compiles cleanly."
}