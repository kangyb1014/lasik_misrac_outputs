{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 17.2.\nHere is the comment from the agent.\n<violation scenario>\nThe code calls the function-pointer daemon->notify_connection from within new_connection_process_. If daemon->notify_connection is (directly) set to point to new_connection_process_ (or (indirectly) to any function that eventually calls new_connection_process_), this produces an indirect self-call (recursion), violating MISRA C 2023 Rule 17.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified new_connection_process_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1176.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of new_connection_process_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of new_connection_process_:\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\nPlease provide the modified new_connection_process_ code.\n",
  "test_code": "static enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n  /* reentrancy probe counter (file-scope would be fine too). */\n  static int new_connection_process_reentrancy = 0;\n  FILE *logf = NULL;\n\n  /* Enter probe: increment depth and log state */\n  new_connection_process_reentrancy++;\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"ENTER new_connection_process_: depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p connections=%d connection_limit=%d socket_fd=%d\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon,\n            (void *) connection,\n            (void *) (daemon ? daemon->notify_connection : NULL),\n            (void *) (daemon ? daemon->notify_connection_cls : NULL),\n            (int) (daemon ? daemon->connections : -1),\n            (int) (daemon ? daemon->connection_limit : -1),\n            (int) (connection ? connection->socket_fd : -1));\n    if (new_connection_process_reentrancy > 1)\n      fprintf(logf, \"POTENTIAL RECURSION DETECTED: new_connection_process_ re-entered (depth=%d)\\n\",\n              new_connection_process_reentrancy);\n    fclose(logf);\n    logf = NULL;\n  }\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n\n    /* Log pool creation failure */\n    logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n    if (logf)\n    {\n      fprintf(logf, \"POOL_CREATION_FAILED depth=%d daemon=%p connection=%p errno=%d\\n\",\n              new_connection_process_reentrancy,\n              (void *) daemon,\n              (void *) connection,\n              errno);\n      fclose(logf);\n    }\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n\n      /* Log connection limit reached */\n      logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n      if (logf)\n      {\n        fprintf(logf, \"CONNECTION_LIMIT depth=%d daemon=%p connection=%p connections=%d limit=%d\\n\",\n                new_connection_process_reentrancy,\n                (void *) daemon,\n                (void *) connection,\n                daemon->connections,\n                daemon->connection_limit);\n        fclose(logf);\n      }\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_STARTED depth=%d daemon=%p connection=%p notify_fn=%p notify_cls=%p socket_ctx=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection,\n                  (void *) daemon->notify_connection_cls,\n                  (void *) &connection->socket_context);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n\n        /* Log after notify_connection call */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_STARTED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n        {\n          /* Log success thread creation and then return (preserve logic) */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            fprintf(logf, \"THREAD_CREATED return MHD_YES depth=%d daemon=%p connection=%p tid=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection,\n                    (void *) (intptr_t) connection->tid);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;  /* *** Function success exit point *** */\n        }\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              /* Log epoll add success and then return */\n              logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n              if (logf)\n              {\n                fprintf(logf, \"EPOLL_ADDED return MHD_YES depth=%d daemon=%p connection=%p epoll_fd=%d socket_fd=%d\\n\",\n                        new_connection_process_reentrancy,\n                        (void *) daemon,\n                        (void *) connection,\n                        daemon->epoll_fd,\n                        connection->socket_fd);\n                fclose(logf);\n              }\n\n              new_connection_process_reentrancy--;\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            /* Log turbo-path success and return */\n            logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n            if (logf)\n            {\n              fprintf(logf, \"TURBO_EPOLL_INSERT return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                      new_connection_process_reentrancy,\n                      (void *) daemon,\n                      (void *) connection);\n              fclose(logf);\n            }\n\n            new_connection_process_reentrancy--;\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        {\n          /* Log no-epoll success return */\n          logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n          if (logf)\n          {\n            fprintf(logf, \"NO_EPOLL return MHD_YES depth=%d daemon=%p connection=%p\\n\",\n                    new_connection_process_reentrancy,\n                    (void *) daemon,\n                    (void *) connection);\n            fclose(logf);\n          }\n\n          new_connection_process_reentrancy--;\n          return MHD_YES;    /* *** Function success exit point *** */\n        }\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n      {\n        /* Log before notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"BEFORE_NOTIFY_CLOSED depth=%d daemon=%p connection=%p notify_fn=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection,\n                  (void *) daemon->notify_connection);\n          fclose(logf);\n        }\n\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n\n        /* Log after notify_connection (closed) */\n        logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"AFTER_NOTIFY_CLOSED depth=%d daemon=%p connection=%p\\n\",\n                  new_connection_process_reentrancy,\n                  (void *) daemon,\n                  (void *) connection);\n          fclose(logf);\n        }\n      }\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n\n  /* Log function exit (failure path) and decrement depth */\n  logf = fopen(\"/tmp/logs/1176.txt\", \"a\");\n  if (logf)\n  {\n    fprintf(logf, \"EXIT new_connection_process_ failure return MHD_NO depth=%d daemon=%p\\n\",\n            new_connection_process_reentrancy,\n            (void *) daemon);\n    fclose(logf);\n  }\n  new_connection_process_reentrancy--;\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n"
}