{
  "user_message": "An agent A claimed that the following new_connection_process_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_process_.\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe standalone statement '(void) 0;' is an executed no-op inserted to mute compiler warnings. Removing it does not change program behaviour (whether or not the preceding #if block sets 'eno'), so this is dead code introduced solely to silence a warning and therefore violates MISRA C 2023 Rule 2.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f21e0; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f21e0; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f3670; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f3670; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f38c0; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f38c0; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f3b10; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f3b10; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f3d60; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f3d60; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f3fb0; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f3fb0; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4200; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4200; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daemon_connections=0\nnew_connection_process_: no_epoll_success; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=0x564baf0f2630; daemon_connections=1\nnew_connection_process_: entry; eno=0; errno=107; connection=0x564baf0f4450; socket_fd=5; pool=(nil); daem\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The standalone statement \u201c(void) 0;\u201d is an executed no\u2011op whose removal would not change the observable behaviour of the program (it has no side effects other than an imperceptible timing effect in practice). Under MISRA C 2023 Rule 2.2 (\u201cA project shall not contain dead code\u201d), that constitutes dead code. The statement is clearly present only to silence compiler warnings when the conditional ENOMEM/ENFILE assignment is absent; it does not affect program state and therefore violates Rule 2.2. (If timing were a safety\u2011critical observable in this context, an argument might be made that the extra instruction affects behaviour, but in typical use this is not the case \u2014 and MISRA would prefer explicit, justified constructs or suppression mechanisms rather than a no\u2011op.) Suggested remediations include using a construct that documents intent (e.g. an explicit cast to void of an intentionally unused variable where appropriate, conditional compilation to avoid an empty statement, or a documented deviation.)"
}