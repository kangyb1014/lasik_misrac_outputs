{
  "user_message": "An agent A claimed that the following new_connection_process_ code violates the MISRA C 2023 rule 14.3.\n<misra_rule>\nMISRA C 2023 Rule 14.3 is Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<target_code>\nHere is the original code of new_connection_process_.\n```c\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe controlling expression '1' in the statement \"if (1)\" is an invariant constant true expression used to select a block; it is not creating an infinite loop nor a do-while constant-false exception, so it violates MISRA C 2023 Rule 14.3.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d21e0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d21e0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d21e0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d21e0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d3670 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d3670 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d3670 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d3670 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d38c0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d38c0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d38c0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d38c0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d3b10 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d3b10 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d3b10 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d3b10 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d3d60 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d3d60 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d3d60 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d3d60 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d3fb0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d3fb0 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d3fb0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d3fb0 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d4200 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d4200 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d4200 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d4200 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=enter daemon=0x55a3223d18d0 connection=0x55a3223d4450 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=pool_create_ok daemon=0x55a3223d18d0 connection=0x55a3223d4450 socket_fd=5 connections=0 connection_limit=1019 eno=0\nevent=enter_non_thread_per_conn_branch_if_1 daemon=0x55a3223d18d0 connection=0x55a3223d4450 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=no_epoll_return_yes daemon=0x55a3223d18d0 connection=0x55a3223d4450 socket_fd=5 connections=1 connection_limit=1019 eno=0\nevent=en\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The controlling expression if (1) is an invariant (constant true) and is not used to create an infinite loop nor is it a do-while false case allowed by the exceptions to MISRA C 2023 Rule 14.3. Although the if (1) appears as a preprocessor convenience to keep a common if/else structure when MHD_USE_THREADS is not defined, that does not make it conformant: when built with !MHD_USE_THREADS the compiled code contains a constant-true controlling expression and therefore violates Rule 14.3. (The provided execution log simply shows the branch being taken at runtime and does not affect the static rule violation.) Recommended remediation is to remove the if (1) and restructure the preprocessor branches (for example, use #if/#else to select the appropriate block or invert the preprocessor logic) so that no invariant controlling expression remains in any build configuration."
}