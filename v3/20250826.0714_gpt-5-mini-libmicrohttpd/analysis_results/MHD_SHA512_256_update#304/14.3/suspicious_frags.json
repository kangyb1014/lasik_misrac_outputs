{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_SHA512_256_update:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No controlling expressions in this function are manifestly invariant at compile time. Each conditional or loop depends on runtime values (function parameters or context fields) or on preprocess-time configuration: \n\n- mhd_assert((data != NULL) || (length == 0)): This is an assertion macro and depends on the runtime parameter data and length.\n- #ifndef MHD_FAVOR_SMALL_CODE / if (0 == length) return;: The if tests the runtime parameter length, so it is not invariant. The surrounding #ifndef is a compile-time inclusion guard (preprocessor), not a runtime controlling expression subject to Rule 14.3.\n- bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1)); if (0 != bytes_have): bytes_have is computed from ctx->count (a runtime-modifiable field), so the condition is not invariant.\n- ctx->count += length; #if SIZEOF_SIZE_T > 7 if (length > ctx->count) ... #endif: The #if SIZEOF_SIZE_T > 7 is a preprocessor conditional (compile-time). The enclosed if tests runtime variables (length and ctx->count) and is therefore not invariant.\n- count_hi = ctx->count >> 61; if (0 != count_hi): count_hi is derived from ctx->count, a runtime value, so the condition is not invariant.\n- if (length >= bytes_left): bytes_left is computed from bytes_have and a block-size constant; bytes_have is runtime-derived, and length is a parameter \u2014 not invariant.\n- while (SHA512_256_BLOCK_SIZE <= length): length is a runtime parameter and is modified in the loop, so the loop condition is not a compile-time invariant. This is not an infinite-loop invariant; it depends on length and is updated inside the loop.\n- if (0 != length) memcpy(...): length is a runtime value (possibly modified earlier), so the condition is not invariant.\n\nNo do-while loops with constant false controlling expressions or intentionally invariant infinite loops are present. Therefore there are no fragments that appear to violate MISRA C 2023 Rule 14.3 and no code fragments need further investigation under that rule."
}