{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the function sha512_256_transform is declared to take a non-const pointer for the input block (for example: void sha512_256_transform(uint64_t H[8], uint8_t *block) or void sha512_256_transform(uint64_t H[8], uint8_t block[SHA512_256_BLOCK_SIZE])) but the function only reads the block data (does not modify it), then the pointer should be to a const-qualified type (e.g. const uint8_t * or const uint8_t block[]) and Rule 8.13 is violated. If, however, sha512_256_transform legitimately modifies the buffer contents, then using a non-const pointer is required and there is no violation.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953b01b length=3\nctx->count (before)=0 bytes_have=0\nctx->count (after)=3 ctx->count_bits_hi=0\nbuffer_before_final_memcpy: pointer=0x7fff696183c8 block_size=3 snapshot_bytes=3\nbuffer_before_final_memcpy: data = 06 00 00\ndata_before_final_memcpy: pointer=0x555b3953b01b block_size=3 snapshot_bytes=3\ndata_before_final_memcpy: data = 61 62 63\nbuffer_after_final_memcpy: pointer=0x7fff696183c8 block_size=3 snapshot_bytes=3\nbuffer_after_final_memcpy: data = 61 62 63\nMHD_SHA512_256_update: exit ctx=0x7fff69618388\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953b01f length=112\nctx->count (before)=0 bytes_have=0\nctx->count (after)=112 ctx->count_bits_hi=0\nbuffer_before_final_memcpy: pointer=0x7fff696183c8 block_size=112 snapshot_bytes=64\nbuffer_before_final_memcpy: data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ndata_before_final_memcpy: pointer=0x555b3953b01f block_size=112 snapshot_bytes=64\ndata_before_final_memcpy: data = 61 62 63 64 65 66 67 68 62 63 64 65 66 67 68 69 63 64 65 66 67 68 69 6a 64 65 66 67 68 69 6a 6b 65 66 67 68 69 6a 6b 6c 66 67 68 69 6a 6b 6c 6d 67 68 69 6a 6b 6c 6d 6e 68 69 6a 6b 6c 6d 6e 6f\nbuffer_after_final_memcpy: pointer=0x7fff696183c8 block_size=112 snapshot_bytes=64\nbuffer_after_final_memcpy: data = 61 62 63 64 65 66 67 68 62 63 64 65 66 67 68 69 63 64 65 66 67 68 69 6a 64 65 66 67 68 69 6a 6b 65 66 67 68 69 6a 6b 6c 66 67 68 69 6a 6b 6c 6d 67 68 69 6a 6b 6c 6d 6e 68 69 6a 6b 6c 6d 6e 6f\nMHD_SHA512_256_update: exit ctx=0x7fff69618388\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953e869 length=0\nMHD_SHA512_256_update: length is 0, returning early\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953b090 length=28\nctx->count (before)=0 bytes_have=0\nctx->count (after)=28 ctx->count_bits_hi=0\nbuffer_before_final_memcpy: pointer=0x7fff696183c8 block_size=28 snapshot_bytes=28\nbuffer_before_final_memcpy: data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ndata_before_final_memcpy: pointer=0x555b3953b090 block_size=28 snapshot_bytes=28\ndata_before_final_memcpy: data = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24 40 23 7b 7d 5b 5d 5c 2f 21 3f 60 2e\nbuffer_after_final_memcpy: pointer=0x7fff696183c8 block_size=28 snapshot_bytes=28\nbuffer_after_final_memcpy: data = 31 32 33 34 35 36 37 38 39 30 21 40 7e 25 26 24 40 23 7b 7d 5b 5d 5c 2f 21 3f 60 2e\nMHD_SHA512_256_update: exit ctx=0x7fff69618388\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953b0ad length=14\nctx->count (before)=0 bytes_have=0\nctx->count (after)=14 ctx->count_bits_hi=0\nbuffer_before_final_memcpy: pointer=0x7fff696183c8 block_size=14 snapshot_bytes=14\nbuffer_before_final_memcpy: data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ndata_before_final_memcpy: pointer=0x555b3953b0ad block_size=14 snapshot_bytes=14\ndata_before_final_memcpy: data = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nbuffer_after_final_memcpy: pointer=0x7fff696183c8 block_size=14 snapshot_bytes=14\nbuffer_after_final_memcpy: data = 53 69 6d 70 6c 65 20 73 74 72 69 6e 67 2e\nMHD_SHA512_256_update: exit ctx=0x7fff69618388\nMHD_SHA512_256_update: entry ctx=0x7fff69618388 data=0x555b3953b0bc length=26\nctx->count (before)=0 bytes_have=0\nctx->count (after)=26 ctx->count_bits_hi=0\nbuffer_before_final_memcpy: pointer=0x7fff696183c8 block_size=26 snapshot_bytes=26\nbuffer_before_final_memcpy: data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ndata_before_final_memcpy: pointer=0x555b3953b0bc block_size=26 snapshot_bytes=26\ndata_before_final_memcpy: data = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a\nbuffer_after_final_memcpy: pointer=0x7fff696183c8 block_size=26 snapshot_bytes=26\nbuffer_after_final_memcpy: data = 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a\nMHD_SHA512_256_update: exit ctx=0x7fff69618388\n\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct in the way it characterises the issue, but it is conditional on the declaration of sha512_256_transform. MISRA C:2023 Rule 8.13 requires pointer types to be const-qualified when they are only used to read object data. In MHD_SHA512_256_update the input data is declared as const uint8_t *data and is passed unchanged to sha512_256_transform (sha512_256_transform(ctx->H, data)). If sha512_256_transform\u2019s prototype declares the block parameter as a non-const pointer (for example uint8_t *block or uint8_t block[...]) yet the function only reads from the block, then the block parameter should be declared const and Rule 8.13 is violated \u2014 so Agent A\u2019s claim is correct in that scenario. Conversely, if sha512_256_transform legitimately modifies the buffer or its prototype already uses a const-qualified pointer, there is no Rule 8.13 violation. In short: the report is correct when sha512_256_transform\u2019s parameter is non-const but only used for reading; otherwise the report is not applicable."
}