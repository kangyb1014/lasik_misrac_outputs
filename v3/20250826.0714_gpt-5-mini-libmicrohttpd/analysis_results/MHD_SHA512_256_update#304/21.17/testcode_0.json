{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the debug assertion mhd_assert is compiled out (as in production) and the caller passes data == NULL with length > 0, the memcpy call will dereference a NULL source pointer and access beyond the bounds of the object referenced by 'data'. Equally, if the invariant that ctx->buffer is at least SHA512_256_BLOCK_SIZE bytes is violated (or bytes_have + length > SHA512_256_BLOCK_SIZE due to corrupted ctx->count), the memcpy destination would overflow the buffer.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_SHA512_256_update code that contains useful probe functions that print useful logs to a file \"/tmp/logs/3049.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_SHA512_256_update as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_SHA512_256_update:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\nPlease provide the modified MHD_SHA512_256_update code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <stddef.h>\n\nstatic void mhd_logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/3049.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  /* Log entry with caller-provided pointers/length. Do not dereference ctx here\n     so we preserve original crash behavior if ctx is NULL. */\n  mhd_logf(\"ENTRY: ctx=%p data=%p length=%zu\", (void *)ctx, (const void *)data, length);\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Log state after computing bytes_have but before modifying ctx->count */\n  mhd_logf(\"STATE before count update: ctx=%p bytes_have=%u ctx->count(before)=%\" PRIu64,\n           (void *)ctx, bytes_have, ctx->count);\n\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  /* Log state after count update */\n  mhd_logf(\"STATE after count update: ctx=%p bytes_have=%u ctx->count=%\" PRIu64 \" ctx->count_bits_hi=%\" PRIu64 \" count_hi=%\" PRIu64,\n           (void *)ctx, bytes_have, ctx->count, ctx->count_bits_hi, count_hi);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      /* Probe logging immediately before memcpy that may read from data and write into ctx->buffer. */\n      mhd_logf(\"COPY1: dest=(%p)+%u bytes_left=%u length=%zu data=%p\",\n               (void *)ctx->buffer, bytes_have, bytes_left, length, (const void *)data);\n\n      if (data == NULL && bytes_left > 0 && length > 0) {\n        mhd_logf(\"POTENTIAL_VIOLATION: source data is NULL while bytes_left=%u length=%zu -> memcpy will dereference NULL\",\n                 bytes_left, length);\n      }\n\n      /* We intentionally do not change program flow or prevent the memcpy; we only log. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      mhd_logf(\"COPY1_DONE: dest=(%p)+%u copied=%u\", (void *)ctx->buffer, bytes_have, bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    mhd_logf(\"TRANSFORM: full block at data=%p remaining_length=%zu\", (const void *)data, length);\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    /* Probe logging immediately before final memcpy that may overflow the destination. */\n    mhd_logf(\"COPY2: dest=(%p)+%u length=%zu data=%p\", (void *)ctx->buffer, bytes_have, length, (const void *)data);\n\n    /* Check and log potential destination overflow without altering program behavior. */\n    if ((size_t)bytes_have + length > (size_t)SHA512_256_BLOCK_SIZE) {\n      mhd_logf(\"POTENTIAL_VIOLATION: dest overflow: bytes_have+length=%zu > SHA512_256_BLOCK_SIZE=%d\",\n               (size_t)bytes_have + length, SHA512_256_BLOCK_SIZE);\n    }\n\n    if (data == NULL && length > 0) {\n      mhd_logf(\"POTENTIAL_VIOLATION: source data is NULL while length=%zu -> memcpy will dereference NULL\", length);\n    }\n\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    mhd_logf(\"COPY2_DONE: dest=(%p)+%u copied=%zu\", (void *)ctx->buffer, bytes_have, length);\n  }\n\n  mhd_logf(\"EXIT: ctx=%p remaining_length=%zu\", (void *)ctx, length);\n}\n"
}