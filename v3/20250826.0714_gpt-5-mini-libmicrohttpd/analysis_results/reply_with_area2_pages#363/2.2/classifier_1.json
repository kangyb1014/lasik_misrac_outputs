{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of reply_with_area2_pages:\n```c\nstatic enum MHD_Result\nreply_with_area2_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA2_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Very restricted secret page</title></head>\" \\\n      \"<body>Welcome to the super restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA2_URL \"other_path/other_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 == strcmp (url, SEC_AREA2_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Very restricted secret page</title></head>\" \\\n      \"<body>Welcome to the super restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. All executed statements in the fragment contribute to the observable program behaviour: creating the response, checking for NULL, optionally adding the Content-Type header, queuing the response and destroying it. The (void) cast only ignores the return value \u2014 the function is still executed and affects the HTTP response (so its removal would change behaviour). The #if 0 block in the full file is not compiled and thus not considered dead code per the standard notes."
}