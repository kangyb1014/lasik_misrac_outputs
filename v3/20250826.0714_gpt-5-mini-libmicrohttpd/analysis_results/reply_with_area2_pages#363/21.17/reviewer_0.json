{
  "user_message": "An agent A claimed that the following reply_with_area2_pages code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of reply_with_area2_pages.\n```c\nstatic enum MHD_Result\nreply_with_area2_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA2_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Very restricted secret page</title></head>\" \\\n      \"<body>Welcome to the super restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA2_URL \"other_path/other_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf 'url' is not guaranteed to be a NUL-terminated string (for example it comes from a fixed-size network buffer that may not contain a terminating '\\0'), calling strcmp(url, SEC_AREA2_URL \"other_path/other_page\") will cause strcmp to read past the end of the 'url' object while searching for the terminator, producing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17. (Note: the concatenated string literal is itself properly NUL-terminated; the risk comes from the 'url' operand.)\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in the relevant sense: calling strcmp(url, ...) assumes that the object pointed to by url is a NUL-terminated char array. If url can point to a fixed-size network buffer that is not guaranteed to contain a terminating '\\0', strcmp will scan past the buffer looking for the terminator and thus may access memory beyond the bounds of the object \u2014 exactly what MISRA C:2023 Rule 21.17 forbids. In the snippet shown there is no local check or documented assertion that url is NUL-terminated, so the use of strcmp is potentially non-compliant. If, however, the surrounding API (e.g. the libmicrohttpd handler contract) formally guarantees that url is always a NUL-terminated string, then the use of strcmp is safe and the reported violation would be incorrect; that external guarantee must be documented or proven. To be MISRA-compliant without relying on external guarantees either validate/ensure termination or use a bounded comparison (e.g. use a length-aware compare with an explicit maximum length after verifying the buffer size)."
}