{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_sys_cpu_count_sysctl_:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_ (void)\n{\n  int ret = -1;\n  /* Do not use sysctl() function on GNU/Linux even if\n     sysctl() is available */\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The number of available logical CPUs */\n    if ((0 != sysctlbyname (\"hw.logicalcpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* FreeBSD: The number of online CPUs */\n    if ((0 != sysctlbyname (\"kern.smp.cpus\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The current number of CPUs available to run threads */\n    if ((0 != sysctlbyname (\"hw.activecpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* OpenBSD, NetBSD: The number of online CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpuonline\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The old/alternative name for \"hw.activecpu\" */\n    if ((0 != sysctlbyname (\"hw.availcpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_NCPUONLINE)\n  if (0 >= ret)\n  {\n    /* OpenBSD, NetBSD: The number of online CPUs */\n    int mib[2] = {CTL_HW, HW_NCPUONLINE};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPUONLINE */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_AVAILCPU)\n  if (0 >= ret)\n  {\n    /* Darwin: The MIB name for \"hw.activecpu\" */\n    int mib[2] = {CTL_HW, HW_AVAILCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_AVAILCPU */\n#endif /* ! __linux__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nsize_t value_size = sizeof (ret);\n    /* OpenBSD, NetBSD: The number of online CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpuonline\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The code initializes value_size to sizeof(ret), passes it to sysctlbyname (which takes the address and may modify it), then checks whether sysctlbyname failed or the returned size differs from sizeof(ret). The initialization of value_size and the subsequent comparison are meaningful: value_size is an in/out parameter to sysctlbyname and the comparison detects an unexpected returned size. Thus these operations are not dead code."
}