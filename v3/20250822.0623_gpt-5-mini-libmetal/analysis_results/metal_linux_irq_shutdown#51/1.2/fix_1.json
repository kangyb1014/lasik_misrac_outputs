{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nvoid metal_log(int level, const char *fmt, ...);\nstatic void probe_write(const char *label, int ret)\n{\n    FILE *f;\n    /* Ensure directory exists (ignore errors) */\n    (void)mkdir(\"/tmp/logs\", 0755);\n\n    f = fopen(\"/tmp/logs/510.txt\", \"a\");\n    if (!f) {\n        /* If logging fails, avoid disturbing original logic; return silently. */\n        return;\n    }\n\n    /* Write a single-line record with relevant state */\n    fprintf(f, \"%s: label=%s, ret=%d, irq_notify_fd=%d, irq_handling_stop=%d, irq_pthread=%lu\\n\",\n            \"metal_linux_irq_shutdown\", label, ret, irq_notify_fd,\n            (int)(irq_handling_stop ? 1 : 0), (unsigned long)irq_pthread);\n\n    fclose(f);\n}\n\nvoid metal_linux_irq_shutdown(void)\n{\n    int ret;\n\n    /* Log entry to probe file before calling metal_log */\n    probe_write(\"entry_before_metal_log_debug\", 0);\n\n    /* Original log call (may be a macro in the real project) */\n    metal_log(METAL_LOG_DEBUG, \"%s\\n\", __func__);\n\n    /* Record that we set irq_handling_stop and then notify */\n    probe_write(\"before_setting_irq_handling_stop\", 0);\n\n    irq_handling_stop = true;\n\n    probe_write(\"after_setting_irq_handling_stop_before_notify\", 0);\n\n    metal_linux_irq_notify();\n\n    probe_write(\"after_notify_before_join\", 0);\n\n    ret = pthread_join(irq_pthread, NULL);\n\n    /* Record the join result and related state */\n    probe_write(\"after_join\", ret);\n\n    if (ret) {\n        /* Preserve original behavior: call metal_log and also record additional info */\n        metal_log(METAL_LOG_ERROR, \"Failed to join IRQ thread: %d.\\n\",\n                  ret);\n\n        /* Add more context about the error to the probe file */\n        probe_write(\"join_failed_with_error\", ret);\n\n        /* Attempt to record a human readable form of the error code */\n        {\n            char errbuf[128];\n            /* Use strerror_r where available, but keep simple and portable: */\n            const char *s = strerror_r(ret, errbuf, sizeof(errbuf));\n            if (!s) {\n                s = errbuf; /* if strerror_r returned 0 but filled buf */\n            }\n            FILE *f = fopen(\"/tmp/logs/510.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"%s: join_error_description=%s\\n\",\n                        \"metal_linux_irq_shutdown\", s);\n                fclose(f);\n            }\n        }\n    }\n\n    /* Continue original cleanup */\n    close(irq_notify_fd);\n    metal_mutex_deinit(&irq_lock);\n\n    probe_write(\"exit\", ret);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\nIn file included from /tmp/tmpn3kxar3g/build/lib/include/metal/sys.h:18,\n                 from /tmp/tmpn3kxar3g/build/lib/include/metal/io.h:22,\n                 from /tmp/tmpn3kxar3g/build/lib/include/metal/device.h:16,\n                 from /tmp/tmpn3kxar3g/src/lib/system/linux/irq.c:27:\n/tmp/tmpn3kxar3g/build/lib/include/metal/log.h:98:37: error: expected identifier or '(' before '{' token\n   98 | #define metal_log(level, fmt, ...) ({                              \\\n      |                                     ^\n/tmp/tmpn3kxar3g/src/lib/system/linux/irq.c:264:6: note: in expansion of macro 'metal_log'\n  264 | void metal_log(int level, const char *fmt, ...);\n      |      ^~~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:244: lib/CMakeFiles/metal-shared.dir/system/linux/irq.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_linux_irq_shutdown as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void probe_write(const char *label, int ret)\n{\n    FILE *f;\n    /* Ensure directory exists (ignore errors) */\n    (void)mkdir(\"/tmp/logs\", 0755);\n\n    f = fopen(\"/tmp/logs/510.txt\", \"a\");\n    if (!f) {\n        /* If logging fails, avoid disturbing original logic; return silently. */\n        return;\n    }\n\n    /* Write a single-line record with relevant state */\n    fprintf(f, \"%s: label=%s, ret=%d, irq_notify_fd=%d, irq_handling_stop=%d, irq_pthread=%lu\\n\",\n            \"metal_linux_irq_shutdown\", label, ret, irq_notify_fd,\n            (int)(irq_handling_stop ? 1 : 0), (unsigned long)irq_pthread);\n\n    fclose(f);\n}\n\nvoid metal_linux_irq_shutdown(void)\n{\n    int ret;\n\n    /* Log entry to probe file before calling metal_log */\n    probe_write(\"entry_before_metal_log_debug\", 0);\n\n    /* Original log call (may be a macro in the real project) */\n    metal_log(METAL_LOG_DEBUG, \"%s\\n\", __func__);\n\n    /* Record that we set irq_handling_stop and then notify */\n    probe_write(\"before_setting_irq_handling_stop\", 0);\n\n    irq_handling_stop = true;\n\n    probe_write(\"after_setting_irq_handling_stop_before_notify\", 0);\n\n    metal_linux_irq_notify();\n\n    probe_write(\"after_notify_before_join\", 0);\n\n    ret = pthread_join(irq_pthread, NULL);\n\n    /* Record the join result and related state */\n    probe_write(\"after_join\", ret);\n\n    if (ret) {\n        /* Preserve original behavior: call metal_log and also record additional info */\n        metal_log(METAL_LOG_ERROR, \"Failed to join IRQ thread: %d.\\n\",\n                  ret);\n\n        /* Add more context about the error to the probe file */\n        probe_write(\"join_failed_with_error\", ret);\n\n        /* Attempt to record a human readable form of the error code */\n        {\n            char errbuf[128];\n            /* Use strerror_r where available, but keep simple and portable: */\n            const char *s = strerror_r(ret, errbuf, sizeof(errbuf));\n            if (!s) {\n                s = errbuf; /* if strerror_r returned 0 but filled buf */\n            }\n            FILE *f = fopen(\"/tmp/logs/510.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"%s: join_error_description=%s\\n\",\n                        \"metal_linux_irq_shutdown\", s);\n                fclose(f);\n            }\n        }\n    }\n\n    /* Continue original cleanup */\n    close(irq_notify_fd);\n    metal_mutex_deinit(&irq_lock);\n\n    probe_write(\"exit\", ret);\n}\n",
  "explanation": "The compilation error was caused by a prototype declaration for metal_log which conflicts with a macro named metal_log defined in the included headers. I removed the redundant prototype declaration (void metal_log(...);). The code now relies on the metal_log macro provided by the project headers, preserving the original logic."
}