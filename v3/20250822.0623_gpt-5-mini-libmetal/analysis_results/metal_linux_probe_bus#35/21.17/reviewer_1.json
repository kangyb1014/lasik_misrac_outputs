{
  "user_message": "An agent A claimed that the following metal_linux_probe_bus code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_probe_bus.\n```c\nstatic int metal_linux_probe_bus(struct linux_bus *lbus)\n{\n\tstruct linux_driver *ldrv;\n\tint ret, error = -ENODEV;\n\n\tlbus->sbus = sysfs_open_bus(lbus->bus_name);\n\tif (!lbus->sbus)\n\t\treturn -ENODEV;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tret = metal_linux_probe_driver(lbus, ldrv);\n\t\t/* Clear the error if any driver is available */\n\t\tif (!ret)\n\t\t\terror = ret;\n\t}\n\n\tif (error) {\n\t\tmetal_linux_bus_close(&lbus->bus);\n\t\treturn error;\n\t}\n\n\terror = metal_linux_register_bus(lbus);\n\tif (error)\n\t\tmetal_linux_bus_close(&lbus->bus);\n\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nmetal_linux_register_bus assigns lbus->bus.name = lbus->bus_name and then calls metal_bus_register(&lbus->bus). metal_bus_register calls strlen(bus->name). If lbus->bus_name does not point to a valid NUL-terminated string (for example it points to a non-terminated char buffer, a truncated slice, or a dangling/invalid pointer), the call to strlen can read beyond the bounds of the object, violating Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_linux_probe_bus: lbus=0x7f678eaccb60, lbus->bus_name=0x7f678eac6730, &lbus->bus=0x7f678eaccb60\nsysfs_open_bus returned sbus=0x5614625078c0 for bus_name=0x7f678eac6730\nPROBE START: ldrv=0x7f678eaccbc0 for lbus=0x7f678eaccb60\nPROBE RESULT: ldrv=0x7f678eaccbc0 returned 0\nPROBE START: ldrv=0x7f678eaccc08 for lbus=0x7f678eaccb60\nPROBE RESULT: ldrv=0x7f678eaccc08 returned 0\nNo probe errors, about to call metal_linux_register_bus: lbus=0x7f678eaccb60, bus_name=0x7f678eac6730, &lbus->bus=0x7f678eaccb60\nAFTER REGISTER: metal_linux_register_bus returned 0 for lbus=0x7f678eaccb60\nRegistration succeeded for lbus=0x7f678eaccb60\nEXIT: metal_linux_probe_bus returning 0\nENTER: metal_linux_probe_bus: lbus=0x7f678eacddc8, lbus->bus_name=0x7f678eac675d, &lbus->bus=0x7f678eacddc8\nsysfs_open_bus returned sbus=0x561462507d60 for bus_name=0x7f678eac675d\nPROBE START: ldrv=0x7f678eacde28 for lbus=0x7f678eacddc8\nPROBE RESULT: ldrv=0x7f678eacde28 returned 0\nPROBE START: ldrv=0x7f678eacde70 for lbus=0x7f678eacddc8\nPROBE RESULT: ldrv=0x7f678eacde70 returned 0\nNo probe errors, about to call metal_linux_register_bus: lbus=0x7f678eacddc8, bus_name=0x7f678eac675d, &lbus->bus=0x7f678eacddc8\nAFTER REGISTER: metal_linux_register_bus returned 0 for lbus=0x7f678eacddc8\nRegistration succeeded for lbus=0x7f678eacddc8\nEXIT: metal_linux_probe_bus returning 0\nENTER: metal_linux_probe_bus: lbus=0x5649fb941260, lbus->bus_name=0x5649fb939220, &lbus->bus=0x5649fb941260\nsysfs_open_bus returned sbus=0x564a31af78c0 for bus_name=0x5649fb939220\nPROBE START: ldrv=0x5649fb9412c0 for lbus=0x5649fb941260\nPROBE RESULT: ldrv=0x5649fb9412c0 returned 0\nPROBE START: ldrv=0x5649fb941308 for lbus=0x5649fb941260\nPROBE RESULT: ldrv=0x5649fb941308 returned 0\nNo probe errors, about to call metal_linux_register_bus: lbus=0x5649fb941260, bus_name=0x5649fb939220, &lbus->bus=0x5649fb941260\nAFTER REGISTER: metal_linux_register_bus returned 0 for lbus=0x5649fb941260\nRegistration succeeded for lbus=0x5649fb941260\nEXIT: metal_linux_probe_bus returning 0\nENTER: metal_linux_probe_bus: lbus=0x5649fb9424c8, lbus->bus_name=0x5649fb93924d, &lbus->bus=0x5649fb9424c8\nsysfs_open_bus returned sbus=0x564a31af7d60 for bus_name=0x5649fb93924d\nPROBE START: ldrv=0x5649fb942528 for lbus=0x5649fb9424c8\nPROBE RESULT: ldrv=0x5649fb942528 returned 0\nPROBE START: ldrv=0x5649fb942570 for lbus=0x5649fb9424c8\nPROBE RESULT: ldrv=0x5649fb942570 returned 0\nNo probe errors, about to call metal_linux_register_bus: lbus=0x5649fb9424c8, bus_name=0x5649fb93924d, &lbus->bus=0x5649fb9424c8\nAFTER REGISTER: metal_linux_register_bus returned 0 for lbus=0x5649fb9424c8\nRegistration succeeded for lbus=0x5649fb9424c8\nEXIT: metal_linux_probe_bus returning 0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_probe_bus:\nstruct linux_bus {\n\tstruct metal_bus\tbus;\n\tconst char\t\t*bus_name;\n\tstruct linux_driver\tdrivers[MAX_DRIVERS];\n\tstruct sysfs_bus\t*sbus;\n}\n...\nstruct linux_driver {\n\tconst char\t\t*drv_name;\n\tconst char\t\t*mod_name;\n\tconst char\t\t*cls_name;\n\tstruct sysfs_driver\t*sdrv;\n\tint\t\t\t(*dev_open)(struct linux_bus *lbus,\n\t\t\t\t\t    struct linux_device *ldev);\n\tvoid\t\t\t(*dev_close)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev);\n\tvoid\t\t\t(*dev_irq_ack)(struct linux_bus *lbus,\n\t\t\t\t\t     struct linux_device *ldev,\n\t\t\t\t\t     int irq);\n\tint\t\t\t(*dev_dma_map)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg_in,\n\t\t\t\t\t\tint nents_in,\n\t\t\t\t\t\tstruct metal_sg *sg_out);\n\tvoid\t\t\t(*dev_dma_unmap)(struct linux_bus *lbus,\n\t\t\t\t\t\tstruct linux_device *ldev,\n\t\t\t\t\t\tuint32_t dir,\n\t\t\t\t\t\tstruct metal_sg *sg,\n\t\t\t\t\t\tint nents);\n}\n...\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n...\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n...\nstatic struct linux_bus *to_linux_bus(struct metal_bus *bus)\n{\n\treturn metal_container_of(bus, struct linux_bus, bus);\n}\n...\nstatic int metal_linux_register_bus(struct linux_bus *lbus)\n{\n\tlbus->bus.name = lbus->bus_name;\n\tlbus->bus.ops  = metal_linux_bus_ops;\n\treturn metal_bus_register(&lbus->bus);\n}\n...\nint metal_bus_register(struct metal_bus *bus)\n{\n\tif (!bus || !bus->name || !strlen(bus->name))\n\t\treturn -EINVAL;\n\tif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n\tmetal_list_init(&bus->devices);\n\tmetal_list_add_tail(&_metal.common.bus_list, &bus->node);\n\tmetal_log(METAL_LOG_DEBUG, \"registered %s bus\\n\", bus->name);\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's scenario is correct: metal_linux_probe_bus assigns lbus->bus.name = lbus->bus_name and then calls metal_bus_register (via metal_linux_register_bus). metal_bus_register calls strlen(bus->name). If lbus->bus_name does not point to a valid NUL-terminated character array, the call to strlen may read past the bounds of the object and therefore can violate MISRA C 2023 Rule 21.17. The presented code does not perform any explicit validation that lbus->bus_name is NUL-terminated before passing it on, so unless there is an external/invariant guarantee (documented precondition or initialization invariant) that bus_name is always a valid NUL-terminated string, this is a potential Rule 21.17 violation. Note: in practice sysfs_open_bus was called earlier with the same pointer and succeeded in the execution log (which suggests bus_name is valid at runtime), but that runtime evidence does not eliminate the static possibility that a non-terminated pointer could be passed \u2014 and MISRA requires eliminating such possibilities or proving the precondition. To be compliant, either prove/document that bus_name is always a valid NUL-terminated string or add explicit checks or use a bounded alternative (e.g. strnlen with a documented maximum) before calling strlen."
}