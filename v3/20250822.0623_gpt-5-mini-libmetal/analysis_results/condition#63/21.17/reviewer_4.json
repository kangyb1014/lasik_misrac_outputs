{
  "user_message": "An agent A claimed that the following condition code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of condition.\n```c\nstatic int condition(void)\n{\n\tint ret;\n\tint ts_created;\n\tpthread_t tids[THREADS];\n\n\t/** TC1 consumer threads go first */\n\t/** create 10 consumer threads first */\n\tret = metal_run_noblock(THREADS, consumer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 producer threads next */\n\tret = metal_run(THREADS, producer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** wait for consumer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\n\t/** TC2 producer threads go first */\n\t/** create 10 producer threads first */\n\tret = metal_run_noblock(THREADS, producer_thread, NULL, tids,\n\t\t\t\t&ts_created);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create consumer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\n\t/** create 10 consumer threads next */\n\tret = metal_run(THREADS, consumer_thread, NULL);\n\tif (ret < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to create producer thread: %d.\\n\",\n\t\t\t  ret);\n\t\tgoto out;\n\t}\n\nout:\n\t/** wait for producer threads to finish */\n\tmetal_finish_threads(THREADS, (void *)tids);\n\treturn ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: pthread_create() returns a positive errno (e.g. EAGAIN == 11). The code sets error = -pthread_create(...), so on failure error becomes negative (e.g. -11). The fragment then calls strerror(error) with a negative errnum. strerror(expectation is a valid non\u2011negative errno) may index into its internal message table or otherwise access memory based on errnum; passing a negative value can cause out\u2011of\u2011bounds access of the internal data and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[condition] stage=after_metal_run_noblock_consumers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_noblock_consumers tids[0]=139844990785088\n[condition] after_metal_run_noblock_consumers tids[1]=139844999177792\n[condition] after_metal_run_noblock_consumers tids[2]=139845007570496\n[condition] after_metal_run_noblock_consumers tids[3]=139845486384704\n[condition] stage=after_metal_run_producers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_producers tids[0]=139844990785088\n[condition] after_metal_run_producers tids[1]=139844999177792\n[condition] after_metal_run_producers tids[2]=139845007570496\n[condition] after_metal_run_producers tids[3]=139845486384704\n[condition] stage=after_metal_run_noblock_producers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_noblock_producers tids[0]=139845503170112\n[condition] after_metal_run_noblock_producers tids[1]=139845511562816\n[condition] after_metal_run_noblock_producers tids[2]=139845519955520\n[condition] after_metal_run_noblock_producers tids[3]=139845528348224\n[condition] stage=after_metal_run_consumers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_consumers tids[0]=139845503170112\n[condition] after_metal_run_consumers tids[1]=139845511562816\n[condition] after_metal_run_consumers tids[2]=139845519955520\n[condition] after_metal_run_consumers tids[3]=139845528348224\n[condition] stage=exit_condition ret=0 errno=0 ts_created=10\n[condition] exit_condition tids[0]=139845503170112\n[condition] exit_condition tids[1]=139845511562816\n[condition] exit_condition tids[2]=139845519955520\n[condition] exit_condition tids[3]=139845528348224\n[condition] stage=after_metal_run_noblock_consumers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_noblock_consumers tids[0]=140517723575872\n[condition] after_metal_run_noblock_consumers tids[1]=140517731968576\n[condition] after_metal_run_noblock_consumers tids[2]=140517740361280\n[condition] after_metal_run_noblock_consumers tids[3]=140517748753984\n[condition] stage=after_metal_run_producers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_producers tids[0]=140517723575872\n[condition] after_metal_run_producers tids[1]=140517731968576\n[condition] after_metal_run_producers tids[2]=140517740361280\n[condition] after_metal_run_producers tids[3]=140517748753984\n[condition] stage=after_metal_run_noblock_producers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_noblock_producers tids[0]=140517765539392\n[condition] after_metal_run_noblock_producers tids[1]=140517773932096\n[condition] after_metal_run_noblock_producers tids[2]=140517855073856\n[condition] after_metal_run_noblock_producers tids[3]=140517863466560\n[condition] stage=after_metal_run_consumers ret=0 errno=0 ts_created=10\n[condition] after_metal_run_consumers tids[0]=140517765539392\n[condition] after_metal_run_consumers tids[1]=140517773932096\n[condition] after_metal_run_consumers tids[2]=140517855073856\n[condition] after_metal_run_consumers tids[3]=140517863466560\n[condition] stage=exit_condition ret=0 errno=0 ts_created=10\n[condition] exit_condition tids[0]=140517765539392\n[condition] exit_condition tids[1]=140517773932096\n[condition] exit_condition tids[2]=140517855073856\n[condition] exit_condition tids[3]=140517863466560\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function condition:\nint metal_run_noblock(int threads, metal_thread_t child,\n\t\t     void *arg, void *tids, int *threads_out)\n{\n\tint error, i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < threads; i++) {\n\t\terror = -pthread_create(&tid_p[i], NULL, child, arg);\n\t\tif (error) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"failed to create thread - %s\\n\",\n\t\t\t\t  strerror(error));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*threads_out = i;\n\treturn error;\n}\n...\nint metal_run(int threads, metal_thread_t child, void *arg)\n{\n\tpthread_t tids[threads];\n\tint error, ts_created;\n\n\terror = metal_run_noblock(threads, child, arg, tids, &ts_created);\n\n\tmetal_finish_threads(ts_created, (void *)tids);\n\n\treturn error;\n}\n...\nvoid metal_finish_threads(int threads, void *tids)\n{\n\tint i;\n\tpthread_t *tid_p = (pthread_t *)tids;\n\n\tif (!tids) {\n\t\tmetal_log(METAL_LOG_ERROR, \"invalid argument, tids is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < threads; i++)\n\t\t(void)pthread_join(tid_p[i], NULL);\n}\n...\nstatic void *consumer_thread(void *arg)\n{\n\t(void)arg;\n\tmetal_mutex_acquire(&lock);\n\twhile (!counter)\n\t\tmetal_condition_wait(&nempty_condv, &lock);\n\tcounter--;\n\tmetal_condition_signal(&nfull_condv);\n\tmetal_mutex_release(&lock);\n\n\treturn NULL;\n}\n...\nstatic void *producer_thread(void *arg)\n{\n\t(void)arg;\n\tmetal_mutex_acquire(&lock);\n\twhile (counter == COUNTER_MAX)\n\t\tmetal_condition_wait(&nfull_condv, &lock);\n\tcounter++;\n\tmetal_condition_signal(&nempty_condv);\n\tmetal_mutex_release(&lock);\n\n\treturn NULL;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\n#define THREADS 10\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. metal_run_noblock() negates the pthread_create() return value (error = -pthread_create(...)). On POSIX, pthread_create() returns 0 on success or a positive errno value on failure. If pthread_create() fails with a positive errno (e.g. EAGAIN == 11), error becomes negative (e.g. -11) and the code calls strerror(error). strerror is a string-handling function (declared in <string.h>) that expects a non-negative errno; implementations may use the supplied errnum to index internal tables and passing a negative value can lead to out-of-bounds accesses. That is exactly the kind of potential out-of-bounds access of a string.h routine that MISRA C 2023 Rule 21.17 forbids. The execution log shows no such failure in the observed runs, but the code is still incorrect and can trigger the violation at runtime. Recommended fixes: do not negate the pthread_create() return before calling strerror (e.g. call strerror(ret) when ret is the positive error code), or convert to a non-negative errno before calling strerror (e.g. strerror(-error) if you intend to keep error negative for returns)."
}