{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_bus_register:\n```c\nint metal_bus_register(struct metal_bus *bus)\n{\n\tif (!bus || !bus->name || !strlen(bus->name))\n\t\treturn -EINVAL;\n\tif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n\tmetal_list_init(&bus->devices);\n\tmetal_list_add_tail(&_metal.common.bus_list, &bus->node);\n\tmetal_log(METAL_LOG_DEBUG, \"registered %s bus\\n\", bus->name);\n\treturn 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_bus_register:\nstruct metal_bus {\n\tconst char\t\t*name;\n\tstruct metal_bus_ops\tops;\n\tstruct metal_list\tdevices;\n\tstruct metal_list\tnode;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (metal_bus_find(bus->name, NULL) == 0)\n\t\treturn -EEXIST;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The condition if (metal_bus_find(bus->name, NULL) == 0) is a runtime check whose outcome depends on the result of metal_bus_find and on the current bus registry; it does not create code that can never be executed. The subsequent initialization and registration code is reachable when metal_bus_find does not return 0. (Hypothetical violating scenario: if metal_bus_find were a constant-return stub or macro that always returns 0 for all inputs\u2014e.g. #define metal_bus_find(...) 0 or an inline function that unconditionally returns 0\u2014then the registration code after this check would be unreachable for all valid inputs and would violate MISRA C 2023 Rule 2.1.)"
}