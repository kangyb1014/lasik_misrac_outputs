{
  "user_message": "Target function code is:\n```c\nstatic void metal_softirq_set_enable(struct metal_irq_controller *cntr,\n\t\t\t\t     int irq, unsigned int enable)\n{\n\tif (irq < cntr->irq_base ||\n\t    irq >= (cntr->irq_base + cntr->irq_num)) {\n\t\treturn;\n\t}\n\n\tirq -= cntr->irq_base;\n\tif (enable ==  METAL_IRQ_ENABLE) {\n\t\tatomic_store(&metal_softirq_enabled[irq], 1);\n\t} else {\n\t\tatomic_store(&metal_softirq_enabled[irq], 0);\n\t}\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct metal_irq_controller",
    "metal_softirq_enabled",
    "METAL_IRQ_ENABLE",
    "atomic_store",
    "typedefs used by metal_softirq_enabled (e.g. atomic_int, atomic_t, _Atomic types)",
    "headers that define atomic_store (e.g. <stdatomic.h> or project atomic header)",
    "compiler feature macros (__STDC_VERSION__)",
    "compiler builtin symbols potentially used by atomic implementation (__atomic_store_n, __sync_* builtins)"
  ],
  "explanation": "- struct metal_irq_controller: The function accesses cntr->irq_base and cntr->irq_num. The field types (and whether the struct contains bit-fields, anonymous unions, attributes or nonstandard extensions) must be known to determine if any language extensions are used.\n\n- metal_softirq_enabled: The declaration and type of this array are required to see whether it uses C11 _Atomic, a compiler-specific atomic type, or other nonstandard constructs (e.g. GCC atomic types, custom macros). That determines if the code relies on language/compiler extensions.\n\n- METAL_IRQ_ENABLE: The macro/constant definition must be checked to ensure it is a plain constant and does not expand to a compiler extension (statement-expression, typeof, attributes, or other nonstandard constructs).\n\n- atomic_store: You must inspect the definition or declaration of atomic_store to tell if it is the standard C11 atomic_store (stdatomic), or a project/macro wrapper that maps to compiler builtins or uses extensions. Its implementation may hide extension usage.\n\n- typedefs used by metal_softirq_enabled (e.g. atomic_int, atomic_t, _Atomic types): If the array uses a typedef name, you need that typedef to see whether it resolves to a standard _Atomic type or to a compiler-specific type/extension.\n\n- headers that define atomic_store (e.g. <stdatomic.h> or project atomic header): The header shows whether standard library facilities are used or a custom/extension-based implementation (and may contain macros that expand to compiler builtins or attributes).\n\n- compiler feature macros (__STDC_VERSION__): To decide whether constructs like _Atomic or stdatomic are standard in the used language mode (C11+) or would be considered extensions for the project\u2019s configured language standard.\n\n- compiler builtin symbols potentially used by atomic implementation (__atomic_store_n, __sync_* builtins): If atomic_store is implemented using GCC/Clang builtins, those builtins are compiler extensions; detecting their use is necessary to report a violation."
}