{
  "user_message": "An agent A claimed that the following metal_io_block_read code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_io_block_read.\n```c\nint metal_io_block_read(struct metal_io_region *io, unsigned long offset,\n\t       void *restrict dst, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tunsigned char *dest = dst;\n\tint retlen;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_read) {\n\t\tretlen = (*io->ops.block_read)(\n\t\t\tio, offset, dst, memory_order_seq_cst, len);\n\t} else {\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t\twhile ( len && (\n\t\t\t((uintptr_t)dest % sizeof(int)) ||\n\t\t\t((uintptr_t)ptr % sizeof(int)))) {\n\t\t\t*(unsigned char *)dest =\n\t\t\t\t*(const unsigned char *)ptr;\n\t\t\tdest++;\n\t\t\tptr++;\n\t\t\tlen--;\n\t\t}\n\t\tfor (; len >= (int)sizeof(int); dest += sizeof(int),\n\t\t\t\t\tptr += sizeof(int),\n\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)dest = *(const unsigned int *)ptr;\n\t\tfor (; len != 0; dest++, ptr++, len--)\n\t\t\t*(unsigned char *)dest =\n\t\t\t\t*(const unsigned char *)ptr;\n\t}\n\treturn retlen;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call is through a function pointer (io->ops.block_write). If that pointer is initialized to point to metal_io_block_write itself (or to another function that eventually calls metal_io_block_write), then metal_io_block_write will call itself indirectly via the function pointer, causing indirect recursion and violating MISRA C 2023 Rule 17.2. The same reasoning applies to the analogous block_read call if io->ops.block_read points to metal_io_block_read.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function metal_io_block_read:\nint metal_io_block_write(struct metal_io_region *io, unsigned long offset,\n\t       const void *restrict src, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tconst unsigned char *source = src;\n\tint retlen;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_write) {\n\t\tretlen = (*io->ops.block_write)(\n\t\t\tio, offset, src, memory_order_seq_cst, len);\n\t} else {\n\t\twhile ( len && (\n\t\t\t((uintptr_t)ptr % sizeof(int)) ||\n\t\t\t((uintptr_t)source % sizeof(int)))) {\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\t\tptr++;\n\t\t\tsource++;\n\t\t\tlen--;\n\t\t}\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\tsource += sizeof(int),\n\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = *(const unsigned int *)source;\n\t\tfor (; len != 0; ptr++, source++, len--)\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n...\nint metal_io_block_set(struct metal_io_region *io, unsigned long offset,\n\t       unsigned char value, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tint retlen = len;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_set) {\n\t\t(*io->ops.block_set)(\n\t\t\tio, offset, value, memory_order_seq_cst, len);\n\t} else {\n\t\tunsigned int cint = value;\n\t\tunsigned int i;\n\n\t\tfor (i = 1; i < sizeof(int); i++)\n\t\t\tcint |= ((unsigned int)value << (CHAR_BIT * i));\n\n\t\tfor (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = cint;\n\t\tfor (; len != 0; ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n...\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as stated. metal_io_block_read does call a function pointer (io->ops.block_read), and if that pointer were (mis)initialized to point back to metal_io_block_read (or to a chain that leads back to it) an indirect recursion would occur at runtime. However, MISRA C:2023 Rule 17.2 prohibits functions calling themselves (directly or indirectly) as an actual property of the program\u2019s call graph. The mere presence of a function-pointer call in the code is not by itself a proven violation; a violation only exists if the call graph (including how the function-pointer targets are initialized in the system) creates recursion. In the fragment shown there is no evidence that io->ops.block_read is set to metal_io_block_read, so you cannot conclude a Rule 17.2 violation from this code alone. If the wider system can allow the ops pointer to alias to the same wrapper, then the system design would need to prevent that or justify a deviation, but that is a separate design/initialization concern, not an automatic MISRA 17.2 violation of the shown function."
}