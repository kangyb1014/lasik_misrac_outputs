{
  "user_message": "An agent A claimed that the following metal_tests_run code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of metal_tests_run.\n```c\nint metal_tests_run(struct metal_init_params *params)\n{\n\tstruct metal_init_params dparams = METAL_INIT_DEFAULTS;\n\tstruct metal_test_case *test_case;\n\tstruct metal_list *node;\n\tint error, errors = 0;\n\tconst char *dots = \"..................................\";\n\tconst char *pad;\n\n\tif (!params)\n\t\tparams = &dparams;\n\n\tparams->log_level = METAL_LOG_DEBUG;\n\terror = metal_init(params);\n\tif (error)\n\t\treturn error;\n\n\tmetal_list_for_each(&test_cases, node) {\n\t\ttest_case = metal_container_of(node, struct metal_test_case,\n\t\t\t\t\t       node);\n\t\tpad = dots + strlen(test_case->name);\n\t\tmetal_log(METAL_LOG_INFO,\"running [%s]\\n\", test_case->name);\n\t\terror = test_case->test();\n\t\tmetal_log(METAL_LOG_INFO,\"result [%s]%s %s%s%s\\n\",\n\t\t       test_case->name, pad,\n\t\t       error ? \"fail\" : \"pass\",\n\t\t       error ? \" - error: \" : \"\",\n\t\t       error ? strerror(-error) : \"\");\n\t\tif (error)\n\t\t\terrors++;\n\t}\n\n\tmetal_finish();\n\n\treturn errors;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code computes pad = dots + strlen(test_case->name) and later passes pad as a %s argument to metal_log. If strlen(test_case->name) > strlen(dots) (for example, test_case->name is 40 chars while dots has 34), pad will point beyond the end of the dots array and the subsequent %s will read out-of-bounds. This can result in accesses beyond the bounds of the object referenced by the pointer parameter to the string-handling/printing routine, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[probe] running test case capture: name='atomic' name_len=6 dots_len=34 offset=6 diff=-28 pad_ptr=0x558551aae5ee\n[probe] about to call metal_log for start of test 'atomic' (pad=0x558551aae5ee, oob=NO)\n[probe] test finished: name='atomic' error=0 pad=0x558551aae5ee (name_len=6 dots_len=34 oob=NO)\n[probe] running test case capture: name='mutex' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x558551aae5ed\n[probe] about to call metal_log for start of test 'mutex' (pad=0x558551aae5ed, oob=NO)\n[probe] test finished: name='mutex' error=0 pad=0x558551aae5ed (name_len=5 dots_len=34 oob=NO)\n[probe] running test case capture: name='shmem' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x558551aae5ed\n[probe] about to call metal_log for start of test 'shmem' (pad=0x558551aae5ed, oob=NO)\n[probe] test finished: name='shmem' error=0 pad=0x558551aae5ed (name_len=5 dots_len=34 oob=NO)\n[probe] running test case capture: name='condition' name_len=9 dots_len=34 offset=9 diff=-25 pad_ptr=0x558551aae5f1\n[probe] about to call metal_log for start of test 'condition' (pad=0x558551aae5f1, oob=NO)\n[probe] test finished: name='condition' error=0 pad=0x558551aae5f1 (name_len=9 dots_len=34 oob=NO)\n[probe] running test case capture: name='spinlock' name_len=8 dots_len=34 offset=8 diff=-26 pad_ptr=0x558551aae5f0\n[probe] about to call metal_log for start of test 'spinlock' (pad=0x558551aae5f0, oob=NO)\n[probe] test finished: name='spinlock' error=0 pad=0x558551aae5f0 (name_len=8 dots_len=34 oob=NO)\n[probe] running test case capture: name='alloc' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x558551aae5ed\n[probe] about to call metal_log for start of test 'alloc' (pad=0x558551aae5ed, oob=NO)\n[probe] test finished: name='alloc' error=0 pad=0x558551aae5ed (name_len=5 dots_len=34 oob=NO)\n[probe] running test case capture: name='irq' name_len=3 dots_len=34 offset=3 diff=-31 pad_ptr=0x558551aae5eb\n[probe] about to call metal_log for start of test 'irq' (pad=0x558551aae5eb, oob=NO)\n[probe] test finished: name='irq' error=0 pad=0x558551aae5eb (name_len=3 dots_len=34 oob=NO)\n[probe] running test case capture: name='version' name_len=7 dots_len=34 offset=7 diff=-27 pad_ptr=0x558551aae5ef\n[probe] about to call metal_log for start of test 'version' (pad=0x558551aae5ef, oob=NO)\n[probe] test finished: name='version' error=0 pad=0x558551aae5ef (name_len=7 dots_len=34 oob=NO)\n[probe] running test case capture: name='atomic' name_len=6 dots_len=34 offset=6 diff=-28 pad_ptr=0x561a5d2b45ee\n[probe] about to call metal_log for start of test 'atomic' (pad=0x561a5d2b45ee, oob=NO)\n[probe] test finished: name='atomic' error=0 pad=0x561a5d2b45ee (name_len=6 dots_len=34 oob=NO)\n[probe] running test case capture: name='mutex' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x561a5d2b45ed\n[probe] about to call metal_log for start of test 'mutex' (pad=0x561a5d2b45ed, oob=NO)\n[probe] test finished: name='mutex' error=0 pad=0x561a5d2b45ed (name_len=5 dots_len=34 oob=NO)\n[probe] running test case capture: name='shmem' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x561a5d2b45ed\n[probe] about to call metal_log for start of test 'shmem' (pad=0x561a5d2b45ed, oob=NO)\n[probe] test finished: name='shmem' error=0 pad=0x561a5d2b45ed (name_len=5 dots_len=34 oob=NO)\n[probe] running test case capture: name='condition' name_len=9 dots_len=34 offset=9 diff=-25 pad_ptr=0x561a5d2b45f1\n[probe] about to call metal_log for start of test 'condition' (pad=0x561a5d2b45f1, oob=NO)\n[probe] test finished: name='condition' error=0 pad=0x561a5d2b45f1 (name_len=9 dots_len=34 oob=NO)\n[probe] running test case capture: name='spinlock' name_len=8 dots_len=34 offset=8 diff=-26 pad_ptr=0x561a5d2b45f0\n[probe] about to call metal_log for start of test 'spinlock' (pad=0x561a5d2b45f0, oob=NO)\n[probe] test finished: name='spinlock' error=0 pad=0x561a5d2b45f0 (name_len=8 dots_len=34 oob=NO)\n[probe] running test case capture: name='alloc' name_len=5 dots_len=34 offset=5 diff=-29 pad_ptr=0x561a5d2b45ed\n[probe] about to call metal_log for start of test 'alloc' (pad=0x561a5d2b45ed, oob=NO)\n[probe] test finished: name\n</execution_log>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identified a real out\u2011of\u2011bounds risk in the code (pad = dots + strlen(test_case->name) can point past the end of the dots string if the test name is longer than the dots buffer, and later being printed as a %s would cause a read from that out\u2011of\u2011bounds address). However, MISRA C:2023 Rule 21.17 as quoted applies specifically to the standard string.h functions (the rule text and examples explicitly list functions such as memcpy, strcpy, strlen, etc.) and requires that calls to those functions must not cause accesses beyond the bounds of the objects passed to them. In this function the only call to a string.h function is strlen(test_case->name), whose pointer parameter is test_case->name \u2014 that call would only violate 21.17 if strlen itself were to read beyond the bounds of test_case->name (for example if the name were not NUL\u2011terminated). The out\u2011of\u2011bounds access described by the agent occurs when pad (derived from dots) is later supplied to metal_log as a %s argument (printf family), i.e. the read happens via the formatting/IO routine, not via a string.h function parameter. Therefore the code as written does present a possible UB/read\u2011past\u2011end bug, but that bug is not a direct violation of MISRA C 2023 Rule 21.17 as stated. It may violate other MISRA rules about pointer arithmetic or use of I/O, but the specific claim that Rule 21.17 is violated is incorrect."
}