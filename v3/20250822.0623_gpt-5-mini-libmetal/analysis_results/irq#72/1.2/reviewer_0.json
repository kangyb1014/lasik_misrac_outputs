{
  "user_message": "An agent A claimed that the following irq code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of irq.\n```c\nstatic int irq(void)\n{\n\tint rc = 0;\n\tchar *err_msg=\"\";\n\tenum metal_log_level mll= metal_get_log_level();\n\tint i, tst_irq[2];\n\n\t/* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n\tmetal_set_log_level(METAL_LOG_CRITICAL);\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* we only want to test the lib API, so create 'virtual' IRQs */\n\t\ttst_irq[i] = eventfd(0,0);\n\t\tmetal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n\t\t\t  __func__, i, tst_irq[i]);\n\t}\n\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\trc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 1 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\n\tmetal_irq_unregister(tst_irq[0]);\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 after unregistering failed\\n\";\n\t\tgoto out;\n\t}\n\tmetal_irq_unregister(tst_irq[0]);\n\tmetal_irq_unregister(tst_irq[1]);\n\nout:\n\tfor (i = 0; i < 2; i++) {\n\t\tclose(tst_irq[i]);\n\t}\n\tmetal_set_log_level(mll);\n\tif ((err_msg[0] != '\\0') && (!rc))\n\t\trc = -EINVAL;\n\tif (rc) metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n\treturn rc;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_log uses compiler extensions: a GCC statement-expression '({ ... })' and the GNU preprocessor extension '##__VA_ARGS__' to suppress the comma when no variadic arguments are supplied. Both are explicit compiler extensions and thus violate MISRA C 2023 Rule 1.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[probe] entry: rc=0 err_msg='' loop_i=-1 fd0=-1 fd1=-1 mll=7\n[probe] after_eventfd: rc=0 err_msg='' loop_i=0 fd0=6 fd1=32766 mll=7\n[probe] before_metal_log_debug: rc=0 err_msg='format=\"%s: irq %d associated with fd %d\\n\"' loop_i=0 fd0=6 fd1=32766 mll=7\n[probe] after_metal_log_debug: rc=0 err_msg='' loop_i=0 fd0=6 fd1=32766 mll=7\n[probe] after_eventfd: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] before_metal_log_debug: rc=0 err_msg='format=\"%s: irq %d associated with fd %d\\n\"' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] after_metal_log_debug: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] before_register_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_register_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] before_register_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_register_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] before_unregister_and_reregister: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_unregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_reregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_final_unregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_final_unregister_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_close_fd: rc=0 err_msg='' loop_i=0 fd0=6 fd1=7 mll=7\n[probe] after_close_fd: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] after_restore_log_level: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] exit: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] entry: rc=0 err_msg='' loop_i=-1 fd0=-1 fd1=-1 mll=7\n[probe] after_eventfd: rc=0 err_msg='' loop_i=0 fd0=6 fd1=32765 mll=7\n[probe] before_metal_log_debug: rc=0 err_msg='format=\"%s: irq %d associated with fd %d\\n\"' loop_i=0 fd0=6 fd1=32765 mll=7\n[probe] after_metal_log_debug: rc=0 err_msg='' loop_i=0 fd0=6 fd1=32765 mll=7\n[probe] after_eventfd: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] before_metal_log_debug: rc=0 err_msg='format=\"%s: irq %d associated with fd %d\\n\"' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] after_metal_log_debug: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] before_register_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_register_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] before_register_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_register_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] before_unregister_and_reregister: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_unregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_reregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_final_unregister_0: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_final_unregister_1: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] after_close_fd: rc=0 err_msg='' loop_i=0 fd0=6 fd1=7 mll=7\n[probe] after_close_fd: rc=0 err_msg='' loop_i=1 fd0=6 fd1=7 mll=7\n[probe] after_restore_log_level: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n[probe] exit: rc=0 err_msg='' loop_i=-1 fd0=6 fd1=7 mll=7\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function irq:\nenum metal_log_level metal_get_log_level(void)\n{\n\treturn _metal.common.log_level;\n}\n...\nvoid metal_set_log_level(enum metal_log_level level)\n{\n\t_metal.common.log_level = level;\n}\n...\nenum metal_log_level {\n\tMETAL_LOG_EMERGENCY,\t/**< system is unusable.               */\n\tMETAL_LOG_ALERT,\t/**< action must be taken immediately. */\n\tMETAL_LOG_CRITICAL,\t/**< critical conditions.              */\n\tMETAL_LOG_ERROR,\t/**< error conditions.                 */\n\tMETAL_LOG_WARNING,\t/**< warning conditions.               */\n\tMETAL_LOG_NOTICE,\t/**< normal but significant condition. */\n\tMETAL_LOG_INFO,\t\t/**< informational messages.           */\n\tMETAL_LOG_DEBUG,\t/**< debug-level messages.             */\n}\n...\nint metal_irq_register(int irq,\n\t\t       metal_irq_handler irq_handler,\n\t\t       void *arg)\n{\n\tstruct metal_irq_controller *cntr;\n\tstruct metal_irq *irq_data;\n\n\tcntr = metal_irq_get_controller(irq);\n\tif (cntr == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (cntr->irq_register != NULL) {\n\t\treturn cntr->irq_register(cntr, irq, irq_handler, arg);\n\t}\n\tif (cntr->irqs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tirq_data = &cntr->irqs[irq - cntr->irq_base];\n\tirq_data->hd = irq_handler;\n\tirq_data->arg = arg;\n\treturn 0;\n}\n...\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n\tstruct metal_list *node;\n\tstruct metal_irq_controller *cntr;\n\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tint irq_base, irq_end;\n\n\t\tcntr = (struct metal_irq_controller *)\n\t\t       metal_container_of(node, struct metal_irq_controller,\n\t\t\t\t\t  node);\n\t\tirq_base = cntr->irq_base;\n\t\tirq_end = irq_base + cntr->irq_num;\n\t\tif (irq >= irq_base && irq < irq_end) {\n\t\t\treturn cntr;\n\t\t}\n\t}\n\treturn NULL;\n}\n...\nstatic int irq_handler(int irq, void *priv)\n{\n\t(void)irq;\n\t(void)priv;\n\n\treturn 0;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The metal_log macro uses two non\u2011standard GNU extensions: the GCC statement\u2011expression construct ({ ... }) and the GNU preprocessor trick with ##__VA_ARGS__ to suppress the comma when no variadic arguments are supplied. Both constructs are documented compiler extensions (GCC/clang) and are not part of standard C; therefore their presence (and use of metal_log in irq) violates MISRA C 2023 Rule 1.2 unless an approved deviation or a documented, tool\u2011supported extension exception is in place."
}