{
  "user_message": "An agent A claimed that the following irq code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of irq.\n```c\nstatic int irq(void)\n{\n\tint rc = 0;\n\tchar *err_msg=\"\";\n\tenum metal_log_level mll= metal_get_log_level();\n\tint i, tst_irq[2];\n\n\t/* Do not show LOG_ERROR or LOG_DEBUG for expected fail case */\n\tmetal_set_log_level(METAL_LOG_CRITICAL);\n\n\tfor (i = 0; i < 2; i++) {\n\t\t/* we only want to test the lib API, so create 'virtual' IRQs */\n\t\ttst_irq[i] = eventfd(0,0);\n\t\tmetal_log(METAL_LOG_DEBUG, \"%s: irq %d associated with fd %d\\n\",\n\t\t\t  __func__, i, tst_irq[i]);\n\t}\n\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\trc = metal_irq_register(tst_irq[1], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 1 fail drv_id 1\\n\";\n\t\tgoto out;\n\t}\n\n\tmetal_irq_unregister(tst_irq[0]);\n\trc = metal_irq_register(tst_irq[0], irq_handler, (void *)1);\n\tif (rc) {\n\t\terr_msg = \"register irq 0 after unregistering failed\\n\";\n\t\tgoto out;\n\t}\n\tmetal_irq_unregister(tst_irq[0]);\n\tmetal_irq_unregister(tst_irq[1]);\n\nout:\n\tfor (i = 0; i < 2; i++) {\n\t\tclose(tst_irq[i]);\n\t}\n\tmetal_set_log_level(mll);\n\tif ((err_msg[0] != '\\0') && (!rc))\n\t\trc = -EINVAL;\n\tif (rc) metal_log(METAL_LOG_ERROR, \"%s\", err_msg);\n\treturn rc;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call uses a function pointer (cntr->irq_register). If that pointer is set to metal_irq_register itself or to any function that (directly or indirectly) calls metal_irq_register, an indirect recursion occurs: metal_irq_register -> cntr->irq_register -> metal_irq_register -> ... , violating MISRA C 2023 Rule 17.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n2025-08-22 06:36:10 pid=2444057 tid=139873474878656: ENTER irq: saved log level=7, addr(metal_irq_register)=0x7f36d4efba9b, addr(irq_handler)=0x5614e7e45c97\n2025-08-22 06:36:10 pid=2444057 tid=139873474878656: irq: created eventfd index=0 fd=6\n2025-08-22 06:36:10 pid=2444057 tid=139873474878656: irq: created eventfd index=1 fd=7\n2025-08-22 06:36:10 pid=2444057 tid=139873474878656: about to call metal_irq_register(fd=6, handler=0x5614e7e45c97, arg=0x1)\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[0] 0x5614e7e45fd2 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x5fd2) [0x5614e7e45fd2]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[1] 0x5614e7e46334 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x6334) [0x5614e7e46334]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[2] 0x5614e7e46d18 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x6d18) [0x5614e7e46d18]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[3] 0x5614e7e43891 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x3891) [0x5614e7e43891]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[4] 0x7f36d4cded90 /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f36d4cded90]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[5] 0x7f36d4cdee40 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x80) [0x7f36d4cdee40]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[6] 0x5614e7e437a5 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x37a5) [0x5614e7e437a5]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: returned from metal_irq_register(fd=6) => rc=0\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: about to call metal_irq_register(fd=7, handler=0x5614e7e45c97, arg=0x1)\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[0] 0x5614e7e45fd2 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x5fd2) [0x5614e7e45fd2]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[1] 0x5614e7e46406 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x6406) [0x5614e7e46406]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[2] 0x5614e7e46d18 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x6d18) [0x5614e7e46d18]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[3] 0x5614e7e43891 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x3891) [0x5614e7e43891]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[4] 0x7f36d4cded90 /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f36d4cded90]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[5] 0x7f36d4cdee40 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x80) [0x7f36d4cdee40]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[6] 0x5614e7e437a5 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x37a5) [0x5614e7e437a5]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: returned from metal_irq_register(fd=7) => rc=0\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: about to call metal_irq_unregister(fd=6)\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: returned from metal_irq_unregister(fd=6)\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: about to call metal_irq_register(fd=6, handler=0x5614e7e45c97, arg=0x1) after unregister\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[0] 0x5614e7e45fd2 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x5fd2) [0x5614e7e45fd2]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[1] 0x5614e7e4654a /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x654a) [0x5614e7e4654a]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[2] 0x5614e7e46d18 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x6d18) [0x5614e7e46d18]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[3] 0x5614e7e43891 /tmp/tmpnlm5ibtg/build/test/test-metal-shared(+0x3891) [0x5614e7e43891]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[4] 0x7f36d4cded90 /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f36d4cded90]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[5] 0x7f36d4cdee40 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x80) [0x7f36d4cdee40]\n2025-08-22 06:36:11 pid=2444057 tid=139873474878656: bt[6] 0x5614e7e437a5 /tmp/tmpnlm5ibtg/build/test\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function irq:\nenum metal_log_level metal_get_log_level(void)\n{\n\treturn _metal.common.log_level;\n}\n...\nvoid metal_set_log_level(enum metal_log_level level)\n{\n\t_metal.common.log_level = level;\n}\n...\nint metal_irq_register(int irq,\n\t\t       metal_irq_handler irq_handler,\n\t\t       void *arg)\n{\n\tstruct metal_irq_controller *cntr;\n\tstruct metal_irq *irq_data;\n\n\tcntr = metal_irq_get_controller(irq);\n\tif (cntr == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (cntr->irq_register != NULL) {\n\t\treturn cntr->irq_register(cntr, irq, irq_handler, arg);\n\t}\n\tif (cntr->irqs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tirq_data = &cntr->irqs[irq - cntr->irq_base];\n\tirq_data->hd = irq_handler;\n\tirq_data->arg = arg;\n\treturn 0;\n}\n...\nstatic struct metal_irq_controller *metal_irq_get_controller(int irq)\n{\n\tstruct metal_list *node;\n\tstruct metal_irq_controller *cntr;\n\n\tmetal_list_for_each(&irq_cntrs, node) {\n\t\tint irq_base, irq_end;\n\n\t\tcntr = (struct metal_irq_controller *)\n\t\t       metal_container_of(node, struct metal_irq_controller,\n\t\t\t\t\t  node);\n\t\tirq_base = cntr->irq_base;\n\t\tirq_end = irq_base + cntr->irq_num;\n\t\tif (irq >= irq_base && irq < irq_end) {\n\t\t\treturn cntr;\n\t\t}\n\t}\n\treturn NULL;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic int irq_handler(int irq, void *priv)\n{\n\t(void)irq;\n\t(void)priv;\n\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The presented irq() function and the metal_irq_register() implementation do not, by themselves, create direct or indirect recursion: metal_irq_register() looks up a controller and, if present, calls cntr->irq_register(cntr, ...). For an indirect recursion to exist, cntr->irq_register would actually have to call back into metal_irq_register (or be the same function), which is not shown in the codebase you provided and does not happen in the supplied execution log (the calls to metal_irq_register return normally). Furthermore, the controller callback has a different prototype (it receives the controller pointer as first argument) so assigning metal_irq_register to cntr->irq_register would be a mismatched/unusual assignment (and would typically require an explicit cast). If a particular controller implementation were written so that its irq_register called metal_irq_register, that controller implementation would itself introduce indirect recursion (and thus violate Rule 17.2), but that would be a defect in that controller code, not in the irq() or metal_irq_register() code shown. Therefore agent A\u2019s blanket claim that the irq code violates MISRA C 2023 Rule 17.2 is not supported by the provided code or trace."
}