{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strncpy(_metal.page_sizes[index].path, path, PATH_MAX) can write exactly PATH_MAX bytes into the destination. If _metal.page_sizes[index].path is not an array of size PATH_MAX (or larger), this will write beyond the bounds of the destination object and thus violate MISRA C 2023 Rule 21.17. (Also note that if the source length >= PATH_MAX the result will not be NUL-terminated, which is a separate safety/semantic issue.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified metal_add_page_size code that contains useful probe functions that print useful logs to a file \"/tmp/logs/449.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of metal_add_page_size as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of metal_add_page_size:\n```c\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n```\n</target_code>\nPlease provide the modified metal_add_page_size code.\n",
  "test_code": "static int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n    int index = _metal.num_page_sizes;\n    unsigned long size = 1UL << shift;\n\n    /* Probe/logging variables */\n    FILE *logf = NULL;\n    size_t dest_buf_size = 0u;\n    size_t src_len = 0u;\n    size_t bytes_to_copy = (size_t)PATH_MAX;\n\n    /* Open probe log (append) early to capture entry state */\n    logf = fopen(\"/tmp/logs/449.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"ENTER metal_add_page_size: path=%p, shift=%d, mmap_flags=%d, index=%d, num_page_sizes=%d, MAX_PAGE_SIZES=%d, computed_size=%lu, PATH_MAX=%zu\\n\",\n                (const void *)path, shift, mmap_flags, index, _metal.num_page_sizes, MAX_PAGE_SIZES, size, bytes_to_copy);\n        fflush(logf);\n    }\n\n    if (index >= MAX_PAGE_SIZES) {\n        if (logf) {\n            fprintf(logf, \"SKIP: index >= MAX_PAGE_SIZES (%d >= %d)\\n\", index, MAX_PAGE_SIZES);\n            fflush(logf);\n            fclose(logf);\n        }\n\n        metal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n                  size);\n        return -EOVERFLOW;\n    }\n\n    if (!path || shift <= 0) {\n        if (logf) {\n            fprintf(logf, \"SKIP: invalid args: path=%p, shift=%d\\n\", (const void *)path, shift);\n            fflush(logf);\n            fclose(logf);\n        }\n\n        metal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n                  size);\n        return -EINVAL;\n    }\n\n    /* Compute and log destination buffer size (compile-time sizeof if array, pointer size if pointer) */\n    dest_buf_size = sizeof(_metal.page_sizes[index].path);\n\n    /* Safely compute source length (path is non-NULL here) */\n    src_len = strlen(path);\n\n    if (logf) {\n        fprintf(logf, \"BEFORE strncpy: dest_addr=%p, dest_buf_size=%zu, src_len=%zu, bytes_to_copy=%zu\\n\",\n                (void *)_metal.page_sizes[index].path, dest_buf_size, src_len, bytes_to_copy);\n        /* Note: if dest_buf_size < bytes_to_copy and dest_buf_size does not reflect actual buffer capacity,\n           this will be evidence for a potential out-of-bounds write when strncpy is called below. */\n        fflush(logf);\n    }\n\n    _metal.page_sizes[index].page_shift = shift;\n    _metal.page_sizes[index].page_size = size;\n    _metal.page_sizes[index].mmap_flags = mmap_flags;\n    strncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\n    if (logf) {\n        /* After copy, log whether source was truncated by strncpy semantics */\n        int src_truncated = (src_len >= bytes_to_copy) ? 1 : 0;\n        fprintf(logf, \"AFTER strncpy: src_len=%zu, bytes_to_copy=%zu, src_truncated=%d, num_page_sizes_before_inc=%d\\n\",\n                src_len, bytes_to_copy, src_truncated, _metal.num_page_sizes);\n        fflush(logf);\n    }\n\n    _metal.num_page_sizes++;\n\n    metal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n    if (logf) {\n        fprintf(logf, \"EXIT metal_add_page_size: added index=%d, new_num_page_sizes=%d\\n\",\n                index, _metal.num_page_sizes);\n        fflush(logf);\n        fclose(logf);\n    }\n\n    return 0;\n}\n"
}