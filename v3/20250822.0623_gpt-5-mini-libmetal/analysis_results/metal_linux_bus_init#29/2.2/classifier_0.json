{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_linux_bus_init:\n```c\nint metal_linux_bus_init(void)\n{\n\tstruct linux_bus *lbus;\n\tint valid = 0;\n\n\tfor_each_linux_bus(lbus)\n\t\tvalid += metal_linux_probe_bus(lbus) ? 0 : 1;\n\n\treturn valid ? 0 : -ENODEV;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_bus_init:\n#define for_each_linux_bus(lbus) for((lbus)=linux_bus;(lbus)->bus_name;(lbus)++)\n...\nstatic int metal_linux_probe_bus(struct linux_bus *lbus)\n{\n\tstruct linux_driver *ldrv;\n\tint ret, error = -ENODEV;\n\n\tlbus->sbus = sysfs_open_bus(lbus->bus_name);\n\tif (!lbus->sbus)\n\t\treturn -ENODEV;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tret = metal_linux_probe_driver(lbus, ldrv);\n\t\t/* Clear the error if any driver is available */\n\t\tif (!ret)\n\t\t\terror = ret;\n\t}\n\n\tif (error) {\n\t\tmetal_linux_bus_close(&lbus->bus);\n\t\treturn error;\n\t}\n\n\terror = metal_linux_register_bus(lbus);\n\tif (error)\n\t\tmetal_linux_bus_close(&lbus->bus);\n\n\treturn error;\n}\n...\nstatic int metal_linux_probe_driver(struct linux_bus *lbus,\n\t\t\t\t    struct linux_driver *ldrv)\n{\n\tchar command[256];\n\tint ret;\n\n\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\n\t/* Try probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* Try sudo probing the module and then open the driver. */\n\tif (!ldrv->sdrv) {\n\t\tret = snprintf(command, sizeof(command),\n\t\t\t       \"sudo modprobe %s > /dev/null 2>&1\", ldrv->mod_name);\n\t\tif (ret >= (int)sizeof(command))\n\t\t\treturn -EOVERFLOW;\n\t\tret = system(command);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t\t  \"%s: executing system command '%s' failed.\\n\",\n\t\t\t\t  __func__, command);\n\t\t}\n\t\tldrv->sdrv = sysfs_open_driver(lbus->bus_name, ldrv->drv_name);\n\t}\n\n\t/* If all else fails... */\n\treturn ldrv->sdrv ? 0 : -ENODEV;\n}\n...\nstatic void metal_linux_bus_close(struct metal_bus *bus)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_driver *ldrv;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\t\tif (ldrv->sdrv)\n\t\t\tsysfs_close_driver(ldrv->sdrv);\n\t\tldrv->sdrv = NULL;\n\t}\n\n\tsysfs_close_bus(lbus->sbus);\n\tlbus->sbus = NULL;\n}\n...\nstatic int metal_linux_register_bus(struct linux_bus *lbus)\n{\n\tlbus->bus.name = lbus->bus_name;\n\tlbus->bus.ops  = metal_linux_bus_ops;\n\treturn metal_bus_register(&lbus->bus);\n}\n...\nint metal_sys_init(const struct metal_init_params *params)\n{\n\tconst char *tmp_path;\n\tunsigned int seed;\n\tFILE *urandom;\n\tint result;\n\n\t/* Find the temporary directory location. */\n\ttmp_path = getenv(\"TMPDIR\");\n\tif (!tmp_path)\n\t\ttmp_path = \"/tmp\";\n\t_metal.tmp_path = tmp_path;\n\n\t/* Initialize the pseudo-random number generator. */\n\turandom = fopen(\"/dev/urandom\", \"r\");\n\tif (!urandom) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to open /dev/urandom (%s)\\n\",\n\t\t\t  strerror(errno));\n\t\treturn -errno;\n\t}\n\tif (fread(&seed, 1, sizeof(seed), urandom) <= 0) {\n\t\tmetal_log(METAL_LOG_DEBUG, \"Failed fread /dev/urandom\\n\");\n\t}\n\tfclose(urandom);\n\tsrand(seed);\n\n\tresult = metal_init_page_sizes();\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = metal_linux_bus_init();\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = open(\"/proc/self/pagemap\", O_RDONLY | O_CLOEXEC);\n\tif (result < 0) {\n\t\tmetal_log(METAL_LOG_DEBUG, \"Failed pagemap open - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\t_metal.pagemap_fd = result;\n\n\tmetal_unused(params);\n\n\t/* Initialize IRQ handling */\n\tmetal_linux_irq_init();\n\treturn 0;\n}\n...\nint metal_init(const struct metal_init_params *params)\n{\n\tint error = 0;\n\n\tif (_metal.common.ref_count++ != 0)\n\t\treturn 0;\n\n\tmemset(&_metal, 0, sizeof(_metal));\n\n\t_metal.common.log_handler   = params->log_handler;\n\t_metal.common.log_level     = params->log_level;\n\n\tmetal_list_init(&_metal.common.bus_list);\n\tmetal_list_init(&_metal.common.generic_shmem_list);\n\tmetal_list_init(&_metal.common.generic_device_list);\n\n\terror = metal_sys_init(params);\n\tif (error)\n\t\treturn error;\n\n\t++_metal.common.ref_count;\n\treturn error;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (_metal.common.ref_count++ != 0)\n\t\treturn 0;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "When _metal.common.ref_count == 0 the expression (_metal.common.ref_count++ != 0) executes the post-increment side\u2011effect (ref_count becomes 1) but the very next statement is memset(&_metal, 0, sizeof(_metal)), which clears ref_count back to 0. The increment is therefore executed yet has no observable effect \u2014 removing that increment would not change program behaviour in this path. This constitutes dead code, so Rule 2.2 is violated."
}