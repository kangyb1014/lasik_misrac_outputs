{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_linux_dev_open:\n```c\nstatic int metal_linux_dev_open(struct metal_bus *bus,\n\t\t\t\tconst char *dev_name,\n\t\t\t\tstruct metal_device **device)\n{\n\tstruct linux_bus *lbus = to_linux_bus(bus);\n\tstruct linux_device *ldev = NULL;\n\tstruct linux_driver *ldrv;\n\tint error;\n\n\tldev = malloc(sizeof(*ldev));\n\tif (!ldev)\n\t\treturn -ENOMEM;\n\n\tfor_each_linux_driver(lbus, ldrv) {\n\n\t\t/* Check if we have a viable driver. */\n\t\tif (!ldrv->sdrv || !ldrv->dev_open)\n\t\t\tcontinue;\n\n\t\t/* Allocate a linux device if we haven't already. */\n\t\tif (!ldev)\n\t\t\tldev = malloc(sizeof(*ldev));\n\t\tif (!ldev)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Reset device data. */\n\t\tmemset(ldev, 0, sizeof(*ldev));\n\t\tstrncpy(ldev->dev_name, dev_name, sizeof(ldev->dev_name) - 1);\n\t\tldev->fd = -1;\n\t\tldev->ldrv = ldrv;\n\t\tldev->device.bus = bus;\n\n\t\t/* Try and open the device. */\n\t\terror = ldrv->dev_open(lbus, ldev);\n\t\tif (error) {\n\t\t\tldrv->dev_close(lbus, ldev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*device = &ldev->device;\n\t\t(*device)->name = ldev->dev_name;\n\n\t\tmetal_list_add_tail(&bus->devices, &(*device)->node);\n\t\treturn 0;\n\t}\n\n\tif (ldev)\n\t\tfree(ldev);\n\n\treturn -ENODEV;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_dev_open:\nstatic struct linux_bus *to_linux_bus(struct metal_bus *bus)\n{\n\treturn metal_container_of(bus, struct linux_bus, bus);\n}\n...\n#define for_each_linux_driver(lbus, ldrv) for((ldrv)=lbus->drivers;(ldrv)->drv_name;(ldrv)++)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nldrv->dev_close(lbus, ldev);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown fragment: ldrv->dev_close(lbus, ldev) calls a driver-provided close callback (different symbol/signature than metal_linux_dev_open) and so is not a call to itself. A Rule 17.2 violation would only occur if the driver\u2019s dev_close implementation (directly or indirectly) called metal_linux_dev_open, creating a call cycle; there is no evidence of that here."
}