{
  "user_message": "Target function code is:\n```c\nstatic void *metal_linux_irq_handling(void *args)\n{\n\tstruct sched_param param;\n\tuint64_t val;\n\tint ret;\n\tint i, j, pfds_total;\n\tstruct pollfd *pfds;\n\n\t(void)args;\n\n\tpfds = (struct pollfd *)malloc(FD_SETSIZE * sizeof(struct pollfd));\n\tif (!pfds) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to allocate irq fds mem.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tparam.sched_priority = sched_get_priority_max(SCHED_FIFO);\n\t/* Ignore the set scheduler error */\n\tret = sched_setscheduler(0, SCHED_FIFO, &param);\n\tif (ret) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s: Failed to set scheduler: %s.\\n\", __func__,\n\t\t\t  strerror(ret));\n\t}\n\n\twhile (1) {\n\t\tmetal_mutex_acquire(&irq_lock);\n\t\tif (irq_handling_stop) {\n\t\t\t/* Killing this IRQ handling thread */\n\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get the fdset */\n\t\tmemset(pfds, 0, MAX_IRQS * sizeof(struct pollfd));\n\t\tpfds[0].fd = irq_notify_fd;\n\t\tpfds[0].events = POLLIN;\n\t\tj = 1;\n\t\tmetal_bitmap_for_each_set_bit(irqs_enabled, i,\n\t\t\t\t\t      linux_irq_cntr.irq_num) {\n\t\t\tpfds[j].fd = i;\n\t\t\tpfds[j].events = POLLIN;\n\t\t\tj++;\n\t\t}\n\t\tmetal_mutex_release(&irq_lock);\n\t\t/* Wait for interrupt */\n\t\tret = poll(pfds, j, -1);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"%s: poll() failed: %s.\\n\",\n\t\t\t\t  __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\t/* Waken up from interrupt */\n\t\tpfds_total = j;\n\t\tfor (i = 0; i < pfds_total; i++) {\n\t\t\tif ((pfds[i].fd == irq_notify_fd) &&\n\t\t\t    (pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\t/* IRQ registration change notification */\n\t\t\t\tif (read(pfds[i].fd,\n\t\t\t\t\t (void *)&val, sizeof(uint64_t)) < 0)\n\t\t\t\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t\t\t\t  \"%s, read irq fd %d failed\\n\",\n\t\t\t\t\t\t  __func__, pfds[i].fd);\n\t\t\t} else if ((pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\tstruct metal_device *dev = NULL;\n\t\t\t\tint irq_handled = 0;\n\t\t\t\tint fd;\n\n\t\t\t\tfd = pfds[i].fd;\n\t\t\t\tdev = irqs_devs[fd];\n\t\t\t\tmetal_mutex_acquire(&irq_lock);\n\t\t\t\tif (metal_irq_handle(&irqs[fd], fd)\n\t\t\t\t    == METAL_IRQ_HANDLED)\n\t\t\t\t\tirq_handled = 1;\n\t\t\t\tif (irq_handled) {\n\t\t\t\t\tif (dev && dev->bus->ops.dev_irq_ack)\n\t\t\t\t\t\tdev->bus->ops.dev_irq_ack(\n\t\t\t\t\t\t\tdev->bus, dev, fd);\n\t\t\t\t}\n\t\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\t} else if (pfds[i].revents) {\n\t\t\t\tmetal_log(METAL_LOG_DEBUG,\n\t\t\t\t\t  \"%s: poll unexpected. fd %d: %d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  pfds[i].fd, pfds[i].revents);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfds);\n\treturn NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'metal_linux_irq_handling': {'callees': ['metal_mutex_acquire', 'metal_mutex_release', 'metal_bitmap_next_set_bit', 'metal_irq_handle'], 'callers': []}, 'metal_mutex_acquire': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_save_disable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_mutex_release': {'callees': [], 'callers': ['metal_condition_wait', 'metal_irq_restore_enable', 'metal_linux_irq_set_enable', 'metal_linux_irq_handling', 'mutex_thread', 'consumer_thread', 'producer_thread']}, 'metal_bitmap_next_set_bit': {'callees': [], 'callers': ['metal_linux_irq_handling']}, 'metal_irq_handle': {'callees': [], 'callers': ['metal_softirq_dispatch', 'metal_linux_irq_handling']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "metal_bitmap_for_each_set_bit",
    "metal_bitmap_next_set_bit",
    "irqs_enabled",
    "metal_bitmap (type)",
    "metal_log",
    "metal_mutex_acquire",
    "metal_mutex_release",
    "metal_irq_handle",
    "irqs_devs",
    "irqs",
    "irq_notify_fd",
    "irq_lock",
    "irq_handling_stop",
    "linux_irq_cntr",
    "dev_irq_ack (bus ops member)",
    "MAX_IRQS",
    "FD_SETSIZE"
  ],
  "explanation": "For checking whether the target function (metal_linux_irq_handling) uses compiler language extensions, the next analyzer must be able to inspect the definitions/implementations of the macros, globals, and functions the routine relies on. The following explains why each listed symbol is required:\n\n- metal_bitmap_for_each_set_bit: This is a macro-style iterator visible in the source. Such iteration macros commonly use GCC/clang extensions (e.g. statement-expressions ({ ... }), typeof, nested declarations, or unusual scoping). The macro definition must be inspected to detect any compiler-specific extensions.\n\n- metal_bitmap_next_set_bit: Often used by the iterator macro; its implementation might itself use inline functions, GNU attributes, or other extensions. Check it for language-extension constructs.\n\n- irqs_enabled: The bitmap/variable passed to the iterator. Its type and declaration are needed to understand how the iterator macro operates and whether any non-standard type features are used.\n\n- metal_bitmap (type): The bitmap type used by irqs_enabled. The type definition may use typedefs, flexible-array members, bit-field tricks, or compiler-specific attributes \u2014 all relevant to detect language extensions.\n\n- metal_log: Logging is typically implemented as a macro or variadic macro/function. Variadic macros are standard in C99, but the macro could use GNU extensions (formatting via statement expressions, __attribute__ ((format)), or other compiler-specific constructs). The macro/function definition must be reviewed.\n\n- metal_mutex_acquire and metal_mutex_release: Provided in the static call graph and called from this function while holding/releasing locks; their implementations should be inspected for inline asm, GCC attributes, or other non-standard constructs (e.g. nested functions, nonstandard inline semantics).\n\n- metal_irq_handle: Called within the critical section; its implementation might use compiler extensions (attributes, inline assembly, statement-expressions) that affect correctness or violate the MISRA rule.\n\n- irqs_devs: Global array of device pointers indexed by fd. The declaration may use nonstandard pointer/array constructs, container_of macros, or attributes; also needed to inspect any macros around device access.\n\n- irqs: The irqs array/structure passed to metal_irq_handle. Its type and declaration may hide extensions (bit-fields, packed attributes, etc.).\n\n- irq_notify_fd: Global fd checked in the poll loop. Its declaration itself is unlikely an extension, but it helps locate related macros or code that may use extensions in notification handling.\n\n- irq_lock: The mutex/lock object used with metal_mutex_acquire/release. The lock type or related macros might employ compiler extensions (e.g. transparent unions, attributes), so its definition should be checked.\n\n- irq_handling_stop: Global flag tested under the lock. Its declaration (volatile, atomic, use of C11 atomics, or compiler-specific atomic builtins) could employ language extensions \u2014 must inspect.\n\n- linux_irq_cntr: The structure with irq_num used as the upper limit in the iterator. Its definition may use nonstandard features (e.g. bitfields, attributes) that are relevant for MISRA extension checks.\n\n- dev_irq_ack (bus ops member): The member function pointer called on dev->bus->ops.dev_irq_ack could have been declared with compiler-specific function attributes, calling conventions, or prototypes using extensions. Inspect the ops structure and member declarations.\n\n- MAX_IRQS and FD_SETSIZE: These macros control memory sizing and the memset call. Their definitions should be checked for non-standard macro tricks (complex macro expressions using statement-expressions, token-pasting hacks, or use of compiler-specific constants).\n\nRationale: The MISRA rule in question only flags explicit compiler language extensions. Most suspicious uses in this function are hidden behind macros, typedefs, and external function implementations. To decide if an extension is used, the analyzer must examine those macro/function/type definitions listed above (they are the likely places where statement-expressions, typeof, nested functions, inline asm, GCC/Clang attributes, or other documented compiler extensions would appear)."
}