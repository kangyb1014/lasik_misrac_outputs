{
  "user_message": "An agent A claimed that the following metal_linux_irq_handling code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_linux_irq_handling.\n```c\nstatic void *metal_linux_irq_handling(void *args)\n{\n\tstruct sched_param param;\n\tuint64_t val;\n\tint ret;\n\tint i, j, pfds_total;\n\tstruct pollfd *pfds;\n\n\t(void)args;\n\n\tpfds = (struct pollfd *)malloc(FD_SETSIZE * sizeof(struct pollfd));\n\tif (!pfds) {\n\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t  \"%s: failed to allocate irq fds mem.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tparam.sched_priority = sched_get_priority_max(SCHED_FIFO);\n\t/* Ignore the set scheduler error */\n\tret = sched_setscheduler(0, SCHED_FIFO, &param);\n\tif (ret) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"%s: Failed to set scheduler: %s.\\n\", __func__,\n\t\t\t  strerror(ret));\n\t}\n\n\twhile (1) {\n\t\tmetal_mutex_acquire(&irq_lock);\n\t\tif (irq_handling_stop) {\n\t\t\t/* Killing this IRQ handling thread */\n\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Get the fdset */\n\t\tmemset(pfds, 0, MAX_IRQS * sizeof(struct pollfd));\n\t\tpfds[0].fd = irq_notify_fd;\n\t\tpfds[0].events = POLLIN;\n\t\tj = 1;\n\t\tmetal_bitmap_for_each_set_bit(irqs_enabled, i,\n\t\t\t\t\t      linux_irq_cntr.irq_num) {\n\t\t\tpfds[j].fd = i;\n\t\t\tpfds[j].events = POLLIN;\n\t\t\tj++;\n\t\t}\n\t\tmetal_mutex_release(&irq_lock);\n\t\t/* Wait for interrupt */\n\t\tret = poll(pfds, j, -1);\n\t\tif (ret < 0) {\n\t\t\tmetal_log(METAL_LOG_ERROR, \"%s: poll() failed: %s.\\n\",\n\t\t\t\t  __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\t/* Waken up from interrupt */\n\t\tpfds_total = j;\n\t\tfor (i = 0; i < pfds_total; i++) {\n\t\t\tif ((pfds[i].fd == irq_notify_fd) &&\n\t\t\t    (pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\t/* IRQ registration change notification */\n\t\t\t\tif (read(pfds[i].fd,\n\t\t\t\t\t (void *)&val, sizeof(uint64_t)) < 0)\n\t\t\t\t\tmetal_log(METAL_LOG_ERROR,\n\t\t\t\t\t\t  \"%s, read irq fd %d failed\\n\",\n\t\t\t\t\t\t  __func__, pfds[i].fd);\n\t\t\t} else if ((pfds[i].revents & (POLLIN | POLLRDNORM))) {\n\t\t\t\tstruct metal_device *dev = NULL;\n\t\t\t\tint irq_handled = 0;\n\t\t\t\tint fd;\n\n\t\t\t\tfd = pfds[i].fd;\n\t\t\t\tdev = irqs_devs[fd];\n\t\t\t\tmetal_mutex_acquire(&irq_lock);\n\t\t\t\tif (metal_irq_handle(&irqs[fd], fd)\n\t\t\t\t    == METAL_IRQ_HANDLED)\n\t\t\t\t\tirq_handled = 1;\n\t\t\t\tif (irq_handled) {\n\t\t\t\t\tif (dev && dev->bus->ops.dev_irq_ack)\n\t\t\t\t\t\tdev->bus->ops.dev_irq_ack(\n\t\t\t\t\t\t\tdev->bus, dev, fd);\n\t\t\t\t}\n\t\t\t\tmetal_mutex_release(&irq_lock);\n\t\t\t} else if (pfds[i].revents) {\n\t\t\t\tmetal_log(METAL_LOG_DEBUG,\n\t\t\t\t\t  \"%s: poll unexpected. fd %d: %d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  pfds[i].fd, pfds[i].revents);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfds);\n\treturn NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses GCC/Clang language extensions: the statement-expression construct '({ ... })' and the GNU variadic comma-swallowing idiom '##__VA_ARGS__'. Both are documented compiler extensions, so Rule 1.2 is violated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nmetal_linux_irq_handling: allocated pfds=0x7f2468000b70 (FD_SETSIZE=1024)\nmetal_linux_irq_handling: sched_setscheduler returned -1, sched_priority=99\nmetal_linux_irq_handling: acquired irq_lock\nmetal_linux_irq_handling: added notify fd index=0 fd=5 events=POLLIN\nmetal_linux_irq_handling: released irq_lock, built pfds count j=1\nmetal_linux_irq_handling: calling poll(pfds, 1, -1)\nmetal_linux_irq_handling: poll returned ret=1\nmetal_linux_irq_handling: inspecting pfds[0] fd=5 revents=0x1\nmetal_linux_irq_handling: read notify fd 5 success val=1\nmetal_linux_irq_handling: acquired irq_lock\nmetal_linux_irq_handling: irq_handling_stop is set (value=1), exiting loop\nmetal_linux_irq_handling: released irq_lock before break\nmetal_linux_irq_handling: allocated pfds=0x7f2508000b70 (FD_SETSIZE=1024)\nmetal_linux_irq_handling: sched_setscheduler returned -1, sched_priority=99\nmetal_linux_irq_handling: acquired irq_lock\nmetal_linux_irq_handling: added notify fd index=0 fd=5 events=POLLIN\nmetal_linux_irq_handling: released irq_lock, built pfds count j=1\nmetal_linux_irq_handling: calling poll(pfds, 1, -1)\nmetal_linux_irq_handling: poll returned ret=1\nmetal_linux_irq_handling: inspecting pfds[0] fd=5 revents=0x1\nmetal_linux_irq_handling: read notify fd 5 success val=1\nmetal_linux_irq_handling: acquired irq_lock\nmetal_linux_irq_handling: irq_handling_stop is set (value=1), exiting loop\nmetal_linux_irq_handling: released irq_lock before break\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_linux_irq_handling:\n#define metal_bitmap_for_each_set_bit(bitmap, bit, max) for((bit)=metal_bitmap_next_set_bit((bitmap),0,(max));(bit)<(max);(bit)=metal_bitmap_next_set_bit((bitmap),(bit+1),(max)))\n...\nstatic unsigned long\nirqs_enabled[metal_div_round_up(MAX_IRQS, METAL_BITS_PER_ULONG)]\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic struct metal_device *irqs_devs[MAX_IRQS]\n...\nstatic struct metal_irq irqs[MAX_IRQS]\n...\nstatic int irq_notify_fd\n...\nstatic metal_mutex_t irq_lock\n...\nstatic bool irq_handling_stop\n...\nstatic METAL_IRQ_CONTROLLER_DECLARE(linux_irq_cntr,\n\t\t\t\t    0, MAX_IRQS,\n\t\t\t\t    NULL,\n\t\t\t\t    metal_linux_irq_set_enable, NULL,\n\t\t\t\t    irqs)\n...\n#define MAX_IRQS (FD_SETSIZE-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code uses GCC/Clang language extensions in the metal_log macro: the statement-expression construct ({ ... }) and the GNU comma\u2011swallowing idiom (##__VA_ARGS__). Both are documented compiler extensions (GCC/Clang) and therefore violate MISRA C 2023 Rule 1.2 which forbids use of language extensions. The problematic macro is: #define metal_log(level, fmt, __VA_ARGS__) ({ if(_metal.common.log_handler && level <= _metal.common.log_level) _metal.common.log_handler(level, metal_fmt(fmt), ##__VA_ARGS__); }) \u2014 this clearly uses the two extensions cited by Agent A."
}