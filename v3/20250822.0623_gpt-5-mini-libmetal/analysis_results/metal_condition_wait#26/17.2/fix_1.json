{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_append_str(char *buf, int *pos, const char *s)\n{\n    while (*s) buf[(*pos)++] = *s++;\n}\nstatic void probe_append_uint(char *buf, int *pos, unsigned long x)\n{\n    char tmp[32];\n    int t = 0;\n    if (x == 0) {\n        tmp[t++] = '0';\n    } else {\n        while (x) {\n            tmp[t++] = (char)('0' + (x % 10));\n            x /= 10;\n        }\n    }\n    for (int i = t - 1; i >= 0; --i) buf[(*pos)++] = tmp[i];\n}\nstatic void probe_append_hex(char *buf, int *pos, unsigned long x)\n{\n    const char *hex = \"0123456789abcdef\";\n    char tmp[32];\n    int t = 0;\n    if (x == 0) {\n        tmp[t++] = '0';\n    } else {\n        while (x) {\n            tmp[t++] = hex[x & 0xF];\n            x >>= 4;\n        }\n    }\n    buf[(*pos)++] = '0';\n    buf[(*pos)++] = 'x';\n    for (int i = t - 1; i >= 0; --i) buf[(*pos)++] = tmp[i];\n}\nstatic void probe_write(const char *msg, size_t len)\n{\n    /* Open, write, close to append message to the log file. Use syscalls to\n     * avoid stdio locking which could interfere with mutex-related investigations.\n     */\n#ifdef SYS_openat\n    long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n#else\n    long fd = syscall(SYS_open, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n#endif\n    if (fd >= 0) {\n        syscall(SYS_write, fd, msg, len);\n        syscall(SYS_close, fd);\n    }\n}\nstatic void probe_log_state(const char *stage,\n                            struct metal_condition *cv,\n                            metal_mutex_t *m,\n                            uintptr_t tmpmptr,\n                            uintptr_t mptr,\n                            int v,\n                            long futex_ret)\n{\n    char buf[512];\n    int pos = 0;\n    probe_append_str(buf, &pos, \"[metal_condition_wait] \");\n    probe_append_str(buf, &pos, stage);\n    probe_append_str(buf, &pos, \": cv=\");\n    probe_append_hex(buf, &pos, (unsigned long)cv);\n    probe_append_str(buf, &pos, \" m=\");\n    probe_append_hex(buf, &pos, (unsigned long)m);\n    probe_append_str(buf, &pos, \" mptr=\");\n    probe_append_uint(buf, &pos, (unsigned long)mptr);\n    probe_append_str(buf, &pos, \" tmpmptr=\");\n    probe_append_uint(buf, &pos, (unsigned long)tmpmptr);\n    probe_append_str(buf, &pos, \" wakeups=\");\n    probe_append_uint(buf, &pos, (unsigned long)v);\n    if (futex_ret != 0) {\n        probe_append_str(buf, &pos, \" futex_ret=\");\n        /* futex_ret can be negative, print sign then magnitude */\n        if (futex_ret < 0) {\n            buf[pos++] = '-';\n            probe_append_uint(buf, &pos, (unsigned long)(-futex_ret));\n        } else {\n            probe_append_uint(buf, &pos, (unsigned long)futex_ret);\n        }\n    }\n    buf[pos++] = '\\n';\n    probe_write(buf, (size_t)pos);\n}\n\nint metal_condition_wait(struct metal_condition *cv,\n                       metal_mutex_t *m)\n{\n    uintptr_t tmpmptr = 0, mptr = (uintptr_t)m;\n    int v = 0;\n\n    /* Log entry */\n    probe_log_state(\"ENTER\", cv, m, tmpmptr, mptr, -1, 0);\n\n    /* Check if the mutex has been acquired */\n    if (!cv || !m || !metal_mutex_is_acquired(m)) {\n        probe_log_state(\"EARLY_RETURN_INVALID_ARGS_OR_NOT_ACQUIRED\", cv, m, tmpmptr, mptr, -1, 0);\n        return -EINVAL;\n    }\n\n    if (!atomic_compare_exchange_strong(&cv->mptr, &tmpmptr, mptr)) {\n        /* Log state after failed compare-exchange (tmpmptr has been updated) */\n        probe_log_state(\"CMPXCHG_FAILED\", cv, m, tmpmptr, mptr, -1, 0);\n        if (tmpmptr != mptr) {\n            probe_log_state(\"EARLY_RETURN_MPTR_MISMATCH\", cv, m, tmpmptr, mptr, -1, 0);\n            return -EINVAL;\n        }\n    }\n\n    v = atomic_load(&cv->wakeups);\n    probe_log_state(\"BEFORE_INCREMENT_WAITERS\", cv, m, tmpmptr, mptr, v, 0);\n    atomic_fetch_add(&cv->waiters, 1);\n\n    /* Release the mutex before sleeping. */\n    probe_log_state(\"BEFORE_MUTEX_RELEASE\", cv, m, tmpmptr, mptr, v, 0);\n    metal_mutex_release(m);\n\n    /* Sleep on the futex. Capture return value for logging. */\n    long futex_ret = syscall(SYS_futex, &cv->wakeups, FUTEX_WAIT, v, NULL, NULL, 0);\n    probe_log_state(\"AFTER_FUTEX_WAIT\", cv, m, tmpmptr, mptr, v, futex_ret);\n\n    atomic_fetch_sub(&cv->waiters, 1);\n    /* Acquire the mutex after it's waken up. */\n    probe_log_state(\"BEFORE_MUTEX_ACQUIRE\", cv, m, tmpmptr, mptr, v, futex_ret);\n    metal_mutex_acquire(m);\n    probe_log_state(\"AFTER_MUTEX_ACQUIRE\", cv, m, tmpmptr, mptr, v, futex_ret);\n\n    probe_log_state(\"RETURN_OK\", cv, m, tmpmptr, mptr, v, futex_ret);\n    return 0;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n-- Build type:  \n-- Host:    Linux/x86_64\n-- Target:  Linux/x86_64\n-- Machine: Generic\n-- Vendor: none\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c: In function 'probe_write':\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c:66:35: error: 'AT_FDCWD' undeclared (first use in this function)\n   66 |     long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                   ^~~~~~~~\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c:66:35: note: each undeclared identifier is reported only once for each function it appears in\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c:66:66: error: 'O_WRONLY' undeclared (first use in this function)\n   66 |     long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                                                  ^~~~~~~~\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c:66:77: error: 'O_CREAT' undeclared (first use in this function)\n   66 |     long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                                                             ^~~~~~~\n/tmp/tmp6vtq13ak/src/lib/system/linux/condition.c:66:87: error: 'O_APPEND' undeclared (first use in this function)\n   66 |     long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n      |                                                                                       ^~~~~~~~\ngmake[2]: *** [lib/CMakeFiles/metal-shared.dir/build.make:202: lib/CMakeFiles/metal-shared.dir/system/linux/condition.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:291: lib/CMakeFiles/metal-shared.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of metal_condition_wait as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stddef.h>\n#include <stdint.h>\n#include <stdatomic.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <linux/futex.h>\n\n/* Minimal in-file definitions so this translation unit compiles. The real\n * project provides full definitions elsewhere; we keep signatures so that the\n * original logic of metal_condition_wait is preserved. */\ntypedef struct metal_mutex metal_mutex_t;\nstruct metal_mutex { int _dummy; };\n\nstruct metal_condition {\n    _Atomic(uintptr_t) mptr;\n    _Atomic(int) wakeups;\n    _Atomic(int) waiters;\n};\n\n/* The real implementations live elsewhere in the project. Only declare them\n * so this file compiles. */\nint metal_mutex_is_acquired(metal_mutex_t *m);\nvoid metal_mutex_release(metal_mutex_t *m);\nvoid metal_mutex_acquire(metal_mutex_t *m);\n\nstatic void probe_append_str(char *buf, int *pos, const char *s)\n{\n    while (*s) buf[(*pos)++] = *s++;\n}\nstatic void probe_append_uint(char *buf, int *pos, unsigned long x)\n{\n    char tmp[32];\n    int t = 0;\n    if (x == 0) {\n        tmp[t++] = '0';\n    } else {\n        while (x) {\n            tmp[t++] = (char)('0' + (x % 10));\n            x /= 10;\n        }\n    }\n    for (int i = t - 1; i >= 0; --i) buf[(*pos)++] = tmp[i];\n}\nstatic void probe_append_hex(char *buf, int *pos, unsigned long x)\n{\n    const char *hex = \"0123456789abcdef\";\n    char tmp[32];\n    int t = 0;\n    if (x == 0) {\n        tmp[t++] = '0';\n    } else {\n        while (x) {\n            tmp[t++] = hex[x & 0xF];\n            x >>= 4;\n        }\n    }\n    buf[(*pos)++] = '0';\n    buf[(*pos)++] = 'x';\n    for (int i = t - 1; i >= 0; --i) buf[(*pos)++] = tmp[i];\n}\nstatic void probe_write(const char *msg, size_t len)\n{\n    /* Open, write, close to append message to the log file. Use syscalls to\n     * avoid stdio locking which could interfere with mutex-related investigations.\n     */\n#ifdef SYS_openat\n    long fd = syscall(SYS_openat, AT_FDCWD, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n#else\n    long fd = syscall(SYS_open, \"/tmp/logs/266.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n#endif\n    if (fd >= 0) {\n        syscall(SYS_write, fd, msg, len);\n        syscall(SYS_close, fd);\n    }\n}\nstatic void probe_log_state(const char *stage,\n                            struct metal_condition *cv,\n                            metal_mutex_t *m,\n                            uintptr_t tmpmptr,\n                            uintptr_t mptr,\n                            int v,\n                            long futex_ret)\n{\n    char buf[512];\n    int pos = 0;\n    probe_append_str(buf, &pos, \"[metal_condition_wait] \");\n    probe_append_str(buf, &pos, stage);\n    probe_append_str(buf, &pos, \": cv=\");\n    probe_append_hex(buf, &pos, (unsigned long)cv);\n    probe_append_str(buf, &pos, \" m=\");\n    probe_append_hex(buf, &pos, (unsigned long)m);\n    probe_append_str(buf, &pos, \" mptr=\");\n    probe_append_uint(buf, &pos, (unsigned long)mptr);\n    probe_append_str(buf, &pos, \" tmpmptr=\");\n    probe_append_uint(buf, &pos, (unsigned long)tmpmptr);\n    probe_append_str(buf, &pos, \" wakeups=\");\n    probe_append_uint(buf, &pos, (unsigned long)v);\n    if (futex_ret != 0) {\n        probe_append_str(buf, &pos, \" futex_ret=\");\n        /* futex_ret can be negative, print sign then magnitude */\n        if (futex_ret < 0) {\n            buf[pos++] = '-';\n            probe_append_uint(buf, &pos, (unsigned long)(-futex_ret));\n        } else {\n            probe_append_uint(buf, &pos, (unsigned long)futex_ret);\n        }\n    }\n    buf[pos++] = '\\n';\n    probe_write(buf, (size_t)pos);\n}\n\nint metal_condition_wait(struct metal_condition *cv,\n                       metal_mutex_t *m)\n{\n    uintptr_t tmpmptr = 0, mptr = (uintptr_t)m;\n    int v = 0;\n\n    /* Log entry */\n    probe_log_state(\"ENTER\", cv, m, tmpmptr, mptr, -1, 0);\n\n    /* Check if the mutex has been acquired */\n    if (!cv || !m || !metal_mutex_is_acquired(m)) {\n        probe_log_state(\"EARLY_RETURN_INVALID_ARGS_OR_NOT_ACQUIRED\", cv, m, tmpmptr, mptr, -1, 0);\n        return -EINVAL;\n    }\n\n    if (!atomic_compare_exchange_strong(&cv->mptr, &tmpmptr, mptr)) {\n        /* Log state after failed compare-exchange (tmpmptr has been updated) */\n        probe_log_state(\"CMPXCHG_FAILED\", cv, m, tmpmptr, mptr, -1, 0);\n        if (tmpmptr != mptr) {\n            probe_log_state(\"EARLY_RETURN_MPTR_MISMATCH\", cv, m, tmpmptr, mptr, -1, 0);\n            return -EINVAL;\n        }\n    }\n\n    v = atomic_load(&cv->wakeups);\n    probe_log_state(\"BEFORE_INCREMENT_WAITERS\", cv, m, tmpmptr, mptr, v, 0);\n    atomic_fetch_add(&cv->waiters, 1);\n\n    /* Release the mutex before sleeping. */\n    probe_log_state(\"BEFORE_MUTEX_RELEASE\", cv, m, tmpmptr, mptr, v, 0);\n    metal_mutex_release(m);\n\n    /* Sleep on the futex. Capture return value for logging. */\n    long futex_ret = syscall(SYS_futex, &cv->wakeups, FUTEX_WAIT, v, NULL, NULL, 0);\n    probe_log_state(\"AFTER_FUTEX_WAIT\", cv, m, tmpmptr, mptr, v, futex_ret);\n\n    atomic_fetch_sub(&cv->waiters, 1);\n    /* Acquire the mutex after it's waken up. */\n    probe_log_state(\"BEFORE_MUTEX_ACQUIRE\", cv, m, tmpmptr, mptr, v, futex_ret);\n    metal_mutex_acquire(m);\n    probe_log_state(\"AFTER_MUTEX_ACQUIRE\", cv, m, tmpmptr, mptr, v, futex_ret);\n\n    probe_log_state(\"RETURN_OK\", cv, m, tmpmptr, mptr, v, futex_ret);\n    return 0;\n}\n",
  "explanation": "Added the necessary standard and kernel headers so constants like AT_FDCWD, O_WRONLY, O_CREAT, O_APPEND, SYS_* and FUTEX_WAIT are defined. I also provided a minimal in-file definition of struct metal_condition (with _Atomic members) and a metal_mutex_t type, and declared the external mutex helper functions so the translation unit compiles. No logic of metal_condition_wait was changed \u2014 only supporting declarations and includes were added to fix the compilation errors."
}