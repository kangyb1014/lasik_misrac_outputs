{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_for_each_page_size_down(ps) hides the actual for(;;) clauses. If that macro expands to a well-formed for loop that uses only the loop counter identifier ps in the second clause and only modifies ps in the third clause (for example: for (ps = last_page_size; ps >= first_page_size; --ps)) then Rule 14.2 is satisfied. However, a violation occurs if the macro expansion places function calls or uses other objects in the second or third clauses that have persistent side effects or that reference objects modified in the loop body. Concrete violation example: the macro expands to\n  for (ps = page_size_list_last(); page_size_available(ps); ps = page_size_list_prev(ps))\nwhere page_size_available() has side effects (or reads/writes an object that metal_shmem_try_map() modifies). In that case the second clause has persistent side effects and/or uses objects modified in the body, violating MISRA C 2023 Rule 14.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3e8974e20)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3e9175e20)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3e9976e20)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3ea177e20)\nafter metal_shmem_open_generic: error=-2\nafter metal_shmem_open_generic: error=-2\nafter metal_shmem_open_generic: error=-2\nafter metal_shmem_open_generic: error=-2\nafter metal_open: return=6\nafter metal_open: return=7\nafter metal_open: return=8\nafter metal_open: return=9\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3eb179e20)\nshmem fd=6\nshmem fd=7\nshmem fd=8\nshmem fd=9\nBEGIN: iterate page sizes (fd=6, size=1048576)\nafter metal_shmem_open_generic: error=-2\nBEGIN: iterate page sizes (fd=8, size=1048576)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3ea978e20)\nBEGIN: iterate page sizes (fd=9, size=1048576)\nBEGIN: iterate page sizes (fd=7, size=1048576)\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: ps=0x55c383a16800 page_size=4096\nafter metal_open: return=10\nafter metal_shmem_open_generic: error=-2\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=6, size=1048576, result=0x7fb3e9175e20)\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=8, size=1048576, result=0x7fb3e9976e20)\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=9, size=1048576, result=0x7fb3ea177e20)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3d3ffee20)\nshmem fd=10\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=7, size=1048576, result=0x7fb3e8974e20)\nafter metal_open: return=11\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3d37fde20)\nBEGIN: iterate page sizes (fd=10, size=1048576)\nafter metal_shmem_open_generic: error=-2\nshmem fd=11\niter 1: ps=0x55c383a16800 page_size=4096\nafter metal_shmem_open_generic: error=-2\nBEGIN: iterate page sizes (fd=11, size=1048576)\nafter metal_open: return=15\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=10, size=1048576, result=0x7fb3eb179e20)\niter 1: ps=0x55c383a16800 page_size=4096\nshmem fd=15\nafter metal_open: return=13\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=11, size=1048576, result=0x7fb3ea978e20)\nBEGIN: iterate page sizes (fd=15, size=1048576)\nshmem fd=13\niter 1: ps=0x55c383a16800 page_size=4096\nBEGIN: iterate page sizes (fd=13, size=1048576)\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=15, size=1048576, result=0x7fb3d3ffee20)\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=13, size=1048576, result=0x7fb3d37fde20)\niter 1: metal_shmem_try_map returned 0\niter 1: mapping succeeded, breaking out of loop\nEND: finished iteration, closing fd=9, final error=0\nRETURN: 0\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3d2ffce20)\nafter metal_shmem_open_generic: error=-2\nafter metal_open: return=9\nshmem fd=9\nBEGIN: iterate page sizes (fd=9, size=1048576)\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=9, size=1048576, result=0x7fb3d2ffce20)\nENTER: metal_shmem_open(name=/foo, size=1048576, result=0x7fb3d27fbe20)\niter 1: metal_shmem_try_map returned 0\nafter metal_shmem_open_generic: error=-2\niter 1: mapping succeeded, breaking out of loop\nafter metal_open: return=12\nEND: finished iteration, closing fd=6, final error=0\nshmem fd=12\nRETURN: 0\nBEGIN: iterate page sizes (fd=12, size=1048576)\niter 1: ps=0x55c383a16800 page_size=4096\niter 1: calling metal_shmem_try_map(ps=0x55c383a16800, fd=12, size=1048576, result=0x7fb3d27fbe20)\niter 1: metal_shmem_try_map returned 0\niter 1: mapping succeeded, breaking out of loop\nEND: finished iteration, closing fd=15, final error=0\nRETURN: 0\niter 1: metal_shmem_try_map returned 0\niter 1: mapping succeeded, breaking out of loop\nEND: finished iteration, closing fd=13, final error=0\nRETURN: 0\niter 1: metal_shmem_try_map returned 0\niter 1: mapping succeeded, breaking out of loop\nEND: finished ite\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\nint metal_map(int fd, off_t offset, size_t size, int expand, int flags,\n\t      void **result)\n{\n\tint prot = PROT_READ | PROT_WRITE, error;\n\tvoid *mem;\n\n\tflags |= MAP_SHARED;\n\n\tif (fd < 0) {\n\t\tfd = -1;\n\t\tflags = MAP_PRIVATE | MAP_ANONYMOUS;\n\t} else if (expand) {\n\t\toff_t reqsize = offset + size;\n\t\tstruct stat stat;\n\n\t\terror = flock(fd, LOCK_EX) < 0 ? -errno : 0;\n\t\tif (!error)\n\t\t\terror = fstat(fd, &stat);\n\t\tif (!error && stat.st_size < reqsize)\n\t\t\terror = ftruncate(fd, reqsize);\n\t\tif (!error)\n\t\t\tflock(fd, LOCK_UN);\n\t\tif (error)\n\t\t\treturn -errno;\n\t}\n\n\tmem = mmap(NULL, size, prot, flags, fd, offset);\n\tif (mem == MAP_FAILED)\n\t\treturn -errno;\n\t*result = mem;\n\treturn 0;\n}\n...\nint metal_unmap(void *mem, size_t size)\n{\n\treturn munmap(mem, size) < 0 ? -errno : 0;\n}\n...\nvoid metal_io_init(struct metal_io_region *io, void *virt,\n\t      const metal_phys_addr_t *physmap, size_t size,\n\t      unsigned int page_shift, unsigned int mem_flags,\n\t      const struct metal_io_ops *ops)\n{\n\tconst struct metal_io_ops nops = {\n\t\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n\t};\n\n\tio->virt = virt;\n\tio->physmap = physmap;\n\tio->size = size;\n\tio->page_shift = page_shift;\n\tif (page_shift >= sizeof(io->page_mask) * CHAR_BIT)\n\t\t/* avoid overflow */\n\t\tio->page_mask = -1UL;\n\telse\n\t\tio->page_mask = (1UL << page_shift) - 1UL;\n\tio->mem_flags = mem_flags;\n\tio->ops = ops ? *ops : nops;\n\tmetal_sys_io_mem_map(io);\n}\n...\nstatic int metal_virt2phys(void *addr, unsigned long *phys)\n{\n\toff_t offset;\n\tuint64_t entry;\n\tint error;\n\n\tif (_metal.pagemap_fd < 0)\n\t\treturn -EINVAL;\n\n\toffset = ((uintptr_t)addr >> _metal.page_shift) * sizeof(entry);\n\terror = pread(_metal.pagemap_fd, &entry, sizeof(entry), offset);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed pagemap pread (offset %llx) - %s\\n\",\n\t\t\t  (unsigned long long)offset, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\t/* Check page present and not swapped. */\n\tif ((entry >> 62) != 2) {\n\t\tmetal_log(METAL_LOG_ERROR, \"pagemap page not present, %llx -> %llx\\n\",\n\t\t\t  (unsigned long long)offset, (unsigned long long)entry);\n\t\treturn -ENOENT;\n\t}\n\n\t*phys = (entry & ((1ULL << 54) - 1)) << _metal.page_shift;\n\treturn 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "I cannot confirm the reported MISRA 14.2 violation from the code shown. The for loop in the source is hidden behind the macro metal_for_each_page_size_down(ps), and whether Rule 14.2 is violated depends entirely on how that macro expands. If the macro expands to a simple well-formed for loop that uses only the loop counter identifier ps in the loop-test and only modifies ps in the iteration-expression (for example: for (ps = last; ps >= first; --ps)), then the loop meets Rule 14.2. The violation scenario described by agent A (an expansion such as for (ps = page_size_list_last(); page_size_available(ps); ps = page_size_list_prev(ps)) where page_size_available() has persistent side effects or reads/writes objects that the loop body modifies) would indeed violate Rule 14.2, but that is only a possible expansion, not shown in the provided sources.\n\nTherefore the agent A report is not proven correct on the basis of the provided code and logs. To decide definitively you must examine the actual definition/expansion of metal_for_each_page_size_down and ensure the second clause has no persistent side effects and does not reference objects modified in the loop body, and the third clause modifies only the loop counter. If the macro uses function calls with side effects or tests objects modified in the body, that would be a MISRA 14.2 violation and should be fixed (e.g. evaluate side-effecting expressions outside the for header, use a single identifier loop counter, or rewrite the iteration explicitly)."
}