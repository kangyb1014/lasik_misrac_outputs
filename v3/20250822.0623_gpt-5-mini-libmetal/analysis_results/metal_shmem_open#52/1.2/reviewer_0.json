{
  "user_message": "An agent A claimed that the following metal_shmem_open code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of metal_shmem_open.\n```c\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro metal_log uses GCC/clang statement-expressions (the '({ ... })' construct) and also uses the GNU variadic-macro comma-swallowing extension ('##__VA_ARGS__'). Both constructs are documented compiler-specific extensions and therefore violate MISRA C 2023 Rule 1.2 (language extensions should not be used).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae97ffee20\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae96ffce20\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae977fde20\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae9cdd7e20\n[after_generic] metal_shmem_open_generic returned -2\n[after_generic] metal_shmem_open_generic returned -2\n[after_generic] metal_shmem_open_generic returned -2\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae9ddd9e20\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae9d5d8e20\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae967fbe20\n[after_generic] metal_shmem_open_generic returned -2\n[after_metal_open] metal_open('/foo',1) returned 9\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae957f9e20\n[after_metal_open] metal_open('/foo',1) returned 7\n[after_metal_open] metal_open('/foo',1) returned 8\n[after_generic] metal_shmem_open_generic returned -2\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae95ffae20\n[after_generic] metal_shmem_open_generic returned -2\n[after_generic] metal_shmem_open_generic returned -2\n[fd_obtained] opened fd=9\n[after_metal_open] metal_open('/foo',1) returned 6\n[fd_obtained] opened fd=7\n[after_generic] metal_shmem_open_generic returned -2\n[fd_obtained] opened fd=8\n[enter] metal_shmem_open name='/foo' size=1048576 result_ptr=0x7fae94ff8e20\n[after_metal_open] metal_open('/foo',1) returned 11\n[after_generic] metal_shmem_open_generic returned -2\n[after_metal_open] metal_open('/foo',1) returned 20\n[page_iter] considering page_size=4096 for requested size=1048576\n[after_metal_open] metal_open('/foo',1) returned 12\n[fd_obtained] opened fd=6\n[page_iter] considering page_size=4096 for requested size=1048576\n[after_metal_open] metal_open('/foo',1) returned 13\n[page_iter] considering page_size=4096 for requested size=1048576\n[after_generic] metal_shmem_open_generic returned -2\n[fd_obtained] opened fd=20\n[fd_obtained] opened fd=11\n[fd_obtained] opened fd=12\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=9 size=1048576\n[page_iter] considering page_size=4096 for requested size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=7 size=1048576\n[after_metal_open] metal_open('/foo',1) returned 16\n[fd_obtained] opened fd=13\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=8 size=1048576\n[page_iter] considering page_size=4096 for requested size=1048576\n[after_metal_open] metal_open('/foo',1) returned 10\n[page_iter] considering page_size=4096 for requested size=1048576\n[page_iter] considering page_size=4096 for requested size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=6 size=1048576\n[fd_obtained] opened fd=16\n[page_iter] considering page_size=4096 for requested size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=20 size=1048576\n[fd_obtained] opened fd=10\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=11 size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=12 size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=13 size=1048576\n[page_iter] considering page_size=4096 for requested size=1048576\n[page_iter] considering page_size=4096 for requested size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=10 size=1048576\n[try_map] attempting metal_shmem_try_map with page_size=4096 fd=16 size=1048576\n[try_map_result] metal_shmem_try_map returned 0 result_region_ptr=0x7fae84001560\n[map_success] mapping succeeded with page_size=4096, breaking loop\n[done] closed fd=20 final_error=0\n[try_map_result] metal_shmem_try_map returned 0 result_region_ptr=0x7fae90001560\n[map_success] mapping succeeded with page_size=4096, breaking loop\n[done] closed fd=9 final_error=0\n[try_map_result] metal_shmem_try_map returned 0 result_region_ptr=0x7fae70001560\n[map_success] mapping succeeded with page_size=4096, breaking loop\n[done] closed fd=16 final_error=0\n[try_map_result] metal_\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_shmem_open:\n#define metal_for_each_page_size_down(ps) for((ps)=&_metal.page_sizes[_metal.num_page_sizes-1];(ps)>=&_metal.page_sizes[0];(ps)--)\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstruct metal_page_size {\n\t/** Page size. */\n\tsize_t\tpage_size;\n\n\t/** Page shift. */\n\tunsigned long page_shift;\n\n\t/** Path to hugetlbfs (or tmpfs) mount point. */\n\tchar path[PATH_MAX];\n\n\t/** Flags to use for mmap. */\n\tint mmap_flags;\n}\n...\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The metal_log macro expands to two compiler-specific language extensions: (1) a GCC/Clang statement-expression using the '({ ... })' construct, and (2) the GNU variadic-macro comma\u2011swallowing extension '##__VA_ARGS__'. Both constructs are documented as compiler extensions (they are not part of ISO C) and therefore violate MISRA C 2023 Rule 1.2. Because metal_shmem_open invokes metal_log, the function's translation unit will contain those extensions after macro expansion and thus the report of a Rule 1.2 violation is valid (unless an accepted project deviation or a documented, permitted compiler extension policy is in place)."
}