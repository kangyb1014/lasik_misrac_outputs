{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of metal_io_block_set:\n```c\nint metal_io_block_set(struct metal_io_region *io, unsigned long offset,\n\t       unsigned char value, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tint retlen = len;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_set) {\n\t\t(*io->ops.block_set)(\n\t\t\tio, offset, value, memory_order_seq_cst, len);\n\t} else {\n\t\tunsigned int cint = value;\n\t\tunsigned int i;\n\n\t\tfor (i = 1; i < sizeof(int); i++)\n\t\t\tcint |= ((unsigned int)value << (CHAR_BIT * i));\n\n\t\tfor (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = cint;\n\t\tfor (; len != 0; ptr++, len--)\n\t\t\t*(unsigned char *)ptr = (unsigned char) value;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function metal_io_block_set:\nint metal_io_block_read(struct metal_io_region *io, unsigned long offset,\n\t       void *restrict dst, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tunsigned char *dest = dst;\n\tint retlen;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_read) {\n\t\tretlen = (*io->ops.block_read)(\n\t\t\tio, offset, dst, memory_order_seq_cst, len);\n\t} else {\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t\twhile ( len && (\n\t\t\t((uintptr_t)dest % sizeof(int)) ||\n\t\t\t((uintptr_t)ptr % sizeof(int)))) {\n\t\t\t*(unsigned char *)dest =\n\t\t\t\t*(const unsigned char *)ptr;\n\t\t\tdest++;\n\t\t\tptr++;\n\t\t\tlen--;\n\t\t}\n\t\tfor (; len >= (int)sizeof(int); dest += sizeof(int),\n\t\t\t\t\tptr += sizeof(int),\n\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)dest = *(const unsigned int *)ptr;\n\t\tfor (; len != 0; dest++, ptr++, len--)\n\t\t\t*(unsigned char *)dest =\n\t\t\t\t*(const unsigned char *)ptr;\n\t}\n\treturn retlen;\n}\n...\nint metal_io_block_write(struct metal_io_region *io, unsigned long offset,\n\t       const void *restrict src, int len)\n{\n\tunsigned char *ptr = metal_io_virt(io, offset);\n\tconst unsigned char *source = src;\n\tint retlen;\n\n\tif (!ptr)\n\t\treturn -ERANGE;\n\tif ((offset + len) > io->size)\n\t\tlen = io->size - offset;\n\tretlen = len;\n\tif (io->ops.block_write) {\n\t\tretlen = (*io->ops.block_write)(\n\t\t\tio, offset, src, memory_order_seq_cst, len);\n\t} else {\n\t\twhile ( len && (\n\t\t\t((uintptr_t)ptr % sizeof(int)) ||\n\t\t\t((uintptr_t)source % sizeof(int)))) {\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\t\tptr++;\n\t\t\tsource++;\n\t\t\tlen--;\n\t\t}\n\t\tfor (; len >= (int)sizeof(int); ptr += sizeof(int),\n\t\t\t\t\tsource += sizeof(int),\n\t\t\t\t\tlen -= sizeof(int))\n\t\t\t*(unsigned int *)ptr = *(const unsigned int *)source;\n\t\tfor (; len != 0; ptr++, source++, len--)\n\t\t\t*(unsigned char *)ptr =\n\t\t\t\t*(const unsigned char *)source;\n\t\tatomic_thread_fence(memory_order_seq_cst);\n\t}\n\treturn retlen;\n}\n...\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (io->ops.block_read) {\n\t\tretlen = (*io->ops.block_read)(\n\t\t\t\tio, offset, dst, memory_order_seq_cst, len);\n\t\t}\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "If the function pointer io->ops.block_read is (or can be) initialized to point to metal_io_block_read (for example: io->ops.block_read = metal_io_block_read), then the call retlen = (*io->ops.block_read)(...) inside metal_io_block_read will invoke metal_io_block_read again, creating indirect recursion (infinite re-entry). This situation would violate MISRA C 2023 Rule 17.2."
}