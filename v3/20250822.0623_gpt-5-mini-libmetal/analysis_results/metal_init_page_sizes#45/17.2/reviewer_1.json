{
  "user_message": "An agent A claimed that the following metal_init_page_sizes code violates the MISRA C 2023 rule 17.2.\n<misra_rule>\nMISRA C 2023 Rule 17.2 is Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<target_code>\nHere is the original code of metal_init_page_sizes.\n```c\nstatic int metal_init_page_sizes(void)\n{\n\tconst int max_sizes = MAX_PAGE_SIZES - 1;\n\tlong sizes[max_sizes];\n\n\t/* Determine system page size. */\n\tsizes[0] = getpagesize();\n\tif (sizes[0] <= 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"failed to get page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_metal.page_size  = sizes[0];\n\t_metal.page_shift = metal_log2(sizes[0]);\n\tmetal_add_page_size(_metal.tmp_path, _metal.page_shift, 0);\n\n#ifdef HAVE_HUGETLBFS_H\n#ifndef MAP_HUGE_SHIFT\n\t/* System does not support multiple huge page sizes. */\n\tsizes[0] = gethugepagesize();\n\tif (sizes[0] > 0) {\n\t\tmetal_add_page_size(hugetlbfs_find_path(),\n\t\t\t\t    metal_log2(sizes[0]),\n\t\t\t\t    MAP_HUGETLB);\n\t}\n#else\n\tif (gethugepagesize() >= 0) {\n\t\tint i, count;\n\n\t\t/* System supports multiple huge page sizes. */\n\t\tcount = gethugepagesizes(sizes, max_sizes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint shift = metal_log2(sizes[i]);\n\n\t\t\tif ((shift & MAP_HUGE_MASK) != shift)\n\t\t\t\tcontinue;\n\t\t\tmetal_add_page_size(\n\t\t\t\thugetlbfs_find_path_for_size(sizes[i]),\n\t\t\t\tshift, (MAP_HUGETLB |\n\t\t\t\t(shift << MAP_HUGE_SHIFT)));\n\t\t}\n\t}\n#endif\n#endif\n\n\t/* Finally sort the resulting array by size. */\n\tqsort(_metal.page_sizes, _metal.num_page_sizes,\n\t      sizeof(struct metal_page_size), metal_pagesize_compare);\n\n\treturn 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro expands to a call to _metal.common.log_handler(...). If that log handler (or any function it calls) invokes metal_log (directly or indirectly), an indirect recursive call chain is created. Example: setting _metal.common.log_handler = my_log_handler where my_log_handler(...) calls metal_log(...) -> log_handler -> my_log_handler ... leads to infinite recursion and thus violates MISRA C 2023 Rule 17.2.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nENTER: metal_init_page_sizes\ngetpagesize() -> 4096\n_metal.page_size = 4096, _metal.page_shift = 12\ncalling metal_add_page_size(tmp_path=0x7f123be9ec38, shift=12, flags=0)\ngethugepagesizes() -> count = 2\nhuge size[0] = 2097152, shift = 21\ncalling metal_add_page_size(hugetlbfs_find_path_for_size(2097152), 21, flags=MAP_HUGETLB|(21<<MAP_HUGE_SHIFT))\nhuge size[1] = 1073741824, shift = 30\ncalling metal_add_page_size(hugetlbfs_find_path_for_size(1073741824), 30, flags=MAP_HUGETLB|(30<<MAP_HUGE_SHIFT))\nabout to qsort: _metal.num_page_sizes = 1\nqsort completed\nEXIT: metal_init_page_sizes -> 0\nENTER: metal_init_page_sizes\ngetpagesize() -> 4096\n_metal.page_size = 4096, _metal.page_shift = 12\ncalling metal_add_page_size(tmp_path=0x55ec143f5c00, shift=12, flags=0)\ngethugepagesizes() -> count = 2\nhuge size[0] = 2097152, shift = 21\ncalling metal_add_page_size(hugetlbfs_find_path_for_size(2097152), 21, flags=MAP_HUGETLB|(21<<MAP_HUGE_SHIFT))\nhuge size[1] = 1073741824, shift = 30\ncalling metal_add_page_size(hugetlbfs_find_path_for_size(1073741824), 30, flags=MAP_HUGETLB|(30<<MAP_HUGE_SHIFT))\nabout to qsort: _metal.num_page_sizes = 1\nqsort completed\nEXIT: metal_init_page_sizes -> 0\n\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function metal_init_page_sizes:\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic int metal_add_page_size(const char *path, int shift, int mmap_flags)\n{\n\tint index = _metal.num_page_sizes;\n\tunsigned long size = 1UL << shift;\n\n\tif (index >= MAX_PAGE_SIZES) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - overflow\\n\",\n\t\t\t  size);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (!path || shift <= 0) {\n\t\tmetal_log(METAL_LOG_WARNING, \"skipped page size %ld - invalid args\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\t_metal.page_sizes[index].page_shift = shift;\n\t_metal.page_sizes[index].page_size = size;\n\t_metal.page_sizes[index].mmap_flags = mmap_flags;\n\tstrncpy(_metal.page_sizes[index].path, path, PATH_MAX);\n\t_metal.num_page_sizes++;\n\n\tmetal_log(METAL_LOG_DEBUG, \"added page size %ld @%s\\n\", size, path);\n\n\treturn 0;\n}\n...\nstatic int metal_pagesize_compare(const void *_a, const void *_b)\n{\n\tconst struct metal_page_size *a = _a, *b = _b;\n\tlong diff = a->page_size - b->page_size;\n\n\treturn metal_sign(diff);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 17.2 prohibits functions calling themselves (directly or indirectly). In the provided code metal_init_page_sizes calls metal_add_page_size and that calls the metal_log macro which in turn invokes a user-supplied _metal.common.log_handler function pointer. A user-supplied log handler that calls metal_log (or any function that calls back into the same handler) can produce an infinite recursion between the log handler and the logging call site. That would make the logging functions (and the handler) part of a recursive cycle, not metal_init_page_sizes itself. metal_init_page_sizes is not shown to call itself, nor is there any static call chain in the provided code that returns to metal_init_page_sizes. Also metal_log is a macro expanding to a call through a function pointer; the potential recursion depends on client-supplied code assigning a handler that calls back \u2014 a runtime misuse, not an intrinsic static indirect recursive call of metal_init_page_sizes. Therefore the claim that metal_init_page_sizes violates MISRA C 2023 Rule 17.2 is incorrect."
}