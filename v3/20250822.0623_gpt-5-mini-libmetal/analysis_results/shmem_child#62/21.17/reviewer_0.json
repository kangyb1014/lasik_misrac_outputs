{
  "user_message": "An agent A claimed that the following shmem_child code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of shmem_child.\n```c\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strcmp(shmem->name, name) occurs without validating that 'name' is non-NULL and NUL\u2011terminated. If metal_shmem_open_generic() is invoked with name == NULL (or with a non\u2011terminated buffer), strcmp will dereference/read past the bounds of the object referenced by its pointer parameter, violating Rule 21.17. Note: the expression '!path || !strlen(path)' in metal_open is safe for a NULL path due to short\u2011circuit evaluation, but strlen(path) will still read out of bounds if a non\u2011NULL path is not NUL\u2011terminated.\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: metal_shmem_open returned 0, io=0x7f2e8c002570\nshmem_child: virt=0x7f2ea182a000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: metal_shmem_open returned 0, io=0x7f2e88002570\nshmem_child: virt=0x7f2ea0e29000 phys=0\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: metal_shmem_open returned 0, io=0x7f2e84002570\nshmem_child: virt=0x7f2ea182a000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: finished, returning NULL\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: entering, name_ptr=0x559821bc73f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x559821bc73f7, size=1048576)\nshmem_child: metal_shmem_open returned 0, io=0x7f2e880025f0\nshmem_child: virt=0x7f2ea182a000 phys=0\nshmem_child: metal_shmem_open returned 0, io=0x7f2e840025f0\nshmem_child: virt=0x7f2ea0428000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: finished, returning NULL\nshmem_child: metal_shmem_open returned 0, io=0x7f2e8c0025f0\nshmem_child: virt=0x7f2ea0f29000 phys=0\nshmem_child: metal_shmem_open returned 0, io=0x7f2e94002570\nshmem_child: virt=0x7f2ea1a2a000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: finished, returning NULL\nshmem_child: metal_shmem_open returned 0, io=0x7f2e7c002570\nshmem_child: virt=0x7f2ea0e29000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: metal_shmem_open returned 0, io=0x7f2e90002570\nshmem_child: virt=0x7f2ea192a000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: metal_shmem_open returned 0, io=0x7f2e74002570\nshmem_child: virt=0x7f2ea0528000 phys=0\nshmem_child: finished, returning NULL\nshmem_child: entering, name_ptr=0x55fbca43d3f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x55fbca43d3f7, size=1048576)\nshmem_child: entering, name_ptr=0x55fbca43d3f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x55fbca43d3f7, size=1048576)\nshmem_child: entering, name_ptr=0x55fbca43d3f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x55fbca43d3f7, size=1048576)\nshmem_child: entering, name_ptr=0x55fbca43d3f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x55fbca43d3f7, size=1048576)\nshmem_child: entering, name_ptr=0x55fbca43d3f7\nshmem_child: name is non-NULL (not dereferenced)\nshmem_child: about to call metal_shmem_open(name_ptr=0x55fbca43d3f7, size=1048576)\nshmem_child: metal_shmem_open r\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function shmem_child:\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n...\nint metal_shmem_open_generic(const char *name, size_t size,\n\t\t\t     struct metal_io_region **result)\n{\n\tstruct metal_generic_shmem *shmem;\n\tstruct metal_list *node;\n\n\tmetal_list_for_each(&_metal.common.generic_shmem_list, node) {\n\t\tshmem = metal_container_of(node, struct metal_generic_shmem, node);\n\t\tif (strcmp(shmem->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (size <= metal_io_region_size(&shmem->io)) {\n\t\t\t*result = &shmem->io;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n...\nint metal_open(const char *path, int shm)\n{\n\tconst int flags = O_RDWR | O_CREAT | O_CLOEXEC;\n\tconst int mode = S_IRUSR | S_IWUSR;\n\tint fd;\n\n\tif (!path || !strlen(path))\n\t\treturn -EINVAL;\n\n\tfd = shm ? shm_open(path, flags, mode) : open(path, flags, mode);\n\treturn fd < 0 ? -errno : fd;\n}\n...\nstatic int metal_shmem_try_map(struct metal_page_size *ps, int fd, size_t size,\n\t\t\t       struct metal_io_region **result)\n{\n\tsize_t pages, page, phys_size;\n\tstruct metal_io_region *io;\n\tmetal_phys_addr_t *phys;\n\tuint8_t *virt;\n\tvoid *mem;\n\tint error;\n\n\tsize = metal_align_up(size, ps->page_size);\n\tpages = size / ps->page_size;\n\n\terror = metal_map(fd, 0, size, 1, ps->mmap_flags, &mem);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\t  \"failed to mmap shmem %ld,0x%x - %s\\n\",\n\t\t\t  size, ps->mmap_flags, strerror(-error));\n\t\treturn error;\n\t}\n\n\terror = mlock(mem, size);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_WARNING, \"failed to mlock shmem - %s\\n\",\n\t\t\t  strerror(errno));\n\t}\n\n\tphys_size = sizeof(*phys) * pages;\n\tphys = malloc(phys_size);\n\tif (!phys) {\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tio = malloc(sizeof(*io));\n\tif (!io) {\n\t\tfree(phys);\n\t\tmetal_unmap(mem, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (_metal.pagemap_fd < 0) {\n\t\tphys[0] = 0;\n\t\tmetal_log(METAL_LOG_WARNING,\n\t\t\"shmem - failed to get va2pa mapping. use offset as pa.\\n\");\n\t\tmetal_io_init(io, mem, phys, size, -1, 0, &metal_shmem_io_ops);\n\t} else {\n\t\tfor (virt = mem, page = 0; page < pages; page++) {\n\t\t\tsize_t offset = page * ps->page_size;\n\n\t\t\terror = metal_virt2phys(virt + offset, &phys[page]);\n\t\t\tif (error < 0)\n\t\t\t\tphys[page] = METAL_BAD_OFFSET;\n\t\t}\n\t\tmetal_io_init(io, mem, phys, size, ps->page_shift, 0,\n\t\t\t&metal_shmem_io_ops);\n\t}\n\t*result = io;\n\n\treturn 0;\n}\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\n#define METAL_BAD_OFFSET ((unsignedlong)-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The code path is: shmem_child takes arg as const char *name without validation and passes it to metal_shmem_open(); that function calls metal_shmem_open_generic(name, ...), which unconditionally calls strcmp(shmem->name, name). If name is NULL (or points to a buffer that is not NUL\u2011terminated), strcmp will dereference/read beyond the bounds of the object referenced by the name pointer, violating MISRA C 2023 Rule 21.17. The later check in metal_open (!path || !strlen(path)) does not prevent the unsafe strcmp call because metal_open is invoked only after metal_shmem_open_generic returns (i.e. the unsafe strcmp happens before metal_open would be reached). The runtime log only shows well\u2011formed, non\u2011NULL names in the tested runs, but that does not remove the potential out\u2011of\u2011bounds access in the code. Therefore the report of a Rule 21.17 violation is correct."
}