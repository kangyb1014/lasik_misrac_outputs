{
  "user_message": "An agent A claimed that the following shmem_child code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of shmem_child.\n```c\nstatic void *shmem_child(void *arg)\n{\n\tconst char *name = arg;\n\tstruct {\n\t\tmetal_mutex_t\tmutex;\n\t\tint\t\t\tcounter;\n\t} *virt;\n\tstruct metal_io_region *io;\n\tunsigned long phys;\n\tsize_t size = 1 * 1024 * 1024;\n\tint error;\n\n\terror = metal_shmem_open(name, size, &io);\n\tif (error) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed shmem_open: %d.\\n\", error);\n\t\tatomic_fetch_add(&nb_err, 1);\n\t\treturn NULL;\n\t}\n\n\tvirt = metal_io_virt(io, 0);\n\tphys = metal_io_phys(io, 0);\n\tif (phys != METAL_BAD_OFFSET) {\n\t\tif (virt != metal_io_phys_to_virt(io, phys)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed virt != phys.\\n\");\n\t\t}\n\t\tif (phys != metal_io_virt_to_phys(io, virt)) {\n\t\t\tatomic_fetch_add(&nb_err, 1);\n\t\t\tmetal_log(METAL_LOG_ERROR, \"Failed phys != virt.\\n\");\n\t\t}\n\t}\n\n\tmetal_io_finish(io);\n\treturn NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses GCC-specific extensions: a statement-expression construct '({ ... })' and the token-pasting/comma\u2011elision '##__VA_ARGS__' GCC extension in the variadic macro. Both are documented compiler extensions (GCC) and therefore violate MISRA C 2023 Rule 1.2 (no language extensions).\n</scenario>\n\n<execution_log>\nThe agent A also provided the following output log:\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nshmem_child: entry name=/foo, size=1048576\nmetal_shmem_open returned error=0, io=0x7fd4e8001560\nafter mapping: io=0x7fd4e8001560, virt=0x7fd4f4092000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nshmem_child: entry name=/foo, size=1048576\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4e8001560)\nmetal_io_finish returned, shmem_child returning NULL\nshmem_child: entry name=/foo, size=1048576\nmetal_shmem_open returned error=0, io=0x7fd4cc001560\nafter mapping: io=0x7fd4cc001560, virt=0x7fd4f4092000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4cc001560)\nmetal_io_finish returned, shmem_child returning NULL\nshmem_child: entry name=/foo, size=1048576\nmetal_shmem_open returned error=0, io=0x7fd4d4001560\nafter mapping: io=0x7fd4d4001560, virt=0x7fd4ef3ff000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4d4001560)\nmetal_io_finish returned, shmem_child returning NULL\nmetal_shmem_open returned error=0, io=0x7fd4d8001560\nafter mapping: io=0x7fd4d8001560, virt=0x7fd4eff00000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nmetal_shmem_open returned error=0, io=0x7fd4c8001560\nCalling metal_io_finish(io=0x7fd4d8001560)\nafter mapping: io=0x7fd4c8001560, virt=0x7fd4eeafe000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4c8001560)\nmetal_shmem_open returned error=0, io=0x7fd4c0001560\nafter mapping: io=0x7fd4c0001560, virt=0x7fd4f4092000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4c0001560)\nmetal_io_finish returned, shmem_child returning NULL\nmetal_io_finish returned, shmem_child returning NULL\nmetal_shmem_open returned error=0, io=0x7fd4dc001560\nafter mapping: io=0x7fd4dc001560, virt=0x7fd4ef4ff000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nmetal_io_finish returned, shmem_child returning NULL\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4dc001560)\nmetal_io_finish returned, shmem_child returning NULL\nmetal_shmem_open returned error=0, io=0x7fd4d0001560\nafter mapping: io=0x7fd4d0001560, virt=0x7fd4ef5ff000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nCalling metal_io_finish(io=0x7fd4d0001560)\nmetal_shmem_open returned error=0, io=0x7fd4e4001560\nafter mapping: io=0x7fd4e4001560, virt=0x7fd4f4192000, phys=0x0\nphys != METAL_BAD_OFFSET (phys=0x0). Performing consistency checks.\nconsistency check passed: virt == metal_io_phys_to_virt(io, phys)\nconsistency check passed: phys == metal_io_virt_to_phys(io, virt)\nmetal_io_finish returned, shmem_child returning NULL\nCalling metal_io_finish(io=0x7fd4e4001560)\nme\n</execution_log>\n<additional code>Here are the definitions of symbols that are close to the target function shmem_child:\ntypedef struct {\n\tatomic_int v;\n} metal_mutex_t\n...\nstruct metal_io_region {\n\tvoid\t\t\t*virt;      /**< base virtual address */\n\tconst metal_phys_addr_t\t*physmap;   /**< table of base physical address\n\t\t\t\t\t\t of each of the pages in the I/O\n\t\t\t\t\t\t region */\n\tsize_t\t\t\tsize;       /**< size of the I/O region */\n\tunsigned long\t\tpage_shift; /**< page shift of I/O region */\n\tmetal_phys_addr_t\tpage_mask;  /**< page mask of I/O region */\n\tunsigned int\t\tmem_flags;  /**< memory attribute of the\n\t\t\t\t\t\t I/O region */\n\tstruct metal_io_ops\tops;        /**< I/O region operations */\n}\n...\n#define METAL_BAD_OFFSET ((unsignedlong)-1)\n...\nint metal_shmem_open(const char *name, size_t size,\n\t\t     struct metal_io_region **result)\n{\n\tstruct metal_page_size *ps;\n\tint fd, error;\n\n\terror = metal_shmem_open_generic(name, size, result);\n\tif (!error)\n\t\treturn error;\n\n\terror = metal_open(name, 1);\n\tif (error < 0) {\n\t\tmetal_log(METAL_LOG_ERROR, \"Failed to open shmem file :%s\\n\", name);\n\t\treturn error;\n\t}\n\tfd = error;\n\n\t/* Iterate through page sizes in decreasing order. */\n\tmetal_for_each_page_size_down(ps) {\n\t\tif (ps->page_size > 2 * size)\n\t\t\tcontinue;\n\t\terror = metal_shmem_try_map(ps, fd, size, result);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tclose(fd);\n\treturn error;\n}\n...\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__);\\\n})\n...\nstatic atomic_int nb_err = ATOMIC_VAR_INIT(0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The provided additional code shows the macro definition\n\n#define metal_log(level, fmt, __VA_ARGS__) ({if(_metal.common.log_handler&&level<=_metal.common.log_level)_metal.common.log_handler(level,metal_fmt(fmt),##__VA_ARGS__;\\\n})\n\nwhich uses two GNU extensions: the statement-expression construct ({ ... }) and the token-pasting/comma-elision form ##__VA_ARGS__. Both are documented GCC extensions (not standard ISO C) and therefore constitute use of language/compiler extensions. The shmem_child function calls metal_log, so the translation unit uses those non\u2011standard extensions and thus violates MISRA C 2023 Rule 1.2."
}